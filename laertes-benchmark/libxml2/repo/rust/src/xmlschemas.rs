
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type _xmlBuf;
    /*
 * Summary: string dictionary
 * Description: dictionary of reusable strings, just used to avoid allocation
 *         and freeing operations.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * The dictionary.
 */
    pub type _xmlDict;
    pub type _xmlHashTable;
    pub type _xmlAutomataState;
    pub type _xmlAutomata;
    pub type _xmlValidState;
    /*
 * Summary: regular expressions handling
 * Description: basic API for libxml regular expressions handling used
 *              for XML Schemas and validation.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlRegexpPtr:
 *
 * A libxml regular expression, they can actually be far more complex
 * thank the POSIX regex expressions.
 */
    pub type _xmlRegexp;
    /* *
 * xmlRegExecCtxtPtr:
 *
 * A libxml progressive regular expression evaluation context
 */
    pub type _xmlRegExecCtxt;
    pub type _xmlRelaxNG;
    pub type _xmlRelaxNGValidCtxt;
    pub type _xmlSchemaVal;
    pub type _xmlPattern;
    pub type _xmlXIncludeCtxt;
    pub type _xmlStreamCtxt;
    /*
 * Summary: set of routines to process strings
 * Description: type and interfaces needed for the internal string handling
 *              of the library, especially UTF8 processing.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlChar:
 *
 * This is a basic byte in an UTF-8 encoded string.
 * It's unsigned allowing to pinpoint case where char * are assigned
 * to xmlChar * (possibly making serialization back impossible).
 */
    /* *
 * BAD_CAST:
 *
 * Macro to cast a string to an xmlChar * when one know its safe.
 */
    /*
 * xmlChar handling
 */
    #[no_mangle]
    fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlEscapeFormatString(msg: *mut *mut xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCharStrdup(cur: *const std::os::raw::c_char) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrndup(cur: *const xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn snprintf(_: *mut std::os::raw::c_char, _: std::os::raw::c_ulong,
                _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrlen(str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrncat(cur: *mut xmlChar, add: *const xmlChar, len: std::os::raw::c_int)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrncatNew(str1: *const xmlChar, str2: *const xmlChar,
                     len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrcat(cur: *mut xmlChar, add: *const xmlChar) -> *mut xmlChar;
    /*
 * Constructor and destructor.
 */
    #[no_mangle]
    fn xmlDictCreate() -> xmlDictPtr;
    #[no_mangle]
    fn xmlDictReference(dict: xmlDictPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDictFree(dict: xmlDictPtr);
    /*
 * Lookup of entry in the dictionary.
 */
    #[no_mangle]
    fn xmlDictLookup(dict: xmlDictPtr, name: *const xmlChar, len: std::os::raw::c_int)
     -> *const xmlChar;
    /*
 * The POSIX like API
 */
    #[no_mangle]
    fn xmlRegexpCompile(regexp: *const xmlChar) -> xmlRegexpPtr;
    #[no_mangle]
    fn xmlRegFreeRegexp(regexp: xmlRegexpPtr);
    #[no_mangle]
    fn xmlRegexpExec(comp: xmlRegexpPtr, value: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegexpIsDeterminist(comp: xmlRegexpPtr) -> std::os::raw::c_int;
    /*
 * The progressive API
 */
    #[no_mangle]
    fn xmlRegNewExecCtxt(comp: xmlRegexpPtr, callback: xmlRegExecCallbacks,
                         data: *mut std::os::raw::c_void) -> xmlRegExecCtxtPtr;
    #[no_mangle]
    fn xmlRegFreeExecCtxt(exec: xmlRegExecCtxtPtr);
    #[no_mangle]
    fn xmlRegExecPushString(exec: xmlRegExecCtxtPtr, value: *const xmlChar,
                            data: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegExecPushString2(exec: xmlRegExecCtxtPtr, value: *const xmlChar,
                             value2: *const xmlChar, data: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegExecNextValues(exec: xmlRegExecCtxtPtr, nbval: *mut std::os::raw::c_int,
                            nbneg: *mut std::os::raw::c_int,
                            values: *mut *mut xmlChar,
                            terminal: *mut std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegExecErrInfo(exec: xmlRegExecCtxtPtr, string: *mut *const xmlChar,
                         nbval: *mut std::os::raw::c_int, nbneg: *mut std::os::raw::c_int,
                         values: *mut *mut xmlChar,
                         terminal: *mut std::os::raw::c_int) -> std::os::raw::c_int;
    /* *
 * xmlChildrenNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children."
 */
    /* *
 * xmlRootNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children".
 */
    /*
 * Variables.
 */
    /*
 * Some helper functions
 */
    #[no_mangle]
    fn xmlValidateNCName(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateQName(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSplitQName2(name: *const xmlChar, prefix: *mut *mut xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlSplitQName3(name: *const xmlChar, len: *mut std::os::raw::c_int)
     -> *const xmlChar;
    /* LIBXML_LEGACY_ENABLED */
    #[no_mangle]
    fn xmlNewNs(node: xmlNodePtr, href: *const xmlChar,
                prefix: *const xmlChar) -> xmlNsPtr;
    #[no_mangle]
    fn xmlFreeDoc(cur: xmlDocPtr);
    #[no_mangle]
    fn xmlNewProp(node: xmlNodePtr, name: *const xmlChar,
                  value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlNewNsProp(node: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar,
                    value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlNewText(content: *const xmlChar) -> xmlNodePtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
    #[no_mangle]
    fn xmlDocGetRootElement(doc: *const xmlDoc) -> xmlNodePtr;
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlAddChild(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlUnlinkNode(cur: xmlNodePtr);
    #[no_mangle]
    fn xmlFreeNode(cur: xmlNodePtr);
    /*
 * Namespaces.
 */
    #[no_mangle]
    fn xmlSearchNs(doc: xmlDocPtr, node: xmlNodePtr,
                   nameSpace: *const xmlChar) -> xmlNsPtr;
    #[no_mangle]
    fn xmlSearchNsByHref(doc: xmlDocPtr, node: xmlNodePtr,
                         href: *const xmlChar) -> xmlNsPtr;
    #[no_mangle]
    fn xmlGetNsList(doc: *const xmlDoc, node: *const xmlNode)
     -> *mut xmlNsPtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \
	  defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
    #[no_mangle]
    fn xmlGetNoNsProp(node: *const xmlNode, name: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlHasProp(node: *const xmlNode, name: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlNodeListGetString(doc: xmlDocPtr, list: *const xmlNode,
                            inLine: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeGetContent(cur: *const xmlNode) -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeGetSpacePreserve(cur: *const xmlNode) -> std::os::raw::c_int;
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlNodeGetBase(doc: *const xmlDoc, cur: *const xmlNode)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlHashCreateDict(size: std::os::raw::c_int, dict: xmlDictPtr)
     -> xmlHashTablePtr;
    #[no_mangle]
    fn xmlHashFree(table: xmlHashTablePtr, f: xmlHashDeallocator);
    /*
 * Add a new entry to the hash table.
 */
    #[no_mangle]
    fn xmlHashAddEntry(table: xmlHashTablePtr, name: *const xmlChar,
                       userdata: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashAddEntry2(table: xmlHashTablePtr, name: *const xmlChar,
                        name2: *const xmlChar, userdata: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    /*
 * Retrieve the userdata.
 */
    #[no_mangle]
    fn xmlHashLookup(table: xmlHashTablePtr, name: *const xmlChar)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashLookup2(table: xmlHashTablePtr, name: *const xmlChar,
                      name2: *const xmlChar) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashSize(table: xmlHashTablePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashScan(table: xmlHashTablePtr, f: xmlHashScanner,
                   data: *mut std::os::raw::c_void);
    #[no_mangle]
    fn xmlHashScanFull(table: xmlHashTablePtr, f: xmlHashScannerFull,
                       data: *mut std::os::raw::c_void);
    /*
 * Extended error information routines
 */
    #[no_mangle]
    fn xmlGetLastError() -> xmlErrorPtr;
    /*
 * Internal callback reporting routine
 */
    #[no_mangle]
    fn __xmlRaiseError(schannel: xmlStructuredErrorFunc,
                       channel: xmlGenericErrorFunc, data: *mut std::os::raw::c_void,
                       ctx: *mut std::os::raw::c_void, node: *mut std::os::raw::c_void,
                       domain: std::os::raw::c_int, code: std::os::raw::c_int,
                       level: xmlErrorLevel, file: *const std::os::raw::c_char,
                       line: std::os::raw::c_int, str1: *const std::os::raw::c_char,
                       str2: *const std::os::raw::c_char, str3: *const std::os::raw::c_char,
                       int1: std::os::raw::c_int, col: std::os::raw::c_int,
                       msg: *const std::os::raw::c_char, _: ...);
    #[no_mangle]
    fn __xmlSimpleError(domain: std::os::raw::c_int, code: std::os::raw::c_int,
                        node: xmlNodePtr, msg: *const std::os::raw::c_char,
                        extra: *const std::os::raw::c_char);
    /*
 * Building API
 */
    #[no_mangle]
    fn xmlNewAutomata() -> xmlAutomataPtr;
    #[no_mangle]
    fn xmlFreeAutomata(am: xmlAutomataPtr);
    #[no_mangle]
    fn xmlAutomataGetInitState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataSetFinalState(am: xmlAutomataPtr,
                                state: xmlAutomataStatePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlAutomataNewState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataNewTransition2(am: xmlAutomataPtr,
                                 from: xmlAutomataStatePtr,
                                 to: xmlAutomataStatePtr,
                                 token: *const xmlChar,
                                 token2: *const xmlChar,
                                 data: *mut std::os::raw::c_void)
     -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataNewNegTrans(am: xmlAutomataPtr, from: xmlAutomataStatePtr,
                              to: xmlAutomataStatePtr, token: *const xmlChar,
                              token2: *const xmlChar, data: *mut std::os::raw::c_void)
     -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataNewCountTrans2(am: xmlAutomataPtr,
                                 from: xmlAutomataStatePtr,
                                 to: xmlAutomataStatePtr,
                                 token: *const xmlChar,
                                 token2: *const xmlChar, min: std::os::raw::c_int,
                                 max: std::os::raw::c_int, data: *mut std::os::raw::c_void)
     -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataNewOnceTrans2(am: xmlAutomataPtr, from: xmlAutomataStatePtr,
                                to: xmlAutomataStatePtr,
                                token: *const xmlChar, token2: *const xmlChar,
                                min: std::os::raw::c_int, max: std::os::raw::c_int,
                                data: *mut std::os::raw::c_void)
     -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataNewAllTrans(am: xmlAutomataPtr, from: xmlAutomataStatePtr,
                              to: xmlAutomataStatePtr, lax: std::os::raw::c_int)
     -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataNewEpsilon(am: xmlAutomataPtr, from: xmlAutomataStatePtr,
                             to: xmlAutomataStatePtr) -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataNewCountedTrans(am: xmlAutomataPtr,
                                  from: xmlAutomataStatePtr,
                                  to: xmlAutomataStatePtr,
                                  counter: std::os::raw::c_int)
     -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataNewCounterTrans(am: xmlAutomataPtr,
                                  from: xmlAutomataStatePtr,
                                  to: xmlAutomataStatePtr,
                                  counter: std::os::raw::c_int)
     -> xmlAutomataStatePtr;
    #[no_mangle]
    fn xmlAutomataNewCounter(am: xmlAutomataPtr, min: std::os::raw::c_int,
                             max: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlAutomataCompile(am: xmlAutomataPtr) -> xmlRegexpPtr;
    #[no_mangle]
    fn xmlFreeEnumeration(cur: xmlEnumerationPtr);
    /* LIBXML_OUTPUT_ENABLED */
    /* IDs */
    #[no_mangle]
    fn xmlAddID(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr, value: *const xmlChar,
                attr: xmlAttrPtr) -> xmlIDPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateFilename(URI: *const std::os::raw::c_char,
                                          enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlStopParser(ctxt: xmlParserCtxtPtr);
    /* LIBXML_SAX1_ENABLED */
    /*
 * Less common routines and SAX interfaces
 */
    #[no_mangle]
    fn xmlParseDocument(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    /*
 * Parser contexts handling.
 */
    #[no_mangle]
    fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlFreeParserCtxt(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlNewIOInputStream(ctxt: xmlParserCtxtPtr,
                           input: xmlParserInputBufferPtr,
                           enc: xmlCharEncoding) -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlCtxtReadFile(ctxt: xmlParserCtxtPtr, filename: *const std::os::raw::c_char,
                       encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlCtxtReadMemory(ctxt: xmlParserCtxtPtr, buffer: *const std::os::raw::c_char,
                         size: std::os::raw::c_int, URL: *const std::os::raw::c_char,
                         encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlSAX2GetLineNumber(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    /* * DOC_DISABLE */
/*
 * In general the memory allocation entry points are not kept
 * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED
 *    - xmlMalloc
 *    - xmlMallocAtomic
 *    - xmlRealloc
 *    - xmlMemStrdup
 *    - xmlFree
 */
    /* !LIBXML_THREAD_ALLOC_ENABLED */
    #[no_mangle]
    static mut xmlMalloc: xmlMallocFunc;
    #[no_mangle]
    static mut xmlMallocAtomic: xmlMallocFunc;
    #[no_mangle]
    static mut xmlRealloc: xmlReallocFunc;
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    #[no_mangle]
    fn __xmlGenericError() -> *mut xmlGenericErrorFunc;
    #[no_mangle]
    fn __xmlGenericErrorContext() -> *mut *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlFreeStreamCtxt(stream: xmlStreamCtxtPtr);
    #[no_mangle]
    fn xmlFreePattern(comp: xmlPatternPtr);
    #[no_mangle]
    fn warningSplit(ctx: *mut std::os::raw::c_void, msg: *const std::os::raw::c_char, _: ...);
    #[no_mangle]
    fn errorSplit(ctx: *mut std::os::raw::c_void, msg: *const std::os::raw::c_char, _: ...);
    #[no_mangle]
    fn fatalErrorSplit(ctx: *mut std::os::raw::c_void, msg: *const std::os::raw::c_char,
                       _: ...);
    #[no_mangle]
    fn xmlStreamPush(stream: xmlStreamCtxtPtr, name: *const xmlChar,
                     ns: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStreamPushAttr(stream: xmlStreamCtxtPtr, name: *const xmlChar,
                         ns: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlPatternGetStreamCtxt(comp: xmlPatternPtr) -> xmlStreamCtxtPtr;
    #[no_mangle]
    fn xmlStreamPop(stream: xmlStreamCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlPatterncompile(pattern: *const xmlChar, dict: *mut xmlDict,
                         flags: std::os::raw::c_int, namespaces: *mut *const xmlChar)
     -> xmlPatternPtr;
    #[no_mangle]
    fn xmlTextReaderLookupNamespace(reader: xmlTextReaderPtr,
                                    prefix: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn memcpy(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_void, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn memset(_: *mut std::os::raw::c_void, _: std::os::raw::c_int, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn strchr(_: *const std::os::raw::c_char, _: std::os::raw::c_int) -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn inputPush(ctxt: xmlParserCtxtPtr, value: xmlParserInputPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBuildURI(URI: *const xmlChar, base: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlSchemaInitTypes();
    #[no_mangle]
    fn xmlSchemaGetPredefinedType(name: *const xmlChar, ns: *const xmlChar)
     -> xmlSchemaTypePtr;
    #[no_mangle]
    fn xmlSchemaValidatePredefinedType(type_0: xmlSchemaTypePtr,
                                       value: *const xmlChar,
                                       val: *mut xmlSchemaValPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValPredefTypeNode(type_0: xmlSchemaTypePtr,
                                  value: *const xmlChar,
                                  val: *mut xmlSchemaValPtr, node: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateFacetWhtsp(facet: xmlSchemaFacetPtr,
                                   fws: xmlSchemaWhitespaceValueType,
                                   valType: xmlSchemaValType,
                                   value: *const xmlChar,
                                   val: xmlSchemaValPtr,
                                   ws: xmlSchemaWhitespaceValueType)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaFreeValue(val: xmlSchemaValPtr);
    #[no_mangle]
    fn xmlSchemaCompareValues(x: xmlSchemaValPtr, y: xmlSchemaValPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateListSimpleTypeFacet(facet: xmlSchemaFacetPtr,
                                            value: *const xmlChar,
                                            actualLen: std::os::raw::c_ulong,
                                            expectedLen: *mut std::os::raw::c_ulong)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaGetBuiltInType(type_0: xmlSchemaValType) -> xmlSchemaTypePtr;
    #[no_mangle]
    fn xmlSchemaIsBuiltInTypeFacet(type_0: xmlSchemaTypePtr,
                                   facetType: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaCollapseString(value: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlSchemaWhiteSpaceReplace(value: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlSchemaGetFacetValueAsULong(facet: xmlSchemaFacetPtr)
     -> std::os::raw::c_ulong;
    #[no_mangle]
    fn xmlSchemaValidateLengthFacetWhtsp(facet: xmlSchemaFacetPtr,
                                         valType: xmlSchemaValType,
                                         value: *const xmlChar,
                                         val: xmlSchemaValPtr,
                                         length: *mut std::os::raw::c_ulong,
                                         ws: xmlSchemaWhitespaceValueType)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValPredefTypeNodeNoNorm(type_0: xmlSchemaTypePtr,
                                        value: *const xmlChar,
                                        val: *mut xmlSchemaValPtr,
                                        node: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaGetCanonValue(val: xmlSchemaValPtr,
                              retValue: *mut *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValueAppend(prev: xmlSchemaValPtr, cur: xmlSchemaValPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValueGetNext(cur: xmlSchemaValPtr) -> xmlSchemaValPtr;
    #[no_mangle]
    fn xmlSchemaValueGetAsString(val: xmlSchemaValPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlSchemaValueGetAsBoolean(val: xmlSchemaValPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaNewNOTATIONValue(name: *const xmlChar, ns: *const xmlChar)
     -> xmlSchemaValPtr;
    #[no_mangle]
    fn xmlSchemaNewQNameValue(namespaceName: *const xmlChar,
                              localName: *const xmlChar) -> xmlSchemaValPtr;
    #[no_mangle]
    fn xmlSchemaCompareValuesWhtsp(x: xmlSchemaValPtr,
                                   xws: xmlSchemaWhitespaceValueType,
                                   y: xmlSchemaValPtr,
                                   yws: xmlSchemaWhitespaceValueType)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaCopyValue(val: xmlSchemaValPtr) -> xmlSchemaValPtr;
    #[no_mangle]
    fn xmlSchemaGetValType(val: xmlSchemaValPtr) -> xmlSchemaValType;
}
pub type xmlChar = std::os::raw::c_uchar;
pub type size_t = std::os::raw::c_ulong;
pub type __off_t = std::os::raw::c_long;
pub type __off64_t = std::os::raw::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: std::os::raw::c_int,
    pub _IO_read_ptr: *mut std::os::raw::c_char,
    pub _IO_read_end: *mut std::os::raw::c_char,
    pub _IO_read_base: *mut std::os::raw::c_char,
    pub _IO_write_base: *mut std::os::raw::c_char,
    pub _IO_write_ptr: *mut std::os::raw::c_char,
    pub _IO_write_end: *mut std::os::raw::c_char,
    pub _IO_buf_base: *mut std::os::raw::c_char,
    pub _IO_buf_end: *mut std::os::raw::c_char,
    pub _IO_save_base: *mut std::os::raw::c_char,
    pub _IO_backup_base: *mut std::os::raw::c_char,
    pub _IO_save_end: *mut std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: std::os::raw::c_int,
    pub _flags2: std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: std::os::raw::c_ushort,
    pub _vtable_offset: std::os::raw::c_schar,
    pub _shortbuf: [std::os::raw::c_char; 1],
    pub _lock: *mut std::os::raw::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: std::os::raw::c_int,
    pub _unused2: [std::os::raw::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
/* *
 * xmlOutputCloseCallback:
 * @context:  an Output context
 *
 * Callback used in the I/O Output API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
/* LIBXML_OUTPUT_ENABLED */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInputBuffer {
    pub context: *mut std::os::raw::c_void,
    pub readcallback: xmlInputReadCallback,
    pub closecallback: xmlInputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub raw: xmlBufPtr,
    pub compressed: std::os::raw::c_int,
    pub error: std::os::raw::c_int,
    pub rawconsumed: std::os::raw::c_ulong,
}
pub type xmlBufPtr = *mut xmlBuf;
pub type xmlBuf = _xmlBuf;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
/* *
 * xmlCharEncodingInputFunc:
 * @out:  a pointer to an array of bytes to store the UTF-8 result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of chars in the original encoding
 * @inlen:  the length of @in
 *
 * Take a block of chars in the original encoding and try to convert
 * it to an UTF-8 block of chars out.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets consumed.
 */
/* *
 * xmlCharEncodingOutputFunc:
 * @out:  a pointer to an array of bytes to store the result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of UTF-8 chars
 * @inlen:  the length of @in
 *
 * Take a block of UTF-8 chars in and try to convert it to another
 * encoding.
 * Note: a first call designed to produce heading info is called with
 * in = NULL. If stateful this should also initialize the encoder state.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets produced.
 */
/*
 * Block defining the handlers for non UTF-8 encodings.
 * If iconv is supported, there are two extra fields.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlCharEncodingHandler {
    pub name: *mut std::os::raw::c_char,
    pub input: xmlCharEncodingInputFunc,
    pub output: xmlCharEncodingOutputFunc,
    pub iconv_in: iconv_t,
    pub iconv_out: iconv_t,
}
pub type iconv_t = *mut std::os::raw::c_void;
pub type xmlCharEncodingOutputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
pub type xmlCharEncodingInputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
pub type xmlInputCloseCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type xmlInputReadCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_char,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
/*
 * Summary: the core parser module
 * Description: Interfaces, constants and types related to the XML parser
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * XML_DEFAULT_VERSION:
 *
 * The default version of XML used: 1.0
 */
/* *
 * xmlParserInput:
 *
 * An xmlParserInput is an input flow for the XML processor.
 * Each entity parsed is associated an xmlParserInput (except the
 * few predefined ones). This is the case both for internal entities
 * - in which case the flow is already completely in memory - or
 * external entities - in which case we use the buf structure for
 * progressive reading and I18N conversions to the internal UTF-8 format.
 */
/* *
 * xmlParserInputDeallocate:
 * @str:  the string to deallocate
 *
 * Callback for freeing some parser input allocations.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInput {
    pub buf: xmlParserInputBufferPtr,
    pub filename: *const std::os::raw::c_char,
    pub directory: *const std::os::raw::c_char,
    pub base: *const xmlChar,
    pub cur: *const xmlChar,
    pub end: *const xmlChar,
    pub length: std::os::raw::c_int,
    pub line: std::os::raw::c_int,
    pub col: std::os::raw::c_int,
    pub consumed: std::os::raw::c_ulong,
    pub free: xmlParserInputDeallocate,
    pub encoding: *const xmlChar,
    pub version: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub id: std::os::raw::c_int,
}
pub type xmlParserInputDeallocate
    =
    Option<unsafe extern "C" fn(_: *mut xmlChar) -> ()>;
/* parser.h */
pub type xmlParserInput = _xmlParserInput;
pub type xmlParserInputPtr = *mut xmlParserInput;
/* an unique identifier for the entity */
/* *
 * xmlParserNodeInfo:
 *
 * The parser can be asked to collect Node informations, i.e. at what
 * place in the file they were detected.
 * NOTE: This is off by default and not very well tested.
 */
/* Position & line # that text that created the node begins & ends on */
/* *
 * xmlParserInputState:
 *
 * The parser is now working also as a state based parser.
 * The recursive one use the state info for entities processing.
 */
/* nothing is to be parsed */
/* nothing has been parsed */
/* Misc* before int subset */
/* Within a processing instruction */
/* within some DTD content */
/* Misc* after internal subset */
/* within a comment */
/* within a start tag */
/* within the content */
/* within a CDATA section */
/* within a closing tag */
/* within an entity declaration */
/* within an entity value in a decl */
/* within an attribute value */
/* within a SYSTEM value */
/* the Misc* after the last end tag */
/* within an IGNORED section */
/* within a PUBLIC value */
/* *
 * XML_DETECT_IDS:
 *
 * Bit in the loadsubset context field to tell to do ID/REFs lookups.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
/* *
 * XML_COMPLETE_ATTRS:
 *
 * Bit in the loadsubset context field to tell to do complete the
 * elements attributes lists with the ones defaulted from the DTDs.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
/* *
 * XML_SKIP_IDS:
 *
 * Bit in the loadsubset context field to tell to not do ID/REFs registration.
 * Used to initialize xmlLoadExtDtdDefaultValue in some special cases.
 */
/* *
 * xmlParserMode:
 *
 * A parser can operate in various modes
 */
/* *
 * xmlParserCtxt:
 *
 * The parser context.
 * NOTE This doesn't completely define the parser state, the (current ?)
 *      design of the parser uses recursive function calls since this allow
 *      and easy mapping from the production rules of the specification
 *      to the actual code. The drawback is that the actual function call
 *      also reflect the parser state. However most of the parsing routines
 *      takes as the only argument the parser context pointer, so migrating
 *      to a state based parser for progressive parsing shouldn't be too hard.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserCtxt {
    pub sax: *mut _xmlSAXHandler,
    pub userData: *mut std::os::raw::c_void,
    pub myDoc: xmlDocPtr,
    pub wellFormed: std::os::raw::c_int,
    pub replaceEntities: std::os::raw::c_int,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub html: std::os::raw::c_int,
    pub input: xmlParserInputPtr,
    pub inputNr: std::os::raw::c_int,
    pub inputMax: std::os::raw::c_int,
    pub inputTab: *mut xmlParserInputPtr,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub record_info: std::os::raw::c_int,
    pub node_seq: xmlParserNodeInfoSeq,
    pub errNo: std::os::raw::c_int,
    pub hasExternalSubset: std::os::raw::c_int,
    pub hasPErefs: std::os::raw::c_int,
    pub external: std::os::raw::c_int,
    pub valid: std::os::raw::c_int,
    pub validate: std::os::raw::c_int,
    pub vctxt: xmlValidCtxt,
    pub instate: xmlParserInputState,
    pub token: std::os::raw::c_int,
    pub directory: *mut std::os::raw::c_char,
    pub name: *const xmlChar,
    pub nameNr: std::os::raw::c_int,
    pub nameMax: std::os::raw::c_int,
    pub nameTab: *mut *const xmlChar,
    pub nbChars: std::os::raw::c_long,
    pub checkIndex: std::os::raw::c_long,
    pub keepBlanks: std::os::raw::c_int,
    pub disableSAX: std::os::raw::c_int,
    pub inSubset: std::os::raw::c_int,
    pub intSubName: *const xmlChar,
    pub extSubURI: *mut xmlChar,
    pub extSubSystem: *mut xmlChar,
    pub space: *mut std::os::raw::c_int,
    pub spaceNr: std::os::raw::c_int,
    pub spaceMax: std::os::raw::c_int,
    pub spaceTab: *mut std::os::raw::c_int,
    pub depth: std::os::raw::c_int,
    pub entity: xmlParserInputPtr,
    pub charset: std::os::raw::c_int,
    pub nodelen: std::os::raw::c_int,
    pub nodemem: std::os::raw::c_int,
    pub pedantic: std::os::raw::c_int,
    pub _private: *mut std::os::raw::c_void,
    pub loadsubset: std::os::raw::c_int,
    pub linenumbers: std::os::raw::c_int,
    pub catalogs: *mut std::os::raw::c_void,
    pub recovery: std::os::raw::c_int,
    pub progressive: std::os::raw::c_int,
    pub dict: xmlDictPtr,
    pub atts: *mut *const xmlChar,
    pub maxatts: std::os::raw::c_int,
    pub docdict: std::os::raw::c_int,
    pub str_xml: *const xmlChar,
    pub str_xmlns: *const xmlChar,
    pub str_xml_ns: *const xmlChar,
    pub sax2: std::os::raw::c_int,
    pub nsNr: std::os::raw::c_int,
    pub nsMax: std::os::raw::c_int,
    pub nsTab: *mut *const xmlChar,
    pub attallocs: *mut std::os::raw::c_int,
    pub pushTab: *mut *mut std::os::raw::c_void,
    pub attsDefault: xmlHashTablePtr,
    pub attsSpecial: xmlHashTablePtr,
    pub nsWellFormed: std::os::raw::c_int,
    pub options: std::os::raw::c_int,
    pub dictNames: std::os::raw::c_int,
    pub freeElemsNr: std::os::raw::c_int,
    pub freeElems: xmlNodePtr,
    pub freeAttrsNr: std::os::raw::c_int,
    pub freeAttrs: xmlAttrPtr,
    pub lastError: xmlError,
    pub parseMode: xmlParserMode,
    pub nbentities: std::os::raw::c_ulong,
    pub sizeentities: std::os::raw::c_ulong,
    pub nodeInfo: *mut xmlParserNodeInfo,
    pub nodeInfoNr: std::os::raw::c_int,
    pub nodeInfoMax: std::os::raw::c_int,
    pub nodeInfoTab: *mut xmlParserNodeInfo,
    pub input_id: std::os::raw::c_int,
    pub sizeentcopy: std::os::raw::c_ulong,
}
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfo {
    pub node: *const _xmlNode,
    pub begin_pos: std::os::raw::c_ulong,
    pub begin_line: std::os::raw::c_ulong,
    pub end_pos: std::os::raw::c_ulong,
    pub end_line: std::os::raw::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNode {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub content: *mut xmlChar,
    pub properties: *mut _xmlAttr,
    pub nsDef: *mut xmlNs,
    pub psvi: *mut std::os::raw::c_void,
    pub line: std::os::raw::c_ushort,
    pub extra: std::os::raw::c_ushort,
}
/* entities.h */
/* *
 * BASE_BUFFER_SIZE:
 *
 * default buffer size 4000.
 */
/* *
 * LIBXML_NAMESPACE_DICT:
 *
 * Defines experimental behaviour:
 * 1) xmlNs gets an additional field @context (a xmlDoc)
 * 2) when creating a tree, xmlNs->href is stored in the dict of xmlDoc.
 */
/* #define LIBXML_NAMESPACE_DICT */
/* *
 * xmlBufferAllocationScheme:
 *
 * A buffer allocation scheme can be defined to either match exactly the
 * need or double it's allocated size each time it is found too small.
 */
/* double each time one need to grow */
/* grow only to the minimal size */
/* immutable buffer */
/* special allocation scheme used for I/O */
/* exact up to a threshold, and doubleit thereafter */
/* limit the upper size of the buffer */
/* *
 * xmlBuffer:
 *
 * A buffer structure, this old construct is limited to 2GB and
 * is being deprecated, use API with xmlBuf instead
 */
/* The buffer content UTF8 */
/* The buffer size used */
/* The buffer size */
/* The realloc method */
/* in IO mode we may have a different base */
/* *
 * xmlBuf:
 *
 * A buffer structure, new one, the actual structure internals are not public
 */
/* *
 * xmlBufPtr:
 *
 * A pointer to a buffer structure, the actual structure internals are not
 * public
 */
/*
 * A few public routines for xmlBuf. As those are expected to be used
 * mostly internally the bulk of the routines are internal in buf.h
 */
/*
 * LIBXML2_NEW_BUFFER:
 *
 * Macro used to express that the API use the new buffers for
 * xmlParserInputBuffer and xmlOutputBuffer. The change was
 * introduced in 2.9.0.
 */
/* *
 * XML_XML_NAMESPACE:
 *
 * This is the namespace for the special xml: prefix predefined in the
 * XML Namespace specification.
 */
/* *
 * XML_XML_ID:
 *
 * This is the name for the special xml:id attribute
 */
/*
 * The different element types carried by an XML tree.
 *
 * NOTE: This is synchronized with DOM Level1 values
 *       See http://www.w3.org/TR/REC-DOM-Level-1/
 *
 * Actually this had diverged a bit, and now XML_DOCUMENT_TYPE_NODE should
 * be deprecated to use an XML_DTD_NODE.
 */
/* *
 * xmlNotation:
 *
 * A DTD Notation definition.
 */
/* Notation name */
/* Public identifier, if any */
/* System identifier, if any */
/* *
 * xmlAttributeType:
 *
 * A DTD Attribute type definition.
 */
/* *
 * xmlAttributeDefault:
 *
 * A DTD Attribute default definition.
 */
/* *
 * xmlEnumeration:
 *
 * List structure used when there is an enumeration in DTDs.
 */
/* next one */
/* Enumeration name */
/* *
 * xmlAttribute:
 *
 * An Attribute declaration in a DTD.
 */
/* application data */
/* XML_ATTRIBUTE_DECL, must be second ! */
/* Attribute name */
/* NULL */
/* NULL */
/* -> DTD */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* next in hash table */
/* The attribute type */
/* the default */
/* or the default value */
/* or the enumeration tree if any */
/* the namespace prefix if any */
/* Element holding the attribute */
/* *
 * xmlElementContentType:
 *
 * Possible definitions of element content types.
 */
/* *
 * xmlElementContentOccur:
 *
 * Possible definitions of element content occurrences.
 */
/* *
 * xmlElementContent:
 *
 * An XML Element content as stored after parsing an element definition
 * in a DTD.
 */
/* PCDATA, ELEMENT, SEQ or OR */
/* ONCE, OPT, MULT or PLUS */
/* Element name */
/* first child */
/* second child */
/* parent */
/* Namespace prefix */
/* *
 * xmlElementTypeVal:
 *
 * The different possibilities for an element content type.
 */
/* *
 * xmlElement:
 *
 * An XML Element declaration from a DTD.
 */
/* application data */
/* XML_ELEMENT_DECL, must be second ! */
/* Element name */
/* NULL */
/* NULL */
/* -> DTD */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* The type */
/* the allowed element content */
/* List of the declared attributes */
/* the namespace prefix if any */
/* the validating regexp */
/* *
 * XML_LOCAL_NAMESPACE:
 *
 * A namespace declaration node.
 */
/* *
 * xmlNs:
 *
 * An XML namespace.
 * Note that prefix == NULL is valid, it defines the default namespace
 * within the subtree (until overridden).
 *
 * xmlNsType is unified with xmlElementType.
 */
pub type xmlNs = _xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNs {
    pub next: *mut _xmlNs,
    pub type_0: xmlNsType,
    pub href: *const xmlChar,
    pub prefix: *const xmlChar,
    pub _private: *mut std::os::raw::c_void,
    pub context: *mut _xmlDoc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDoc {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *mut std::os::raw::c_char,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub compression: std::os::raw::c_int,
    pub standalone: std::os::raw::c_int,
    pub intSubset: *mut _xmlDtd,
    pub extSubset: *mut _xmlDtd,
    pub oldNs: *mut _xmlNs,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub ids: *mut std::os::raw::c_void,
    pub refs: *mut std::os::raw::c_void,
    pub URL: *const xmlChar,
    pub charset: std::os::raw::c_int,
    pub dict: *mut _xmlDict,
    pub psvi: *mut std::os::raw::c_void,
    pub parseFlags: std::os::raw::c_int,
    pub properties: std::os::raw::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDtd {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDoc,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub notations: *mut std::os::raw::c_void,
    pub elements: *mut std::os::raw::c_void,
    pub attributes: *mut std::os::raw::c_void,
    pub entities: *mut std::os::raw::c_void,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub pentities: *mut std::os::raw::c_void,
}
pub type xmlElementType = std::os::raw::c_uint;
pub const XML_DOCB_DOCUMENT_NODE: xmlElementType = 21;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
pub type xmlNsType = xmlElementType;
/* normally an xmlDoc */
/* *
 * xmlDtd:
 *
 * An XML DTD, as defined by <!DOCTYPE ... There is actually one for
 * the internal subset and for the external subset.
 */
/* application data */
/* XML_DTD_NODE, must be second ! */
/* Name of the DTD */
/* the value of the property link */
/* last child link */
/* child->parent link */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* End of common part */
/* Hash table for notations if any */
/* Hash table for elements if any */
/* Hash table for attributes if any */
/* Hash table for entities if any */
/* External identifier for PUBLIC DTD */
/* URI for a SYSTEM or PUBLIC DTD */
/* Hash table for param entities if any */
/* *
 * xmlAttr:
 *
 * An attribute on an XML node.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttr {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlAttr,
    pub prev: *mut _xmlAttr,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub atype: xmlAttributeType,
    pub psvi: *mut std::os::raw::c_void,
}
pub type xmlAttributeType = std::os::raw::c_uint;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = std::os::raw::c_uint;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
/*
 * Summary: error handling
 * Description: the API used to report errors
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlErrorLevel:
 *
 * Indicates the level of an error
 */
/* A simple warning */
/* A recoverable error */
/* A fatal error */
/* *
 * xmlErrorDomain:
 *
 * Indicates where an error may have come from
 */
/* The XML parser */
/* The tree module */
/* The XML Namespace module */
/* The XML DTD validation with parser context*/
/* The HTML parser */
/* The memory allocator */
/* The serialization code */
/* The Input/Output stack */
/* The FTP module */
/* The HTTP module */
/* The XInclude processing */
/* The XPath module */
/* The XPointer module */
/* The regular expressions module */
/* The W3C XML Schemas Datatype module */
/* The W3C XML Schemas parser module */
/* The W3C XML Schemas validation module */
/* The Relax-NG parser module */
/* The Relax-NG validator module */
/* The Catalog module */
/* The Canonicalization module */
/* The XSLT engine from libxslt */
/* The XML DTD validation with valid context */
/* The error checking module */
/* The xmlwriter module */
/* The dynamically loaded module module*/
/* The module handling character conversion */
/* The Schematron validator module */
/* The buffers module */
/* The URI module */
/* *
 * xmlError:
 *
 * An XML Error instance.
 */
pub type xmlError = _xmlError;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlError {
    pub domain: std::os::raw::c_int,
    pub code: std::os::raw::c_int,
    pub message: *mut std::os::raw::c_char,
    pub level: xmlErrorLevel,
    pub file: *mut std::os::raw::c_char,
    pub line: std::os::raw::c_int,
    pub str1: *mut std::os::raw::c_char,
    pub str2: *mut std::os::raw::c_char,
    pub str3: *mut std::os::raw::c_char,
    pub int1: std::os::raw::c_int,
    pub int2: std::os::raw::c_int,
    pub ctxt: *mut std::os::raw::c_void,
    pub node: *mut std::os::raw::c_void,
}
pub type xmlErrorLevel = std::os::raw::c_uint;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
pub type xmlAttrPtr = *mut xmlAttr;
pub type xmlAttr = _xmlAttr;
/* for type/PSVI informations */
/* *
 * xmlID:
 *
 * An XML ID instance.
 */
/* next ID */
/* The ID name */
/* The attribute holding it */
/* The attribute if attr is not available */
/* The line number if attr is not available */
/* The document holding the ID */
/* *
 * xmlRef:
 *
 * An XML IDREF instance.
 */
/* next Ref */
/* The Ref name */
/* The attribute holding it */
/* The attribute if attr is not available */
/* The line number if attr is not available */
/* *
 * xmlNode:
 *
 * A node in an XML tree.
 */
pub type xmlNodePtr = *mut xmlNode;
pub type xmlNode = _xmlNode;
/*
 * Summary: Chained hash tables
 * Description: This module implements the hash table support used in
 *		various places in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Bjorn Reese <bjorn.reese@systematic.dk>
 */
/*
 * The hash table.
 */
pub type xmlHashTablePtr = *mut xmlHashTable;
pub type xmlHashTable = _xmlHashTable;
pub type xmlDictPtr = *mut xmlDict;
pub type xmlDict = _xmlDict;
pub type xmlParserInputState = std::os::raw::c_int;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
/*
 * Summary: The DTD validation
 * Description: API for the DTD handling and the validity checking
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Validation state added for non-determinist content model.
 */
/* *
 * xmlValidityErrorFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity error is found. This is a message
 * oriented function similar to an *printf function.
 */
/* *
 * xmlValidityWarningFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity warning is found. This is a message
 * oriented function similar to an *printf function.
 */
/* *
 * XML_CTXT_FINISH_DTD_0:
 *
 * Special value for finishDtd field when embedded in an xmlParserCtxt
 */
/* *
 * XML_CTXT_FINISH_DTD_1:
 *
 * Special value for finishDtd field when embedded in an xmlParserCtxt
 */
/*
 * xmlValidCtxt:
 * An xmlValidCtxt is used for error reporting when validating.
 */
pub type xmlValidCtxt = _xmlValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlValidCtxt {
    pub userData: *mut std::os::raw::c_void,
    pub error: xmlValidityErrorFunc,
    pub warning: xmlValidityWarningFunc,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub finishDtd: std::os::raw::c_uint,
    pub doc: xmlDocPtr,
    pub valid: std::os::raw::c_int,
    pub vstate: *mut xmlValidState,
    pub vstateNr: std::os::raw::c_int,
    pub vstateMax: std::os::raw::c_int,
    pub vstateTab: *mut xmlValidState,
    pub am: xmlAutomataPtr,
    pub state: xmlAutomataStatePtr,
}
/*
 * Summary: API to build regexp automata
 * Description: the API to build regexp automata
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlAutomataPtr:
 *
 * A libxml automata description, It can be compiled into a regexp
 */
/* *
 * xmlAutomataStatePtr:
 *
 * A state int the automata description,
 */
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataPtr = *mut xmlAutomata;
pub type xmlAutomata = _xmlAutomata;
pub type xmlValidState = _xmlValidState;
/* application data */
/* type number, must be second ! */
/* the name of the node, or the entity */
/* parent->childs link */
/* last child link */
/* child->parent link */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* End of common part */
/* pointer to the associated namespace */
/* the content */
/* properties list */
/* namespace definitions on this node */
/* for type/PSVI informations */
/* line number */
/* extra data for XPath/XSLT */
/* *
 * XML_GET_CONTENT:
 *
 * Macro to extract the content pointer of a node.
 */
/* *
 * XML_GET_LINE:
 *
 * Macro to extract the line number of an element node.
 */
/* *
 * xmlDocProperty
 *
 * Set of properties of the document as found by the parser
 * Some of them are linked to similary named xmlParserOption
 */
/* document is XML well formed */
/* document is Namespace valid */
/* parsed with old XML-1.0 parser */
/* DTD validation was successful */
/* XInclude substitution was done */
/* Document was built using the API
                                           and not by parsing an instance */
/* built for internal processing */
/* parsed or built HTML document */
/* *
 * xmlDoc:
 *
 * An XML document.
 */
pub type xmlDocPtr = *mut xmlDoc;
pub type xmlDoc = _xmlDoc;
pub type xmlValidityWarningFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlValidityErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfoSeq {
    pub maximum: std::os::raw::c_ulong,
    pub length: std::os::raw::c_ulong,
    pub buffer: *mut xmlParserNodeInfo,
}
/* volume of entity copy */
/* *
 * xmlSAXLocator:
 *
 * A SAX Locator.
 */
/* *
 * xmlSAXHandler:
 *
 * A SAX handler is bunch of callbacks called by the parser when processing
 * of the input generate data or structure informations.
 */
/* *
 * resolveEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * Callback:
 * The entity loader, to control the loading of external entities,
 * the application can either:
 *    - override this resolveEntity() callback in the SAX block
 *    - or better use the xmlSetExternalEntityLoader() function to
 *      set up it's own entity resolution routine
 *
 * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
 */
/* *
 * internalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on internal subset declaration.
 */
/* *
 * externalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on external subset declaration.
 */
/* *
 * getEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get an entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
/* *
 * getParameterEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get a parameter entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
/* *
 * entityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the entity name
 * @type:  the entity type
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @content: the entity value (without processing).
 *
 * An entity definition has been parsed.
 */
/* *
 * notationDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the notation
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * What to do when a notation declaration has been parsed.
 */
/* *
 * attributeDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @elem:  the name of the element
 * @fullname:  the attribute name
 * @type:  the attribute type
 * @def:  the type of default value
 * @defaultValue: the attribute default value
 * @tree:  the tree of enumerated value set
 *
 * An attribute definition has been parsed.
 */
/* *
 * elementDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the element name
 * @type:  the element type
 * @content: the element value tree
 *
 * An element definition has been parsed.
 */
/* *
 * unparsedEntityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the entity
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @notationName: the name of the notation
 *
 * What to do when an unparsed entity declaration is parsed.
 */
/* *
 * setDocumentLocatorSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @loc: A SAX Locator
 *
 * Receive the document locator at startup, actually xmlDefaultSAXLocator.
 * Everything is available on the context, so this is useless in our case.
 */
/* *
 * startDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document start being processed.
 */
/* *
 * endDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document end has been detected.
 */
/* *
 * startElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name, including namespace prefix
 * @atts:  An array of name/value attributes pairs, NULL terminated
 *
 * Called when an opening tag has been processed.
 */
/* *
 * endElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name
 *
 * Called when the end of an element has been detected.
 */
/* *
 * attributeSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The attribute name, including namespace prefix
 * @value:  The attribute value
 *
 * Handle an attribute that has been read by the parser.
 * The default handling is to convert the attribute into an
 * DOM subtree and past it in a new xmlAttr element added to
 * the element.
 */
/* *
 * referenceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The entity name
 *
 * Called when an entity reference is detected.
 */
/* *
 * charactersSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some chars from the parser.
 */
/* *
 * ignorableWhitespaceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some ignorable whitespaces from the parser.
 * UNUSED: by default the DOM building will use characters.
 */
/* *
 * processingInstructionSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @target:  the target name
 * @data: the PI data's
 *
 * A processing instruction has been parsed.
 */
/* *
 * commentSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  the comment content
 *
 * A comment has been parsed.
 */
/* *
 * cdataBlockSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  The pcdata content
 * @len:  the block length
 *
 * Called when a pcdata block has been parsed.
 */
/* *
 * warningSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format a warning messages, callback.
 */
/* *
 * errorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format an error messages, callback.
 */
/* *
 * fatalErrorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format fatal error messages, callback.
 * Note: so far fatalError() SAX callbacks are not used, error()
 *       get all the callbacks for errors.
 */
/* *
 * isStandaloneSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Is this document tagged standalone?
 *
 * Returns 1 if true
 */
/* *
 * hasInternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an internal subset.
 *
 * Returns 1 if true
 */
/* *
 * hasExternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an external subset?
 *
 * Returns 1 if true
 */
/* ***********************************************************************
 *									*
 *			The SAX version 2 API extensions		*
 *									*
 ************************************************************************/
/* *
 * XML_SAX2_MAGIC:
 *
 * Special constant found in SAX2 blocks initialized fields
 */
/* *
 * startElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 * @nb_namespaces:  number of namespace definitions on that node
 * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
 * @nb_attributes:  the number of attributes on that node
 * @nb_defaulted:  the number of defaulted attributes. The defaulted
 *                  ones are at the end of the array
 * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
 *               attribute values.
 *
 * SAX2 callback when an element start has been detected by the parser.
 * It provides the namespace informations for the element, as well as
 * the new namespace declarations on the element.
 */
/* *
 * endElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 *
 * SAX2 callback when an element end has been detected by the parser.
 * It provides the namespace informations for the element.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandler {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: std::os::raw::c_uint,
    pub _private: *mut std::os::raw::c_void,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub serror: xmlStructuredErrorFunc,
}
/* the node in the tree */
/* *
 * xmlParserError:
 *
 * This is an error that the XML (or HTML) parser can generate
 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* 11 */
/* 12 */
/* 13 */
/* 14 */
/* 15 */
/* 16 */
/* 17 */
/* 18 */
/* 19 */
/* 20 */
/* 21 */
/* 22 */
/* 23 */
/* 24 */
/* 25 */
/* 26 */
/* 27 */
/* 28 */
/* 29 */
/* 30 */
/* 31 */
/* 32 */
/* 33 */
/* 34 */
/* 35 */
/* 36 */
/* 37 */
/* 38 */
/* 39 */
/* 40 */
/* 41 */
/* 42 */
/* 43 */
/* 44 */
/* 45 */
/* 46 */
/* 47 */
/* 48 */
/* 49 */
/* 50 */
/* 51 */
/* 52 */
/* 53 */
/* 54 */
/* 55 */
/* 56 */
/* 57 */
/* 58 */
/* 59 */
/* 60 */
/* 61 */
/* 62 */
/* 63 */
/* 64 */
/* 65 */
/* 66 */
/* 67 */
/* 68 */
/* 69 */
/* 70 */
/* 71 */
/* 72 */
/* 73 */
/* 74 */
/* 75 */
/* 76 */
/* 77 */
/* 78 */
/* 79 */
/* 80 */
/* 81 */
/* 82 */
/* 83 */
/* 84 */
/* 85 */
/* 86 */
/* 87 */
/* 88 */
/* 89 */
/* 90 */
/* 91 */
/* 92 */
/* 93 */
/* 94 */
/* 95 */
/* 96 */
/* 97 */
/* 98 */
/* 99 */
/* 100 */
/* 101 */
/* 102 */
/* 103 */
/* 104 */
/* 105 */
/* 106 */
/* 107 */
/* 108 */
/* 109 */
/* 110 */
/* 111 */
/* 201 */
/* 202 */
/* 203 */
/* 204 */
/* 205 */
/* 501 */
/* 502 */
/* 503 */
/* 504 */
/* 505 */
/* 506 */
/* 507 */
/* 508 */
/* 509 */
/* 510 */
/* 511 */
/* 512 */
/* 513 */
/* 514 */
/* 515 */
/* 516 */
/* 517 */
/* 518 */
/* 519 */
/* 520 */
/* 521 */
/* 522 */
/* 523 */
/* 524 */
/* 525 */
/* 526 */
/* 527 */
/* 528 */
/* 529 */
/* 530 */
/* 531 */
/* 532 */
/* 533 */
/* 534 */
/* 535 */
/* 536 */
/* 537 */
/* 538 */
/* 539 */
/* 540 */
/* 541 */
/* 801 */
/* 1001 */
/* 1002 */
/* 1003 */
/* 1004 */
/* 1005 */
/* 1006 */
/* 1007 */
/* 1008 */
/* 1009 */
/* 1010 */
/* 1011 */
/* 1012 */
/* 1013 */
/* 1014 */
/* 1015 */
/* 1016 */
/* 1017 */
/* 1018 */
/* 1019 */
/* 1020 */
/* 1021 */
/* 1022 */
/* 1023 */
/* 1024 */
/* 1025 */
/* 1026 */
/* 1027 */
/* 1028 */
/* 1029 */
/* 1030 */
/* 1031 */
/* 1032 */
/* 1033 */
/* 1034 */
/* 1035 */
/* 1036 */
/* 1037 */
/* 1038 */
/* 1039 */
/* 1040 */
/* 1041 */
/* 1042 */
/* 1043 */
/* 1044 */
/* 1045 */
/* 1046 */
/* 1047 */
/* 1048 */
/* 1049 */
/* 1050 */
/* 1051 */
/* 1052 */
/* 1053 */
/* 1054 */
/* 1055 */
/* 1056 */
/* 1057 */
/* 1058 */
/* 1059 */
/* 1060 */
/* 1061 */
/* 1062 */
/* 1063 */
/* 1064 */
/* 1065 */
/* 1066 */
/* 1067 */
/* 1068 */
/* 1069 */
/* 1070 */
/* 1071 */
/* 1072 */
/* 1073 */
/* 1074 */
/* 1075 */
/* 1076 */
/* 1077 */
/* 1078 */
/* 1079 */
/* 1080 */
/* 1081 */
/* 1082 */
/* 1083 */
/* 1084 */
/* 1085 */
/* 1086 */
/* 1087 */
/* 1088 */
/* 1089 */
/* 1090 */
/* 1091 */
/* 1092 */
/* 1093 */
/* 1094 */
/* 1095 */
/* 1096 */
/* 1097 */
/* 1098 */
/* 1099 */
/* 1100 */
/* 1101 */
/* 1102 */
/* 1103 */
/* 1104 */
/* 1105 */
/* 1106 */
/* 1107 */
/* 1108 */
/* 1109 */
/* 1110 */
/* 1111 */
/* 1112 */
/* 1113 */
/* 1114 */
/* 1115 */
/* 1116 */
/* 1117 */
/* 1118 */
/* 1119 */
/* 1120 */
/* 1121 */
/* 1122 */
/* 1201 */
/* 1202 */
/* 1203 */
/* 1204 */
/* 1205 */
/* 1206 */
/* 1207 */
/* 1208 */
/* 1209 */
/* 1210 */
/* 1211 */
/* 1212 */
/* 1213 */
/* 1214 */
/* 1215 */
/* 1216 */
/* 1217 */
/* 1218 */
/* 1219 */
/* 1220 */
/* 1221 */
/* 1301 */
/* 1302 */
/* 1303 */
/* 1401 */
/* 1402 */
/* 1403 */
/* 1501 */
/* 1502 */
/* 1503 */
/* 1504 */
/* 1505 */
/* 1506 */
/* 1507 */
/* 1508 */
/* 1509 */
/* 1510 */
/* 1511 */
/* 1512 */
/* 1513 */
/* 1514 */
/* 1515 */
/* 1516 */
/* 1517 */
/* 1518 */
/* 1519 */
/* 1520 */
/* 1521 */
/* 1522 */
/* 1523 */
/* 1524 */
/* 1525 */
/* 1526 */
/* 1527 */
/* 1528 */
/* 1529 */
/* 1530 */
/* 1531 */
/* 1532 */
/* 1533 */
/* 1534 */
/* 1535 */
/* 1536 */
/* 1537 */
/* 1538 */
/* 1539 */
/* 1540 */
/* 1541 */
/* 1542 */
/* 1543 */
/* 1544 */
/* 1545 */
/* 1546 */
/* 1547 */
/* 1548 */
/* 1549 */
/* 1550 */
/* 1551 */
/* 1552 */
/* 1553 */
/* 1554 */
/* 1555 */
/* 1556 */
/* 1601 */
/* 1602 */
/* 1603 */
/* 1604 */
/* 1605 */
/* 1606 */
/* 1607 */
/* 1608 */
/* 1609 */
/* 1610 */
/* 1611 */
/* 1612 */
/* 1613 */
/* 1614 */
/* 1615 */
/* 1616 */
/* 1617 */
/* 1618 */
/* 1651 */
/* 1652 */
/* 1653 */
/* 1654 */
/* 1701 */
/* 1702 */
/* 1703 */
/* 1704 */
/* 1705 */
/* 1706 */
/* 1707 */
/* 1708 */
/* 1709 */
/* 1710 */
/* 1711 */
/* 1712 */
/* 1713 */
/* 1714 */
/* 1715 */
/* 1716 */
/* 1717 */
/* 1718 */
/* 1719 */
/* 1720 */
/* 1721 */
/* 1722 */
/* 1723 */
/* 1724 */
/* 1725 */
/* 1726 */
/* 1727 */
/* 1728 */
/* 1729 */
/* 1730 */
/* 1731 */
/* 1732 */
/* 1733 */
/* 1734 */
/* 1735 */
/* 1736 */
/* 1737 */
/* 1738 */
/* 1739 */
/* 1740 */
/* 1741 */
/* 1742 */
/* 1743 */
/* 1744 */
/* 1745 */
/* 1746 */
/* 1747 */
/* 1748 */
/* 1749 */
/* 1750 */
/* 1751 */
/* 1752 */
/* 1753 */
/* 1754 */
/* 1755 */
/* 1756 */
/* 1757 */
/* 1758 */
/* 1759 */
/* 1760 */
/* 1761 */
/* 1762 */
/* 1763 */
/* 1764 */
/* 1765 */
/* 1766 */
/* 1767 */
/* 1768 */
/* 1769 */
/* 1770 */
/* 1771 */
/* 1772 */
/* 1773 */
/* 1774 */
/* 1775 */
/* 1776 */
/* 1777 */
/* 1778 */
/* 1779 */
/* 1780 */
/* 1781 */
/* 1782 */
/* 1783 */
/* 1784 */
/* 1785 */
/* 1786 */
/* 1787 */
/* 1788 */
/* 1789 */
/* 1790 */
/* 1791 */
/* 1792 */
/* 1793 */
/* 1794 */
/* 1795 */
/* 1796 */
/* 1797 */
/* 1798 */
/* 1799 */
/* 1800 */
/* 1802 */
/* 1803 */
/* 1804 */
/* 1805 */
/* 1806 */
/* 1807 */
/* 1808 */
/* 1809 */
/* 1810 */
/* 1811 */
/* 1812 */
/* 1813 */
/* 1814 */
/* 1815 */
/* 1816 */
/* 1817 */
/* 1818 */
/* 1819 */
/* 1820 */
/* 1821 */
/* 1822 */
/* 1823 */
/* 1824 */
/* 1825 */
/* 1826 */
/* 1827 */
/* 1828 */
/* 1829 */
/* 1830 */
/* 1831 */
/* 1832 */
/* 1833 */
/* 1834 */
/* 1835 */
/* 1836 */
/* 1837 */
/* 1838 */
/* 1839 */
/* 1840 */
/* 1841 */
/* 1842 */
/* 1843 */
/* 1844 */
/* 1845 */
/* 1846 */
/* 1847 */
/* 1848 */
/* 1849 */
/* 1850 */
/* 1851 */
/* 1852 */
/* 1853 */
/* 1854 */
/* 1855 */
/* 1856 */
/* 1857 */
/* 1858 */
/* 1859 */
/* 1860 */
/* 1861 */
/* 1862 */
/* 1863 */
/* 1864 */
/* 1865 */
/* 1866 */
/* 1867 */
/* 1868 */
/* 1869 */
/* 1870 */
/* 1871 */
/* 1872 */
/* 1873 */
/* 1874 */
/* 1875 */
/* 1876 */
/* 1877 */
/* 1878 */
/* 1879 */
/* 1901 */
/* 1902 */
/* 1903 */
/* 1951 */
/* 1952 */
/* 1953 */
/* 1954 */
/* 1955 */
/* 2001 */
/* 2002 */
/* 2003 */
/* 2021 */
/* 2022 */
/* 3001 */
/* 3002 */
/* 3003 */
/* 3004 */
/* 3005 */
/* 3006 */
/* 3007 */
/* 3008 */
/* 3009 */
/* 3010 */
/* 3011 */
/* 3012 */
/* 3013 */
/* 3014 */
/* 3015 */
/* 3016 */
/* 3017 */
/* 3018 */
/* 3019 */
/* 3020 */
/* 3021 */
/* 3022 */
/* 3023 */
/* 3024 */
/* 3025 */
/* 3026 */
/* 3027 */
/* 3028 */
/* 3029 */
/* 3030 */
/* 3031 */
/* 3032 */
/* 3033 */
/* 3034 */
/* 3035 */
/* 3036 */
/* 3037 */
/* 3038 */
/* 3039 */
/* 3040 */
/* 3041 */
/* 3042 */
/* 3043 */
/* 3044 */
/* 3045 */
/* 3046 */
/* 3047 */
/* 3048 */
/* 3049 */
/* 3050 */
/* 3051 */
/* 3052 */
/* 3053 */
/* 3054 */
/* 3055 */
/* 3056 */
/* 3057 */
/* 3058 */
/* 3059 */
/* 3060 */
/* 3061 */
/* 3062 */
/* 3063 */
/* 3064 */
/* 3065 */
/* 3066 */
/* 3067 */
/* 3068 */
/* 3069 non-W3C */
/* 3070 non-W3C */
/* 3071 */
/* 3072 */
/* 3073 */
/* 3074 */
/* 3075 */
/* 3076 */
/* 3077 */
/* 3078 */
/* 3079 */
/* 3080 */
/* 3081 */
/* 3082 */
/* 3083 */
/* 3084 */
/* 3085 */
/* 3085 */
/* 3086 */
/* 3087 */
/* 3088 */
/* 3089 */
/* 3090 */
/* 4000 */
/* 4900 */
/* 4901 */
/* 5001 */
/* 5002 */
/* 5003 */
/* 5004 */
/* 5005 */
/* 5006 */
/* 5007 */
/* 5008 */
/* 5009 */
/* 5010 */
/* 5011 */
/* 5012 */
/* 5013 */
/* 5014 */
/* 5015 */
/* 5016 */
/* 5017 */
/* 5018 */
/* 5019 */
/* 5020 */
/* 5021 */
/* 5022 */
/* 5023 */
/* 5024 */
/* 5025 */
/* 5026 */
/* 5027 */
/* 5028 */
/* 5029 */
/* 5030 */
/* 5031 */
/* 5032 */
/* 5033 */
/* 5034 */
/* 5035 */
/* 5036 */
/* 5037 */
/* 6001 */
/* 6002 */
/* 6003 */
/* 6004 */
/* *
 * xmlGenericErrorFunc:
 * @ctx:  a parsing context
 * @msg:  the message
 * @...:  the extra arguments of the varags to format the message
 *
 * Signature of the function to use when there is an error and
 * no parsing or validity context available .
 */
/* *
 * xmlStructuredErrorFunc:
 * @userData:  user provided data for the error callback
 * @error:  the error being raised.
 *
 * Signature of the function to use when there is an error and
 * the module handles the new error reporting mechanism.
 */
pub type xmlStructuredErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlErrorPtr) -> ()>;
pub type xmlErrorPtr = *mut xmlError;
pub type endElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type startElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *mut *const xmlChar,
                                _: std::os::raw::c_int, _: std::os::raw::c_int,
                                _: *mut *const xmlChar) -> ()>;
pub type externalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type cdataBlockSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type getParameterEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type xmlEntityPtr = *mut xmlEntity;
pub type xmlEntity = _xmlEntity;
/*
 * Summary: interface for the XML entities handling
 * Description: this module provides some of the entity API needed
 *              for the parser and applications.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * The different valid entity types.
 */
/*
 * An unit of storage for an entity, contains the string, the value
 * and the linkind data needed for the linking in the hash table.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEntity {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub orig: *mut xmlChar,
    pub content: *mut xmlChar,
    pub length: std::os::raw::c_int,
    pub etype: xmlEntityType,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub nexte: *mut _xmlEntity,
    pub URI: *const xmlChar,
    pub owner: std::os::raw::c_int,
    pub checked: std::os::raw::c_int,
}
pub type xmlEntityType = std::os::raw::c_uint;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub type fatalErrorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type errorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type warningSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type commentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type processingInstructionSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type ignorableWhitespaceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type charactersSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type referenceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type endElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type startElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *mut *const xmlChar) -> ()>;
pub type endDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type startDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type setDocumentLocatorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlSAXLocatorPtr)
               -> ()>;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXLocator = _xmlSAXLocator;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXLocator {
    pub getPublicId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getSystemId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getLineNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                  -> std::os::raw::c_int>,
    pub getColumnNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                    -> std::os::raw::c_int>,
}
pub type unparsedEntityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type elementDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: xmlElementContentPtr)
               -> ()>;
pub type xmlElementContentPtr = *mut xmlElementContent;
pub type xmlElementContent = _xmlElementContent;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElementContent {
    pub type_0: xmlElementContentType,
    pub ocur: xmlElementContentOccur,
    pub name: *const xmlChar,
    pub c1: *mut _xmlElementContent,
    pub c2: *mut _xmlElementContent,
    pub parent: *mut _xmlElementContent,
    pub prefix: *const xmlChar,
}
pub type xmlElementContentOccur = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub type attributeDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: std::os::raw::c_int,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: xmlEnumerationPtr) -> ()>;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
pub type xmlEnumeration = _xmlEnumeration;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEnumeration {
    pub next: *mut _xmlEnumeration,
    pub name: *const xmlChar,
}
pub type notationDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type entityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: *const xmlChar, _: *mut xmlChar) -> ()>;
pub type getEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type resolveEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlParserInputPtr>;
pub type hasExternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type hasInternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type isStandaloneSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type internalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type xmlParserCtxt = _xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
pub type xmlSAXHandler = _xmlSAXHandler;
pub type xmlSAXHandlerPtr = *mut xmlSAXHandler;
pub type xmlRegexp = _xmlRegexp;
pub type xmlRegexpPtr = *mut xmlRegexp;
pub type xmlRegExecCtxt = _xmlRegExecCtxt;
pub type xmlRegExecCtxtPtr = *mut xmlRegExecCtxt;
/* *
 * xmlRegExecCallbacks:
 * @exec: the regular expression context
 * @token: the current token string
 * @transdata: transition data
 * @inputdata: input data
 *
 * Callback function when doing a transition in the automata
 */
pub type xmlRegExecCallbacks
    =
    Option<unsafe extern "C" fn(_: xmlRegExecCtxtPtr, _: *const xmlChar,
                                _: *mut std::os::raw::c_void, _: *mut std::os::raw::c_void)
               -> ()>;
pub type xmlNsPtr = *mut xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlID {
    pub next: *mut _xmlID,
    pub value: *const xmlChar,
    pub attr: xmlAttrPtr,
    pub name: *const xmlChar,
    pub lineno: std::os::raw::c_int,
    pub doc: *mut _xmlDoc,
}
pub type xmlID = _xmlID;
pub type xmlIDPtr = *mut xmlID;
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */
/* *
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/* *
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
/* *
 * xmlMallocFunc:
 * @size:  the size requested in bytes
 *
 * Signature for a malloc() implementation.
 *
 * Returns a pointer to the newly allocated block or NULL in case of error.
 */
pub type xmlMallocFunc
    =
    Option<unsafe extern "C" fn(_: size_t) -> *mut std::os::raw::c_void>;
/* *
 * xmlReallocFunc:
 * @mem: an already allocated block of memory
 * @size:  the new size requested in bytes
 *
 * Signature for a realloc() implementation.
 *
 * Returns a pointer to the newly reallocated block or NULL in case of error.
 */
pub type xmlReallocFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: size_t)
               -> *mut std::os::raw::c_void>;
/*
 * Recent version of gcc produce a warning when a function pointer is assigned
 * to an object pointer, or vice versa.  The following macro is a dirty hack
 * to allow suppression of the warning.  If your architecture has function
 * pointers which are a different size than a void pointer, there may be some
 * serious trouble within the library.
 */
/* *
 * XML_CAST_FPTR:
 * @fptr:  pointer to a function
 *
 * Macro to do a casting from an object pointer to a
 * function pointer without encountering a warning from
 * gcc
 *
 * #define XML_CAST_FPTR(fptr) (*(void **)(&fptr))
 * This macro violated ISO C aliasing rules (gcc4 on s390 broke)
 * so it is disabled now
 */
/*
 * function types:
 */
/* *
 * xmlHashDeallocator:
 * @payload:  the data in the hash
 * @name:  the name associated
 *
 * Callback to free data from a hash.
 */
pub type xmlHashDeallocator
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
/* *
 * xmlHashScanner:
 * @payload:  the data in the hash
 * @data:  extra scannner data
 * @name:  the name associated
 *
 * Callback when scanning data in a hash with the simple scanner.
 */
pub type xmlHashScanner
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_void,
                                _: *const xmlChar) -> ()>;
/* *
 * xmlHashScannerFull:
 * @payload:  the data in the hash
 * @data:  extra scannner data
 * @name:  the name associated
 * @name2:  the second name associated
 * @name3:  the third name associated
 *
 * Callback when scanning data in a hash with the full scanner.
 */
pub type xmlHashScannerFull
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_void,
                                _: *const xmlChar, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type C2RustUnnamed = std::os::raw::c_uint;
pub const XML_FROM_URI: C2RustUnnamed = 30;
pub const XML_FROM_BUFFER: C2RustUnnamed = 29;
pub const XML_FROM_SCHEMATRONV: C2RustUnnamed = 28;
pub const XML_FROM_I18N: C2RustUnnamed = 27;
pub const XML_FROM_MODULE: C2RustUnnamed = 26;
pub const XML_FROM_WRITER: C2RustUnnamed = 25;
pub const XML_FROM_CHECK: C2RustUnnamed = 24;
pub const XML_FROM_VALID: C2RustUnnamed = 23;
pub const XML_FROM_XSLT: C2RustUnnamed = 22;
pub const XML_FROM_C14N: C2RustUnnamed = 21;
pub const XML_FROM_CATALOG: C2RustUnnamed = 20;
pub const XML_FROM_RELAXNGV: C2RustUnnamed = 19;
pub const XML_FROM_RELAXNGP: C2RustUnnamed = 18;
pub const XML_FROM_SCHEMASV: C2RustUnnamed = 17;
pub const XML_FROM_SCHEMASP: C2RustUnnamed = 16;
pub const XML_FROM_DATATYPE: C2RustUnnamed = 15;
pub const XML_FROM_REGEXP: C2RustUnnamed = 14;
pub const XML_FROM_XPOINTER: C2RustUnnamed = 13;
pub const XML_FROM_XPATH: C2RustUnnamed = 12;
pub const XML_FROM_XINCLUDE: C2RustUnnamed = 11;
pub const XML_FROM_HTTP: C2RustUnnamed = 10;
pub const XML_FROM_FTP: C2RustUnnamed = 9;
pub const XML_FROM_IO: C2RustUnnamed = 8;
pub const XML_FROM_OUTPUT: C2RustUnnamed = 7;
pub const XML_FROM_MEMORY: C2RustUnnamed = 6;
pub const XML_FROM_HTML: C2RustUnnamed = 5;
pub const XML_FROM_DTD: C2RustUnnamed = 4;
pub const XML_FROM_NAMESPACE: C2RustUnnamed = 3;
pub const XML_FROM_TREE: C2RustUnnamed = 2;
pub const XML_FROM_PARSER: C2RustUnnamed = 1;
pub const XML_FROM_NONE: C2RustUnnamed = 0;
pub type xmlParserErrors = std::os::raw::c_uint;
pub const XML_BUF_OVERFLOW: xmlParserErrors = 7000;
pub const XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors =
    3007;
pub const XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors =
    3005;
pub const XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const XML_IO_EALREADY: xmlParserErrors = 1555;
pub const XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const XML_IO_EISCONN: xmlParserErrors = 1551;
pub const XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const XML_IO_WRITE: xmlParserErrors = 1546;
pub const XML_IO_FLUSH: xmlParserErrors = 1545;
pub const XML_IO_ENCODER: xmlParserErrors = 1544;
pub const XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const XML_IO_EXDEV: xmlParserErrors = 1542;
pub const XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const XML_IO_ESRCH: xmlParserErrors = 1540;
pub const XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const XML_IO_EROFS: xmlParserErrors = 1538;
pub const XML_IO_ERANGE: xmlParserErrors = 1537;
pub const XML_IO_EPIPE: xmlParserErrors = 1536;
pub const XML_IO_EPERM: xmlParserErrors = 1535;
pub const XML_IO_ENXIO: xmlParserErrors = 1534;
pub const XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const XML_IO_ENOENT: xmlParserErrors = 1524;
pub const XML_IO_ENODEV: xmlParserErrors = 1523;
pub const XML_IO_ENFILE: xmlParserErrors = 1522;
pub const XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const XML_IO_EMLINK: xmlParserErrors = 1519;
pub const XML_IO_EMFILE: xmlParserErrors = 1518;
pub const XML_IO_EISDIR: xmlParserErrors = 1517;
pub const XML_IO_EIO: xmlParserErrors = 1516;
pub const XML_IO_EINVAL: xmlParserErrors = 1515;
pub const XML_IO_EINTR: xmlParserErrors = 1514;
pub const XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const XML_IO_EFBIG: xmlParserErrors = 1512;
pub const XML_IO_EFAULT: xmlParserErrors = 1511;
pub const XML_IO_EEXIST: xmlParserErrors = 1510;
pub const XML_IO_EDOM: xmlParserErrors = 1509;
pub const XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const XML_IO_ECHILD: xmlParserErrors = 1507;
pub const XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const XML_IO_EBUSY: xmlParserErrors = 1505;
pub const XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const XML_IO_EBADF: xmlParserErrors = 1503;
pub const XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const XML_IO_EACCES: xmlParserErrors = 1501;
pub const XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const XML_WAR_NS_URI: xmlParserErrors = 99;
pub const XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const XML_ERR_OK: xmlParserErrors = 0;
pub type xmlGenericErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlValidCtxtPtr = *mut xmlValidCtxt;
/*
 * Summary: interface for the encoding conversion functions
 * Description: interface for the encoding conversion functions needed for
 *              XML basic encoding and iconv() support.
 *
 * Related specs are
 * rfc2044        (UTF-8 and UTF-16) F. Yergeau Alis Technologies
 * [ISO-10646]    UTF-8 and UTF-16 in Annexes
 * [ISO-8859-1]   ISO Latin-1 characters codes.
 * [UNICODE]      The Unicode Consortium, "The Unicode Standard --
 *                Worldwide Character Encoding -- Version 1.0", Addison-
 *                Wesley, Volume 1, 1991, Volume 2, 1992.  UTF-8 is
 *                described in Unicode Technical Report #4.
 * [US-ASCII]     Coded Character Set--7-bit American Standard Code for
 *                Information Interchange, ANSI X3.4-1986.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * xmlCharEncoding:
 *
 * Predefined values for some standard encodings.
 * Libxml does not do beforehand translation on UTF8 and ISOLatinX.
 * It also supports ASCII, ISO-8859-1, and UTF16 (LE and BE) by default.
 *
 * Anything else would have to be translated to UTF8 before being
 * given to the parser itself. The BOM for UTF16 and the encoding
 * declaration are looked at and a converter is looked for at that
 * point. If not found the parser stops here as asked by the XML REC. A
 * converter can be registered by the user using xmlRegisterCharEncodingHandler
 * but the current form doesn't allow stateful transcoding (a serious
 * problem agreed !). If iconv has been found it will be used
 * automatically and allow stateful transcoding, the simplest is then
 * to be sure to enable iconv and to provide iconv libs for the encoding
 * support needed.
 *
 * Note that the generic "UTF-16" is not a predefined value.  Instead, only
 * the specific UTF-16LE and UTF-16BE are present.
 */
pub type xmlCharEncoding = std::os::raw::c_int;
/* pure ASCII */
/* EUC-JP */
pub const XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
/* Shift_JIS */
pub const XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
/* ISO-2022-JP */
pub const XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
/* ISO-8859-9 */
pub const XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
/* ISO-8859-8 */
pub const XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
/* ISO-8859-7 */
pub const XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
/* ISO-8859-6 */
pub const XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
/* ISO-8859-5 */
pub const XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
/* ISO-8859-4 */
pub const XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
/* ISO-8859-3 */
pub const XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
/* ISO-8859-2 ISO Latin 2 */
pub const XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
/* ISO-8859-1 ISO Latin 1 */
pub const XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
/* UCS-2 */
pub const XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
/* UCS-4 unusual ordering */
pub const XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
/* UCS-4 unusual ordering */
pub const XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
/* EBCDIC uh! */
pub const XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
/* UCS-4 big endian */
pub const XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
/* UCS-4 little endian */
pub const XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
/* UTF-16 big endian */
pub const XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
/* UTF-16 little endian */
pub const XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
/* UTF-8 */
pub const XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
/* No char encoding detected */
pub const XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
/* No char encoding detected */
pub const XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
/*
 * New set of simpler/more flexible APIs
 */
/* *
 * xmlParserOption:
 *
 * This is the set of XML parser options that can be passed down
 * to the xmlReadDoc() and similar calls.
 */
pub type C2RustUnnamed_0 = std::os::raw::c_uint;
/* Store big lines numbers in text PSVI field */
/* ignore internal document encoding hint */
pub const XML_PARSE_BIG_LINES: C2RustUnnamed_0 = 4194304;
/* parse using SAX2 interface before 2.7.0 */
pub const XML_PARSE_IGNORE_ENC: C2RustUnnamed_0 = 2097152;
/* relax any hardcoded limit from the parser */
pub const XML_PARSE_OLDSAX: C2RustUnnamed_0 = 1048576;
/* do not fixup XINCLUDE xml:base uris */
pub const XML_PARSE_HUGE: C2RustUnnamed_0 = 524288;
/* parse using XML-1.0 before update 5 */
pub const XML_PARSE_NOBASEFIX: C2RustUnnamed_0 = 262144;
/* compact small text nodes; no modification of
                                   the tree allowed afterwards (will possibly
				   crash if you try to modify the tree) */
pub const XML_PARSE_OLD10: C2RustUnnamed_0 = 131072;
/* do not generate XINCLUDE START/END nodes */
pub const XML_PARSE_COMPACT: C2RustUnnamed_0 = 65536;
/* merge CDATA as text nodes */
pub const XML_PARSE_NOXINCNODE: C2RustUnnamed_0 = 32768;
/* remove redundant namespaces declarations */
pub const XML_PARSE_NOCDATA: C2RustUnnamed_0 = 16384;
/* Do not reuse the context dictionary */
pub const XML_PARSE_NSCLEAN: C2RustUnnamed_0 = 8192;
/* Forbid network access */
pub const XML_PARSE_NODICT: C2RustUnnamed_0 = 4096;
/* Implement XInclude substitition  */
pub const XML_PARSE_NONET: C2RustUnnamed_0 = 2048;
/* use the SAX1 interface internally */
pub const XML_PARSE_XINCLUDE: C2RustUnnamed_0 = 1024;
/* remove blank nodes */
pub const XML_PARSE_SAX1: C2RustUnnamed_0 = 512;
/* pedantic error reporting */
pub const XML_PARSE_NOBLANKS: C2RustUnnamed_0 = 256;
/* suppress warning reports */
pub const XML_PARSE_PEDANTIC: C2RustUnnamed_0 = 128;
/* suppress error reports */
pub const XML_PARSE_NOWARNING: C2RustUnnamed_0 = 64;
/* validate with the DTD */
pub const XML_PARSE_NOERROR: C2RustUnnamed_0 = 32;
/* default DTD attributes */
pub const XML_PARSE_DTDVALID: C2RustUnnamed_0 = 16;
/* load the external subset */
pub const XML_PARSE_DTDATTR: C2RustUnnamed_0 = 8;
/* substitute entities */
pub const XML_PARSE_DTDLOAD: C2RustUnnamed_0 = 4;
/* recover on errors */
pub const XML_PARSE_NOENT: C2RustUnnamed_0 = 2;
pub const XML_PARSE_RECOVER: C2RustUnnamed_0 = 1;
/*
 * Summary: implementation of the Relax-NG validation
 * Description: implementation of the Relax-NG validation
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
pub type xmlRelaxNG = _xmlRelaxNG;
pub type xmlRelaxNGPtr = *mut xmlRelaxNG;
pub type xmlRelaxNGValidCtxt = _xmlRelaxNGValidCtxt;
pub type xmlRelaxNGValidCtxtPtr = *mut xmlRelaxNGValidCtxt;
pub type C2RustUnnamed_1 = std::os::raw::c_uint;
pub const XML_SCHEMA_VAL_VC_I_CREATE: C2RustUnnamed_1 = 1;
/* *
 * _xmlSchema:
 *
 * A Schemas definition
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchema {
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub version: *const xmlChar,
    pub id: *const xmlChar,
    pub doc: xmlDocPtr,
    pub annot: xmlSchemaAnnotPtr,
    pub flags: std::os::raw::c_int,
    pub typeDecl: xmlHashTablePtr,
    pub attrDecl: xmlHashTablePtr,
    pub attrgrpDecl: xmlHashTablePtr,
    pub elemDecl: xmlHashTablePtr,
    pub notaDecl: xmlHashTablePtr,
    pub schemasImports: xmlHashTablePtr,
    pub _private: *mut std::os::raw::c_void,
    pub groupDecl: xmlHashTablePtr,
    pub dict: xmlDictPtr,
    pub includes: *mut std::os::raw::c_void,
    pub preserve: std::os::raw::c_int,
    pub counter: std::os::raw::c_int,
    pub idcDef: xmlHashTablePtr,
    pub volatiles: *mut std::os::raw::c_void,
}
pub type xmlSchemaAnnotPtr = *mut xmlSchemaAnnot;
/* *
 * Annotation
 */
pub type xmlSchemaAnnot = _xmlSchemaAnnot;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnot {
    pub next: *mut _xmlSchemaAnnot,
    pub content: xmlNodePtr,
}
pub type xmlSchema = _xmlSchema;
pub type xmlSchemaPtr = *mut xmlSchema;
pub type xmlSchemaValidityErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlSchemaValidityWarningFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaParserCtxt {
    pub type_0: std::os::raw::c_int,
    pub errCtxt: *mut std::os::raw::c_void,
    pub error: xmlSchemaValidityErrorFunc,
    pub warning: xmlSchemaValidityWarningFunc,
    pub err: std::os::raw::c_int,
    pub nberrors: std::os::raw::c_int,
    pub serror: xmlStructuredErrorFunc,
    pub constructor: xmlSchemaConstructionCtxtPtr,
    pub ownsConstructor: std::os::raw::c_int,
    pub schema: xmlSchemaPtr,
    pub counter: std::os::raw::c_int,
    pub URL: *const xmlChar,
    pub doc: xmlDocPtr,
    pub preserve: std::os::raw::c_int,
    pub buffer: *const std::os::raw::c_char,
    pub size: std::os::raw::c_int,
    pub am: xmlAutomataPtr,
    pub start: xmlAutomataStatePtr,
    pub end: xmlAutomataStatePtr,
    pub state: xmlAutomataStatePtr,
    pub dict: xmlDictPtr,
    pub ctxtType: xmlSchemaTypePtr,
    pub options: std::os::raw::c_int,
    pub vctxt: xmlSchemaValidCtxtPtr,
    pub isS4S: std::os::raw::c_int,
    pub isRedefine: std::os::raw::c_int,
    pub xsiAssemble: std::os::raw::c_int,
    pub stop: std::os::raw::c_int,
    pub targetNamespace: *const xmlChar,
    pub redefined: xmlSchemaBucketPtr,
    pub redef: xmlSchemaRedefPtr,
    pub redefCounter: std::os::raw::c_int,
    pub attrProhibs: xmlSchemaItemListPtr,
}
pub type xmlSchemaItemListPtr = *mut xmlSchemaItemList;
pub type xmlSchemaItemList = _xmlSchemaItemList;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaItemList {
    pub items: *mut *mut std::os::raw::c_void,
    pub nbItems: std::os::raw::c_int,
    pub sizeItems: std::os::raw::c_int,
}
pub type xmlSchemaRedefPtr = *mut xmlSchemaRedef;
/* *
 * xmlSchemaRedef:
 */
pub type xmlSchemaRedef = _xmlSchemaRedef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaRedef {
    pub next: xmlSchemaRedefPtr,
    pub item: xmlSchemaBasicItemPtr,
    pub reference: xmlSchemaBasicItemPtr,
    pub target: xmlSchemaBasicItemPtr,
    pub refName: *const xmlChar,
    pub refTargetNs: *const xmlChar,
    pub targetBucket: xmlSchemaBucketPtr,
}
pub type xmlSchemaBucketPtr = *mut xmlSchemaBucket;
/* Fix alignment issues */
pub type xmlSchemaBucket = _xmlSchemaBucket;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaBucket {
    pub type_0: std::os::raw::c_int,
    pub flags: std::os::raw::c_int,
    pub schemaLocation: *const xmlChar,
    pub origTargetNamespace: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub doc: xmlDocPtr,
    pub relations: xmlSchemaSchemaRelationPtr,
    pub located: std::os::raw::c_int,
    pub parsed: std::os::raw::c_int,
    pub imported: std::os::raw::c_int,
    pub preserveDoc: std::os::raw::c_int,
    pub globals: xmlSchemaItemListPtr,
    pub locals: xmlSchemaItemListPtr,
}
pub type xmlSchemaSchemaRelationPtr = *mut xmlSchemaSchemaRelation;
/* *
 * xmlSchemaSchemaRelation:
 *
 * Used to create a graph of schema relationships.
 */
pub type xmlSchemaSchemaRelation = _xmlSchemaSchemaRelation;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSchemaRelation {
    pub next: xmlSchemaSchemaRelationPtr,
    pub type_0: std::os::raw::c_int,
    pub importNamespace: *const xmlChar,
    pub bucket: xmlSchemaBucketPtr,
}
pub type xmlSchemaBasicItemPtr = *mut xmlSchemaBasicItem;
/* *
 * xmlSchemaBasicItem:
 *
 * The abstract base type for schema components.
 */
pub type xmlSchemaBasicItem = _xmlSchemaBasicItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaBasicItem {
    pub type_0: xmlSchemaTypeType,
    pub dummy: *mut std::os::raw::c_void,
}
pub type xmlSchemaTypeType = std::os::raw::c_uint;
pub const XML_SCHEMA_EXTRA_ATTR_USE_PROHIB: xmlSchemaTypeType = 2001;
pub const XML_SCHEMA_EXTRA_QNAMEREF: xmlSchemaTypeType = 2000;
pub const XML_SCHEMA_FACET_MINLENGTH: xmlSchemaTypeType = 1011;
pub const XML_SCHEMA_FACET_MAXLENGTH: xmlSchemaTypeType = 1010;
pub const XML_SCHEMA_FACET_LENGTH: xmlSchemaTypeType = 1009;
pub const XML_SCHEMA_FACET_WHITESPACE: xmlSchemaTypeType = 1008;
pub const XML_SCHEMA_FACET_ENUMERATION: xmlSchemaTypeType = 1007;
pub const XML_SCHEMA_FACET_PATTERN: xmlSchemaTypeType = 1006;
pub const XML_SCHEMA_FACET_FRACTIONDIGITS: xmlSchemaTypeType = 1005;
pub const XML_SCHEMA_FACET_TOTALDIGITS: xmlSchemaTypeType = 1004;
pub const XML_SCHEMA_FACET_MAXEXCLUSIVE: xmlSchemaTypeType = 1003;
pub const XML_SCHEMA_FACET_MAXINCLUSIVE: xmlSchemaTypeType = 1002;
pub const XML_SCHEMA_FACET_MINEXCLUSIVE: xmlSchemaTypeType = 1001;
pub const XML_SCHEMA_FACET_MININCLUSIVE: xmlSchemaTypeType = 1000;
pub const XML_SCHEMA_TYPE_ATTRIBUTE_USE: xmlSchemaTypeType = 26;
pub const XML_SCHEMA_TYPE_PARTICLE: xmlSchemaTypeType = 25;
pub const XML_SCHEMA_TYPE_IDC_KEYREF: xmlSchemaTypeType = 24;
pub const XML_SCHEMA_TYPE_IDC_KEY: xmlSchemaTypeType = 23;
pub const XML_SCHEMA_TYPE_IDC_UNIQUE: xmlSchemaTypeType = 22;
pub const XML_SCHEMA_TYPE_ANY_ATTRIBUTE: xmlSchemaTypeType = 21;
pub const XML_SCHEMA_TYPE_UNION: xmlSchemaTypeType = 20;
pub const XML_SCHEMA_TYPE_LIST: xmlSchemaTypeType = 19;
pub const XML_SCHEMA_TYPE_NOTATION: xmlSchemaTypeType = 18;
pub const XML_SCHEMA_TYPE_GROUP: xmlSchemaTypeType = 17;
pub const XML_SCHEMA_TYPE_ATTRIBUTEGROUP: xmlSchemaTypeType = 16;
pub const XML_SCHEMA_TYPE_ATTRIBUTE: xmlSchemaTypeType = 15;
pub const XML_SCHEMA_TYPE_ELEMENT: xmlSchemaTypeType = 14;
pub const XML_SCHEMA_TYPE_EXTENSION: xmlSchemaTypeType = 13;
pub const XML_SCHEMA_TYPE_RESTRICTION: xmlSchemaTypeType = 12;
pub const XML_SCHEMA_TYPE_UR: xmlSchemaTypeType = 11;
pub const XML_SCHEMA_TYPE_COMPLEX_CONTENT: xmlSchemaTypeType = 10;
pub const XML_SCHEMA_TYPE_SIMPLE_CONTENT: xmlSchemaTypeType = 9;
pub const XML_SCHEMA_TYPE_ALL: xmlSchemaTypeType = 8;
pub const XML_SCHEMA_TYPE_CHOICE: xmlSchemaTypeType = 7;
pub const XML_SCHEMA_TYPE_SEQUENCE: xmlSchemaTypeType = 6;
pub const XML_SCHEMA_TYPE_COMPLEX: xmlSchemaTypeType = 5;
pub const XML_SCHEMA_TYPE_SIMPLE: xmlSchemaTypeType = 4;
pub const XML_SCHEMA_TYPE_FACET: xmlSchemaTypeType = 3;
pub const XML_SCHEMA_TYPE_ANY: xmlSchemaTypeType = 2;
pub const XML_SCHEMA_TYPE_BASIC: xmlSchemaTypeType = 1;
pub type xmlSchemaValidCtxtPtr = *mut xmlSchemaValidCtxt;
pub type xmlSchemaValidCtxt = _xmlSchemaValidCtxt;
/* *
 * xmlSchemaValidCtxt:
 *
 * A Schemas validation context
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaValidCtxt {
    pub type_0: std::os::raw::c_int,
    pub errCtxt: *mut std::os::raw::c_void,
    pub error: xmlSchemaValidityErrorFunc,
    pub warning: xmlSchemaValidityWarningFunc,
    pub serror: xmlStructuredErrorFunc,
    pub schema: xmlSchemaPtr,
    pub doc: xmlDocPtr,
    pub input: xmlParserInputBufferPtr,
    pub enc: xmlCharEncoding,
    pub sax: xmlSAXHandlerPtr,
    pub parserCtxt: xmlParserCtxtPtr,
    pub user_data: *mut std::os::raw::c_void,
    pub filename: *mut std::os::raw::c_char,
    pub err: std::os::raw::c_int,
    pub nberrors: std::os::raw::c_int,
    pub node: xmlNodePtr,
    pub cur: xmlNodePtr,
    pub regexp: xmlRegExecCtxtPtr,
    pub value: xmlSchemaValPtr,
    pub valueWS: std::os::raw::c_int,
    pub options: std::os::raw::c_int,
    pub validationRoot: xmlNodePtr,
    pub pctxt: xmlSchemaParserCtxtPtr,
    pub xsiAssemble: std::os::raw::c_int,
    pub depth: std::os::raw::c_int,
    pub elemInfos: *mut xmlSchemaNodeInfoPtr,
    pub sizeElemInfos: std::os::raw::c_int,
    pub inode: xmlSchemaNodeInfoPtr,
    pub aidcs: xmlSchemaIDCAugPtr,
    pub xpathStates: xmlSchemaIDCStateObjPtr,
    pub xpathStatePool: xmlSchemaIDCStateObjPtr,
    pub idcMatcherCache: xmlSchemaIDCMatcherPtr,
    pub idcNodes: *mut xmlSchemaPSVIIDCNodePtr,
    pub nbIdcNodes: std::os::raw::c_int,
    pub sizeIdcNodes: std::os::raw::c_int,
    pub idcKeys: *mut xmlSchemaPSVIIDCKeyPtr,
    pub nbIdcKeys: std::os::raw::c_int,
    pub sizeIdcKeys: std::os::raw::c_int,
    pub flags: std::os::raw::c_int,
    pub dict: xmlDictPtr,
    pub reader: xmlTextReaderPtr,
    pub attrInfos: *mut xmlSchemaAttrInfoPtr,
    pub nbAttrInfos: std::os::raw::c_int,
    pub sizeAttrInfos: std::os::raw::c_int,
    pub skipDepth: std::os::raw::c_int,
    pub nodeQNames: xmlSchemaItemListPtr,
    pub hasKeyrefs: std::os::raw::c_int,
    pub createIDCNodeTables: std::os::raw::c_int,
    pub psviExposeIDCNodeTables: std::os::raw::c_int,
    pub locFunc: xmlSchemaValidityLocatorFunc,
    pub locCtxt: *mut std::os::raw::c_void,
}
pub type xmlSchemaValidityLocatorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                _: *mut *const std::os::raw::c_char,
                                _: *mut std::os::raw::c_ulong) -> std::os::raw::c_int>;
pub type xmlSchemaAttrInfoPtr = *mut xmlSchemaAttrInfo;
pub type xmlSchemaAttrInfo = _xmlSchemaAttrInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttrInfo {
    pub nodeType: std::os::raw::c_int,
    pub node: xmlNodePtr,
    pub nodeLine: std::os::raw::c_int,
    pub localName: *const xmlChar,
    pub nsName: *const xmlChar,
    pub value: *const xmlChar,
    pub val: xmlSchemaValPtr,
    pub typeDef: xmlSchemaTypePtr,
    pub flags: std::os::raw::c_int,
    pub decl: xmlSchemaAttributePtr,
    pub use_0: xmlSchemaAttributeUsePtr,
    pub state: std::os::raw::c_int,
    pub metaType: std::os::raw::c_int,
    pub vcValue: *const xmlChar,
    pub parent: xmlSchemaNodeInfoPtr,
}
pub type xmlSchemaNodeInfoPtr = *mut xmlSchemaNodeInfo;
pub type xmlSchemaNodeInfo = _xmlSchemaNodeInfo;
/* *
 * xmlSchemaNodeInfo:
 *
 * Holds information of an element node.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaNodeInfo {
    pub nodeType: std::os::raw::c_int,
    pub node: xmlNodePtr,
    pub nodeLine: std::os::raw::c_int,
    pub localName: *const xmlChar,
    pub nsName: *const xmlChar,
    pub value: *const xmlChar,
    pub val: xmlSchemaValPtr,
    pub typeDef: xmlSchemaTypePtr,
    pub flags: std::os::raw::c_int,
    pub valNeeded: std::os::raw::c_int,
    pub normVal: std::os::raw::c_int,
    pub decl: xmlSchemaElementPtr,
    pub depth: std::os::raw::c_int,
    pub idcTable: xmlSchemaPSVIIDCBindingPtr,
    pub idcMatchers: xmlSchemaIDCMatcherPtr,
    pub regexCtxt: xmlRegExecCtxtPtr,
    pub nsBindings: *mut *const xmlChar,
    pub nbNsBindings: std::os::raw::c_int,
    pub sizeNsBindings: std::os::raw::c_int,
    pub hasKeyrefs: std::os::raw::c_int,
    pub appliedXPath: std::os::raw::c_int,
}
pub type xmlSchemaIDCMatcherPtr = *mut xmlSchemaIDCMatcher;
pub type xmlSchemaIDCMatcher = _xmlSchemaIDCMatcher;
/* *
 * xmlSchemaIDCMatcher:
 *
 * Used to evaluate IDC selectors (and fields).
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCMatcher {
    pub type_0: std::os::raw::c_int,
    pub depth: std::os::raw::c_int,
    pub next: xmlSchemaIDCMatcherPtr,
    pub nextCached: xmlSchemaIDCMatcherPtr,
    pub aidc: xmlSchemaIDCAugPtr,
    pub idcType: std::os::raw::c_int,
    pub keySeqs: *mut *mut xmlSchemaPSVIIDCKeyPtr,
    pub sizeKeySeqs: std::os::raw::c_int,
    pub targets: xmlSchemaItemListPtr,
}
pub type xmlSchemaPSVIIDCKeyPtr = *mut xmlSchemaPSVIIDCKey;
/* the lowest tree level to which IDC
                        tables need to be bubbled upwards */
/* *
 * xmlSchemaPSVIIDCKeySequence:
 *
 * The key sequence of a node table item.
 */
pub type xmlSchemaPSVIIDCKey = _xmlSchemaPSVIIDCKey;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCKey {
    pub type_0: xmlSchemaTypePtr,
    pub val: xmlSchemaValPtr,
}
pub type xmlSchemaValPtr = *mut xmlSchemaVal;
pub type xmlSchemaVal = _xmlSchemaVal;
pub type xmlSchemaTypePtr = *mut xmlSchemaType;
pub type xmlSchemaType = _xmlSchemaType;
/* *
 * XML_SCHEMAS_TYPE_REDEFINING:
 *
 * The type redefines an other type.
 */
/* #define XML_SCHEMAS_TYPE_REDEFINING    1 << 31 */
/* *
 * _xmlSchemaType:
 *
 * Schemas type definition.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaType {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaType,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub subtypes: xmlSchemaTypePtr,
    pub attributes: xmlSchemaAttributePtr,
    pub node: xmlNodePtr,
    pub minOccurs: std::os::raw::c_int,
    pub maxOccurs: std::os::raw::c_int,
    pub flags: std::os::raw::c_int,
    pub contentType: xmlSchemaContentType,
    pub base: *const xmlChar,
    pub baseNs: *const xmlChar,
    pub baseType: xmlSchemaTypePtr,
    pub facets: xmlSchemaFacetPtr,
    pub redef: *mut _xmlSchemaType,
    pub recurse: std::os::raw::c_int,
    pub attributeUses: *mut xmlSchemaAttributeLinkPtr,
    pub attributeWildcard: xmlSchemaWildcardPtr,
    pub builtInType: std::os::raw::c_int,
    pub memberTypes: xmlSchemaTypeLinkPtr,
    pub facetSet: xmlSchemaFacetLinkPtr,
    pub refPrefix: *const xmlChar,
    pub contentTypeDef: xmlSchemaTypePtr,
    pub contModel: xmlRegexpPtr,
    pub targetNamespace: *const xmlChar,
    pub attrUses: *mut std::os::raw::c_void,
}
pub type xmlSchemaFacetLinkPtr = *mut xmlSchemaFacetLink;
/* the linked type */
/* *
 * xmlSchemaFacetLink:
 * Used to build a list of facets.
 */
pub type xmlSchemaFacetLink = _xmlSchemaFacetLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaFacetLink {
    pub next: *mut _xmlSchemaFacetLink,
    pub facet: xmlSchemaFacetPtr,
}
pub type xmlSchemaFacetPtr = *mut xmlSchemaFacet;
pub type xmlSchemaFacet = _xmlSchemaFacet;
/* *
 * A facet definition.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaFacet {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaFacet,
    pub value: *const xmlChar,
    pub id: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub node: xmlNodePtr,
    pub fixed: std::os::raw::c_int,
    pub whitespace: std::os::raw::c_int,
    pub val: xmlSchemaValPtr,
    pub regexp: xmlRegexpPtr,
}
pub type xmlSchemaTypeLinkPtr = *mut xmlSchemaTypeLink;
/* *
 * xmlSchemaTypeLink:
 * Used to build a list of types (e.g. member types of
 * simpleType with variety "union").
 */
pub type xmlSchemaTypeLink = _xmlSchemaTypeLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaTypeLink {
    pub next: *mut _xmlSchemaTypeLink,
    pub type_0: xmlSchemaTypePtr,
}
pub type xmlSchemaWildcardPtr = *mut xmlSchemaWildcard;
/* the value */
/* *
 * xmlSchemaWildcard.
 * A wildcard.
 */
pub type xmlSchemaWildcard = _xmlSchemaWildcard;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaWildcard {
    pub type_0: xmlSchemaTypeType,
    pub id: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub node: xmlNodePtr,
    pub minOccurs: std::os::raw::c_int,
    pub maxOccurs: std::os::raw::c_int,
    pub processContents: std::os::raw::c_int,
    pub any: std::os::raw::c_int,
    pub nsSet: xmlSchemaWildcardNsPtr,
    pub negNsSet: xmlSchemaWildcardNsPtr,
    pub flags: std::os::raw::c_int,
}
pub type xmlSchemaWildcardNsPtr = *mut xmlSchemaWildcardNs;
/* the linked attribute */
/* *
 * XML_SCHEMAS_WILDCARD_COMPLETE:
 *
 * If the wildcard is complete.
 */
/* *
 * xmlSchemaCharValueLink:
 * Used to build a list of namespaces on wildcards.
 */
pub type xmlSchemaWildcardNs = _xmlSchemaWildcardNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaWildcardNs {
    pub next: *mut _xmlSchemaWildcardNs,
    pub value: *const xmlChar,
}
pub type xmlSchemaAttributeLinkPtr = *mut xmlSchemaAttributeLink;
/* Deprecated; not used */
/* *
 * xmlSchemaAttributeLink:
 * Used to build a list of attribute uses on complexType definitions.
 * WARNING: Deprecated; not used.
 */
pub type xmlSchemaAttributeLink = _xmlSchemaAttributeLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeLink {
    pub next: *mut _xmlSchemaAttributeLink,
    pub attr: *mut _xmlSchemaAttribute,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttribute {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaAttribute,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub typeName: *const xmlChar,
    pub typeNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub base: xmlSchemaTypePtr,
    pub occurs: std::os::raw::c_int,
    pub defValue: *const xmlChar,
    pub subtypes: xmlSchemaTypePtr,
    pub node: xmlNodePtr,
    pub targetNamespace: *const xmlChar,
    pub flags: std::os::raw::c_int,
    pub refPrefix: *const xmlChar,
    pub defVal: xmlSchemaValPtr,
    pub refDecl: xmlSchemaAttributePtr,
}
pub type xmlSchemaAttributePtr = *mut xmlSchemaAttribute;
/* *
 * xmlSchemaAttribute:
 * An attribute definition.
 */
pub type xmlSchemaAttribute = _xmlSchemaAttribute;
pub type xmlSchemaContentType = std::os::raw::c_uint;
pub const XML_SCHEMA_CONTENT_ANY: xmlSchemaContentType = 7;
pub const XML_SCHEMA_CONTENT_BASIC: xmlSchemaContentType = 6;
pub const XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS: xmlSchemaContentType = 5;
pub const XML_SCHEMA_CONTENT_SIMPLE: xmlSchemaContentType = 4;
pub const XML_SCHEMA_CONTENT_MIXED: xmlSchemaContentType = 3;
pub const XML_SCHEMA_CONTENT_ELEMENTS: xmlSchemaContentType = 2;
pub const XML_SCHEMA_CONTENT_EMPTY: xmlSchemaContentType = 1;
pub const XML_SCHEMA_CONTENT_UNKNOWN: xmlSchemaContentType = 0;
pub type xmlSchemaIDCAugPtr = *mut xmlSchemaIDCAug;
/* *
 * xmlSchemaIDCAug:
 *
 * The augmented IDC information used for validation.
 */
pub type xmlSchemaIDCAug = _xmlSchemaIDCAug;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCAug {
    pub next: xmlSchemaIDCAugPtr,
    pub def: xmlSchemaIDCPtr,
    pub keyrefDepth: std::os::raw::c_int,
}
pub type xmlSchemaIDCPtr = *mut xmlSchemaIDC;
pub type xmlSchemaIDC = _xmlSchemaIDC;
/* the compiled XPath expression */
/* *
 * xmlSchemaIDC:
 *
 * The identity-constraint definition component.
 * (Extends xmlSchemaAnnotItem)
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDC {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaIDCPtr,
    pub node: xmlNodePtr,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub selector: xmlSchemaIDCSelectPtr,
    pub fields: xmlSchemaIDCSelectPtr,
    pub nbFields: std::os::raw::c_int,
    pub ref_0: xmlSchemaQNameRefPtr,
}
pub type xmlSchemaQNameRefPtr = *mut xmlSchemaQNameRef;
/* *
 * xmlSchemaQNameRef:
 *
 * A component reference item (not a schema component)
 * (Extends xmlSchemaBasicItem)
 */
pub type xmlSchemaQNameRef = _xmlSchemaQNameRef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaQNameRef {
    pub type_0: xmlSchemaTypeType,
    pub item: xmlSchemaBasicItemPtr,
    pub itemType: xmlSchemaTypeType,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub node: xmlNodePtr,
}
pub type xmlSchemaIDCSelectPtr = *mut xmlSchemaIDCSelect;
/* *
 * xmlSchemaIDCSelect:
 *
 * The identity-constraint "field" and "selector" item, holding the
 * XPath expression.
 */
pub type xmlSchemaIDCSelect = _xmlSchemaIDCSelect;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCSelect {
    pub next: xmlSchemaIDCSelectPtr,
    pub idc: xmlSchemaIDCPtr,
    pub index: std::os::raw::c_int,
    pub xpath: *const xmlChar,
    pub xpathComp: *mut std::os::raw::c_void,
}
pub type xmlSchemaPSVIIDCBindingPtr = *mut xmlSchemaPSVIIDCBinding;
/* *
 * xmlSchemaPSVIIDCBinding:
 *
 * The identity-constraint binding item of the [identity-constraint table].
 */
pub type xmlSchemaPSVIIDCBinding = _xmlSchemaPSVIIDCBinding;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCBinding {
    pub next: xmlSchemaPSVIIDCBindingPtr,
    pub definition: xmlSchemaIDCPtr,
    pub nodeTable: *mut xmlSchemaPSVIIDCNodePtr,
    pub nbNodes: std::os::raw::c_int,
    pub sizeNodes: std::os::raw::c_int,
    pub dupls: xmlSchemaItemListPtr,
}
pub type xmlSchemaPSVIIDCNodePtr = *mut xmlSchemaPSVIIDCNode;
/* *
 * xmlSchemaPSVIIDCNode:
 *
 * The node table item of a node table.
 */
pub type xmlSchemaPSVIIDCNode = _xmlSchemaPSVIIDCNode;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCNode {
    pub node: xmlNodePtr,
    pub keys: *mut xmlSchemaPSVIIDCKeyPtr,
    pub nodeLine: std::os::raw::c_int,
    pub nodeQNameID: std::os::raw::c_int,
}
pub type xmlSchemaElementPtr = *mut xmlSchemaElement;
pub type xmlSchemaElement = _xmlSchemaElement;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaElement {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaType,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub subtypes: xmlSchemaTypePtr,
    pub attributes: xmlSchemaAttributePtr,
    pub node: xmlNodePtr,
    pub minOccurs: std::os::raw::c_int,
    pub maxOccurs: std::os::raw::c_int,
    pub flags: std::os::raw::c_int,
    pub targetNamespace: *const xmlChar,
    pub namedType: *const xmlChar,
    pub namedTypeNs: *const xmlChar,
    pub substGroup: *const xmlChar,
    pub substGroupNs: *const xmlChar,
    pub scope: *const xmlChar,
    pub value: *const xmlChar,
    pub refDecl: *mut _xmlSchemaElement,
    pub contModel: xmlRegexpPtr,
    pub contentType: xmlSchemaContentType,
    pub refPrefix: *const xmlChar,
    pub defVal: xmlSchemaValPtr,
    pub idcs: *mut std::os::raw::c_void,
}
pub type xmlSchemaAttributeUsePtr = *mut xmlSchemaAttributeUse;
/* *
 * xmlSchemaAttributeUsePtr:
 *
 * The abstract base type for tree-like structured schema components.
 * (Extends xmlSchemaTreeItem)
 */
pub type xmlSchemaAttributeUse = _xmlSchemaAttributeUse;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeUse {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaAttributeUsePtr,
    pub attrDecl: xmlSchemaAttributePtr,
    pub flags: std::os::raw::c_int,
    pub node: xmlNodePtr,
    pub occurs: std::os::raw::c_int,
    pub defValue: *const xmlChar,
    pub defVal: xmlSchemaValPtr,
}
pub type xmlTextReaderPtr = *mut xmlTextReader;
pub type xmlTextReader = _xmlTextReader;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlTextReader {
    pub mode: std::os::raw::c_int,
    pub doc: xmlDocPtr,
    pub validate: xmlTextReaderValidate,
    pub allocs: std::os::raw::c_int,
    pub state: xmlTextReaderState,
    pub ctxt: xmlParserCtxtPtr,
    pub sax: xmlSAXHandlerPtr,
    pub input: xmlParserInputBufferPtr,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub characters: charactersSAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub base: std::os::raw::c_uint,
    pub cur: std::os::raw::c_uint,
    pub node: xmlNodePtr,
    pub curnode: xmlNodePtr,
    pub depth: std::os::raw::c_int,
    pub faketext: xmlNodePtr,
    pub preserve: std::os::raw::c_int,
    pub buffer: xmlBufPtr,
    pub dict: xmlDictPtr,
    pub ent: xmlNodePtr,
    pub entNr: std::os::raw::c_int,
    pub entMax: std::os::raw::c_int,
    pub entTab: *mut xmlNodePtr,
    pub errorFunc: xmlTextReaderErrorFunc,
    pub errorFuncArg: *mut std::os::raw::c_void,
    pub rngSchemas: xmlRelaxNGPtr,
    pub rngValidCtxt: xmlRelaxNGValidCtxtPtr,
    pub rngPreserveCtxt: std::os::raw::c_int,
    pub rngValidErrors: std::os::raw::c_int,
    pub rngFullNode: xmlNodePtr,
    pub xsdSchemas: xmlSchemaPtr,
    pub xsdValidCtxt: xmlSchemaValidCtxtPtr,
    pub xsdPreserveCtxt: std::os::raw::c_int,
    pub xsdValidErrors: std::os::raw::c_int,
    pub xsdPlug: xmlSchemaSAXPlugPtr,
    pub xinclude: std::os::raw::c_int,
    pub xinclude_name: *const xmlChar,
    pub xincctxt: xmlXIncludeCtxtPtr,
    pub in_xinclude: std::os::raw::c_int,
    pub patternNr: std::os::raw::c_int,
    pub patternMax: std::os::raw::c_int,
    pub patternTab: *mut xmlPatternPtr,
    pub preserves: std::os::raw::c_int,
    pub parserFlags: std::os::raw::c_int,
    pub sErrorFunc: xmlStructuredErrorFunc,
}
pub type xmlPatternPtr = *mut xmlPattern;
pub type xmlPattern = _xmlPattern;
pub type xmlXIncludeCtxtPtr = *mut xmlXIncludeCtxt;
pub type xmlXIncludeCtxt = _xmlXIncludeCtxt;
pub type xmlSchemaSAXPlugPtr = *mut xmlSchemaSAXPlugStruct;
pub type xmlSchemaSAXPlugStruct = _xmlSchemaSAXPlug;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSAXPlug {
    pub magic: std::os::raw::c_uint,
    pub user_sax_ptr: *mut xmlSAXHandlerPtr,
    pub user_sax: xmlSAXHandlerPtr,
    pub user_data_ptr: *mut *mut std::os::raw::c_void,
    pub user_data: *mut std::os::raw::c_void,
    pub schemas_sax: xmlSAXHandler,
    pub ctxt: xmlSchemaValidCtxtPtr,
}
/* *
 * xmlTextReaderErrorFunc:
 * @arg: the user argument
 * @msg: the message
 * @severity: the severity of the error
 * @locator: a locator indicating where the error occurred
 *
 * Signature of an error callback from a reader parser
 */
pub type xmlTextReaderErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: xmlParserSeverities,
                                _: xmlTextReaderLocatorPtr) -> ()>;
/*
 * Error handling extensions
 */
pub type xmlTextReaderLocatorPtr = *mut std::os::raw::c_void;
pub type xmlParserSeverities = std::os::raw::c_uint;
pub const XML_PARSER_SEVERITY_ERROR: xmlParserSeverities = 4;
pub const XML_PARSER_SEVERITY_WARNING: xmlParserSeverities = 3;
pub const XML_PARSER_SEVERITY_VALIDITY_ERROR: xmlParserSeverities = 2;
pub const XML_PARSER_SEVERITY_VALIDITY_WARNING: xmlParserSeverities = 1;
pub type xmlTextReaderState = std::os::raw::c_int;
pub const XML_TEXTREADER_ERROR: xmlTextReaderState = 6;
pub const XML_TEXTREADER_DONE: xmlTextReaderState = 5;
pub const XML_TEXTREADER_BACKTRACK: xmlTextReaderState = 4;
pub const XML_TEXTREADER_EMPTY: xmlTextReaderState = 3;
pub const XML_TEXTREADER_END: xmlTextReaderState = 2;
pub const XML_TEXTREADER_ELEMENT: xmlTextReaderState = 1;
pub const XML_TEXTREADER_START: xmlTextReaderState = 0;
pub const XML_TEXTREADER_NONE: xmlTextReaderState = -1;
pub type xmlTextReaderValidate = std::os::raw::c_uint;
pub const XML_TEXTREADER_VALIDATE_XSD: xmlTextReaderValidate = 4;
pub const XML_TEXTREADER_VALIDATE_RNG: xmlTextReaderValidate = 2;
pub const XML_TEXTREADER_VALIDATE_DTD: xmlTextReaderValidate = 1;
pub const XML_TEXTREADER_NOT_VALIDATE: xmlTextReaderValidate = 0;
pub type xmlSchemaIDCStateObjPtr = *mut xmlSchemaIDCStateObj;
/* *
 * xmlSchemaIDCStateObj:
 *
 * The state object used to evaluate XPath expressions.
 */
pub type xmlSchemaIDCStateObj = _xmlSchemaIDCStateObj;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCStateObj {
    pub type_0: std::os::raw::c_int,
    pub next: xmlSchemaIDCStateObjPtr,
    pub depth: std::os::raw::c_int,
    pub history: *mut std::os::raw::c_int,
    pub nbHistory: std::os::raw::c_int,
    pub sizeHistory: std::os::raw::c_int,
    pub matcher: xmlSchemaIDCMatcherPtr,
    pub sel: xmlSchemaIDCSelectPtr,
    pub xpathCtxt: *mut std::os::raw::c_void,
}
pub type xmlSchemaParserCtxtPtr = *mut xmlSchemaParserCtxt;
pub type xmlSchemaParserCtxt = _xmlSchemaParserCtxt;
pub type xmlSchemaConstructionCtxtPtr = *mut xmlSchemaConstructionCtxt;
/* The redefined schema. */
/* *
 * xmlSchemaConstructionCtxt:
 */
pub type xmlSchemaConstructionCtxt = _xmlSchemaConstructionCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaConstructionCtxt {
    pub mainSchema: xmlSchemaPtr,
    pub mainBucket: xmlSchemaBucketPtr,
    pub dict: xmlDictPtr,
    pub buckets: xmlSchemaItemListPtr,
    pub bucket: xmlSchemaBucketPtr,
    pub pending: xmlSchemaItemListPtr,
    pub substGroups: xmlHashTablePtr,
    pub redefs: xmlSchemaRedefPtr,
    pub lastRedef: xmlSchemaRedefPtr,
}
pub type xmlSchemaSubstGroupPtr = *mut xmlSchemaSubstGroup;
/* *
 * xmlSchemaSubstGroup:
 *
 *
 */
pub type xmlSchemaSubstGroup = _xmlSchemaSubstGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSubstGroup {
    pub head: xmlSchemaElementPtr,
    pub members: xmlSchemaItemListPtr,
}
pub type xmlStreamCtxtPtr = *mut xmlStreamCtxt;
pub type xmlStreamCtxt = _xmlStreamCtxt;
pub type xmlSchemaAbstractCtxtPtr = *mut xmlSchemaAbstractCtxt;
pub type xmlSchemaAbstractCtxt = _xmlSchemaAbstractCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAbstractCtxt {
    pub type_0: std::os::raw::c_int,
    pub dummy: *mut std::os::raw::c_void,
}
pub type xmlSchemaImportPtr = *mut xmlSchemaImport;
/* Local components. */
/* *
 * xmlSchemaImport:
 * (extends xmlSchemaBucket)
 *
 * Reflects a schema. Holds some information
 * about the schema and its toplevel components. Duplicate
 * toplevel components are not checked at this level.
 */
pub type xmlSchemaImport = _xmlSchemaImport;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaImport {
    pub type_0: std::os::raw::c_int,
    pub flags: std::os::raw::c_int,
    pub schemaLocation: *const xmlChar,
    pub origTargetNamespace: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub doc: xmlDocPtr,
    pub relations: xmlSchemaSchemaRelationPtr,
    pub located: std::os::raw::c_int,
    pub parsed: std::os::raw::c_int,
    pub imported: std::os::raw::c_int,
    pub preserveDoc: std::os::raw::c_int,
    pub globals: xmlSchemaItemListPtr,
    pub locals: xmlSchemaItemListPtr,
    pub schema: xmlSchemaPtr,
}
pub type xmlSchemaTreeItemPtr = *mut xmlSchemaTreeItem;
/* *
 * xmlSchemaTreeItem:
 *
 * The abstract base type for tree-like structured schema components.
 * (Extends xmlSchemaAnnotItem)
 */
pub type xmlSchemaTreeItem = _xmlSchemaTreeItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaTreeItem {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
}
pub const XML_SCHEMAS_ANYTYPE: xmlSchemaValType = 45;
pub type xmlSchemaNotationPtr = *mut xmlSchemaNotation;
/* The regex for patterns */
/* *
 * A notation definition.
 */
pub type xmlSchemaNotation = _xmlSchemaNotation;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaNotation {
    pub type_0: xmlSchemaTypeType,
    pub name: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub identifier: *const xmlChar,
    pub targetNamespace: *const xmlChar,
}
pub type xmlSchemaModelGroupDefPtr = *mut xmlSchemaModelGroupDef;
/* *
 * xmlSchemaModelGroupDef:
 *
 * A model group definition component.
 * (Extends xmlSchemaTreeItem)
 */
pub type xmlSchemaModelGroupDef = _xmlSchemaModelGroupDef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaModelGroupDef {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub node: xmlNodePtr,
    pub flags: std::os::raw::c_int,
}
pub type xmlSchemaAttributeGroupPtr = *mut xmlSchemaAttributeGroup;
/* *
 * An attribute group definition.
 *
 * xmlSchemaAttribute and xmlSchemaAttributeGroup start of structures
 * must be kept similar
 */
pub type xmlSchemaAttributeGroup = _xmlSchemaAttributeGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeGroup {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaAttribute,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub attributes: xmlSchemaAttributePtr,
    pub node: xmlNodePtr,
    pub flags: std::os::raw::c_int,
    pub attributeWildcard: xmlSchemaWildcardPtr,
    pub refPrefix: *const xmlChar,
    pub refItem: xmlSchemaAttributeGroupPtr,
    pub targetNamespace: *const xmlChar,
    pub attrUses: *mut std::os::raw::c_void,
}
pub type xmlSchemaModelGroupPtr = *mut xmlSchemaModelGroup;
/* *
 * xmlSchemaModelGroup:
 *
 * A model group component.
 * (Extends xmlSchemaTreeItem)
 */
pub type xmlSchemaModelGroup = _xmlSchemaModelGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaModelGroup {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
    pub node: xmlNodePtr,
}
pub type xmlSchemaAttributeUseProhibPtr = *mut xmlSchemaAttributeUseProhib;
/* *
 * xmlSchemaAttributeUseProhibPtr:
 *
 * A helper component to reflect attribute prohibitions.
 * (Extends xmlSchemaBasicItem)
 */
pub type xmlSchemaAttributeUseProhib = _xmlSchemaAttributeUseProhib;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeUseProhib {
    pub type_0: xmlSchemaTypeType,
    pub node: xmlNodePtr,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub isRef: std::os::raw::c_int,
}
pub type xmlSchemaParticlePtr = *mut xmlSchemaParticle;
/* *
 * xmlSchemaParticle:
 *
 * A particle component.
 * (Extends xmlSchemaTreeItem)
 */
pub type xmlSchemaParticle = _xmlSchemaParticle;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaParticle {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
    pub minOccurs: std::os::raw::c_int,
    pub maxOccurs: std::os::raw::c_int,
    pub node: xmlNodePtr,
}
pub type xmlSchemaValType = std::os::raw::c_uint;
pub const XML_SCHEMAS_ANYSIMPLETYPE: xmlSchemaValType = 46;
pub const XML_SCHEMAS_BASE64BINARY: xmlSchemaValType = 44;
pub const XML_SCHEMAS_HEXBINARY: xmlSchemaValType = 43;
pub const XML_SCHEMAS_UBYTE: xmlSchemaValType = 42;
pub const XML_SCHEMAS_BYTE: xmlSchemaValType = 41;
pub const XML_SCHEMAS_USHORT: xmlSchemaValType = 40;
pub const XML_SCHEMAS_SHORT: xmlSchemaValType = 39;
pub const XML_SCHEMAS_ULONG: xmlSchemaValType = 38;
pub const XML_SCHEMAS_LONG: xmlSchemaValType = 37;
pub const XML_SCHEMAS_UINT: xmlSchemaValType = 36;
pub const XML_SCHEMAS_INT: xmlSchemaValType = 35;
pub const XML_SCHEMAS_PINTEGER: xmlSchemaValType = 34;
pub const XML_SCHEMAS_NNINTEGER: xmlSchemaValType = 33;
pub const XML_SCHEMAS_NINTEGER: xmlSchemaValType = 32;
pub const XML_SCHEMAS_NPINTEGER: xmlSchemaValType = 31;
pub const XML_SCHEMAS_INTEGER: xmlSchemaValType = 30;
pub const XML_SCHEMAS_ANYURI: xmlSchemaValType = 29;
pub const XML_SCHEMAS_NOTATION: xmlSchemaValType = 28;
pub const XML_SCHEMAS_ENTITIES: xmlSchemaValType = 27;
pub const XML_SCHEMAS_ENTITY: xmlSchemaValType = 26;
pub const XML_SCHEMAS_IDREFS: xmlSchemaValType = 25;
pub const XML_SCHEMAS_IDREF: xmlSchemaValType = 24;
pub const XML_SCHEMAS_ID: xmlSchemaValType = 23;
pub const XML_SCHEMAS_NCNAME: xmlSchemaValType = 22;
pub const XML_SCHEMAS_QNAME: xmlSchemaValType = 21;
pub const XML_SCHEMAS_NAME: xmlSchemaValType = 20;
pub const XML_SCHEMAS_NMTOKENS: xmlSchemaValType = 19;
pub const XML_SCHEMAS_NMTOKEN: xmlSchemaValType = 18;
pub const XML_SCHEMAS_LANGUAGE: xmlSchemaValType = 17;
pub const XML_SCHEMAS_TOKEN: xmlSchemaValType = 16;
pub const XML_SCHEMAS_BOOLEAN: xmlSchemaValType = 15;
pub const XML_SCHEMAS_DOUBLE: xmlSchemaValType = 14;
pub const XML_SCHEMAS_FLOAT: xmlSchemaValType = 13;
pub const XML_SCHEMAS_DURATION: xmlSchemaValType = 12;
pub const XML_SCHEMAS_DATETIME: xmlSchemaValType = 11;
pub const XML_SCHEMAS_DATE: xmlSchemaValType = 10;
pub const XML_SCHEMAS_GYEARMONTH: xmlSchemaValType = 9;
pub const XML_SCHEMAS_GYEAR: xmlSchemaValType = 8;
pub const XML_SCHEMAS_GMONTHDAY: xmlSchemaValType = 7;
pub const XML_SCHEMAS_GMONTH: xmlSchemaValType = 6;
pub const XML_SCHEMAS_GDAY: xmlSchemaValType = 5;
pub const XML_SCHEMAS_TIME: xmlSchemaValType = 4;
pub const XML_SCHEMAS_DECIMAL: xmlSchemaValType = 3;
pub const XML_SCHEMAS_NORMSTRING: xmlSchemaValType = 2;
pub const XML_SCHEMAS_STRING: xmlSchemaValType = 1;
pub const XML_SCHEMAS_UNKNOWN: xmlSchemaValType = 0;
pub type xmlSchemaWhitespaceValueType = std::os::raw::c_uint;
pub const XML_SCHEMA_WHITESPACE_COLLAPSE: xmlSchemaWhitespaceValueType = 3;
pub const XML_SCHEMA_WHITESPACE_REPLACE: xmlSchemaWhitespaceValueType = 2;
pub const XML_SCHEMA_WHITESPACE_PRESERVE: xmlSchemaWhitespaceValueType = 1;
pub const XML_SCHEMA_WHITESPACE_UNKNOWN: xmlSchemaWhitespaceValueType = 0;
pub type xmlSchemaIncludePtr = *mut xmlSchemaInclude;
/*
* (extends xmlSchemaBucket)
*/
pub type xmlSchemaInclude = _xmlSchemaInclude;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaInclude {
    pub type_0: std::os::raw::c_int,
    pub flags: std::os::raw::c_int,
    pub schemaLocation: *const xmlChar,
    pub origTargetNamespace: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub doc: xmlDocPtr,
    pub relations: xmlSchemaSchemaRelationPtr,
    pub located: std::os::raw::c_int,
    pub parsed: std::os::raw::c_int,
    pub imported: std::os::raw::c_int,
    pub preserveDoc: std::os::raw::c_int,
    pub globals: xmlSchemaItemListPtr,
    pub locals: xmlSchemaItemListPtr,
    pub ownerImport: xmlSchemaImportPtr,
}
pub type xmlSchemaAnnotItemPtr = *mut xmlSchemaAnnotItem;
/* Fix alignment issues */
/* *
 * xmlSchemaAnnotItem:
 *
 * The abstract base type for annotated schema components.
 * (Extends xmlSchemaBasicItem)
 */
pub type xmlSchemaAnnotItem = _xmlSchemaAnnotItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnotItem {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
}
pub const XML_PATTERN_XSSEL: C2RustUnnamed_2 = 2;
pub const XML_PATTERN_XSFIELD: C2RustUnnamed_2 = 4;
pub type C2RustUnnamed_2 = std::os::raw::c_uint;
pub const XML_PATTERN_XPATH: C2RustUnnamed_2 = 1;
pub const XML_PATTERN_DEFAULT: C2RustUnnamed_2 = 0;
/*
 * The XML Schemas namespaces
 */
static mut xmlSchemaNs: *const xmlChar =
    b"http://www.w3.org/2001/XMLSchema\x00" as *const u8 as
        *const std::os::raw::c_char as *const xmlChar;
static mut xmlSchemaInstanceNs: *const xmlChar =
    b"http://www.w3.org/2001/XMLSchema-instance\x00" as *const u8 as
        *const std::os::raw::c_char as *const xmlChar;
static mut xmlNamespaceNs: *const xmlChar =
    b"http://www.w3.org/2000/xmlns/\x00" as *const u8 as *const std::os::raw::c_char
        as *const xmlChar;
/* ***********************************************************************
 *									*
 *			Helper functions			        *
 *									*
 ************************************************************************/
/* *
 * xmlSchemaItemTypeToStr:
 * @type: the type of the schema item
 *
 * Returns the component name of a schema item.
 */
unsafe extern "C" fn xmlSchemaItemTypeToStr(mut type_0: xmlSchemaTypeType)
 -> *const xmlChar {
    match type_0 as std::os::raw::c_uint {
        1 => {
            return b"simple type definition\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        4 => {
            return b"simple type definition\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        5 => {
            return b"complex type definition\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        14 => {
            return b"element declaration\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        26 => {
            return b"attribute use\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        15 => {
            return b"attribute declaration\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        17 => {
            return b"model group definition\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        16 => {
            return b"attribute group definition\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        18 => {
            return b"notation declaration\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        6 => {
            return b"model group (sequence)\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        7 => {
            return b"model group (choice)\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        8 => {
            return b"model group (all)\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        25 => {
            return b"particle\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        22 => {
            return b"unique identity-constraint\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        23 => {
            /* return(BAD_CAST "IDC (unique)"); */
            return b"key identity-constraint\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        24 => {
            /* return(BAD_CAST "IDC (key)"); */
            return b"keyref identity-constraint\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        2 => {
            /* return(BAD_CAST "IDC (keyref)"); */
            return b"wildcard (any)\x00" as *const u8 as *const std::os::raw::c_char
                       as *mut xmlChar
        }
        2000 => {
            return b"[helper component] QName reference\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        2001 => {
            return b"[helper component] attribute use prohibition\x00" as
                       *const u8 as *const std::os::raw::c_char as *mut xmlChar
        }
        _ => {
            return b"Not a schema component\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
    };
}
/* *
 * xmlSchemaGetComponentTypeStr:
 * @type: the type of the schema item
 *
 * Returns the component name of a schema item.
 */
unsafe extern "C" fn xmlSchemaGetComponentTypeStr(mut item:
                                                      xmlSchemaBasicItemPtr)
 -> *const xmlChar {
    match (*item).type_0 as std::os::raw::c_uint {
        1 => {
            if (*(item as xmlSchemaTypePtr)).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
                   (*(item as xmlSchemaTypePtr)).builtInType ==
                       XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
                return b"complex type definition\x00" as *const u8 as
                           *const std::os::raw::c_char as *mut xmlChar
            } else {
                return b"simple type definition\x00" as *const u8 as
                           *const std::os::raw::c_char as *mut xmlChar
            }
        }
        _ => { return xmlSchemaItemTypeToStr((*item).type_0) }
    };
}
/* *
 * xmlSchemaGetComponentNode:
 * @item: a schema component
 *
 * Returns node associated with the schema component.
 * NOTE that such a node need not be available; plus, a component's
 * node need not to reflect the component directly, since there is no
 * one-to-one relationship between the XML Schema representation and
 * the component representation.
 */
unsafe extern "C" fn xmlSchemaGetComponentNode(mut item:
                                                   xmlSchemaBasicItemPtr)
 -> xmlNodePtr {
    match (*item).type_0 as std::os::raw::c_uint {
        14 => { return (*(item as xmlSchemaElementPtr)).node }
        15 => { return (*(item as xmlSchemaAttributePtr)).node }
        5 | 4 => { return (*(item as xmlSchemaTypePtr)).node }
        2 | 21 => { return (*(item as xmlSchemaWildcardPtr)).node }
        25 => { return (*(item as xmlSchemaParticlePtr)).node }
        6 | 7 | 8 => { return (*(item as xmlSchemaModelGroupPtr)).node }
        17 => { return (*(item as xmlSchemaModelGroupDefPtr)).node }
        16 => { return (*(item as xmlSchemaAttributeGroupPtr)).node }
        22 | 23 | 24 => { return (*(item as xmlSchemaIDCPtr)).node }
        2000 => { return (*(item as xmlSchemaQNameRefPtr)).node }
        26 => {
            /* TODO: What to do with NOTATIONs?
	case XML_SCHEMA_TYPE_NOTATION:
	    return (((xmlSchemaNotationPtr) item)->node);
	*/
            return (*(item as xmlSchemaAttributeUsePtr)).node
        }
        _ => { return 0 as xmlNodePtr }
    };
}
/* *
 * xmlSchemaFormatQName:
 * @buf: the string buffer
 * @namespaceName:  the namespace name
 * @localName: the local name
 *
 * Returns the given QName in the format "{namespaceName}localName" or
 * just "localName" if @namespaceName is NULL.
 *
 * Returns the localName if @namespaceName is NULL, a formatted
 * string otherwise.
 */
unsafe extern "C" fn xmlSchemaFormatQName(mut buf: *mut *mut xmlChar,
                                          mut namespaceName: *const xmlChar,
                                          mut localName: *const xmlChar)
 -> *const xmlChar {
    if !(*buf).is_null() {
        xmlFree.expect("non-null function pointer")(*buf as
                                                        *mut std::os::raw::c_void);
        *buf = 0 as *mut xmlChar
    }
    if !namespaceName.is_null() {
        *buf =
            xmlStrdup(b"{\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        *buf = xmlStrcat(*buf, namespaceName);
        *buf =
            xmlStrcat(*buf,
                      b"}\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    if !localName.is_null() {
        if namespaceName.is_null() { return localName }
        *buf = xmlStrcat(*buf, localName)
    } else {
        *buf =
            xmlStrcat(*buf,
                      b"(NULL)\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    return *buf as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaFormatQNameNs(mut buf: *mut *mut xmlChar,
                                            mut ns: xmlNsPtr,
                                            mut localName: *const xmlChar)
 -> *const xmlChar {
    if !ns.is_null() {
        return xmlSchemaFormatQName(buf, (*ns).href, localName)
    } else {
        return xmlSchemaFormatQName(buf, 0 as *const xmlChar, localName)
    };
}
unsafe extern "C" fn xmlSchemaGetComponentName(mut item:
                                                   xmlSchemaBasicItemPtr)
 -> *const xmlChar {
    match (*item).type_0 as std::os::raw::c_uint {
        14 => { return (*(item as xmlSchemaElementPtr)).name }
        15 => { return (*(item as xmlSchemaAttributePtr)).name }
        16 => { return (*(item as xmlSchemaAttributeGroupPtr)).name }
        1 | 4 | 5 => { return (*(item as xmlSchemaTypePtr)).name }
        17 => { return (*(item as xmlSchemaModelGroupDefPtr)).name }
        23 | 22 | 24 => { return (*(item as xmlSchemaIDCPtr)).name }
        26 => {
            if !(*(item as xmlSchemaAttributeUsePtr)).attrDecl.is_null() {
                return xmlSchemaGetComponentName((*(item as
                                                        xmlSchemaAttributeUsePtr)).attrDecl
                                                     as xmlSchemaBasicItemPtr)
            } else { return 0 as *const xmlChar }
        }
        2000 => { return (*(item as xmlSchemaQNameRefPtr)).name }
        18 => { return (*(item as xmlSchemaNotationPtr)).name }
        _ => { }
    }
    return 0 as *const xmlChar;
}
/*
static const xmlChar *
xmlSchemaGetQNameRefName(void *ref)
{
    return(((xmlSchemaQNameRefPtr) ref)->name);
}

static const xmlChar *
xmlSchemaGetQNameRefTargetNs(void *ref)
{
    return(((xmlSchemaQNameRefPtr) ref)->targetNamespace);
}
*/
unsafe extern "C" fn xmlSchemaGetComponentTargetNs(mut item:
                                                       xmlSchemaBasicItemPtr)
 -> *const xmlChar {
    match (*item).type_0 as std::os::raw::c_uint {
        14 => { return (*(item as xmlSchemaElementPtr)).targetNamespace }
        15 => { return (*(item as xmlSchemaAttributePtr)).targetNamespace }
        16 => {
            return (*(item as xmlSchemaAttributeGroupPtr)).targetNamespace
        }
        1 => {
            return b"http://www.w3.org/2001/XMLSchema\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
        4 | 5 => { return (*(item as xmlSchemaTypePtr)).targetNamespace }
        17 => {
            return (*(item as xmlSchemaModelGroupDefPtr)).targetNamespace
        }
        23 | 22 | 24 => {
            return (*(item as xmlSchemaIDCPtr)).targetNamespace
        }
        26 => {
            if !(*(item as xmlSchemaAttributeUsePtr)).attrDecl.is_null() {
                return xmlSchemaGetComponentTargetNs((*(item as
                                                            xmlSchemaAttributeUsePtr)).attrDecl
                                                         as
                                                         xmlSchemaBasicItemPtr)
            }
        }
        2000 => { return (*(item as xmlSchemaQNameRefPtr)).targetNamespace }
        18 => { return (*(item as xmlSchemaNotationPtr)).targetNamespace }
        _ => { }
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaGetComponentQName(mut buf: *mut *mut xmlChar,
                                                mut item: *mut std::os::raw::c_void)
 -> *const xmlChar {
    return xmlSchemaFormatQName(buf,
                                xmlSchemaGetComponentTargetNs(item as
                                                                  xmlSchemaBasicItemPtr),
                                xmlSchemaGetComponentName(item as
                                                              xmlSchemaBasicItemPtr));
}
unsafe extern "C" fn xmlSchemaGetComponentDesignation(mut buf:
                                                          *mut *mut xmlChar,
                                                      mut item:
                                                          *mut std::os::raw::c_void)
 -> *const xmlChar {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    *buf =
        xmlStrcat(*buf,
                  xmlSchemaGetComponentTypeStr(item as
                                                   xmlSchemaBasicItemPtr));
    *buf =
        xmlStrcat(*buf,
                  b" \'\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    *buf =
        xmlStrcat(*buf,
                  xmlSchemaGetComponentQName(&mut str,
                                             item as xmlSchemaBasicItemPtr as
                                                 *mut std::os::raw::c_void));
    *buf =
        xmlStrcat(*buf,
                  b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut std::os::raw::c_void);
        str = 0 as *mut xmlChar
    }
    return *buf;
}
unsafe extern "C" fn xmlSchemaGetIDCDesignation(mut buf: *mut *mut xmlChar,
                                                mut idc: xmlSchemaIDCPtr)
 -> *const xmlChar {
    return xmlSchemaGetComponentDesignation(buf, idc as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaWildcardPCToString:
 * @pc: the type of processContents
 *
 * Returns a string representation of the type of
 * processContents.
 */
unsafe extern "C" fn xmlSchemaWildcardPCToString(mut pc: std::os::raw::c_int)
 -> *const xmlChar {
    match pc {
        1 => {
            return b"skip\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        2 => {
            return b"lax\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        3 => {
            return b"strict\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        _ => {
            return b"invalid process contents\x00" as *const u8 as
                       *const std::os::raw::c_char as *mut xmlChar
        }
    };
}
/* *
 * xmlSchemaGetCanonValueWhtspExt:
 * @val: the precomputed value
 * @retValue: the returned value
 * @ws: the whitespace type of the value
 *
 * Get a the canonical representation of the value.
 * The caller has to free the returned retValue.
 *
 * Returns 0 if the value could be built and -1 in case of
 *         API errors or if the value type is not supported yet.
 */
unsafe extern "C" fn xmlSchemaGetCanonValueWhtspExt(mut val: xmlSchemaValPtr,
                                                    mut ws:
                                                        xmlSchemaWhitespaceValueType,
                                                    mut retValue:
                                                        *mut *mut xmlChar)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut list: std::os::raw::c_int = 0;
    let mut valType: xmlSchemaValType = XML_SCHEMAS_UNKNOWN;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    let mut value2: *const xmlChar = 0 as *const xmlChar;
    if retValue.is_null() || val.is_null() { return -(1 as std::os::raw::c_int) }
    list =
        if !xmlSchemaValueGetNext(val).is_null() {
            1 as std::os::raw::c_int
        } else { 0 as std::os::raw::c_int };
    *retValue = 0 as *mut xmlChar;
    loop  {
        value = 0 as *const xmlChar;
        valType = xmlSchemaGetValType(val);
        match valType as std::os::raw::c_uint {
            1 | 2 | 46 => {
                value = xmlSchemaValueGetAsString(val);
                if !value.is_null() {
                    if ws as std::os::raw::c_uint ==
                           XML_SCHEMA_WHITESPACE_COLLAPSE as std::os::raw::c_int as
                               std::os::raw::c_uint {
                        value2 = xmlSchemaCollapseString(value)
                    } else if ws as std::os::raw::c_uint ==
                                  XML_SCHEMA_WHITESPACE_REPLACE as std::os::raw::c_int
                                      as std::os::raw::c_uint {
                        value2 = xmlSchemaWhiteSpaceReplace(value)
                    }
                    if !value2.is_null() { value = value2 }
                }
            }
            _ => {
                if xmlSchemaGetCanonValue(val, &mut value2) ==
                       -(1 as std::os::raw::c_int) {
                    if !value2.is_null() {
                        xmlFree.expect("non-null function pointer")(value2 as
                                                                        *mut xmlChar
                                                                        as
                                                                        *mut std::os::raw::c_void);
                    }
                    current_block = 5751271863244501970;
                    break ;
                } else { value = value2 }
            }
        }
        if (*retValue).is_null() {
            if value.is_null() {
                if list == 0 {
                    *retValue =
                        xmlStrdup(b"\x00" as *const u8 as *const std::os::raw::c_char
                                      as *mut xmlChar)
                }
            } else { *retValue = xmlStrdup(value) }
        } else if !value.is_null() {
            /* List. */
            *retValue =
                xmlStrcat(*retValue,
                          b" \x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            *retValue = xmlStrcat(*retValue, value)
        }
        if !value2.is_null() {
            xmlFree.expect("non-null function pointer")(value2 as *mut xmlChar
                                                            as
                                                            *mut std::os::raw::c_void);
            value2 = 0 as *const xmlChar
        }
        val = xmlSchemaValueGetNext(val);
        if val.is_null() { current_block = 4090602189656566074; break ; }
    }
    match current_block {
        4090602189656566074 => { return 0 as std::os::raw::c_int }
        _ => {
            if !(*retValue).is_null() {
                xmlFree.expect("non-null function pointer")(*retValue as
                                                                *mut std::os::raw::c_void);
            }
            if !value2.is_null() {
                xmlFree.expect("non-null function pointer")(value2 as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            return -(1 as std::os::raw::c_int)
        }
    };
}
/* *
 * xmlSchemaFormatItemForReport:
 * @buf: the string buffer
 * @itemDes: the designation of the item
 * @itemName: the name of the item
 * @item: the item as an object
 * @itemNode: the node of the item
 * @local: the local name
 * @parsing: if the function is used during the parse
 *
 * Returns a representation of the given item used
 * for error reports.
 *
 * The following order is used to build the resulting
 * designation if the arguments are not NULL:
 * 1a. If itemDes not NULL -> itemDes
 * 1b. If (itemDes not NULL) and (itemName not NULL)
 *     -> itemDes + itemName
 * 2. If the preceding was NULL and (item not NULL) -> item
 * 3. If the preceding was NULL and (itemNode not NULL) -> itemNode
 *
 * If the itemNode is an attribute node, the name of the attribute
 * will be appended to the result.
 *
 * Returns the formatted string and sets @buf to the resulting value.
 */
unsafe extern "C" fn xmlSchemaFormatItemForReport(mut buf: *mut *mut xmlChar,
                                                  mut itemDes: *const xmlChar,
                                                  mut item:
                                                      xmlSchemaBasicItemPtr,
                                                  mut itemNode: xmlNodePtr)
 -> *mut xmlChar {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut named: std::os::raw::c_int = 1 as std::os::raw::c_int;
    if !(*buf).is_null() {
        xmlFree.expect("non-null function pointer")(*buf as
                                                        *mut std::os::raw::c_void);
        *buf = 0 as *mut xmlChar
    }
    if !itemDes.is_null() {
        *buf = xmlStrdup(itemDes)
    } else if !item.is_null() {
        let mut current_block_107: u64;
        match (*item).type_0 as std::os::raw::c_uint {
            1 => {
                let mut type_0: xmlSchemaTypePtr = item as xmlSchemaTypePtr;
                if (*type_0).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int !=
                       0 {
                    *buf =
                        xmlStrdup(b"atomic type \'xs:\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else if (*type_0).flags &
                              (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
                    *buf =
                        xmlStrdup(b"list type \'xs:\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else if (*type_0).flags &
                              (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
                    *buf =
                        xmlStrdup(b"union type \'xs:\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else {
                    *buf =
                        xmlStrdup(b"simple type \'xs:\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                *buf = xmlStrcat(*buf, (*type_0).name);
                *buf =
                    xmlStrcat(*buf,
                              b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar);
                current_block_107 = 13253659531982233645;
            }
            4 => {
                let mut type_1: xmlSchemaTypePtr = item as xmlSchemaTypePtr;
                if (*type_1).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int !=
                       0 {
                    *buf =
                        xmlStrdup(b"\x00" as *const u8 as *const std::os::raw::c_char
                                      as *mut xmlChar)
                } else {
                    *buf =
                        xmlStrdup(b"local \x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                if (*type_1).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int !=
                       0 {
                    *buf =
                        xmlStrcat(*buf,
                                  b"atomic type\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else if (*type_1).flags &
                              (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
                    *buf =
                        xmlStrcat(*buf,
                                  b"list type\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else if (*type_1).flags &
                              (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
                    *buf =
                        xmlStrcat(*buf,
                                  b"union type\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else {
                    *buf =
                        xmlStrcat(*buf,
                                  b"simple type\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                if (*type_1).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int !=
                       0 {
                    *buf =
                        xmlStrcat(*buf,
                                  b" \'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar);
                    *buf = xmlStrcat(*buf, (*type_1).name);
                    *buf =
                        xmlStrcat(*buf,
                                  b"\'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                current_block_107 = 13253659531982233645;
            }
            5 => {
                let mut type_2: xmlSchemaTypePtr = item as xmlSchemaTypePtr;
                if (*type_2).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int !=
                       0 {
                    *buf =
                        xmlStrdup(b"\x00" as *const u8 as *const std::os::raw::c_char
                                      as *mut xmlChar)
                } else {
                    *buf =
                        xmlStrdup(b"local \x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                *buf =
                    xmlStrcat(*buf,
                              b"complex type\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar);
                if (*type_2).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int !=
                       0 {
                    *buf =
                        xmlStrcat(*buf,
                                  b" \'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar);
                    *buf = xmlStrcat(*buf, (*type_2).name);
                    *buf =
                        xmlStrcat(*buf,
                                  b"\'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                current_block_107 = 13253659531982233645;
            }
            26 => {
                let mut ause: xmlSchemaAttributeUsePtr =
                    0 as *mut xmlSchemaAttributeUse;
                ause = item as xmlSchemaAttributeUsePtr;
                *buf =
                    xmlStrdup(b"attribute use \x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar);
                if !(*ause).attrDecl.is_null() {
                    *buf =
                        xmlStrcat(*buf,
                                  b"\'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar);
                    *buf =
                        xmlStrcat(*buf,
                                  xmlSchemaGetComponentQName(&mut str,
                                                             (*ause).attrDecl
                                                                 as
                                                                 *mut std::os::raw::c_void));
                    if !str.is_null() {
                        xmlFree.expect("non-null function pointer")(str as
                                                                        *mut std::os::raw::c_void);
                        str = 0 as *mut xmlChar
                    }
                    *buf =
                        xmlStrcat(*buf,
                                  b"\'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else {
                    *buf =
                        xmlStrcat(*buf,
                                  b"(unknown)\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                current_block_107 = 13253659531982233645;
            }
            15 => {
                let mut attr: xmlSchemaAttributePtr =
                    0 as *mut xmlSchemaAttribute;
                attr = item as xmlSchemaAttributePtr;
                *buf =
                    xmlStrdup(b"attribute decl.\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar);
                *buf =
                    xmlStrcat(*buf,
                              b" \'\x00" as *const u8 as *const std::os::raw::c_char
                                  as *mut xmlChar);
                *buf =
                    xmlStrcat(*buf,
                              xmlSchemaFormatQName(&mut str,
                                                   (*attr).targetNamespace,
                                                   (*attr).name));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                *buf =
                    xmlStrcat(*buf,
                              b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar);
                current_block_107 = 13253659531982233645;
            }
            16 => {
                xmlSchemaGetComponentDesignation(buf,
                                                 item as *mut std::os::raw::c_void);
                current_block_107 = 13253659531982233645;
            }
            14 => {
                let mut elem: xmlSchemaElementPtr =
                    0 as *mut xmlSchemaElement;
                elem = item as xmlSchemaElementPtr;
                *buf =
                    xmlStrdup(b"element decl.\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar);
                *buf =
                    xmlStrcat(*buf,
                              b" \'\x00" as *const u8 as *const std::os::raw::c_char
                                  as *mut xmlChar);
                *buf =
                    xmlStrcat(*buf,
                              xmlSchemaFormatQName(&mut str,
                                                   (*elem).targetNamespace,
                                                   (*elem).name));
                *buf =
                    xmlStrcat(*buf,
                              b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar);
                current_block_107 = 13253659531982233645;
            }
            22 | 23 | 24 => {
                if (*item).type_0 as std::os::raw::c_uint ==
                       XML_SCHEMA_TYPE_IDC_UNIQUE as std::os::raw::c_int as
                           std::os::raw::c_uint {
                    *buf =
                        xmlStrdup(b"unique \'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else if (*item).type_0 as std::os::raw::c_uint ==
                              XML_SCHEMA_TYPE_IDC_KEY as std::os::raw::c_int as
                                  std::os::raw::c_uint {
                    *buf =
                        xmlStrdup(b"key \'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else {
                    *buf =
                        xmlStrdup(b"keyRef \'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                *buf = xmlStrcat(*buf, (*(item as xmlSchemaIDCPtr)).name);
                *buf =
                    xmlStrcat(*buf,
                              b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar);
                current_block_107 = 13253659531982233645;
            }
            2 | 21 => {
                *buf =
                    xmlStrdup(xmlSchemaWildcardPCToString((*(item as
                                                                 xmlSchemaWildcardPtr)).processContents));
                *buf =
                    xmlStrcat(*buf,
                              b" wildcard\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar);
                current_block_107 = 13253659531982233645;
            }
            1000 | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 | 1007 | 1008 |
            1009 | 1010 | 1011 => {
                *buf =
                    xmlStrdup(b"facet \'\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar);
                *buf =
                    xmlStrcat(*buf,
                              xmlSchemaFacetTypeToString((*item).type_0));
                *buf =
                    xmlStrcat(*buf,
                              b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar);
                current_block_107 = 13253659531982233645;
            }
            17 => {
                *buf =
                    xmlStrdup(b"model group def.\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar);
                *buf =
                    xmlStrcat(*buf,
                              b" \'\x00" as *const u8 as *const std::os::raw::c_char
                                  as *mut xmlChar);
                *buf =
                    xmlStrcat(*buf,
                              xmlSchemaGetComponentQName(&mut str,
                                                         item as
                                                             *mut std::os::raw::c_void));
                *buf =
                    xmlStrcat(*buf,
                              b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar);
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                current_block_107 = 13253659531982233645;
            }
            6 | 7 | 8 | 25 => {
                *buf = xmlStrdup(xmlSchemaGetComponentTypeStr(item));
                current_block_107 = 13253659531982233645;
            }
            18 => {
                *buf = xmlStrdup(xmlSchemaGetComponentTypeStr(item));
                *buf =
                    xmlStrcat(*buf,
                              b" \'\x00" as *const u8 as *const std::os::raw::c_char
                                  as *mut xmlChar);
                *buf =
                    xmlStrcat(*buf,
                              xmlSchemaGetComponentQName(&mut str,
                                                         item as
                                                             *mut std::os::raw::c_void));
                *buf =
                    xmlStrcat(*buf,
                              b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar);
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                current_block_107 = 12867774346570004230;
            }
            _ => { current_block_107 = 12867774346570004230; }
        }
        match current_block_107 {
            12867774346570004230 =>
            /* Falls through. */
            {
                named = 0 as std::os::raw::c_int
            }
            _ => { }
        }
    } else { named = 0 as std::os::raw::c_int }
    if named == 0 as std::os::raw::c_int && !itemNode.is_null() {
        let mut elem_0: xmlNodePtr = 0 as *mut xmlNode;
        if (*itemNode).type_0 as std::os::raw::c_uint ==
               XML_ATTRIBUTE_NODE as std::os::raw::c_int as std::os::raw::c_uint {
            elem_0 = (*itemNode).parent
        } else { elem_0 = itemNode }
        *buf =
            xmlStrdup(b"Element \'\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        if !(*elem_0).ns.is_null() {
            *buf =
                xmlStrcat(*buf,
                          xmlSchemaFormatQName(&mut str, (*(*elem_0).ns).href,
                                               (*elem_0).name));
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
        } else { *buf = xmlStrcat(*buf, (*elem_0).name) }
        *buf =
            xmlStrcat(*buf,
                      b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    if !itemNode.is_null() &&
           (*itemNode).type_0 as std::os::raw::c_uint ==
               XML_ATTRIBUTE_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        *buf =
            xmlStrcat(*buf,
                      b", attribute \'\x00" as *const u8 as
                          *const std::os::raw::c_char as *mut xmlChar);
        if !(*itemNode).ns.is_null() {
            *buf =
                xmlStrcat(*buf,
                          xmlSchemaFormatQName(&mut str,
                                               (*(*itemNode).ns).href,
                                               (*itemNode).name));
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
        } else { *buf = xmlStrcat(*buf, (*itemNode).name) }
        *buf =
            xmlStrcat(*buf,
                      b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut std::os::raw::c_void);
        str = 0 as *mut xmlChar
    }
    return xmlEscapeFormatString(buf);
}
/* *
 * xmlSchemaFormatFacetEnumSet:
 * @buf: the string buffer
 * @type: the type holding the enumeration facets
 *
 * Builds a string consisting of all enumeration elements.
 *
 * Returns a string of all enumeration elements.
 */
unsafe extern "C" fn xmlSchemaFormatFacetEnumSet(mut actxt:
                                                     xmlSchemaAbstractCtxtPtr,
                                                 mut buf: *mut *mut xmlChar,
                                                 mut type_0: xmlSchemaTypePtr)
 -> *const xmlChar {
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut ws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut res: std::os::raw::c_int = 0;
    let mut found: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if !(*buf).is_null() {
        xmlFree.expect("non-null function pointer")(*buf as
                                                        *mut std::os::raw::c_void);
    }
    *buf = 0 as *mut xmlChar;
    loop  {
        /*
	* Use the whitespace type of the base type.
	*/
        ws = xmlSchemaGetWhiteSpaceFacetValue((*type_0).baseType);
        facet = (*type_0).facets;
        while !facet.is_null() {
            if !((*facet).type_0 as std::os::raw::c_uint !=
                     XML_SCHEMA_FACET_ENUMERATION as std::os::raw::c_int as
                         std::os::raw::c_uint) {
                found = 1 as std::os::raw::c_int;
                res =
                    xmlSchemaGetCanonValueWhtspExt((*facet).val, ws,
                                                   &mut value);
                if res == -(1 as std::os::raw::c_int) {
                    xmlSchemaInternalErr(actxt,
                                         b"xmlSchemaFormatFacetEnumSet\x00" as
                                             *const u8 as *const std::os::raw::c_char,
                                         b"compute the canonical lexical representation\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    if !(*buf).is_null() {
                        xmlFree.expect("non-null function pointer")(*buf as
                                                                        *mut std::os::raw::c_void);
                    }
                    *buf = 0 as *mut xmlChar;
                    return 0 as *const xmlChar
                }
                if (*buf).is_null() {
                    *buf =
                        xmlStrdup(b"\'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                } else {
                    *buf =
                        xmlStrcat(*buf,
                                  b", \'\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                *buf = xmlStrcat(*buf, value);
                *buf =
                    xmlStrcat(*buf,
                              b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar);
                if !value.is_null() {
                    xmlFree.expect("non-null function pointer")(value as
                                                                    *mut std::os::raw::c_void);
                    value = 0 as *mut xmlChar
                }
            }
            facet = (*facet).next
        }
        /*
	* The enumeration facet of a type restricts the enumeration
	* facet of the ancestor type; i.e., such restricted enumerations
	* do not belong to the set of the given type. Thus we break
	* on the first found enumeration.
	*/
        if found != 0 { break ; }
        type_0 = (*type_0).baseType;
        if !(!type_0.is_null() &&
                 (*type_0).type_0 as std::os::raw::c_uint !=
                     XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint) {
            break ;
        }
    }
    return *buf as *const xmlChar;
}
/* ***********************************************************************
 *									*
 *			Error functions				        *
 *									*
 ************************************************************************/
unsafe extern "C" fn xmlSchemaPSimpleErr(mut msg: *const std::os::raw::c_char) {
    __xmlSimpleError(XML_FROM_SCHEMASP as std::os::raw::c_int,
                     XML_ERR_NO_MEMORY as std::os::raw::c_int, 0 as xmlNodePtr,
                     0 as *const std::os::raw::c_char, msg);
}
/* *
 * xmlSchemaPErrMemory:
 * @node: a context node
 * @extra:  extra informations
 *
 * Handle an out of memory condition
 */
unsafe extern "C" fn xmlSchemaPErrMemory(mut ctxt: xmlSchemaParserCtxtPtr,
                                         mut extra: *const std::os::raw::c_char,
                                         mut node: xmlNodePtr) {
    if !ctxt.is_null() { (*ctxt).nberrors += 1 }
    __xmlSimpleError(XML_FROM_SCHEMASP as std::os::raw::c_int,
                     XML_ERR_NO_MEMORY as std::os::raw::c_int, node,
                     0 as *const std::os::raw::c_char, extra);
}
/* *
 * xmlSchemaPErr:
 * @ctxt: the parsing context
 * @node: the context node
 * @error: the error code
 * @msg: the error message
 * @str1: extra data
 * @str2: extra data
 *
 * Handle a parser error
 */
unsafe extern "C" fn xmlSchemaPErr(mut ctxt: xmlSchemaParserCtxtPtr,
                                   mut node: xmlNodePtr,
                                   mut error: std::os::raw::c_int,
                                   mut msg: *const std::os::raw::c_char,
                                   mut str1: *const xmlChar,
                                   mut str2: *const xmlChar) {
    let mut channel: xmlGenericErrorFunc = None;
    let mut schannel: xmlStructuredErrorFunc = None;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    if !ctxt.is_null() {
        (*ctxt).nberrors += 1;
        (*ctxt).err = error;
        channel = (*ctxt).error;
        data = (*ctxt).errCtxt;
        schannel = (*ctxt).serror
    }
    __xmlRaiseError(schannel, channel, data, ctxt as *mut std::os::raw::c_void,
                    node as *mut std::os::raw::c_void,
                    XML_FROM_SCHEMASP as std::os::raw::c_int, error, XML_ERR_ERROR,
                    0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    str1 as *const std::os::raw::c_char, str2 as *const std::os::raw::c_char,
                    0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as std::os::raw::c_int, msg, str1, str2);
}
/* *
 * xmlSchemaPErr2:
 * @ctxt: the parsing context
 * @node: the context node
 * @node: the current child
 * @error: the error code
 * @msg: the error message
 * @str1: extra data
 * @str2: extra data
 *
 * Handle a parser error
 */
unsafe extern "C" fn xmlSchemaPErr2(mut ctxt: xmlSchemaParserCtxtPtr,
                                    mut node: xmlNodePtr,
                                    mut child: xmlNodePtr,
                                    mut error: std::os::raw::c_int,
                                    mut msg: *const std::os::raw::c_char,
                                    mut str1: *const xmlChar,
                                    mut str2: *const xmlChar) {
    if !child.is_null() {
        xmlSchemaPErr(ctxt, child, error, msg, str1, str2);
    } else { xmlSchemaPErr(ctxt, node, error, msg, str1, str2); };
}
/* *
 * xmlSchemaPErrExt:
 * @ctxt: the parsing context
 * @node: the context node
 * @error: the error code
 * @strData1: extra data
 * @strData2: extra data
 * @strData3: extra data
 * @msg: the message
 * @str1:  extra parameter for the message display
 * @str2:  extra parameter for the message display
 * @str3:  extra parameter for the message display
 * @str4:  extra parameter for the message display
 * @str5:  extra parameter for the message display
 *
 * Handle a parser error
 */
unsafe extern "C" fn xmlSchemaPErrExt(mut ctxt: xmlSchemaParserCtxtPtr,
                                      mut node: xmlNodePtr,
                                      mut error: std::os::raw::c_int,
                                      mut strData1: *const xmlChar,
                                      mut strData2: *const xmlChar,
                                      mut strData3: *const xmlChar,
                                      mut msg: *const std::os::raw::c_char,
                                      mut str1: *const xmlChar,
                                      mut str2: *const xmlChar,
                                      mut str3: *const xmlChar,
                                      mut str4: *const xmlChar,
                                      mut str5: *const xmlChar) {
    let mut channel: xmlGenericErrorFunc = None;
    let mut schannel: xmlStructuredErrorFunc = None;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    if !ctxt.is_null() {
        (*ctxt).nberrors += 1;
        (*ctxt).err = error;
        channel = (*ctxt).error;
        data = (*ctxt).errCtxt;
        schannel = (*ctxt).serror
    }
    __xmlRaiseError(schannel, channel, data, ctxt as *mut std::os::raw::c_void,
                    node as *mut std::os::raw::c_void,
                    XML_FROM_SCHEMASP as std::os::raw::c_int, error, XML_ERR_ERROR,
                    0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    strData1 as *const std::os::raw::c_char,
                    strData2 as *const std::os::raw::c_char,
                    strData3 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as std::os::raw::c_int, msg, str1, str2, str3, str4, str5);
}
/* ***********************************************************************
 *									*
 *			Allround error functions			*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaVTypeErrMemory:
 * @node: a context node
 * @extra:  extra informations
 *
 * Handle an out of memory condition
 */
unsafe extern "C" fn xmlSchemaVErrMemory(mut ctxt: xmlSchemaValidCtxtPtr,
                                         mut extra: *const std::os::raw::c_char,
                                         mut node: xmlNodePtr) {
    if !ctxt.is_null() {
        (*ctxt).nberrors += 1;
        (*ctxt).err = XML_SCHEMAV_INTERNAL as std::os::raw::c_int
    }
    __xmlSimpleError(XML_FROM_SCHEMASV as std::os::raw::c_int,
                     XML_ERR_NO_MEMORY as std::os::raw::c_int, node,
                     0 as *const std::os::raw::c_char, extra);
}
unsafe extern "C" fn xmlSchemaPSimpleInternalErr(mut node: xmlNodePtr,
                                                 mut msg: *const std::os::raw::c_char,
                                                 mut str: *const xmlChar) {
    __xmlSimpleError(XML_FROM_SCHEMASP as std::os::raw::c_int,
                     XML_SCHEMAP_INTERNAL as std::os::raw::c_int, node, msg,
                     str as *const std::os::raw::c_char);
}
/* *
 * xmlSchemaErr4Line:
 * @ctxt: the validation context
 * @errorLevel: the error level
 * @error: the error code
 * @node: the context node
 * @line: the line number
 * @msg: the error message
 * @str1: extra data
 * @str2: extra data
 * @str3: extra data
 * @str4: extra data
 *
 * Handle a validation error
 */
unsafe extern "C" fn xmlSchemaErr4Line(mut ctxt: xmlSchemaAbstractCtxtPtr,
                                       mut errorLevel: xmlErrorLevel,
                                       mut error: std::os::raw::c_int,
                                       mut node: xmlNodePtr,
                                       mut line: std::os::raw::c_int,
                                       mut msg: *const std::os::raw::c_char,
                                       mut str1: *const xmlChar,
                                       mut str2: *const xmlChar,
                                       mut str3: *const xmlChar,
                                       mut str4: *const xmlChar) {
    let mut schannel: xmlStructuredErrorFunc = None;
    let mut channel: xmlGenericErrorFunc = None;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    if !ctxt.is_null() {
        if (*ctxt).type_0 == 2 as std::os::raw::c_int {
            let mut vctxt: xmlSchemaValidCtxtPtr =
                ctxt as xmlSchemaValidCtxtPtr;
            let mut file: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
            let mut col: std::os::raw::c_int = 0 as std::os::raw::c_int;
            if errorLevel as std::os::raw::c_uint !=
                   XML_ERR_WARNING as std::os::raw::c_int as std::os::raw::c_uint {
                (*vctxt).nberrors += 1;
                (*vctxt).err = error;
                channel = (*vctxt).error
            } else { channel = (*vctxt).warning }
            schannel = (*vctxt).serror;
            data = (*vctxt).errCtxt;
            /*
	    * Error node. If we specify a line number, then
	    * do not channel any node to the error function.
	    */
            if line == 0 as std::os::raw::c_int {
                if node.is_null() && (*vctxt).depth >= 0 as std::os::raw::c_int &&
                       !(*vctxt).inode.is_null() {
                    node = (*(*vctxt).inode).node
                }
                /*
		* Get filename and line if no node-tree.
		*/
                if node.is_null() && !(*vctxt).parserCtxt.is_null() &&
                       !(*(*vctxt).parserCtxt).input.is_null() {
                    file = (*(*(*vctxt).parserCtxt).input).filename;
                    line = (*(*(*vctxt).parserCtxt).input).line;
                    col = (*(*(*vctxt).parserCtxt).input).col
                }
            } else {
                /*
		* Override the given node's (if any) position
		* and channel only the given line number.
		*/
                node = 0 as xmlNodePtr;
                /*
		* Get filename.
		*/
                if !(*vctxt).doc.is_null() {
                    file = (*(*vctxt).doc).URL as *const std::os::raw::c_char
                } else if !(*vctxt).parserCtxt.is_null() &&
                              !(*(*vctxt).parserCtxt).input.is_null() {
                    file = (*(*(*vctxt).parserCtxt).input).filename
                }
            }
            if (*vctxt).locFunc.is_some() {
                if file.is_null() || line == 0 as std::os::raw::c_int {
                    let mut l: std::os::raw::c_ulong = 0;
                    let mut f: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
                    (*vctxt).locFunc.expect("non-null function pointer")((*vctxt).locCtxt,
                                                                         &mut f,
                                                                         &mut l);
                    if file.is_null() { file = f }
                    if line == 0 as std::os::raw::c_int { line = l as std::os::raw::c_int }
                }
            }
            if file.is_null() && !(*vctxt).filename.is_null() {
                file = (*vctxt).filename
            }
            __xmlRaiseError(schannel, channel, data,
                            ctxt as *mut std::os::raw::c_void,
                            node as *mut std::os::raw::c_void,
                            XML_FROM_SCHEMASV as std::os::raw::c_int, error,
                            errorLevel, file, line,
                            str1 as *const std::os::raw::c_char,
                            str2 as *const std::os::raw::c_char,
                            str3 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                            col, msg, str1, str2, str3, str4);
        } else if (*ctxt).type_0 == 1 as std::os::raw::c_int {
            let mut pctxt: xmlSchemaParserCtxtPtr =
                ctxt as xmlSchemaParserCtxtPtr;
            if errorLevel as std::os::raw::c_uint !=
                   XML_ERR_WARNING as std::os::raw::c_int as std::os::raw::c_uint {
                (*pctxt).nberrors += 1;
                (*pctxt).err = error;
                channel = (*pctxt).error
            } else { channel = (*pctxt).warning }
            schannel = (*pctxt).serror;
            data = (*pctxt).errCtxt;
            __xmlRaiseError(schannel, channel, data,
                            ctxt as *mut std::os::raw::c_void,
                            node as *mut std::os::raw::c_void,
                            XML_FROM_SCHEMASP as std::os::raw::c_int, error,
                            errorLevel, 0 as *const std::os::raw::c_char,
                            0 as std::os::raw::c_int, str1 as *const std::os::raw::c_char,
                            str2 as *const std::os::raw::c_char,
                            str3 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                            0 as std::os::raw::c_int, msg, str1, str2, str3, str4);
        } else {
            (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                       b"Unimplemented block at %s:%d\n\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const std::os::raw::c_char,
                                                                       b"xmlschemas.c\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const std::os::raw::c_char,
                                                                       2138 as
                                                                           std::os::raw::c_int);
        }
    };
}
/* *
 * xmlSchemaErr3:
 * @ctxt: the validation context
 * @node: the context node
 * @error: the error code
 * @msg: the error message
 * @str1: extra data
 * @str2: extra data
 * @str3: extra data
 *
 * Handle a validation error
 */
unsafe extern "C" fn xmlSchemaErr3(mut actxt: xmlSchemaAbstractCtxtPtr,
                                   mut error: std::os::raw::c_int,
                                   mut node: xmlNodePtr,
                                   mut msg: *const std::os::raw::c_char,
                                   mut str1: *const xmlChar,
                                   mut str2: *const xmlChar,
                                   mut str3: *const xmlChar) {
    xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0 as std::os::raw::c_int,
                      msg, str1, str2, str3, 0 as *const xmlChar);
}
unsafe extern "C" fn xmlSchemaErr4(mut actxt: xmlSchemaAbstractCtxtPtr,
                                   mut error: std::os::raw::c_int,
                                   mut node: xmlNodePtr,
                                   mut msg: *const std::os::raw::c_char,
                                   mut str1: *const xmlChar,
                                   mut str2: *const xmlChar,
                                   mut str3: *const xmlChar,
                                   mut str4: *const xmlChar) {
    xmlSchemaErr4Line(actxt, XML_ERR_ERROR, error, node, 0 as std::os::raw::c_int,
                      msg, str1, str2, str3, str4);
}
unsafe extern "C" fn xmlSchemaErr(mut actxt: xmlSchemaAbstractCtxtPtr,
                                  mut error: std::os::raw::c_int,
                                  mut node: xmlNodePtr,
                                  mut msg: *const std::os::raw::c_char,
                                  mut str1: *const xmlChar,
                                  mut str2: *const xmlChar) {
    xmlSchemaErr4(actxt, error, node, msg, str1, str2, 0 as *const xmlChar,
                  0 as *const xmlChar);
}
unsafe extern "C" fn xmlSchemaFormatNodeForError(mut msg: *mut *mut xmlChar,
                                                 mut actxt:
                                                     xmlSchemaAbstractCtxtPtr,
                                                 mut node: xmlNodePtr)
 -> *mut xmlChar {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    *msg = 0 as *mut xmlChar;
    if !node.is_null() &&
           (*node).type_0 as std::os::raw::c_uint !=
               XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint &&
           (*node).type_0 as std::os::raw::c_uint !=
               XML_ATTRIBUTE_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        /*
	* Don't try to format other nodes than element and
	* attribute nodes.
	* Play safe and return an empty string.
	*/
        *msg =
            xmlStrdup(b"\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        return *msg
    }
    if !node.is_null() {
        /*
	* Work on tree nodes.
	*/
        if (*node).type_0 as std::os::raw::c_uint ==
               XML_ATTRIBUTE_NODE as std::os::raw::c_int as std::os::raw::c_uint {
            let mut elem: xmlNodePtr = (*node).parent;
            *msg =
                xmlStrdup(b"Element \'\x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar);
            if !(*elem).ns.is_null() {
                *msg =
                    xmlStrcat(*msg,
                              xmlSchemaFormatQName(&mut str,
                                                   (*(*elem).ns).href,
                                                   (*elem).name))
            } else {
                *msg =
                    xmlStrcat(*msg,
                              xmlSchemaFormatQName(&mut str,
                                                   0 as *const xmlChar,
                                                   (*elem).name))
            }
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
            *msg =
                xmlStrcat(*msg,
                          b"\', \x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            *msg =
                xmlStrcat(*msg,
                          b"attribute \'\x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar)
        } else {
            *msg =
                xmlStrdup(b"Element \'\x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar)
        }
        if !(*node).ns.is_null() {
            *msg =
                xmlStrcat(*msg,
                          xmlSchemaFormatQName(&mut str, (*(*node).ns).href,
                                               (*node).name))
        } else {
            *msg =
                xmlStrcat(*msg,
                          xmlSchemaFormatQName(&mut str, 0 as *const xmlChar,
                                               (*node).name))
        }
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as
                                                            *mut std::os::raw::c_void);
            str = 0 as *mut xmlChar
        }
        *msg =
            xmlStrcat(*msg,
                      b"\': \x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    } else if (*actxt).type_0 == 2 as std::os::raw::c_int {
        let mut vctxt: xmlSchemaValidCtxtPtr = actxt as xmlSchemaValidCtxtPtr;
        /*
	* Work on node infos.
	*/
        if (*(*vctxt).inode).nodeType == XML_ATTRIBUTE_NODE as std::os::raw::c_int {
            let mut ielem: xmlSchemaNodeInfoPtr =
                *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
            *msg =
                xmlStrdup(b"Element \'\x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar);
            *msg =
                xmlStrcat(*msg,
                          xmlSchemaFormatQName(&mut str, (*ielem).nsName,
                                               (*ielem).localName));
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
            *msg =
                xmlStrcat(*msg,
                          b"\', \x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            *msg =
                xmlStrcat(*msg,
                          b"attribute \'\x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar)
        } else {
            *msg =
                xmlStrdup(b"Element \'\x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar)
        }
        *msg =
            xmlStrcat(*msg,
                      xmlSchemaFormatQName(&mut str, (*(*vctxt).inode).nsName,
                                           (*(*vctxt).inode).localName));
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as
                                                            *mut std::os::raw::c_void);
            str = 0 as *mut xmlChar
        }
        *msg =
            xmlStrcat(*msg,
                      b"\': \x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    } else if (*actxt).type_0 == 1 as std::os::raw::c_int {
        /*
	* Hmm, no node while parsing?
	* Return an empty string, in case NULL will break something.
	*/
        *msg =
            xmlStrdup(b"\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    } else {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Unimplemented block at %s:%d\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   b"xmlschemas.c\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   2259 as
                                                                       std::os::raw::c_int);
        return 0 as *mut xmlChar
    }
    /*
     * xmlSchemaFormatItemForReport() also returns an escaped format
     * string, so do this before calling it below (in the future).
     */
    xmlEscapeFormatString(msg);
    /*
    * VAL TODO: The output of the given schema component is currently
    * disabled.
    */
    return *msg;
}
unsafe extern "C" fn xmlSchemaInternalErr2(mut actxt:
                                               xmlSchemaAbstractCtxtPtr,
                                           mut funcName: *const std::os::raw::c_char,
                                           mut message: *const std::os::raw::c_char,
                                           mut str1: *const xmlChar,
                                           mut str2: *const xmlChar) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    if actxt.is_null() { return }
    msg =
        xmlStrdup(b"Internal error: %s, \x00" as *const u8 as
                      *const std::os::raw::c_char as *mut xmlChar);
    msg = xmlStrcat(msg, message as *mut xmlChar);
    msg =
        xmlStrcat(msg,
                  b".\n\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if (*actxt).type_0 == 2 as std::os::raw::c_int {
        xmlSchemaErr3(actxt, XML_SCHEMAV_INTERNAL as std::os::raw::c_int,
                      0 as xmlNodePtr, msg as *const std::os::raw::c_char,
                      funcName as *const xmlChar, str1, str2);
    } else if (*actxt).type_0 == 1 as std::os::raw::c_int {
        xmlSchemaErr3(actxt, XML_SCHEMAP_INTERNAL as std::os::raw::c_int,
                      0 as xmlNodePtr, msg as *const std::os::raw::c_char,
                      funcName as *const xmlChar, str1, str2);
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
        msg = 0 as *mut xmlChar
    };
}
unsafe extern "C" fn xmlSchemaInternalErr(mut actxt: xmlSchemaAbstractCtxtPtr,
                                          mut funcName: *const std::os::raw::c_char,
                                          mut message: *const std::os::raw::c_char) {
    xmlSchemaInternalErr2(actxt, funcName, message, 0 as *const xmlChar,
                          0 as *const xmlChar);
}
unsafe extern "C" fn xmlSchemaCustomErr4(mut actxt: xmlSchemaAbstractCtxtPtr,
                                         mut error: xmlParserErrors,
                                         mut node: xmlNodePtr,
                                         mut item: xmlSchemaBasicItemPtr,
                                         mut message: *const std::os::raw::c_char,
                                         mut str1: *const xmlChar,
                                         mut str2: *const xmlChar,
                                         mut str3: *const xmlChar,
                                         mut str4: *const xmlChar) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    if node.is_null() && !item.is_null() &&
           (*actxt).type_0 == 1 as std::os::raw::c_int {
        node = xmlSchemaGetComponentNode(item);
        xmlSchemaFormatItemForReport(&mut msg, 0 as *const xmlChar, item,
                                     0 as xmlNodePtr);
        msg =
            xmlStrcat(msg,
                      b": \x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    } else { xmlSchemaFormatNodeForError(&mut msg, actxt, node); }
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg =
        xmlStrcat(msg,
                  b".\n\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    xmlSchemaErr4(actxt, error as std::os::raw::c_int, node,
                  msg as *const std::os::raw::c_char, str1, str2, str3, str4);
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
        msg = 0 as *mut xmlChar
    };
}
unsafe extern "C" fn xmlSchemaCustomErr(mut actxt: xmlSchemaAbstractCtxtPtr,
                                        mut error: xmlParserErrors,
                                        mut node: xmlNodePtr,
                                        mut item: xmlSchemaBasicItemPtr,
                                        mut message: *const std::os::raw::c_char,
                                        mut str1: *const xmlChar,
                                        mut str2: *const xmlChar) {
    xmlSchemaCustomErr4(actxt, error, node, item, message, str1, str2,
                        0 as *const xmlChar, 0 as *const xmlChar);
}
unsafe extern "C" fn xmlSchemaCustomWarning(mut actxt:
                                                xmlSchemaAbstractCtxtPtr,
                                            mut error: xmlParserErrors,
                                            mut node: xmlNodePtr,
                                            mut type_0: xmlSchemaTypePtr,
                                            mut message: *const std::os::raw::c_char,
                                            mut str1: *const xmlChar,
                                            mut str2: *const xmlChar,
                                            mut str3: *const xmlChar) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg =
        xmlStrcat(msg,
                  b".\n\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    /* URGENT TODO: Set the error code to something sane. */
    xmlSchemaErr4Line(actxt, XML_ERR_WARNING, error as std::os::raw::c_int, node,
                      0 as std::os::raw::c_int, msg as *const std::os::raw::c_char, str1,
                      str2, str3, 0 as *const xmlChar);
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
        msg = 0 as *mut xmlChar
    };
}
unsafe extern "C" fn xmlSchemaKeyrefErr(mut vctxt: xmlSchemaValidCtxtPtr,
                                        mut error: xmlParserErrors,
                                        mut idcNode: xmlSchemaPSVIIDCNodePtr,
                                        mut type_0: xmlSchemaTypePtr,
                                        mut message: *const std::os::raw::c_char,
                                        mut str1: *const xmlChar,
                                        mut str2: *const xmlChar) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut qname: *mut xmlChar = 0 as *mut xmlChar;
    msg =
        xmlStrdup(b"Element \'%s\': \x00" as *const u8 as *const std::os::raw::c_char
                      as *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg =
        xmlStrcat(msg,
                  b".\n\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    xmlSchemaErr4Line(vctxt as xmlSchemaAbstractCtxtPtr, XML_ERR_ERROR,
                      error as std::os::raw::c_int, 0 as xmlNodePtr,
                      (*idcNode).nodeLine, msg as *const std::os::raw::c_char,
                      xmlSchemaFormatQName(&mut qname,
                                           *(*(*vctxt).nodeQNames).items.offset(((*idcNode).nodeQNameID
                                                                                     +
                                                                                     1
                                                                                         as
                                                                                         std::os::raw::c_int)
                                                                                    as
                                                                                    isize)
                                               as *const xmlChar,
                                           *(*(*vctxt).nodeQNames).items.offset((*idcNode).nodeQNameID
                                                                                    as
                                                                                    isize)
                                               as *const xmlChar), str1, str2,
                      0 as *const xmlChar);
    if !qname.is_null() {
        xmlFree.expect("non-null function pointer")(qname as
                                                        *mut std::os::raw::c_void);
        qname = 0 as *mut xmlChar
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
        msg = 0 as *mut xmlChar
    };
}
unsafe extern "C" fn xmlSchemaEvalErrorNodeType(mut actxt:
                                                    xmlSchemaAbstractCtxtPtr,
                                                mut node: xmlNodePtr)
 -> std::os::raw::c_int {
    if !node.is_null() { return (*node).type_0 as std::os::raw::c_int }
    if (*actxt).type_0 == 2 as std::os::raw::c_int &&
           !(*(actxt as xmlSchemaValidCtxtPtr)).inode.is_null() {
        return (*(*(actxt as xmlSchemaValidCtxtPtr)).inode).nodeType
    }
    return -(1 as std::os::raw::c_int);
}
unsafe extern "C" fn xmlSchemaIsGlobalItem(mut item: xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    match (*item).type_0 as std::os::raw::c_uint {
        5 | 4 => {
            if (*item).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0 {
                return 1 as std::os::raw::c_int
            }
        }
        17 => { return 1 as std::os::raw::c_int }
        14 => {
            if (*(item as xmlSchemaElementPtr)).flags &
                   (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
                return 1 as std::os::raw::c_int
            }
        }
        15 => {
            if (*(item as xmlSchemaAttributePtr)).flags &
                   (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 {
                return 1 as std::os::raw::c_int
            }
        }
        _ => {
            /* Note that attribute groups are always global. */
            return 1 as std::os::raw::c_int
        }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaSimpleTypeErr(mut actxt:
                                                xmlSchemaAbstractCtxtPtr,
                                            mut error: xmlParserErrors,
                                            mut node: xmlNodePtr,
                                            mut value: *const xmlChar,
                                            mut type_0: xmlSchemaTypePtr,
                                            mut displayValue: std::os::raw::c_int) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    if displayValue != 0 ||
           xmlSchemaEvalErrorNodeType(actxt, node) ==
               XML_ATTRIBUTE_NODE as std::os::raw::c_int {
        msg =
            xmlStrcat(msg,
                      b"\'%s\' is not a valid value of \x00" as *const u8 as
                          *const std::os::raw::c_char as *mut xmlChar)
    } else {
        msg =
            xmlStrcat(msg,
                      b"The character content is not a valid value of \x00" as
                          *const u8 as *const std::os::raw::c_char as *mut xmlChar)
    }
    if xmlSchemaIsGlobalItem(type_0) == 0 {
        msg =
            xmlStrcat(msg,
                      b"the local \x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    } else {
        msg =
            xmlStrcat(msg,
                      b"the \x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    if (*type_0).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0 {
        msg =
            xmlStrcat(msg,
                      b"atomic type\x00" as *const u8 as *const std::os::raw::c_char
                          as *mut xmlChar)
    } else if (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
        msg =
            xmlStrcat(msg,
                      b"list type\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    } else if (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
        msg =
            xmlStrcat(msg,
                      b"union type\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    if xmlSchemaIsGlobalItem(type_0) != 0 {
        let mut str: *mut xmlChar = 0 as *mut xmlChar;
        msg =
            xmlStrcat(msg,
                      b" \'\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        if (*type_0).builtInType != 0 as std::os::raw::c_int {
            msg =
                xmlStrcat(msg,
                          b"xs:\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            str = xmlStrdup((*type_0).name)
        } else {
            let mut qName: *const xmlChar =
                xmlSchemaFormatQName(&mut str, (*type_0).targetNamespace,
                                     (*type_0).name);
            if str.is_null() { str = xmlStrdup(qName) }
        }
        msg = xmlStrcat(msg, xmlEscapeFormatString(&mut str));
        msg =
            xmlStrcat(msg,
                      b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as
                                                            *mut std::os::raw::c_void);
            str = 0 as *mut xmlChar
        }
    }
    msg =
        xmlStrcat(msg,
                  b".\n\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if displayValue != 0 ||
           xmlSchemaEvalErrorNodeType(actxt, node) ==
               XML_ATTRIBUTE_NODE as std::os::raw::c_int {
        xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                     msg as *const std::os::raw::c_char, value, 0 as *const xmlChar);
    } else {
        xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                     msg as *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
        msg = 0 as *mut xmlChar
    };
}
unsafe extern "C" fn xmlSchemaFormatErrorNodeQName(mut str: *mut *mut xmlChar,
                                                   mut ni:
                                                       xmlSchemaNodeInfoPtr,
                                                   mut node: xmlNodePtr)
 -> *const xmlChar {
    if !node.is_null() {
        if !(*node).ns.is_null() {
            return xmlSchemaFormatQName(str, (*(*node).ns).href, (*node).name)
        } else {
            return xmlSchemaFormatQName(str, 0 as *const xmlChar,
                                        (*node).name)
        }
    } else {
        if !ni.is_null() {
            return xmlSchemaFormatQName(str, (*ni).nsName, (*ni).localName)
        }
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaIllegalAttrErr(mut actxt:
                                                 xmlSchemaAbstractCtxtPtr,
                                             mut error: xmlParserErrors,
                                             mut ni: xmlSchemaAttrInfoPtr,
                                             mut node: xmlNodePtr) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    msg =
        xmlStrcat(msg,
                  b"The attribute \'%s\' is not allowed.\n\x00" as *const u8
                      as *const std::os::raw::c_char as *mut xmlChar);
    xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                 msg as *const std::os::raw::c_char,
                 xmlSchemaFormatErrorNodeQName(&mut str,
                                               ni as xmlSchemaNodeInfoPtr,
                                               node), 0 as *const xmlChar);
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut std::os::raw::c_void);
        str = 0 as *mut xmlChar
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
        msg = 0 as *mut xmlChar
    };
}
unsafe extern "C" fn xmlSchemaComplexTypeErr(mut actxt:
                                                 xmlSchemaAbstractCtxtPtr,
                                             mut error: xmlParserErrors,
                                             mut node: xmlNodePtr,
                                             mut type_0: xmlSchemaTypePtr,
                                             mut message: *const std::os::raw::c_char,
                                             mut nbval: std::os::raw::c_int,
                                             mut nbneg: std::os::raw::c_int,
                                             mut values: *mut *mut xmlChar) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut nsName: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut end: *const xmlChar = 0 as *const xmlChar;
    let mut i: std::os::raw::c_int = 0;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg =
        xmlStrcat(msg,
                  b".\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    /*
    * Note that is does not make sense to report that we have a
    * wildcard here, since the wildcard might be unfolded into
    * multiple transitions.
    */
    if nbval + nbneg > 0 as std::os::raw::c_int {
        if nbval + nbneg > 1 as std::os::raw::c_int {
            str =
                xmlStrdup(b" Expected is one of ( \x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar)
        } else {
            str =
                xmlStrdup(b" Expected is ( \x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar)
        }
        nsName = 0 as *mut xmlChar;
        let mut current_block_55: u64;
        i = 0 as std::os::raw::c_int;
        while i < nbval + nbneg {
            cur = *values.offset(i as isize);
            if !cur.is_null() {
                if *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                       'n' as i32 &&
                       *cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int
                           == 'o' as i32 &&
                       *cur.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int
                           == 't' as i32 &&
                       *cur.offset(3 as std::os::raw::c_int as isize) as std::os::raw::c_int
                           == ' ' as i32 {
                    cur = cur.offset(4 as std::os::raw::c_int as isize);
                    str =
                        xmlStrcat(str,
                                  b"##other\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar)
                }
                /*
	    * Get the local name.
	    */
                localName = 0 as *mut xmlChar;
                end = cur;
                if *end as std::os::raw::c_int == '*' as i32 {
                    localName =
                        xmlStrdup(b"*\x00" as *const u8 as *const std::os::raw::c_char
                                      as *mut xmlChar);
                    end = end.offset(1)
                } else {
                    while *end as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                              *end as std::os::raw::c_int != '|' as i32 {
                        end = end.offset(1)
                    }
                    localName =
                        xmlStrncat(localName, cur as *mut xmlChar,
                                   end.offset_from(cur) as
                                       std::os::raw::c_long as std::os::raw::c_int)
                }
                if *end as std::os::raw::c_int != 0 as std::os::raw::c_int {
                    end = end.offset(1);
                    /*
		* Skip "*|*" if they come with negated expressions, since
		* they represent the same negated wildcard.
		*/
                    if nbneg == 0 as std::os::raw::c_int ||
                           *end as std::os::raw::c_int != '*' as i32 ||
                           *localName as std::os::raw::c_int != '*' as i32 {
                        /*
		    * Get the namespace name.
		    */
                        cur = end;
                        if *end as std::os::raw::c_int == '*' as i32 {
                            nsName =
                                xmlStrdup(b"{*}\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *mut xmlChar)
                        } else {
                            while *end as std::os::raw::c_int != 0 as std::os::raw::c_int {
                                end = end.offset(1)
                            }
                            if i >= nbval {
                                nsName =
                                    xmlStrdup(b"{##other:\x00" as *const u8 as
                                                  *const std::os::raw::c_char as
                                                  *mut xmlChar)
                            } else {
                                nsName =
                                    xmlStrdup(b"{\x00" as *const u8 as
                                                  *const std::os::raw::c_char as
                                                  *mut xmlChar)
                            }
                            nsName =
                                xmlStrncat(nsName, cur as *mut xmlChar,
                                           end.offset_from(cur) as
                                               std::os::raw::c_long as std::os::raw::c_int);
                            nsName =
                                xmlStrcat(nsName,
                                          b"}\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *mut xmlChar)
                        }
                        str = xmlStrcat(str, nsName);
                        if !nsName.is_null() {
                            xmlFree.expect("non-null function pointer")(nsName
                                                                            as
                                                                            *mut std::os::raw::c_void);
                            nsName = 0 as *mut xmlChar
                        }
                        current_block_55 = 7990025728955927862;
                    } else {
                        if !localName.is_null() {
                            xmlFree.expect("non-null function pointer")(localName
                                                                            as
                                                                            *mut std::os::raw::c_void);
                            localName = 0 as *mut xmlChar
                        }
                        current_block_55 = 13536709405535804910;
                    }
                } else { current_block_55 = 7990025728955927862; }
                match current_block_55 {
                    13536709405535804910 => { }
                    _ => {
                        str = xmlStrcat(str, localName);
                        if !localName.is_null() {
                            xmlFree.expect("non-null function pointer")(localName
                                                                            as
                                                                            *mut std::os::raw::c_void);
                            localName = 0 as *mut xmlChar
                        }
                        if i < nbval + nbneg - 1 as std::os::raw::c_int {
                            str =
                                xmlStrcat(str,
                                          b", \x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *mut xmlChar)
                        }
                    }
                }
            }
            i += 1
        }
        str =
            xmlStrcat(str,
                      b" ).\n\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        msg = xmlStrcat(msg, xmlEscapeFormatString(&mut str));
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as
                                                            *mut std::os::raw::c_void);
            str = 0 as *mut xmlChar
        }
    } else {
        msg =
            xmlStrcat(msg,
                      b"\n\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                 msg as *const std::os::raw::c_char, 0 as *const xmlChar,
                 0 as *const xmlChar);
    xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
}
unsafe extern "C" fn xmlSchemaFacetErr(mut actxt: xmlSchemaAbstractCtxtPtr,
                                       mut error: xmlParserErrors,
                                       mut node: xmlNodePtr,
                                       mut value: *const xmlChar,
                                       mut length: std::os::raw::c_ulong,
                                       mut type_0: xmlSchemaTypePtr,
                                       mut facet: xmlSchemaFacetPtr,
                                       mut message: *const std::os::raw::c_char,
                                       mut str1: *const xmlChar,
                                       mut str2: *const xmlChar) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut facetType: xmlSchemaTypeType = 0 as xmlSchemaTypeType;
    let mut nodeType: std::os::raw::c_int = xmlSchemaEvalErrorNodeType(actxt, node);
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    if error as std::os::raw::c_uint ==
           XML_SCHEMAV_CVC_ENUMERATION_VALID as std::os::raw::c_int as std::os::raw::c_uint {
        facetType = XML_SCHEMA_FACET_ENUMERATION
        /*
	* If enumerations are validated, one must not expect the
	* facet to be given.
	*/
    } else { facetType = (*facet).type_0 }
    msg =
        xmlStrcat(msg,
                  b"[\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    msg =
        xmlStrcat(msg,
                  b"facet \'\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facetType));
    msg =
        xmlStrcat(msg,
                  b"\'] \x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if message.is_null() {
        /*
	* Use a default message.
	*/
        if facetType as std::os::raw::c_uint ==
               XML_SCHEMA_FACET_LENGTH as std::os::raw::c_int as std::os::raw::c_uint ||
               facetType as std::os::raw::c_uint ==
                   XML_SCHEMA_FACET_MINLENGTH as std::os::raw::c_int as std::os::raw::c_uint
               ||
               facetType as std::os::raw::c_uint ==
                   XML_SCHEMA_FACET_MAXLENGTH as std::os::raw::c_int as std::os::raw::c_uint {
            let mut len: [std::os::raw::c_char; 25] = [0; 25];
            let mut actLen: [std::os::raw::c_char; 25] = [0; 25];
            /* FIXME, TODO: What is the max expected string length of the
	    * this value?
	    */
            if nodeType == XML_ATTRIBUTE_NODE as std::os::raw::c_int {
                msg =
                    xmlStrcat(msg,
                              b"The value \'%s\' has a length of \'%s\'; \x00"
                                  as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar)
            } else {
                msg =
                    xmlStrcat(msg,
                              b"The value has a length of \'%s\'; \x00" as
                                  *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar)
            }
            snprintf(len.as_mut_ptr(), 24 as std::os::raw::c_int as std::os::raw::c_ulong,
                     b"%lu\x00" as *const u8 as *const std::os::raw::c_char,
                     xmlSchemaGetFacetValueAsULong(facet));
            snprintf(actLen.as_mut_ptr(), 24 as std::os::raw::c_int as std::os::raw::c_ulong,
                     b"%lu\x00" as *const u8 as *const std::os::raw::c_char, length);
            if facetType as std::os::raw::c_uint ==
                   XML_SCHEMA_FACET_LENGTH as std::os::raw::c_int as std::os::raw::c_uint {
                msg =
                    xmlStrcat(msg,
                              b"this differs from the allowed length of \'%s\'.\n\x00"
                                  as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar)
            } else if facetType as std::os::raw::c_uint ==
                          XML_SCHEMA_FACET_MAXLENGTH as std::os::raw::c_int as
                              std::os::raw::c_uint {
                msg =
                    xmlStrcat(msg,
                              b"this exceeds the allowed maximum length of \'%s\'.\n\x00"
                                  as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar)
            } else if facetType as std::os::raw::c_uint ==
                          XML_SCHEMA_FACET_MINLENGTH as std::os::raw::c_int as
                              std::os::raw::c_uint {
                msg =
                    xmlStrcat(msg,
                              b"this underruns the allowed minimum length of \'%s\'.\n\x00"
                                  as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar)
            }
            if nodeType == XML_ATTRIBUTE_NODE as std::os::raw::c_int {
                xmlSchemaErr3(actxt, error as std::os::raw::c_int, node,
                              msg as *const std::os::raw::c_char, value,
                              actLen.as_mut_ptr() as *const xmlChar,
                              len.as_mut_ptr() as *const xmlChar);
            } else {
                xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                             msg as *const std::os::raw::c_char,
                             actLen.as_mut_ptr() as *const xmlChar,
                             len.as_mut_ptr() as *const xmlChar);
            }
        } else if facetType as std::os::raw::c_uint ==
                      XML_SCHEMA_FACET_ENUMERATION as std::os::raw::c_int as
                          std::os::raw::c_uint {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' is not an element of the set {%s}.\n\x00"
                              as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, value,
                         xmlSchemaFormatFacetEnumSet(actxt, &mut str,
                                                     type_0));
        } else if facetType as std::os::raw::c_uint ==
                      XML_SCHEMA_FACET_PATTERN as std::os::raw::c_int as std::os::raw::c_uint
         {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' is not accepted by the pattern \'%s\'.\n\x00"
                              as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, value, (*facet).value);
        } else if facetType as std::os::raw::c_uint ==
                      XML_SCHEMA_FACET_MININCLUSIVE as std::os::raw::c_int as
                          std::os::raw::c_uint {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' is less than the minimum value allowed (\'%s\').\n\x00"
                              as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, value, (*facet).value);
        } else if facetType as std::os::raw::c_uint ==
                      XML_SCHEMA_FACET_MAXINCLUSIVE as std::os::raw::c_int as
                          std::os::raw::c_uint {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' is greater than the maximum value allowed (\'%s\').\n\x00"
                              as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, value, (*facet).value);
        } else if facetType as std::os::raw::c_uint ==
                      XML_SCHEMA_FACET_MINEXCLUSIVE as std::os::raw::c_int as
                          std::os::raw::c_uint {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' must be greater than \'%s\'.\n\x00"
                              as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, value, (*facet).value);
        } else if facetType as std::os::raw::c_uint ==
                      XML_SCHEMA_FACET_MAXEXCLUSIVE as std::os::raw::c_int as
                          std::os::raw::c_uint {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' must be less than \'%s\'.\n\x00"
                              as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, value, (*facet).value);
        } else if facetType as std::os::raw::c_uint ==
                      XML_SCHEMA_FACET_TOTALDIGITS as std::os::raw::c_int as
                          std::os::raw::c_uint {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' has more digits than are allowed (\'%s\').\n\x00"
                              as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, value, (*facet).value);
        } else if facetType as std::os::raw::c_uint ==
                      XML_SCHEMA_FACET_FRACTIONDIGITS as std::os::raw::c_int as
                          std::os::raw::c_uint {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' has more fractional digits than are allowed (\'%s\').\n\x00"
                              as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, value, (*facet).value);
        } else if nodeType == XML_ATTRIBUTE_NODE as std::os::raw::c_int {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' is not facet-valid.\n\x00" as
                              *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, value,
                         0 as *const xmlChar);
        } else {
            msg =
                xmlStrcat(msg,
                          b"The value is not facet-valid.\n\x00" as *const u8
                              as *const std::os::raw::c_char as *mut xmlChar);
            xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                         msg as *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        }
    } else {
        msg = xmlStrcat(msg, message as *const xmlChar);
        msg =
            xmlStrcat(msg,
                      b".\n\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        xmlSchemaErr(actxt, error as std::os::raw::c_int, node,
                     msg as *const std::os::raw::c_char, str1, str2);
    }
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut std::os::raw::c_void);
        str = 0 as *mut xmlChar
    }
    xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaPMissingAttrErr:
 * @ctxt: the schema validation context
 * @ownerDes: the designation of  the owner
 * @ownerName: the name of the owner
 * @ownerItem: the owner as a schema object
 * @ownerElem: the owner as an element node
 * @node: the parent element node of the missing attribute node
 * @type: the corresponding type of the attribute node
 *
 * Reports an illegal attribute.
 */
unsafe extern "C" fn xmlSchemaPMissingAttrErr(mut ctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut error: xmlParserErrors,
                                              mut ownerItem:
                                                  xmlSchemaBasicItemPtr,
                                              mut ownerElem: xmlNodePtr,
                                              mut name: *const std::os::raw::c_char,
                                              mut message:
                                                  *const std::os::raw::c_char) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem,
                                 ownerElem);
    if !message.is_null() {
        xmlSchemaPErr(ctxt, ownerElem, error as std::os::raw::c_int,
                      b"%s: %s.\n\x00" as *const u8 as *const std::os::raw::c_char,
                      des, message as *mut xmlChar);
    } else {
        xmlSchemaPErr(ctxt, ownerElem, error as std::os::raw::c_int,
                      b"%s: The attribute \'%s\' is required but missing.\n\x00"
                          as *const u8 as *const std::os::raw::c_char, des,
                      name as *mut xmlChar);
    }
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut std::os::raw::c_void);
        des = 0 as *mut xmlChar
    };
}
/* *
 * xmlSchemaPResCompAttrErr:
 * @ctxt: the schema validation context
 * @error: the error code
 * @ownerDes: the designation of  the owner
 * @ownerItem: the owner as a schema object
 * @ownerElem: the owner as an element node
 * @name: the name of the attribute holding the QName
 * @refName: the referenced local name
 * @refURI: the referenced namespace URI
 * @message: optional message
 *
 * Used to report QName attribute values that failed to resolve
 * to schema components.
 */
unsafe extern "C" fn xmlSchemaPResCompAttrErr(mut ctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut error: xmlParserErrors,
                                              mut ownerItem:
                                                  xmlSchemaBasicItemPtr,
                                              mut ownerElem: xmlNodePtr,
                                              mut name: *const std::os::raw::c_char,
                                              mut refName: *const xmlChar,
                                              mut refURI: *const xmlChar,
                                              mut refType: xmlSchemaTypeType,
                                              mut refTypeStr:
                                                  *const std::os::raw::c_char) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    let mut strA: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem,
                                 ownerElem);
    if refTypeStr.is_null() {
        refTypeStr = xmlSchemaItemTypeToStr(refType) as *const std::os::raw::c_char
    }
    xmlSchemaPErrExt(ctxt, ownerElem, error as std::os::raw::c_int,
                     0 as *const xmlChar, 0 as *const xmlChar,
                     0 as *const xmlChar,
                     b"%s, attribute \'%s\': The QName value \'%s\' does not resolve to a(n) %s.\n\x00"
                         as *const u8 as *const std::os::raw::c_char, des,
                     name as *mut xmlChar,
                     xmlSchemaFormatQName(&mut strA, refURI, refName),
                     refTypeStr as *mut xmlChar, 0 as *const xmlChar);
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut std::os::raw::c_void);
        des = 0 as *mut xmlChar
    }
    if !strA.is_null() {
        xmlFree.expect("non-null function pointer")(strA as
                                                        *mut std::os::raw::c_void);
        strA = 0 as *mut xmlChar
    };
}
/* *
 * xmlSchemaPCustomAttrErr:
 * @ctxt: the schema parser context
 * @error: the error code
 * @ownerDes: the designation of the owner
 * @ownerItem: the owner as a schema object
 * @attr: the illegal attribute node
 *
 * Reports an illegal attribute during the parse.
 */
unsafe extern "C" fn xmlSchemaPCustomAttrErr(mut ctxt: xmlSchemaParserCtxtPtr,
                                             mut error: xmlParserErrors,
                                             mut ownerDes: *mut *mut xmlChar,
                                             mut ownerItem:
                                                 xmlSchemaBasicItemPtr,
                                             mut attr: xmlAttrPtr,
                                             mut msg: *const std::os::raw::c_char) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    if ownerDes.is_null() {
        xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem,
                                     (*attr).parent);
    } else if (*ownerDes).is_null() {
        xmlSchemaFormatItemForReport(ownerDes, 0 as *const xmlChar, ownerItem,
                                     (*attr).parent);
        des = *ownerDes
    } else { des = *ownerDes }
    if attr.is_null() {
        xmlSchemaPErrExt(ctxt, 0 as xmlNodePtr, error as std::os::raw::c_int,
                         0 as *const xmlChar, 0 as *const xmlChar,
                         0 as *const xmlChar,
                         b"%s, attribute \'%s\': %s.\n\x00" as *const u8 as
                             *const std::os::raw::c_char, des,
                         b"Unknown\x00" as *const u8 as *const std::os::raw::c_char as
                             *const xmlChar, msg as *const xmlChar,
                         0 as *const xmlChar, 0 as *const xmlChar);
    } else {
        xmlSchemaPErrExt(ctxt, attr as xmlNodePtr, error as std::os::raw::c_int,
                         0 as *const xmlChar, 0 as *const xmlChar,
                         0 as *const xmlChar,
                         b"%s, attribute \'%s\': %s.\n\x00" as *const u8 as
                             *const std::os::raw::c_char, des, (*attr).name,
                         msg as *const xmlChar, 0 as *const xmlChar,
                         0 as *const xmlChar);
    }
    if ownerDes.is_null() {
        if !des.is_null() {
            xmlFree.expect("non-null function pointer")(des as
                                                            *mut std::os::raw::c_void);
            des = 0 as *mut xmlChar
        }
    };
}
/* *
 * xmlSchemaPIllegalAttrErr:
 * @ctxt: the schema parser context
 * @error: the error code
 * @ownerDes: the designation of the attribute's owner
 * @ownerItem: the attribute's owner item
 * @attr: the illegal attribute node
 *
 * Reports an illegal attribute during the parse.
 */
unsafe extern "C" fn xmlSchemaPIllegalAttrErr(mut ctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut error: xmlParserErrors,
                                              mut ownerComp:
                                                  xmlSchemaBasicItemPtr,
                                              mut attr: xmlAttrPtr) {
    let mut strA: *mut xmlChar = 0 as *mut xmlChar;
    let mut strB: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut strA, ctxt as xmlSchemaAbstractCtxtPtr,
                                (*attr).parent);
    xmlSchemaErr4(ctxt as xmlSchemaAbstractCtxtPtr, error as std::os::raw::c_int,
                  attr as xmlNodePtr,
                  b"%sThe attribute \'%s\' is not allowed.\n\x00" as *const u8
                      as *const std::os::raw::c_char, strA,
                  xmlSchemaFormatQNameNs(&mut strB, (*attr).ns, (*attr).name),
                  0 as *const xmlChar, 0 as *const xmlChar);
    if !strA.is_null() {
        xmlFree.expect("non-null function pointer")(strA as
                                                        *mut std::os::raw::c_void);
        strA = 0 as *mut xmlChar
    }
    if !strB.is_null() {
        xmlFree.expect("non-null function pointer")(strB as
                                                        *mut std::os::raw::c_void);
        strB = 0 as *mut xmlChar
    };
}
/* *
 * xmlSchemaPCustomErr:
 * @ctxt: the schema parser context
 * @error: the error code
 * @itemDes: the designation of the schema item
 * @item: the schema item
 * @itemElem: the node of the schema item
 * @message: the error message
 * @str1: an optional param for the error message
 * @str2: an optional param for the error message
 * @str3: an optional param for the error message
 *
 * Reports an error during parsing.
 */
unsafe extern "C" fn xmlSchemaPCustomErrExt(mut ctxt: xmlSchemaParserCtxtPtr,
                                            mut error: xmlParserErrors,
                                            mut item: xmlSchemaBasicItemPtr,
                                            mut itemElem: xmlNodePtr,
                                            mut message: *const std::os::raw::c_char,
                                            mut str1: *const xmlChar,
                                            mut str2: *const xmlChar,
                                            mut str3: *const xmlChar) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, item,
                                 itemElem);
    msg =
        xmlStrdup(b"%s: \x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg =
        xmlStrcat(msg,
                  b".\n\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if itemElem.is_null() && !item.is_null() {
        itemElem = xmlSchemaGetComponentNode(item)
    }
    xmlSchemaPErrExt(ctxt, itemElem, error as std::os::raw::c_int,
                     0 as *const xmlChar, 0 as *const xmlChar,
                     0 as *const xmlChar, msg as *const std::os::raw::c_char, des,
                     str1, str2, str3, 0 as *const xmlChar);
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut std::os::raw::c_void);
        des = 0 as *mut xmlChar
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
        msg = 0 as *mut xmlChar
    };
}
/* *
 * xmlSchemaPCustomErr:
 * @ctxt: the schema parser context
 * @error: the error code
 * @itemDes: the designation of the schema item
 * @item: the schema item
 * @itemElem: the node of the schema item
 * @message: the error message
 * @str1: the optional param for the error message
 *
 * Reports an error during parsing.
 */
unsafe extern "C" fn xmlSchemaPCustomErr(mut ctxt: xmlSchemaParserCtxtPtr,
                                         mut error: xmlParserErrors,
                                         mut item: xmlSchemaBasicItemPtr,
                                         mut itemElem: xmlNodePtr,
                                         mut message: *const std::os::raw::c_char,
                                         mut str1: *const xmlChar) {
    xmlSchemaPCustomErrExt(ctxt, error, item, itemElem, message, str1,
                           0 as *const xmlChar, 0 as *const xmlChar);
}
/* *
 * xmlSchemaPAttrUseErr:
 * @ctxt: the schema parser context
 * @error: the error code
 * @itemDes: the designation of the schema type
 * @item: the schema type
 * @itemElem: the node of the schema type
 * @attr: the invalid schema attribute
 * @message: the error message
 * @str1: the optional param for the error message
 *
 * Reports an attribute use error during parsing.
 */
unsafe extern "C" fn xmlSchemaPAttrUseErr4(mut ctxt: xmlSchemaParserCtxtPtr,
                                           mut error: xmlParserErrors,
                                           mut node: xmlNodePtr,
                                           mut ownerItem:
                                               xmlSchemaBasicItemPtr,
                                           attruse: xmlSchemaAttributeUsePtr,
                                           mut message: *const std::os::raw::c_char,
                                           mut str1: *const xmlChar,
                                           mut str2: *const xmlChar,
                                           mut str3: *const xmlChar,
                                           mut str4: *const xmlChar) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut msg, 0 as *const xmlChar, ownerItem,
                                 0 as xmlNodePtr);
    msg =
        xmlStrcat(msg,
                  b", \x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    msg =
        xmlStrcat(msg,
                  xmlSchemaFormatItemForReport(&mut str, 0 as *const xmlChar,
                                               attruse as
                                                   xmlSchemaBasicItemPtr,
                                               0 as xmlNodePtr));
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut std::os::raw::c_void);
        str = 0 as *mut xmlChar
    }
    msg =
        xmlStrcat(msg,
                  b": \x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg =
        xmlStrcat(msg,
                  b".\n\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    xmlSchemaErr4(ctxt as xmlSchemaAbstractCtxtPtr, error as std::os::raw::c_int,
                  node, msg as *const std::os::raw::c_char, str1, str2, str3, str4);
    xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaPIllegalFacetAtomicErr:
 * @ctxt: the schema parser context
 * @error: the error code
 * @type: the schema type
 * @baseType: the base type of type
 * @facet: the illegal facet
 *
 * Reports an illegal facet for atomic simple types.
 */
unsafe extern "C" fn xmlSchemaPIllegalFacetAtomicErr(mut ctxt:
                                                         xmlSchemaParserCtxtPtr,
                                                     mut error:
                                                         xmlParserErrors,
                                                     mut type_0:
                                                         xmlSchemaTypePtr,
                                                     mut baseType:
                                                         xmlSchemaTypePtr,
                                                     mut facet:
                                                         xmlSchemaFacetPtr) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    let mut strT: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar,
                                 type_0 as xmlSchemaBasicItemPtr,
                                 (*type_0).node);
    xmlSchemaPErrExt(ctxt, (*type_0).node, error as std::os::raw::c_int,
                     0 as *const xmlChar, 0 as *const xmlChar,
                     0 as *const xmlChar,
                     b"%s: The facet \'%s\' is not allowed on types derived from the type %s.\n\x00"
                         as *const u8 as *const std::os::raw::c_char, des,
                     xmlSchemaFacetTypeToString((*facet).type_0),
                     xmlSchemaFormatItemForReport(&mut strT,
                                                  0 as *const xmlChar,
                                                  baseType as
                                                      xmlSchemaBasicItemPtr,
                                                  0 as xmlNodePtr),
                     0 as *const xmlChar, 0 as *const xmlChar);
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut std::os::raw::c_void);
        des = 0 as *mut xmlChar
    }
    if !strT.is_null() {
        xmlFree.expect("non-null function pointer")(strT as
                                                        *mut std::os::raw::c_void);
        strT = 0 as *mut xmlChar
    };
}
/* *
 * xmlSchemaPIllegalFacetListUnionErr:
 * @ctxt: the schema parser context
 * @error: the error code
 * @itemDes: the designation of the schema item involved
 * @item: the schema item involved
 * @facet: the illegal facet
 *
 * Reports an illegal facet for <list> and <union>.
 */
unsafe extern "C" fn xmlSchemaPIllegalFacetListUnionErr(mut ctxt:
                                                            xmlSchemaParserCtxtPtr,
                                                        mut error:
                                                            xmlParserErrors,
                                                        mut type_0:
                                                            xmlSchemaTypePtr,
                                                        mut facet:
                                                            xmlSchemaFacetPtr) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar,
                                 type_0 as xmlSchemaBasicItemPtr,
                                 (*type_0).node);
    xmlSchemaPErr(ctxt, (*type_0).node, error as std::os::raw::c_int,
                  b"%s: The facet \'%s\' is not allowed.\n\x00" as *const u8
                      as *const std::os::raw::c_char, des,
                  xmlSchemaFacetTypeToString((*facet).type_0));
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut std::os::raw::c_void);
        des = 0 as *mut xmlChar
    };
}
/* *
 * xmlSchemaPMutualExclAttrErr:
 * @ctxt: the schema validation context
 * @error: the error code
 * @elemDes: the designation of the parent element node
 * @attr: the bad attribute node
 * @type: the corresponding type of the attribute node
 *
 * Reports an illegal attribute.
 */
unsafe extern "C" fn xmlSchemaPMutualExclAttrErr(mut ctxt:
                                                     xmlSchemaParserCtxtPtr,
                                                 mut error: xmlParserErrors,
                                                 mut ownerItem:
                                                     xmlSchemaBasicItemPtr,
                                                 mut attr: xmlAttrPtr,
                                                 mut name1:
                                                     *const std::os::raw::c_char,
                                                 mut name2:
                                                     *const std::os::raw::c_char) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem,
                                 (*attr).parent);
    xmlSchemaPErrExt(ctxt, attr as xmlNodePtr, error as std::os::raw::c_int,
                     0 as *const xmlChar, 0 as *const xmlChar,
                     0 as *const xmlChar,
                     b"%s: The attributes \'%s\' and \'%s\' are mutually exclusive.\n\x00"
                         as *const u8 as *const std::os::raw::c_char, des,
                     name1 as *mut xmlChar, name2 as *mut xmlChar,
                     0 as *const xmlChar, 0 as *const xmlChar);
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut std::os::raw::c_void);
        des = 0 as *mut xmlChar
    };
}
/* *
 * xmlSchemaPSimpleTypeErr:
 * @ctxt:  the schema validation context
 * @error: the error code
 * @type: the type specifier
 * @ownerDes: the designation of the owner
 * @ownerItem: the schema object if existent
 * @node: the validated node
 * @value: the validated value
 *
 * Reports a simple type validation error.
 * TODO: Should this report the value of an element as well?
 */
unsafe extern "C" fn xmlSchemaPSimpleTypeErr(mut ctxt: xmlSchemaParserCtxtPtr,
                                             mut error: xmlParserErrors,
                                             mut ownerItem:
                                                 xmlSchemaBasicItemPtr,
                                             mut node: xmlNodePtr,
                                             mut type_0: xmlSchemaTypePtr,
                                             mut expected:
                                                 *const std::os::raw::c_char,
                                             mut value: *const xmlChar,
                                             mut message: *const std::os::raw::c_char,
                                             mut str1: *const xmlChar,
                                             mut str2: *const xmlChar) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, ctxt as xmlSchemaAbstractCtxtPtr,
                                node);
    if message.is_null() {
        /*
	* Use default messages.
	*/
        if !type_0.is_null() {
            if (*node).type_0 as std::os::raw::c_uint ==
                   XML_ATTRIBUTE_NODE as std::os::raw::c_int as std::os::raw::c_uint {
                msg =
                    xmlStrcat(msg,
                              b"\'%s\' is not a valid value of \x00" as
                                  *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar)
            } else {
                msg =
                    xmlStrcat(msg,
                              b"The character content is not a valid value of \x00"
                                  as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar)
            }
            if xmlSchemaIsGlobalItem(type_0) == 0 {
                msg =
                    xmlStrcat(msg,
                              b"the local \x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar)
            } else {
                msg =
                    xmlStrcat(msg,
                              b"the \x00" as *const u8 as *const std::os::raw::c_char
                                  as *mut xmlChar)
            }
            if (*type_0).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0 {
                msg =
                    xmlStrcat(msg,
                              b"atomic type\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar)
            } else if (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int
                          != 0 {
                msg =
                    xmlStrcat(msg,
                              b"list type\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar)
            } else if (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int
                          != 0 {
                msg =
                    xmlStrcat(msg,
                              b"union type\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar)
            }
            if xmlSchemaIsGlobalItem(type_0) != 0 {
                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                msg =
                    xmlStrcat(msg,
                              b" \'\x00" as *const u8 as *const std::os::raw::c_char
                                  as *mut xmlChar);
                if (*type_0).builtInType != 0 as std::os::raw::c_int {
                    msg =
                        xmlStrcat(msg,
                                  b"xs:\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar);
                    str = xmlStrdup((*type_0).name)
                } else {
                    let mut qName: *const xmlChar =
                        xmlSchemaFormatQName(&mut str,
                                             (*type_0).targetNamespace,
                                             (*type_0).name);
                    if str.is_null() { str = xmlStrdup(qName) }
                }
                msg = xmlStrcat(msg, xmlEscapeFormatString(&mut str));
                msg =
                    xmlStrcat(msg,
                              b"\'.\x00" as *const u8 as *const std::os::raw::c_char
                                  as *mut xmlChar);
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
            }
        } else if (*node).type_0 as std::os::raw::c_uint ==
                      XML_ATTRIBUTE_NODE as std::os::raw::c_int as std::os::raw::c_uint {
            msg =
                xmlStrcat(msg,
                          b"The value \'%s\' is not valid.\x00" as *const u8
                              as *const std::os::raw::c_char as *mut xmlChar)
        } else {
            msg =
                xmlStrcat(msg,
                          b"The character content is not valid.\x00" as
                              *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar)
        }
        if !expected.is_null() {
            let mut expectedEscaped: *mut xmlChar = xmlCharStrdup(expected);
            msg =
                xmlStrcat(msg,
                          b" Expected is \'\x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar);
            msg = xmlStrcat(msg, xmlEscapeFormatString(&mut expectedEscaped));
            if !expectedEscaped.is_null() {
                xmlFree.expect("non-null function pointer")(expectedEscaped as
                                                                *mut std::os::raw::c_void);
                expectedEscaped = 0 as *mut xmlChar
            }
            msg =
                xmlStrcat(msg,
                          b"\'.\n\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar)
        } else {
            msg =
                xmlStrcat(msg,
                          b"\n\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar)
        }
        if (*node).type_0 as std::os::raw::c_uint ==
               XML_ATTRIBUTE_NODE as std::os::raw::c_int as std::os::raw::c_uint {
            xmlSchemaPErr(ctxt, node, error as std::os::raw::c_int,
                          msg as *const std::os::raw::c_char, value,
                          0 as *const xmlChar);
        } else {
            xmlSchemaPErr(ctxt, node, error as std::os::raw::c_int,
                          msg as *const std::os::raw::c_char, 0 as *const xmlChar,
                          0 as *const xmlChar);
        }
    } else {
        msg = xmlStrcat(msg, message as *mut xmlChar);
        msg =
            xmlStrcat(msg,
                      b".\n\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        xmlSchemaPErrExt(ctxt, node, error as std::os::raw::c_int,
                         0 as *const xmlChar, 0 as *const xmlChar,
                         0 as *const xmlChar, msg as *const std::os::raw::c_char,
                         str1, str2, 0 as *const xmlChar, 0 as *const xmlChar,
                         0 as *const xmlChar);
    }
    /* Cleanup. */
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
        msg = 0 as *mut xmlChar
    };
}
/* *
 * xmlSchemaPContentErr:
 * @ctxt: the schema parser context
 * @error: the error code
 * @onwerDes: the designation of the holder of the content
 * @ownerItem: the owner item of the holder of the content
 * @ownerElem: the node of the holder of the content
 * @child: the invalid child node
 * @message: the optional error message
 * @content: the optional string describing the correct content
 *
 * Reports an error concerning the content of a schema element.
 */
unsafe extern "C" fn xmlSchemaPContentErr(mut ctxt: xmlSchemaParserCtxtPtr,
                                          mut error: xmlParserErrors,
                                          mut ownerItem:
                                              xmlSchemaBasicItemPtr,
                                          mut ownerElem: xmlNodePtr,
                                          mut child: xmlNodePtr,
                                          mut message: *const std::os::raw::c_char,
                                          mut content: *const std::os::raw::c_char) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem,
                                 ownerElem);
    if !message.is_null() {
        xmlSchemaPErr2(ctxt, ownerElem, child, error as std::os::raw::c_int,
                       b"%s: %s.\n\x00" as *const u8 as *const std::os::raw::c_char,
                       des, message as *mut xmlChar);
    } else if !content.is_null() {
        xmlSchemaPErr2(ctxt, ownerElem, child, error as std::os::raw::c_int,
                       b"%s: The content is not valid. Expected is %s.\n\x00"
                           as *const u8 as *const std::os::raw::c_char, des,
                       content as *mut xmlChar);
    } else {
        xmlSchemaPErr2(ctxt, ownerElem, child, error as std::os::raw::c_int,
                       b"%s: The content is not valid.\n\x00" as *const u8 as
                           *const std::os::raw::c_char, des, 0 as *const xmlChar);
    }
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut std::os::raw::c_void);
        des = 0 as *mut xmlChar
    };
}
/* ***********************************************************************
 *									*
 *			Streamable error functions                      *
 *									*
 ************************************************************************/
/* ***********************************************************************
 *									*
 *			Validation helper functions			*
 *									*
 ************************************************************************/
/* ***********************************************************************
 *									*
 *			Allocation functions				*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaNewSchemaForParserCtxt:
 * @ctxt:  a schema validation context
 *
 * Allocate a new Schema structure.
 *
 * Returns the newly allocated structure or NULL in case or error
 */
unsafe extern "C" fn xmlSchemaNewSchema(mut ctxt: xmlSchemaParserCtxtPtr)
 -> xmlSchemaPtr {
    let mut ret: xmlSchemaPtr = 0 as *mut xmlSchema;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchema>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating schema\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchema>() as std::os::raw::c_ulong);
    (*ret).dict = (*ctxt).dict;
    xmlDictReference((*ret).dict);
    return ret;
}
/* *
 * xmlSchemaNewFacet:
 *
 * Allocate a new Facet structure.
 *
 * Returns the newly allocated structure or NULL in case or error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewFacet() -> xmlSchemaFacetPtr {
    let mut ret: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaFacet>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaFacetPtr;
    if ret.is_null() { return 0 as xmlSchemaFacetPtr }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaFacet>() as std::os::raw::c_ulong);
    return ret;
}
/* *
 * xmlSchemaNewAnnot:
 * @ctxt:  a schema validation context
 * @node:  a node
 *
 * Allocate a new annotation structure.
 *
 * Returns the newly allocated structure or NULL in case or error
 */
unsafe extern "C" fn xmlSchemaNewAnnot(mut ctxt: xmlSchemaParserCtxtPtr,
                                       mut node: xmlNodePtr)
 -> xmlSchemaAnnotPtr {
    let mut ret: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaAnnot>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaAnnotPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating annotation\x00" as *const u8 as
                                *const std::os::raw::c_char, node);
        return 0 as xmlSchemaAnnotPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaAnnot>() as std::os::raw::c_ulong);
    (*ret).content = node;
    return ret;
}
unsafe extern "C" fn xmlSchemaItemListCreate() -> xmlSchemaItemListPtr {
    let mut ret: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaItemList>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaItemListPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                            b"allocating an item list structure\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaItemListPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaItemList>() as std::os::raw::c_ulong);
    return ret;
}
unsafe extern "C" fn xmlSchemaItemListClear(mut list: xmlSchemaItemListPtr) {
    if !(*list).items.is_null() {
        xmlFree.expect("non-null function pointer")((*list).items as
                                                        *mut std::os::raw::c_void);
        (*list).items = 0 as *mut *mut std::os::raw::c_void
    }
    (*list).nbItems = 0 as std::os::raw::c_int;
    (*list).sizeItems = 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaItemListAdd(mut list: xmlSchemaItemListPtr,
                                          mut item: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    if (*list).items.is_null() {
        (*list).items =
            xmlMalloc.expect("non-null function pointer")((20 as std::os::raw::c_int
                                                               as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut *mut std::os::raw::c_void;
        if (*list).items.is_null() {
            xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                                b"allocating new item list\x00" as *const u8
                                    as *const std::os::raw::c_char, 0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
        (*list).sizeItems = 20 as std::os::raw::c_int
    } else if (*list).sizeItems <= (*list).nbItems {
        (*list).sizeItems *= 2 as std::os::raw::c_int;
        (*list).items =
            xmlRealloc.expect("non-null function pointer")((*list).items as
                                                               *mut std::os::raw::c_void,
                                                           ((*list).sizeItems
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut *mut std::os::raw::c_void;
        if (*list).items.is_null() {
            xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                                b"growing item list\x00" as *const u8 as
                                    *const std::os::raw::c_char, 0 as xmlNodePtr);
            (*list).sizeItems = 0 as std::os::raw::c_int;
            return -(1 as std::os::raw::c_int)
        }
    }
    let fresh0 = (*list).nbItems;
    (*list).nbItems = (*list).nbItems + 1;
    let ref mut fresh1 = *(*list).items.offset(fresh0 as isize);
    *fresh1 = item;
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaItemListAddSize(mut list: xmlSchemaItemListPtr,
                                              mut initialSize: std::os::raw::c_int,
                                              mut item: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    if (*list).items.is_null() {
        if initialSize <= 0 as std::os::raw::c_int { initialSize = 1 as std::os::raw::c_int }
        (*list).items =
            xmlMalloc.expect("non-null function pointer")((initialSize as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut *mut std::os::raw::c_void;
        if (*list).items.is_null() {
            xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                                b"allocating new item list\x00" as *const u8
                                    as *const std::os::raw::c_char, 0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
        (*list).sizeItems = initialSize
    } else if (*list).sizeItems <= (*list).nbItems {
        (*list).sizeItems *= 2 as std::os::raw::c_int;
        (*list).items =
            xmlRealloc.expect("non-null function pointer")((*list).items as
                                                               *mut std::os::raw::c_void,
                                                           ((*list).sizeItems
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut *mut std::os::raw::c_void;
        if (*list).items.is_null() {
            xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                                b"growing item list\x00" as *const u8 as
                                    *const std::os::raw::c_char, 0 as xmlNodePtr);
            (*list).sizeItems = 0 as std::os::raw::c_int;
            return -(1 as std::os::raw::c_int)
        }
    }
    let fresh2 = (*list).nbItems;
    (*list).nbItems = (*list).nbItems + 1;
    let ref mut fresh3 = *(*list).items.offset(fresh2 as isize);
    *fresh3 = item;
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaItemListInsert(mut list: xmlSchemaItemListPtr,
                                             mut item: *mut std::os::raw::c_void,
                                             mut idx: std::os::raw::c_int)
 -> std::os::raw::c_int {
    if (*list).items.is_null() {
        (*list).items =
            xmlMalloc.expect("non-null function pointer")((20 as std::os::raw::c_int
                                                               as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut *mut std::os::raw::c_void;
        if (*list).items.is_null() {
            xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                                b"allocating new item list\x00" as *const u8
                                    as *const std::os::raw::c_char, 0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
        (*list).sizeItems = 20 as std::os::raw::c_int
    } else if (*list).sizeItems <= (*list).nbItems {
        (*list).sizeItems *= 2 as std::os::raw::c_int;
        (*list).items =
            xmlRealloc.expect("non-null function pointer")((*list).items as
                                                               *mut std::os::raw::c_void,
                                                           ((*list).sizeItems
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut *mut std::os::raw::c_void;
        if (*list).items.is_null() {
            xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                                b"growing item list\x00" as *const u8 as
                                    *const std::os::raw::c_char, 0 as xmlNodePtr);
            (*list).sizeItems = 0 as std::os::raw::c_int;
            return -(1 as std::os::raw::c_int)
        }
    }
    /*
    * Just append if the index is greater/equal than the item count.
    */
    if idx >= (*list).nbItems {
        let fresh4 = (*list).nbItems;
        (*list).nbItems = (*list).nbItems + 1;
        let ref mut fresh5 = *(*list).items.offset(fresh4 as isize);
        *fresh5 = item
    } else {
        let mut i: std::os::raw::c_int = 0;
        i = (*list).nbItems;
        while i > idx {
            let ref mut fresh6 = *(*list).items.offset(i as isize);
            *fresh6 = *(*list).items.offset((i - 1 as std::os::raw::c_int) as isize);
            i -= 1
        }
        let ref mut fresh7 = *(*list).items.offset(idx as isize);
        *fresh7 = item;
        (*list).nbItems += 1
    }
    return 0 as std::os::raw::c_int;
}
/* enable if ever needed */
unsafe extern "C" fn xmlSchemaItemListRemove(mut list: xmlSchemaItemListPtr,
                                             mut idx: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut i: std::os::raw::c_int = 0;
    if (*list).items.is_null() || idx >= (*list).nbItems {
        xmlSchemaPSimpleErr(b"Internal error: xmlSchemaItemListRemove, index error.\n\x00"
                                as *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    if (*list).nbItems == 1 as std::os::raw::c_int {
        /* TODO: Really free the list? */
        xmlFree.expect("non-null function pointer")((*list).items as
                                                        *mut std::os::raw::c_void);
        (*list).items = 0 as *mut *mut std::os::raw::c_void;
        (*list).nbItems = 0 as std::os::raw::c_int;
        (*list).sizeItems = 0 as std::os::raw::c_int
    } else if (*list).nbItems - 1 as std::os::raw::c_int == idx {
        (*list).nbItems -= 1
    } else {
        i = idx;
        while i < (*list).nbItems - 1 as std::os::raw::c_int {
            let ref mut fresh8 = *(*list).items.offset(i as isize);
            *fresh8 = *(*list).items.offset((i + 1 as std::os::raw::c_int) as isize);
            i += 1
        }
        (*list).nbItems -= 1
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaItemListFree:
 * @annot:  a schema type structure
 *
 * Deallocate a annotation structure
 */
unsafe extern "C" fn xmlSchemaItemListFree(mut list: xmlSchemaItemListPtr) {
    if list.is_null() { return }
    if !(*list).items.is_null() {
        xmlFree.expect("non-null function pointer")((*list).items as
                                                        *mut std::os::raw::c_void);
    }
    xmlFree.expect("non-null function pointer")(list as *mut std::os::raw::c_void);
}
unsafe extern "C" fn xmlSchemaBucketFree(mut bucket: xmlSchemaBucketPtr) {
    if bucket.is_null() { return }
    if !(*bucket).globals.is_null() {
        xmlSchemaComponentListFree((*bucket).globals);
        xmlSchemaItemListFree((*bucket).globals);
    }
    if !(*bucket).locals.is_null() {
        xmlSchemaComponentListFree((*bucket).locals);
        xmlSchemaItemListFree((*bucket).locals);
    }
    if !(*bucket).relations.is_null() {
        let mut prev: xmlSchemaSchemaRelationPtr =
            0 as *mut xmlSchemaSchemaRelation;
        let mut cur: xmlSchemaSchemaRelationPtr = (*bucket).relations;
        loop  {
            prev = cur;
            cur = (*cur).next;
            xmlFree.expect("non-null function pointer")(prev as
                                                            *mut std::os::raw::c_void);
            if cur.is_null() { break ; }
        }
    }
    if (*bucket).preserveDoc == 0 && !(*bucket).doc.is_null() {
        xmlFreeDoc((*bucket).doc);
    }
    if (*bucket).type_0 == 1 as std::os::raw::c_int {
        if !(*(bucket as xmlSchemaImportPtr)).schema.is_null() {
            xmlSchemaFree((*(bucket as xmlSchemaImportPtr)).schema);
        }
    }
    xmlFree.expect("non-null function pointer")(bucket as *mut std::os::raw::c_void);
}
unsafe extern "C" fn xmlSchemaBucketFreeEntry(mut bucket: *mut std::os::raw::c_void,
                                              mut name: *const xmlChar) {
    xmlSchemaBucketFree(bucket as xmlSchemaBucketPtr);
}
unsafe extern "C" fn xmlSchemaBucketCreate(mut pctxt: xmlSchemaParserCtxtPtr,
                                           mut type_0: std::os::raw::c_int,
                                           mut targetNamespace:
                                               *const xmlChar)
 -> xmlSchemaBucketPtr {
    let mut ret: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut size: std::os::raw::c_int = 0;
    let mut mainSchema: xmlSchemaPtr = 0 as *mut xmlSchema;
    if (*(*pctxt).constructor).mainSchema.is_null() {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaBucketCreate\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"no main schema on constructor\x00" as *const u8
                                 as *const std::os::raw::c_char);
        return 0 as xmlSchemaBucketPtr
    }
    mainSchema = (*(*pctxt).constructor).mainSchema;
    /* Create the schema bucket. */
    if type_0 == 2 as std::os::raw::c_int || type_0 == 3 as std::os::raw::c_int {
        size =
            ::std::mem::size_of::<xmlSchemaInclude>() as std::os::raw::c_ulong as
                std::os::raw::c_int
    } else {
        size =
            ::std::mem::size_of::<xmlSchemaImport>() as std::os::raw::c_ulong as
                std::os::raw::c_int
    }
    ret =
        xmlMalloc.expect("non-null function pointer")(size as size_t) as
            xmlSchemaBucketPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                            b"allocating schema bucket\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaBucketPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int, size as std::os::raw::c_ulong);
    (*ret).targetNamespace = targetNamespace;
    (*ret).type_0 = type_0;
    (*ret).globals = xmlSchemaItemListCreate();
    if (*ret).globals.is_null() {
        xmlFree.expect("non-null function pointer")(ret as *mut std::os::raw::c_void);
        return 0 as xmlSchemaBucketPtr
    }
    (*ret).locals = xmlSchemaItemListCreate();
    if (*ret).locals.is_null() {
        xmlFree.expect("non-null function pointer")(ret as *mut std::os::raw::c_void);
        return 0 as xmlSchemaBucketPtr
    }
    /*
    * The following will assure that only the first bucket is marked as
    * XML_SCHEMA_SCHEMA_MAIN and it points to the *main* schema.
    * For each following import buckets an xmlSchema will be created.
    * An xmlSchema will be created for every distinct targetNamespace.
    * We assign the targetNamespace to the schemata here.
    */
    if !(!(*(*pctxt).constructor).buckets.is_null() &&
             (*(*(*pctxt).constructor).buckets).nbItems > 0 as std::os::raw::c_int) {
        if type_0 == 2 as std::os::raw::c_int || type_0 == 3 as std::os::raw::c_int {
            xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaBucketCreate\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 b"first bucket but it\'s an include or redefine\x00"
                                     as *const u8 as *const std::os::raw::c_char);
            xmlSchemaBucketFree(ret);
            return 0 as xmlSchemaBucketPtr
        }
        /* Force the type to be XML_SCHEMA_SCHEMA_MAIN. */
        (*ret).type_0 = 0 as std::os::raw::c_int;
        /* Point to the *main* schema. */
        (*(*pctxt).constructor).mainBucket = ret;
        let ref mut fresh9 = (*(ret as xmlSchemaImportPtr)).schema;
        *fresh9 = mainSchema;
        /*
	* Ensure that the main schema gets a targetNamespace.
	*/
        (*mainSchema).targetNamespace = targetNamespace
    } else if type_0 == 0 as std::os::raw::c_int {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaBucketCreate\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"main bucket but it\'s not the first one\x00" as
                                 *const u8 as *const std::os::raw::c_char);
        xmlSchemaBucketFree(ret);
        return 0 as xmlSchemaBucketPtr
    } else {
        if type_0 == 1 as std::os::raw::c_int {
            /*
	    * Create a schema for imports and assign the
	    * targetNamespace.
	    */
            let ref mut fresh10 = (*(ret as xmlSchemaImportPtr)).schema;
            *fresh10 = xmlSchemaNewSchema(pctxt);
            if (*(ret as xmlSchemaImportPtr)).schema.is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr
            }
            let ref mut fresh11 =
                (*(*(ret as xmlSchemaImportPtr)).schema).targetNamespace;
            *fresh11 = targetNamespace
        }
    }
    if type_0 == 0 as std::os::raw::c_int || type_0 == 1 as std::os::raw::c_int {
        let mut res: std::os::raw::c_int = 0;
        /*
	* Imports go into the "schemasImports" slot of the main *schema*.
	* Note that we create an import entry for the main schema as well; i.e.,
	* even if there's only one schema, we'll get an import.
	*/
        if (*mainSchema).schemasImports.is_null() {
            (*mainSchema).schemasImports =
                xmlHashCreateDict(5 as std::os::raw::c_int,
                                  (*(*pctxt).constructor).dict);
            if (*mainSchema).schemasImports.is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr
            }
        }
        if targetNamespace.is_null() {
            res =
                xmlHashAddEntry((*mainSchema).schemasImports,
                                b"##\x00" as *const u8 as *const std::os::raw::c_char
                                    as *const xmlChar,
                                ret as *mut std::os::raw::c_void)
        } else {
            res =
                xmlHashAddEntry((*mainSchema).schemasImports, targetNamespace,
                                ret as *mut std::os::raw::c_void)
        }
        if res != 0 as std::os::raw::c_int {
            xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaBucketCreate\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 b"failed to add the schema bucket to the hash\x00"
                                     as *const u8 as *const std::os::raw::c_char);
            xmlSchemaBucketFree(ret);
            return 0 as xmlSchemaBucketPtr
        }
    } else {
        /* Set the @ownerImport of an include bucket. */
        if (*(*(*pctxt).constructor).bucket).type_0 == 0 as std::os::raw::c_int ||
               (*(*(*pctxt).constructor).bucket).type_0 == 1 as std::os::raw::c_int {
            let ref mut fresh12 = (*(ret as xmlSchemaIncludePtr)).ownerImport;
            *fresh12 = (*(*pctxt).constructor).bucket as xmlSchemaImportPtr
        } else {
            let ref mut fresh13 = (*(ret as xmlSchemaIncludePtr)).ownerImport;
            *fresh13 =
                (*((*(*pctxt).constructor).bucket as
                       xmlSchemaIncludePtr)).ownerImport
        }
        /* Includes got into the "includes" slot of the *main* schema. */
        if (*mainSchema).includes.is_null() {
            (*mainSchema).includes =
                xmlSchemaItemListCreate() as *mut std::os::raw::c_void;
            if (*mainSchema).includes.is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr
            }
        }
        xmlSchemaItemListAdd((*mainSchema).includes as xmlSchemaItemListPtr,
                             ret as *mut std::os::raw::c_void);
    }
    /*
    * Add to list of all buckets; this is used for lookup
    * during schema construction time only.
    */
    if xmlSchemaItemListAdd((*(*pctxt).constructor).buckets,
                            ret as *mut std::os::raw::c_void) == -(1 as std::os::raw::c_int) {
        return 0 as xmlSchemaBucketPtr
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaAddItemSize(mut list: *mut xmlSchemaItemListPtr,
                                          mut initialSize: std::os::raw::c_int,
                                          mut item: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    if (*list).is_null() {
        *list = xmlSchemaItemListCreate();
        if (*list).is_null() { return -(1 as std::os::raw::c_int) }
    }
    xmlSchemaItemListAddSize(*list, initialSize, item);
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaFreeAnnot:
 * @annot:  a schema type structure
 *
 * Deallocate a annotation structure
 */
unsafe extern "C" fn xmlSchemaFreeAnnot(mut annot: xmlSchemaAnnotPtr) {
    if annot.is_null() { return }
    if (*annot).next.is_null() {
        xmlFree.expect("non-null function pointer")(annot as
                                                        *mut std::os::raw::c_void);
    } else {
        let mut prev: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
        loop  {
            prev = annot;
            annot = (*annot).next;
            xmlFree.expect("non-null function pointer")(prev as
                                                            *mut std::os::raw::c_void);
            if annot.is_null() { break ; }
        }
    };
}
/* *
 * xmlSchemaFreeNotation:
 * @schema:  a schema notation structure
 *
 * Deallocate a Schema Notation structure.
 */
unsafe extern "C" fn xmlSchemaFreeNotation(mut nota: xmlSchemaNotationPtr) {
    if nota.is_null() { return }
    xmlFree.expect("non-null function pointer")(nota as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeAttribute:
 * @attr:  an attribute declaration
 *
 * Deallocates an attribute declaration structure.
 */
unsafe extern "C" fn xmlSchemaFreeAttribute(mut attr: xmlSchemaAttributePtr) {
    if attr.is_null() { return }
    if !(*attr).annot.is_null() { xmlSchemaFreeAnnot((*attr).annot); }
    if !(*attr).defVal.is_null() { xmlSchemaFreeValue((*attr).defVal); }
    xmlFree.expect("non-null function pointer")(attr as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeAttributeUse:
 * @use:  an attribute use
 *
 * Deallocates an attribute use structure.
 */
unsafe extern "C" fn xmlSchemaFreeAttributeUse(mut use_0:
                                                   xmlSchemaAttributeUsePtr) {
    if use_0.is_null() { return }
    if !(*use_0).annot.is_null() { xmlSchemaFreeAnnot((*use_0).annot); }
    if !(*use_0).defVal.is_null() { xmlSchemaFreeValue((*use_0).defVal); }
    xmlFree.expect("non-null function pointer")(use_0 as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeAttributeUseProhib:
 * @prohib:  an attribute use prohibition
 *
 * Deallocates an attribute use structure.
 */
unsafe extern "C" fn xmlSchemaFreeAttributeUseProhib(mut prohib:
                                                         xmlSchemaAttributeUseProhibPtr) {
    if prohib.is_null() { return }
    xmlFree.expect("non-null function pointer")(prohib as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeWildcardNsSet:
 * set:  a schema wildcard namespace
 *
 * Deallocates a list of wildcard constraint structures.
 */
unsafe extern "C" fn xmlSchemaFreeWildcardNsSet(mut set:
                                                    xmlSchemaWildcardNsPtr) {
    let mut next: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    while !set.is_null() {
        next = (*set).next;
        xmlFree.expect("non-null function pointer")(set as *mut std::os::raw::c_void);
        set = next
    };
}
/* *
 * xmlSchemaFreeWildcard:
 * @wildcard:  a wildcard structure
 *
 * Deallocates a wildcard structure.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeWildcard(mut wildcard:
                                                   xmlSchemaWildcardPtr) {
    if wildcard.is_null() { return }
    if !(*wildcard).annot.is_null() { xmlSchemaFreeAnnot((*wildcard).annot); }
    if !(*wildcard).nsSet.is_null() {
        xmlSchemaFreeWildcardNsSet((*wildcard).nsSet);
    }
    if !(*wildcard).negNsSet.is_null() {
        xmlFree.expect("non-null function pointer")((*wildcard).negNsSet as
                                                        *mut std::os::raw::c_void);
    }
    xmlFree.expect("non-null function pointer")(wildcard as
                                                    *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeAttributeGroup:
 * @schema:  a schema attribute group structure
 *
 * Deallocate a Schema Attribute Group structure.
 */
unsafe extern "C" fn xmlSchemaFreeAttributeGroup(mut attrGr:
                                                     xmlSchemaAttributeGroupPtr) {
    if attrGr.is_null() { return }
    if !(*attrGr).annot.is_null() { xmlSchemaFreeAnnot((*attrGr).annot); }
    if !(*attrGr).attrUses.is_null() {
        xmlSchemaItemListFree((*attrGr).attrUses as xmlSchemaItemListPtr);
    }
    xmlFree.expect("non-null function pointer")(attrGr as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeQNameRef:
 * @item: a QName reference structure
 *
 * Deallocatea a QName reference structure.
 */
unsafe extern "C" fn xmlSchemaFreeQNameRef(mut item: xmlSchemaQNameRefPtr) {
    xmlFree.expect("non-null function pointer")(item as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeTypeLinkList:
 * @alink: a type link
 *
 * Deallocate a list of types.
 */
unsafe extern "C" fn xmlSchemaFreeTypeLinkList(mut link:
                                                   xmlSchemaTypeLinkPtr) {
    let mut next: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    while !link.is_null() {
        next = (*link).next;
        xmlFree.expect("non-null function pointer")(link as
                                                        *mut std::os::raw::c_void);
        link = next
    };
}
unsafe extern "C" fn xmlSchemaFreeIDCStateObjList(mut sto:
                                                      xmlSchemaIDCStateObjPtr) {
    let mut next: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    while !sto.is_null() {
        next = (*sto).next;
        if !(*sto).history.is_null() {
            xmlFree.expect("non-null function pointer")((*sto).history as
                                                            *mut std::os::raw::c_void);
        }
        if !(*sto).xpathCtxt.is_null() {
            xmlFreeStreamCtxt((*sto).xpathCtxt as xmlStreamCtxtPtr);
        }
        xmlFree.expect("non-null function pointer")(sto as *mut std::os::raw::c_void);
        sto = next
    };
}
/* *
 * xmlSchemaFreeIDC:
 * @idc: a identity-constraint definition
 *
 * Deallocates an identity-constraint definition.
 */
unsafe extern "C" fn xmlSchemaFreeIDC(mut idcDef: xmlSchemaIDCPtr) {
    let mut cur: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
    let mut prev: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
    if idcDef.is_null() { return }
    if !(*idcDef).annot.is_null() { xmlSchemaFreeAnnot((*idcDef).annot); }
    /* Selector */
    if !(*idcDef).selector.is_null() {
        if !(*(*idcDef).selector).xpathComp.is_null() {
            xmlFreePattern((*(*idcDef).selector).xpathComp as xmlPatternPtr);
        }
        xmlFree.expect("non-null function pointer")((*idcDef).selector as
                                                        *mut std::os::raw::c_void);
    }
    /* Fields */
    if !(*idcDef).fields.is_null() {
        cur = (*idcDef).fields;
        loop  {
            prev = cur;
            cur = (*cur).next;
            if !(*prev).xpathComp.is_null() {
                xmlFreePattern((*prev).xpathComp as xmlPatternPtr);
            }
            xmlFree.expect("non-null function pointer")(prev as
                                                            *mut std::os::raw::c_void);
            if cur.is_null() { break ; }
        }
    }
    xmlFree.expect("non-null function pointer")(idcDef as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeElement:
 * @schema:  a schema element structure
 *
 * Deallocate a Schema Element structure.
 */
unsafe extern "C" fn xmlSchemaFreeElement(mut elem: xmlSchemaElementPtr) {
    if elem.is_null() { return }
    if !(*elem).annot.is_null() { xmlSchemaFreeAnnot((*elem).annot); }
    if !(*elem).contModel.is_null() { xmlRegFreeRegexp((*elem).contModel); }
    if !(*elem).defVal.is_null() { xmlSchemaFreeValue((*elem).defVal); }
    xmlFree.expect("non-null function pointer")(elem as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeFacet:
 * @facet:  a schema facet structure
 *
 * Deallocate a Schema Facet structure.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeFacet(mut facet: xmlSchemaFacetPtr) {
    if facet.is_null() { return }
    if !(*facet).val.is_null() { xmlSchemaFreeValue((*facet).val); }
    if !(*facet).regexp.is_null() { xmlRegFreeRegexp((*facet).regexp); }
    if !(*facet).annot.is_null() { xmlSchemaFreeAnnot((*facet).annot); }
    xmlFree.expect("non-null function pointer")(facet as *mut std::os::raw::c_void);
}
/* Obsolete */
/* *
 * xmlSchemaFreeType:
 * @type:  a schema type structure
 *
 * Deallocate a Schema Type structure.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeType(mut type_0: xmlSchemaTypePtr) {
    if type_0.is_null() { return }
    if !(*type_0).annot.is_null() { xmlSchemaFreeAnnot((*type_0).annot); }
    if !(*type_0).facets.is_null() {
        let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        let mut next: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        facet = (*type_0).facets;
        while !facet.is_null() {
            next = (*facet).next;
            xmlSchemaFreeFacet(facet);
            facet = next
        }
    }
    if !(*type_0).attrUses.is_null() {
        xmlSchemaItemListFree((*type_0).attrUses as xmlSchemaItemListPtr);
    }
    if !(*type_0).memberTypes.is_null() {
        xmlSchemaFreeTypeLinkList((*type_0).memberTypes);
    }
    if !(*type_0).facetSet.is_null() {
        let mut next_0: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
        let mut link: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
        link = (*type_0).facetSet;
        loop  {
            next_0 = (*link).next;
            xmlFree.expect("non-null function pointer")(link as
                                                            *mut std::os::raw::c_void);
            link = next_0;
            if link.is_null() { break ; }
        }
    }
    if !(*type_0).contModel.is_null() {
        xmlRegFreeRegexp((*type_0).contModel);
    }
    xmlFree.expect("non-null function pointer")(type_0 as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeModelGroupDef:
 * @item:  a schema model group definition
 *
 * Deallocates a schema model group definition.
 */
unsafe extern "C" fn xmlSchemaFreeModelGroupDef(mut item:
                                                    xmlSchemaModelGroupDefPtr) {
    if !(*item).annot.is_null() { xmlSchemaFreeAnnot((*item).annot); }
    xmlFree.expect("non-null function pointer")(item as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaFreeModelGroup:
 * @item:  a schema model group
 *
 * Deallocates a schema model group structure.
 */
unsafe extern "C" fn xmlSchemaFreeModelGroup(mut item:
                                                 xmlSchemaModelGroupPtr) {
    if !(*item).annot.is_null() { xmlSchemaFreeAnnot((*item).annot); }
    xmlFree.expect("non-null function pointer")(item as *mut std::os::raw::c_void);
}
unsafe extern "C" fn xmlSchemaComponentListFree(mut list:
                                                    xmlSchemaItemListPtr) {
    if list.is_null() || (*list).nbItems == 0 as std::os::raw::c_int { return }
    let mut item: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut items: *mut xmlSchemaTreeItemPtr =
        (*list).items as *mut xmlSchemaTreeItemPtr;
    let mut i: std::os::raw::c_int = 0;
    i = 0 as std::os::raw::c_int;
    while i < (*list).nbItems {
        item = *items.offset(i as isize);
        if !item.is_null() {
            match (*item).type_0 as std::os::raw::c_uint {
                4 | 5 => { xmlSchemaFreeType(item as xmlSchemaTypePtr); }
                15 => {
                    xmlSchemaFreeAttribute(item as xmlSchemaAttributePtr);
                }
                26 => {
                    xmlSchemaFreeAttributeUse(item as
                                                  xmlSchemaAttributeUsePtr);
                }
                2001 => {
                    xmlSchemaFreeAttributeUseProhib(item as
                                                        xmlSchemaAttributeUseProhibPtr);
                }
                14 => { xmlSchemaFreeElement(item as xmlSchemaElementPtr); }
                25 => {
                    if !(*item).annot.is_null() {
                        xmlSchemaFreeAnnot((*item).annot);
                    }
                    xmlFree.expect("non-null function pointer")(item as
                                                                    *mut std::os::raw::c_void);
                }
                6 | 7 | 8 => {
                    xmlSchemaFreeModelGroup(item as xmlSchemaModelGroupPtr);
                }
                16 => {
                    xmlSchemaFreeAttributeGroup(item as
                                                    xmlSchemaAttributeGroupPtr);
                }
                17 => {
                    xmlSchemaFreeModelGroupDef(item as
                                                   xmlSchemaModelGroupDefPtr);
                }
                2 | 21 => {
                    xmlSchemaFreeWildcard(item as xmlSchemaWildcardPtr);
                }
                23 | 22 | 24 => { xmlSchemaFreeIDC(item as xmlSchemaIDCPtr); }
                18 => { xmlSchemaFreeNotation(item as xmlSchemaNotationPtr); }
                2000 => {
                    xmlSchemaFreeQNameRef(item as xmlSchemaQNameRefPtr);
                }
                _ => {
                    /* TODO: This should never be hit. */
                    xmlSchemaPSimpleInternalErr(0 as xmlNodePtr,
                                                b"Internal error: xmlSchemaComponentListFree, unexpected component type \'%s\'\n\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char,
                                                xmlSchemaGetComponentTypeStr(item
                                                                                 as
                                                                                 xmlSchemaBasicItemPtr));
                }
            }
        }
        i += 1
    }
    (*list).nbItems = 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaFree:
 * @schema:  a schema structure
 *
 * Deallocate a Schema structure.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFree(mut schema: xmlSchemaPtr) {
    if schema.is_null() { return }
    /* @volatiles is not used anymore :-/ */
    if !(*schema).volatiles.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Unimplemented block at %s:%d\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   b"xmlschemas.c\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   4147 as
                                                                       std::os::raw::c_int);
    }
    /*
    * Note that those slots are not responsible for freeing
    * schema components anymore; this will now be done by
    * the schema buckets.
    */
    if !(*schema).notaDecl.is_null() {
        xmlHashFree((*schema).notaDecl, None);
    }
    if !(*schema).attrDecl.is_null() {
        xmlHashFree((*schema).attrDecl, None);
    }
    if !(*schema).attrgrpDecl.is_null() {
        xmlHashFree((*schema).attrgrpDecl, None);
    }
    if !(*schema).elemDecl.is_null() {
        xmlHashFree((*schema).elemDecl, None);
    }
    if !(*schema).typeDecl.is_null() {
        xmlHashFree((*schema).typeDecl, None);
    }
    if !(*schema).groupDecl.is_null() {
        xmlHashFree((*schema).groupDecl, None);
    }
    if !(*schema).idcDef.is_null() { xmlHashFree((*schema).idcDef, None); }
    if !(*schema).schemasImports.is_null() {
        xmlHashFree((*schema).schemasImports,
                    Some(xmlSchemaBucketFreeEntry as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *const xmlChar) -> ()));
    }
    if !(*schema).includes.is_null() {
        let mut list: xmlSchemaItemListPtr =
            (*schema).includes as xmlSchemaItemListPtr;
        let mut i: std::os::raw::c_int = 0;
        i = 0 as std::os::raw::c_int;
        while i < (*list).nbItems {
            xmlSchemaBucketFree(*(*list).items.offset(i as isize) as
                                    xmlSchemaBucketPtr);
            i += 1
        }
        xmlSchemaItemListFree(list);
    }
    if !(*schema).annot.is_null() { xmlSchemaFreeAnnot((*schema).annot); }
    /* Never free the doc here, since this will be done by the buckets. */
    xmlDictFree((*schema).dict);
    xmlFree.expect("non-null function pointer")(schema as *mut std::os::raw::c_void);
}
/* forward */
/* *
 * xmlSchemaElementDump:
 * @elem:  an element
 * @output:  the file output
 *
 * Dump the element
 */
unsafe extern "C" fn xmlSchemaElementDump(mut payload: *mut std::os::raw::c_void,
                                          mut data: *mut std::os::raw::c_void,
                                          mut name: *const xmlChar,
                                          mut namespace: *const xmlChar,
                                          mut context: *const xmlChar) {
    let mut elem: xmlSchemaElementPtr = payload as xmlSchemaElementPtr;
    let mut output: *mut FILE = data as *mut FILE;
    if elem.is_null() { return }
    fprintf(output, b"Element\x00" as *const u8 as *const std::os::raw::c_char);
    if (*elem).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
        fprintf(output, b" (global)\x00" as *const u8 as *const std::os::raw::c_char);
    }
    fprintf(output, b": \'%s\' \x00" as *const u8 as *const std::os::raw::c_char,
            (*elem).name);
    if !namespace.is_null() {
        fprintf(output, b"ns \'%s\'\x00" as *const u8 as *const std::os::raw::c_char,
                namespace);
    }
    fprintf(output, b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    /*
    * Misc other properties.
    */
    if (*elem).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 ||
           (*elem).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int != 0 ||
           (*elem).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0 ||
           (*elem).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
        fprintf(output, b"  props: \x00" as *const u8 as *const std::os::raw::c_char);
        if (*elem).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0 {
            fprintf(output,
                    b"[fixed] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        if (*elem).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
            fprintf(output,
                    b"[default] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        if (*elem).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int != 0 {
            fprintf(output,
                    b"[abstract] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        if (*elem).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 {
            fprintf(output,
                    b"[nillable] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        fprintf(output, b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    /*
    * Default/fixed value.
    */
    if !(*elem).value.is_null() {
        fprintf(output,
                b"  value: \'%s\'\n\x00" as *const u8 as *const std::os::raw::c_char,
                (*elem).value);
    }
    /*
    * Type.
    */
    if !(*elem).namedType.is_null() {
        fprintf(output,
                b"  type: \'%s\' \x00" as *const u8 as *const std::os::raw::c_char,
                (*elem).namedType);
        if !(*elem).namedTypeNs.is_null() {
            fprintf(output,
                    b"ns \'%s\'\n\x00" as *const u8 as *const std::os::raw::c_char,
                    (*elem).namedTypeNs);
        } else {
            fprintf(output, b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
    } else if !(*elem).subtypes.is_null() {
        /*
	* Dump local types.
	*/
        xmlSchemaTypeDump((*elem).subtypes, output);
    }
    /*
    * Substitution group.
    */
    if !(*elem).substGroup.is_null() {
        fprintf(output,
                b"  substitutionGroup: \'%s\' \x00" as *const u8 as
                    *const std::os::raw::c_char, (*elem).substGroup);
        if !(*elem).substGroupNs.is_null() {
            fprintf(output,
                    b"ns \'%s\'\n\x00" as *const u8 as *const std::os::raw::c_char,
                    (*elem).substGroupNs);
        } else {
            fprintf(output, b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
    };
}
/* *
 * xmlSchemaAnnotDump:
 * @output:  the file output
 * @annot:  a annotation
 *
 * Dump the annotation
 */
unsafe extern "C" fn xmlSchemaAnnotDump(mut output: *mut FILE,
                                        mut annot: xmlSchemaAnnotPtr) {
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if annot.is_null() { return }
    content = xmlNodeGetContent((*annot).content as *const xmlNode);
    if !content.is_null() {
        fprintf(output,
                b"  Annot: %s\n\x00" as *const u8 as *const std::os::raw::c_char,
                content);
        xmlFree.expect("non-null function pointer")(content as
                                                        *mut std::os::raw::c_void);
    } else {
        fprintf(output,
                b"  Annot: empty\n\x00" as *const u8 as *const std::os::raw::c_char);
    };
}
/* *
 * xmlSchemaContentModelDump:
 * @particle: the schema particle
 * @output: the file output
 * @depth: the depth used for intentation
 *
 * Dump a SchemaType structure
 */
unsafe extern "C" fn xmlSchemaContentModelDump(mut particle:
                                                   xmlSchemaParticlePtr,
                                               mut output: *mut FILE,
                                               mut depth: std::os::raw::c_int) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut term: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut shift: [std::os::raw::c_char; 100] = [0; 100];
    let mut i: std::os::raw::c_int = 0;
    if particle.is_null() { return }
    i = 0 as std::os::raw::c_int;
    while i < depth && i < 25 as std::os::raw::c_int {
        shift[(2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int) as usize] =
            ' ' as i32 as std::os::raw::c_char;
        shift[(2 as std::os::raw::c_int * i) as usize] =
            shift[(2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int) as usize];
        i += 1
    }
    shift[(2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int) as usize] =
        0 as std::os::raw::c_int as std::os::raw::c_char;
    shift[(2 as std::os::raw::c_int * i) as usize] =
        shift[(2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int) as usize];
    fprintf(output, b"%s\x00" as *const u8 as *const std::os::raw::c_char,
            shift.as_mut_ptr());
    if (*particle).children.is_null() {
        fprintf(output,
                b"MISSING particle term\n\x00" as *const u8 as
                    *const std::os::raw::c_char);
        return
    }
    term = (*particle).children;
    if term.is_null() {
        fprintf(output, b"(NULL)\x00" as *const u8 as *const std::os::raw::c_char);
    } else {
        match (*term).type_0 as std::os::raw::c_uint {
            14 => {
                fprintf(output,
                        b"ELEM \'%s\'\x00" as *const u8 as
                            *const std::os::raw::c_char,
                        xmlSchemaFormatQName(&mut str,
                                             (*(term as
                                                    xmlSchemaElementPtr)).targetNamespace,
                                             (*(term as
                                                    xmlSchemaElementPtr)).name));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
            }
            6 => {
                fprintf(output,
                        b"SEQUENCE\x00" as *const u8 as *const std::os::raw::c_char);
            }
            7 => {
                fprintf(output,
                        b"CHOICE\x00" as *const u8 as *const std::os::raw::c_char);
            }
            8 => {
                fprintf(output,
                        b"ALL\x00" as *const u8 as *const std::os::raw::c_char);
            }
            2 => {
                fprintf(output,
                        b"ANY\x00" as *const u8 as *const std::os::raw::c_char);
            }
            _ => {
                fprintf(output,
                        b"UNKNOWN\n\x00" as *const u8 as *const std::os::raw::c_char);
                return
            }
        }
    }
    if (*particle).minOccurs != 1 as std::os::raw::c_int {
        fprintf(output, b" min: %d\x00" as *const u8 as *const std::os::raw::c_char,
                (*particle).minOccurs);
    }
    if (*particle).maxOccurs >= (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int {
        fprintf(output,
                b" max: unbounded\x00" as *const u8 as *const std::os::raw::c_char);
    } else if (*particle).maxOccurs != 1 as std::os::raw::c_int {
        fprintf(output, b" max: %d\x00" as *const u8 as *const std::os::raw::c_char,
                (*particle).maxOccurs);
    }
    fprintf(output, b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    if !term.is_null() &&
           ((*term).type_0 as std::os::raw::c_uint ==
                XML_SCHEMA_TYPE_SEQUENCE as std::os::raw::c_int as std::os::raw::c_uint ||
                (*term).type_0 as std::os::raw::c_uint ==
                    XML_SCHEMA_TYPE_CHOICE as std::os::raw::c_int as std::os::raw::c_uint ||
                (*term).type_0 as std::os::raw::c_uint ==
                    XML_SCHEMA_TYPE_ALL as std::os::raw::c_int as std::os::raw::c_uint) &&
           !(*term).children.is_null() {
        xmlSchemaContentModelDump((*term).children as xmlSchemaParticlePtr,
                                  output, depth + 1 as std::os::raw::c_int);
    }
    if !(*particle).next.is_null() {
        xmlSchemaContentModelDump((*particle).next as xmlSchemaParticlePtr,
                                  output, depth);
    };
}
/* *
 * xmlSchemaAttrUsesDump:
 * @uses:  attribute uses list
 * @output:  the file output
 *
 * Dumps a list of attribute use components.
 */
unsafe extern "C" fn xmlSchemaAttrUsesDump(mut uses: xmlSchemaItemListPtr,
                                           mut output: *mut FILE) {
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut prohib: xmlSchemaAttributeUseProhibPtr =
        0 as *mut xmlSchemaAttributeUseProhib;
    let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut tns: *const xmlChar = 0 as *const xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut i: std::os::raw::c_int = 0;
    if uses.is_null() || (*uses).nbItems == 0 as std::os::raw::c_int { return }
    fprintf(output,
            b"  attributes:\n\x00" as *const u8 as *const std::os::raw::c_char);
    i = 0 as std::os::raw::c_int;
    while i < (*uses).nbItems {
        use_0 = *(*uses).items.offset(i as isize) as xmlSchemaAttributeUsePtr;
        if (*use_0).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as std::os::raw::c_int as std::os::raw::c_uint
           {
            fprintf(output,
                    b"  [prohibition] \x00" as *const u8 as
                        *const std::os::raw::c_char);
            prohib = use_0 as xmlSchemaAttributeUseProhibPtr;
            name = (*prohib).name;
            tns = (*prohib).targetNamespace
        } else if (*use_0).type_0 as std::os::raw::c_uint ==
                      XML_SCHEMA_EXTRA_QNAMEREF as std::os::raw::c_int as std::os::raw::c_uint
         {
            fprintf(output,
                    b"  [reference] \x00" as *const u8 as
                        *const std::os::raw::c_char);
            ref_0 = use_0 as xmlSchemaQNameRefPtr;
            name = (*ref_0).name;
            tns = (*ref_0).targetNamespace
        } else {
            fprintf(output,
                    b"  [use] \x00" as *const u8 as *const std::os::raw::c_char);
            name = (*(*use_0).attrDecl).name;
            tns = (*(*use_0).attrDecl).targetNamespace
        }
        fprintf(output, b"\'%s\'\n\x00" as *const u8 as *const std::os::raw::c_char,
                xmlSchemaFormatQName(&mut str, tns, name) as
                    *const std::os::raw::c_char);
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as
                                                            *mut std::os::raw::c_void);
            str = 0 as *mut xmlChar
        }
        i += 1
    };
}
/* ***********************************************************************
 *									*
 *			Debug functions					*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaTypeDump:
 * @output:  the file output
 * @type:  a type structure
 *
 * Dump a SchemaType structure
 */
unsafe extern "C" fn xmlSchemaTypeDump(mut type_0: xmlSchemaTypePtr,
                                       mut output: *mut FILE) {
    if type_0.is_null() {
        fprintf(output,
                b"Type: NULL\n\x00" as *const u8 as *const std::os::raw::c_char);
        return
    }
    fprintf(output, b"Type: \x00" as *const u8 as *const std::os::raw::c_char);
    if !(*type_0).name.is_null() {
        fprintf(output, b"\'%s\' \x00" as *const u8 as *const std::os::raw::c_char,
                (*type_0).name);
    } else {
        fprintf(output,
                b"(no name) \x00" as *const u8 as *const std::os::raw::c_char);
    }
    if !(*type_0).targetNamespace.is_null() {
        fprintf(output, b"ns \'%s\' \x00" as *const u8 as *const std::os::raw::c_char,
                (*type_0).targetNamespace);
    }
    match (*type_0).type_0 as std::os::raw::c_uint {
        1 => {
            fprintf(output,
                    b"[basic] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        4 => {
            fprintf(output,
                    b"[simple] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        5 => {
            fprintf(output,
                    b"[complex] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        6 => {
            fprintf(output,
                    b"[sequence] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        7 => {
            fprintf(output,
                    b"[choice] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        8 => {
            fprintf(output,
                    b"[all] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        11 => {
            fprintf(output, b"[ur] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        12 => {
            fprintf(output,
                    b"[restriction] \x00" as *const u8 as
                        *const std::os::raw::c_char);
        }
        13 => {
            fprintf(output,
                    b"[extension] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        _ => {
            fprintf(output,
                    b"[unknown type %d] \x00" as *const u8 as
                        *const std::os::raw::c_char,
                    (*type_0).type_0 as std::os::raw::c_uint);
        }
    }
    fprintf(output, b"content: \x00" as *const u8 as *const std::os::raw::c_char);
    match (*type_0).contentType as std::os::raw::c_uint {
        0 => {
            fprintf(output,
                    b"[unknown] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        1 => {
            fprintf(output,
                    b"[empty] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        2 => {
            fprintf(output,
                    b"[element] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        3 => {
            fprintf(output,
                    b"[mixed] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        6 => {
            fprintf(output,
                    b"[basic] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        4 => {
            fprintf(output,
                    b"[simple] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        7 => {
            fprintf(output,
                    b"[any] \x00" as *const u8 as *const std::os::raw::c_char);
        }
        5 | _ => { }
    }
    fprintf(output, b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    if !(*type_0).base.is_null() {
        fprintf(output,
                b"  base type: \'%s\'\x00" as *const u8 as
                    *const std::os::raw::c_char, (*type_0).base);
        if !(*type_0).baseNs.is_null() {
            fprintf(output,
                    b" ns \'%s\'\n\x00" as *const u8 as *const std::os::raw::c_char,
                    (*type_0).baseNs);
        } else {
            fprintf(output, b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
    }
    if !(*type_0).attrUses.is_null() {
        xmlSchemaAttrUsesDump((*type_0).attrUses as xmlSchemaItemListPtr,
                              output);
    }
    if !(*type_0).annot.is_null() {
        xmlSchemaAnnotDump(output, (*type_0).annot);
    }
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint &&
           !(*type_0).subtypes.is_null() {
        xmlSchemaContentModelDump((*type_0).subtypes as xmlSchemaParticlePtr,
                                  output, 1 as std::os::raw::c_int);
    };
}
unsafe extern "C" fn xmlSchemaTypeDumpEntry(mut type_0: *mut std::os::raw::c_void,
                                            mut output: *mut std::os::raw::c_void,
                                            mut name: *const xmlChar) {
    xmlSchemaTypeDump(type_0 as xmlSchemaTypePtr, output as *mut FILE);
}
/* *
 * xmlSchemaDump:
 * @output:  the file output
 * @schema:  a schema structure
 *
 * Dump a Schema structure.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaDump(mut output: *mut FILE,
                                       mut schema: xmlSchemaPtr) {
    if output.is_null() { return }
    if schema.is_null() {
        fprintf(output,
                b"Schemas: NULL\n\x00" as *const u8 as *const std::os::raw::c_char);
        return
    }
    fprintf(output, b"Schemas: \x00" as *const u8 as *const std::os::raw::c_char);
    if !(*schema).name.is_null() {
        fprintf(output, b"%s, \x00" as *const u8 as *const std::os::raw::c_char,
                (*schema).name);
    } else {
        fprintf(output, b"no name, \x00" as *const u8 as *const std::os::raw::c_char);
    }
    if !(*schema).targetNamespace.is_null() {
        fprintf(output, b"%s\x00" as *const u8 as *const std::os::raw::c_char,
                (*schema).targetNamespace as *const std::os::raw::c_char);
    } else {
        fprintf(output,
                b"no target namespace\x00" as *const u8 as
                    *const std::os::raw::c_char);
    }
    fprintf(output, b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    if !(*schema).annot.is_null() {
        xmlSchemaAnnotDump(output, (*schema).annot);
    }
    xmlHashScan((*schema).typeDecl,
                Some(xmlSchemaTypeDumpEntry as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *mut std::os::raw::c_void,
                                              _: *const xmlChar) -> ()),
                output as *mut std::os::raw::c_void);
    xmlHashScanFull((*schema).elemDecl,
                    Some(xmlSchemaElementDump as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *mut std::os::raw::c_void,
                                                  _: *const xmlChar,
                                                  _: *const xmlChar,
                                                  _: *const xmlChar) -> ()),
                    output as *mut std::os::raw::c_void);
}
/* DEBUG_IDC */
/* LIBXML_OUTPUT_ENABLED */
/* ***********************************************************************
 *									*
 *			Utilities					*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaGetPropNode:
 * @node: the element node
 * @name: the name of the attribute
 *
 * Seeks an attribute with a name of @name in
 * no namespace.
 *
 * Returns the attribute or NULL if not present.
 */
unsafe extern "C" fn xmlSchemaGetPropNode(mut node: xmlNodePtr,
                                          mut name: *const std::os::raw::c_char)
 -> xmlAttrPtr {
    let mut prop: xmlAttrPtr = 0 as *mut xmlAttr;
    if node.is_null() || name.is_null() { return 0 as xmlAttrPtr }
    prop = (*node).properties;
    while !prop.is_null() {
        if (*prop).ns.is_null() &&
               xmlStrEqual((*prop).name, name as *mut xmlChar) != 0 {
            return prop
        }
        prop = (*prop).next
    }
    return 0 as xmlAttrPtr;
}
/* *
 * xmlSchemaGetPropNodeNs:
 * @node: the element node
 * @uri: the uri
 * @name: the name of the attribute
 *
 * Seeks an attribute with a local name of @name and
 * a namespace URI of @uri.
 *
 * Returns the attribute or NULL if not present.
 */
unsafe extern "C" fn xmlSchemaGetPropNodeNs(mut node: xmlNodePtr,
                                            mut uri: *const std::os::raw::c_char,
                                            mut name: *const std::os::raw::c_char)
 -> xmlAttrPtr {
    let mut prop: xmlAttrPtr = 0 as *mut xmlAttr;
    if node.is_null() || name.is_null() { return 0 as xmlAttrPtr }
    prop = (*node).properties;
    while !prop.is_null() {
        if !(*prop).ns.is_null() &&
               xmlStrEqual((*prop).name, name as *mut xmlChar) != 0 &&
               xmlStrEqual((*(*prop).ns).href, uri as *mut xmlChar) != 0 {
            return prop
        }
        prop = (*prop).next
    }
    return 0 as xmlAttrPtr;
}
unsafe extern "C" fn xmlSchemaGetNodeContent(mut ctxt: xmlSchemaParserCtxtPtr,
                                             mut node: xmlNodePtr)
 -> *const xmlChar {
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    val = xmlNodeGetContent(node as *const xmlNode);
    if val.is_null() {
        val =
            xmlStrdup(b"\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    ret = xmlDictLookup((*ctxt).dict, val, -(1 as std::os::raw::c_int));
    xmlFree.expect("non-null function pointer")(val as *mut std::os::raw::c_void);
    return ret;
}
unsafe extern "C" fn xmlSchemaGetNodeContentNoDict(mut node: xmlNodePtr)
 -> *const xmlChar {
    return xmlNodeGetContent(node as *const xmlNode) as *const xmlChar;
}
/* *
 * xmlSchemaGetProp:
 * @ctxt: the parser context
 * @node: the node
 * @name: the property name
 *
 * Read a attribute value and internalize the string
 *
 * Returns the string or NULL if not present.
 */
unsafe extern "C" fn xmlSchemaGetProp(mut ctxt: xmlSchemaParserCtxtPtr,
                                      mut node: xmlNodePtr,
                                      mut name: *const std::os::raw::c_char)
 -> *const xmlChar {
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    val = xmlGetNoNsProp(node as *const xmlNode, name as *mut xmlChar);
    if val.is_null() { return 0 as *const xmlChar }
    ret = xmlDictLookup((*ctxt).dict, val, -(1 as std::os::raw::c_int));
    xmlFree.expect("non-null function pointer")(val as *mut std::os::raw::c_void);
    return ret;
}
/* ***********************************************************************
 *									*
 *			Parsing functions				*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaGetElem:
 * @schema:  the schema context
 * @name:  the element name
 * @ns:  the element namespace
 *
 * Lookup a global element declaration in the schema.
 *
 * Returns the element declaration or NULL if not found.
 */
unsafe extern "C" fn xmlSchemaGetElem(mut schema: xmlSchemaPtr,
                                      mut name: *const xmlChar,
                                      mut nsName: *const xmlChar)
 -> xmlSchemaElementPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    if name.is_null() || schema.is_null() { return 0 as xmlSchemaElementPtr }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret =
                xmlHashLookup((*schema).elemDecl, name) as
                    xmlSchemaElementPtr;
            if !ret.is_null() {
                current_block = 6010215666508624724;
            } else { current_block = 6483416627284290920; }
        } else { current_block = 6483416627284290920; }
        match current_block {
            6010215666508624724 => { }
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as std::os::raw::c_int {
                    let mut import: xmlSchemaImportPtr =
                        0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import =
                            xmlHashLookup((*schema).schemasImports,
                                          b"##\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) as
                                xmlSchemaImportPtr
                    } else {
                        import =
                            xmlHashLookup((*schema).schemasImports, nsName) as
                                xmlSchemaImportPtr
                    }
                    if !import.is_null() {
                        ret =
                            xmlHashLookup((*(*import).schema).elemDecl, name)
                                as xmlSchemaElementPtr
                    }
                }
            }
        }
    }
    return ret;
}
/* *
 * xmlSchemaGetType:
 * @schema:  the main schema
 * @name:  the type's name
 * nsName:  the type's namespace
 *
 * Lookup a type in the schemas or the predefined types
 *
 * Returns the group definition or NULL if not found.
 */
unsafe extern "C" fn xmlSchemaGetType(mut schema: xmlSchemaPtr,
                                      mut name: *const xmlChar,
                                      mut nsName: *const xmlChar)
 -> xmlSchemaTypePtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    if name.is_null() { return 0 as xmlSchemaTypePtr }
    /* First try the built-in types. */
    if !nsName.is_null() && xmlStrEqual(nsName, xmlSchemaNs) != 0 {
        ret = xmlSchemaGetPredefinedType(name, nsName);
        if !ret.is_null() {
            current_block = 17801665505684756258;
        } else { current_block = 15427931788582360902; }
        /*
	* Note that we try the parsed schemas as well here
	* since one might have parsed the S4S, which contain more
	* than the built-in types.
	* TODO: Can we optimize this?
	*/
    } else { current_block = 15427931788582360902; }
    match current_block {
        15427931788582360902 => {
            if !schema.is_null() {
                if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
                    ret =
                        xmlHashLookup((*schema).typeDecl, name) as
                            xmlSchemaTypePtr;
                    if !ret.is_null() {
                        current_block = 17801665505684756258;
                    } else { current_block = 11812396948646013369; }
                } else { current_block = 11812396948646013369; }
                match current_block {
                    17801665505684756258 => { }
                    _ => {
                        if xmlHashSize((*schema).schemasImports) >
                               1 as std::os::raw::c_int {
                            let mut import: xmlSchemaImportPtr =
                                0 as *mut xmlSchemaImport;
                            if nsName.is_null() {
                                import =
                                    xmlHashLookup((*schema).schemasImports,
                                                  b"##\x00" as *const u8 as
                                                      *const std::os::raw::c_char as
                                                      *const xmlChar) as
                                        xmlSchemaImportPtr
                            } else {
                                import =
                                    xmlHashLookup((*schema).schemasImports,
                                                  nsName) as
                                        xmlSchemaImportPtr
                            }
                            if !import.is_null() {
                                ret =
                                    xmlHashLookup((*(*import).schema).typeDecl,
                                                  name) as xmlSchemaTypePtr
                            }
                        }
                    }
                }
            }
        }
        _ => { }
    }
    return ret;
}
/* *
 * xmlSchemaGetAttributeDecl:
 * @schema:  the context of the schema
 * @name:  the name of the attribute
 * @ns:  the target namespace of the attribute
 *
 * Lookup a an attribute in the schema or imported schemas
 *
 * Returns the attribute declaration or NULL if not found.
 */
unsafe extern "C" fn xmlSchemaGetAttributeDecl(mut schema: xmlSchemaPtr,
                                               mut name: *const xmlChar,
                                               mut nsName: *const xmlChar)
 -> xmlSchemaAttributePtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaAttributePtr = 0 as xmlSchemaAttributePtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributePtr
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret =
                xmlHashLookup((*schema).attrDecl, name) as
                    xmlSchemaAttributePtr;
            if !ret.is_null() {
                current_block = 11328988525375026301;
            } else { current_block = 6483416627284290920; }
        } else { current_block = 6483416627284290920; }
        match current_block {
            11328988525375026301 => { }
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as std::os::raw::c_int {
                    let mut import: xmlSchemaImportPtr =
                        0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import =
                            xmlHashLookup((*schema).schemasImports,
                                          b"##\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) as
                                xmlSchemaImportPtr
                    } else {
                        import =
                            xmlHashLookup((*schema).schemasImports, nsName) as
                                xmlSchemaImportPtr
                    }
                    if !import.is_null() {
                        ret =
                            xmlHashLookup((*(*import).schema).attrDecl, name)
                                as xmlSchemaAttributePtr
                    }
                }
            }
        }
    }
    return ret;
}
/* *
 * xmlSchemaGetAttributeGroup:
 * @schema:  the context of the schema
 * @name:  the name of the attribute group
 * @ns:  the target namespace of the attribute group
 *
 * Lookup a an attribute group in the schema or imported schemas
 *
 * Returns the attribute group definition or NULL if not found.
 */
unsafe extern "C" fn xmlSchemaGetAttributeGroup(mut schema: xmlSchemaPtr,
                                                mut name: *const xmlChar,
                                                mut nsName: *const xmlChar)
 -> xmlSchemaAttributeGroupPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaAttributeGroupPtr = 0 as xmlSchemaAttributeGroupPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret =
                xmlHashLookup((*schema).attrgrpDecl, name) as
                    xmlSchemaAttributeGroupPtr;
            if !ret.is_null() {
                current_block = 1418100976178683513;
            } else { current_block = 6483416627284290920; }
        } else { current_block = 6483416627284290920; }
        match current_block {
            1418100976178683513 => { }
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as std::os::raw::c_int {
                    let mut import: xmlSchemaImportPtr =
                        0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import =
                            xmlHashLookup((*schema).schemasImports,
                                          b"##\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) as
                                xmlSchemaImportPtr
                    } else {
                        import =
                            xmlHashLookup((*schema).schemasImports, nsName) as
                                xmlSchemaImportPtr
                    }
                    if !import.is_null() {
                        ret =
                            xmlHashLookup((*(*import).schema).attrgrpDecl,
                                          name) as xmlSchemaAttributeGroupPtr
                    }
                }
            }
        }
    }
    /* TODO:
    if ((ret != NULL) && (ret->redef != NULL)) {
	* Return the last redefinition. *
	ret = ret->redef;
    }
    */
    return ret;
}
/* *
 * xmlSchemaGetGroup:
 * @schema:  the context of the schema
 * @name:  the name of the group
 * @ns:  the target namespace of the group
 *
 * Lookup a group in the schema or imported schemas
 *
 * Returns the group definition or NULL if not found.
 */
unsafe extern "C" fn xmlSchemaGetGroup(mut schema: xmlSchemaPtr,
                                       mut name: *const xmlChar,
                                       mut nsName: *const xmlChar)
 -> xmlSchemaModelGroupDefPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaModelGroupDefPtr = 0 as xmlSchemaModelGroupDefPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret =
                xmlHashLookup((*schema).groupDecl, name) as
                    xmlSchemaModelGroupDefPtr;
            if !ret.is_null() {
                current_block = 15814109165786788792;
            } else { current_block = 6483416627284290920; }
        } else { current_block = 6483416627284290920; }
        match current_block {
            15814109165786788792 => { }
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as std::os::raw::c_int {
                    let mut import: xmlSchemaImportPtr =
                        0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import =
                            xmlHashLookup((*schema).schemasImports,
                                          b"##\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) as
                                xmlSchemaImportPtr
                    } else {
                        import =
                            xmlHashLookup((*schema).schemasImports, nsName) as
                                xmlSchemaImportPtr
                    }
                    if !import.is_null() {
                        ret =
                            xmlHashLookup((*(*import).schema).groupDecl, name)
                                as xmlSchemaModelGroupDefPtr
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetNotation(mut schema: xmlSchemaPtr,
                                          mut name: *const xmlChar,
                                          mut nsName: *const xmlChar)
 -> xmlSchemaNotationPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaNotationPtr = 0 as xmlSchemaNotationPtr;
    if name.is_null() || schema.is_null() { return 0 as xmlSchemaNotationPtr }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret =
                xmlHashLookup((*schema).notaDecl, name) as
                    xmlSchemaNotationPtr;
            if !ret.is_null() {
                current_block = 12461969981931391843;
            } else { current_block = 6483416627284290920; }
        } else { current_block = 6483416627284290920; }
        match current_block {
            12461969981931391843 => { }
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as std::os::raw::c_int {
                    let mut import: xmlSchemaImportPtr =
                        0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import =
                            xmlHashLookup((*schema).schemasImports,
                                          b"##\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) as
                                xmlSchemaImportPtr
                    } else {
                        import =
                            xmlHashLookup((*schema).schemasImports, nsName) as
                                xmlSchemaImportPtr
                    }
                    if !import.is_null() {
                        ret =
                            xmlHashLookup((*(*import).schema).notaDecl, name)
                                as xmlSchemaNotationPtr
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetIDC(mut schema: xmlSchemaPtr,
                                     mut name: *const xmlChar,
                                     mut nsName: *const xmlChar)
 -> xmlSchemaIDCPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
    if name.is_null() || schema.is_null() { return 0 as xmlSchemaIDCPtr }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).idcDef, name) as xmlSchemaIDCPtr;
            if !ret.is_null() {
                current_block = 7771945985954939940;
            } else { current_block = 6483416627284290920; }
        } else { current_block = 6483416627284290920; }
        match current_block {
            7771945985954939940 => { }
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as std::os::raw::c_int {
                    let mut import: xmlSchemaImportPtr =
                        0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import =
                            xmlHashLookup((*schema).schemasImports,
                                          b"##\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) as
                                xmlSchemaImportPtr
                    } else {
                        import =
                            xmlHashLookup((*schema).schemasImports, nsName) as
                                xmlSchemaImportPtr
                    }
                    if !import.is_null() {
                        ret =
                            xmlHashLookup((*(*import).schema).idcDef, name) as
                                xmlSchemaIDCPtr
                    }
                }
            }
        }
    }
    return ret;
}
/* *
 * xmlSchemaGetNamedComponent:
 * @schema:  the schema
 * @name:  the name of the group
 * @ns:  the target namespace of the group
 *
 * Lookup a group in the schema or imported schemas
 *
 * Returns the group definition or NULL if not found.
 */
unsafe extern "C" fn xmlSchemaGetNamedComponent(mut schema: xmlSchemaPtr,
                                                mut itemType:
                                                    xmlSchemaTypeType,
                                                mut name: *const xmlChar,
                                                mut targetNs: *const xmlChar)
 -> xmlSchemaBasicItemPtr {
    match itemType as std::os::raw::c_uint {
        17 => {
            return xmlSchemaGetGroup(schema, name, targetNs) as
                       xmlSchemaBasicItemPtr
        }
        14 => {
            return xmlSchemaGetElem(schema, name, targetNs) as
                       xmlSchemaBasicItemPtr
        }
        _ => {
            (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                       b"Unimplemented block at %s:%d\n\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const std::os::raw::c_char,
                                                                       b"xmlschemas.c\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const std::os::raw::c_char,
                                                                       5019 as
                                                                           std::os::raw::c_int);
            return 0 as xmlSchemaBasicItemPtr
        }
    };
}
/* *
 * xmlSchemaIsBlank:
 * @str:  a string
 * @len: the length of the string or -1
 *
 * Check if a string is ignorable
 *
 * Returns 1 if the string is NULL or made of blanks chars, 0 otherwise
 */
unsafe extern "C" fn xmlSchemaIsBlank(mut str: *mut xmlChar,
                                      mut len: std::os::raw::c_int) -> std::os::raw::c_int {
    if str.is_null() { return 1 as std::os::raw::c_int }
    if len < 0 as std::os::raw::c_int {
        while *str as std::os::raw::c_int != 0 as std::os::raw::c_int {
            if !(*str as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                     0x9 as std::os::raw::c_int <= *str as std::os::raw::c_int &&
                         *str as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                     *str as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
                return 0 as std::os::raw::c_int
            }
            str = str.offset(1)
        }
    } else {
        while *str as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                  len != 0 as std::os::raw::c_int {
            if !(*str as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                     0x9 as std::os::raw::c_int <= *str as std::os::raw::c_int &&
                         *str as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                     *str as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
                return 0 as std::os::raw::c_int
            }
            str = str.offset(1);
            len -= 1
        }
    }
    return 1 as std::os::raw::c_int;
}
/*
* xmlSchemaFindRedefCompInGraph:
* ATTENTION TODO: This uses pointer comp. for strings.
*/
unsafe extern "C" fn xmlSchemaFindRedefCompInGraph(mut bucket:
                                                       xmlSchemaBucketPtr,
                                                   mut type_0:
                                                       xmlSchemaTypeType,
                                                   mut name: *const xmlChar,
                                                   mut nsName: *const xmlChar)
 -> xmlSchemaBasicItemPtr {
    let mut ret: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut i: std::os::raw::c_int = 0;
    if bucket.is_null() || name.is_null() {
        return 0 as xmlSchemaBasicItemPtr
    }
    if !((*bucket).globals.is_null() ||
             (*(*bucket).globals).nbItems == 0 as std::os::raw::c_int) {
        /*
    * Search in global components.
    */
        i = 0 as std::os::raw::c_int;
        while i < (*(*bucket).globals).nbItems {
            ret =
                *(*(*bucket).globals).items.offset(i as isize) as
                    xmlSchemaBasicItemPtr;
            if (*ret).type_0 as std::os::raw::c_uint == type_0 as std::os::raw::c_uint {
                match type_0 as std::os::raw::c_uint {
                    5 | 4 => {
                        if (*(ret as xmlSchemaTypePtr)).name == name &&
                               (*(ret as xmlSchemaTypePtr)).targetNamespace ==
                                   nsName {
                            return ret
                        }
                    }
                    17 => {
                        if (*(ret as xmlSchemaModelGroupDefPtr)).name == name
                               &&
                               (*(ret as
                                      xmlSchemaModelGroupDefPtr)).targetNamespace
                                   == nsName {
                            return ret
                        }
                    }
                    16 => {
                        if (*(ret as xmlSchemaAttributeGroupPtr)).name == name
                               &&
                               (*(ret as
                                      xmlSchemaAttributeGroupPtr)).targetNamespace
                                   == nsName {
                            return ret
                        }
                    }
                    _ => {
                        /* Should not be hit. */
                        return 0 as xmlSchemaBasicItemPtr
                    }
                }
            }
            i += 1
        }
    }
    /*
    * Process imported/included schemas.
    */
    if !(*bucket).relations.is_null() {
        let mut rel: xmlSchemaSchemaRelationPtr = (*bucket).relations;
        /*
	* TODO: Marking the bucket will not avoid multiple searches
	* in the same schema, but avoids at least circularity.
	*/
        (*bucket).flags |= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int;
        loop  {
            if !(*rel).bucket.is_null() &&
                   (*(*rel).bucket).flags &
                       (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                ret =
                    xmlSchemaFindRedefCompInGraph((*rel).bucket, type_0, name,
                                                  nsName);
                if !ret.is_null() { return ret }
            }
            rel = (*rel).next;
            if rel.is_null() { break ; }
        }
        (*bucket).flags ^= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
    }
    return 0 as xmlSchemaBasicItemPtr;
}
/* *
 * xmlSchemaAddNotation:
 * @ctxt:  a schema parser context
 * @schema:  the schema being built
 * @name:  the item name
 *
 * Add an XML schema annotation declaration
 * *WARNING* this interface is highly subject to change
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddNotation(mut ctxt: xmlSchemaParserCtxtPtr,
                                          mut schema: xmlSchemaPtr,
                                          mut name: *const xmlChar,
                                          mut nsName: *const xmlChar,
                                          mut node: xmlNodePtr)
 -> xmlSchemaNotationPtr {
    let mut ret: xmlSchemaNotationPtr = 0 as xmlSchemaNotationPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaNotationPtr
    }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaNotation>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaNotationPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"add annotation\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaNotationPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaNotation>() as std::os::raw::c_ulong);
    (*ret).type_0 = XML_SCHEMA_TYPE_NOTATION;
    (*ret).name = name;
    (*ret).targetNamespace = nsName;
    /* TODO: do we need the node to be set?
    * ret->node = node;*/
    xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).globals,
                         5 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
/* *
 * xmlSchemaAddAttribute:
 * @ctxt:  a schema parser context
 * @schema:  the schema being built
 * @name:  the item name
 * @namespace:  the namespace
 *
 * Add an XML schema Attrribute declaration
 * *WARNING* this interface is highly subject to change
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddAttribute(mut ctxt: xmlSchemaParserCtxtPtr,
                                           mut schema: xmlSchemaPtr,
                                           mut name: *const xmlChar,
                                           mut nsName: *const xmlChar,
                                           mut node: xmlNodePtr,
                                           mut topLevel: std::os::raw::c_int)
 -> xmlSchemaAttributePtr {
    let mut ret: xmlSchemaAttributePtr = 0 as xmlSchemaAttributePtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributePtr
    }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaAttribute>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaAttributePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating attribute\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaAttributePtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaAttribute>() as std::os::raw::c_ulong);
    (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTE;
    (*ret).node = node;
    (*ret).name = name;
    (*ret).targetNamespace = nsName;
    if topLevel != 0 {
        xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).globals,
                             5 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    } else {
        xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).locals,
                             10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    }
    xmlSchemaAddItemSize(&mut (*(*ctxt).constructor).pending,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
/* *
 * xmlSchemaAddAttributeUse:
 * @ctxt:  a schema parser context
 * @schema:  the schema being built
 * @name:  the item name
 * @namespace:  the namespace
 *
 * Add an XML schema Attrribute declaration
 * *WARNING* this interface is highly subject to change
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddAttributeUse(mut pctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut node: xmlNodePtr)
 -> xmlSchemaAttributeUsePtr {
    let mut ret: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    if pctxt.is_null() { return 0 as xmlSchemaAttributeUsePtr }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaAttributeUse>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaAttributeUsePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(pctxt,
                            b"allocating attribute\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaAttributeUsePtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaAttributeUse>() as std::os::raw::c_ulong);
    (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTE_USE;
    (*ret).node = node;
    xmlSchemaAddItemSize(&mut (*(*(*pctxt).constructor).bucket).locals,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
/*
* xmlSchemaAddRedef:
*
* Adds a redefinition information. This is used at a later stage to:
* resolve references to the redefined components and to check constraints.
*/
unsafe extern "C" fn xmlSchemaAddRedef(mut pctxt: xmlSchemaParserCtxtPtr,
                                       mut targetBucket: xmlSchemaBucketPtr,
                                       mut item: *mut std::os::raw::c_void,
                                       mut refName: *const xmlChar,
                                       mut refTargetNs: *const xmlChar)
 -> xmlSchemaRedefPtr {
    let mut ret: xmlSchemaRedefPtr = 0 as *mut xmlSchemaRedef;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaRedef>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaRedefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(pctxt,
                            b"allocating redefinition info\x00" as *const u8
                                as *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaRedefPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaRedef>() as std::os::raw::c_ulong);
    (*ret).item = item as xmlSchemaBasicItemPtr;
    (*ret).targetBucket = targetBucket;
    (*ret).refName = refName;
    (*ret).refTargetNs = refTargetNs;
    if (*(*pctxt).constructor).redefs.is_null() {
        (*(*pctxt).constructor).redefs = ret
    } else { (*(*(*pctxt).constructor).lastRedef).next = ret }
    (*(*pctxt).constructor).lastRedef = ret;
    return ret;
}
/* *
 * xmlSchemaAddAttributeGroupDefinition:
 * @ctxt:  a schema parser context
 * @schema:  the schema being built
 * @name:  the item name
 * @nsName:  the target namespace
 * @node: the corresponding node
 *
 * Add an XML schema Attrribute Group definition.
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddAttributeGroupDefinition(mut pctxt:
                                                              xmlSchemaParserCtxtPtr,
                                                          mut schema:
                                                              xmlSchemaPtr,
                                                          mut name:
                                                              *const xmlChar,
                                                          mut nsName:
                                                              *const xmlChar,
                                                          mut node:
                                                              xmlNodePtr)
 -> xmlSchemaAttributeGroupPtr {
    let mut ret: xmlSchemaAttributeGroupPtr = 0 as xmlSchemaAttributeGroupPtr;
    if pctxt.is_null() || name.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr
    }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaAttributeGroup>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaAttributeGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(pctxt,
                            b"allocating attribute group\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaAttributeGroupPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaAttributeGroup>() as std::os::raw::c_ulong);
    (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTEGROUP;
    (*ret).name = name;
    (*ret).targetNamespace = nsName;
    (*ret).node = node;
    /* TODO: Remove the flag. */
    (*ret).flags |= (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int;
    if (*pctxt).isRedefine != 0 {
        (*pctxt).redef =
            xmlSchemaAddRedef(pctxt, (*pctxt).redefined,
                              ret as *mut std::os::raw::c_void, name, nsName);
        if (*pctxt).redef.is_null() {
            xmlFree.expect("non-null function pointer")(ret as
                                                            *mut std::os::raw::c_void);
            return 0 as xmlSchemaAttributeGroupPtr
        }
        (*pctxt).redefCounter = 0 as std::os::raw::c_int
    }
    xmlSchemaAddItemSize(&mut (*(*(*pctxt).constructor).bucket).globals,
                         5 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    xmlSchemaAddItemSize(&mut (*(*pctxt).constructor).pending,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
/* *
 * xmlSchemaAddElement:
 * @ctxt:  a schema parser context
 * @schema:  the schema being built
 * @name:  the type name
 * @namespace:  the type namespace
 *
 * Add an XML schema Element declaration
 * *WARNING* this interface is highly subject to change
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddElement(mut ctxt: xmlSchemaParserCtxtPtr,
                                         mut name: *const xmlChar,
                                         mut nsName: *const xmlChar,
                                         mut node: xmlNodePtr,
                                         mut topLevel: std::os::raw::c_int)
 -> xmlSchemaElementPtr {
    let mut ret: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    if ctxt.is_null() || name.is_null() { return 0 as xmlSchemaElementPtr }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaElement>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaElementPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating element\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaElementPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaElement>() as std::os::raw::c_ulong);
    (*ret).type_0 = XML_SCHEMA_TYPE_ELEMENT;
    (*ret).name = name;
    (*ret).targetNamespace = nsName;
    (*ret).node = node;
    if topLevel != 0 {
        xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).globals,
                             5 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    } else {
        xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).locals,
                             10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    }
    xmlSchemaAddItemSize(&mut (*(*ctxt).constructor).pending,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
/* *
 * xmlSchemaAddType:
 * @ctxt:  a schema parser context
 * @schema:  the schema being built
 * @name:  the item name
 * @namespace:  the namespace
 *
 * Add an XML schema item
 * *WARNING* this interface is highly subject to change
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddType(mut ctxt: xmlSchemaParserCtxtPtr,
                                      mut schema: xmlSchemaPtr,
                                      mut type_0: xmlSchemaTypeType,
                                      mut name: *const xmlChar,
                                      mut nsName: *const xmlChar,
                                      mut node: xmlNodePtr,
                                      mut topLevel: std::os::raw::c_int)
 -> xmlSchemaTypePtr {
    let mut ret: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    if ctxt.is_null() || schema.is_null() { return 0 as xmlSchemaTypePtr }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaType>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaTypePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating type\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaTypePtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaType>() as std::os::raw::c_ulong);
    (*ret).type_0 = type_0;
    (*ret).name = name;
    (*ret).targetNamespace = nsName;
    (*ret).node = node;
    if topLevel != 0 {
        if (*ctxt).isRedefine != 0 {
            (*ctxt).redef =
                xmlSchemaAddRedef(ctxt, (*ctxt).redefined,
                                  ret as *mut std::os::raw::c_void, name, nsName);
            if (*ctxt).redef.is_null() {
                xmlFree.expect("non-null function pointer")(ret as
                                                                *mut std::os::raw::c_void);
                return 0 as xmlSchemaTypePtr
            }
            (*ctxt).redefCounter = 0 as std::os::raw::c_int
        }
        xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).globals,
                             5 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    } else {
        xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).locals,
                             10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    }
    xmlSchemaAddItemSize(&mut (*(*ctxt).constructor).pending,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
unsafe extern "C" fn xmlSchemaNewQNameRef(mut pctxt: xmlSchemaParserCtxtPtr,
                                          mut refType: xmlSchemaTypeType,
                                          mut refName: *const xmlChar,
                                          mut refNs: *const xmlChar)
 -> xmlSchemaQNameRefPtr {
    let mut ret: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaQNameRef>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaQNameRefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(pctxt,
                            b"allocating QName reference item\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaQNameRefPtr
    }
    (*ret).node = 0 as xmlNodePtr;
    (*ret).type_0 = XML_SCHEMA_EXTRA_QNAMEREF;
    (*ret).name = refName;
    (*ret).targetNamespace = refNs;
    (*ret).item = 0 as xmlSchemaBasicItemPtr;
    (*ret).itemType = refType;
    /*
    * Store the reference item in the schema.
    */
    xmlSchemaAddItemSize(&mut (*(*(*pctxt).constructor).bucket).locals,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
unsafe extern "C" fn xmlSchemaAddAttributeUseProhib(mut pctxt:
                                                        xmlSchemaParserCtxtPtr)
 -> xmlSchemaAttributeUseProhibPtr {
    let mut ret: xmlSchemaAttributeUseProhibPtr =
        0 as *mut xmlSchemaAttributeUseProhib;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaAttributeUseProhib>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaAttributeUseProhibPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(pctxt,
                            b"allocating attribute use prohibition\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaAttributeUseProhibPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaAttributeUseProhib>() as
               std::os::raw::c_ulong);
    (*ret).type_0 = XML_SCHEMA_EXTRA_ATTR_USE_PROHIB;
    xmlSchemaAddItemSize(&mut (*(*(*pctxt).constructor).bucket).locals,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
/* *
 * xmlSchemaAddModelGroup:
 * @ctxt:  a schema parser context
 * @schema:  the schema being built
 * @type: the "compositor" type of the model group
 * @node: the node in the schema doc
 *
 * Adds a schema model group
 * *WARNING* this interface is highly subject to change
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddModelGroup(mut ctxt: xmlSchemaParserCtxtPtr,
                                            mut schema: xmlSchemaPtr,
                                            mut type_0: xmlSchemaTypeType,
                                            mut node: xmlNodePtr)
 -> xmlSchemaModelGroupPtr {
    let mut ret: xmlSchemaModelGroupPtr = 0 as xmlSchemaModelGroupPtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaModelGroupPtr
    }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaModelGroup>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaModelGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating model group component\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaModelGroupPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaModelGroup>() as std::os::raw::c_ulong);
    (*ret).type_0 = type_0;
    (*ret).node = node;
    xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).locals,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    if type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_SEQUENCE as std::os::raw::c_int as std::os::raw::c_uint ||
           type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_CHOICE as std::os::raw::c_int as std::os::raw::c_uint {
        xmlSchemaAddItemSize(&mut (*(*ctxt).constructor).pending,
                             10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    }
    return ret;
}
/* *
 * xmlSchemaAddParticle:
 * @ctxt:  a schema parser context
 * @schema:  the schema being built
 * @node: the corresponding node in the schema doc
 * @min: the minOccurs
 * @max: the maxOccurs
 *
 * Adds an XML schema particle component.
 * *WARNING* this interface is highly subject to change
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddParticle(mut ctxt: xmlSchemaParserCtxtPtr,
                                          mut node: xmlNodePtr,
                                          mut min: std::os::raw::c_int,
                                          mut max: std::os::raw::c_int)
 -> xmlSchemaParticlePtr {
    let mut ret: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
    if ctxt.is_null() { return 0 as xmlSchemaParticlePtr }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaParticle>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaParticlePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating particle component\x00" as *const u8
                                as *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaParticlePtr
    }
    (*ret).type_0 = XML_SCHEMA_TYPE_PARTICLE;
    (*ret).annot = 0 as xmlSchemaAnnotPtr;
    (*ret).node = node;
    (*ret).minOccurs = min;
    (*ret).maxOccurs = max;
    (*ret).next = 0 as xmlSchemaTreeItemPtr;
    (*ret).children = 0 as xmlSchemaTreeItemPtr;
    xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).locals,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    /*
    * Note that addition to pending components will be done locally
    * to the specific parsing function, since the most particles
    * need not to be fixed up (i.e. the reference to be resolved).
    * REMOVED: WXS_ADD_PENDING(ctxt, ret);
    */
    return ret;
}
/* *
 * xmlSchemaAddModelGroupDefinition:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @name:  the group name
 *
 * Add an XML schema Group definition
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddModelGroupDefinition(mut ctxt:
                                                          xmlSchemaParserCtxtPtr,
                                                      mut schema:
                                                          xmlSchemaPtr,
                                                      mut name:
                                                          *const xmlChar,
                                                      mut nsName:
                                                          *const xmlChar,
                                                      mut node: xmlNodePtr)
 -> xmlSchemaModelGroupDefPtr {
    let mut ret: xmlSchemaModelGroupDefPtr = 0 as xmlSchemaModelGroupDefPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr
    }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaModelGroupDef>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaModelGroupDefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"adding group\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaModelGroupDefPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaModelGroupDef>() as std::os::raw::c_ulong);
    (*ret).name = name;
    (*ret).type_0 = XML_SCHEMA_TYPE_GROUP;
    (*ret).node = node;
    (*ret).targetNamespace = nsName;
    if (*ctxt).isRedefine != 0 {
        (*ctxt).redef =
            xmlSchemaAddRedef(ctxt, (*ctxt).redefined,
                              ret as *mut std::os::raw::c_void, name, nsName);
        if (*ctxt).redef.is_null() {
            xmlFree.expect("non-null function pointer")(ret as
                                                            *mut std::os::raw::c_void);
            return 0 as xmlSchemaModelGroupDefPtr
        }
        (*ctxt).redefCounter = 0 as std::os::raw::c_int
    }
    xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).globals,
                         5 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    xmlSchemaAddItemSize(&mut (*(*ctxt).constructor).pending,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
/* *
 * xmlSchemaNewWildcardNs:
 * @ctxt:  a schema validation context
 *
 * Creates a new wildcard namespace constraint.
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaNewWildcardNsConstraint(mut ctxt:
                                                          xmlSchemaParserCtxtPtr)
 -> xmlSchemaWildcardNsPtr {
    let mut ret: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaWildcardNs>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaWildcardNsPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"creating wildcard namespace constraint\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaWildcardNsPtr
    }
    (*ret).value = 0 as *const xmlChar;
    (*ret).next = 0 as *mut _xmlSchemaWildcardNs;
    return ret;
}
unsafe extern "C" fn xmlSchemaAddIDC(mut ctxt: xmlSchemaParserCtxtPtr,
                                     mut schema: xmlSchemaPtr,
                                     mut name: *const xmlChar,
                                     mut nsName: *const xmlChar,
                                     mut category: std::os::raw::c_int,
                                     mut node: xmlNodePtr)
 -> xmlSchemaIDCPtr {
    let mut ret: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaIDCPtr
    }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaIDC>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaIDCPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating an identity-constraint definition\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaIDCPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaIDC>() as std::os::raw::c_ulong);
    /* The target namespace of the parent element declaration. */
    (*ret).targetNamespace = nsName;
    (*ret).name = name;
    (*ret).type_0 = category as xmlSchemaTypeType;
    (*ret).node = node;
    xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).globals,
                         5 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    /*
    * Only keyrefs need to be fixup up.
    */
    if category == XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int {
        xmlSchemaAddItemSize(&mut (*(*ctxt).constructor).pending,
                             10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    }
    return ret;
}
/* *
 * xmlSchemaAddWildcard:
 * @ctxt:  a schema validation context
 * @schema: a schema
 *
 * Adds a wildcard.
 * It corresponds to a xsd:anyAttribute and xsd:any.
 *
 * Returns the new struture or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaAddWildcard(mut ctxt: xmlSchemaParserCtxtPtr,
                                          mut schema: xmlSchemaPtr,
                                          mut type_0: xmlSchemaTypeType,
                                          mut node: xmlNodePtr)
 -> xmlSchemaWildcardPtr {
    let mut ret: xmlSchemaWildcardPtr = 0 as xmlSchemaWildcardPtr;
    if ctxt.is_null() || schema.is_null() { return 0 as xmlSchemaWildcardPtr }
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaWildcard>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaWildcardPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"adding wildcard\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaWildcardPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaWildcard>() as std::os::raw::c_ulong);
    (*ret).type_0 = type_0;
    (*ret).node = node;
    xmlSchemaAddItemSize(&mut (*(*(*ctxt).constructor).bucket).locals,
                         10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    return ret;
}
unsafe extern "C" fn xmlSchemaSubstGroupFree(mut group:
                                                 xmlSchemaSubstGroupPtr) {
    if group.is_null() { return }
    if !(*group).members.is_null() {
        xmlSchemaItemListFree((*group).members);
    }
    xmlFree.expect("non-null function pointer")(group as *mut std::os::raw::c_void);
}
unsafe extern "C" fn xmlSchemaSubstGroupFreeEntry(mut group:
                                                      *mut std::os::raw::c_void,
                                                  mut name: *const xmlChar) {
    xmlSchemaSubstGroupFree(group as xmlSchemaSubstGroupPtr);
}
unsafe extern "C" fn xmlSchemaSubstGroupAdd(mut pctxt: xmlSchemaParserCtxtPtr,
                                            mut head: xmlSchemaElementPtr)
 -> xmlSchemaSubstGroupPtr {
    let mut ret: xmlSchemaSubstGroupPtr = 0 as *mut xmlSchemaSubstGroup;
    /* Init subst group hash. */
    if (*(*pctxt).constructor).substGroups.is_null() {
        (*(*pctxt).constructor).substGroups =
            xmlHashCreateDict(10 as std::os::raw::c_int, (*pctxt).dict);
        if (*(*pctxt).constructor).substGroups.is_null() {
            return 0 as xmlSchemaSubstGroupPtr
        }
    }
    /* Create a new substitution group. */
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaSubstGroup>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaSubstGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                            b"allocating a substitution group container\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaSubstGroupPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaSubstGroup>() as std::os::raw::c_ulong);
    (*ret).head = head;
    /* Create list of members. */
    (*ret).members = xmlSchemaItemListCreate();
    if (*ret).members.is_null() {
        xmlSchemaSubstGroupFree(ret);
        return 0 as xmlSchemaSubstGroupPtr
    }
    /* Add subst group to hash. */
    if xmlHashAddEntry2((*(*pctxt).constructor).substGroups, (*head).name,
                        (*head).targetNamespace, ret as *mut std::os::raw::c_void) !=
           0 as std::os::raw::c_int {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaSubstGroupAdd\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"failed to add a new substitution container\x00"
                                 as *const u8 as *const std::os::raw::c_char);
        xmlSchemaSubstGroupFree(ret);
        return 0 as xmlSchemaSubstGroupPtr
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaSubstGroupGet(mut pctxt: xmlSchemaParserCtxtPtr,
                                            mut head: xmlSchemaElementPtr)
 -> xmlSchemaSubstGroupPtr {
    if (*(*pctxt).constructor).substGroups.is_null() {
        return 0 as xmlSchemaSubstGroupPtr
    }
    return xmlHashLookup2((*(*pctxt).constructor).substGroups, (*head).name,
                          (*head).targetNamespace) as xmlSchemaSubstGroupPtr;
}
/* *
 * xmlSchemaAddElementSubstitutionMember:
 * @pctxt:  a schema parser context
 * @head:  the head of the substitution group
 * @member: the new member of the substitution group
 *
 * Allocate a new annotation structure.
 *
 * Returns the newly allocated structure or NULL in case or error
 */
unsafe extern "C" fn xmlSchemaAddElementSubstitutionMember(mut pctxt:
                                                               xmlSchemaParserCtxtPtr,
                                                           mut head:
                                                               xmlSchemaElementPtr,
                                                           mut member:
                                                               xmlSchemaElementPtr)
 -> std::os::raw::c_int {
    let mut substGroup: xmlSchemaSubstGroupPtr = 0 as xmlSchemaSubstGroupPtr;
    if pctxt.is_null() || head.is_null() || member.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    substGroup = xmlSchemaSubstGroupGet(pctxt, head);
    if substGroup.is_null() {
        substGroup = xmlSchemaSubstGroupAdd(pctxt, head)
    }
    if substGroup.is_null() { return -(1 as std::os::raw::c_int) }
    if xmlSchemaItemListAdd((*substGroup).members,
                            member as *mut std::os::raw::c_void) ==
           -(1 as std::os::raw::c_int) {
        return -(1 as std::os::raw::c_int)
    }
    return 0 as std::os::raw::c_int;
}
/* ***********************************************************************
 *									*
 *		Utilities for parsing					*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaPValAttrNodeQNameValue:
 * @ctxt:  a schema parser context
 * @schema: the schema context
 * @ownerDes: the designation of the parent element
 * @ownerItem: the parent as a schema object
 * @value:  the QName value
 * @local: the resulting local part if found, the attribute value otherwise
 * @uri:  the resulting namespace URI if found
 *
 * Extracts the local name and the URI of a QName value and validates it.
 * This one is intended to be used on attribute values that
 * should resolve to schema components.
 *
 * Returns 0, in case the QName is valid, a positive error code
 * if not valid and -1 if an internal error occurs.
 */
unsafe extern "C" fn xmlSchemaPValAttrNodeQNameValue(mut ctxt:
                                                         xmlSchemaParserCtxtPtr,
                                                     mut schema: xmlSchemaPtr,
                                                     mut ownerItem:
                                                         xmlSchemaBasicItemPtr,
                                                     mut attr: xmlAttrPtr,
                                                     mut value:
                                                         *const xmlChar,
                                                     mut uri:
                                                         *mut *const xmlChar,
                                                     mut local:
                                                         *mut *const xmlChar)
 -> std::os::raw::c_int {
    let mut pref: *const xmlChar = 0 as *const xmlChar;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut len: std::os::raw::c_int = 0;
    let mut ret: std::os::raw::c_int = 0;
    *uri = 0 as *const xmlChar;
    *local = 0 as *const xmlChar;
    ret = xmlValidateQName(value, 1 as std::os::raw::c_int);
    if ret > 0 as std::os::raw::c_int {
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                ownerItem, attr as xmlNodePtr,
                                xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
                                0 as *const std::os::raw::c_char, value,
                                0 as *const std::os::raw::c_char, 0 as *const xmlChar,
                                0 as *const xmlChar);
        *local = value;
        return (*ctxt).err
    } else { if ret < 0 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) } }
    if strchr(value as *mut std::os::raw::c_char, ':' as i32).is_null() {
        ns = xmlSearchNs((*attr).doc, (*attr).parent, 0 as *const xmlChar);
        if !ns.is_null() {
            *uri =
                xmlDictLookup((*ctxt).dict, (*ns).href, -(1 as std::os::raw::c_int))
        } else if (*schema).flags & (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int !=
                      0 {
            /* TODO: move XML_SCHEMAS_INCLUDING_CONVERT_NS to the
	    * parser context. */
	    /*
	    * This one takes care of included schemas with no
	    * target namespace.
	    */
            *uri = (*ctxt).targetNamespace
        }
        *local = xmlDictLookup((*ctxt).dict, value, -(1 as std::os::raw::c_int));
        return 0 as std::os::raw::c_int
    }
    /*
    * At this point xmlSplitQName3 has to return a local name.
    */
    *local = xmlSplitQName3(value, &mut len);
    *local = xmlDictLookup((*ctxt).dict, *local, -(1 as std::os::raw::c_int));
    pref = xmlDictLookup((*ctxt).dict, value, len);
    ns = xmlSearchNs((*attr).doc, (*attr).parent, pref);
    if ns.is_null() {
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                ownerItem, attr as xmlNodePtr,
                                xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
                                0 as *const std::os::raw::c_char, value,
                                b"The value \'%s\' of simple type \'xs:QName\' has no corresponding namespace declaration in scope\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                value, 0 as *const xmlChar);
        return (*ctxt).err
    } else {
        *uri = xmlDictLookup((*ctxt).dict, (*ns).href, -(1 as std::os::raw::c_int))
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaPValAttrNodeQName:
 * @ctxt:  a schema parser context
 * @schema: the schema context
 * @ownerDes: the designation of the owner element
 * @ownerItem: the owner as a schema object
 * @attr:  the attribute node
 * @local: the resulting local part if found, the attribute value otherwise
 * @uri:  the resulting namespace URI if found
 *
 * Extracts and validates the QName of an attribute value.
 * This one is intended to be used on attribute values that
 * should resolve to schema components.
 *
 * Returns 0, in case the QName is valid, a positive error code
 * if not valid and -1 if an internal error occurs.
 */
unsafe extern "C" fn xmlSchemaPValAttrNodeQName(mut ctxt:
                                                    xmlSchemaParserCtxtPtr,
                                                mut schema: xmlSchemaPtr,
                                                mut ownerItem:
                                                    xmlSchemaBasicItemPtr,
                                                mut attr: xmlAttrPtr,
                                                mut uri: *mut *const xmlChar,
                                                mut local:
                                                    *mut *const xmlChar)
 -> std::os::raw::c_int {
    let mut value: *const xmlChar = 0 as *const xmlChar;
    value = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    return xmlSchemaPValAttrNodeQNameValue(ctxt, schema, ownerItem, attr,
                                           value, uri, local);
}
/* *
 * xmlSchemaPValAttrQName:
 * @ctxt:  a schema parser context
 * @schema: the schema context
 * @ownerDes: the designation of the parent element
 * @ownerItem: the owner as a schema object
 * @ownerElem:  the parent node of the attribute
 * @name:  the name of the attribute
 * @local: the resulting local part if found, the attribute value otherwise
 * @uri:  the resulting namespace URI if found
 *
 * Extracts and validates the QName of an attribute value.
 *
 * Returns 0, in case the QName is valid, a positive error code
 * if not valid and -1 if an internal error occurs.
 */
unsafe extern "C" fn xmlSchemaPValAttrQName(mut ctxt: xmlSchemaParserCtxtPtr,
                                            mut schema: xmlSchemaPtr,
                                            mut ownerItem:
                                                xmlSchemaBasicItemPtr,
                                            mut ownerElem: xmlNodePtr,
                                            mut name: *const std::os::raw::c_char,
                                            mut uri: *mut *const xmlChar,
                                            mut local: *mut *const xmlChar)
 -> std::os::raw::c_int {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(ownerElem, name);
    if attr.is_null() {
        *local = 0 as *const xmlChar;
        *uri = 0 as *const xmlChar;
        return 0 as std::os::raw::c_int
    }
    return xmlSchemaPValAttrNodeQName(ctxt, schema, ownerItem, attr, uri,
                                      local);
}
/* *
 * xmlSchemaPValAttrID:
 * @ctxt:  a schema parser context
 * @schema: the schema context
 * @ownerDes: the designation of the parent element
 * @ownerItem: the owner as a schema object
 * @ownerElem:  the parent node of the attribute
 * @name:  the name of the attribute
 *
 * Extracts and validates the ID of an attribute value.
 *
 * Returns 0, in case the ID is valid, a positive error code
 * if not valid and -1 if an internal error occurs.
 */
unsafe extern "C" fn xmlSchemaPValAttrNodeID(mut ctxt: xmlSchemaParserCtxtPtr,
                                             mut attr: xmlAttrPtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    if attr.is_null() { return 0 as std::os::raw::c_int }
    value = xmlSchemaGetNodeContentNoDict(attr as xmlNodePtr);
    ret = xmlValidateNCName(value, 1 as std::os::raw::c_int);
    if ret == 0 as std::os::raw::c_int {
        /*
	* NOTE: the IDness might have already be declared in the DTD
	*/
        if (*attr).atype as std::os::raw::c_uint !=
               XML_ATTRIBUTE_ID as std::os::raw::c_int as std::os::raw::c_uint {
            let mut res: xmlIDPtr = 0 as *mut xmlID;
            let mut strip: *mut xmlChar = 0 as *mut xmlChar;
            /*
	    * TODO: Use xmlSchemaStrip here; it's not exported at this
	    * moment.
	    */
            strip = xmlSchemaCollapseString(value);
            if !strip.is_null() {
                xmlFree.expect("non-null function pointer")(value as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
                value = strip
            }
            res = xmlAddID(0 as xmlValidCtxtPtr, (*attr).doc, value, attr);
            if res.is_null() {
                ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as std::os::raw::c_int;
                xmlSchemaPSimpleTypeErr(ctxt,
                                        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                        0 as xmlSchemaBasicItemPtr,
                                        attr as xmlNodePtr,
                                        xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
                                        0 as *const std::os::raw::c_char,
                                        0 as *const xmlChar,
                                        b"Duplicate value \'%s\' of simple type \'xs:ID\'\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char, value,
                                        0 as *const xmlChar);
            } else { (*attr).atype = XML_ATTRIBUTE_ID }
        }
    } else if ret > 0 as std::os::raw::c_int {
        ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as std::os::raw::c_int;
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
                                0 as *const std::os::raw::c_char, 0 as *const xmlChar,
                                b"The value \'%s\' of simple type \'xs:ID\' is not a valid \'xs:NCName\'\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                value, 0 as *const xmlChar);
    }
    if !value.is_null() {
        xmlFree.expect("non-null function pointer")(value as *mut xmlChar as
                                                        *mut std::os::raw::c_void);
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPValAttrID(mut ctxt: xmlSchemaParserCtxtPtr,
                                         mut ownerElem: xmlNodePtr,
                                         mut name: *const xmlChar)
 -> std::os::raw::c_int {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(ownerElem, name as *const std::os::raw::c_char);
    if attr.is_null() { return 0 as std::os::raw::c_int }
    return xmlSchemaPValAttrNodeID(ctxt, attr);
}
/* *
 * xmlGetMaxOccurs:
 * @ctxt:  a schema validation context
 * @node:  a subtree containing XML Schema informations
 *
 * Get the maxOccurs property
 *
 * Returns the default if not found, or the value
 */
unsafe extern "C" fn xmlGetMaxOccurs(mut ctxt: xmlSchemaParserCtxtPtr,
                                     mut node: xmlNodePtr,
                                     mut min: std::os::raw::c_int,
                                     mut max: std::os::raw::c_int,
                                     mut def: std::os::raw::c_int,
                                     mut expected: *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr =
        xmlSchemaGetPropNode(node,
                             b"maxOccurs\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    if attr.is_null() { return def }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if xmlStrEqual(val,
                   b"unbounded\x00" as *const u8 as *const std::os::raw::c_char as
                       *const xmlChar) != 0 {
        if max != (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int {
            xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                    0 as xmlSchemaBasicItemPtr,
                                    attr as xmlNodePtr, 0 as xmlSchemaTypePtr,
                                    expected, val, 0 as *const std::os::raw::c_char,
                                    0 as *const xmlChar, 0 as *const xmlChar);
            return def
        } else { return (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int }
        /* encoding it with -1 might be another option */
    }
    cur = val;
    while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
              0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                  *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
              *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
        cur = cur.offset(1)
    }
    if *cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr, 0 as xmlSchemaTypePtr,
                                expected, val, 0 as *const std::os::raw::c_char,
                                0 as *const xmlChar, 0 as *const xmlChar);
        return def
    }
    while *cur as std::os::raw::c_int >= '0' as i32 &&
              *cur as std::os::raw::c_int <= '9' as i32 {
        ret = ret * 10 as std::os::raw::c_int + (*cur as std::os::raw::c_int - '0' as i32);
        cur = cur.offset(1)
    }
    while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
              0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                  *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
              *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
        cur = cur.offset(1)
    }
    /*
    * TODO: Restrict the maximal value to Integer.
    */
    if *cur as std::os::raw::c_int != 0 as std::os::raw::c_int || ret < min ||
           max != -(1 as std::os::raw::c_int) && ret > max {
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr, 0 as xmlSchemaTypePtr,
                                expected, val, 0 as *const std::os::raw::c_char,
                                0 as *const xmlChar, 0 as *const xmlChar);
        return def
    }
    return ret;
}
/* *
 * xmlGetMinOccurs:
 * @ctxt:  a schema validation context
 * @node:  a subtree containing XML Schema informations
 *
 * Get the minOccurs property
 *
 * Returns the default if not found, or the value
 */
unsafe extern "C" fn xmlGetMinOccurs(mut ctxt: xmlSchemaParserCtxtPtr,
                                     mut node: xmlNodePtr,
                                     mut min: std::os::raw::c_int,
                                     mut max: std::os::raw::c_int,
                                     mut def: std::os::raw::c_int,
                                     mut expected: *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr =
        xmlSchemaGetPropNode(node,
                             b"minOccurs\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    if attr.is_null() { return def }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    cur = val;
    while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
              0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                  *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
              *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
        cur = cur.offset(1)
    }
    if *cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr, 0 as xmlSchemaTypePtr,
                                expected, val, 0 as *const std::os::raw::c_char,
                                0 as *const xmlChar, 0 as *const xmlChar);
        return def
    }
    while *cur as std::os::raw::c_int >= '0' as i32 &&
              *cur as std::os::raw::c_int <= '9' as i32 {
        ret = ret * 10 as std::os::raw::c_int + (*cur as std::os::raw::c_int - '0' as i32);
        cur = cur.offset(1)
    }
    while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
              0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                  *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
              *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
        cur = cur.offset(1)
    }
    /*
    * TODO: Restrict the maximal value to Integer.
    */
    if *cur as std::os::raw::c_int != 0 as std::os::raw::c_int || ret < min ||
           max != -(1 as std::os::raw::c_int) && ret > max {
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr, 0 as xmlSchemaTypePtr,
                                expected, val, 0 as *const std::os::raw::c_char,
                                0 as *const xmlChar, 0 as *const xmlChar);
        return def
    }
    return ret;
}
/* *
 * xmlSchemaPGetBoolNodeValue:
 * @ctxt:  a schema validation context
 * @ownerDes:  owner designation
 * @ownerItem:  the owner as a schema item
 * @node: the node holding the value
 *
 * Converts a boolean string value into 1 or 0.
 *
 * Returns 0 or 1.
 */
unsafe extern "C" fn xmlSchemaPGetBoolNodeValue(mut ctxt:
                                                    xmlSchemaParserCtxtPtr,
                                                mut ownerItem:
                                                    xmlSchemaBasicItemPtr,
                                                mut node: xmlNodePtr)
 -> std::os::raw::c_int {
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut res: std::os::raw::c_int = 0 as std::os::raw::c_int;
    value = xmlNodeGetContent(node as *const xmlNode);
    /*
    * 3.2.2.1 Lexical representation
    * An instance of a datatype that is defined as `boolean`
    * can have the following legal literals {true, false, 1, 0}.
    */
    if xmlStrEqual(value,
                   b"true\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        res = 1 as std::os::raw::c_int
    } else if xmlStrEqual(value,
                          b"false\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar) != 0 {
        res = 0 as std::os::raw::c_int
    } else if xmlStrEqual(value,
                          b"1\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar) != 0 {
        res = 1 as std::os::raw::c_int
    } else if xmlStrEqual(value,
                          b"0\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar) != 0 {
        res = 0 as std::os::raw::c_int
    } else {
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_INVALID_BOOLEAN, ownerItem,
                                node,
                                xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
                                0 as *const std::os::raw::c_char, value,
                                0 as *const std::os::raw::c_char, 0 as *const xmlChar,
                                0 as *const xmlChar);
    }
    if !value.is_null() {
        xmlFree.expect("non-null function pointer")(value as
                                                        *mut std::os::raw::c_void);
    }
    return res;
}
/* *
 * xmlGetBooleanProp:
 * @ctxt:  a schema validation context
 * @node:  a subtree containing XML Schema informations
 * @name:  the attribute name
 * @def:  the default value
 *
 * Evaluate if a boolean property is set
 *
 * Returns the default if not found, 0 if found to be false,
 * 1 if found to be true
 */
unsafe extern "C" fn xmlGetBooleanProp(mut ctxt: xmlSchemaParserCtxtPtr,
                                       mut node: xmlNodePtr,
                                       mut name: *const std::os::raw::c_char,
                                       mut def: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    val = xmlSchemaGetProp(ctxt, node, name);
    if val.is_null() { return def }
    /*
    * 3.2.2.1 Lexical representation
    * An instance of a datatype that is defined as `boolean`
    * can have the following legal literals {true, false, 1, 0}.
    */
    if xmlStrEqual(val,
                   b"true\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        def = 1 as std::os::raw::c_int
    } else if xmlStrEqual(val,
                          b"false\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar) != 0 {
        def = 0 as std::os::raw::c_int
    } else if xmlStrEqual(val,
                          b"1\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar) != 0 {
        def = 1 as std::os::raw::c_int
    } else if xmlStrEqual(val,
                          b"0\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar) != 0 {
        def = 0 as std::os::raw::c_int
    } else {
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_INVALID_BOOLEAN,
                                0 as xmlSchemaBasicItemPtr,
                                xmlSchemaGetPropNode(node, name) as
                                    xmlNodePtr,
                                xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
                                0 as *const std::os::raw::c_char, val,
                                0 as *const std::os::raw::c_char, 0 as *const xmlChar,
                                0 as *const xmlChar);
    }
    return def;
}
/* *
 * xmlSchemaPValAttrNodeValue:
 *
 * @ctxt:  a schema parser context
 * @ownerDes: the designation of the parent element
 * @ownerItem: the schema object owner if existent
 * @attr:  the schema attribute node being validated
 * @value: the value
 * @type: the built-in type to be validated against
 *
 * Validates a value against the given built-in type.
 * This one is intended to be used internally for validation
 * of schema attribute values during parsing of the schema.
 *
 * Returns 0 if the value is valid, a positive error code
 * number otherwise and -1 in case of an internal or API error.
 */
unsafe extern "C" fn xmlSchemaPValAttrNodeValue(mut pctxt:
                                                    xmlSchemaParserCtxtPtr,
                                                mut ownerItem:
                                                    xmlSchemaBasicItemPtr,
                                                mut attr: xmlAttrPtr,
                                                mut value: *const xmlChar,
                                                mut type_0: xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
    * NOTE: Should we move this to xmlschematypes.c? Hmm, but this
    * one is really meant to be used internally, so better not.
    */
    if pctxt.is_null() || type_0.is_null() || attr.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    if (*type_0).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaPValAttrNodeValue\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"the given type is not a built-in type\x00" as
                                 *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    match (*type_0).builtInType {
        22 | 21 | 29 | 16 | 17 => {
            ret =
                xmlSchemaValPredefTypeNode(type_0, value,
                                           0 as *mut xmlSchemaValPtr,
                                           attr as xmlNodePtr)
        }
        _ => {
            xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaPValAttrNodeValue\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"validation using the given type is not supported while parsing a schema\x00"
                                     as *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
    }
    /*
    * TODO: Should we use the S4S error codes instead?
    */
    if ret < 0 as std::os::raw::c_int {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaPValAttrNodeValue\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"failed to validate a schema attribute value\x00"
                                 as *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    } else {
        if ret > 0 as std::os::raw::c_int {
            if (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as std::os::raw::c_int
            } else {
                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as std::os::raw::c_int
            }
            xmlSchemaPSimpleTypeErr(pctxt, ret as xmlParserErrors, ownerItem,
                                    attr as xmlNodePtr, type_0,
                                    0 as *const std::os::raw::c_char, value,
                                    0 as *const std::os::raw::c_char,
                                    0 as *const xmlChar, 0 as *const xmlChar);
        }
    }
    return ret;
}
/* *
 * xmlSchemaPValAttrNode:
 *
 * @ctxt:  a schema parser context
 * @ownerDes: the designation of the parent element
 * @ownerItem: the schema object owner if existent
 * @attr:  the schema attribute node being validated
 * @type: the built-in type to be validated against
 * @value: the resulting value if any
 *
 * Extracts and validates a value against the given built-in type.
 * This one is intended to be used internally for validation
 * of schema attribute values during parsing of the schema.
 *
 * Returns 0 if the value is valid, a positive error code
 * number otherwise and -1 in case of an internal or API error.
 */
unsafe extern "C" fn xmlSchemaPValAttrNode(mut ctxt: xmlSchemaParserCtxtPtr,
                                           mut ownerItem:
                                               xmlSchemaBasicItemPtr,
                                           mut attr: xmlAttrPtr,
                                           mut type_0: xmlSchemaTypePtr,
                                           mut value: *mut *const xmlChar)
 -> std::os::raw::c_int {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || type_0.is_null() || attr.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if !value.is_null() { *value = val }
    return xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr, val, type_0);
}
/* *
 * xmlSchemaPValAttr:
 *
 * @ctxt:  a schema parser context
 * @node: the element node of the attribute
 * @ownerDes: the designation of the parent element
 * @ownerItem: the schema object owner if existent
 * @ownerElem: the owner element node
 * @name:  the name of the schema attribute node
 * @type: the built-in type to be validated against
 * @value: the resulting value if any
 *
 * Extracts and validates a value against the given built-in type.
 * This one is intended to be used internally for validation
 * of schema attribute values during parsing of the schema.
 *
 * Returns 0 if the value is valid, a positive error code
 * number otherwise and -1 in case of an internal or API error.
 */
unsafe extern "C" fn xmlSchemaPValAttr(mut ctxt: xmlSchemaParserCtxtPtr,
                                       mut ownerItem: xmlSchemaBasicItemPtr,
                                       mut ownerElem: xmlNodePtr,
                                       mut name: *const std::os::raw::c_char,
                                       mut type_0: xmlSchemaTypePtr,
                                       mut value: *mut *const xmlChar)
 -> std::os::raw::c_int {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || type_0.is_null() {
        if !value.is_null() { *value = 0 as *const xmlChar }
        return -(1 as std::os::raw::c_int)
    }
    if (*type_0).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
        if !value.is_null() { *value = 0 as *const xmlChar }
        xmlSchemaPErr(ctxt, ownerElem, XML_SCHEMAP_INTERNAL as std::os::raw::c_int,
                      b"Internal error: xmlSchemaPValAttr, the given type \'%s\' is not a built-in type.\n\x00"
                          as *const u8 as *const std::os::raw::c_char, (*type_0).name,
                      0 as *const xmlChar);
        return -(1 as std::os::raw::c_int)
    }
    attr = xmlSchemaGetPropNode(ownerElem, name);
    if attr.is_null() {
        if !value.is_null() { *value = 0 as *const xmlChar }
        return 0 as std::os::raw::c_int
    }
    return xmlSchemaPValAttrNode(ctxt, ownerItem, attr, type_0, value);
}
unsafe extern "C" fn xmlSchemaCheckReference(mut pctxt:
                                                 xmlSchemaParserCtxtPtr,
                                             mut schema: xmlSchemaPtr,
                                             mut node: xmlNodePtr,
                                             mut attr: xmlAttrPtr,
                                             mut namespaceName:
                                                 *const xmlChar)
 -> std::os::raw::c_int {
    /* TODO: Pointer comparison instead? */
    if xmlStrEqual((*pctxt).targetNamespace, namespaceName) != 0 {
        return 0 as std::os::raw::c_int
    }
    if xmlStrEqual(xmlSchemaNs, namespaceName) != 0 {
        return 0 as std::os::raw::c_int
    }
    /*
    * Check if the referenced namespace was <import>ed.
    */
    if !(*(*(*pctxt).constructor).bucket).relations.is_null() {
        let mut rel: xmlSchemaSchemaRelationPtr =
            0 as *mut xmlSchemaSchemaRelation;
        rel = (*(*(*pctxt).constructor).bucket).relations;
        loop  {
            if ((*rel).type_0 == 0 as std::os::raw::c_int ||
                    (*rel).type_0 == 1 as std::os::raw::c_int) &&
                   xmlStrEqual(namespaceName, (*rel).importNamespace) != 0 {
                return 0 as std::os::raw::c_int
            }
            rel = (*rel).next;
            if rel.is_null() { break ; }
        }
    }
    /*
    * No matching <import>ed namespace found.
    */
    let mut n: xmlNodePtr =
        if !attr.is_null() { attr as xmlNodePtr } else { node };
    if namespaceName.is_null() {
        xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAP_SRC_RESOLVE, n,
                           0 as xmlSchemaBasicItemPtr,
                           b"References from this schema to components in no namespace are not allowed, since not indicated by an import statement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
    } else {
        xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAP_SRC_RESOLVE, n,
                           0 as xmlSchemaBasicItemPtr,
                           b"References from this schema to components in the namespace \'%s\' are not allowed, since not indicated by an import statement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           namespaceName, 0 as *const xmlChar);
    }
    return XML_SCHEMAP_SRC_RESOLVE as std::os::raw::c_int;
}
/* *
 * xmlSchemaParseLocalAttributes:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 * @type:  the hosting type where the attributes will be anchored
 *
 * Parses attribute uses and attribute declarations and
 * attribute group references.
 */
unsafe extern "C" fn xmlSchemaParseLocalAttributes(mut ctxt:
                                                       xmlSchemaParserCtxtPtr,
                                                   mut schema: xmlSchemaPtr,
                                                   mut child: *mut xmlNodePtr,
                                                   mut list:
                                                       *mut xmlSchemaItemListPtr,
                                                   mut parentType:
                                                       std::os::raw::c_int,
                                                   mut hasRefs:
                                                       *mut std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut item: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    while !(*child).is_null() && !(**child).ns.is_null() &&
              xmlStrEqual((**child).name,
                          b"attribute\x00" as *const u8 as *const std::os::raw::c_char
                              as *const xmlChar) != 0 &&
              xmlStrEqual((*(**child).ns).href, xmlSchemaNs) != 0 ||
              !(*child).is_null() && !(**child).ns.is_null() &&
                  xmlStrEqual((**child).name,
                              b"attributeGroup\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(**child).ns).href, xmlSchemaNs) != 0 {
        if !(*child).is_null() && !(**child).ns.is_null() &&
               xmlStrEqual((**child).name,
                           b"attribute\x00" as *const u8 as
                               *const std::os::raw::c_char as *const xmlChar) != 0 &&
               xmlStrEqual((*(**child).ns).href, xmlSchemaNs) != 0 {
            item =
                xmlSchemaParseLocalAttribute(ctxt, schema, *child, *list,
                                             parentType) as *mut std::os::raw::c_void
        } else {
            item =
                xmlSchemaParseAttributeGroupRef(ctxt, schema, *child) as
                    *mut std::os::raw::c_void;
            if !item.is_null() && !hasRefs.is_null() {
                *hasRefs = 1 as std::os::raw::c_int
            }
        }
        if !item.is_null() {
            if (*list).is_null() {
                /* TODO: Customize grow factor. */
                *list = xmlSchemaItemListCreate();
                if (*list).is_null() { return -(1 as std::os::raw::c_int) }
            }
            if xmlSchemaItemListAddSize(*list, 2 as std::os::raw::c_int, item) ==
                   -(1 as std::os::raw::c_int) {
                return -(1 as std::os::raw::c_int)
            }
        }
        *child = (**child).next
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaParseAnnotation:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Attrribute declaration
 * *WARNING* this interface is highly subject to change
 *
 * Returns -1 in case of error, 0 if the declaration is improper and
 *         1 in case of success.
 */
unsafe extern "C" fn xmlSchemaParseAnnotation(mut ctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut node: xmlNodePtr,
                                              mut needed: std::os::raw::c_int)
 -> xmlSchemaAnnotPtr {
    let mut ret: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut barked: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
    * INFO: S4S completed.
    */
    /*
    * id = ID
    * {any attributes with non-schema namespace . . .}>
    * Content: (appinfo | documentation)*
    */
    if ctxt.is_null() || node.is_null() { return 0 as xmlSchemaAnnotPtr }
    if needed != 0 {
        ret = xmlSchemaNewAnnot(ctxt, node)
    } else { ret = 0 as xmlSchemaAnnotPtr }
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() &&
               xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 ||
               !(*attr).ns.is_null() &&
                   xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * And now for the children...
    */
    child = (*node).children;
    while !child.is_null() {
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"appinfo\x00" as *const u8 as *const std::os::raw::c_char
                               as *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            /* TODO: make available the content of "appinfo". */
	    /*
	    * source = anyURI
	    * {any attributes with non-schema namespace . . .}>
	    * Content: ({any})*
	    */
            attr = (*child).properties;
            while !attr.is_null() {
                if (*attr).ns.is_null() &&
                       xmlStrEqual((*attr).name,
                                   b"source\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) ==
                           0 ||
                       !(*attr).ns.is_null() &&
                           xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                    xmlSchemaPIllegalAttrErr(ctxt,
                                             XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                             0 as xmlSchemaBasicItemPtr,
                                             attr);
                }
                attr = (*attr).next
            }
            xmlSchemaPValAttr(ctxt, 0 as xmlSchemaBasicItemPtr, child,
                              b"source\x00" as *const u8 as
                                  *const std::os::raw::c_char,
                              xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                              0 as *mut *const xmlChar);
            child = (*child).next
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"documentation\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            /* TODO: make available the content of "documentation". */
	    /*
	    * source = anyURI
	    * {any attributes with non-schema namespace . . .}>
	    * Content: ({any})*
	    */
            attr = (*child).properties;
            while !attr.is_null() {
                if (*attr).ns.is_null() {
                    if xmlStrEqual((*attr).name,
                                   b"source\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) ==
                           0 {
                        xmlSchemaPIllegalAttrErr(ctxt,
                                                 XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                                 0 as xmlSchemaBasicItemPtr,
                                                 attr);
                    }
                } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 ||
                              xmlStrEqual((*attr).name,
                                          b"lang\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *mut xmlChar) != 0 &&
                                  xmlStrEqual((*(*attr).ns).href,
                                              b"http://www.w3.org/XML/1998/namespace\x00"
                                                  as *const u8 as
                                                  *const std::os::raw::c_char as
                                                  *const xmlChar) == 0 {
                    xmlSchemaPIllegalAttrErr(ctxt,
                                             XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                             0 as xmlSchemaBasicItemPtr,
                                             attr);
                }
                attr = (*attr).next
            }
            /*
	    * Attribute "xml:lang".
	    */
            attr =
                xmlSchemaGetPropNodeNs(child,
                                       b"http://www.w3.org/XML/1998/namespace\x00"
                                           as *const u8 as *const std::os::raw::c_char
                                           as *const xmlChar as
                                           *const std::os::raw::c_char,
                                       b"lang\x00" as *const u8 as
                                           *const std::os::raw::c_char);
            if !attr.is_null() {
                xmlSchemaPValAttrNode(ctxt, 0 as xmlSchemaBasicItemPtr, attr,
                                      xmlSchemaGetBuiltInType(XML_SCHEMAS_LANGUAGE),
                                      0 as *mut *const xmlChar);
            }
            child = (*child).next
        } else {
            if barked == 0 {
                xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, node, child,
                                     0 as *const std::os::raw::c_char,
                                     b"(appinfo | documentation)*\x00" as
                                         *const u8 as *const std::os::raw::c_char);
            }
            barked = 1 as std::os::raw::c_int;
            child = (*child).next
        }
    }
    return ret;
}
/* *
 * xmlSchemaParseFacet:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Facet declaration
 * *WARNING* this interface is highly subject to change
 *
 * Returns the new type structure or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaParseFacet(mut ctxt: xmlSchemaParserCtxtPtr,
                                         mut schema: xmlSchemaPtr,
                                         mut node: xmlNodePtr)
 -> xmlSchemaFacetPtr {
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaFacetPtr
    }
    facet = xmlSchemaNewFacet();
    if facet.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating facet\x00" as *const u8 as
                                *const std::os::raw::c_char, node);
        return 0 as xmlSchemaFacetPtr
    }
    (*facet).node = node;
    value =
        xmlSchemaGetProp(ctxt, node,
                         b"value\x00" as *const u8 as *const std::os::raw::c_char);
    if value.is_null() {
        xmlSchemaPErr2(ctxt, node, child,
                       XML_SCHEMAP_FACET_NO_VALUE as std::os::raw::c_int,
                       b"Facet %s has no value\n\x00" as *const u8 as
                           *const std::os::raw::c_char, (*node).name,
                       0 as *const xmlChar);
        xmlSchemaFreeFacet(facet);
        return 0 as xmlSchemaFacetPtr
    }
    if !node.is_null() && !(*node).ns.is_null() &&
           xmlStrEqual((*node).name,
                       b"minInclusive\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_MININCLUSIVE
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"minExclusive\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_MINEXCLUSIVE
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"maxInclusive\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_MAXINCLUSIVE
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"maxExclusive\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_MAXEXCLUSIVE
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"totalDigits\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_TOTALDIGITS
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"fractionDigits\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_FRACTIONDIGITS
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"pattern\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_PATTERN
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"enumeration\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_ENUMERATION
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"whiteSpace\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_WHITESPACE
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"length\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_LENGTH
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"maxLength\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_MAXLENGTH
    } else if !node.is_null() && !(*node).ns.is_null() &&
                  xmlStrEqual((*node).name,
                              b"minLength\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0 {
        (*facet).type_0 = XML_SCHEMA_FACET_MINLENGTH
    } else {
        xmlSchemaPErr2(ctxt, node, child,
                       XML_SCHEMAP_UNKNOWN_FACET_TYPE as std::os::raw::c_int,
                       b"Unknown facet type %s\n\x00" as *const u8 as
                           *const std::os::raw::c_char, (*node).name,
                       0 as *const xmlChar);
        xmlSchemaFreeFacet(facet);
        return 0 as xmlSchemaFacetPtr
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    (*facet).value = value;
    if (*facet).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_FACET_PATTERN as std::os::raw::c_int as std::os::raw::c_uint &&
           (*facet).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_FACET_ENUMERATION as std::os::raw::c_int as std::os::raw::c_uint {
        let mut fixed: *const xmlChar = 0 as *const xmlChar;
        fixed =
            xmlSchemaGetProp(ctxt, node,
                             b"fixed\x00" as *const u8 as
                                 *const std::os::raw::c_char);
        if !fixed.is_null() {
            if xmlStrEqual(fixed,
                           b"true\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) != 0 {
                (*facet).fixed = 1 as std::os::raw::c_int
            }
        }
    }
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*facet).annot =
            xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPErr2(ctxt, node, child,
                       XML_SCHEMAP_UNKNOWN_FACET_CHILD as std::os::raw::c_int,
                       b"Facet %s has unexpected child content\n\x00" as
                           *const u8 as *const std::os::raw::c_char, (*node).name,
                       0 as *const xmlChar);
    }
    return facet;
}
/* *
 * xmlSchemaParseWildcardNs:
 * @ctxt:  a schema parser context
 * @wildc:  the wildcard, already created
 * @node:  a subtree containing XML Schema informations
 *
 * Parses the attribute "processContents" and "namespace"
 * of a xsd:anyAttribute and xsd:any.
 * *WARNING* this interface is highly subject to change
 *
 * Returns 0 if everything goes fine, a positive error code
 * if something is not valid and -1 if an internal error occurs.
 */
unsafe extern "C" fn xmlSchemaParseWildcardNs(mut ctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut schema: xmlSchemaPtr,
                                              mut wildc: xmlSchemaWildcardPtr,
                                              mut node: xmlNodePtr)
 -> std::os::raw::c_int {
    let mut pc: *const xmlChar = 0 as *const xmlChar;
    let mut ns: *const xmlChar = 0 as *const xmlChar;
    let mut dictnsItem: *const xmlChar = 0 as *const xmlChar;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut nsItem: *mut xmlChar = 0 as *mut xmlChar;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut lastNs: xmlSchemaWildcardNsPtr = 0 as xmlSchemaWildcardNsPtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    pc =
        xmlSchemaGetProp(ctxt, node,
                         b"processContents\x00" as *const u8 as
                             *const std::os::raw::c_char);
    if pc.is_null() ||
           xmlStrEqual(pc,
                       b"strict\x00" as *const u8 as *const std::os::raw::c_char as
                           *const xmlChar) != 0 {
        (*wildc).processContents = 3 as std::os::raw::c_int
    } else if xmlStrEqual(pc,
                          b"skip\x00" as *const u8 as *const std::os::raw::c_char as
                              *const xmlChar) != 0 {
        (*wildc).processContents = 1 as std::os::raw::c_int
    } else if xmlStrEqual(pc,
                          b"lax\x00" as *const u8 as *const std::os::raw::c_char as
                              *const xmlChar) != 0 {
        (*wildc).processContents = 2 as std::os::raw::c_int
    } else {
        xmlSchemaPSimpleTypeErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr, node,
                                0 as xmlSchemaTypePtr,
                                b"(strict | skip | lax)\x00" as *const u8 as
                                    *const std::os::raw::c_char, pc,
                                0 as *const std::os::raw::c_char, 0 as *const xmlChar,
                                0 as *const xmlChar);
        (*wildc).processContents = 3 as std::os::raw::c_int;
        ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as std::os::raw::c_int
    }
    /*
     * Build the namespace constraints.
     */
    attr =
        xmlSchemaGetPropNode(node,
                             b"namespace\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    ns = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if attr.is_null() ||
           xmlStrEqual(ns,
                       b"##any\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
        (*wildc).any = 1 as std::os::raw::c_int
    } else if xmlStrEqual(ns,
                          b"##other\x00" as *const u8 as *const std::os::raw::c_char
                              as *mut xmlChar) != 0 {
        (*wildc).negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);
        if (*wildc).negNsSet.is_null() { return -(1 as std::os::raw::c_int) }
        (*(*wildc).negNsSet).value = (*ctxt).targetNamespace
    } else {
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut cur: *const xmlChar = 0 as *const xmlChar;
        cur = ns;
        loop  {
            while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                      0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                          *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                      *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                cur = cur.offset(1)
            }
            end = cur;
            while *end as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                      !(*end as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                            0x9 as std::os::raw::c_int <= *end as std::os::raw::c_int &&
                                *end as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                            *end as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
                end = end.offset(1)
            }
            if end == cur { break ; }
            nsItem =
                xmlStrndup(cur,
                           end.offset_from(cur) as std::os::raw::c_long as
                               std::os::raw::c_int);
            if xmlStrEqual(nsItem,
                           b"##other\x00" as *const u8 as *const std::os::raw::c_char
                               as *mut xmlChar) != 0 ||
                   xmlStrEqual(nsItem,
                               b"##any\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) != 0 {
                xmlSchemaPSimpleTypeErr(ctxt,
                                        XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER,
                                        0 as xmlSchemaBasicItemPtr,
                                        attr as xmlNodePtr,
                                        0 as xmlSchemaTypePtr,
                                        b"((##any | ##other) | List of (xs:anyURI | (##targetNamespace | ##local)))\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char, nsItem,
                                        0 as *const std::os::raw::c_char,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar);
                ret = XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER as std::os::raw::c_int
            } else {
                if xmlStrEqual(nsItem,
                               b"##targetNamespace\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) != 0 {
                    dictnsItem = (*ctxt).targetNamespace
                } else if xmlStrEqual(nsItem,
                                      b"##local\x00" as *const u8 as
                                          *const std::os::raw::c_char as *mut xmlChar)
                              != 0 {
                    dictnsItem = 0 as *const xmlChar
                } else {
                    /*
		    * Validate the item (anyURI).
		    */
                    xmlSchemaPValAttrNodeValue(ctxt,
                                               0 as xmlSchemaBasicItemPtr,
                                               attr, nsItem,
                                               xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI));
                    dictnsItem =
                        xmlDictLookup((*ctxt).dict, nsItem,
                                      -(1 as std::os::raw::c_int))
                }
                /*
		* Avoid dublicate namespaces.
		*/
                tmp = (*wildc).nsSet;
                while !tmp.is_null() {
                    if dictnsItem == (*tmp).value { break ; }
                    tmp = (*tmp).next
                }
                if tmp.is_null() {
                    tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
                    if tmp.is_null() {
                        xmlFree.expect("non-null function pointer")(nsItem as
                                                                        *mut std::os::raw::c_void);
                        return -(1 as std::os::raw::c_int)
                    }
                    (*tmp).value = dictnsItem;
                    (*tmp).next = 0 as *mut _xmlSchemaWildcardNs;
                    if (*wildc).nsSet.is_null() {
                        (*wildc).nsSet = tmp
                    } else if !lastNs.is_null() { (*lastNs).next = tmp }
                    lastNs = tmp
                }
            }
            xmlFree.expect("non-null function pointer")(nsItem as
                                                            *mut std::os::raw::c_void);
            cur = end;
            if !(*cur as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPCheckParticleCorrect_2(mut ctxt:
                                                          xmlSchemaParserCtxtPtr,
                                                      mut item:
                                                          xmlSchemaParticlePtr,
                                                      mut node: xmlNodePtr,
                                                      mut minOccurs:
                                                          std::os::raw::c_int,
                                                      mut maxOccurs:
                                                          std::os::raw::c_int)
 -> std::os::raw::c_int {
    if maxOccurs == 0 as std::os::raw::c_int && minOccurs == 0 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    if maxOccurs != (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int {
        /*
	* TODO: Maybe we should better not create the particle,
	* if min/max is invalid, since it could confuse the build of the
	* content model.
	*/
	/*
	* 3.9.6 Schema Component Constraint: Particle Correct
	*
	*/
        if maxOccurs < 1 as std::os::raw::c_int {
            /*
	    * 2.2 {max occurs} must be greater than or equal to 1.
	    */
            xmlSchemaPCustomAttrErr(ctxt, XML_SCHEMAP_P_PROPS_CORRECT_2_2,
                                    0 as *mut *mut xmlChar,
                                    0 as xmlSchemaBasicItemPtr,
                                    xmlSchemaGetPropNode(node,
                                                         b"maxOccurs\x00" as
                                                             *const u8 as
                                                             *const std::os::raw::c_char),
                                    b"The value must be greater than or equal to 1\x00"
                                        as *const u8 as *const std::os::raw::c_char);
            return XML_SCHEMAP_P_PROPS_CORRECT_2_2 as std::os::raw::c_int
        } else {
            if minOccurs > maxOccurs {
                /*
	    * 2.1 {min occurs} must not be greater than {max occurs}.
	    */
                xmlSchemaPCustomAttrErr(ctxt, XML_SCHEMAP_P_PROPS_CORRECT_2_1,
                                        0 as *mut *mut xmlChar,
                                        0 as xmlSchemaBasicItemPtr,
                                        xmlSchemaGetPropNode(node,
                                                             b"minOccurs\x00"
                                                                 as *const u8
                                                                 as
                                                                 *const std::os::raw::c_char),
                                        b"The value must not be greater than the value of \'maxOccurs\'\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char);
                return XML_SCHEMAP_P_PROPS_CORRECT_2_1 as std::os::raw::c_int
            }
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaParseAny:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * Parsea a XML schema <any> element. A particle and wildcard
 * will be created (except if minOccurs==maxOccurs==0, in this case
 * nothing will be created).
 * *WARNING* this interface is highly subject to change
 *
 * Returns the particle or NULL in case of error or if minOccurs==maxOccurs==0
 */
unsafe extern "C" fn xmlSchemaParseAny(mut ctxt: xmlSchemaParserCtxtPtr,
                                       mut schema: xmlSchemaPtr,
                                       mut node: xmlNodePtr)
 -> xmlSchemaParticlePtr {
    let mut particle: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut wild: xmlSchemaWildcardPtr = 0 as *mut xmlSchemaWildcard;
    let mut min: std::os::raw::c_int = 0;
    let mut max: std::os::raw::c_int = 0;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut annot: xmlSchemaAnnotPtr = 0 as xmlSchemaAnnotPtr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaParticlePtr
    }
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"minOccurs\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0
                   &&
                   xmlStrEqual((*attr).name,
                               b"maxOccurs\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0
                   &&
                   xmlStrEqual((*attr).name,
                               b"namespace\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0
                   &&
                   xmlStrEqual((*attr).name,
                               b"processContents\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * minOccurs/maxOccurs.
    */
    max =
        xmlGetMaxOccurs(ctxt, node, 0 as std::os::raw::c_int,
                        (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int,
                        1 as std::os::raw::c_int,
                        b"(xs:nonNegativeInteger | unbounded)\x00" as
                            *const u8 as *const std::os::raw::c_char);
    min =
        xmlGetMinOccurs(ctxt, node, 0 as std::os::raw::c_int, -(1 as std::os::raw::c_int),
                        1 as std::os::raw::c_int,
                        b"xs:nonNegativeInteger\x00" as *const u8 as
                            *const std::os::raw::c_char);
    xmlSchemaPCheckParticleCorrect_2(ctxt, 0 as xmlSchemaParticlePtr, node,
                                     min, max);
    /*
    * Create & parse the wildcard.
    */
    wild = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY, node);
    if wild.is_null() { return 0 as xmlSchemaParticlePtr }
    xmlSchemaParseWildcardNs(ctxt, schema, wild, node);
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        annot = xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    /*
    * No component if minOccurs==maxOccurs==0.
    */
    if min == 0 as std::os::raw::c_int && max == 0 as std::os::raw::c_int {
        /* Don't free the wildcard, since it's already on the list. */
        return 0 as xmlSchemaParticlePtr
    }
    /*
    * Create the particle.
    */
    particle = xmlSchemaAddParticle(ctxt, node, min, max);
    if particle.is_null() { return 0 as xmlSchemaParticlePtr }
    (*particle).annot = annot;
    (*particle).children = wild as xmlSchemaTreeItemPtr;
    return particle;
}
/* *
 * xmlSchemaParseNotation:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Notation declaration
 *
 * Returns the new structure or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaParseNotation(mut ctxt: xmlSchemaParserCtxtPtr,
                                            mut schema: xmlSchemaPtr,
                                            mut node: xmlNodePtr)
 -> xmlSchemaNotationPtr {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlSchemaNotationPtr = 0 as *mut xmlSchemaNotation;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaNotationPtr
    }
    name =
        xmlSchemaGetProp(ctxt, node,
                         b"name\x00" as *const u8 as *const std::os::raw::c_char);
    if name.is_null() {
        xmlSchemaPErr2(ctxt, node, child,
                       XML_SCHEMAP_NOTATION_NO_NAME as std::os::raw::c_int,
                       b"Notation has no name\n\x00" as *const u8 as
                           *const std::os::raw::c_char, 0 as *const xmlChar,
                       0 as *const xmlChar);
        return 0 as xmlSchemaNotationPtr
    }
    ret =
        xmlSchemaAddNotation(ctxt, schema, name, (*ctxt).targetNamespace,
                             node);
    if ret.is_null() { return 0 as xmlSchemaNotationPtr }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*ret).annot =
            xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    return ret;
}
/* *
 * xmlSchemaParseAnyAttribute:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema AnyAttrribute declaration
 * *WARNING* this interface is highly subject to change
 *
 * Returns a wildcard or NULL.
 */
unsafe extern "C" fn xmlSchemaParseAnyAttribute(mut ctxt:
                                                    xmlSchemaParserCtxtPtr,
                                                mut schema: xmlSchemaPtr,
                                                mut node: xmlNodePtr)
 -> xmlSchemaWildcardPtr {
    let mut ret: xmlSchemaWildcardPtr = 0 as *mut xmlSchemaWildcard;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaWildcardPtr
    }
    ret =
        xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
                             node);
    if ret.is_null() { return 0 as xmlSchemaWildcardPtr }
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"namespace\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0
                   &&
                   xmlStrEqual((*attr).name,
                               b"processContents\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * Parse the namespace list.
    */
    if xmlSchemaParseWildcardNs(ctxt, schema, ret, node) != 0 as std::os::raw::c_int {
        return 0 as xmlSchemaWildcardPtr
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*ret).annot =
            xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    return ret;
}
/* *
 * xmlSchemaParseAttribute:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Attrribute declaration
 * *WARNING* this interface is highly subject to change
 *
 * Returns the attribute declaration.
 */
unsafe extern "C" fn xmlSchemaParseLocalAttribute(mut pctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut schema: xmlSchemaPtr,
                                                  mut node: xmlNodePtr,
                                                  mut uses:
                                                      xmlSchemaItemListPtr,
                                                  mut parentType: std::os::raw::c_int)
 -> xmlSchemaBasicItemPtr {
    let mut current_block: u64;
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ns: *const xmlChar = 0 as *const xmlChar;
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut tmpNs: *const xmlChar = 0 as *const xmlChar;
    let mut tmpName: *const xmlChar = 0 as *const xmlChar;
    let mut defValue: *const xmlChar = 0 as *const xmlChar;
    let mut isRef: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut occurs: std::os::raw::c_int = 2 as std::os::raw::c_int;
    let mut nberrors: std::os::raw::c_int = 0;
    let mut hasForm: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut defValueType: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
     * 3.2.3 Constraints on XML Representations of Attribute Declarations
     */
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaBasicItemPtr
    }
    attr =
        xmlSchemaGetPropNode(node,
                             b"ref\x00" as *const u8 as *const std::os::raw::c_char);
    if !attr.is_null() {
        if xmlSchemaPValAttrNodeQName(pctxt, schema,
                                      0 as xmlSchemaBasicItemPtr, attr,
                                      &mut tmpNs, &mut tmpName) !=
               0 as std::os::raw::c_int {
            return 0 as xmlSchemaBasicItemPtr
        }
        if xmlSchemaCheckReference(pctxt, schema, node, attr, tmpNs) !=
               0 as std::os::raw::c_int {
            return 0 as xmlSchemaBasicItemPtr
        }
        isRef = 1 as std::os::raw::c_int
    }
    nberrors = (*pctxt).nberrors;
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if isRef != 0 {
                if xmlStrEqual((*attr).name,
                               b"id\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) != 0 {
                    xmlSchemaPValAttrNodeID(pctxt, attr);
                    current_block = 16681897953743547465;
                } else if xmlStrEqual((*attr).name,
                                      b"ref\x00" as *const u8 as
                                          *const std::os::raw::c_char as *mut xmlChar)
                              != 0 {
                    current_block = 16681897953743547465;
                } else { current_block = 9007357115414505193; }
            } else if xmlStrEqual((*attr).name,
                                  b"name\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                current_block = 16681897953743547465;
            } else if xmlStrEqual((*attr).name,
                                  b"id\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                xmlSchemaPValAttrNodeID(pctxt, attr);
                current_block = 16681897953743547465;
            } else if xmlStrEqual((*attr).name,
                                  b"type\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                xmlSchemaPValAttrNodeQName(pctxt, schema,
                                           0 as xmlSchemaBasicItemPtr, attr,
                                           &mut tmpNs, &mut tmpName);
                current_block = 16681897953743547465;
            } else if xmlStrEqual((*attr).name,
                                  b"form\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                /*
		    * Evaluate the target namespace
		    */
                hasForm = 1 as std::os::raw::c_int;
                attrValue =
                    xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
                if xmlStrEqual(attrValue,
                               b"qualified\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) != 0 {
                    ns = (*pctxt).targetNamespace
                } else if xmlStrEqual(attrValue,
                                      b"unqualified\x00" as *const u8 as
                                          *const std::os::raw::c_char as *mut xmlChar)
                              == 0 {
                    xmlSchemaPSimpleTypeErr(pctxt,
                                            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                            0 as xmlSchemaBasicItemPtr,
                                            attr as xmlNodePtr,
                                            0 as xmlSchemaTypePtr,
                                            b"(qualified | unqualified)\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            attrValue,
                                            0 as *const std::os::raw::c_char,
                                            0 as *const xmlChar,
                                            0 as *const xmlChar);
                }
                current_block = 16681897953743547465;
            } else { current_block = 9007357115414505193; }
            match current_block {
                16681897953743547465 => { }
                _ => {
                    if xmlStrEqual((*attr).name,
                                   b"use\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) !=
                           0 {
                        attrValue =
                            xmlSchemaGetNodeContent(pctxt,
                                                    attr as xmlNodePtr);
                        /* TODO: Maybe we need to normalize the value beforehand. */
                        if xmlStrEqual(attrValue,
                                       b"optional\x00" as *const u8 as
                                           *const std::os::raw::c_char as
                                           *mut xmlChar) != 0 {
                            occurs = 2 as std::os::raw::c_int
                        } else if xmlStrEqual(attrValue,
                                              b"prohibited\x00" as *const u8
                                                  as *const std::os::raw::c_char as
                                                  *mut xmlChar) != 0 {
                            occurs = 0 as std::os::raw::c_int
                        } else if xmlStrEqual(attrValue,
                                              b"required\x00" as *const u8 as
                                                  *const std::os::raw::c_char as
                                                  *mut xmlChar) != 0 {
                            occurs = 1 as std::os::raw::c_int
                        } else {
                            xmlSchemaPSimpleTypeErr(pctxt,
                                                    XML_SCHEMAP_INVALID_ATTR_USE,
                                                    0 as
                                                        xmlSchemaBasicItemPtr,
                                                    attr as xmlNodePtr,
                                                    0 as xmlSchemaTypePtr,
                                                    b"(optional | prohibited | required)\x00"
                                                        as *const u8 as
                                                        *const std::os::raw::c_char,
                                                    attrValue,
                                                    0 as *const std::os::raw::c_char,
                                                    0 as *const xmlChar,
                                                    0 as *const xmlChar);
                        }
                        current_block = 16681897953743547465;
                    } else if xmlStrEqual((*attr).name,
                                          b"default\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *mut xmlChar) != 0 {
                        /*
		* 3.2.3 : 1
		* default and fixed must not both be present.
		*/
                        if !defValue.is_null() {
                            xmlSchemaPMutualExclAttrErr(pctxt,
                                                        XML_SCHEMAP_SRC_ATTRIBUTE_1,
                                                        0 as
                                                            xmlSchemaBasicItemPtr,
                                                        attr,
                                                        b"default\x00" as
                                                            *const u8 as
                                                            *const std::os::raw::c_char,
                                                        b"fixed\x00" as
                                                            *const u8 as
                                                            *const std::os::raw::c_char);
                        } else {
                            defValue =
                                xmlSchemaGetNodeContent(pctxt,
                                                        attr as xmlNodePtr);
                            defValueType = 1 as std::os::raw::c_int
                        }
                        current_block = 16681897953743547465;
                    } else if xmlStrEqual((*attr).name,
                                          b"fixed\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *mut xmlChar) != 0 {
                        /*
		* 3.2.3 : 1
		* default and fixed must not both be present.
		*/
                        if !defValue.is_null() {
                            xmlSchemaPMutualExclAttrErr(pctxt,
                                                        XML_SCHEMAP_SRC_ATTRIBUTE_1,
                                                        0 as
                                                            xmlSchemaBasicItemPtr,
                                                        attr,
                                                        b"default\x00" as
                                                            *const u8 as
                                                            *const std::os::raw::c_char,
                                                        b"fixed\x00" as
                                                            *const u8 as
                                                            *const std::os::raw::c_char);
                        } else {
                            defValue =
                                xmlSchemaGetNodeContent(pctxt,
                                                        attr as xmlNodePtr);
                            defValueType = 2 as std::os::raw::c_int
                        }
                        current_block = 16681897953743547465;
                    } else { current_block = 981995395831942902; }
                }
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) == 0 {
            current_block = 16681897953743547465;
        } else { current_block = 981995395831942902; }
        match current_block {
            981995395831942902 => {
                xmlSchemaPIllegalAttrErr(pctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
            _ => { }
        }
        attr = (*attr).next
    }
    /*
    * 3.2.3 : 2
    * If default and use are both present, use must have
    * the actual value optional.
    */
    if defValueType == 1 as std::os::raw::c_int && occurs != 2 as std::os::raw::c_int {
        xmlSchemaPSimpleTypeErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_2,
                                0 as xmlSchemaBasicItemPtr, node,
                                0 as xmlSchemaTypePtr,
                                b"(optional | prohibited | required)\x00" as
                                    *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar,
                                b"The value of the attribute \'use\' must be \'optional\' if the attribute \'default\' is present\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar, 0 as *const xmlChar);
    }
    /*
    * We want correct attributes.
    */
    if nberrors != (*pctxt).nberrors { return 0 as xmlSchemaBasicItemPtr }
    if isRef == 0 {
        let mut attrDecl: xmlSchemaAttributePtr =
            0 as *mut xmlSchemaAttribute;
        /* TODO: move XML_SCHEMAS_QUALIF_ATTR to the parser. */
        if hasForm == 0 &&
               (*schema).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
            ns = (*pctxt).targetNamespace
        }
        /*
	* 3.2.6 Schema Component Constraint: xsi: Not Allowed
	* TODO: Move this to the component layer.
	*/
        if xmlStrEqual(ns, xmlSchemaInstanceNs) != 0 {
            xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAP_NO_XSI, node,
                               0 as xmlSchemaBasicItemPtr,
                               b"The target namespace must not match \'%s\'\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlSchemaInstanceNs, 0 as *const xmlChar);
        }
        attr =
            xmlSchemaGetPropNode(node,
                                 b"name\x00" as *const u8 as
                                     *const std::os::raw::c_char);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                     0 as xmlSchemaBasicItemPtr, node,
                                     b"name\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     0 as *const std::os::raw::c_char);
            return 0 as xmlSchemaBasicItemPtr
        }
        if xmlSchemaPValAttrNode(pctxt, 0 as xmlSchemaBasicItemPtr, attr,
                                 xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                                 &mut name) != 0 as std::os::raw::c_int {
            return 0 as xmlSchemaBasicItemPtr
        }
        /*
	* 3.2.6 Schema Component Constraint: xmlns Not Allowed
	* TODO: Move this to the component layer.
	*/
        if xmlStrEqual(name,
                       b"xmlns\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
            xmlSchemaPSimpleTypeErr(pctxt, XML_SCHEMAP_NO_XMLNS,
                                    0 as xmlSchemaBasicItemPtr,
                                    attr as xmlNodePtr,
                                    xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                                    0 as *const std::os::raw::c_char,
                                    0 as *const xmlChar,
                                    b"The value of the attribute must not match \'xmlns\'\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    0 as *const xmlChar, 0 as *const xmlChar);
            return 0 as xmlSchemaBasicItemPtr
        }
        if !(occurs == 0 as std::os::raw::c_int) {
            /*
	* Create the attribute use component.
	*/
            use_0 = xmlSchemaAddAttributeUse(pctxt, node);
            if use_0.is_null() { return 0 as xmlSchemaBasicItemPtr }
            (*use_0).occurs = occurs;
            /*
	* Create the attribute declaration.
	*/
            attrDecl =
                xmlSchemaAddAttribute(pctxt, schema, name, ns, node,
                                      0 as std::os::raw::c_int);
            if attrDecl.is_null() { return 0 as xmlSchemaBasicItemPtr }
            if !tmpName.is_null() {
                (*attrDecl).typeName = tmpName;
                (*attrDecl).typeNs = tmpNs
            }
            (*use_0).attrDecl = attrDecl;
            /*
	* Value constraint.
	*/
            if !defValue.is_null() {
                (*attrDecl).defValue = defValue;
                if defValueType == 2 as std::os::raw::c_int {
                    (*attrDecl).flags |=
                        (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int
                }
            }
        }
    } else if occurs != 0 as std::os::raw::c_int {
        let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
        /*
	* Create the attribute use component.
	*/
        use_0 = xmlSchemaAddAttributeUse(pctxt, node);
        if use_0.is_null() { return 0 as xmlSchemaBasicItemPtr }
        /*
	* We need to resolve the reference at later stage.
	*/
        xmlSchemaAddItemSize(&mut (*(*pctxt).constructor).pending,
                             10 as std::os::raw::c_int, use_0 as *mut std::os::raw::c_void);
        (*use_0).occurs = occurs;
        /*
	* Create a QName reference to the attribute declaration.
	*/
        ref_0 =
            xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTE, tmpName,
                                 tmpNs);
        if ref_0.is_null() { return 0 as xmlSchemaBasicItemPtr }
        /*
	* Assign the reference. This will be substituted for the
	* referenced attribute declaration when the QName is resolved.
	*/
        (*use_0).attrDecl = ref_0 as xmlSchemaAttributePtr;
        /*
	* Value constraint.
	*/
        if !defValue.is_null() { (*use_0).defValue = defValue }
        if defValueType == 2 as std::os::raw::c_int {
            (*use_0).flags |= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
        }
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if occurs == 0 as std::os::raw::c_int {
        let mut prohib: xmlSchemaAttributeUseProhibPtr =
            0 as *mut xmlSchemaAttributeUseProhib;
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"annotation\x00" as *const u8 as
                               *const std::os::raw::c_char as *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaParseAnnotation(pctxt, child, 0 as std::os::raw::c_int);
            child = (*child).next
        }
        if !child.is_null() {
            xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation?)\x00" as *const u8 as
                                     *const std::os::raw::c_char);
        }
        /*
	* Check for pointlessness of attribute prohibitions.
	*/
        if parentType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as std::os::raw::c_int {
            xmlSchemaCustomWarning(pctxt as xmlSchemaAbstractCtxtPtr,
                                   XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH, node,
                                   0 as xmlSchemaTypePtr,
                                   b"Skipping attribute use prohibition, since it is pointless inside an <attributeGroup>\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   0 as *const xmlChar, 0 as *const xmlChar,
                                   0 as *const xmlChar);
            return 0 as xmlSchemaBasicItemPtr
        } else {
            if parentType == XML_SCHEMA_TYPE_EXTENSION as std::os::raw::c_int {
                xmlSchemaCustomWarning(pctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                                       node, 0 as xmlSchemaTypePtr,
                                       b"Skipping attribute use prohibition, since it is pointless when extending a type\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       0 as *const xmlChar,
                                       0 as *const xmlChar,
                                       0 as *const xmlChar);
                return 0 as xmlSchemaBasicItemPtr
            }
        }
        if isRef == 0 { tmpName = name; tmpNs = ns }
        /*
	* Check for duplicate attribute prohibitions.
	*/
        if !uses.is_null() {
            let mut i: std::os::raw::c_int = 0;
            i = 0 as std::os::raw::c_int;
            while i < (*uses).nbItems {
                use_0 =
                    *(*uses).items.offset(i as isize) as
                        xmlSchemaAttributeUsePtr;
                if (*use_0).type_0 as std::os::raw::c_uint ==
                       XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as std::os::raw::c_int as
                           std::os::raw::c_uint &&
                       tmpName ==
                           (*(use_0 as xmlSchemaAttributeUseProhibPtr)).name
                       &&
                       tmpNs ==
                           (*(use_0 as
                                  xmlSchemaAttributeUseProhibPtr)).targetNamespace
                   {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomWarning(pctxt as xmlSchemaAbstractCtxtPtr,
                                           XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                                           node, 0 as xmlSchemaTypePtr,
                                           b"Skipping duplicate attribute use prohibition \'%s\'\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlSchemaFormatQName(&mut str,
                                                                tmpNs,
                                                                tmpName),
                                           0 as *const xmlChar,
                                           0 as *const xmlChar);
                    if !str.is_null() {
                        xmlFree.expect("non-null function pointer")(str as
                                                                        *mut std::os::raw::c_void);
                        str = 0 as *mut xmlChar
                    }
                    return 0 as xmlSchemaBasicItemPtr
                }
                i += 1
            }
        }
        /*
	* Create the attribute prohibition helper component.
	*/
        prohib = xmlSchemaAddAttributeUseProhib(pctxt);
        if prohib.is_null() { return 0 as xmlSchemaBasicItemPtr }
        (*prohib).node = node;
        (*prohib).name = tmpName;
        (*prohib).targetNamespace = tmpNs;
        if isRef != 0 {
            /*
	    * We need at least to resolve to the attribute declaration.
	    */
            xmlSchemaAddItemSize(&mut (*(*pctxt).constructor).pending,
                                 10 as std::os::raw::c_int,
                                 prohib as *mut std::os::raw::c_void);
        }
        return prohib as xmlSchemaBasicItemPtr
    } else {
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"annotation\x00" as *const u8 as
                               *const std::os::raw::c_char as *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            /*
	    * TODO: Should this go into the attr decl?
	    */
            (*use_0).annot =
                xmlSchemaParseAnnotation(pctxt, child, 1 as std::os::raw::c_int);
            child = (*child).next
        }
        if isRef != 0 {
            if !child.is_null() {
                if !child.is_null() && !(*child).ns.is_null() &&
                       xmlStrEqual((*child).name,
                                   b"simpleType\x00" as *const u8 as
                                       *const std::os::raw::c_char as *const xmlChar)
                           != 0 &&
                       xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                    /*
		    * 3.2.3 : 3.2
		    * If ref is present, then all of <simpleType>,
		    * form and type must be absent.
		    */
                    xmlSchemaPContentErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_3_2,
                                         0 as xmlSchemaBasicItemPtr, node,
                                         child, 0 as *const std::os::raw::c_char,
                                         b"(annotation?)\x00" as *const u8 as
                                             *const std::os::raw::c_char);
                } else {
                    xmlSchemaPContentErr(pctxt,
                                         XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, node,
                                         child, 0 as *const std::os::raw::c_char,
                                         b"(annotation?)\x00" as *const u8 as
                                             *const std::os::raw::c_char);
                }
            }
        } else {
            if !child.is_null() && !(*child).ns.is_null() &&
                   xmlStrEqual((*child).name,
                               b"simpleType\x00" as *const u8 as
                                   *const std::os::raw::c_char as *const xmlChar) != 0
                   && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                if !(*(*use_0).attrDecl).typeName.is_null() {
                    /*
		    * 3.2.3 : 4
		    * type and <simpleType> must not both be present.
		    */
                    xmlSchemaPContentErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_4,
                                         0 as xmlSchemaBasicItemPtr, node,
                                         child,
                                         b"The attribute \'type\' and the <simpleType> child are mutually exclusive\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char,
                                         0 as *const std::os::raw::c_char);
                } else {
                    (*(*use_0).attrDecl).subtypes =
                        xmlSchemaParseSimpleType(pctxt, schema, child,
                                                 0 as std::os::raw::c_int)
                }
                child = (*child).next
            }
            if !child.is_null() {
                xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, node, child,
                                     0 as *const std::os::raw::c_char,
                                     b"(annotation?, simpleType?)\x00" as
                                         *const u8 as *const std::os::raw::c_char);
            }
        }
    }
    return use_0 as xmlSchemaBasicItemPtr;
}
unsafe extern "C" fn xmlSchemaParseGlobalAttribute(mut pctxt:
                                                       xmlSchemaParserCtxtPtr,
                                                   mut schema: xmlSchemaPtr,
                                                   mut node: xmlNodePtr)
 -> xmlSchemaAttributePtr {
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlSchemaAttributePtr = 0 as *mut xmlSchemaAttribute;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    /*
     * Note that the w3c spec assumes the schema to be validated with schema
     * for schemas beforehand.
     *
     * 3.2.3 Constraints on XML Representations of Attribute Declarations
     */
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaAttributePtr
    }
    /*
    * 3.2.3 : 3.1
    * One of ref or name must be present, but not both
    */
    attr =
        xmlSchemaGetPropNode(node,
                             b"name\x00" as *const u8 as *const std::os::raw::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                 0 as xmlSchemaBasicItemPtr, node,
                                 b"name\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
        return 0 as xmlSchemaAttributePtr
    }
    if xmlSchemaPValAttrNode(pctxt, 0 as xmlSchemaBasicItemPtr, attr,
                             xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                             &mut attrValue) != 0 as std::os::raw::c_int {
        return 0 as xmlSchemaAttributePtr
    }
    /*
    * 3.2.6 Schema Component Constraint: xmlns Not Allowed
    * TODO: Move this to the component layer.
    */
    if xmlStrEqual(attrValue,
                   b"xmlns\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        xmlSchemaPSimpleTypeErr(pctxt, XML_SCHEMAP_NO_XMLNS,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                                0 as *const std::os::raw::c_char, 0 as *const xmlChar,
                                b"The value of the attribute must not match \'xmlns\'\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar, 0 as *const xmlChar);
        return 0 as xmlSchemaAttributePtr
    }
    /*
    * 3.2.6 Schema Component Constraint: xsi: Not Allowed
    * TODO: Move this to the component layer.
    *       Or better leave it here and add it to the component layer
    *       if we have a schema construction API.
    */
    if xmlStrEqual((*pctxt).targetNamespace, xmlSchemaInstanceNs) != 0 {
        xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAP_NO_XSI, node,
                           0 as xmlSchemaBasicItemPtr,
                           b"The target namespace must not match \'%s\'\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlSchemaInstanceNs, 0 as *const xmlChar);
    }
    ret =
        xmlSchemaAddAttribute(pctxt, schema, attrValue,
                              (*pctxt).targetNamespace, node,
                              1 as std::os::raw::c_int);
    if ret.is_null() { return 0 as xmlSchemaAttributePtr }
    (*ret).flags |= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int;
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"default\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0
                   &&
                   xmlStrEqual((*attr).name,
                               b"fixed\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0
                   &&
                   xmlStrEqual((*attr).name,
                               b"name\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"type\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(pctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrQName(pctxt, schema, 0 as xmlSchemaBasicItemPtr, node,
                           b"type\x00" as *const u8 as *const std::os::raw::c_char,
                           &mut (*ret).typeNs, &mut (*ret).typeName);
    xmlSchemaPValAttrID(pctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * Attribute "fixed".
    */
    (*ret).defValue =
        xmlSchemaGetProp(pctxt, node,
                         b"fixed\x00" as *const u8 as *const std::os::raw::c_char);
    if !(*ret).defValue.is_null() {
        (*ret).flags |= (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int
    }
    /*
    * Attribute "default".
    */
    attr =
        xmlSchemaGetPropNode(node,
                             b"default\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    if !attr.is_null() {
        /*
	* 3.2.3 : 1
	* default and fixed must not both be present.
	*/
        if (*ret).flags & (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int != 0 {
            xmlSchemaPMutualExclAttrErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_1,
                                        ret as xmlSchemaBasicItemPtr, attr,
                                        b"default\x00" as *const u8 as
                                            *const std::os::raw::c_char,
                                        b"fixed\x00" as *const u8 as
                                            *const std::os::raw::c_char);
        } else {
            (*ret).defValue =
                xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr)
        }
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*ret).annot =
            xmlSchemaParseAnnotation(pctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"simpleType\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        if !(*ret).typeName.is_null() {
            /*
	    * 3.2.3 : 4
	    * type and <simpleType> must not both be present.
	    */
            xmlSchemaPContentErr(pctxt, XML_SCHEMAP_SRC_ATTRIBUTE_4,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 b"The attribute \'type\' and the <simpleType> child are mutually exclusive\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
        } else {
            (*ret).subtypes =
                xmlSchemaParseSimpleType(pctxt, schema, child,
                                         0 as std::os::raw::c_int)
        }
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, simpleType?)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    return ret;
}
/* *
 * xmlSchemaParseAttributeGroupRef:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * Parse an attribute group definition reference.
 * Note that a reference to an attribute group does not
 * correspond to any component at all.
 * *WARNING* this interface is highly subject to change
 *
 * Returns the attribute group or NULL in case of error.
 */
unsafe extern "C" fn xmlSchemaParseAttributeGroupRef(mut pctxt:
                                                         xmlSchemaParserCtxtPtr,
                                                     mut schema: xmlSchemaPtr,
                                                     mut node: xmlNodePtr)
 -> xmlSchemaQNameRefPtr {
    let mut ret: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut refNs: *const xmlChar = 0 as *const xmlChar;
    let mut ref_0: *const xmlChar = 0 as *const xmlChar;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaQNameRefPtr
    }
    attr =
        xmlSchemaGetPropNode(node,
                             b"ref\x00" as *const u8 as *const std::os::raw::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                 0 as xmlSchemaBasicItemPtr, node,
                                 b"ref\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
        return 0 as xmlSchemaQNameRefPtr
    }
    xmlSchemaPValAttrNodeQName(pctxt, schema, 0 as xmlSchemaBasicItemPtr,
                               attr, &mut refNs, &mut ref_0);
    if xmlSchemaCheckReference(pctxt, schema, node, attr, refNs) !=
           0 as std::os::raw::c_int {
        return 0 as xmlSchemaQNameRefPtr
    }
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"ref\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"id\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(pctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    /* Attribute ID */
    xmlSchemaPValAttrID(pctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* TODO: We do not have a place to store the annotation, do we?
	*/
        xmlSchemaParseAnnotation(pctxt, child, 0 as std::os::raw::c_int);
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    /*
    * Handle attribute group redefinitions.
    */
    if (*pctxt).isRedefine != 0 && !(*pctxt).redef.is_null() &&
           (*(*(*pctxt).redef).item).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_ATTRIBUTEGROUP as std::os::raw::c_int as std::os::raw::c_uint
           && ref_0 == (*(*pctxt).redef).refName &&
           refNs == (*(*pctxt).redef).refTargetNs {
        /*
	* SPEC src-redefine:
	* (7.1) "If it has an <attributeGroup> among its contents
	* the `actual value` of whose ref [attribute] is the same
	* as the `actual value` of its own name attribute plus
	* target namespace, then it must have exactly one such group."
	*/
        if (*pctxt).redefCounter != 0 as std::os::raw::c_int {
            let mut str: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAP_SRC_REDEFINE, node,
                               0 as xmlSchemaBasicItemPtr,
                               b"The redefining attribute group definition \'%s\' must not contain more than one reference to the redefined definition\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlSchemaFormatQName(&mut str, refNs, ref_0),
                               0 as *const xmlChar);
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
            return 0 as xmlSchemaQNameRefPtr
        }
        (*pctxt).redefCounter += 1;
        /*
	* URGENT TODO: How to ensure that the reference will not be
	* handled by the normal component resolution mechanism?
	*/
        ret =
            xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref_0,
                                 refNs);
        if ret.is_null() { return 0 as xmlSchemaQNameRefPtr }
        (*ret).node = node;
        (*(*pctxt).redef).reference = ret as xmlSchemaBasicItemPtr
    } else {
        /*
	* Create a QName-reference helper component. We will substitute this
	* component for the attribute uses of the referenced attribute group
	* definition.
	*/
        ret =
            xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref_0,
                                 refNs);
        if ret.is_null() { return 0 as xmlSchemaQNameRefPtr }
        (*ret).node = node;
        /* Add to pending items, to be able to resolve the reference. */
        xmlSchemaAddItemSize(&mut (*(*pctxt).constructor).pending,
                             10 as std::os::raw::c_int, ret as *mut std::os::raw::c_void);
    }
    return ret;
}
/* *
 * xmlSchemaParseAttributeGroupDefinition:
 * @pctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Attribute Group declaration
 * *WARNING* this interface is highly subject to change
 *
 * Returns the attribute group definition or NULL in case of error.
 */
unsafe extern "C" fn xmlSchemaParseAttributeGroupDefinition(mut pctxt:
                                                                xmlSchemaParserCtxtPtr,
                                                            mut schema:
                                                                xmlSchemaPtr,
                                                            mut node:
                                                                xmlNodePtr)
 -> xmlSchemaAttributeGroupPtr {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlSchemaAttributeGroupPtr =
        0 as *mut xmlSchemaAttributeGroup;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut hasRefs: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr
    }
    attr =
        xmlSchemaGetPropNode(node,
                             b"name\x00" as *const u8 as *const std::os::raw::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                 0 as xmlSchemaBasicItemPtr, node,
                                 b"name\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
        return 0 as xmlSchemaAttributeGroupPtr
    }
    /*
    * The name is crucial, exit if invalid.
    */
    if xmlSchemaPValAttrNode(pctxt, 0 as xmlSchemaBasicItemPtr, attr,
                             xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                             &mut name) != 0 as std::os::raw::c_int {
        return 0 as xmlSchemaAttributeGroupPtr
    }
    ret =
        xmlSchemaAddAttributeGroupDefinition(pctxt, schema, name,
                                             (*pctxt).targetNamespace, node);
    if ret.is_null() { return 0 as xmlSchemaAttributeGroupPtr }
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"name\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"id\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(pctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    /* Attribute ID */
    xmlSchemaPValAttrID(pctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*ret).annot =
            xmlSchemaParseAnnotation(pctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    /*
    * Parse contained attribute decls/refs.
    */
    if xmlSchemaParseLocalAttributes(pctxt, schema, &mut child,
                                     &mut (*ret).attrUses as
                                         *mut *mut std::os::raw::c_void as
                                         *mut xmlSchemaItemListPtr,
                                     XML_SCHEMA_TYPE_ATTRIBUTEGROUP as
                                         std::os::raw::c_int, &mut hasRefs) ==
           -(1 as std::os::raw::c_int) {
        return 0 as xmlSchemaAttributeGroupPtr
    }
    if hasRefs != 0 { (*ret).flags |= (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int }
    /*
    * Parse the attribute wildcard.
    */
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"anyAttribute\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*ret).attributeWildcard =
            xmlSchemaParseAnyAttribute(pctxt, schema, child);
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    return ret;
}
/* *
 * xmlSchemaPValAttrFormDefault:
 * @value:  the value
 * @flags: the flags to be modified
 * @flagQualified: the specific flag for "qualified"
 *
 * Returns 0 if the value is valid, 1 otherwise.
 */
unsafe extern "C" fn xmlSchemaPValAttrFormDefault(mut value: *const xmlChar,
                                                  mut flags: *mut std::os::raw::c_int,
                                                  mut flagQualified:
                                                      std::os::raw::c_int)
 -> std::os::raw::c_int {
    if xmlStrEqual(value,
                   b"qualified\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        if *flags & flagQualified == 0 as std::os::raw::c_int {
            *flags |= flagQualified
        }
    } else if xmlStrEqual(value,
                          b"unqualified\x00" as *const u8 as
                              *const std::os::raw::c_char as *mut xmlChar) == 0 {
        return 1 as std::os::raw::c_int
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaPValAttrBlockFinal:
 * @value:  the value
 * @flags: the flags to be modified
 * @flagAll: the specific flag for "#all"
 * @flagExtension: the specific flag for "extension"
 * @flagRestriction: the specific flag for "restriction"
 * @flagSubstitution: the specific flag for "substitution"
 * @flagList: the specific flag for "list"
 * @flagUnion: the specific flag for "union"
 *
 * Validates the value of the attribute "final" and "block". The value
 * is converted into the specified flag values and returned in @flags.
 *
 * Returns 0 if the value is valid, 1 otherwise.
 */
unsafe extern "C" fn xmlSchemaPValAttrBlockFinal(mut value: *const xmlChar,
                                                 mut flags: *mut std::os::raw::c_int,
                                                 mut flagAll: std::os::raw::c_int,
                                                 mut flagExtension:
                                                     std::os::raw::c_int,
                                                 mut flagRestriction:
                                                     std::os::raw::c_int,
                                                 mut flagSubstitution:
                                                     std::os::raw::c_int,
                                                 mut flagList: std::os::raw::c_int,
                                                 mut flagUnion: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
    * TODO: This does not check for dublicate entries.
    */
    if flags.is_null() || value.is_null() { return -(1 as std::os::raw::c_int) }
    if *value.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
           0 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    if xmlStrEqual(value,
                   b"#all\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        if flagAll != -(1 as std::os::raw::c_int) {
            *flags |= flagAll
        } else {
            if flagExtension != -(1 as std::os::raw::c_int) {
                *flags |= flagExtension
            }
            if flagRestriction != -(1 as std::os::raw::c_int) {
                *flags |= flagRestriction
            }
            if flagSubstitution != -(1 as std::os::raw::c_int) {
                *flags |= flagSubstitution
            }
            if flagList != -(1 as std::os::raw::c_int) { *flags |= flagList }
            if flagUnion != -(1 as std::os::raw::c_int) { *flags |= flagUnion }
        }
    } else {
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut cur: *const xmlChar = value;
        let mut item: *mut xmlChar = 0 as *mut xmlChar;
        loop  {
            while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                      0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                          *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                      *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                cur = cur.offset(1)
            }
            end = cur;
            while *end as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                      !(*end as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                            0x9 as std::os::raw::c_int <= *end as std::os::raw::c_int &&
                                *end as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                            *end as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
                end = end.offset(1)
            }
            if end == cur { break ; }
            item =
                xmlStrndup(cur,
                           end.offset_from(cur) as std::os::raw::c_long as
                               std::os::raw::c_int);
            if xmlStrEqual(item,
                           b"extension\x00" as *const u8 as
                               *const std::os::raw::c_char as *mut xmlChar) != 0 {
                if flagExtension != -(1 as std::os::raw::c_int) {
                    if *flags & flagExtension == 0 as std::os::raw::c_int {
                        *flags |= flagExtension
                    }
                } else { ret = 1 as std::os::raw::c_int }
            } else if xmlStrEqual(item,
                                  b"restriction\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                if flagRestriction != -(1 as std::os::raw::c_int) {
                    if *flags & flagRestriction == 0 as std::os::raw::c_int {
                        *flags |= flagRestriction
                    }
                } else { ret = 1 as std::os::raw::c_int }
            } else if xmlStrEqual(item,
                                  b"substitution\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                if flagSubstitution != -(1 as std::os::raw::c_int) {
                    if *flags & flagSubstitution == 0 as std::os::raw::c_int {
                        *flags |= flagSubstitution
                    }
                } else { ret = 1 as std::os::raw::c_int }
            } else if xmlStrEqual(item,
                                  b"list\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                if flagList != -(1 as std::os::raw::c_int) {
                    if *flags & flagList == 0 as std::os::raw::c_int {
                        *flags |= flagList
                    }
                } else { ret = 1 as std::os::raw::c_int }
            } else if xmlStrEqual(item,
                                  b"union\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                if flagUnion != -(1 as std::os::raw::c_int) {
                    if *flags & flagUnion == 0 as std::os::raw::c_int {
                        *flags |= flagUnion
                    }
                } else { ret = 1 as std::os::raw::c_int }
            } else { ret = 1 as std::os::raw::c_int }
            if !item.is_null() {
                xmlFree.expect("non-null function pointer")(item as
                                                                *mut std::os::raw::c_void);
            }
            cur = end;
            if !(ret == 0 as std::os::raw::c_int &&
                     *cur as std::os::raw::c_int != 0 as std::os::raw::c_int) {
                break ;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckCSelectorXPath(mut ctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut idc: xmlSchemaIDCPtr,
                                                  mut selector:
                                                      xmlSchemaIDCSelectPtr,
                                                  mut attr: xmlAttrPtr,
                                                  mut isField: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    /*
    * c-selector-xpath:
    * Schema Component Constraint: Selector Value OK
    *
    * TODO: 1 The {selector} must be a valid XPath expression, as defined
    * in [XPath].
    */
    if selector.is_null() {
        xmlSchemaPErr(ctxt, (*idc).node, XML_SCHEMAP_INTERNAL as std::os::raw::c_int,
                      b"Internal error: xmlSchemaCheckCSelectorXPath, the selector is not specified.\n\x00"
                          as *const u8 as *const std::os::raw::c_char,
                      0 as *const xmlChar, 0 as *const xmlChar);
        return -(1 as std::os::raw::c_int)
    }
    if attr.is_null() {
        node = (*idc).node
    } else { node = attr as xmlNodePtr }
    if (*selector).xpath.is_null() {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                            0 as xmlSchemaBasicItemPtr, node,
                            b"The XPath expression of the selector is not valid\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
        return XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as std::os::raw::c_int
    } else {
        let mut nsArray: *mut *const xmlChar = 0 as *mut *const xmlChar;
        let mut nsList: *mut xmlNsPtr = 0 as *mut xmlNsPtr;
        /*
	* Compile the XPath expression.
	*/
	/*
	* TODO: We need the array of in-scope namespaces for compilation.
	* TODO: Call xmlPatterncompile with different options for selector/
	* field.
	*/
        if attr.is_null() {
            nsList = 0 as *mut xmlNsPtr
        } else { nsList = xmlGetNsList((*attr).doc, (*attr).parent) }
        /*
	* Build an array of prefixes and namespaces.
	*/
        if !nsList.is_null() {
            let mut i: std::os::raw::c_int = 0;
            let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
            i = 0 as std::os::raw::c_int;
            while !(*nsList.offset(i as isize)).is_null() {
                count += 1;
                i += 1
            }
            nsArray =
                xmlMalloc.expect("non-null function pointer")(((count *
                                                                    2 as
                                                                        std::os::raw::c_int
                                                                    +
                                                                    1 as
                                                                        std::os::raw::c_int)
                                                                   as
                                                                   std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                   as
                                                                                                   std::os::raw::c_ulong))
                    as *mut *const xmlChar;
            if nsArray.is_null() {
                xmlSchemaPErrMemory(ctxt,
                                    b"allocating a namespace array\x00" as
                                        *const u8 as *const std::os::raw::c_char,
                                    0 as xmlNodePtr);
                xmlFree.expect("non-null function pointer")(nsList as
                                                                *mut std::os::raw::c_void);
                return -(1 as std::os::raw::c_int)
            }
            i = 0 as std::os::raw::c_int;
            while i < count {
                let ref mut fresh14 =
                    *nsArray.offset((2 as std::os::raw::c_int * i) as isize);
                *fresh14 = (**nsList.offset(i as isize)).href;
                let ref mut fresh15 =
                    *nsArray.offset((2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int)
                                        as isize);
                *fresh15 = (**nsList.offset(i as isize)).prefix;
                i += 1
            }
            let ref mut fresh16 =
                *nsArray.offset((count * 2 as std::os::raw::c_int) as isize);
            *fresh16 = 0 as *const xmlChar;
            xmlFree.expect("non-null function pointer")(nsList as
                                                            *mut std::os::raw::c_void);
        }
        /*
	* TODO: Differentiate between "selector" and "field".
	*/
        if isField != 0 {
            (*selector).xpathComp =
                xmlPatterncompile((*selector).xpath, 0 as *mut xmlDict,
                                  XML_PATTERN_XSFIELD as std::os::raw::c_int, nsArray)
                    as *mut std::os::raw::c_void
        } else {
            (*selector).xpathComp =
                xmlPatterncompile((*selector).xpath, 0 as *mut xmlDict,
                                  XML_PATTERN_XSSEL as std::os::raw::c_int, nsArray)
                    as *mut std::os::raw::c_void
        }
        if !nsArray.is_null() {
            xmlFree.expect("non-null function pointer")(nsArray as
                                                            *mut *mut xmlChar
                                                            as
                                                            *mut std::os::raw::c_void);
        }
        if (*selector).xpathComp.is_null() {
            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr, node,
                                b"The XPath expression \'%s\' could not be compiled\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                (*selector).xpath);
            return XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as std::os::raw::c_int
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaAssignAnnotation:
 * @item: the schema component
 * @annot: the annotation
 *
 * Adds the annotation to the given schema component.
 *
 * Returns the given annotaion.
 */
unsafe extern "C" fn xmlSchemaAddAnnotation(mut annItem:
                                                xmlSchemaAnnotItemPtr,
                                            mut annot: xmlSchemaAnnotPtr)
 -> xmlSchemaAnnotPtr {
    if annItem.is_null() || annot.is_null() { return 0 as xmlSchemaAnnotPtr }
    match (*annItem).type_0 as std::os::raw::c_uint {
        14 => {
            let mut item: xmlSchemaElementPtr =
                annItem as xmlSchemaElementPtr;
            let mut cur: xmlSchemaAnnotPtr = (*item).annot;
            if (*item).annot.is_null() { (*item).annot = annot; return annot }
            cur = (*item).annot;
            if !(*cur).next.is_null() { cur = (*cur).next }
            (*cur).next = annot
        }
        15 => {
            let mut item_0: xmlSchemaAttributePtr =
                annItem as xmlSchemaAttributePtr;
            let mut cur_0: xmlSchemaAnnotPtr = (*item_0).annot;
            if (*item_0).annot.is_null() {
                (*item_0).annot = annot;
                return annot
            }
            cur_0 = (*item_0).annot;
            if !(*cur_0).next.is_null() { cur_0 = (*cur_0).next }
            (*cur_0).next = annot
        }
        21 | 2 => {
            let mut item_1: xmlSchemaWildcardPtr =
                annItem as xmlSchemaWildcardPtr;
            let mut cur_1: xmlSchemaAnnotPtr = (*item_1).annot;
            if (*item_1).annot.is_null() {
                (*item_1).annot = annot;
                return annot
            }
            cur_1 = (*item_1).annot;
            if !(*cur_1).next.is_null() { cur_1 = (*cur_1).next }
            (*cur_1).next = annot
        }
        25 | 23 | 24 | 22 => {
            let mut item_2: xmlSchemaAnnotItemPtr = annItem;
            let mut cur_2: xmlSchemaAnnotPtr = (*item_2).annot;
            if (*item_2).annot.is_null() {
                (*item_2).annot = annot;
                return annot
            }
            cur_2 = (*item_2).annot;
            if !(*cur_2).next.is_null() { cur_2 = (*cur_2).next }
            (*cur_2).next = annot
        }
        16 => {
            let mut item_3: xmlSchemaAttributeGroupPtr =
                annItem as xmlSchemaAttributeGroupPtr;
            let mut cur_3: xmlSchemaAnnotPtr = (*item_3).annot;
            if (*item_3).annot.is_null() {
                (*item_3).annot = annot;
                return annot
            }
            cur_3 = (*item_3).annot;
            if !(*cur_3).next.is_null() { cur_3 = (*cur_3).next }
            (*cur_3).next = annot
        }
        18 => {
            let mut item_4: xmlSchemaNotationPtr =
                annItem as xmlSchemaNotationPtr;
            let mut cur_4: xmlSchemaAnnotPtr = (*item_4).annot;
            if (*item_4).annot.is_null() {
                (*item_4).annot = annot;
                return annot
            }
            cur_4 = (*item_4).annot;
            if !(*cur_4).next.is_null() { cur_4 = (*cur_4).next }
            (*cur_4).next = annot
        }
        1000 | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 | 1007 | 1008 | 1009 |
        1010 | 1011 => {
            let mut item_5: xmlSchemaFacetPtr = annItem as xmlSchemaFacetPtr;
            let mut cur_5: xmlSchemaAnnotPtr = (*item_5).annot;
            if (*item_5).annot.is_null() {
                (*item_5).annot = annot;
                return annot
            }
            cur_5 = (*item_5).annot;
            if !(*cur_5).next.is_null() { cur_5 = (*cur_5).next }
            (*cur_5).next = annot
        }
        4 | 5 => {
            let mut item_6: xmlSchemaTypePtr = annItem as xmlSchemaTypePtr;
            let mut cur_6: xmlSchemaAnnotPtr = (*item_6).annot;
            if (*item_6).annot.is_null() {
                (*item_6).annot = annot;
                return annot
            }
            cur_6 = (*item_6).annot;
            if !(*cur_6).next.is_null() { cur_6 = (*cur_6).next }
            (*cur_6).next = annot
        }
        17 => {
            let mut item_7: xmlSchemaModelGroupDefPtr =
                annItem as xmlSchemaModelGroupDefPtr;
            let mut cur_7: xmlSchemaAnnotPtr = (*item_7).annot;
            if (*item_7).annot.is_null() {
                (*item_7).annot = annot;
                return annot
            }
            cur_7 = (*item_7).annot;
            if !(*cur_7).next.is_null() { cur_7 = (*cur_7).next }
            (*cur_7).next = annot
        }
        6 | 7 | 8 => {
            let mut item_8: xmlSchemaModelGroupPtr =
                annItem as xmlSchemaModelGroupPtr;
            let mut cur_8: xmlSchemaAnnotPtr = (*item_8).annot;
            if (*item_8).annot.is_null() {
                (*item_8).annot = annot;
                return annot
            }
            cur_8 = (*item_8).annot;
            if !(*cur_8).next.is_null() { cur_8 = (*cur_8).next }
            (*cur_8).next = annot
        }
        _ => {
            xmlSchemaPCustomErr(0 as xmlSchemaParserCtxtPtr,
                                XML_SCHEMAP_INTERNAL,
                                0 as xmlSchemaBasicItemPtr, 0 as xmlNodePtr,
                                b"Internal error: xmlSchemaAddAnnotation, The item is not a annotated schema component\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar);
        }
    }
    return annot;
}
/* *
 * xmlSchemaParseIDCSelectorAndField:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * Parses a XML Schema identity-contraint definition's
 * <selector> and <field> elements.
 *
 * Returns the parsed identity-constraint definition.
 */
unsafe extern "C" fn xmlSchemaParseIDCSelectorAndField(mut ctxt:
                                                           xmlSchemaParserCtxtPtr,
                                                       mut idc:
                                                           xmlSchemaIDCPtr,
                                                       mut node: xmlNodePtr,
                                                       mut isField:
                                                           std::os::raw::c_int)
 -> xmlSchemaIDCSelectPtr {
    let mut item: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"xpath\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    /*
    * Create the item.
    */
    item =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaIDCSelect>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaIDCSelectPtr;
    if item.is_null() {
        xmlSchemaPErrMemory(ctxt,
                            b"allocating a \'selector\' of an identity-constraint definition\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaIDCSelectPtr
    }
    memset(item as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaIDCSelect>() as std::os::raw::c_ulong);
    /*
    * Attribute "xpath" (mandatory).
    */
    attr =
        xmlSchemaGetPropNode(node,
                             b"xpath\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                 0 as xmlSchemaBasicItemPtr, node,
                                 b"name\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
    } else {
        (*item).xpath = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
        /*
	* URGENT TODO: "field"s have an other syntax than "selector"s.
	*/
        if xmlSchemaCheckCSelectorXPath(ctxt, idc, item, attr, isField) ==
               -(1 as std::os::raw::c_int) {
            xmlSchemaPErr(ctxt, attr as xmlNodePtr,
                          XML_SCHEMAP_INTERNAL as std::os::raw::c_int,
                          b"Internal error: xmlSchemaParseIDCSelectorAndField, validating the XPath expression of a IDC selector.\n\x00"
                              as *const u8 as *const std::os::raw::c_char,
                          0 as *const xmlChar, 0 as *const xmlChar);
        }
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* Add the annotation to the parent IDC.
	*/
        xmlSchemaAddAnnotation(idc as xmlSchemaAnnotItemPtr,
                               xmlSchemaParseAnnotation(ctxt, child,
                                                        1 as std::os::raw::c_int));
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    return item;
}
/* *
 * xmlSchemaParseIDC:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * Parses a XML Schema identity-contraint definition.
 *
 * Returns the parsed identity-constraint definition.
 */
unsafe extern "C" fn xmlSchemaParseIDC(mut ctxt: xmlSchemaParserCtxtPtr,
                                       mut schema: xmlSchemaPtr,
                                       mut node: xmlNodePtr,
                                       mut idcCategory: xmlSchemaTypeType,
                                       mut targetNamespace: *const xmlChar)
 -> xmlSchemaIDCPtr {
    let mut item: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut field: xmlSchemaIDCSelectPtr = 0 as xmlSchemaIDCSelectPtr;
    let mut lastField: xmlSchemaIDCSelectPtr = 0 as xmlSchemaIDCSelectPtr;
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"name\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 &&
                   (idcCategory as std::os::raw::c_uint !=
                        XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int as
                            std::os::raw::c_uint ||
                        xmlStrEqual((*attr).name,
                                    b"refer\x00" as *const u8 as
                                        *const std::os::raw::c_char as *mut xmlChar)
                            == 0) {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    /*
    * Attribute "name" (mandatory).
    */
    attr =
        xmlSchemaGetPropNode(node,
                             b"name\x00" as *const u8 as *const std::os::raw::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                 0 as xmlSchemaBasicItemPtr, node,
                                 b"name\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
        return 0 as xmlSchemaIDCPtr
    } else {
        if xmlSchemaPValAttrNode(ctxt, 0 as xmlSchemaBasicItemPtr, attr,
                                 xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                                 &mut name) != 0 as std::os::raw::c_int {
            return 0 as xmlSchemaIDCPtr
        }
    }
    /* Create the component. */
    item =
        xmlSchemaAddIDC(ctxt, schema, name, targetNamespace,
                        idcCategory as std::os::raw::c_int, node);
    if item.is_null() { return 0 as xmlSchemaIDCPtr }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    if idcCategory as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int as std::os::raw::c_uint {
        /*
	* Attribute "refer" (mandatory).
	*/
        attr =
            xmlSchemaGetPropNode(node,
                                 b"refer\x00" as *const u8 as
                                     *const std::os::raw::c_char);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                     0 as xmlSchemaBasicItemPtr, node,
                                     b"refer\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     0 as *const std::os::raw::c_char);
        } else {
            /*
	    * Create a reference item.
	    */
            (*item).ref_0 =
                xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_IDC_KEY,
                                     0 as *const xmlChar,
                                     0 as *const xmlChar);
            if (*item).ref_0.is_null() { return 0 as xmlSchemaIDCPtr }
            xmlSchemaPValAttrNodeQName(ctxt, schema,
                                       0 as xmlSchemaBasicItemPtr, attr,
                                       &mut (*(*item).ref_0).targetNamespace,
                                       &mut (*(*item).ref_0).name);
            xmlSchemaCheckReference(ctxt, schema, node, attr,
                                    (*(*item).ref_0).targetNamespace);
        }
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*item).annot =
            xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_MISSING,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             b"A child element is missing\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"(annotation?, (selector, field+))\x00" as
                                 *const u8 as *const std::os::raw::c_char);
    }
    /*
    * Child element <selector>.
    */
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"selector\x00" as *const u8 as *const std::os::raw::c_char as
                           *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*item).selector =
            xmlSchemaParseIDCSelectorAndField(ctxt, item, child,
                                              0 as std::os::raw::c_int);
        child = (*child).next;
        /*
	* Child elements <field>.
	*/
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"field\x00" as *const u8 as *const std::os::raw::c_char as
                               *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            loop  {
                field =
                    xmlSchemaParseIDCSelectorAndField(ctxt, item, child,
                                                      1 as std::os::raw::c_int);
                if !field.is_null() {
                    (*field).index = (*item).nbFields;
                    (*item).nbFields += 1;
                    if !lastField.is_null() {
                        (*lastField).next = field
                    } else { (*item).fields = field }
                    lastField = field
                }
                child = (*child).next;
                if !(!child.is_null() && !(*child).ns.is_null() &&
                         xmlStrEqual((*child).name,
                                     b"field\x00" as *const u8 as
                                         *const std::os::raw::c_char as
                                         *const xmlChar) != 0 &&
                         xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0) {
                    break ;
                }
            }
        } else {
            xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation?, (selector, field+))\x00" as
                                     *const u8 as *const std::os::raw::c_char);
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, (selector, field+))\x00" as
                                 *const u8 as *const std::os::raw::c_char);
    }
    return item;
}
/* *
 * xmlSchemaParseElement:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 * @topLevel: indicates if this is global declaration
 *
 * Parses a XML schema element declaration.
 * *WARNING* this interface is highly subject to change
 *
 * Returns the element declaration or a particle; NULL in case
 * of an error or if the particle has minOccurs==maxOccurs==0.
 */
unsafe extern "C" fn xmlSchemaParseElement(mut ctxt: xmlSchemaParserCtxtPtr,
                                           mut schema: xmlSchemaPtr,
                                           mut node: xmlNodePtr,
                                           mut isElemRef: *mut std::os::raw::c_int,
                                           mut topLevel: std::os::raw::c_int)
 -> xmlSchemaBasicItemPtr {
    let mut current_block: u64;
    let mut decl: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    let mut particle: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
    let mut annot: xmlSchemaAnnotPtr = 0 as xmlSchemaAnnotPtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut nameAttr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut min: std::os::raw::c_int = 0;
    let mut max: std::os::raw::c_int = 0;
    let mut isRef: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    /* 3.3.3 Constraints on XML Representations of Element Declarations */
    /* TODO: Complete implementation of 3.3.6 */
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaBasicItemPtr
    }
    if !isElemRef.is_null() { *isElemRef = 0 as std::os::raw::c_int }
    /*
    * If we get a "ref" attribute on a local <element> we will assume it's
    * a reference - even if there's a "name" attribute; this seems to be more
    * robust.
    */
    nameAttr =
        xmlSchemaGetPropNode(node,
                             b"name\x00" as *const u8 as *const std::os::raw::c_char);
    attr =
        xmlSchemaGetPropNode(node,
                             b"ref\x00" as *const u8 as *const std::os::raw::c_char);
    if topLevel != 0 || attr.is_null() {
        if nameAttr.is_null() {
            xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                     0 as xmlSchemaBasicItemPtr, node,
                                     b"name\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     0 as *const std::os::raw::c_char);
            return 0 as xmlSchemaBasicItemPtr
        }
    } else { isRef = 1 as std::os::raw::c_int }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        annot = xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    /*
    * Skip particle part if a global declaration.
    */
    if topLevel != 0 {
        current_block = 10380409671385728102;
    } else {
        /*
    * The particle part ==================================================
    */
        min =
            xmlGetMinOccurs(ctxt, node, 0 as std::os::raw::c_int, -(1 as std::os::raw::c_int),
                            1 as std::os::raw::c_int,
                            b"xs:nonNegativeInteger\x00" as *const u8 as
                                *const std::os::raw::c_char);
        max =
            xmlGetMaxOccurs(ctxt, node, 0 as std::os::raw::c_int,
                            (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int,
                            1 as std::os::raw::c_int,
                            b"(xs:nonNegativeInteger | unbounded)\x00" as
                                *const u8 as *const std::os::raw::c_char);
        xmlSchemaPCheckParticleCorrect_2(ctxt, 0 as xmlSchemaParticlePtr,
                                         node, min, max);
        particle = xmlSchemaAddParticle(ctxt, node, min, max);
        if particle.is_null() {
            current_block = 5848473817914411189;
        } else if isRef != 0 {
            let mut refNs: *const xmlChar = 0 as *const xmlChar;
            let mut ref_0: *const xmlChar = 0 as *const xmlChar;
            let mut refer: xmlSchemaQNameRefPtr = 0 as xmlSchemaQNameRefPtr;
            /* ret->flags |= XML_SCHEMAS_ELEM_REF; */
            /*
	* The reference part =============================================
	*/
            if !isElemRef.is_null() { *isElemRef = 1 as std::os::raw::c_int }
            xmlSchemaPValAttrNodeQName(ctxt, schema,
                                       0 as xmlSchemaBasicItemPtr, attr,
                                       &mut refNs, &mut ref_0);
            xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
            /*
	* SPEC (3.3.3 : 2.1) "One of ref or name must be present, but not both"
	*/
            if !nameAttr.is_null() {
                xmlSchemaPMutualExclAttrErr(ctxt, XML_SCHEMAP_SRC_ELEMENT_2_1,
                                            0 as xmlSchemaBasicItemPtr,
                                            nameAttr,
                                            b"ref\x00" as *const u8 as
                                                *const std::os::raw::c_char,
                                            b"name\x00" as *const u8 as
                                                *const std::os::raw::c_char);
            }
            /*
	* Check for illegal attributes.
	*/
            attr = (*node).properties;
            while !attr.is_null() {
                if (*attr).ns.is_null() {
                    if xmlStrEqual((*attr).name,
                                   b"ref\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) !=
                           0 ||
                           xmlStrEqual((*attr).name,
                                       b"name\x00" as *const u8 as
                                           *const std::os::raw::c_char as
                                           *mut xmlChar) != 0 ||
                           xmlStrEqual((*attr).name,
                                       b"id\x00" as *const u8 as
                                           *const std::os::raw::c_char as
                                           *mut xmlChar) != 0 ||
                           xmlStrEqual((*attr).name,
                                       b"maxOccurs\x00" as *const u8 as
                                           *const std::os::raw::c_char as
                                           *mut xmlChar) != 0 ||
                           xmlStrEqual((*attr).name,
                                       b"minOccurs\x00" as *const u8 as
                                           *const std::os::raw::c_char as
                                           *mut xmlChar) != 0 {
                        attr = (*attr).next
                    } else {
                        /* SPEC (3.3.3 : 2.2) */
                        xmlSchemaPCustomAttrErr(ctxt,
                                                XML_SCHEMAP_SRC_ELEMENT_2_2,
                                                0 as *mut *mut xmlChar,
                                                0 as xmlSchemaBasicItemPtr,
                                                attr,
                                                b"Only the attributes \'minOccurs\', \'maxOccurs\' and \'id\' are allowed in addition to \'ref\'\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char);
                        break ;
                    }
                } else {
                    if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                        xmlSchemaPIllegalAttrErr(ctxt,
                                                 XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                                 0 as xmlSchemaBasicItemPtr,
                                                 attr);
                    }
                    attr = (*attr).next
                }
            }
            /*
	* No children except <annotation> expected.
	*/
            if !child.is_null() {
                xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, node, child,
                                     0 as *const std::os::raw::c_char,
                                     b"(annotation?)\x00" as *const u8 as
                                         *const std::os::raw::c_char);
            }
            if min == 0 as std::os::raw::c_int && max == 0 as std::os::raw::c_int {
                current_block = 5848473817914411189;
            } else {
                /*
	* Create the reference item and attach it to the particle.
	*/
                refer =
                    xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_ELEMENT, ref_0,
                                         refNs);
                if refer.is_null() {
                    current_block = 5848473817914411189;
                } else {
                    (*particle).children = refer as xmlSchemaTreeItemPtr;
                    (*particle).annot = annot;
                    /*
	* Add the particle to pending components, since the reference
	* need to be resolved.
	*/
                    xmlSchemaAddItemSize(&mut (*(*ctxt).constructor).pending,
                                         10 as std::os::raw::c_int,
                                         particle as *mut std::os::raw::c_void);
                    return particle as xmlSchemaBasicItemPtr
                }
            }
        } else { current_block = 10380409671385728102; }
    }
    match current_block {
        10380409671385728102 =>
        /*
    * The declaration part ===============================================
    */
        {
            let mut ns: *const xmlChar = 0 as *const xmlChar;
            let mut fixed: *const xmlChar = 0 as *const xmlChar;
            let mut name: *const xmlChar = 0 as *const xmlChar;
            let mut attrValue: *const xmlChar = 0 as *const xmlChar;
            let mut curIDC: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
            let mut lastIDC: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
            if !(xmlSchemaPValAttrNode(ctxt, 0 as xmlSchemaBasicItemPtr,
                                       nameAttr,
                                       xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                                       &mut name) != 0 as std::os::raw::c_int) {
                /*
	* Evaluate the target namespace.
	*/
                if topLevel != 0 {
                    ns = (*ctxt).targetNamespace
                } else {
                    attr =
                        xmlSchemaGetPropNode(node,
                                             b"form\x00" as *const u8 as
                                                 *const std::os::raw::c_char);
                    if !attr.is_null() {
                        attrValue =
                            xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlStrEqual(attrValue,
                                       b"qualified\x00" as *const u8 as
                                           *const std::os::raw::c_char as
                                           *mut xmlChar) != 0 {
                            ns = (*ctxt).targetNamespace
                        } else if xmlStrEqual(attrValue,
                                              b"unqualified\x00" as *const u8
                                                  as *const std::os::raw::c_char as
                                                  *mut xmlChar) == 0 {
                            xmlSchemaPSimpleTypeErr(ctxt,
                                                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                    0 as
                                                        xmlSchemaBasicItemPtr,
                                                    attr as xmlNodePtr,
                                                    0 as xmlSchemaTypePtr,
                                                    b"(qualified | unqualified)\x00"
                                                        as *const u8 as
                                                        *const std::os::raw::c_char,
                                                    attrValue,
                                                    0 as *const std::os::raw::c_char,
                                                    0 as *const xmlChar,
                                                    0 as *const xmlChar);
                        }
                    } else if (*schema).flags &
                                  (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0
                     {
                        ns = (*ctxt).targetNamespace
                    }
                }
                decl = xmlSchemaAddElement(ctxt, name, ns, node, topLevel);
                if !decl.is_null() {
                    /*
	* Check for illegal attributes.
	*/
                    attr = (*node).properties;
                    while !attr.is_null() {
                        if (*attr).ns.is_null() {
                            if xmlStrEqual((*attr).name,
                                           b"name\x00" as *const u8 as
                                               *const std::os::raw::c_char as
                                               *mut xmlChar) == 0 &&
                                   xmlStrEqual((*attr).name,
                                               b"type\x00" as *const u8 as
                                                   *const std::os::raw::c_char as
                                                   *mut xmlChar) == 0 &&
                                   xmlStrEqual((*attr).name,
                                               b"id\x00" as *const u8 as
                                                   *const std::os::raw::c_char as
                                                   *mut xmlChar) == 0 &&
                                   xmlStrEqual((*attr).name,
                                               b"default\x00" as *const u8 as
                                                   *const std::os::raw::c_char as
                                                   *mut xmlChar) == 0 &&
                                   xmlStrEqual((*attr).name,
                                               b"fixed\x00" as *const u8 as
                                                   *const std::os::raw::c_char as
                                                   *mut xmlChar) == 0 &&
                                   xmlStrEqual((*attr).name,
                                               b"block\x00" as *const u8 as
                                                   *const std::os::raw::c_char as
                                                   *mut xmlChar) == 0 &&
                                   xmlStrEqual((*attr).name,
                                               b"nillable\x00" as *const u8 as
                                                   *const std::os::raw::c_char as
                                                   *mut xmlChar) == 0 {
                                if topLevel == 0 as std::os::raw::c_int {
                                    if xmlStrEqual((*attr).name,
                                                   b"maxOccurs\x00" as
                                                       *const u8 as
                                                       *const std::os::raw::c_char as
                                                       *mut xmlChar) == 0 &&
                                           xmlStrEqual((*attr).name,
                                                       b"minOccurs\x00" as
                                                           *const u8 as
                                                           *const std::os::raw::c_char
                                                           as *mut xmlChar) ==
                                               0 &&
                                           xmlStrEqual((*attr).name,
                                                       b"form\x00" as
                                                           *const u8 as
                                                           *const std::os::raw::c_char
                                                           as *mut xmlChar) ==
                                               0 {
                                        xmlSchemaPIllegalAttrErr(ctxt,
                                                                 XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                                                 0 as
                                                                     xmlSchemaBasicItemPtr,
                                                                 attr);
                                    }
                                } else if xmlStrEqual((*attr).name,
                                                      b"final\x00" as
                                                          *const u8 as
                                                          *const std::os::raw::c_char
                                                          as *mut xmlChar) ==
                                              0 &&
                                              xmlStrEqual((*attr).name,
                                                          b"abstract\x00" as
                                                              *const u8 as
                                                              *const std::os::raw::c_char
                                                              as *mut xmlChar)
                                                  == 0 &&
                                              xmlStrEqual((*attr).name,
                                                          b"substitutionGroup\x00"
                                                              as *const u8 as
                                                              *const std::os::raw::c_char
                                                              as *mut xmlChar)
                                                  == 0 {
                                    xmlSchemaPIllegalAttrErr(ctxt,
                                                             XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                                             0 as
                                                                 xmlSchemaBasicItemPtr,
                                                             attr);
                                }
                            }
                        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs)
                                      != 0 {
                            xmlSchemaPIllegalAttrErr(ctxt,
                                                     XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                                     0 as
                                                         xmlSchemaBasicItemPtr,
                                                     attr);
                        }
                        attr = (*attr).next
                    }
                    /*
	* Extract/validate attributes.
	*/
                    if topLevel != 0 {
                        /*
	    * Process top attributes of global element declarations here.
	    */
                        (*decl).flags |=
                            (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int;
                        (*decl).flags |=
                            (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int;
                        xmlSchemaPValAttrQName(ctxt, schema,
                                               0 as xmlSchemaBasicItemPtr,
                                               node,
                                               b"substitutionGroup\x00" as
                                                   *const u8 as
                                                   *const std::os::raw::c_char,
                                               &mut (*decl).substGroupNs,
                                               &mut (*decl).substGroup);
                        if xmlGetBooleanProp(ctxt, node,
                                             b"abstract\x00" as *const u8 as
                                                 *const std::os::raw::c_char,
                                             0 as std::os::raw::c_int) != 0 {
                            (*decl).flags |=
                                (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int
                        }
                        /*
	    * Attribute "final".
	    */
                        attr =
                            xmlSchemaGetPropNode(node,
                                                 b"final\x00" as *const u8 as
                                                     *const std::os::raw::c_char);
                        if attr.is_null() {
                            if (*schema).flags &
                                   (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0
                               {
                                (*decl).flags |=
                                    (1 as std::os::raw::c_int) << 15 as std::os::raw::c_int
                            }
                            if (*schema).flags &
                                   (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0
                               {
                                (*decl).flags |=
                                    (1 as std::os::raw::c_int) << 16 as std::os::raw::c_int
                            }
                        } else {
                            attrValue =
                                xmlSchemaGetNodeContent(ctxt,
                                                        attr as xmlNodePtr);
                            if xmlSchemaPValAttrBlockFinal(attrValue,
                                                           &mut (*decl).flags,
                                                           -(1 as
                                                                 std::os::raw::c_int),
                                                           (1 as std::os::raw::c_int)
                                                               <<
                                                               15 as
                                                                   std::os::raw::c_int,
                                                           (1 as std::os::raw::c_int)
                                                               <<
                                                               16 as
                                                                   std::os::raw::c_int,
                                                           -(1 as
                                                                 std::os::raw::c_int),
                                                           -(1 as
                                                                 std::os::raw::c_int),
                                                           -(1 as
                                                                 std::os::raw::c_int))
                                   != 0 as std::os::raw::c_int {
                                xmlSchemaPSimpleTypeErr(ctxt,
                                                        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                        0 as
                                                            xmlSchemaBasicItemPtr,
                                                        attr as xmlNodePtr,
                                                        0 as xmlSchemaTypePtr,
                                                        b"(#all | List of (extension | restriction))\x00"
                                                            as *const u8 as
                                                            *const std::os::raw::c_char,
                                                        attrValue,
                                                        0 as
                                                            *const std::os::raw::c_char,
                                                        0 as *const xmlChar,
                                                        0 as *const xmlChar);
                            }
                        }
                    }
                    /*
	* Attribute "block".
	*/
                    attr =
                        xmlSchemaGetPropNode(node,
                                             b"block\x00" as *const u8 as
                                                 *const std::os::raw::c_char);
                    if attr.is_null() {
                        /*
	    * Apply default "block" values.
	    */
                        if (*schema).flags &
                               (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
                            (*decl).flags |=
                                (1 as std::os::raw::c_int) << 12 as std::os::raw::c_int
                        }
                        if (*schema).flags &
                               (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
                            (*decl).flags |=
                                (1 as std::os::raw::c_int) << 11 as std::os::raw::c_int
                        }
                        if (*schema).flags &
                               (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0 {
                            (*decl).flags |=
                                (1 as std::os::raw::c_int) << 13 as std::os::raw::c_int
                        }
                    } else {
                        attrValue =
                            xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(attrValue,
                                                       &mut (*decl).flags,
                                                       -(1 as std::os::raw::c_int),
                                                       (1 as std::os::raw::c_int) <<
                                                           11 as std::os::raw::c_int,
                                                       (1 as std::os::raw::c_int) <<
                                                           12 as std::os::raw::c_int,
                                                       (1 as std::os::raw::c_int) <<
                                                           13 as std::os::raw::c_int,
                                                       -(1 as std::os::raw::c_int),
                                                       -(1 as std::os::raw::c_int)) !=
                               0 as std::os::raw::c_int {
                            xmlSchemaPSimpleTypeErr(ctxt,
                                                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                    0 as
                                                        xmlSchemaBasicItemPtr,
                                                    attr as xmlNodePtr,
                                                    0 as xmlSchemaTypePtr,
                                                    b"(#all | List of (extension | restriction | substitution))\x00"
                                                        as *const u8 as
                                                        *const std::os::raw::c_char,
                                                    attrValue,
                                                    0 as *const std::os::raw::c_char,
                                                    0 as *const xmlChar,
                                                    0 as *const xmlChar);
                        }
                    }
                    if xmlGetBooleanProp(ctxt, node,
                                         b"nillable\x00" as *const u8 as
                                             *const std::os::raw::c_char,
                                         0 as std::os::raw::c_int) != 0 {
                        (*decl).flags |=
                            (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
                    }
                    attr =
                        xmlSchemaGetPropNode(node,
                                             b"type\x00" as *const u8 as
                                                 *const std::os::raw::c_char);
                    if !attr.is_null() {
                        xmlSchemaPValAttrNodeQName(ctxt, schema,
                                                   0 as xmlSchemaBasicItemPtr,
                                                   attr,
                                                   &mut (*decl).namedTypeNs,
                                                   &mut (*decl).namedType);
                        xmlSchemaCheckReference(ctxt, schema, node, attr,
                                                (*decl).namedTypeNs);
                    }
                    (*decl).value =
                        xmlSchemaGetProp(ctxt, node,
                                         b"default\x00" as *const u8 as
                                             *const std::os::raw::c_char);
                    attr =
                        xmlSchemaGetPropNode(node,
                                             b"fixed\x00" as *const u8 as
                                                 *const std::os::raw::c_char);
                    if !attr.is_null() {
                        fixed =
                            xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if !(*decl).value.is_null() {
                            /*
		* 3.3.3 : 1
		* default and fixed must not both be present.
		*/
                            xmlSchemaPMutualExclAttrErr(ctxt,
                                                        XML_SCHEMAP_SRC_ELEMENT_1,
                                                        0 as
                                                            xmlSchemaBasicItemPtr,
                                                        attr,
                                                        b"default\x00" as
                                                            *const u8 as
                                                            *const std::os::raw::c_char,
                                                        b"fixed\x00" as
                                                            *const u8 as
                                                            *const std::os::raw::c_char);
                        } else {
                            (*decl).flags |=
                                (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int;
                            (*decl).value = fixed
                        }
                    }
                    /*
	* And now for the children...
	*/
                    if !child.is_null() && !(*child).ns.is_null() &&
                           xmlStrEqual((*child).name,
                                       b"complexType\x00" as *const u8 as
                                           *const std::os::raw::c_char as
                                           *const xmlChar) != 0 &&
                           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                       {
                        /*
	    * 3.3.3 : 3
	    * "type" and either <simpleType> or <complexType> are mutually
	    * exclusive
	    */
                        if !(*decl).namedType.is_null() {
                            xmlSchemaPContentErr(ctxt,
                                                 XML_SCHEMAP_SRC_ELEMENT_3,
                                                 0 as xmlSchemaBasicItemPtr,
                                                 node, child,
                                                 b"The attribute \'type\' and the <complexType> child are mutually exclusive\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 0 as *const std::os::raw::c_char);
                        } else {
                            (*decl).subtypes =
                                xmlSchemaParseComplexType(ctxt, schema, child,
                                                          0 as std::os::raw::c_int)
                        }
                        child = (*child).next
                    } else if !child.is_null() && !(*child).ns.is_null() &&
                                  xmlStrEqual((*child).name,
                                              b"simpleType\x00" as *const u8
                                                  as *const std::os::raw::c_char as
                                                  *const xmlChar) != 0 &&
                                  xmlStrEqual((*(*child).ns).href,
                                              xmlSchemaNs) != 0 {
                        /*
	    * 3.3.3 : 3
	    * "type" and either <simpleType> or <complexType> are
	    * mutually exclusive
	    */
                        if !(*decl).namedType.is_null() {
                            xmlSchemaPContentErr(ctxt,
                                                 XML_SCHEMAP_SRC_ELEMENT_3,
                                                 0 as xmlSchemaBasicItemPtr,
                                                 node, child,
                                                 b"The attribute \'type\' and the <simpleType> child are mutually exclusive\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 0 as *const std::os::raw::c_char);
                        } else {
                            (*decl).subtypes =
                                xmlSchemaParseSimpleType(ctxt, schema, child,
                                                         0 as std::os::raw::c_int)
                        }
                        child = (*child).next
                    }
                    while !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"unique\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 ||
                              !child.is_null() && !(*child).ns.is_null() &&
                                  xmlStrEqual((*child).name,
                                              b"key\x00" as *const u8 as
                                                  *const std::os::raw::c_char as
                                                  *const xmlChar) != 0 &&
                                  xmlStrEqual((*(*child).ns).href,
                                              xmlSchemaNs) != 0 ||
                              !child.is_null() && !(*child).ns.is_null() &&
                                  xmlStrEqual((*child).name,
                                              b"keyref\x00" as *const u8 as
                                                  *const std::os::raw::c_char as
                                                  *const xmlChar) != 0 &&
                                  xmlStrEqual((*(*child).ns).href,
                                              xmlSchemaNs) != 0 {
                        if !child.is_null() && !(*child).ns.is_null() &&
                               xmlStrEqual((*child).name,
                                           b"unique\x00" as *const u8 as
                                               *const std::os::raw::c_char as
                                               *const xmlChar) != 0 &&
                               xmlStrEqual((*(*child).ns).href, xmlSchemaNs)
                                   != 0 {
                            curIDC =
                                xmlSchemaParseIDC(ctxt, schema, child,
                                                  XML_SCHEMA_TYPE_IDC_UNIQUE,
                                                  (*decl).targetNamespace)
                        } else if !child.is_null() && !(*child).ns.is_null()
                                      &&
                                      xmlStrEqual((*child).name,
                                                  b"key\x00" as *const u8 as
                                                      *const std::os::raw::c_char as
                                                      *const xmlChar) != 0 &&
                                      xmlStrEqual((*(*child).ns).href,
                                                  xmlSchemaNs) != 0 {
                            curIDC =
                                xmlSchemaParseIDC(ctxt, schema, child,
                                                  XML_SCHEMA_TYPE_IDC_KEY,
                                                  (*decl).targetNamespace)
                        } else if !child.is_null() && !(*child).ns.is_null()
                                      &&
                                      xmlStrEqual((*child).name,
                                                  b"keyref\x00" as *const u8
                                                      as *const std::os::raw::c_char
                                                      as *const xmlChar) != 0
                                      &&
                                      xmlStrEqual((*(*child).ns).href,
                                                  xmlSchemaNs) != 0 {
                            curIDC =
                                xmlSchemaParseIDC(ctxt, schema, child,
                                                  XML_SCHEMA_TYPE_IDC_KEYREF,
                                                  (*decl).targetNamespace)
                        }
                        if !lastIDC.is_null() {
                            (*lastIDC).next = curIDC
                        } else { (*decl).idcs = curIDC as *mut std::os::raw::c_void }
                        lastIDC = curIDC;
                        child = (*child).next
                    }
                    if !child.is_null() {
                        xmlSchemaPContentErr(ctxt,
                                             XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                             0 as xmlSchemaBasicItemPtr, node,
                                             child, 0 as *const std::os::raw::c_char,
                                             b"(annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                    }
                    (*decl).annot = annot;
                    /*
    * NOTE: Element Declaration Representation OK 4. will be checked at a
    * different layer.
    */
                    if !des.is_null() {
                        xmlFree.expect("non-null function pointer")(des as
                                                                        *mut std::os::raw::c_void);
                        des = 0 as *mut xmlChar
                    }
                    if topLevel != 0 {
                        return decl as xmlSchemaBasicItemPtr
                    } else {
                        (*particle).children = decl as xmlSchemaTreeItemPtr;
                        return particle as xmlSchemaBasicItemPtr
                    }
                }
            }
        }
        _ => { }
    }
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut std::os::raw::c_void);
        des = 0 as *mut xmlChar
    }
    if !annot.is_null() {
        if !particle.is_null() { (*particle).annot = 0 as xmlSchemaAnnotPtr }
        if !decl.is_null() { (*decl).annot = 0 as xmlSchemaAnnotPtr }
        xmlSchemaFreeAnnot(annot);
    }
    return 0 as xmlSchemaBasicItemPtr;
}
/* *
 * xmlSchemaParseUnion:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Union definition
 * *WARNING* this interface is highly subject to change
 *
 * Returns -1 in case of internal error, 0 in case of success and a positive
 * error code otherwise.
 */
unsafe extern "C" fn xmlSchemaParseUnion(mut ctxt: xmlSchemaParserCtxtPtr,
                                         mut schema: xmlSchemaPtr,
                                         mut node: xmlNodePtr)
 -> std::os::raw::c_int {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    /* Not a component, don't create it. */
    type_0 = (*ctxt).ctxtType;
    /*
    * Mark the simple type as being of variety "union".
    */
    (*type_0).flags |= (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int;
    /*
    * SPEC (Base type) (2) "If the <list> or <union> alternative is chosen,
    * then the `simple ur-type definition`."
    */
    (*type_0).baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"memberTypes\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * Attribute "memberTypes". This is a list of QNames.
    * TODO: Check the value to contain anything.
    */
    attr =
        xmlSchemaGetPropNode(node,
                             b"memberTypes\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    if !attr.is_null() {
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
        let mut localName: *const xmlChar = 0 as *const xmlChar;
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        let mut link: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        let mut lastLink: xmlSchemaTypeLinkPtr = 0 as xmlSchemaTypeLinkPtr;
        let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
        cur = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
        (*type_0).base = cur;
        loop  {
            while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                      0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                          *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                      *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                cur = cur.offset(1)
            }
            end = cur;
            while *end as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                      !(*end as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                            0x9 as std::os::raw::c_int <= *end as std::os::raw::c_int &&
                                *end as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                            *end as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
                end = end.offset(1)
            }
            if end == cur { break ; }
            tmp =
                xmlStrndup(cur,
                           end.offset_from(cur) as std::os::raw::c_long as
                               std::os::raw::c_int);
            if xmlSchemaPValAttrNodeQNameValue(ctxt, schema,
                                               0 as xmlSchemaBasicItemPtr,
                                               attr, tmp, &mut nsName,
                                               &mut localName) ==
                   0 as std::os::raw::c_int {
                /*
		* Create the member type link.
		*/
                link =
                    xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaTypeLink>()
                                                                      as
                                                                      std::os::raw::c_ulong)
                        as xmlSchemaTypeLinkPtr;
                if link.is_null() {
                    xmlSchemaPErrMemory(ctxt,
                                        b"xmlSchemaParseUnion, allocating a type link\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as xmlNodePtr);
                    return -(1 as std::os::raw::c_int)
                }
                (*link).type_0 = 0 as xmlSchemaTypePtr;
                (*link).next = 0 as *mut _xmlSchemaTypeLink;
                if lastLink.is_null() {
                    (*type_0).memberTypes = link
                } else { (*lastLink).next = link }
                lastLink = link;
                /*
		* Create a reference item.
		*/
                ref_0 =
                    xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_SIMPLE,
                                         localName, nsName);
                if ref_0.is_null() {
                    if !tmp.is_null() {
                        xmlFree.expect("non-null function pointer")(tmp as
                                                                        *mut std::os::raw::c_void);
                        tmp = 0 as *mut xmlChar
                    }
                    return -(1 as std::os::raw::c_int)
                }
                /*
		* Assign the reference to the link, it will be resolved
		* later during fixup of the union simple type.
		*/
                (*link).type_0 = ref_0 as xmlSchemaTypePtr
            }
            if !tmp.is_null() {
                xmlFree.expect("non-null function pointer")(tmp as
                                                                *mut std::os::raw::c_void);
                tmp = 0 as *mut xmlChar
            }
            cur = end;
            if !(*cur as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
        }
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* Add the annotation to the simple type ancestor.
	*/
        xmlSchemaAddAnnotation(type_0 as xmlSchemaAnnotItemPtr,
                               xmlSchemaParseAnnotation(ctxt, child,
                                                        1 as std::os::raw::c_int));
        child = (*child).next
    }
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"simpleType\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        let mut subtype: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        let mut last: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
        /*
	* Anchor the member types in the "subtypes" field of the
	* simple type.
	*/
        while !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"simpleType\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            subtype =
                xmlSchemaParseSimpleType(ctxt, schema, child,
                                         0 as std::os::raw::c_int);
            if !subtype.is_null() {
                if last.is_null() {
                    (*type_0).subtypes = subtype;
                    last = subtype
                } else { (*last).next = subtype; last = subtype }
                (*last).next = 0 as *mut _xmlSchemaType
            }
            child = (*child).next
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, simpleType*)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    if attr.is_null() && (*type_0).subtypes.is_null() {
        /*
	* src-union-memberTypes-or-simpleTypes
	* Either the memberTypes [attribute] of the <union> element must
	* be non-empty or there must be at least one simpleType [child].
	*/
        xmlSchemaPCustomErr(ctxt,
                            XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES,
                            0 as xmlSchemaBasicItemPtr, node,
                            b"Either the attribute \'memberTypes\' or at least one <simpleType> child must be present\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaParseList:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema List definition
 * *WARNING* this interface is highly subject to change
 *
 * Returns -1 in case of error, 0 if the declaration is improper and
 *         1 in case of success.
 */
unsafe extern "C" fn xmlSchemaParseList(mut ctxt: xmlSchemaParserCtxtPtr,
                                        mut schema: xmlSchemaPtr,
                                        mut node: xmlNodePtr)
 -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr
    }
    /* Not a component, don't create it. */
    type_0 = (*ctxt).ctxtType;
    /*
    * Mark the type as being of variety "list".
    */
    (*type_0).flags |= (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int;
    /*
    * SPEC (Base type) (2) "If the <list> or <union> alternative is chosen,
    * then the `simple ur-type definition`."
    */
    (*type_0).baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"itemType\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * Attribute "itemType". NOTE that we will use the "ref" and "refNs"
    * fields for holding the reference to the itemType.
    *
    * REVAMP TODO: Use the "base" and "baseNs" fields, since we will remove
    * the "ref" fields.
    */
    xmlSchemaPValAttrQName(ctxt, schema, 0 as xmlSchemaBasicItemPtr, node,
                           b"itemType\x00" as *const u8 as
                               *const std::os::raw::c_char, &mut (*type_0).baseNs,
                           &mut (*type_0).base);
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        xmlSchemaAddAnnotation(type_0 as xmlSchemaAnnotItemPtr,
                               xmlSchemaParseAnnotation(ctxt, child,
                                                        1 as std::os::raw::c_int));
        child = (*child).next
    }
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"simpleType\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* src-list-itemType-or-simpleType
	* Either the itemType [attribute] or the <simpleType> [child] of
	* the <list> element must be present, but not both.
	*/
        if !(*type_0).base.is_null() {
            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
                                0 as xmlSchemaBasicItemPtr, node,
                                b"The attribute \'itemType\' and the <simpleType> child are mutually exclusive\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar);
        } else {
            (*type_0).subtypes =
                xmlSchemaParseSimpleType(ctxt, schema, child,
                                         0 as std::os::raw::c_int)
        }
        child = (*child).next
    } else if (*type_0).base.is_null() {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
                            0 as xmlSchemaBasicItemPtr, node,
                            b"Either the attribute \'itemType\' or the <simpleType> child must be present\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, simpleType?)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    if (*type_0).base.is_null() && (*type_0).subtypes.is_null() &&
           xmlSchemaGetPropNode(node,
                                b"itemType\x00" as *const u8 as
                                    *const std::os::raw::c_char).is_null() {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
                            0 as xmlSchemaBasicItemPtr, node,
                            b"Either the attribute \'itemType\' or the <simpleType> child must be present\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
    }
    return 0 as xmlSchemaTypePtr;
}
/* ***********************************************************************
 *									*
 *		Shema extraction from an Infoset			*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaParseSimpleType:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Simple Type definition
 * *WARNING* this interface is highly subject to change
 *
 * Returns -1 in case of error, 0 if the declaration is improper and
 * 1 in case of success.
 */
unsafe extern "C" fn xmlSchemaParseSimpleType(mut ctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut schema: xmlSchemaPtr,
                                              mut node: xmlNodePtr,
                                              mut topLevel: std::os::raw::c_int)
 -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut oldCtxtType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut hasRestriction: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr
    }
    if topLevel != 0 {
        attr =
            xmlSchemaGetPropNode(node,
                                 b"name\x00" as *const u8 as
                                     *const std::os::raw::c_char);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                     0 as xmlSchemaBasicItemPtr, node,
                                     b"name\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     0 as *const std::os::raw::c_char);
            return 0 as xmlSchemaTypePtr
        } else {
            if xmlSchemaPValAttrNode(ctxt, 0 as xmlSchemaBasicItemPtr, attr,
                                     xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                                     &mut attrValue) != 0 as std::os::raw::c_int {
                return 0 as xmlSchemaTypePtr
            }
            /*
	    * Skip built-in types.
	    */
            if (*ctxt).isS4S != 0 {
                let mut biType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
                if (*ctxt).isRedefine != 0 {
                    /*
		    * REDEFINE: Disallow redefinition of built-in-types.
		    * TODO: It seems that the spec does not say anything
		    * about this case.
		    */
                    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,
                                        0 as xmlSchemaBasicItemPtr, node,
                                        b"Redefinition of built-in simple types is not supported\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as *const xmlChar);
                    return 0 as xmlSchemaTypePtr
                }
                biType = xmlSchemaGetPredefinedType(attrValue, xmlSchemaNs);
                if !biType.is_null() { return biType }
            }
        }
    }
    /*
    * TargetNamespace:
    * SPEC "The `actual value` of the targetNamespace [attribute]
    * of the <schema> ancestor element information item if present,
    * otherwise `absent`.
    */
    if topLevel == 0 as std::os::raw::c_int {
        /*
	* Parse as local simple type definition.
	*/
        type_0 =
            xmlSchemaAddType(ctxt, schema, XML_SCHEMA_TYPE_SIMPLE,
                             0 as *const xmlChar, (*ctxt).targetNamespace,
                             node, 0 as std::os::raw::c_int);
        if type_0.is_null() { return 0 as xmlSchemaTypePtr }
        (*type_0).type_0 = XML_SCHEMA_TYPE_SIMPLE;
        (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
        /*
	* Check for illegal attributes.
	*/
        attr = (*node).properties;
        while !attr.is_null() {
            if (*attr).ns.is_null() {
                if xmlStrEqual((*attr).name,
                               b"id\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 {
                    xmlSchemaPIllegalAttrErr(ctxt,
                                             XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                             0 as xmlSchemaBasicItemPtr,
                                             attr);
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
            attr = (*attr).next
        }
    } else {
        /*
	* Parse as global simple type definition.
	*
	* Note that attrValue is the value of the attribute "name" here.
	*/
        type_0 =
            xmlSchemaAddType(ctxt, schema, XML_SCHEMA_TYPE_SIMPLE, attrValue,
                             (*ctxt).targetNamespace, node, 1 as std::os::raw::c_int);
        if type_0.is_null() { return 0 as xmlSchemaTypePtr }
        (*type_0).type_0 = XML_SCHEMA_TYPE_SIMPLE;
        (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
        (*type_0).flags |= (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int;
        /*
	* Check for illegal attributes.
	*/
        attr = (*node).properties;
        while !attr.is_null() {
            if (*attr).ns.is_null() {
                if xmlStrEqual((*attr).name,
                               b"id\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 &&
                       xmlStrEqual((*attr).name,
                                   b"name\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) ==
                           0 &&
                       xmlStrEqual((*attr).name,
                                   b"final\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) ==
                           0 {
                    xmlSchemaPIllegalAttrErr(ctxt,
                                             XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                             0 as xmlSchemaBasicItemPtr,
                                             attr);
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
            attr = (*attr).next
        }
        /*
	* Attribute "final".
	*/
        attr =
            xmlSchemaGetPropNode(node,
                                 b"final\x00" as *const u8 as
                                     *const std::os::raw::c_char);
        if attr.is_null() {
            if (*schema).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0 {
                (*type_0).flags |= (1 as std::os::raw::c_int) << 10 as std::os::raw::c_int
            }
            if (*schema).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int != 0 {
                (*type_0).flags |= (1 as std::os::raw::c_int) << 11 as std::os::raw::c_int
            }
            if (*schema).flags & (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int != 0 {
                (*type_0).flags |= (1 as std::os::raw::c_int) << 12 as std::os::raw::c_int
            }
        } else {
            attrValue =
                xmlSchemaGetProp(ctxt, node,
                                 b"final\x00" as *const u8 as
                                     *const std::os::raw::c_char);
            if xmlSchemaPValAttrBlockFinal(attrValue, &mut (*type_0).flags,
                                           -(1 as std::os::raw::c_int),
                                           -(1 as std::os::raw::c_int),
                                           (1 as std::os::raw::c_int) <<
                                               10 as std::os::raw::c_int,
                                           -(1 as std::os::raw::c_int),
                                           (1 as std::os::raw::c_int) <<
                                               11 as std::os::raw::c_int,
                                           (1 as std::os::raw::c_int) <<
                                               12 as std::os::raw::c_int) !=
                   0 as std::os::raw::c_int {
                xmlSchemaPSimpleTypeErr(ctxt,
                                        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                        type_0 as xmlSchemaBasicItemPtr,
                                        attr as xmlNodePtr,
                                        0 as xmlSchemaTypePtr,
                                        b"(#all | List of (list | union | restriction)\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char, attrValue,
                                        0 as *const std::os::raw::c_char,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar);
            }
        }
    }
    (*type_0).targetNamespace = (*ctxt).targetNamespace;
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * And now for the children...
    */
    oldCtxtType = (*ctxt).ctxtType;
    (*ctxt).ctxtType = type_0;
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*type_0).annot =
            xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_MISSING,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, (restriction | list | union))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    } else if !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"restriction\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        xmlSchemaParseRestriction(ctxt, schema, child,
                                  XML_SCHEMA_TYPE_SIMPLE);
        hasRestriction = 1 as std::os::raw::c_int;
        child = (*child).next
    } else if !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"list\x00" as *const u8 as *const std::os::raw::c_char
                                  as *const xmlChar) != 0 &&
                  xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        xmlSchemaParseList(ctxt, schema, child);
        child = (*child).next
    } else if !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"union\x00" as *const u8 as *const std::os::raw::c_char
                                  as *const xmlChar) != 0 &&
                  xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        xmlSchemaParseUnion(ctxt, schema, child);
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, (restriction | list | union))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    /*
    * REDEFINE: SPEC src-redefine (5)
    * "Within the [children], each <simpleType> must have a
    * <restriction> among its [children] ... the `actual value` of whose
    * base [attribute] must be the same as the `actual value` of its own
    * name attribute plus target namespace;"
    */
    if topLevel != 0 && (*ctxt).isRedefine != 0 && hasRestriction == 0 {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,
                            0 as xmlSchemaBasicItemPtr, node,
                            b"This is a redefinition, thus the <simpleType> must have a <restriction> child\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
    }
    (*ctxt).ctxtType = oldCtxtType;
    return type_0;
}
/* *
 * xmlSchemaParseModelGroupDefRef:
 * @ctxt:  the parser context
 * @schema: the schema being built
 * @node:  the node
 *
 * Parses a reference to a model group definition.
 *
 * We will return a particle component with a qname-component or
 * NULL in case of an error.
 */
unsafe extern "C" fn xmlSchemaParseModelGroupDefRef(mut ctxt:
                                                        xmlSchemaParserCtxtPtr,
                                                    mut schema: xmlSchemaPtr,
                                                    mut node: xmlNodePtr)
 -> xmlSchemaTreeItemPtr {
    let mut item: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut ref_0: *const xmlChar = 0 as *const xmlChar;
    let mut refNs: *const xmlChar = 0 as *const xmlChar;
    let mut min: std::os::raw::c_int = 0;
    let mut max: std::os::raw::c_int = 0;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTreeItemPtr
    }
    attr =
        xmlSchemaGetPropNode(node,
                             b"ref\x00" as *const u8 as *const std::os::raw::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                 0 as xmlSchemaBasicItemPtr, node,
                                 b"ref\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
        return 0 as xmlSchemaTreeItemPtr
    } else {
        if xmlSchemaPValAttrNodeQName(ctxt, schema,
                                      0 as xmlSchemaBasicItemPtr, attr,
                                      &mut refNs, &mut ref_0) !=
               0 as std::os::raw::c_int {
            return 0 as xmlSchemaTreeItemPtr
        }
    }
    xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
    min =
        xmlGetMinOccurs(ctxt, node, 0 as std::os::raw::c_int, -(1 as std::os::raw::c_int),
                        1 as std::os::raw::c_int,
                        b"xs:nonNegativeInteger\x00" as *const u8 as
                            *const std::os::raw::c_char);
    max =
        xmlGetMaxOccurs(ctxt, node, 0 as std::os::raw::c_int,
                        (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int,
                        1 as std::os::raw::c_int,
                        b"(xs:nonNegativeInteger | unbounded)\x00" as
                            *const u8 as *const std::os::raw::c_char);
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"ref\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"id\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"minOccurs\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0
                   &&
                   xmlStrEqual((*attr).name,
                               b"maxOccurs\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    item = xmlSchemaAddParticle(ctxt, node, min, max);
    if item.is_null() { return 0 as xmlSchemaTreeItemPtr }
    /*
    * Create a qname-reference and set as the term; it will be substituted
    * for the model group after the reference has been resolved.
    */
    (*item).children =
        xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_GROUP, ref_0, refNs) as
            xmlSchemaTreeItemPtr;
    xmlSchemaPCheckParticleCorrect_2(ctxt, item, node, min, max);
    /*
    * And now for the children...
    */
    child = (*node).children;
    /* TODO: Is annotation even allowed for a model group reference? */
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* TODO: What to do exactly with the annotation?
	*/
        (*item).annot =
            xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    /*
    * Corresponds to no component at all if minOccurs==maxOccurs==0.
    */
    if min == 0 as std::os::raw::c_int && max == 0 as std::os::raw::c_int {
        return 0 as xmlSchemaTreeItemPtr
    }
    return item as xmlSchemaTreeItemPtr;
}
/* *
 * xmlSchemaParseModelGroupDefinition:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * Parses a XML schema model group definition.
 *
 * Note that the contraint src-redefine (6.2) can't be applied until
 * references have been resolved. So we will do this at the
 * component fixup level.
 *
 * *WARNING* this interface is highly subject to change
 *
 * Returns -1 in case of error, 0 if the declaration is improper and
 *         1 in case of success.
 */
unsafe extern "C" fn xmlSchemaParseModelGroupDefinition(mut ctxt:
                                                            xmlSchemaParserCtxtPtr,
                                                        mut schema:
                                                            xmlSchemaPtr,
                                                        mut node: xmlNodePtr)
 -> xmlSchemaModelGroupDefPtr {
    let mut item: xmlSchemaModelGroupDefPtr =
        0 as *mut xmlSchemaModelGroupDef;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr
    }
    attr =
        xmlSchemaGetPropNode(node,
                             b"name\x00" as *const u8 as *const std::os::raw::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                 0 as xmlSchemaBasicItemPtr, node,
                                 b"name\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
        return 0 as xmlSchemaModelGroupDefPtr
    } else {
        if xmlSchemaPValAttrNode(ctxt, 0 as xmlSchemaBasicItemPtr, attr,
                                 xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                                 &mut name) != 0 as std::os::raw::c_int {
            return 0 as xmlSchemaModelGroupDefPtr
        }
    }
    item =
        xmlSchemaAddModelGroupDefinition(ctxt, schema, name,
                                         (*ctxt).targetNamespace, node);
    if item.is_null() { return 0 as xmlSchemaModelGroupDefPtr }
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"name\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"id\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*item).annot =
            xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"all\x00" as *const u8 as *const std::os::raw::c_char as
                           *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*item).children =
            xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_ALL,
                                     0 as std::os::raw::c_int);
        child = (*child).next
    } else if !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"choice\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*item).children =
            xmlSchemaParseModelGroup(ctxt, schema, child,
                                     XML_SCHEMA_TYPE_CHOICE,
                                     0 as std::os::raw::c_int);
        child = (*child).next
    } else if !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"sequence\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*item).children =
            xmlSchemaParseModelGroup(ctxt, schema, child,
                                     XML_SCHEMA_TYPE_SEQUENCE,
                                     0 as std::os::raw::c_int);
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, (all | choice | sequence)?)\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    return item;
}
/* *
 * xmlSchemaCleanupDoc:
 * @ctxt:  a schema validation context
 * @node:  the root of the document.
 *
 * removes unwanted nodes in a schemas document tree
 */
unsafe extern "C" fn xmlSchemaCleanupDoc(mut ctxt: xmlSchemaParserCtxtPtr,
                                         mut root: xmlNodePtr) {
    let mut delete: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    if ctxt.is_null() || root.is_null() { return }
    /*
     * Remove all the blank text nodes
     */
    delete = 0 as xmlNodePtr;
    cur = root;
    let mut current_block_21: u64;
    while !cur.is_null() {
        if !delete.is_null() {
            xmlUnlinkNode(delete);
            xmlFreeNode(delete);
            delete = 0 as xmlNodePtr
        }
        if (*cur).type_0 as std::os::raw::c_uint ==
               XML_TEXT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
            if (*cur).type_0 as std::os::raw::c_uint ==
                   XML_TEXT_NODE as std::os::raw::c_int as std::os::raw::c_uint &&
                   xmlSchemaIsBlank((*cur).content, -(1 as std::os::raw::c_int)) != 0
               {
                if xmlNodeGetSpacePreserve(cur as *const xmlNode) !=
                       1 as std::os::raw::c_int {
                    delete = cur
                }
            }
            current_block_21 = 5689001924483802034;
        } else if (*cur).type_0 as std::os::raw::c_uint !=
                      XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint &&
                      (*cur).type_0 as std::os::raw::c_uint !=
                          XML_CDATA_SECTION_NODE as std::os::raw::c_int as
                              std::os::raw::c_uint {
            delete = cur;
            current_block_21 = 14781781443276786816;
        } else { current_block_21 = 5689001924483802034; }
        match current_block_21 {
            5689001924483802034 =>
            /*
         * Skip to next node
         */
            {
                if !(*cur).children.is_null() {
                    if (*(*cur).children).type_0 as std::os::raw::c_uint !=
                           XML_ENTITY_DECL as std::os::raw::c_int as std::os::raw::c_uint &&
                           (*(*cur).children).type_0 as std::os::raw::c_uint !=
                               XML_ENTITY_REF_NODE as std::os::raw::c_int as
                                   std::os::raw::c_uint &&
                           (*(*cur).children).type_0 as std::os::raw::c_uint !=
                               XML_ENTITY_NODE as std::os::raw::c_int as std::os::raw::c_uint
                       {
                        cur = (*cur).children;
                        continue ;
                    }
                }
            }
            _ => { }
        }
        if !(*cur).next.is_null() {
            cur = (*cur).next
        } else {
            loop  {
                cur = (*cur).parent;
                if cur.is_null() { break ; }
                if cur == root {
                    cur = 0 as xmlNodePtr;
                    break ;
                } else if !(*cur).next.is_null() {
                    cur = (*cur).next;
                    break ;
                } else if cur.is_null() { break ; }
            }
        }
    }
    if !delete.is_null() {
        xmlUnlinkNode(delete);
        xmlFreeNode(delete);
        delete = 0 as xmlNodePtr
    };
}
unsafe extern "C" fn xmlSchemaClearSchemaDefaults(mut schema: xmlSchemaPtr) {
    if (*schema).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 {
        (*schema).flags ^= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
    }
    if (*schema).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
        (*schema).flags ^= (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int
    }
    if (*schema).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
        (*schema).flags ^= (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int
    }
    if (*schema).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0 {
        (*schema).flags ^= (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int
    }
    if (*schema).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int != 0 {
        (*schema).flags ^= (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int
    }
    if (*schema).flags & (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int != 0 {
        (*schema).flags ^= (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int
    }
    if (*schema).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
        (*schema).flags ^= (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int
    }
    if (*schema).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
        (*schema).flags ^= (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int
    }
    if (*schema).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0 {
        (*schema).flags ^= (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int
    };
}
unsafe extern "C" fn xmlSchemaParseSchemaElement(mut ctxt:
                                                     xmlSchemaParserCtxtPtr,
                                                 mut schema: xmlSchemaPtr,
                                                 mut node: xmlNodePtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut val: *const xmlChar = 0 as *const xmlChar;
    let mut res: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut oldErrs: std::os::raw::c_int = (*ctxt).nberrors;
    /*
    * Those flags should be moved to the parser context flags,
    * since they are not visible at the component level. I.e.
    * they are used if processing schema *documents* only.
    */
    res =
        xmlSchemaPValAttrID(ctxt, node,
                            b"id\x00" as *const u8 as *const std::os::raw::c_char as
                                *mut xmlChar);
    if !(res == -(1 as std::os::raw::c_int)) {
        /*
    * Since the version is of type xs:token, we won't bother to
    * check it.
    */
    /* REMOVED:
    attr = xmlSchemaGetPropNode(node, "version");
    if (attr != NULL) {
	res = xmlSchemaPValAttrNode(ctxt, NULL, NULL, attr,
	    xmlSchemaGetBuiltInType(XML_SCHEMAS_TOKEN), &val);
	HFAILURE;
    }
    */
        attr =
            xmlSchemaGetPropNode(node,
                                 b"targetNamespace\x00" as *const u8 as
                                     *const std::os::raw::c_char);
        if !attr.is_null() {
            res =
                xmlSchemaPValAttrNode(ctxt, 0 as xmlSchemaBasicItemPtr, attr,
                                      xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                                      0 as *mut *const xmlChar);
            if res == -(1 as std::os::raw::c_int) {
                current_block = 2414536423105145288;
            } else if res != 0 as std::os::raw::c_int {
                (*ctxt).stop =
                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as std::os::raw::c_int;
                current_block = 16810503900853031839;
            } else { current_block = 5399440093318478209; }
        } else { current_block = 5399440093318478209; }
        match current_block {
            2414536423105145288 => { }
            _ => {
                match current_block {
                    5399440093318478209 => {
                        attr =
                            xmlSchemaGetPropNode(node,
                                                 b"elementFormDefault\x00" as
                                                     *const u8 as
                                                     *const std::os::raw::c_char);
                        if !attr.is_null() {
                            val =
                                xmlSchemaGetNodeContent(ctxt,
                                                        attr as xmlNodePtr);
                            res =
                                xmlSchemaPValAttrFormDefault(val,
                                                             &mut (*schema).flags,
                                                             (1 as
                                                                  std::os::raw::c_int)
                                                                 <<
                                                                 0 as
                                                                     std::os::raw::c_int);
                            if res == -(1 as std::os::raw::c_int) {
                                current_block = 2414536423105145288;
                            } else {
                                if res != 0 as std::os::raw::c_int {
                                    xmlSchemaPSimpleTypeErr(ctxt,
                                                            XML_SCHEMAP_ELEMFORMDEFAULT_VALUE,
                                                            0 as
                                                                xmlSchemaBasicItemPtr,
                                                            attr as
                                                                xmlNodePtr,
                                                            0 as
                                                                xmlSchemaTypePtr,
                                                            b"(qualified | unqualified)\x00"
                                                                as *const u8
                                                                as
                                                                *const std::os::raw::c_char,
                                                            val,
                                                            0 as
                                                                *const std::os::raw::c_char,
                                                            0 as
                                                                *const xmlChar,
                                                            0 as
                                                                *const xmlChar);
                                }
                                current_block = 224731115979188411;
                            }
                        } else { current_block = 224731115979188411; }
                        match current_block {
                            2414536423105145288 => { }
                            _ => {
                                attr =
                                    xmlSchemaGetPropNode(node,
                                                         b"attributeFormDefault\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char);
                                if !attr.is_null() {
                                    val =
                                        xmlSchemaGetNodeContent(ctxt,
                                                                attr as
                                                                    xmlNodePtr);
                                    res =
                                        xmlSchemaPValAttrFormDefault(val,
                                                                     &mut (*schema).flags,
                                                                     (1 as
                                                                          std::os::raw::c_int)
                                                                         <<
                                                                         1 as
                                                                             std::os::raw::c_int);
                                    if res == -(1 as std::os::raw::c_int) {
                                        current_block = 2414536423105145288;
                                    } else {
                                        if res != 0 as std::os::raw::c_int {
                                            xmlSchemaPSimpleTypeErr(ctxt,
                                                                    XML_SCHEMAP_ATTRFORMDEFAULT_VALUE,
                                                                    0 as
                                                                        xmlSchemaBasicItemPtr,
                                                                    attr as
                                                                        xmlNodePtr,
                                                                    0 as
                                                                        xmlSchemaTypePtr,
                                                                    b"(qualified | unqualified)\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const std::os::raw::c_char,
                                                                    val,
                                                                    0 as
                                                                        *const std::os::raw::c_char,
                                                                    0 as
                                                                        *const xmlChar,
                                                                    0 as
                                                                        *const xmlChar);
                                        }
                                        current_block = 5689316957504528238;
                                    }
                                } else {
                                    current_block = 5689316957504528238;
                                }
                                match current_block {
                                    2414536423105145288 => { }
                                    _ => {
                                        attr =
                                            xmlSchemaGetPropNode(node,
                                                                 b"finalDefault\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const std::os::raw::c_char);
                                        if !attr.is_null() {
                                            val =
                                                xmlSchemaGetNodeContent(ctxt,
                                                                        attr
                                                                            as
                                                                            xmlNodePtr);
                                            res =
                                                xmlSchemaPValAttrBlockFinal(val,
                                                                            &mut (*schema).flags,
                                                                            -(1
                                                                                  as
                                                                                  std::os::raw::c_int),
                                                                            (1
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                                <<
                                                                                2
                                                                                    as
                                                                                    std::os::raw::c_int,
                                                                            (1
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                                <<
                                                                                3
                                                                                    as
                                                                                    std::os::raw::c_int,
                                                                            -(1
                                                                                  as
                                                                                  std::os::raw::c_int),
                                                                            (1
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                                <<
                                                                                4
                                                                                    as
                                                                                    std::os::raw::c_int,
                                                                            (1
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                                <<
                                                                                5
                                                                                    as
                                                                                    std::os::raw::c_int);
                                            if res == -(1 as std::os::raw::c_int) {
                                                current_block =
                                                    2414536423105145288;
                                            } else {
                                                if res != 0 as std::os::raw::c_int {
                                                    xmlSchemaPSimpleTypeErr(ctxt,
                                                                            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                                            0
                                                                                as
                                                                                xmlSchemaBasicItemPtr,
                                                                            attr
                                                                                as
                                                                                xmlNodePtr,
                                                                            0
                                                                                as
                                                                                xmlSchemaTypePtr,
                                                                            b"(#all | List of (extension | restriction | list | union))\x00"
                                                                                as
                                                                                *const u8
                                                                                as
                                                                                *const std::os::raw::c_char,
                                                                            val,
                                                                            0
                                                                                as
                                                                                *const std::os::raw::c_char,
                                                                            0
                                                                                as
                                                                                *const xmlChar,
                                                                            0
                                                                                as
                                                                                *const xmlChar);
                                                }
                                                current_block =
                                                    3123434771885419771;
                                            }
                                        } else {
                                            current_block =
                                                3123434771885419771;
                                        }
                                        match current_block {
                                            2414536423105145288 => { }
                                            _ => {
                                                attr =
                                                    xmlSchemaGetPropNode(node,
                                                                         b"blockDefault\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const std::os::raw::c_char);
                                                if !attr.is_null() {
                                                    val =
                                                        xmlSchemaGetNodeContent(ctxt,
                                                                                attr
                                                                                    as
                                                                                    xmlNodePtr);
                                                    res =
                                                        xmlSchemaPValAttrBlockFinal(val,
                                                                                    &mut (*schema).flags,
                                                                                    -(1
                                                                                          as
                                                                                          std::os::raw::c_int),
                                                                                    (1
                                                                                         as
                                                                                         std::os::raw::c_int)
                                                                                        <<
                                                                                        6
                                                                                            as
                                                                                            std::os::raw::c_int,
                                                                                    (1
                                                                                         as
                                                                                         std::os::raw::c_int)
                                                                                        <<
                                                                                        7
                                                                                            as
                                                                                            std::os::raw::c_int,
                                                                                    (1
                                                                                         as
                                                                                         std::os::raw::c_int)
                                                                                        <<
                                                                                        8
                                                                                            as
                                                                                            std::os::raw::c_int,
                                                                                    -(1
                                                                                          as
                                                                                          std::os::raw::c_int),
                                                                                    -(1
                                                                                          as
                                                                                          std::os::raw::c_int));
                                                    if res ==
                                                           -(1 as std::os::raw::c_int)
                                                       {
                                                        current_block =
                                                            2414536423105145288;
                                                    } else {
                                                        if res !=
                                                               0 as
                                                                   std::os::raw::c_int
                                                           {
                                                            xmlSchemaPSimpleTypeErr(ctxt,
                                                                                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                                                    0
                                                                                        as
                                                                                        xmlSchemaBasicItemPtr,
                                                                                    attr
                                                                                        as
                                                                                        xmlNodePtr,
                                                                                    0
                                                                                        as
                                                                                        xmlSchemaTypePtr,
                                                                                    b"(#all | List of (extension | restriction | substitution))\x00"
                                                                                        as
                                                                                        *const u8
                                                                                        as
                                                                                        *const std::os::raw::c_char,
                                                                                    val,
                                                                                    0
                                                                                        as
                                                                                        *const std::os::raw::c_char,
                                                                                    0
                                                                                        as
                                                                                        *const xmlChar,
                                                                                    0
                                                                                        as
                                                                                        *const xmlChar);
                                                        }
                                                        current_block =
                                                            16810503900853031839;
                                                    }
                                                } else {
                                                    current_block =
                                                        16810503900853031839;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => { }
                }
                match current_block {
                    2414536423105145288 => { }
                    _ => {
                        if oldErrs != (*ctxt).nberrors { res = (*ctxt).err }
                        return res
                    }
                }
            }
        }
    }
    return -(1 as std::os::raw::c_int);
}
/* *
 * xmlSchemaParseSchemaTopLevel:
 * @ctxt:  a schema validation context
 * @schema:  the schemas
 * @nodes:  the list of top level nodes
 *
 * Returns the internal XML Schema structure built from the resource or
 *         NULL in case of error
 */
unsafe extern "C" fn xmlSchemaParseSchemaTopLevel(mut ctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut schema: xmlSchemaPtr,
                                                  mut nodes: xmlNodePtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut child: xmlNodePtr = 0 as *mut xmlNode;
    let mut annot: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
    let mut res: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut oldErrs: std::os::raw::c_int = 0;
    let mut tmpOldErrs: std::os::raw::c_int = 0;
    if ctxt.is_null() || schema.is_null() || nodes.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    oldErrs = (*ctxt).nberrors;
    child = nodes;
    loop  {
        if !(!child.is_null() && !(*child).ns.is_null() &&
                 xmlStrEqual((*child).name,
                             b"include\x00" as *const u8 as
                                 *const std::os::raw::c_char as *const xmlChar) != 0
                 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                 !child.is_null() && !(*child).ns.is_null() &&
                     xmlStrEqual((*child).name,
                                 b"import\x00" as *const u8 as
                                     *const std::os::raw::c_char as *const xmlChar) !=
                         0 &&
                     xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                 !child.is_null() && !(*child).ns.is_null() &&
                     xmlStrEqual((*child).name,
                                 b"redefine\x00" as *const u8 as
                                     *const std::os::raw::c_char as *const xmlChar) !=
                         0 &&
                     xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                 !child.is_null() && !(*child).ns.is_null() &&
                     xmlStrEqual((*child).name,
                                 b"annotation\x00" as *const u8 as
                                     *const std::os::raw::c_char as *const xmlChar) !=
                         0 &&
                     xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0) {
            current_block = 14832935472441733737;
            break ;
        }
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"annotation\x00" as *const u8 as
                               *const std::os::raw::c_char as *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            annot = xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
            if (*schema).annot.is_null() {
                (*schema).annot = annot
            } else { xmlSchemaFreeAnnot(annot); }
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"import\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            tmpOldErrs = (*ctxt).nberrors;
            res = xmlSchemaParseImport(ctxt, schema, child);
            if res == -(1 as std::os::raw::c_int) {
                current_block = 3038220177365766051;
                break ;
            }
            if (*ctxt).stop != 0 {
                current_block = 7196715760208360122;
                break ;
            }
            if tmpOldErrs != (*ctxt).nberrors {
                current_block = 7196715760208360122;
                break ;
            }
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"include\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            tmpOldErrs = (*ctxt).nberrors;
            res = xmlSchemaParseInclude(ctxt, schema, child);
            if res == -(1 as std::os::raw::c_int) {
                current_block = 3038220177365766051;
                break ;
            }
            if (*ctxt).stop != 0 {
                current_block = 7196715760208360122;
                break ;
            }
            if tmpOldErrs != (*ctxt).nberrors {
                current_block = 7196715760208360122;
                break ;
            }
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"redefine\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            tmpOldErrs = (*ctxt).nberrors;
            res = xmlSchemaParseRedefine(ctxt, schema, child);
            if res == -(1 as std::os::raw::c_int) {
                current_block = 3038220177365766051;
                break ;
            }
            if (*ctxt).stop != 0 {
                current_block = 7196715760208360122;
                break ;
            }
            if tmpOldErrs != (*ctxt).nberrors {
                current_block = 7196715760208360122;
                break ;
            }
        }
        child = (*child).next
    }
    match current_block {
        14832935472441733737 => {
            /*
    * URGENT TODO: Change the functions to return int results.
    * We need especially to catch internal errors.
    */
            while !child.is_null() {
                if !child.is_null() && !(*child).ns.is_null() &&
                       xmlStrEqual((*child).name,
                                   b"complexType\x00" as *const u8 as
                                       *const std::os::raw::c_char as *const xmlChar)
                           != 0 &&
                       xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                    xmlSchemaParseComplexType(ctxt, schema, child,
                                              1 as std::os::raw::c_int);
                    child = (*child).next
                } else if !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"simpleType\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 {
                    xmlSchemaParseSimpleType(ctxt, schema, child,
                                             1 as std::os::raw::c_int);
                    child = (*child).next
                } else if !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"element\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 {
                    xmlSchemaParseElement(ctxt, schema, child,
                                          0 as *mut std::os::raw::c_int,
                                          1 as std::os::raw::c_int);
                    child = (*child).next
                } else if !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"attribute\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 {
                    xmlSchemaParseGlobalAttribute(ctxt, schema, child);
                    child = (*child).next
                } else if !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"attributeGroup\x00" as *const u8
                                              as *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 {
                    xmlSchemaParseAttributeGroupDefinition(ctxt, schema,
                                                           child);
                    child = (*child).next
                } else if !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"group\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 {
                    xmlSchemaParseModelGroupDefinition(ctxt, schema, child);
                    child = (*child).next
                } else if !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"notation\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 {
                    xmlSchemaParseNotation(ctxt, schema, child);
                    child = (*child).next
                } else {
                    xmlSchemaPContentErr(ctxt,
                                         XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr,
                                         (*child).parent, child,
                                         0 as *const std::os::raw::c_char,
                                         b"((include | import | redefine | annotation)*, (((simpleType | complexType | group | attributeGroup) | element | attribute | notation), annotation*)*)\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    child = (*child).next
                }
                while !child.is_null() && !(*child).ns.is_null() &&
                          xmlStrEqual((*child).name,
                                      b"annotation\x00" as *const u8 as
                                          *const std::os::raw::c_char as
                                          *const xmlChar) != 0 &&
                          xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                    /*
	    * TODO: We should add all annotations.
	    */
                    annot =
                        xmlSchemaParseAnnotation(ctxt, child,
                                                 1 as std::os::raw::c_int);
                    if (*schema).annot.is_null() {
                        (*schema).annot = annot
                    } else { xmlSchemaFreeAnnot(annot); }
                    child = (*child).next
                }
            }
        }
        3038220177365766051 => { return -(1 as std::os::raw::c_int) }
        _ => { }
    }
    (*ctxt).ctxtType = 0 as xmlSchemaTypePtr;
    if oldErrs != (*ctxt).nberrors { res = (*ctxt).err }
    return res;
}
unsafe extern "C" fn xmlSchemaSchemaRelationCreate()
 -> xmlSchemaSchemaRelationPtr {
    let mut ret: xmlSchemaSchemaRelationPtr =
        0 as *mut xmlSchemaSchemaRelation;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaSchemaRelation>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaSchemaRelationPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                            b"allocating schema relation\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaSchemaRelationPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaSchemaRelation>() as std::os::raw::c_ulong);
    return ret;
}
unsafe extern "C" fn xmlSchemaRedefListFree(mut redef: xmlSchemaRedefPtr) {
    let mut prev: xmlSchemaRedefPtr = 0 as *mut xmlSchemaRedef;
    while !redef.is_null() {
        prev = redef;
        redef = (*redef).next;
        xmlFree.expect("non-null function pointer")(prev as
                                                        *mut std::os::raw::c_void);
    };
}
unsafe extern "C" fn xmlSchemaConstructionCtxtFree(mut con:
                                                       xmlSchemaConstructionCtxtPtr) {
    /*
    * After the construction context has been freed, there will be
    * no schema graph available any more. Only the schema buckets
    * will stay alive, which are put into the "schemasImports" and
    * "includes" slots of the xmlSchema.
    */
    if !(*con).buckets.is_null() { xmlSchemaItemListFree((*con).buckets); }
    if !(*con).pending.is_null() { xmlSchemaItemListFree((*con).pending); }
    if !(*con).substGroups.is_null() {
        xmlHashFree((*con).substGroups,
                    Some(xmlSchemaSubstGroupFreeEntry as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *const xmlChar) -> ()));
    }
    if !(*con).redefs.is_null() { xmlSchemaRedefListFree((*con).redefs); }
    if !(*con).dict.is_null() { xmlDictFree((*con).dict); }
    xmlFree.expect("non-null function pointer")(con as *mut std::os::raw::c_void);
}
unsafe extern "C" fn xmlSchemaConstructionCtxtCreate(mut dict: xmlDictPtr)
 -> xmlSchemaConstructionCtxtPtr {
    let mut ret: xmlSchemaConstructionCtxtPtr =
        0 as *mut xmlSchemaConstructionCtxt;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaConstructionCtxt>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaConstructionCtxtPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                            b"allocating schema construction context\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaConstructionCtxtPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaConstructionCtxt>() as
               std::os::raw::c_ulong);
    (*ret).buckets = xmlSchemaItemListCreate();
    if (*ret).buckets.is_null() {
        xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                            b"allocating list of schema buckets\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        xmlFree.expect("non-null function pointer")(ret as *mut std::os::raw::c_void);
        return 0 as xmlSchemaConstructionCtxtPtr
    }
    (*ret).pending = xmlSchemaItemListCreate();
    if (*ret).pending.is_null() {
        xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                            b"allocating list of pending global components\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        xmlSchemaConstructionCtxtFree(ret);
        return 0 as xmlSchemaConstructionCtxtPtr
    }
    (*ret).dict = dict;
    xmlDictReference(dict);
    return ret;
}
unsafe extern "C" fn xmlSchemaParserCtxtCreate() -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaParserCtxt>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaParserCtxtPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                            b"allocating schema parser context\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaParserCtxtPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaParserCtxt>() as std::os::raw::c_ulong);
    (*ret).type_0 = 1 as std::os::raw::c_int;
    (*ret).attrProhibs = xmlSchemaItemListCreate();
    if (*ret).attrProhibs.is_null() {
        xmlFree.expect("non-null function pointer")(ret as *mut std::os::raw::c_void);
        return 0 as xmlSchemaParserCtxtPtr
    }
    return ret;
}
/* *
 * xmlSchemaNewParserCtxtUseDict:
 * @URL:  the location of the schema
 * @dict: the dictionary to be used
 *
 * Create an XML Schemas parse context for that file/resource expected
 * to contain an XML Schemas file.
 *
 * Returns the parser context or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaNewParserCtxtUseDict(mut URL:
                                                       *const std::os::raw::c_char,
                                                   mut dict: xmlDictPtr)
 -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() { return 0 as xmlSchemaParserCtxtPtr }
    (*ret).dict = dict;
    xmlDictReference(dict);
    if !URL.is_null() {
        (*ret).URL =
            xmlDictLookup(dict, URL as *const xmlChar, -(1 as std::os::raw::c_int))
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCreatePCtxtOnVCtxt(mut vctxt:
                                                     xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    if (*vctxt).pctxt.is_null() {
        if !(*vctxt).schema.is_null() {
            (*vctxt).pctxt =
                xmlSchemaNewParserCtxtUseDict(b"*\x00" as *const u8 as
                                                  *const std::os::raw::c_char,
                                              (*(*vctxt).schema).dict)
        } else {
            (*vctxt).pctxt =
                xmlSchemaNewParserCtxt(b"*\x00" as *const u8 as
                                           *const std::os::raw::c_char)
        }
        if (*vctxt).pctxt.is_null() {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaCreatePCtxtOnVCtxt\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"failed to create a temp. parser context\x00"
                                     as *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        /* TODO: Pass user data. */
        xmlSchemaSetParserErrors((*vctxt).pctxt, (*vctxt).error,
                                 (*vctxt).warning, (*vctxt).errCtxt);
        xmlSchemaSetParserStructuredErrors((*vctxt).pctxt, (*vctxt).serror,
                                           (*vctxt).errCtxt);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaGetSchemaBucket:
 * @pctxt: the schema parser context
 * @schemaLocation: the URI of the schema document
 *
 * Returns a schema bucket if it was already parsed.
 *
 * Returns a schema bucket if it was already parsed from
 *         @schemaLocation, NULL otherwise.
 */
unsafe extern "C" fn xmlSchemaGetSchemaBucket(mut pctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut schemaLocation:
                                                  *const xmlChar)
 -> xmlSchemaBucketPtr {
    let mut cur: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut list: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    list = (*(*pctxt).constructor).buckets;
    if (*list).nbItems == 0 as std::os::raw::c_int {
        return 0 as xmlSchemaBucketPtr
    } else {
        let mut i: std::os::raw::c_int = 0;
        i = 0 as std::os::raw::c_int;
        while i < (*list).nbItems {
            cur = *(*list).items.offset(i as isize) as xmlSchemaBucketPtr;
            /* Pointer comparison! */
            if (*cur).schemaLocation == schemaLocation { return cur }
            i += 1
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
unsafe extern "C" fn xmlSchemaGetChameleonSchemaBucket(mut pctxt:
                                                           xmlSchemaParserCtxtPtr,
                                                       mut schemaLocation:
                                                           *const xmlChar,
                                                       mut targetNamespace:
                                                           *const xmlChar)
 -> xmlSchemaBucketPtr {
    let mut cur: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut list: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    list = (*(*pctxt).constructor).buckets;
    if (*list).nbItems == 0 as std::os::raw::c_int {
        return 0 as xmlSchemaBucketPtr
    } else {
        let mut i: std::os::raw::c_int = 0;
        i = 0 as std::os::raw::c_int;
        while i < (*list).nbItems {
            cur = *(*list).items.offset(i as isize) as xmlSchemaBucketPtr;
            /* Pointer comparison! */
            if (*cur).origTargetNamespace.is_null() &&
                   (*cur).schemaLocation == schemaLocation &&
                   (*cur).targetNamespace == targetNamespace {
                return cur
            }
            i += 1
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
unsafe extern "C" fn xmlSchemaGetSchemaBucketByTNS(mut pctxt:
                                                       xmlSchemaParserCtxtPtr,
                                                   mut targetNamespace:
                                                       *const xmlChar,
                                                   mut imported: std::os::raw::c_int)
 -> xmlSchemaBucketPtr {
    let mut cur: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut list: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    list = (*(*pctxt).constructor).buckets;
    if (*list).nbItems == 0 as std::os::raw::c_int {
        return 0 as xmlSchemaBucketPtr
    } else {
        let mut i: std::os::raw::c_int = 0;
        i = 0 as std::os::raw::c_int;
        while i < (*list).nbItems {
            cur = *(*list).items.offset(i as isize) as xmlSchemaBucketPtr;
            if !((*cur).doc.is_null() && !(*cur).schemaLocation.is_null()) &&
                   (*cur).origTargetNamespace == targetNamespace &&
                   (imported != 0 && (*cur).imported != 0 ||
                        imported == 0 && (*cur).imported == 0) {
                return cur
            }
            i += 1
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
unsafe extern "C" fn xmlSchemaParseNewDocWithContext(mut pctxt:
                                                         xmlSchemaParserCtxtPtr,
                                                     mut schema: xmlSchemaPtr,
                                                     mut bucket:
                                                         xmlSchemaBucketPtr)
 -> std::os::raw::c_int {
    let mut oldFlags: std::os::raw::c_int = 0;
    let mut oldDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut ret: std::os::raw::c_int = 0;
    let mut oldErrs: std::os::raw::c_int = 0;
    let mut oldbucket: xmlSchemaBucketPtr = (*(*pctxt).constructor).bucket;
    /*
    * Save old values; reset the *main* schema.
    * URGENT TODO: This is not good; move the per-document information
    * to the parser. Get rid of passing the main schema to the
    * parsing functions.
    */
    oldFlags = (*schema).flags;
    oldDoc = (*schema).doc;
    if (*schema).flags != 0 as std::os::raw::c_int {
        xmlSchemaClearSchemaDefaults(schema);
    }
    (*schema).doc = (*bucket).doc;
    (*pctxt).schema = schema;
    /*
    * Keep the current target namespace on the parser *not* on the
    * main schema.
    */
    (*pctxt).targetNamespace = (*bucket).targetNamespace;
    (*(*pctxt).constructor).bucket = bucket;
    if !(*bucket).targetNamespace.is_null() &&
           xmlStrEqual((*bucket).targetNamespace, xmlSchemaNs) != 0 {
        /*
	* We are parsing the schema for schemas!
	*/
        (*pctxt).isS4S = 1 as std::os::raw::c_int
    }
    /* Mark it as parsed, even if parsing fails. */
    (*bucket).parsed += 1;
    /* Compile the schema doc. */
    node = xmlDocGetRootElement((*bucket).doc as *const xmlDoc);
    ret = xmlSchemaParseSchemaElement(pctxt, schema, node);
    if !(ret != 0 as std::os::raw::c_int) {
        /* An empty schema; just get out. */
        if !(*node).children.is_null() {
            oldErrs = (*pctxt).nberrors;
            ret =
                xmlSchemaParseSchemaTopLevel(pctxt, schema, (*node).children);
            if !(ret != 0 as std::os::raw::c_int) {
                /*
    * TODO: Not nice, but I'm not 100% sure we will get always an error
    * as a result of the obove functions; so better rely on pctxt->err
    * as well.
    */
                if ret == 0 as std::os::raw::c_int && oldErrs != (*pctxt).nberrors {
                    ret = (*pctxt).err
                }
            }
        }
    }
    (*(*pctxt).constructor).bucket = oldbucket;
    /* Restore schema values. */
    (*schema).doc = oldDoc;
    (*schema).flags = oldFlags;
    return ret;
}
unsafe extern "C" fn xmlSchemaParseNewDoc(mut pctxt: xmlSchemaParserCtxtPtr,
                                          mut schema: xmlSchemaPtr,
                                          mut bucket: xmlSchemaBucketPtr)
 -> std::os::raw::c_int {
    let mut newpctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut res: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if bucket.is_null() { return 0 as std::os::raw::c_int }
    if (*bucket).parsed != 0 {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaParseNewDoc\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"reparsing a schema doc\x00" as *const u8 as
                                 *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    if (*bucket).doc.is_null() {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaParseNewDoc\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"parsing a schema doc, but there\'s no doc\x00"
                                 as *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    if (*pctxt).constructor.is_null() {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaParseNewDoc\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"no constructor\x00" as *const u8 as
                                 *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    /* Create and init the temporary parser context. */
    newpctxt =
        xmlSchemaNewParserCtxtUseDict((*bucket).schemaLocation as
                                          *const std::os::raw::c_char, (*pctxt).dict);
    if newpctxt.is_null() { return -(1 as std::os::raw::c_int) }
    (*newpctxt).constructor = (*pctxt).constructor;
    /*
    * TODO: Can we avoid that the parser knows about the main schema?
    * It would be better if he knows about the current schema bucket
    * only.
    */
    (*newpctxt).schema = schema;
    xmlSchemaSetParserErrors(newpctxt, (*pctxt).error, (*pctxt).warning,
                             (*pctxt).errCtxt);
    xmlSchemaSetParserStructuredErrors(newpctxt, (*pctxt).serror,
                                       (*pctxt).errCtxt);
    (*newpctxt).counter = (*pctxt).counter;
    res = xmlSchemaParseNewDocWithContext(newpctxt, schema, bucket);
    /* Channel back errors and cleanup the temporary parser context. */
    if res != 0 as std::os::raw::c_int { (*pctxt).err = res }
    (*pctxt).nberrors += (*newpctxt).nberrors;
    (*pctxt).counter = (*newpctxt).counter;
    (*newpctxt).constructor = 0 as xmlSchemaConstructionCtxtPtr;
    /* Free the parser context. */
    xmlSchemaFreeParserCtxt(newpctxt);
    return res;
}
unsafe extern "C" fn xmlSchemaSchemaRelationAddChild(mut bucket:
                                                         xmlSchemaBucketPtr,
                                                     mut rel:
                                                         xmlSchemaSchemaRelationPtr) {
    let mut cur: xmlSchemaSchemaRelationPtr = (*bucket).relations;
    if cur.is_null() { (*bucket).relations = rel; return }
    while !(*cur).next.is_null() { cur = (*cur).next }
    (*cur).next = rel;
}
unsafe extern "C" fn xmlSchemaBuildAbsoluteURI(mut dict: xmlDictPtr,
                                               mut location: *const xmlChar,
                                               mut ctxtNode: xmlNodePtr)
 -> *const xmlChar {
    /*
    * Build an absolue location URI.
    */
    if !location.is_null() {
        if ctxtNode.is_null() {
            return location
        } else {
            let mut base: *mut xmlChar = 0 as *mut xmlChar;
            let mut URI: *mut xmlChar = 0 as *mut xmlChar;
            let mut ret: *const xmlChar = 0 as *const xmlChar;
            base =
                xmlNodeGetBase((*ctxtNode).doc, ctxtNode as *const xmlNode);
            if base.is_null() {
                URI = xmlBuildURI(location, (*(*ctxtNode).doc).URL)
            } else {
                URI = xmlBuildURI(location, base);
                xmlFree.expect("non-null function pointer")(base as
                                                                *mut std::os::raw::c_void);
            }
            if !URI.is_null() {
                ret = xmlDictLookup(dict, URI, -(1 as std::os::raw::c_int));
                xmlFree.expect("non-null function pointer")(URI as
                                                                *mut std::os::raw::c_void);
                return ret
            }
        }
    }
    return 0 as *const xmlChar;
}
/* *
 * xmlSchemaAddSchemaDoc:
 * @pctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * Parse an included (and to-be-redefined) XML schema document.
 *
 * Returns 0 on success, a positive error code on errors and
 *         -1 in case of an internal or API error.
 */
unsafe extern "C" fn xmlSchemaAddSchemaDoc(mut pctxt: xmlSchemaParserCtxtPtr,
                                           mut type_0: std::os::raw::c_int,
                                           mut schemaLocation: *const xmlChar,
                                           mut schemaDoc: xmlDocPtr,
                                           mut schemaBuffer:
                                               *const std::os::raw::c_char,
                                           mut schemaBufferLen: std::os::raw::c_int,
                                           mut invokingNode: xmlNodePtr,
                                           mut sourceTargetNamespace:
                                               *const xmlChar,
                                           mut importNamespace:
                                               *const xmlChar,
                                           mut bucket:
                                               *mut xmlSchemaBucketPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut targetNamespace: *const xmlChar = 0 as *const xmlChar;
    let mut relation: xmlSchemaSchemaRelationPtr =
        0 as xmlSchemaSchemaRelationPtr;
    let mut doc: xmlDocPtr = 0 as xmlDocPtr;
    let mut res: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut err: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut located: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut preserveDoc: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut bkt: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if !bucket.is_null() { *bucket = 0 as xmlSchemaBucketPtr }
    match type_0 {
        1 | 0 => { err = XML_SCHEMAP_SRC_IMPORT as std::os::raw::c_int }
        2 => { err = XML_SCHEMAP_SRC_INCLUDE as std::os::raw::c_int }
        3 => { err = XML_SCHEMAP_SRC_REDEFINE as std::os::raw::c_int }
        _ => { }
    }
    /* Special handling for the main schema:
    * skip the location and relation logic and just parse the doc.
    * We need just a bucket to be returned in this case.
    */
    if type_0 == 0 as std::os::raw::c_int ||
           !(!(*(*pctxt).constructor).buckets.is_null() &&
                 (*(*(*pctxt).constructor).buckets).nbItems >
                     0 as std::os::raw::c_int) {
        current_block = 12232590996125682962;
    } else {
        /* Note that we expect the location to be an absulute URI. */
        if !schemaLocation.is_null() {
            bkt = xmlSchemaGetSchemaBucket(pctxt, schemaLocation);
            if !bkt.is_null() && (*(*pctxt).constructor).bucket == bkt {
                /* Report self-imports/inclusions/redefinitions. */
                xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                   err as xmlParserErrors, invokingNode,
                                   0 as xmlSchemaBasicItemPtr,
                                   b"The schema must not import/include/redefine itself\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   0 as *const xmlChar, 0 as *const xmlChar);
                current_block = 13825201488500399674;
            } else { current_block = 17833034027772472439; }
        } else { current_block = 17833034027772472439; }
        match current_block {
            13825201488500399674 => { }
            _ => {
                /*
    * Create a relation for the graph of schemas.
    */
                relation = xmlSchemaSchemaRelationCreate();
                if relation.is_null() { return -(1 as std::os::raw::c_int) }
                xmlSchemaSchemaRelationAddChild((*(*pctxt).constructor).bucket,
                                                relation);
                (*relation).type_0 = type_0;
                /*
    * Save the namespace import information.
    */
                if type_0 == 0 as std::os::raw::c_int || type_0 == 1 as std::os::raw::c_int {
                    (*relation).importNamespace = importNamespace;
                    if schemaLocation.is_null() {
                        current_block = 13825201488500399674;
                    } else {
                        targetNamespace = importNamespace;
                        current_block = 7056779235015430508;
                    }
                } else { current_block = 7056779235015430508; }
                match current_block {
                    13825201488500399674 => { }
                    _ =>
                    /* Did we already fetch the doc? */
                    {
                        if !bkt.is_null() {
                            if (type_0 == 0 as std::os::raw::c_int ||
                                    type_0 == 1 as std::os::raw::c_int) &&
                                   (*bkt).imported == 0 {
                                /*
	    * We included/redefined and then try to import a schema,
	    * but the new location provided for import was different.
	    */
                                if schemaLocation.is_null() {
                                    schemaLocation =
                                        b"in_memory_buffer\x00" as *const u8
                                            as *const std::os::raw::c_char as
                                            *mut xmlChar
                                }
                                if xmlStrEqual(schemaLocation,
                                               (*bkt).schemaLocation) == 0 {
                                    xmlSchemaCustomErr(pctxt as
                                                           xmlSchemaAbstractCtxtPtr,
                                                       err as xmlParserErrors,
                                                       invokingNode,
                                                       0 as
                                                           xmlSchemaBasicItemPtr,
                                                       b"The schema document \'%s\' cannot be imported, since it was already included or redefined\x00"
                                                           as *const u8 as
                                                           *const std::os::raw::c_char,
                                                       schemaLocation,
                                                       0 as *const xmlChar);
                                    current_block = 13825201488500399674;
                                } else {
                                    current_block = 6450597802325118133;
                                }
                            } else if !(type_0 == 0 as std::os::raw::c_int ||
                                            type_0 == 1 as std::os::raw::c_int) &&
                                          (*bkt).imported != 0 {
                                /*
	    * We imported and then try to include/redefine a schema,
	    * but the new location provided for the include/redefine
	    * was different.
	    */
                                if schemaLocation.is_null() {
                                    schemaLocation =
                                        b"in_memory_buffer\x00" as *const u8
                                            as *const std::os::raw::c_char as
                                            *mut xmlChar
                                }
                                if xmlStrEqual(schemaLocation,
                                               (*bkt).schemaLocation) == 0 {
                                    xmlSchemaCustomErr(pctxt as
                                                           xmlSchemaAbstractCtxtPtr,
                                                       err as xmlParserErrors,
                                                       invokingNode,
                                                       0 as
                                                           xmlSchemaBasicItemPtr,
                                                       b"The schema document \'%s\' cannot be included or redefined, since it was already imported\x00"
                                                           as *const u8 as
                                                           *const std::os::raw::c_char,
                                                       schemaLocation,
                                                       0 as *const xmlChar);
                                    current_block = 13825201488500399674;
                                } else {
                                    current_block = 6450597802325118133;
                                }
                            } else { current_block = 6450597802325118133; }
                        } else { current_block = 6450597802325118133; }
                        match current_block {
                            13825201488500399674 => { }
                            _ => {
                                if type_0 == 0 as std::os::raw::c_int ||
                                       type_0 == 1 as std::os::raw::c_int {
                                    /*
	* Given that the schemaLocation [attribute] is only a hint, it is open
	* to applications to ignore all but the first <import> for a given
	* namespace, regardless of the `actual value` of schemaLocation, but
	* such a strategy risks missing useful information when new
	* schemaLocations are offered.
	*
	* We will use the first <import> that comes with a location.
	* Further <import>s *with* a location, will result in an error.
	* TODO: Better would be to just report a warning here, but
	* we'll try it this way until someone complains.
	*
	* Schema Document Location Strategy:
	* 3 Based on the namespace name, identify an existing schema document,
	* either as a resource which is an XML document or a <schema> element
	* information item, in some local schema repository;
	* 5 Attempt to resolve the namespace name to locate such a resource.
	*
	* NOTE: (3) and (5) are not supported.
	*/
                                    if !bkt.is_null() {
                                        (*relation).bucket = bkt;
                                        current_block = 13825201488500399674;
                                    } else {
                                        bkt =
                                            xmlSchemaGetSchemaBucketByTNS(pctxt,
                                                                          importNamespace,
                                                                          1 as
                                                                              std::os::raw::c_int);
                                        if !bkt.is_null() {
                                            (*relation).bucket = bkt;
                                            if (*bkt).schemaLocation.is_null()
                                               {
                                                /* First given location of the schema; load the doc. */
                                                (*bkt).schemaLocation =
                                                    schemaLocation;
                                                current_block =
                                                    8869332144787829186;
                                            } else {
                                                if xmlStrEqual(schemaLocation,
                                                               (*bkt).schemaLocation)
                                                       == 0 {
                                                    /*
		    * Additional location given; just skip it.
		    * URGENT TODO: We should report a warning here.
		    * res = XML_SCHEMAP_SRC_IMPORT;
		    */
                                                    if schemaLocation.is_null()
                                                       {
                                                        schemaLocation =
                                                            b"in_memory_buffer\x00"
                                                                as *const u8
                                                                as
                                                                *const std::os::raw::c_char
                                                                as
                                                                *mut xmlChar
                                                    }
                                                    xmlSchemaCustomWarning(pctxt
                                                                               as
                                                                               xmlSchemaAbstractCtxtPtr,
                                                                           XML_SCHEMAP_WARN_SKIP_SCHEMA,
                                                                           invokingNode,
                                                                           0
                                                                               as
                                                                               xmlSchemaTypePtr,
                                                                           b"Skipping import of schema located at \'%s\' for the namespace \'%s\', since this namespace was already imported with the schema located at \'%s\'\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char,
                                                                           schemaLocation,
                                                                           importNamespace,
                                                                           (*bkt).schemaLocation);
                                                }
                                                current_block =
                                                    13825201488500399674;
                                            }
                                        } else {
                                            current_block =
                                                8869332144787829186;
                                        }
                                    }
                                    /*
	* No bucket + first location: load the doc and create a
	* bucket.
	*/
                                } else if !bkt.is_null() {
                                    if (*bkt).origTargetNamespace.is_null() &&
                                           (*bkt).targetNamespace !=
                                               sourceTargetNamespace {
                                        let mut chamel: xmlSchemaBucketPtr =
                                            0 as *mut xmlSchemaBucket;
                                        /* <include> and <redefine> */
                                        /*
		* Chameleon include/redefine: skip loading only if it was
		* aleady build for the targetNamespace of the including
		* schema.
		*/
		/*
		* URGENT TODO: If the schema is a chameleon-include then copy
		* the components into the including schema and modify the
		* targetNamespace of those components, do nothing otherwise.
		* NOTE: This is currently worked-around by compiling the
		* chameleon for every destinct including targetNamespace; thus
		* not performant at the moment.
		* TODO: Check when the namespace in wildcards for chameleons
		* needs to be converted: before we built wildcard intersections
		* or after.
		*   Answer: after!
		*/
                                        chamel =
                                            xmlSchemaGetChameleonSchemaBucket(pctxt,
                                                                              schemaLocation,
                                                                              sourceTargetNamespace);
                                        if !chamel.is_null() {
                                            /* A fitting chameleon was already parsed; NOP. */
                                            (*relation).bucket = chamel;
                                            current_block =
                                                13825201488500399674;
                                        } else {
                                            /*
		* We need to parse the chameleon again for a different
		* targetNamespace.
		* CHAMELEON TODO: Optimize this by only parsing the
		* chameleon once, and then copying the components to
		* the new targetNamespace.
		*/
                                            bkt = 0 as xmlSchemaBucketPtr;
                                            current_block =
                                                8869332144787829186;
                                        }
                                    } else {
                                        (*relation).bucket = bkt;
                                        current_block = 13825201488500399674;
                                    }
                                } else {
                                    current_block = 8869332144787829186;
                                }
                                match current_block {
                                    13825201488500399674 => { }
                                    _ => {
                                        if !bkt.is_null() &&
                                               !(*bkt).doc.is_null() {
                                            xmlSchemaInternalErr(pctxt as
                                                                     xmlSchemaAbstractCtxtPtr,
                                                                 b"xmlSchemaAddSchemaDoc\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const std::os::raw::c_char,
                                                                 b"trying to load a schema doc, but a doc is already assigned to the schema bucket\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const std::os::raw::c_char);
                                            current_block =
                                                5726555954411397261;
                                        } else {
                                            current_block =
                                                12232590996125682962;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        12232590996125682962 =>
        /*
    * Load the document.
    */
        {
            if !schemaDoc.is_null() {
                doc = schemaDoc;
                /* Don' free this one, since it was provided by the caller. */
                preserveDoc = 1 as std::os::raw::c_int;
                /* TODO: Does the context or the doc hold the location? */
                if !(*schemaDoc).URL.is_null() {
                    schemaLocation =
                        xmlDictLookup((*pctxt).dict, (*schemaDoc).URL,
                                      -(1 as std::os::raw::c_int))
                } else {
                    schemaLocation =
                        b"in_memory_buffer\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut xmlChar
                }
                current_block = 14851765859726653900;
            } else if !schemaLocation.is_null() || !schemaBuffer.is_null() {
                let mut parserCtxt: xmlParserCtxtPtr =
                    0 as *mut xmlParserCtxt;
                parserCtxt = xmlNewParserCtxt();
                if parserCtxt.is_null() {
                    xmlSchemaPErrMemory(0 as xmlSchemaParserCtxtPtr,
                                        b"xmlSchemaGetDoc, allocating a parser context\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as xmlNodePtr);
                    current_block = 5726555954411397261;
                } else {
                    if !(*pctxt).dict.is_null() &&
                           !(*parserCtxt).dict.is_null() {
                        /*
	    * TODO: Do we have to burden the schema parser dict with all
	    * the content of the schema doc?
	    */
                        xmlDictFree((*parserCtxt).dict);
                        (*parserCtxt).dict = (*pctxt).dict;
                        xmlDictReference((*parserCtxt).dict);
                    }
                    if !schemaLocation.is_null() {
                        /* Parse from file. */
                        doc =
                            xmlCtxtReadFile(parserCtxt,
                                            schemaLocation as
                                                *const std::os::raw::c_char,
                                            0 as *const std::os::raw::c_char,
                                            XML_PARSE_NOENT as std::os::raw::c_int)
                    } else if !schemaBuffer.is_null() {
                        /* Parse from memory buffer. */
                        doc =
                            xmlCtxtReadMemory(parserCtxt, schemaBuffer,
                                              schemaBufferLen,
                                              0 as *const std::os::raw::c_char,
                                              0 as *const std::os::raw::c_char,
                                              XML_PARSE_NOENT as std::os::raw::c_int);
                        schemaLocation =
                            b"in_memory_buffer\x00" as *const u8 as
                                *const std::os::raw::c_char as *mut xmlChar;
                        if !doc.is_null() {
                            (*doc).URL = xmlStrdup(schemaLocation)
                        }
                    }
                    /*
	* For <import>:
	* 2.1 The referent is (a fragment of) a resource which is an
	* XML document (see clause 1.1), which in turn corresponds to
	* a <schema> element information item in a well-formed information
	* set, which in turn corresponds to a valid schema.
	* TODO: (2.1) fragments of XML documents are not supported.
	*
	* 2.2 The referent is a <schema> element information item in
	* a well-formed information set, which in turn corresponds
	* to a valid schema.
	* TODO: (2.2) is not supported.
	*/
                    if doc.is_null() {
                        let mut lerr: xmlErrorPtr = 0 as *mut xmlError;
                        lerr = xmlGetLastError();
                        /*
	    * Check if this a parser error, or if the document could
	    * just not be located.
	    * TODO: Try to find specific error codes to react only on
	    * localisation failures.
	    */
                        if lerr.is_null() ||
                               (*lerr).domain != XML_FROM_IO as std::os::raw::c_int {
                            /*
		* We assume a parser error here.
		*/
                            located = 1 as std::os::raw::c_int;
                            /* TODO: Error code ?? */
                            res = XML_SCHEMAP_SRC_IMPORT_2_1 as std::os::raw::c_int;
                            xmlSchemaCustomErr(pctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               res as xmlParserErrors,
                                               invokingNode,
                                               0 as xmlSchemaBasicItemPtr,
                                               b"Failed to parse the XML resource \'%s\'\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               schemaLocation,
                                               0 as *const xmlChar);
                        }
                    }
                    xmlFreeParserCtxt(parserCtxt);
                    if doc.is_null() && located != 0 {
                        current_block = 15627183366360908572;
                    } else { current_block = 14851765859726653900; }
                }
            } else {
                xmlSchemaPErr(pctxt, 0 as xmlNodePtr,
                              XML_SCHEMAP_NOTHING_TO_PARSE as std::os::raw::c_int,
                              b"No information for parsing was provided with the given schema parser context.\n\x00"
                                  as *const u8 as *const std::os::raw::c_char,
                              0 as *const xmlChar, 0 as *const xmlChar);
                current_block = 5726555954411397261;
            }
            match current_block {
                5726555954411397261 => { }
                _ => {
                    match current_block {
                        14851765859726653900 =>
                        /*
    * Preprocess the document.
    */
                        {
                            if !doc.is_null() {
                                let mut docElem: xmlNodePtr = 0 as xmlNodePtr;
                                located = 1 as std::os::raw::c_int;
                                docElem =
                                    xmlDocGetRootElement(doc as
                                                             *const xmlDoc);
                                if docElem.is_null() {
                                    xmlSchemaCustomErr(pctxt as
                                                           xmlSchemaAbstractCtxtPtr,
                                                       XML_SCHEMAP_NOROOT,
                                                       invokingNode,
                                                       0 as
                                                           xmlSchemaBasicItemPtr,
                                                       b"The document \'%s\' has no document element\x00"
                                                           as *const u8 as
                                                           *const std::os::raw::c_char,
                                                       schemaLocation,
                                                       0 as *const xmlChar);
                                    current_block = 15627183366360908572;
                                } else {
                                    /*
	* Remove all the blank text nodes.
	*/
                                    xmlSchemaCleanupDoc(pctxt, docElem);
                                    /*
	* Check the schema's top level element.
	*/
                                    if !(!docElem.is_null() &&
                                             !(*docElem).ns.is_null() &&
                                             xmlStrEqual((*docElem).name,
                                                         b"schema\x00" as
                                                             *const u8 as
                                                             *const std::os::raw::c_char
                                                             as
                                                             *const xmlChar)
                                                 != 0 &&
                                             xmlStrEqual((*(*docElem).ns).href,
                                                         xmlSchemaNs) != 0) {
                                        xmlSchemaCustomErr(pctxt as
                                                               xmlSchemaAbstractCtxtPtr,
                                                           XML_SCHEMAP_NOT_SCHEMA,
                                                           invokingNode,
                                                           0 as
                                                               xmlSchemaBasicItemPtr,
                                                           b"The XML document \'%s\' is not a schema document\x00"
                                                               as *const u8 as
                                                               *const std::os::raw::c_char,
                                                           schemaLocation,
                                                           0 as
                                                               *const xmlChar);
                                        current_block = 15627183366360908572;
                                    } else {
                                        /*
	* Note that we don't apply a type check for the
	* targetNamespace value here.
	*/
                                        targetNamespace =
                                            xmlSchemaGetProp(pctxt, docElem,
                                                             b"targetNamespace\x00"
                                                                 as *const u8
                                                                 as
                                                                 *const std::os::raw::c_char);
                                        current_block = 2956972668325154207;
                                    }
                                }
                            } else { current_block = 2956972668325154207; }
                            match current_block {
                                15627183366360908572 => { }
                                _ =>
                                /* after_doc_loading: */
                                {
                                    if bkt.is_null() && located != 0 {
                                        /* Only create a bucket if the schema was located. */
                                        bkt =
                                            xmlSchemaBucketCreate(pctxt,
                                                                  type_0,
                                                                  targetNamespace);
                                        if bkt.is_null() {
                                            current_block =
                                                5726555954411397261;
                                        } else {
                                            current_block =
                                                13505557363059842426;
                                        }
                                    } else {
                                        current_block = 13505557363059842426;
                                    }
                                    match current_block {
                                        5726555954411397261 => { }
                                        _ => {
                                            if !bkt.is_null() {
                                                (*bkt).schemaLocation =
                                                    schemaLocation;
                                                (*bkt).located = located;
                                                if !doc.is_null() {
                                                    (*bkt).doc = doc;
                                                    (*bkt).targetNamespace =
                                                        targetNamespace;
                                                    (*bkt).origTargetNamespace
                                                        = targetNamespace;
                                                    if preserveDoc != 0 {
                                                        (*bkt).preserveDoc =
                                                            1 as std::os::raw::c_int
                                                    }
                                                }
                                                if type_0 == 0 as std::os::raw::c_int
                                                       ||
                                                       type_0 ==
                                                           1 as std::os::raw::c_int {
                                                    (*bkt).imported += 1
                                                }
                                                /*
	    * Add it to the graph of schemas.
	    */
                                                if !relation.is_null() {
                                                    (*relation).bucket = bkt
                                                }
                                            }
                                            current_block =
                                                13825201488500399674;
                                        }
                                    }
                                }
                            }
                        }
                        _ => { }
                    }
                    match current_block {
                        13825201488500399674 => { }
                        5726555954411397261 => { }
                        _ => {
                            if !doc.is_null() && preserveDoc == 0 {
                                xmlFreeDoc(doc);
                                if !bkt.is_null() {
                                    (*bkt).doc = 0 as xmlDocPtr
                                }
                            }
                            return (*pctxt).err
                        }
                    }
                }
            }
        }
        _ => { }
    }
    match current_block {
        5726555954411397261 => {
            if !doc.is_null() && preserveDoc == 0 {
                xmlFreeDoc(doc);
                if !bkt.is_null() { (*bkt).doc = 0 as xmlDocPtr }
            }
            return -(1 as std::os::raw::c_int)
        }
        _ =>
        /*
	    * No location; this is just an import of the namespace.
	    * Note that we don't assign a bucket to the relation
	    * in this case.
	    */
        /*
    * Return the bucket explicitely; this is needed for the
    * main schema.
    */
        {
            if !bucket.is_null() { *bucket = bkt }
            return 0 as std::os::raw::c_int
        }
    };
}
/* *
 * xmlSchemaParseImport:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Import definition
 * *WARNING* this interface is highly subject to change
 *
 * Returns 0 in case of success, a positive error code if
 * not valid and -1 in case of an internal error.
 */
unsafe extern "C" fn xmlSchemaParseImport(mut pctxt: xmlSchemaParserCtxtPtr,
                                          mut schema: xmlSchemaPtr,
                                          mut node: xmlNodePtr)
 -> std::os::raw::c_int {
    let mut child: xmlNodePtr = 0 as *mut xmlNode;
    let mut namespaceName: *const xmlChar = 0 as *const xmlChar;
    let mut schemaLocation: *const xmlChar = 0 as *const xmlChar;
    let mut thisTargetNamespace: *const xmlChar = 0 as *const xmlChar;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"namespace\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0
                   &&
                   xmlStrEqual((*attr).name,
                               b"schemaLocation\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(pctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    /*
    * Extract and validate attributes.
    */
    if xmlSchemaPValAttr(pctxt, 0 as xmlSchemaBasicItemPtr, node,
                         b"namespace\x00" as *const u8 as *const std::os::raw::c_char,
                         xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                         &mut namespaceName) != 0 as std::os::raw::c_int {
        xmlSchemaPSimpleTypeErr(pctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr, node,
                                xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                                0 as *const std::os::raw::c_char, namespaceName,
                                0 as *const std::os::raw::c_char, 0 as *const xmlChar,
                                0 as *const xmlChar);
        return (*pctxt).err
    }
    if xmlSchemaPValAttr(pctxt, 0 as xmlSchemaBasicItemPtr, node,
                         b"schemaLocation\x00" as *const u8 as
                             *const std::os::raw::c_char,
                         xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                         &mut schemaLocation) != 0 as std::os::raw::c_int {
        xmlSchemaPSimpleTypeErr(pctxt, XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr, node,
                                xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                                0 as *const std::os::raw::c_char, schemaLocation,
                                0 as *const std::os::raw::c_char, 0 as *const xmlChar,
                                0 as *const xmlChar);
        return (*pctxt).err
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
         * the annotation here is simply discarded ...
	 * TODO: really?
         */
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(pctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?)\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    /*
    * Apply additional constraints.
    *
    * Note that it is important to use the original @targetNamespace
    * (or none at all), to rule out imports of schemas _with_ a
    * @targetNamespace if the importing schema is a chameleon schema
    * (with no @targetNamespace).
    */
    thisTargetNamespace =
        (*(*(*pctxt).constructor).bucket).origTargetNamespace;
    if !namespaceName.is_null() {
        /*
	* 1.1 If the namespace [attribute] is present, then its `actual value`
	* must not match the `actual value` of the enclosing <schema>'s
	* targetNamespace [attribute].
	*/
        if xmlStrEqual(thisTargetNamespace, namespaceName) != 0 {
            xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_SRC_IMPORT_1_1,
                                0 as xmlSchemaBasicItemPtr, node,
                                b"The value of the attribute \'namespace\' must not match the target namespace \'%s\' of the importing schema\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                thisTargetNamespace);
            return (*pctxt).err
        }
    } else if thisTargetNamespace.is_null() {
        xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_SRC_IMPORT_1_2,
                            0 as xmlSchemaBasicItemPtr, node,
                            b"The attribute \'namespace\' must be existent if the importing schema has no target namespace\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
        return (*pctxt).err
    }
    /*
	* 1.2 If the namespace [attribute] is not present, then the enclosing
	* <schema> must have a targetNamespace [attribute].
	*/
    /*
    * Locate and acquire the schema document.
    */
    if !schemaLocation.is_null() {
        schemaLocation =
            xmlSchemaBuildAbsoluteURI((*pctxt).dict, schemaLocation, node)
    }
    ret =
        xmlSchemaAddSchemaDoc(pctxt, 1 as std::os::raw::c_int, schemaLocation,
                              0 as xmlDocPtr, 0 as *const std::os::raw::c_char,
                              0 as std::os::raw::c_int, node, thisTargetNamespace,
                              namespaceName, &mut bucket);
    if ret != 0 as std::os::raw::c_int { return ret }
    /*
    * For <import>: "It is *not* an error for the application
    * schema reference strategy to fail."
    * So just don't parse if no schema document was found.
    * Note that we will get no bucket if the schema could not be
    * located or if there was no schemaLocation.
    */
    if bucket.is_null() && !schemaLocation.is_null() {
        xmlSchemaCustomWarning(pctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAP_WARN_UNLOCATED_SCHEMA, node,
                               0 as xmlSchemaTypePtr,
                               b"Failed to locate a schema at location \'%s\'. Skipping the import\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               schemaLocation, 0 as *const xmlChar,
                               0 as *const xmlChar);
    }
    if !bucket.is_null() &&
           (!(*bucket).doc.is_null() && (*bucket).parsed == 0 as std::os::raw::c_int)
       {
        ret = xmlSchemaParseNewDoc(pctxt, schema, bucket)
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseIncludeOrRedefineAttrs(mut pctxt:
                                                              xmlSchemaParserCtxtPtr,
                                                          mut schema:
                                                              xmlSchemaPtr,
                                                          mut node:
                                                              xmlNodePtr,
                                                          mut schemaLocation:
                                                              *mut *mut xmlChar,
                                                          mut type_0:
                                                              std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if pctxt.is_null() || schema.is_null() || node.is_null() ||
           schemaLocation.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    *schemaLocation = 0 as *mut xmlChar;
    /*
    * Check for illegal attributes.
    * Applies for both <include> and <redefine>.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"schemaLocation\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(pctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(pctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * Preliminary step, extract the URI-Reference and make an URI
    * from the base.
    */
    /*
    * Attribute "schemaLocation" is mandatory.
    */
    attr =
        xmlSchemaGetPropNode(node,
                             b"schemaLocation\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    if !attr.is_null() {
        let mut base: *mut xmlChar = 0 as *mut xmlChar;
        let mut uri: *mut xmlChar = 0 as *mut xmlChar;
        if !(xmlSchemaPValAttrNode(pctxt, 0 as xmlSchemaBasicItemPtr, attr,
                                   xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                                   schemaLocation as *mut *const xmlChar) !=
                 0 as std::os::raw::c_int) {
            base = xmlNodeGetBase((*node).doc, node as *const xmlNode);
            if base.is_null() {
                uri = xmlBuildURI(*schemaLocation, (*(*node).doc).URL)
            } else {
                uri = xmlBuildURI(*schemaLocation, base);
                xmlFree.expect("non-null function pointer")(base as
                                                                *mut std::os::raw::c_void);
            }
            if uri.is_null() {
                xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaParseIncludeOrRedefine\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"could not build an URI from the schemaLocation\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            } else {
                *schemaLocation =
                    xmlDictLookup((*pctxt).dict, uri, -(1 as std::os::raw::c_int)) as
                        *mut xmlChar;
                xmlFree.expect("non-null function pointer")(uri as
                                                                *mut std::os::raw::c_void);
                /*
    * Report self-inclusion and self-redefinition.
    */
                if xmlStrEqual(*schemaLocation, (*pctxt).URL) != 0 {
                    if type_0 == 3 as std::os::raw::c_int {
                        xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_SRC_REDEFINE,
                                            0 as xmlSchemaBasicItemPtr, node,
                                            b"The schema document \'%s\' cannot redefine itself.\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            *schemaLocation); /* hasRedefinitions = 0 */
                    } else {
                        xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_SRC_INCLUDE,
                                            0 as xmlSchemaBasicItemPtr, node,
                                            b"The schema document \'%s\' cannot include itself.\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            *schemaLocation);
                    }
                } else { return 0 as std::os::raw::c_int }
            }
        }
    } else {
        xmlSchemaPMissingAttrErr(pctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                 0 as xmlSchemaBasicItemPtr, node,
                                 b"schemaLocation\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
    }
    return (*pctxt).err;
}
unsafe extern "C" fn xmlSchemaParseIncludeOrRedefine(mut pctxt:
                                                         xmlSchemaParserCtxtPtr,
                                                     mut schema: xmlSchemaPtr,
                                                     mut node: xmlNodePtr,
                                                     mut type_0: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut schemaLocation: *const xmlChar = 0 as *const xmlChar;
    let mut res: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut isChameleon: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut wasChameleon: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    /*
    * Parse attributes. Note that the returned schemaLocation will
    * be already converted to an absolute URI.
    */
    res =
        xmlSchemaParseIncludeOrRedefineAttrs(pctxt, schema, node,
                                             &mut schemaLocation as
                                                 *mut *const xmlChar as
                                                 *mut *mut xmlChar, type_0);
    if res != 0 as std::os::raw::c_int { return res }
    /*
    * Load and add the schema document.
    */
    res =
        xmlSchemaAddSchemaDoc(pctxt, type_0, schemaLocation, 0 as xmlDocPtr,
                              0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                              node, (*pctxt).targetNamespace,
                              0 as *const xmlChar, &mut bucket);
    if res != 0 as std::os::raw::c_int { return res }
    /*
    * If we get no schema bucket back, then this means that the schema
    * document could not be located or was broken XML or was not
    * a schema document.
    */
    if bucket.is_null() || (*bucket).doc.is_null() {
        if type_0 == 2 as std::os::raw::c_int {
            /*
	    * WARNING for <include>:
	    * We will raise an error if the schema cannot be located
	    * for inclusions, since the that was the feedback from the
	    * schema people. I.e. the following spec piece will *not* be
	    * satisfied:
	    * SPEC src-include: "It is not an error for the `actual value` of the
	    * schemaLocation [attribute] to fail to resolve it all, in which
	    * case no corresponding inclusion is performed.
	    * So do we need a warning report here?"
	    */
            res = XML_SCHEMAP_SRC_INCLUDE as std::os::raw::c_int;
            xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                               res as xmlParserErrors, node,
                               0 as xmlSchemaBasicItemPtr,
                               b"Failed to load the document \'%s\' for inclusion\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               schemaLocation, 0 as *const xmlChar);
        } else {
            /*
	    * NOTE: This was changed to raise an error even if no redefinitions
	    * are specified.
	    *
	    * SPEC src-redefine (1)
	    * "If there are any element information items among the [children]
	    * other than <annotation> then the `actual value` of the
	    * schemaLocation [attribute] must successfully resolve."
	    * TODO: Ask the WG if a the location has always to resolve
	    * here as well!
	    */
            res = XML_SCHEMAP_SRC_REDEFINE as std::os::raw::c_int;
            xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                               res as xmlParserErrors, node,
                               0 as xmlSchemaBasicItemPtr,
                               b"Failed to load the document \'%s\' for redefinition\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               schemaLocation, 0 as *const xmlChar);
        }
    } else {
        /*
	* Check targetNamespace sanity before parsing the new schema.
	* TODO: Note that we won't check further content if the
	* targetNamespace was bad.
	*/
        if !(*bucket).origTargetNamespace.is_null() {
            /*
	    * SPEC src-include (2.1)
	    * "SII has a targetNamespace [attribute], and its `actual
	    * value` is identical to the `actual value` of the targetNamespace
	    * [attribute] of SII' (which must have such an [attribute])."
	    */
            if (*pctxt).targetNamespace.is_null() {
                xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                   XML_SCHEMAP_SRC_INCLUDE, node,
                                   0 as xmlSchemaBasicItemPtr,
                                   b"The target namespace of the included/redefined schema \'%s\' has to be absent, since the including/redefining schema has no target namespace\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   schemaLocation, 0 as *const xmlChar);
                current_block = 10217831701293121089;
            } else if xmlStrEqual((*bucket).origTargetNamespace,
                                  (*pctxt).targetNamespace) == 0 {
                /* TODO: Change error function. */
                xmlSchemaPCustomErrExt(pctxt, XML_SCHEMAP_SRC_INCLUDE,
                                       0 as xmlSchemaBasicItemPtr, node,
                                       b"The target namespace \'%s\' of the included/redefined schema \'%s\' differs from \'%s\' of the including/redefining schema\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       (*bucket).origTargetNamespace,
                                       schemaLocation,
                                       (*pctxt).targetNamespace);
                current_block = 10217831701293121089;
            } else { current_block = 8693738493027456495; }
        } else if !(*pctxt).targetNamespace.is_null() {
            /*
	    * Chameleons: the original target namespace will
	    * differ from the resulting namespace.
	    */
            isChameleon = 1 as std::os::raw::c_int;
            if (*bucket).parsed != 0 &&
                   !(*bucket).origTargetNamespace.is_null() {
                xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                   XML_SCHEMAP_SRC_INCLUDE, node,
                                   0 as xmlSchemaBasicItemPtr,
                                   b"The target namespace of the included/redefined schema \'%s\' has to be absent or the same as the including/redefining schema\'s target namespace\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   schemaLocation, 0 as *const xmlChar);
                current_block = 10217831701293121089;
            } else {
                (*bucket).targetNamespace = (*pctxt).targetNamespace;
                current_block = 8693738493027456495;
            }
        } else { current_block = 8693738493027456495; }
        match current_block {
            8693738493027456495 => { }
            _ => { return (*pctxt).err }
        }
    }
    /*
    * Parse the schema.
    */
    if !bucket.is_null() && (*bucket).parsed == 0 && !(*bucket).doc.is_null()
       {
        if isChameleon != 0 {
            /* TODO: Get rid of this flag on the schema itself. */
            if (*schema).flags & (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
                (*schema).flags |= (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int
            } else { wasChameleon = 1 as std::os::raw::c_int }
        }
        xmlSchemaParseNewDoc(pctxt, schema, bucket);
        /* Restore chameleon flag. */
        if isChameleon != 0 && wasChameleon == 0 {
            (*schema).flags ^= (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int
        }
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if type_0 == 3 as std::os::raw::c_int {
        /*
	* Parse (simpleType | complexType | group | attributeGroup))*
	*/
        (*pctxt).redefined = bucket;
        /*
	* How to proceed if the redefined schema was not located?
	*/
        (*pctxt).isRedefine = 1 as std::os::raw::c_int;
        while !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"annotation\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"simpleType\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"complexType\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"group\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"attributeGroup\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            if !(!child.is_null() && !(*child).ns.is_null() &&
                     xmlStrEqual((*child).name,
                                 b"annotation\x00" as *const u8 as
                                     *const std::os::raw::c_char as *const xmlChar) !=
                         0 &&
                     xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0) {
                if !child.is_null() && !(*child).ns.is_null() &&
                       xmlStrEqual((*child).name,
                                   b"simpleType\x00" as *const u8 as
                                       *const std::os::raw::c_char as *const xmlChar)
                           != 0 &&
                       xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                    xmlSchemaParseSimpleType(pctxt, schema, child,
                                             1 as std::os::raw::c_int);
                } else if !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"complexType\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 {
                    xmlSchemaParseComplexType(pctxt, schema, child,
                                              1 as std::os::raw::c_int);
                    /* hasRedefinitions = 1; */
                } else if !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"group\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 {
                    /* hasRedefinitions = 1; */
                    xmlSchemaParseModelGroupDefinition(pctxt, schema, child);
                } else if !child.is_null() && !(*child).ns.is_null() &&
                              xmlStrEqual((*child).name,
                                          b"attributeGroup\x00" as *const u8
                                              as *const std::os::raw::c_char as
                                              *const xmlChar) != 0 &&
                              xmlStrEqual((*(*child).ns).href, xmlSchemaNs) !=
                                  0 {
                    /* hasRedefinitions = 1; */
                    xmlSchemaParseAttributeGroupDefinition(pctxt, schema,
                                                           child);
                }
            }
            child = (*child).next
        }
        (*pctxt).redefined = 0 as xmlSchemaBucketPtr;
        (*pctxt).isRedefine = 0 as std::os::raw::c_int
    } else if !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"annotation\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	    * TODO: discard or not?
	    */
        child = (*child).next
    }
    if !child.is_null() {
        res = XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED as std::os::raw::c_int;
        if type_0 == 3 as std::os::raw::c_int {
            xmlSchemaPContentErr(pctxt, res as xmlParserErrors,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation | (simpleType | complexType | group | attributeGroup))*\x00"
                                     as *const u8 as *const std::os::raw::c_char);
        } else {
            xmlSchemaPContentErr(pctxt, res as xmlParserErrors,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation?)\x00" as *const u8 as
                                     *const std::os::raw::c_char);
        }
    }
    return res;
}
unsafe extern "C" fn xmlSchemaParseRedefine(mut pctxt: xmlSchemaParserCtxtPtr,
                                            mut schema: xmlSchemaPtr,
                                            mut node: xmlNodePtr)
 -> std::os::raw::c_int {
    let mut res: std::os::raw::c_int = 0;
    res =
        xmlSchemaParseIncludeOrRedefine(pctxt, schema, node,
                                        3 as std::os::raw::c_int);
    if res != 0 as std::os::raw::c_int { return res }
    return 0 as std::os::raw::c_int;
}
/* ***********************************************************************
 *									*
 *			Some predeclarations				*
 *									*
 ************************************************************************/
unsafe extern "C" fn xmlSchemaParseInclude(mut pctxt: xmlSchemaParserCtxtPtr,
                                           mut schema: xmlSchemaPtr,
                                           mut node: xmlNodePtr)
 -> std::os::raw::c_int {
    let mut res: std::os::raw::c_int = 0;
    res =
        xmlSchemaParseIncludeOrRedefine(pctxt, schema, node,
                                        2 as std::os::raw::c_int);
    if res != 0 as std::os::raw::c_int { return res }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaParseModelGroup:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 * @type: the "compositor" type
 * @particleNeeded: if a a model group with a particle
 *
 * parse a XML schema Sequence definition.
 * Applies parts of:
 *   Schema Representation Constraint:
 *     Redefinition Constraints and Semantics (src-redefine)
 *     (6.1), (6.1.1), (6.1.2)
 *
 *   Schema Component Constraint:
 *     All Group Limited (cos-all-limited) (2)
 *     TODO: Actually this should go to component-level checks,
 *     but is done here due to performance. Move it to an other layer
 *     is schema construction via an API is implemented.
 *
 * *WARNING* this interface is highly subject to change
 *
 * Returns -1 in case of error, 0 if the declaration is improper and
 *         1 in case of success.
 */
unsafe extern "C" fn xmlSchemaParseModelGroup(mut ctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut schema: xmlSchemaPtr,
                                              mut node: xmlNodePtr,
                                              mut type_0: xmlSchemaTypeType,
                                              mut withParticle: std::os::raw::c_int)
 -> xmlSchemaTreeItemPtr {
    let mut item: xmlSchemaModelGroupPtr = 0 as *mut xmlSchemaModelGroup;
    let mut particle: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut min: std::os::raw::c_int = 1 as std::os::raw::c_int;
    let mut max: std::os::raw::c_int = 1 as std::os::raw::c_int;
    let mut isElemRef: std::os::raw::c_int = 0;
    let mut hasRefs: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTreeItemPtr
    }
    /*
    * Create a model group with the given compositor.
    */
    item = xmlSchemaAddModelGroup(ctxt, schema, type_0, node);
    if item.is_null() { return 0 as xmlSchemaTreeItemPtr }
    if withParticle != 0 {
        if type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_ALL as std::os::raw::c_int as std::os::raw::c_uint {
            min =
                xmlGetMinOccurs(ctxt, node, 0 as std::os::raw::c_int,
                                1 as std::os::raw::c_int, 1 as std::os::raw::c_int,
                                b"(0 | 1)\x00" as *const u8 as
                                    *const std::os::raw::c_char);
            max =
                xmlGetMaxOccurs(ctxt, node, 1 as std::os::raw::c_int,
                                1 as std::os::raw::c_int, 1 as std::os::raw::c_int,
                                b"1\x00" as *const u8 as *const std::os::raw::c_char)
        } else {
            /* choice + sequence */
            min =
                xmlGetMinOccurs(ctxt, node, 0 as std::os::raw::c_int,
                                -(1 as std::os::raw::c_int), 1 as std::os::raw::c_int,
                                b"xs:nonNegativeInteger\x00" as *const u8 as
                                    *const std::os::raw::c_char);
            max =
                xmlGetMaxOccurs(ctxt, node, 0 as std::os::raw::c_int,
                                (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int,
                                1 as std::os::raw::c_int,
                                b"(xs:nonNegativeInteger | unbounded)\x00" as
                                    *const u8 as *const std::os::raw::c_char)
        }
        xmlSchemaPCheckParticleCorrect_2(ctxt, 0 as xmlSchemaParticlePtr,
                                         node, min, max);
        /*
	* Create a particle
	*/
        particle = xmlSchemaAddParticle(ctxt, node, min, max);
        if particle.is_null() { return 0 as xmlSchemaTreeItemPtr }
        (*particle).children = item as xmlSchemaTreeItemPtr;
        /*
	* Check for illegal attributes.
	*/
        attr = (*node).properties;
        while !attr.is_null() {
            if (*attr).ns.is_null() {
                if xmlStrEqual((*attr).name,
                               b"id\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 &&
                       xmlStrEqual((*attr).name,
                                   b"maxOccurs\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) ==
                           0 &&
                       xmlStrEqual((*attr).name,
                                   b"minOccurs\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) ==
                           0 {
                    xmlSchemaPIllegalAttrErr(ctxt,
                                             XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                             0 as xmlSchemaBasicItemPtr,
                                             attr);
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
            attr = (*attr).next
        }
    } else {
        /*
	* Check for illegal attributes.
	*/
        attr = (*node).properties;
        while !attr.is_null() {
            if (*attr).ns.is_null() {
                if xmlStrEqual((*attr).name,
                               b"id\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 {
                    xmlSchemaPIllegalAttrErr(ctxt,
                                             XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                             0 as xmlSchemaBasicItemPtr,
                                             attr);
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
            attr = (*attr).next
        }
    }
    /*
    * Extract and validate attributes.
    */
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*item).annot =
            xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    if type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_ALL as std::os::raw::c_int as std::os::raw::c_uint {
        let mut part: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
        let mut last: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
        while !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"element\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            part =
                xmlSchemaParseElement(ctxt, schema, child, &mut isElemRef,
                                      0 as std::os::raw::c_int) as
                    xmlSchemaParticlePtr;
            /*
	    * SPEC cos-all-limited (2)
	    * "The {max occurs} of all the particles in the {particles}
	    * of the ('all') group must be 0 or 1.
	    */
            if !part.is_null() {
                if isElemRef != 0 { hasRefs += 1 }
                if (*part).minOccurs > 1 as std::os::raw::c_int {
                    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_COS_ALL_LIMITED,
                                        0 as xmlSchemaBasicItemPtr, child,
                                        b"Invalid value for minOccurs (must be 0 or 1)\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as *const xmlChar);
                    /* Reset to 1. */
                    (*part).minOccurs = 1 as std::os::raw::c_int
                }
                if (*part).maxOccurs > 1 as std::os::raw::c_int {
                    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_COS_ALL_LIMITED,
                                        0 as xmlSchemaBasicItemPtr, child,
                                        b"Invalid value for maxOccurs (must be 0 or 1)\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as *const xmlChar);
                    /* Reset to 1. */
                    (*part).maxOccurs = 1 as std::os::raw::c_int
                }
                if last.is_null() {
                    (*item).children = part as xmlSchemaTreeItemPtr
                } else { (*last).next = part as xmlSchemaTreeItemPtr }
                last = part
            }
            child = (*child).next
        }
        if !child.is_null() {
            xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation?, (annotation?, element*)\x00"
                                     as *const u8 as *const std::os::raw::c_char);
        }
    } else {
        /* choice + sequence */
        let mut part_0: xmlSchemaTreeItemPtr = 0 as xmlSchemaTreeItemPtr;
        let mut last_0: xmlSchemaTreeItemPtr = 0 as xmlSchemaTreeItemPtr;
        while !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"element\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"group\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"any\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"choice\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"sequence\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            if !child.is_null() && !(*child).ns.is_null() &&
                   xmlStrEqual((*child).name,
                               b"element\x00" as *const u8 as
                                   *const std::os::raw::c_char as *const xmlChar) != 0
                   && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                part_0 =
                    xmlSchemaParseElement(ctxt, schema, child, &mut isElemRef,
                                          0 as std::os::raw::c_int) as
                        xmlSchemaTreeItemPtr;
                if !part_0.is_null() && isElemRef != 0 { hasRefs += 1 }
            } else if !child.is_null() && !(*child).ns.is_null() &&
                          xmlStrEqual((*child).name,
                                      b"group\x00" as *const u8 as
                                          *const std::os::raw::c_char as
                                          *const xmlChar) != 0 &&
                          xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                part_0 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
                if !part_0.is_null() { hasRefs += 1 }
                /*
		* Handle redefinitions.
		*/
                if (*ctxt).isRedefine != 0 && !(*ctxt).redef.is_null() &&
                       (*(*(*ctxt).redef).item).type_0 as std::os::raw::c_uint ==
                           XML_SCHEMA_TYPE_GROUP as std::os::raw::c_int as
                               std::os::raw::c_uint && !part_0.is_null() &&
                       !(*part_0).children.is_null() {
                    if (*((*part_0).children as xmlSchemaQNameRefPtr)).name ==
                           (*(*ctxt).redef).refName &&
                           (*((*part_0).children as
                                  xmlSchemaQNameRefPtr)).targetNamespace ==
                               (*(*ctxt).redef).refTargetNs {
                        /*
			* SPEC src-redefine:
			* (6.1) "If it has a <group> among its contents at
			* some level the `actual value` of whose ref
			* [attribute] is the same as the `actual value` of
			* its own name attribute plus target namespace, then
			* all of the following must be true:"
			* (6.1.1) "It must have exactly one such group."
			*/
                        if (*ctxt).redefCounter != 0 as std::os::raw::c_int {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(ctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               XML_SCHEMAP_SRC_REDEFINE,
                                               child,
                                               0 as xmlSchemaBasicItemPtr,
                                               b"The redefining model group definition \'%s\' must not contain more than one reference to the redefined definition\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               xmlSchemaFormatQName(&mut str,
                                                                    (*(*ctxt).redef).refTargetNs,
                                                                    (*(*ctxt).redef).refName),
                                               0 as *const xmlChar);
                            if !str.is_null() {
                                xmlFree.expect("non-null function pointer")(str
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                str = 0 as *mut xmlChar
                            }
                            part_0 = 0 as xmlSchemaTreeItemPtr
                        } else if (*(part_0 as
                                         xmlSchemaParticlePtr)).minOccurs !=
                                      1 as std::os::raw::c_int ||
                                      (*(part_0 as
                                             xmlSchemaParticlePtr)).maxOccurs
                                          != 1 as std::os::raw::c_int {
                            let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                            /*
			    * SPEC src-redefine:
			    * (6.1.2) "The `actual value` of both that
			    * group's minOccurs and maxOccurs [attribute]
			    * must be 1 (or `absent`).
			    */
                            xmlSchemaCustomErr(ctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               XML_SCHEMAP_SRC_REDEFINE,
                                               child,
                                               0 as xmlSchemaBasicItemPtr,
                                               b"The redefining model group definition \'%s\' must not contain a reference to the redefined definition with a maxOccurs/minOccurs other than 1\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               xmlSchemaFormatQName(&mut str_0,
                                                                    (*(*ctxt).redef).refTargetNs,
                                                                    (*(*ctxt).redef).refName),
                                               0 as *const xmlChar);
                            if !str_0.is_null() {
                                xmlFree.expect("non-null function pointer")(str_0
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                str_0 = 0 as *mut xmlChar
                            }
                            part_0 = 0 as xmlSchemaTreeItemPtr
                        }
                        (*(*ctxt).redef).reference =
                            part_0 as xmlSchemaBasicItemPtr;
                        (*ctxt).redefCounter += 1
                    }
                }
            } else if !child.is_null() && !(*child).ns.is_null() &&
                          xmlStrEqual((*child).name,
                                      b"any\x00" as *const u8 as
                                          *const std::os::raw::c_char as
                                          *const xmlChar) != 0 &&
                          xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                part_0 =
                    xmlSchemaParseAny(ctxt, schema, child) as
                        xmlSchemaTreeItemPtr
            } else if !child.is_null() && !(*child).ns.is_null() &&
                          xmlStrEqual((*child).name,
                                      b"choice\x00" as *const u8 as
                                          *const std::os::raw::c_char as
                                          *const xmlChar) != 0 &&
                          xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                part_0 =
                    xmlSchemaParseModelGroup(ctxt, schema, child,
                                             XML_SCHEMA_TYPE_CHOICE,
                                             1 as std::os::raw::c_int)
            } else if !child.is_null() && !(*child).ns.is_null() &&
                          xmlStrEqual((*child).name,
                                      b"sequence\x00" as *const u8 as
                                          *const std::os::raw::c_char as
                                          *const xmlChar) != 0 &&
                          xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
                part_0 =
                    xmlSchemaParseModelGroup(ctxt, schema, child,
                                             XML_SCHEMA_TYPE_SEQUENCE,
                                             1 as std::os::raw::c_int)
            }
            if !part_0.is_null() {
                if last_0.is_null() {
                    (*item).children = part_0
                } else { (*last_0).next = part_0 }
                last_0 = part_0
            }
            child = (*child).next
        }
        if !child.is_null() {
            xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation?, (element | group | choice | sequence | any)*)\x00"
                                     as *const u8 as *const std::os::raw::c_char);
        }
    }
    if max == 0 as std::os::raw::c_int && min == 0 as std::os::raw::c_int {
        return 0 as xmlSchemaTreeItemPtr
    }
    if hasRefs != 0 {
        /*
	* We need to resolve references.
	*/
        xmlSchemaAddItemSize(&mut (*(*ctxt).constructor).pending,
                             10 as std::os::raw::c_int, item as *mut std::os::raw::c_void);
    }
    if withParticle != 0 {
        return particle as xmlSchemaTreeItemPtr
    } else { return item as xmlSchemaTreeItemPtr };
}
/* *
 * xmlSchemaParseRestriction:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Restriction definition
 * *WARNING* this interface is highly subject to change
 *
 * Returns the type definition or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaParseRestriction(mut ctxt:
                                                   xmlSchemaParserCtxtPtr,
                                               mut schema: xmlSchemaPtr,
                                               mut node: xmlNodePtr,
                                               mut parentType:
                                                   xmlSchemaTypeType)
 -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr
    }
    /* Not a component, don't create it. */
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int;
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"base\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    /*
    * Extract and validate attributes.
    */
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * Attribute
    */
    /*
    * Extract the base type. The "base" attribute is mandatory if inside
    * a complex type or if redefining.
    *
    * SPEC (1.2) "...otherwise (<restriction> has no <simpleType> "
    * among its [children]), the simple type definition which is
    * the {content type} of the type definition `resolved` to by
    * the `actual value` of the base [attribute]"
    */
    if xmlSchemaPValAttrQName(ctxt, schema, 0 as xmlSchemaBasicItemPtr, node,
                              b"base\x00" as *const u8 as *const std::os::raw::c_char,
                              &mut (*type_0).baseNs, &mut (*type_0).base) ==
           0 as std::os::raw::c_int {
        if (*type_0).base.is_null() &&
               (*type_0).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint {
            xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                     0 as xmlSchemaBasicItemPtr, node,
                                     b"base\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     0 as *const std::os::raw::c_char);
        } else if (*ctxt).isRedefine != 0 &&
                      (*type_0).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int
                          != 0 {
            if (*type_0).base.is_null() {
                xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                         0 as xmlSchemaBasicItemPtr, node,
                                         b"base\x00" as *const u8 as
                                             *const std::os::raw::c_char,
                                         0 as *const std::os::raw::c_char);
            } else if xmlStrEqual((*type_0).base, (*type_0).name) == 0 ||
                          xmlStrEqual((*type_0).baseNs,
                                      (*type_0).targetNamespace) == 0 {
                let mut str1: *mut xmlChar = 0 as *mut xmlChar;
                let mut str2: *mut xmlChar = 0 as *mut xmlChar;
                /*
		* REDEFINE: SPEC src-redefine (5)
		* "Within the [children], each <simpleType> must have a
		* <restriction> among its [children] ... the `actual value` of
		* whose base [attribute] must be the same as the `actual value`
		* of its own name attribute plus target namespace;"
		*/
                xmlSchemaPCustomErrExt(ctxt, XML_SCHEMAP_SRC_REDEFINE,
                                       0 as xmlSchemaBasicItemPtr, node,
                                       b"This is a redefinition, but the QName value \'%s\' of the \'base\' attribute does not match the type\'s designation \'%s\'\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlSchemaFormatQName(&mut str1,
                                                            (*type_0).baseNs,
                                                            (*type_0).base),
                                       xmlSchemaFormatQName(&mut str2,
                                                            (*type_0).targetNamespace,
                                                            (*type_0).name),
                                       0 as *const xmlChar);
                if !str1.is_null() {
                    xmlFree.expect("non-null function pointer")(str1 as
                                                                    *mut std::os::raw::c_void);
                    str1 = 0 as *mut xmlChar
                }
                if !str2.is_null() {
                    xmlFree.expect("non-null function pointer")(str2 as
                                                                    *mut std::os::raw::c_void);
                    str2 = 0 as *mut xmlChar
                }
                /* Avoid confusion and erase the values. */
                (*type_0).base = 0 as *const xmlChar;
                (*type_0).baseNs = 0 as *const xmlChar
            }
        }
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* Add the annotation to the simple type ancestor.
	*/
        xmlSchemaAddAnnotation(type_0 as xmlSchemaAnnotItemPtr,
                               xmlSchemaParseAnnotation(ctxt, child,
                                                        1 as std::os::raw::c_int));
        child = (*child).next
    }
    if parentType as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint {
        /*
	* Corresponds to <simpleType><restriction><simpleType>.
	*/
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"simpleType\x00" as *const u8 as
                               *const std::os::raw::c_char as *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            if !(*type_0).base.is_null() {
                /*
		* src-restriction-base-or-simpleType
		* Either the base [attribute] or the simpleType [child] of the
		* <restriction> element must be present, but not both.
		*/
                xmlSchemaPContentErr(ctxt,
                                     XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
                                     0 as xmlSchemaBasicItemPtr, node, child,
                                     b"The attribute \'base\' and the <simpleType> child are mutually exclusive\x00"
                                         as *const u8 as *const std::os::raw::c_char,
                                     0 as *const std::os::raw::c_char);
            } else {
                (*type_0).baseType =
                    xmlSchemaParseSimpleType(ctxt, schema, child,
                                             0 as std::os::raw::c_int)
            }
            child = (*child).next
        } else if (*type_0).base.is_null() {
            xmlSchemaPContentErr(ctxt,
                                 XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 b"Either the attribute \'base\' or a <simpleType> child must be present\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
        }
    } else if parentType as std::os::raw::c_uint ==
                  XML_SCHEMA_TYPE_COMPLEX_CONTENT as std::os::raw::c_int as
                      std::os::raw::c_uint {
        /*
	* Corresponds to <complexType><complexContent><restriction>...
	* followed by:
	*
	* Model groups <all>, <choice> and <sequence>.
	*/
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"all\x00" as *const u8 as *const std::os::raw::c_char as
                               *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroup(ctxt, schema, child,
                                         XML_SCHEMA_TYPE_ALL,
                                         1 as std::os::raw::c_int) as
                    xmlSchemaTypePtr;
            child = (*child).next
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"choice\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroup(ctxt, schema, child,
                                         XML_SCHEMA_TYPE_CHOICE,
                                         1 as std::os::raw::c_int) as
                    xmlSchemaTypePtr;
            child = (*child).next
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"sequence\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroup(ctxt, schema, child,
                                         XML_SCHEMA_TYPE_SEQUENCE,
                                         1 as std::os::raw::c_int) as
                    xmlSchemaTypePtr;
            child = (*child).next
            /*
	* Model group reference <group>.
	*/
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"group\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroupDefRef(ctxt, schema, child) as
                    xmlSchemaTypePtr;
            /*
	    * Note that the reference will be resolved in
	    * xmlSchemaResolveTypeReferences();
	    */
            child = (*child).next
        }
    } else if parentType as std::os::raw::c_uint ==
                  XML_SCHEMA_TYPE_SIMPLE_CONTENT as std::os::raw::c_int as
                      std::os::raw::c_uint {
        /*
	* Corresponds to <complexType><simpleContent><restriction>...
	*
	* "1.1 the simple type definition corresponding to the <simpleType>
	* among the [children] of <restriction> if there is one;"
	*/
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"simpleType\x00" as *const u8 as
                               *const std::os::raw::c_char as *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            /*
	    * We will store the to-be-restricted simple type in
	    * type->contentTypeDef *temporarily*.
	    */
            (*type_0).contentTypeDef =
                xmlSchemaParseSimpleType(ctxt, schema, child,
                                         0 as std::os::raw::c_int);
            if (*type_0).contentTypeDef.is_null() {
                return 0 as xmlSchemaTypePtr
            }
            child = (*child).next
        }
    }
    if parentType as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
           parentType as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_SIMPLE_CONTENT as std::os::raw::c_int as std::os::raw::c_uint {
        let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        let mut lastfacet: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
        /*
	* Corresponds to <complexType><simpleContent><restriction>...
	* <simpleType><restriction>...
	*/
        /*
	* Add the facets to the simple type ancestor.
	*/
	/*
	* TODO: Datatypes: 4.1.3 Constraints on XML Representation of
	* Simple Type Definition Schema Representation Constraint:
	* *Single Facet Value*
	*/
        while !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"minInclusive\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"minExclusive\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"maxInclusive\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"maxExclusive\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"totalDigits\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"fractionDigits\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"pattern\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"enumeration\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"whiteSpace\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"length\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"maxLength\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 ||
                  !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"minLength\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            facet = xmlSchemaParseFacet(ctxt, schema, child);
            if !facet.is_null() {
                if lastfacet.is_null() {
                    (*type_0).facets = facet
                } else { (*lastfacet).next = facet }
                lastfacet = facet;
                (*lastfacet).next = 0 as *mut _xmlSchemaFacet
            }
            child = (*child).next
        }
        /*
	* Create links for derivation and validation.
	*/
        if !(*type_0).facets.is_null() {
            let mut facetLink: xmlSchemaFacetLinkPtr =
                0 as *mut xmlSchemaFacetLink;
            let mut lastFacetLink: xmlSchemaFacetLinkPtr =
                0 as xmlSchemaFacetLinkPtr;
            facet = (*type_0).facets;
            loop  {
                facetLink =
                    xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaFacetLink>()
                                                                      as
                                                                      std::os::raw::c_ulong)
                        as xmlSchemaFacetLinkPtr;
                if facetLink.is_null() {
                    xmlSchemaPErrMemory(ctxt,
                                        b"allocating a facet link\x00" as
                                            *const u8 as *const std::os::raw::c_char,
                                        0 as xmlNodePtr);
                    xmlFree.expect("non-null function pointer")(facetLink as
                                                                    *mut std::os::raw::c_void);
                    return 0 as xmlSchemaTypePtr
                }
                (*facetLink).facet = facet;
                (*facetLink).next = 0 as *mut _xmlSchemaFacetLink;
                if lastFacetLink.is_null() {
                    (*type_0).facetSet = facetLink
                } else { (*lastFacetLink).next = facetLink }
                lastFacetLink = facetLink;
                facet = (*facet).next;
                if facet.is_null() { break ; }
            }
        }
    }
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint {
        /*
	* Attribute uses/declarations.
	*/
        if xmlSchemaParseLocalAttributes(ctxt, schema, &mut child,
                                         &mut (*type_0).attrUses as
                                             *mut *mut std::os::raw::c_void as
                                             *mut xmlSchemaItemListPtr,
                                         XML_SCHEMA_TYPE_RESTRICTION as
                                             std::os::raw::c_int,
                                         0 as *mut std::os::raw::c_int) ==
               -(1 as std::os::raw::c_int) {
            return 0 as xmlSchemaTypePtr
        }
        /*
	* Attribute wildcard.
	*/
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"anyAttribute\x00" as *const u8 as
                               *const std::os::raw::c_char as *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).attributeWildcard =
                xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = (*child).next
        }
    }
    if !child.is_null() {
        if parentType as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_COMPLEX_CONTENT as std::os::raw::c_int as std::os::raw::c_uint
           {
            xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"annotation?, (group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?))\x00"
                                     as *const u8 as *const std::os::raw::c_char);
        } else if parentType as std::os::raw::c_uint ==
                      XML_SCHEMA_TYPE_SIMPLE_CONTENT as std::os::raw::c_int as
                          std::os::raw::c_uint {
            xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*)?, ((attribute | attributeGroup)*, anyAttribute?))\x00"
                                     as *const u8 as *const std::os::raw::c_char);
        } else {
            /* Simple type */
            xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*))\x00"
                                     as *const u8 as *const std::os::raw::c_char);
        }
    }
    return 0 as xmlSchemaTypePtr;
}
/* *
 * xmlSchemaParseExtension:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * Parses an <extension>, which is found inside a
 * <simpleContent> or <complexContent>.
 * *WARNING* this interface is highly subject to change.
 *
 * TODO: Returns the type definition or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaParseExtension(mut ctxt: xmlSchemaParserCtxtPtr,
                                             mut schema: xmlSchemaPtr,
                                             mut node: xmlNodePtr,
                                             mut parentType:
                                                 xmlSchemaTypeType)
 -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr
    }
    /* Not a component, don't create it. */
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int;
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"base\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * Attribute "base" - mandatory.
    */
    if xmlSchemaPValAttrQName(ctxt, schema, 0 as xmlSchemaBasicItemPtr, node,
                              b"base\x00" as *const u8 as *const std::os::raw::c_char,
                              &mut (*type_0).baseNs, &mut (*type_0).base) ==
           0 as std::os::raw::c_int && (*type_0).base.is_null() {
        xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                 0 as xmlSchemaBasicItemPtr, node,
                                 b"base\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 0 as *const std::os::raw::c_char);
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* Add the annotation to the type ancestor.
	*/
        xmlSchemaAddAnnotation(type_0 as xmlSchemaAnnotItemPtr,
                               xmlSchemaParseAnnotation(ctxt, child,
                                                        1 as std::os::raw::c_int));
        child = (*child).next
    }
    if parentType as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_COMPLEX_CONTENT as std::os::raw::c_int as std::os::raw::c_uint {
        /*
	* Corresponds to <complexType><complexContent><extension>... and:
	*
	* Model groups <all>, <choice>, <sequence> and <group>.
	*/
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"all\x00" as *const u8 as *const std::os::raw::c_char as
                               *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroup(ctxt, schema, child,
                                         XML_SCHEMA_TYPE_ALL,
                                         1 as std::os::raw::c_int) as
                    xmlSchemaTypePtr;
            child = (*child).next
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"choice\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroup(ctxt, schema, child,
                                         XML_SCHEMA_TYPE_CHOICE,
                                         1 as std::os::raw::c_int) as
                    xmlSchemaTypePtr;
            child = (*child).next
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"sequence\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroup(ctxt, schema, child,
                                         XML_SCHEMA_TYPE_SEQUENCE,
                                         1 as std::os::raw::c_int) as
                    xmlSchemaTypePtr;
            child = (*child).next
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"group\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroupDefRef(ctxt, schema, child) as
                    xmlSchemaTypePtr;
            /*
	    * Note that the reference will be resolved in
	    * xmlSchemaResolveTypeReferences();
	    */
            child = (*child).next
        }
    }
    if !child.is_null() {
        /*
	* Attribute uses/declarations.
	*/
        if xmlSchemaParseLocalAttributes(ctxt, schema, &mut child,
                                         &mut (*type_0).attrUses as
                                             *mut *mut std::os::raw::c_void as
                                             *mut xmlSchemaItemListPtr,
                                         XML_SCHEMA_TYPE_EXTENSION as
                                             std::os::raw::c_int,
                                         0 as *mut std::os::raw::c_int) ==
               -(1 as std::os::raw::c_int) {
            return 0 as xmlSchemaTypePtr
        }
        /*
	* Attribute wildcard.
	*/
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"anyAttribute\x00" as *const u8 as
                               *const std::os::raw::c_char as *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*(*ctxt).ctxtType).attributeWildcard =
                xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = (*child).next
        }
    }
    if !child.is_null() {
        if parentType as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_COMPLEX_CONTENT as std::os::raw::c_int as std::os::raw::c_uint
           {
            /* Complex content extension. */
            xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation?, ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?)))\x00"
                                     as *const u8 as *const std::os::raw::c_char);
        } else {
            /* Simple content extension. */
            xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                                 0 as xmlSchemaBasicItemPtr, node, child,
                                 0 as *const std::os::raw::c_char,
                                 b"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))\x00"
                                     as *const u8 as *const std::os::raw::c_char);
        }
    }
    return 0 as xmlSchemaTypePtr;
}
/* *
 * xmlSchemaParseSimpleContent:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema SimpleContent definition
 * *WARNING* this interface is highly subject to change
 *
 * Returns the type definition or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaParseSimpleContent(mut ctxt:
                                                     xmlSchemaParserCtxtPtr,
                                                 mut schema: xmlSchemaPtr,
                                                 mut node: xmlNodePtr,
                                                 mut hasRestrictionOrExtension:
                                                     *mut std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() ||
           hasRestrictionOrExtension.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    *hasRestrictionOrExtension = 0 as std::os::raw::c_int;
    /* Not a component, don't create it. */
    type_0 = (*ctxt).ctxtType;
    (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* Add the annotation to the complex type ancestor.
	*/
        xmlSchemaAddAnnotation(type_0 as xmlSchemaAnnotItemPtr,
                               xmlSchemaParseAnnotation(ctxt, child,
                                                        1 as std::os::raw::c_int));
        child = (*child).next
    }
    if child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_MISSING,
                             0 as xmlSchemaBasicItemPtr, node,
                             0 as xmlNodePtr, 0 as *const std::os::raw::c_char,
                             b"(annotation?, (restriction | extension))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    if child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_MISSING,
                             0 as xmlSchemaBasicItemPtr, node,
                             0 as xmlNodePtr, 0 as *const std::os::raw::c_char,
                             b"(annotation?, (restriction | extension))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"restriction\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        xmlSchemaParseRestriction(ctxt, schema, child,
                                  XML_SCHEMA_TYPE_SIMPLE_CONTENT);
        *hasRestrictionOrExtension = 1 as std::os::raw::c_int;
        child = (*child).next
    } else if !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"extension\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        xmlSchemaParseExtension(ctxt, schema, child,
                                XML_SCHEMA_TYPE_SIMPLE_CONTENT);
        *hasRestrictionOrExtension = 1 as std::os::raw::c_int;
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, (restriction | extension))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaParseComplexContent:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema ComplexContent definition
 * *WARNING* this interface is highly subject to change
 *
 * Returns the type definition or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaParseComplexContent(mut ctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut schema: xmlSchemaPtr,
                                                  mut node: xmlNodePtr,
                                                  mut hasRestrictionOrExtension:
                                                      *mut std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() ||
           hasRestrictionOrExtension.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    *hasRestrictionOrExtension = 0 as std::os::raw::c_int;
    /* Not a component, don't create it. */
    type_0 = (*ctxt).ctxtType;
    /*
    * Check for illegal attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 &&
                   xmlStrEqual((*attr).name,
                               b"mixed\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) == 0 {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    xmlSchemaPValAttrID(ctxt, node,
                        b"id\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar);
    /*
    * Set the 'mixed' on the complex type ancestor.
    */
    if xmlGetBooleanProp(ctxt, node,
                         b"mixed\x00" as *const u8 as *const std::os::raw::c_char,
                         0 as std::os::raw::c_int) != 0 {
        if (*type_0).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int ==
               0 as std::os::raw::c_int {
            (*type_0).flags |= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
        }
    }
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* Add the annotation to the complex type ancestor.
	*/
        xmlSchemaAddAnnotation(type_0 as xmlSchemaAnnotItemPtr,
                               xmlSchemaParseAnnotation(ctxt, child,
                                                        1 as std::os::raw::c_int));
        child = (*child).next
    }
    if child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_MISSING,
                             0 as xmlSchemaBasicItemPtr, node,
                             0 as xmlNodePtr, 0 as *const std::os::raw::c_char,
                             b"(annotation?, (restriction | extension))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    if child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_MISSING,
                             0 as xmlSchemaBasicItemPtr, node,
                             0 as xmlNodePtr, 0 as *const std::os::raw::c_char,
                             b"(annotation?, (restriction | extension))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"restriction\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        xmlSchemaParseRestriction(ctxt, schema, child,
                                  XML_SCHEMA_TYPE_COMPLEX_CONTENT);
        *hasRestrictionOrExtension = 1 as std::os::raw::c_int;
        child = (*child).next
    } else if !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"extension\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        xmlSchemaParseExtension(ctxt, schema, child,
                                XML_SCHEMA_TYPE_COMPLEX_CONTENT);
        *hasRestrictionOrExtension = 1 as std::os::raw::c_int;
        child = (*child).next
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, (restriction | extension))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaParseComplexType:
 * @ctxt:  a schema validation context
 * @schema:  the schema being built
 * @node:  a subtree containing XML Schema informations
 *
 * parse a XML schema Complex Type definition
 * *WARNING* this interface is highly subject to change
 *
 * Returns the type definition or NULL in case of error
 */
unsafe extern "C" fn xmlSchemaParseComplexType(mut ctxt:
                                                   xmlSchemaParserCtxtPtr,
                                               mut schema: xmlSchemaPtr,
                                               mut node: xmlNodePtr,
                                               mut topLevel: std::os::raw::c_int)
 -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ctxtType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut final_0: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut block: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut hasRestrictionOrExtension: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr
    }
    ctxtType = (*ctxt).ctxtType;
    if topLevel != 0 {
        attr =
            xmlSchemaGetPropNode(node,
                                 b"name\x00" as *const u8 as
                                     *const std::os::raw::c_char);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_MISSING,
                                     0 as xmlSchemaBasicItemPtr, node,
                                     b"name\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     0 as *const std::os::raw::c_char);
            return 0 as xmlSchemaTypePtr
        } else {
            if xmlSchemaPValAttrNode(ctxt, 0 as xmlSchemaBasicItemPtr, attr,
                                     xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                                     &mut name) != 0 as std::os::raw::c_int {
                return 0 as xmlSchemaTypePtr
            }
        }
    }
    if topLevel == 0 as std::os::raw::c_int {
        /*
	* Parse as local complex type definition.
	*/
        type_0 =
            xmlSchemaAddType(ctxt, schema, XML_SCHEMA_TYPE_COMPLEX,
                             0 as *const xmlChar, (*ctxt).targetNamespace,
                             node, 0 as std::os::raw::c_int);
        if type_0.is_null() { return 0 as xmlSchemaTypePtr }
        name = (*type_0).name;
        (*type_0).node = node;
        (*type_0).type_0 = XML_SCHEMA_TYPE_COMPLEX
        /*
	* TODO: We need the target namespace.
	*/
    } else {
        /*
	* Parse as global complex type definition.
	*/
        type_0 =
            xmlSchemaAddType(ctxt, schema, XML_SCHEMA_TYPE_COMPLEX, name,
                             (*ctxt).targetNamespace, node, 1 as std::os::raw::c_int);
        if type_0.is_null() { return 0 as xmlSchemaTypePtr }
        (*type_0).node = node;
        (*type_0).type_0 = XML_SCHEMA_TYPE_COMPLEX;
        (*type_0).flags |= (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int
    }
    (*type_0).targetNamespace = (*ctxt).targetNamespace;
    /*
    * Handle attributes.
    */
    attr = (*node).properties;
    while !attr.is_null() {
        if (*attr).ns.is_null() {
            if xmlStrEqual((*attr).name,
                           b"id\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) != 0 {
                /*
		* Attribute "id".
		*/
                xmlSchemaPValAttrID(ctxt, node,
                                    b"id\x00" as *const u8 as
                                        *const std::os::raw::c_char as *mut xmlChar);
            } else if xmlStrEqual((*attr).name,
                                  b"mixed\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                /*
		* Attribute "mixed".
		*/
                if xmlSchemaPGetBoolNodeValue(ctxt,
                                              0 as xmlSchemaBasicItemPtr,
                                              attr as xmlNodePtr) != 0 {
                    (*type_0).flags |= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
                }
            } else if topLevel != 0 {
                /*
		* Attributes of global complex type definitions.
		*/
                if !(xmlStrEqual((*attr).name,
                                 b"name\x00" as *const u8 as
                                     *const std::os::raw::c_char as *mut xmlChar) !=
                         0) {
                    if xmlStrEqual((*attr).name,
                                   b"abstract\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) !=
                           0 {
                        /*
		    * Attribute "abstract".
		    */
                        if xmlSchemaPGetBoolNodeValue(ctxt,
                                                      0 as
                                                          xmlSchemaBasicItemPtr,
                                                      attr as xmlNodePtr) != 0
                           {
                            (*type_0).flags |=
                                (1 as std::os::raw::c_int) << 20 as std::os::raw::c_int
                        }
                    } else if xmlStrEqual((*attr).name,
                                          b"final\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *mut xmlChar) != 0 {
                        /*
		    * Attribute "final".
		    */
                        attrValue =
                            xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(attrValue,
                                                       &mut (*type_0).flags,
                                                       -(1 as std::os::raw::c_int),
                                                       (1 as std::os::raw::c_int) <<
                                                           9 as std::os::raw::c_int,
                                                       (1 as std::os::raw::c_int) <<
                                                           10 as std::os::raw::c_int,
                                                       -(1 as std::os::raw::c_int),
                                                       -(1 as std::os::raw::c_int),
                                                       -(1 as std::os::raw::c_int)) !=
                               0 as std::os::raw::c_int {
                            xmlSchemaPSimpleTypeErr(ctxt,
                                                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                    0 as
                                                        xmlSchemaBasicItemPtr,
                                                    attr as xmlNodePtr,
                                                    0 as xmlSchemaTypePtr,
                                                    b"(#all | List of (extension | restriction))\x00"
                                                        as *const u8 as
                                                        *const std::os::raw::c_char,
                                                    attrValue,
                                                    0 as *const std::os::raw::c_char,
                                                    0 as *const xmlChar,
                                                    0 as *const xmlChar);
                        } else { final_0 = 1 as std::os::raw::c_int }
                    } else if xmlStrEqual((*attr).name,
                                          b"block\x00" as *const u8 as
                                              *const std::os::raw::c_char as
                                              *mut xmlChar) != 0 {
                        /*
		    * Attribute "block".
		    */
                        attrValue =
                            xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(attrValue,
                                                       &mut (*type_0).flags,
                                                       -(1 as std::os::raw::c_int),
                                                       (1 as std::os::raw::c_int) <<
                                                           18 as std::os::raw::c_int,
                                                       (1 as std::os::raw::c_int) <<
                                                           19 as std::os::raw::c_int,
                                                       -(1 as std::os::raw::c_int),
                                                       -(1 as std::os::raw::c_int),
                                                       -(1 as std::os::raw::c_int)) !=
                               0 as std::os::raw::c_int {
                            xmlSchemaPSimpleTypeErr(ctxt,
                                                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                    0 as
                                                        xmlSchemaBasicItemPtr,
                                                    attr as xmlNodePtr,
                                                    0 as xmlSchemaTypePtr,
                                                    b"(#all | List of (extension | restriction)) \x00"
                                                        as *const u8 as
                                                        *const std::os::raw::c_char,
                                                    attrValue,
                                                    0 as *const std::os::raw::c_char,
                                                    0 as *const xmlChar,
                                                    0 as *const xmlChar);
                        } else { block = 1 as std::os::raw::c_int }
                    } else {
                        xmlSchemaPIllegalAttrErr(ctxt,
                                                 XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                                 0 as xmlSchemaBasicItemPtr,
                                                 attr);
                    }
                }
            } else {
                xmlSchemaPIllegalAttrErr(ctxt,
                                         XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                         0 as xmlSchemaBasicItemPtr, attr);
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(ctxt, XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                     0 as xmlSchemaBasicItemPtr, attr);
        }
        attr = (*attr).next
    }
    if block == 0 {
        /*
	* Apply default "block" values.
	*/
        if (*schema).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
            (*type_0).flags |= (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int
        }
        if (*schema).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
            (*type_0).flags |= (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int
        }
    }
    if final_0 == 0 {
        /*
	* Apply default "block" values.
	*/
        if (*schema).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0 {
            (*type_0).flags |= (1 as std::os::raw::c_int) << 10 as std::os::raw::c_int
        }
        if (*schema).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
            (*type_0).flags |= (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int
        }
    }
    /*
    * And now for the children...
    */
    child = (*node).children;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"annotation\x00" as *const u8 as *const std::os::raw::c_char
                           as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        (*type_0).annot =
            xmlSchemaParseAnnotation(ctxt, child, 1 as std::os::raw::c_int);
        child = (*child).next
    }
    (*ctxt).ctxtType = type_0;
    if !child.is_null() && !(*child).ns.is_null() &&
           xmlStrEqual((*child).name,
                       b"simpleContent\x00" as *const u8 as
                           *const std::os::raw::c_char as *const xmlChar) != 0 &&
           xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* <complexType><simpleContent>...
	* 3.4.3 : 2.2
	* Specifying mixed='true' when the <simpleContent>
	* alternative is chosen has no effect
	*/
        if (*type_0).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 {
            (*type_0).flags ^= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
        }
        xmlSchemaParseSimpleContent(ctxt, schema, child,
                                    &mut hasRestrictionOrExtension);
        child = (*child).next
    } else if !child.is_null() && !(*child).ns.is_null() &&
                  xmlStrEqual((*child).name,
                              b"complexContent\x00" as *const u8 as
                                  *const std::os::raw::c_char as *const xmlChar) != 0
                  && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
        /*
	* <complexType><complexContent>...
	*/
        (*type_0).contentType = XML_SCHEMA_CONTENT_EMPTY;
        xmlSchemaParseComplexContent(ctxt, schema, child,
                                     &mut hasRestrictionOrExtension);
        child = (*child).next
    } else {
        /*
	* E.g <complexType><sequence>... or <complexType><attribute>... etc.
	*
	* SPEC
	* "...the third alternative (neither <simpleContent> nor
	* <complexContent>) is chosen. This case is understood as shorthand
	* for complex content restricting the `ur-type definition`, and the
	* details of the mappings should be modified as necessary.
	*/
        (*type_0).baseType = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
        (*type_0).flags |= (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int;
        /*
	* Parse model groups.
	*/
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"all\x00" as *const u8 as *const std::os::raw::c_char as
                               *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroup(ctxt, schema, child,
                                         XML_SCHEMA_TYPE_ALL,
                                         1 as std::os::raw::c_int) as
                    xmlSchemaTypePtr;
            child = (*child).next
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"choice\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroup(ctxt, schema, child,
                                         XML_SCHEMA_TYPE_CHOICE,
                                         1 as std::os::raw::c_int) as
                    xmlSchemaTypePtr;
            child = (*child).next
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"sequence\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroup(ctxt, schema, child,
                                         XML_SCHEMA_TYPE_SEQUENCE,
                                         1 as std::os::raw::c_int) as
                    xmlSchemaTypePtr;
            child = (*child).next
        } else if !child.is_null() && !(*child).ns.is_null() &&
                      xmlStrEqual((*child).name,
                                  b"group\x00" as *const u8 as
                                      *const std::os::raw::c_char as *const xmlChar)
                          != 0 &&
                      xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).subtypes =
                xmlSchemaParseModelGroupDefRef(ctxt, schema, child) as
                    xmlSchemaTypePtr;
            /*
	    * Note that the reference will be resolved in
	    * xmlSchemaResolveTypeReferences();
	    */
            child = (*child).next
        }
        /*
	* Parse attribute decls/refs.
	*/
        if xmlSchemaParseLocalAttributes(ctxt, schema, &mut child,
                                         &mut (*type_0).attrUses as
                                             *mut *mut std::os::raw::c_void as
                                             *mut xmlSchemaItemListPtr,
                                         XML_SCHEMA_TYPE_RESTRICTION as
                                             std::os::raw::c_int,
                                         0 as *mut std::os::raw::c_int) ==
               -(1 as std::os::raw::c_int) {
            return 0 as xmlSchemaTypePtr
        }
        /*
	* Parse attribute wildcard.
	*/
        if !child.is_null() && !(*child).ns.is_null() &&
               xmlStrEqual((*child).name,
                           b"anyAttribute\x00" as *const u8 as
                               *const std::os::raw::c_char as *const xmlChar) != 0 &&
               xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0 {
            (*type_0).attributeWildcard =
                xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = (*child).next
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(ctxt, XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                             0 as xmlSchemaBasicItemPtr, node, child,
                             0 as *const std::os::raw::c_char,
                             b"(annotation?, (simpleContent | complexContent | ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?))))\x00"
                                 as *const u8 as *const std::os::raw::c_char);
    }
    /*
    * REDEFINE: SPEC src-redefine (5)
    */
    if topLevel != 0 && (*ctxt).isRedefine != 0 &&
           hasRestrictionOrExtension == 0 {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_REDEFINE,
                            0 as xmlSchemaBasicItemPtr, node,
                            b"This is a redefinition, thus the <complexType> must have a <restriction> or <extension> grand-child\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
    }
    (*ctxt).ctxtType = ctxtType;
    return type_0;
}
/* ***********************************************************************
 *									*
 *			Validating using Schemas			*
 *									*
 ************************************************************************/
/* ***********************************************************************
 *									*
 *			Reading/Writing Schemas				*
 *									*
 ************************************************************************/
/* Will be enabled if it is clear what options are needed. */
/* *
 * xmlSchemaNewParserCtxt:
 * @URL:  the location of the schema
 *
 * Create an XML Schemas parse context for that file/resource expected
 * to contain an XML Schemas file.
 *
 * Returns the parser context or NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewParserCtxt(mut URL: *const std::os::raw::c_char)
 -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    if URL.is_null() { return 0 as xmlSchemaParserCtxtPtr }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() { return 0 as xmlSchemaParserCtxtPtr }
    (*ret).dict = xmlDictCreate();
    (*ret).URL =
        xmlDictLookup((*ret).dict, URL as *const xmlChar,
                      -(1 as std::os::raw::c_int));
    return ret;
}
/* *
 * xmlSchemaNewMemParserCtxt:
 * @buffer:  a pointer to a char array containing the schemas
 * @size:  the size of the array
 *
 * Create an XML Schemas parse context for that memory buffer expected
 * to contain an XML Schemas file.
 *
 * Returns the parser context or NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewMemParserCtxt(mut buffer:
                                                       *const std::os::raw::c_char,
                                                   mut size: std::os::raw::c_int)
 -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    if buffer.is_null() || size <= 0 as std::os::raw::c_int {
        return 0 as xmlSchemaParserCtxtPtr
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() { return 0 as xmlSchemaParserCtxtPtr }
    (*ret).buffer = buffer;
    (*ret).size = size;
    (*ret).dict = xmlDictCreate();
    return ret;
}
/* *
 * xmlSchemaNewDocParserCtxt:
 * @doc:  a preparsed document tree
 *
 * Create an XML Schemas parse context for that document.
 * NB. The document may be modified during the parsing process.
 *
 * Returns the parser context or NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewDocParserCtxt(mut doc: xmlDocPtr)
 -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    if doc.is_null() { return 0 as xmlSchemaParserCtxtPtr }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() { return 0 as xmlSchemaParserCtxtPtr }
    (*ret).doc = doc;
    (*ret).dict = xmlDictCreate();
    /* The application has responsibility for the document */
    (*ret).preserve = 1 as std::os::raw::c_int;
    return ret;
}
/* *
 * xmlSchemaFreeParserCtxt:
 * @ctxt:  the schema parser context
 *
 * Free the resources associated to the schema parser context
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeParserCtxt(mut ctxt:
                                                     xmlSchemaParserCtxtPtr) {
    if ctxt.is_null() { return }
    if !(*ctxt).doc.is_null() && (*ctxt).preserve == 0 {
        xmlFreeDoc((*ctxt).doc);
    }
    if !(*ctxt).vctxt.is_null() { xmlSchemaFreeValidCtxt((*ctxt).vctxt); }
    if (*ctxt).ownsConstructor != 0 && !(*ctxt).constructor.is_null() {
        xmlSchemaConstructionCtxtFree((*ctxt).constructor);
        (*ctxt).constructor = 0 as xmlSchemaConstructionCtxtPtr;
        (*ctxt).ownsConstructor = 0 as std::os::raw::c_int
    }
    if !(*ctxt).attrProhibs.is_null() {
        xmlSchemaItemListFree((*ctxt).attrProhibs);
    }
    xmlDictFree((*ctxt).dict);
    xmlFree.expect("non-null function pointer")(ctxt as *mut std::os::raw::c_void);
}
/* ***********************************************************************
 *									*
 *			Building the content models			*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaBuildContentModelForSubstGroup:
 *
 * Returns 1 if nillable, 0 otherwise
 */
unsafe extern "C" fn xmlSchemaBuildContentModelForSubstGroup(mut pctxt:
                                                                 xmlSchemaParserCtxtPtr,
                                                             mut particle:
                                                                 xmlSchemaParticlePtr,
                                                             mut counter:
                                                                 std::os::raw::c_int,
                                                             mut end:
                                                                 xmlAutomataStatePtr)
 -> std::os::raw::c_int {
    let mut start: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
    let mut tmp: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
    let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    let mut member: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    let mut substGroup: xmlSchemaSubstGroupPtr =
        0 as *mut xmlSchemaSubstGroup;
    let mut i: std::os::raw::c_int = 0;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    elemDecl = (*particle).children as xmlSchemaElementPtr;
    /*
    * Wrap the substitution group with a CHOICE.
    */
    start = (*pctxt).state;
    if end.is_null() { end = xmlAutomataNewState((*pctxt).am) }
    substGroup = xmlSchemaSubstGroupGet(pctxt, elemDecl);
    if substGroup.is_null() {
        xmlSchemaPErr(pctxt,
                      xmlSchemaGetComponentNode(particle as
                                                    xmlSchemaBasicItemPtr),
                      XML_SCHEMAP_INTERNAL as std::os::raw::c_int,
                      b"Internal error: xmlSchemaBuildContentModelForSubstGroup, declaration is marked having a subst. group but none available.\n\x00"
                          as *const u8 as *const std::os::raw::c_char,
                      (*elemDecl).name, 0 as *const xmlChar);
        return 0 as std::os::raw::c_int
    }
    if counter >= 0 as std::os::raw::c_int {
        /*
	* NOTE that we put the declaration in, even if it's abstract.
	* However, an error will be raised during *validation* if an element
	* information item shall be validated against an abstract element
	* declaration.
	*/
        tmp =
            xmlAutomataNewCountedTrans((*pctxt).am, start,
                                       0 as xmlAutomataStatePtr, counter);
        xmlAutomataNewTransition2((*pctxt).am, tmp, end, (*elemDecl).name,
                                  (*elemDecl).targetNamespace,
                                  elemDecl as *mut std::os::raw::c_void);
        /*
	* Add subst. group members.
	*/
        i = 0 as std::os::raw::c_int;
        while i < (*(*substGroup).members).nbItems {
            member =
                *(*(*substGroup).members).items.offset(i as isize) as
                    xmlSchemaElementPtr;
            xmlAutomataNewTransition2((*pctxt).am, tmp, end, (*member).name,
                                      (*member).targetNamespace,
                                      member as *mut std::os::raw::c_void);
            i += 1
        }
    } else if (*particle).maxOccurs == 1 as std::os::raw::c_int {
        /*
	* NOTE that we put the declaration in, even if it's abstract,
	*/
        xmlAutomataNewEpsilon((*pctxt).am,
                              xmlAutomataNewTransition2((*pctxt).am, start,
                                                        0 as
                                                            xmlAutomataStatePtr,
                                                        (*elemDecl).name,
                                                        (*elemDecl).targetNamespace,
                                                        elemDecl as
                                                            *mut std::os::raw::c_void),
                              end);
        /*
	* Add subst. group members.
	*/
        i = 0 as std::os::raw::c_int;
        while i < (*(*substGroup).members).nbItems {
            member =
                *(*(*substGroup).members).items.offset(i as isize) as
                    xmlSchemaElementPtr;
            /*
	    * NOTE: This fixes bug #341150. xmlAutomataNewOnceTrans2()
	    *  was incorrectly used instead of xmlAutomataNewTransition2()
	    *  (seems like a copy&paste bug from the XML_SCHEMA_TYPE_ALL
	    *  section in xmlSchemaBuildAContentModel() ).
	    * TODO: Check if xmlAutomataNewOnceTrans2() was instead
	    *  intended for the above "counter" section originally. I.e.,
	    *  check xs:all with subst-groups.
	    *
	    * tmp = xmlAutomataNewOnceTrans2(pctxt->am, start, NULL,
	    *	               member->name, member->targetNamespace,
	    *		       1, 1, member);
	    */
            tmp =
                xmlAutomataNewTransition2((*pctxt).am, start,
                                          0 as xmlAutomataStatePtr,
                                          (*member).name,
                                          (*member).targetNamespace,
                                          member as *mut std::os::raw::c_void);
            xmlAutomataNewEpsilon((*pctxt).am, tmp, end);
            i += 1
        }
    } else {
        let mut hop: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
        let mut maxOccurs: std::os::raw::c_int =
            if (*particle).maxOccurs ==
                   (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int {
                ((1 as std::os::raw::c_int)) << 30 as std::os::raw::c_int
            } else { ((*particle).maxOccurs) - 1 as std::os::raw::c_int };
        let mut minOccurs: std::os::raw::c_int =
            if (*particle).minOccurs < 1 as std::os::raw::c_int {
                0 as std::os::raw::c_int
            } else { ((*particle).minOccurs) - 1 as std::os::raw::c_int };
        counter = xmlAutomataNewCounter((*pctxt).am, minOccurs, maxOccurs);
        hop = xmlAutomataNewState((*pctxt).am);
        xmlAutomataNewEpsilon((*pctxt).am,
                              xmlAutomataNewTransition2((*pctxt).am, start,
                                                        0 as
                                                            xmlAutomataStatePtr,
                                                        (*elemDecl).name,
                                                        (*elemDecl).targetNamespace,
                                                        elemDecl as
                                                            *mut std::os::raw::c_void),
                              hop);
        /*
	 * Add subst. group members.
	 */
        i = 0 as std::os::raw::c_int;
        while i < (*(*substGroup).members).nbItems {
            member =
                *(*(*substGroup).members).items.offset(i as isize) as
                    xmlSchemaElementPtr;
            xmlAutomataNewEpsilon((*pctxt).am,
                                  xmlAutomataNewTransition2((*pctxt).am,
                                                            start,
                                                            0 as
                                                                xmlAutomataStatePtr,
                                                            (*member).name,
                                                            (*member).targetNamespace,
                                                            member as
                                                                *mut std::os::raw::c_void),
                                  hop);
            i += 1
        }
        xmlAutomataNewCountedTrans((*pctxt).am, hop, start, counter);
        xmlAutomataNewCounterTrans((*pctxt).am, hop, end, counter);
    }
    if (*particle).minOccurs == 0 as std::os::raw::c_int {
        xmlAutomataNewEpsilon((*pctxt).am, start, end);
        ret = 1 as std::os::raw::c_int
    }
    (*pctxt).state = end;
    return ret;
}
/* *
 * xmlSchemaBuildContentModelForElement:
 *
 * Returns 1 if nillable, 0 otherwise
 */
unsafe extern "C" fn xmlSchemaBuildContentModelForElement(mut ctxt:
                                                              xmlSchemaParserCtxtPtr,
                                                          mut particle:
                                                              xmlSchemaParticlePtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if (*((*particle).children as xmlSchemaElementPtr)).flags &
           (1 as std::os::raw::c_int) << 17 as std::os::raw::c_int != 0 {
        /*
	* Substitution groups.
	*/
        ret =
            xmlSchemaBuildContentModelForSubstGroup(ctxt, particle,
                                                    -(1 as std::os::raw::c_int),
                                                    0 as xmlAutomataStatePtr)
    } else {
        let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
        let mut start: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
        elemDecl = (*particle).children as xmlSchemaElementPtr;
        if (*elemDecl).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int != 0 {
            return 0 as std::os::raw::c_int
        }
        if (*particle).maxOccurs == 1 as std::os::raw::c_int {
            start = (*ctxt).state;
            (*ctxt).state =
                xmlAutomataNewTransition2((*ctxt).am, start,
                                          0 as xmlAutomataStatePtr,
                                          (*elemDecl).name,
                                          (*elemDecl).targetNamespace,
                                          elemDecl as *mut std::os::raw::c_void)
        } else if (*particle).maxOccurs >=
                      (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int &&
                      (*particle).minOccurs < 2 as std::os::raw::c_int {
            /* Special case. */
            start = (*ctxt).state;
            (*ctxt).state =
                xmlAutomataNewTransition2((*ctxt).am, start,
                                          0 as xmlAutomataStatePtr,
                                          (*elemDecl).name,
                                          (*elemDecl).targetNamespace,
                                          elemDecl as *mut std::os::raw::c_void);
            (*ctxt).state =
                xmlAutomataNewTransition2((*ctxt).am, (*ctxt).state,
                                          (*ctxt).state, (*elemDecl).name,
                                          (*elemDecl).targetNamespace,
                                          elemDecl as *mut std::os::raw::c_void)
        } else {
            let mut counter: std::os::raw::c_int = 0;
            let mut maxOccurs: std::os::raw::c_int =
                if (*particle).maxOccurs ==
                       (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int {
                    ((1 as std::os::raw::c_int)) << 30 as std::os::raw::c_int
                } else { ((*particle).maxOccurs) - 1 as std::os::raw::c_int };
            let mut minOccurs: std::os::raw::c_int =
                if (*particle).minOccurs < 1 as std::os::raw::c_int {
                    0 as std::os::raw::c_int
                } else { ((*particle).minOccurs) - 1 as std::os::raw::c_int };
            start =
                xmlAutomataNewEpsilon((*ctxt).am, (*ctxt).state,
                                      0 as xmlAutomataStatePtr);
            counter = xmlAutomataNewCounter((*ctxt).am, minOccurs, maxOccurs);
            (*ctxt).state =
                xmlAutomataNewTransition2((*ctxt).am, start,
                                          0 as xmlAutomataStatePtr,
                                          (*elemDecl).name,
                                          (*elemDecl).targetNamespace,
                                          elemDecl as *mut std::os::raw::c_void);
            xmlAutomataNewCountedTrans((*ctxt).am, (*ctxt).state, start,
                                       counter);
            (*ctxt).state =
                xmlAutomataNewCounterTrans((*ctxt).am, (*ctxt).state,
                                           0 as xmlAutomataStatePtr, counter)
        }
        if (*particle).minOccurs == 0 as std::os::raw::c_int {
            xmlAutomataNewEpsilon((*ctxt).am, start, (*ctxt).state);
            ret = 1 as std::os::raw::c_int
        }
    }
    return ret;
}
/* *
 * xmlSchemaBuildAContentModel:
 * @ctxt:  the schema parser context
 * @particle:  the particle component
 * @name:  the complex type's name whose content is being built
 *
 * Create the automaton for the {content type} of a complex type.
 *
 * Returns 1 if the content is nillable, 0 otherwise
 */
unsafe extern "C" fn xmlSchemaBuildAContentModel(mut pctxt:
                                                     xmlSchemaParserCtxtPtr,
                                                 mut particle:
                                                     xmlSchemaParticlePtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut tmp2: std::os::raw::c_int = 0;
    if particle.is_null() {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaBuildAContentModel\x00" as *const u8
                                 as *const std::os::raw::c_char,
                             b"particle is NULL\x00" as *const u8 as
                                 *const std::os::raw::c_char);
        return 1 as std::os::raw::c_int
    }
    if (*particle).children.is_null() {
        /*
	* Just return in this case. A missing "term" of the particle
	* might arise due to an invalid "term" component.
	*/
        return 1 as std::os::raw::c_int
    }
    match (*(*particle).children).type_0 as std::os::raw::c_uint {
        2 => {
            let mut start: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut end: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut wild: xmlSchemaWildcardPtr = 0 as *mut xmlSchemaWildcard;
            let mut ns: xmlSchemaWildcardNsPtr =
                0 as *mut xmlSchemaWildcardNs;
            wild = (*particle).children as xmlSchemaWildcardPtr;
            start = (*pctxt).state;
            end = xmlAutomataNewState((*pctxt).am);
            if (*particle).maxOccurs == 1 as std::os::raw::c_int {
                if (*wild).any == 1 as std::os::raw::c_int {
                    /*
		    * We need to add both transitions:
		    *
		    * 1. the {"*", "*"} for elements in a namespace.
		    */
                    (*pctxt).state =
                        xmlAutomataNewTransition2((*pctxt).am, start,
                                                  0 as xmlAutomataStatePtr,
                                                  b"*\x00" as *const u8 as
                                                      *const std::os::raw::c_char as
                                                      *mut xmlChar,
                                                  b"*\x00" as *const u8 as
                                                      *const std::os::raw::c_char as
                                                      *mut xmlChar,
                                                  wild as *mut std::os::raw::c_void);
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end);
                    /*
		    * 2. the {"*"} for elements in no namespace.
		    */
                    (*pctxt).state =
                        xmlAutomataNewTransition2((*pctxt).am, start,
                                                  0 as xmlAutomataStatePtr,
                                                  b"*\x00" as *const u8 as
                                                      *const std::os::raw::c_char as
                                                      *mut xmlChar,
                                                  0 as *const xmlChar,
                                                  wild as *mut std::os::raw::c_void);
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end);
                } else if !(*wild).nsSet.is_null() {
                    ns = (*wild).nsSet;
                    loop  {
                        (*pctxt).state = start;
                        (*pctxt).state =
                            xmlAutomataNewTransition2((*pctxt).am,
                                                      (*pctxt).state,
                                                      0 as
                                                          xmlAutomataStatePtr,
                                                      b"*\x00" as *const u8 as
                                                          *const std::os::raw::c_char
                                                          as *mut xmlChar,
                                                      (*ns).value,
                                                      wild as
                                                          *mut std::os::raw::c_void);
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state,
                                              end);
                        ns = (*ns).next;
                        if ns.is_null() { break ; }
                    }
                } else if !(*wild).negNsSet.is_null() {
                    (*pctxt).state =
                        xmlAutomataNewNegTrans((*pctxt).am, start, end,
                                               b"*\x00" as *const u8 as
                                                   *const std::os::raw::c_char as
                                                   *mut xmlChar,
                                               (*(*wild).negNsSet).value,
                                               wild as *mut std::os::raw::c_void)
                }
            } else {
                let mut counter: std::os::raw::c_int = 0;
                let mut hop: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                let mut maxOccurs: std::os::raw::c_int =
                    if (*particle).maxOccurs ==
                           (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int {
                        ((1 as std::os::raw::c_int)) << 30 as std::os::raw::c_int
                    } else { ((*particle).maxOccurs) - 1 as std::os::raw::c_int };
                let mut minOccurs: std::os::raw::c_int =
                    if (*particle).minOccurs < 1 as std::os::raw::c_int {
                        0 as std::os::raw::c_int
                    } else { ((*particle).minOccurs) - 1 as std::os::raw::c_int };
                counter =
                    xmlAutomataNewCounter((*pctxt).am, minOccurs, maxOccurs);
                hop = xmlAutomataNewState((*pctxt).am);
                if (*wild).any == 1 as std::os::raw::c_int {
                    (*pctxt).state =
                        xmlAutomataNewTransition2((*pctxt).am, start,
                                                  0 as xmlAutomataStatePtr,
                                                  b"*\x00" as *const u8 as
                                                      *const std::os::raw::c_char as
                                                      *mut xmlChar,
                                                  b"*\x00" as *const u8 as
                                                      *const std::os::raw::c_char as
                                                      *mut xmlChar,
                                                  wild as *mut std::os::raw::c_void);
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop);
                    (*pctxt).state =
                        xmlAutomataNewTransition2((*pctxt).am, start,
                                                  0 as xmlAutomataStatePtr,
                                                  b"*\x00" as *const u8 as
                                                      *const std::os::raw::c_char as
                                                      *mut xmlChar,
                                                  0 as *const xmlChar,
                                                  wild as *mut std::os::raw::c_void);
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop);
                } else if !(*wild).nsSet.is_null() {
                    ns = (*wild).nsSet;
                    loop  {
                        (*pctxt).state =
                            xmlAutomataNewTransition2((*pctxt).am, start,
                                                      0 as
                                                          xmlAutomataStatePtr,
                                                      b"*\x00" as *const u8 as
                                                          *const std::os::raw::c_char
                                                          as *mut xmlChar,
                                                      (*ns).value,
                                                      wild as
                                                          *mut std::os::raw::c_void);
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state,
                                              hop);
                        ns = (*ns).next;
                        if ns.is_null() { break ; }
                    }
                } else if !(*wild).negNsSet.is_null() {
                    (*pctxt).state =
                        xmlAutomataNewNegTrans((*pctxt).am, start, hop,
                                               b"*\x00" as *const u8 as
                                                   *const std::os::raw::c_char as
                                                   *mut xmlChar,
                                               (*(*wild).negNsSet).value,
                                               wild as *mut std::os::raw::c_void)
                }
                xmlAutomataNewCountedTrans((*pctxt).am, hop, start, counter);
                xmlAutomataNewCounterTrans((*pctxt).am, hop, end, counter);
            }
            if (*particle).minOccurs == 0 as std::os::raw::c_int {
                xmlAutomataNewEpsilon((*pctxt).am, start, end);
                ret = 1 as std::os::raw::c_int
            }
            (*pctxt).state = end
        }
        14 => { ret = xmlSchemaBuildContentModelForElement(pctxt, particle) }
        6 => {
            let mut sub: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
            ret = 1 as std::os::raw::c_int;
            /*
             * If max and min occurances are default (1) then
             * simply iterate over the particles of the <sequence>.
             */
            if (*particle).minOccurs == 1 as std::os::raw::c_int &&
                   (*particle).maxOccurs == 1 as std::os::raw::c_int {
                sub = (*(*particle).children).children;
                while !sub.is_null() {
                    tmp2 =
                        xmlSchemaBuildAContentModel(pctxt,
                                                    sub as
                                                        xmlSchemaParticlePtr);
                    if tmp2 != 1 as std::os::raw::c_int { ret = 0 as std::os::raw::c_int }
                    sub = (*sub).next
                }
            } else {
                let mut oldstate: xmlAutomataStatePtr = (*pctxt).state;
                if (*particle).maxOccurs >=
                       (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int {
                    if (*particle).minOccurs > 1 as std::os::raw::c_int {
                        let mut tmp: xmlAutomataStatePtr =
                            0 as *mut xmlAutomataState;
                        let mut counter_0: std::os::raw::c_int = 0;
                        (*pctxt).state =
                            xmlAutomataNewEpsilon((*pctxt).am, oldstate,
                                                  0 as xmlAutomataStatePtr);
                        oldstate = (*pctxt).state;
                        counter_0 =
                            xmlAutomataNewCounter((*pctxt).am,
                                                  (*particle).minOccurs -
                                                      1 as std::os::raw::c_int,
                                                  (1 as std::os::raw::c_int) <<
                                                      30 as std::os::raw::c_int);
                        sub = (*(*particle).children).children;
                        while !sub.is_null() {
                            tmp2 =
                                xmlSchemaBuildAContentModel(pctxt,
                                                            sub as
                                                                xmlSchemaParticlePtr);
                            if tmp2 != 1 as std::os::raw::c_int {
                                ret = 0 as std::os::raw::c_int
                            }
                            sub = (*sub).next
                        }
                        tmp = (*pctxt).state;
                        xmlAutomataNewCountedTrans((*pctxt).am, tmp, oldstate,
                                                   counter_0);
                        (*pctxt).state =
                            xmlAutomataNewCounterTrans((*pctxt).am, tmp,
                                                       0 as
                                                           xmlAutomataStatePtr,
                                                       counter_0);
                        if ret == 1 as std::os::raw::c_int {
                            xmlAutomataNewEpsilon((*pctxt).am, oldstate,
                                                  (*pctxt).state);
                        }
                    } else {
                        (*pctxt).state =
                            xmlAutomataNewEpsilon((*pctxt).am, oldstate,
                                                  0 as xmlAutomataStatePtr);
                        oldstate = (*pctxt).state;
                        sub = (*(*particle).children).children;
                        while !sub.is_null() {
                            tmp2 =
                                xmlSchemaBuildAContentModel(pctxt,
                                                            sub as
                                                                xmlSchemaParticlePtr);
                            if tmp2 != 1 as std::os::raw::c_int {
                                ret = 0 as std::os::raw::c_int
                            }
                            sub = (*sub).next
                        }
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state,
                                              oldstate);
                        /*
                         * epsilon needed to block previous trans from
                         * being allowed to enter back from another
                         * construct
                         */
                        (*pctxt).state =
                            xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state,
                                                  0 as xmlAutomataStatePtr);
                        if (*particle).minOccurs == 0 as std::os::raw::c_int {
                            xmlAutomataNewEpsilon((*pctxt).am, oldstate,
                                                  (*pctxt).state);
                            ret = 1 as std::os::raw::c_int
                        }
                    }
                } else if (*particle).maxOccurs > 1 as std::os::raw::c_int ||
                              (*particle).minOccurs > 1 as std::os::raw::c_int {
                    let mut tmp_0: xmlAutomataStatePtr =
                        0 as *mut xmlAutomataState;
                    let mut counter_1: std::os::raw::c_int = 0;
                    (*pctxt).state =
                        xmlAutomataNewEpsilon((*pctxt).am, oldstate,
                                              0 as xmlAutomataStatePtr);
                    oldstate = (*pctxt).state;
                    counter_1 =
                        xmlAutomataNewCounter((*pctxt).am,
                                              (*particle).minOccurs -
                                                  1 as std::os::raw::c_int,
                                              (*particle).maxOccurs -
                                                  1 as std::os::raw::c_int);
                    sub = (*(*particle).children).children;
                    while !sub.is_null() {
                        tmp2 =
                            xmlSchemaBuildAContentModel(pctxt,
                                                        sub as
                                                            xmlSchemaParticlePtr);
                        if tmp2 != 1 as std::os::raw::c_int { ret = 0 as std::os::raw::c_int }
                        sub = (*sub).next
                    }
                    tmp_0 = (*pctxt).state;
                    xmlAutomataNewCountedTrans((*pctxt).am, tmp_0, oldstate,
                                               counter_1);
                    (*pctxt).state =
                        xmlAutomataNewCounterTrans((*pctxt).am, tmp_0,
                                                   0 as xmlAutomataStatePtr,
                                                   counter_1);
                    if (*particle).minOccurs == 0 as std::os::raw::c_int ||
                           ret == 1 as std::os::raw::c_int {
                        xmlAutomataNewEpsilon((*pctxt).am, oldstate,
                                              (*pctxt).state);
                        ret = 1 as std::os::raw::c_int
                    }
                } else {
                    sub = (*(*particle).children).children;
                    while !sub.is_null() {
                        tmp2 =
                            xmlSchemaBuildAContentModel(pctxt,
                                                        sub as
                                                            xmlSchemaParticlePtr);
                        if tmp2 != 1 as std::os::raw::c_int { ret = 0 as std::os::raw::c_int }
                        sub = (*sub).next
                    }
                    /*
		     * epsilon needed to block previous trans from
		     * being allowed to enter back from another
		     * construct
		     */
                    (*pctxt).state =
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state,
                                              0 as xmlAutomataStatePtr);
                    if (*particle).minOccurs == 0 as std::os::raw::c_int {
                        xmlAutomataNewEpsilon((*pctxt).am, oldstate,
                                              (*pctxt).state);
                        ret = 1 as std::os::raw::c_int
                    }
                }
            }
        }
        7 => {
            let mut sub_0: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
            let mut start_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut end_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            ret = 0 as std::os::raw::c_int;
            start_0 = (*pctxt).state;
            end_0 = xmlAutomataNewState((*pctxt).am);
            /*
             * iterate over the subtypes and remerge the end with an
             * epsilon transition
             */
            if (*particle).maxOccurs == 1 as std::os::raw::c_int {
                sub_0 = (*(*particle).children).children;
                while !sub_0.is_null() {
                    (*pctxt).state = start_0;
                    tmp2 =
                        xmlSchemaBuildAContentModel(pctxt,
                                                    sub_0 as
                                                        xmlSchemaParticlePtr);
                    if tmp2 == 1 as std::os::raw::c_int { ret = 1 as std::os::raw::c_int }
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end_0);
                    sub_0 = (*sub_0).next
                }
            } else {
                let mut counter_2: std::os::raw::c_int = 0;
                let mut hop_0: xmlAutomataStatePtr =
                    0 as *mut xmlAutomataState;
                let mut base: xmlAutomataStatePtr =
                    0 as *mut xmlAutomataState;
                let mut maxOccurs_0: std::os::raw::c_int =
                    if (*particle).maxOccurs ==
                           (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int {
                        ((1 as std::os::raw::c_int)) << 30 as std::os::raw::c_int
                    } else { ((*particle).maxOccurs) - 1 as std::os::raw::c_int };
                let mut minOccurs_0: std::os::raw::c_int =
                    if (*particle).minOccurs < 1 as std::os::raw::c_int {
                        0 as std::os::raw::c_int
                    } else { ((*particle).minOccurs) - 1 as std::os::raw::c_int };
                /*
                 * use a counter to keep track of the number of transtions
                 * which went through the choice.
                 */
                counter_2 =
                    xmlAutomataNewCounter((*pctxt).am, minOccurs_0,
                                          maxOccurs_0);
                hop_0 = xmlAutomataNewState((*pctxt).am);
                base = xmlAutomataNewState((*pctxt).am);
                sub_0 = (*(*particle).children).children;
                while !sub_0.is_null() {
                    (*pctxt).state = base;
                    tmp2 =
                        xmlSchemaBuildAContentModel(pctxt,
                                                    sub_0 as
                                                        xmlSchemaParticlePtr);
                    if tmp2 == 1 as std::os::raw::c_int { ret = 1 as std::os::raw::c_int }
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop_0);
                    sub_0 = (*sub_0).next
                }
                xmlAutomataNewEpsilon((*pctxt).am, start_0, base);
                xmlAutomataNewCountedTrans((*pctxt).am, hop_0, base,
                                           counter_2);
                xmlAutomataNewCounterTrans((*pctxt).am, hop_0, end_0,
                                           counter_2);
                if ret == 1 as std::os::raw::c_int {
                    xmlAutomataNewEpsilon((*pctxt).am, base, end_0);
                }
            }
            if (*particle).minOccurs == 0 as std::os::raw::c_int {
                xmlAutomataNewEpsilon((*pctxt).am, start_0, end_0);
                ret = 1 as std::os::raw::c_int
            }
            (*pctxt).state = end_0
        }
        8 => {
            let mut start_1: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut tmp_1: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut sub_1: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
            let mut elemDecl: xmlSchemaElementPtr =
                0 as *mut xmlSchemaElement;
            ret = 1 as std::os::raw::c_int;
            sub_1 = (*(*particle).children).children as xmlSchemaParticlePtr;
            if !sub_1.is_null() {
                ret = 0 as std::os::raw::c_int;
                start_1 = (*pctxt).state;
                tmp_1 = xmlAutomataNewState((*pctxt).am);
                xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, tmp_1);
                (*pctxt).state = tmp_1;
                while !sub_1.is_null() {
                    (*pctxt).state = tmp_1;
                    elemDecl = (*sub_1).children as xmlSchemaElementPtr;
                    if elemDecl.is_null() {
                        xmlSchemaInternalErr(pctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             b"xmlSchemaBuildAContentModel\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"<element> particle has no term\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                        return ret
                    }
                    /*
                * NOTE: The {max occurs} of all the particles in the
                * {particles} of the group must be 0 or 1; this is
                * already ensured during the parse of the content of
                * <all>.
                */
                    if (*elemDecl).flags &
                           (1 as std::os::raw::c_int) << 17 as std::os::raw::c_int != 0 {
                        let mut counter_3: std::os::raw::c_int = 0;
                        /*
                     * This is an abstract group, we need to share
                     * the same counter for all the element transitions
                     * derived from the group
                     */
                        counter_3 =
                            xmlAutomataNewCounter((*pctxt).am,
                                                  (*sub_1).minOccurs,
                                                  (*sub_1).maxOccurs);
                        xmlSchemaBuildContentModelForSubstGroup(pctxt, sub_1,
                                                                counter_3,
                                                                (*pctxt).state);
                    } else if (*sub_1).minOccurs == 1 as std::os::raw::c_int &&
                                  (*sub_1).maxOccurs == 1 as std::os::raw::c_int {
                        xmlAutomataNewOnceTrans2((*pctxt).am, (*pctxt).state,
                                                 (*pctxt).state,
                                                 (*elemDecl).name,
                                                 (*elemDecl).targetNamespace,
                                                 1 as std::os::raw::c_int,
                                                 1 as std::os::raw::c_int,
                                                 elemDecl as
                                                     *mut std::os::raw::c_void);
                    } else if (*sub_1).minOccurs == 0 as std::os::raw::c_int &&
                                  (*sub_1).maxOccurs == 1 as std::os::raw::c_int {
                        xmlAutomataNewCountTrans2((*pctxt).am, (*pctxt).state,
                                                  (*pctxt).state,
                                                  (*elemDecl).name,
                                                  (*elemDecl).targetNamespace,
                                                  0 as std::os::raw::c_int,
                                                  1 as std::os::raw::c_int,
                                                  elemDecl as
                                                      *mut std::os::raw::c_void);
                    }
                    sub_1 = (*sub_1).next as xmlSchemaParticlePtr
                }
                (*pctxt).state =
                    xmlAutomataNewAllTrans((*pctxt).am, (*pctxt).state,
                                           0 as xmlAutomataStatePtr,
                                           0 as std::os::raw::c_int);
                if (*particle).minOccurs == 0 as std::os::raw::c_int {
                    xmlAutomataNewEpsilon((*pctxt).am, start_1,
                                          (*pctxt).state);
                    ret = 1 as std::os::raw::c_int
                }
            }
        }
        17 => {
            /*
	    * If we hit a model group definition, then this means that
	    * it was empty, thus was not substituted for the containing
	    * model group. Just do nothing in this case.
	    * TODO: But the group should be substituted and not occur at
	    * all in the content model at this point. Fix this.
	    */
            ret = 1 as std::os::raw::c_int
        }
        _ => {
            xmlSchemaInternalErr2(pctxt as xmlSchemaAbstractCtxtPtr,
                                  b"xmlSchemaBuildAContentModel\x00" as
                                      *const u8 as *const std::os::raw::c_char,
                                  b"found unexpected term of type \'%s\' in content model\x00"
                                      as *const u8 as *const std::os::raw::c_char,
                                  xmlSchemaGetComponentTypeStr((*particle).children
                                                                   as
                                                                   xmlSchemaBasicItemPtr),
                                  0 as *const xmlChar);
            return ret
        }
    }
    return ret;
}
/* *
 * xmlSchemaBuildContentModel:
 * @ctxt:  the schema parser context
 * @type:  the complex type definition
 * @name:  the element name
 *
 * Builds the content model of the complex type.
 */
unsafe extern "C" fn xmlSchemaBuildContentModel(mut type_0: xmlSchemaTypePtr,
                                                mut ctxt:
                                                    xmlSchemaParserCtxtPtr) {
    if (*type_0).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
           !(*type_0).contModel.is_null() ||
           (*type_0).contentType as std::os::raw::c_uint !=
               XML_SCHEMA_CONTENT_ELEMENTS as std::os::raw::c_int as std::os::raw::c_uint &&
               (*type_0).contentType as std::os::raw::c_uint !=
                   XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as std::os::raw::c_uint {
        return
    }
    (*ctxt).am = 0 as xmlAutomataPtr;
    (*ctxt).am = xmlNewAutomata();
    if (*ctxt).am.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Cannot create automata for complex type %s\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   (*type_0).name);
        return
    }
    (*ctxt).state = xmlAutomataGetInitState((*ctxt).am);
    /*
    * Build the automaton.
    */
    xmlSchemaBuildAContentModel(ctxt,
                                (*type_0).subtypes as xmlSchemaParticlePtr);
    xmlAutomataSetFinalState((*ctxt).am, (*ctxt).state);
    (*type_0).contModel = xmlAutomataCompile((*ctxt).am);
    if (*type_0).contModel.is_null() {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_INTERNAL,
                            type_0 as xmlSchemaBasicItemPtr, (*type_0).node,
                            b"Failed to compile the content model\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
    } else if xmlRegexpIsDeterminist((*type_0).contModel) != 1 as std::os::raw::c_int
     {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_NOT_DETERMINISTIC,
                            type_0 as xmlSchemaBasicItemPtr, (*type_0).node,
                            b"The content model is not determinist\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
    }
    (*ctxt).state = 0 as xmlAutomataStatePtr;
    xmlFreeAutomata((*ctxt).am);
    (*ctxt).am = 0 as xmlAutomataPtr;
}
/* *
 * xmlSchemaResolveElementReferences:
 * @elem:  the schema element context
 * @ctxt:  the schema parser context
 *
 * Resolves the references of an element declaration
 * or particle, which has an element declaration as it's
 * term.
 */
unsafe extern "C" fn xmlSchemaResolveElementReferences(mut elemDecl:
                                                           xmlSchemaElementPtr,
                                                       mut ctxt:
                                                           xmlSchemaParserCtxtPtr) {
    if ctxt.is_null() || elemDecl.is_null() ||
           !elemDecl.is_null() &&
               (*elemDecl).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0
       {
        return
    }
    (*elemDecl).flags |= (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int;
    if (*elemDecl).subtypes.is_null() && !(*elemDecl).namedType.is_null() {
        let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        /* (type definition) ... otherwise the type definition `resolved`
	* to by the `actual value` of the type [attribute] ...
	*/
        type_0 =
            xmlSchemaGetType((*ctxt).schema, (*elemDecl).namedType,
                             (*elemDecl).namedTypeNs);
        if type_0.is_null() {
            xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
                                     elemDecl as xmlSchemaBasicItemPtr,
                                     (*elemDecl).node,
                                     b"type\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     (*elemDecl).namedType,
                                     (*elemDecl).namedTypeNs,
                                     XML_SCHEMA_TYPE_BASIC,
                                     b"type definition\x00" as *const u8 as
                                         *const std::os::raw::c_char);
        } else { (*elemDecl).subtypes = type_0 }
    }
    if !(*elemDecl).substGroup.is_null() {
        let mut substHead: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
        /*
	* FIXME TODO: Do we need a new field in _xmlSchemaElement for
	* substitutionGroup?
	*/
        substHead =
            xmlSchemaGetElem((*ctxt).schema, (*elemDecl).substGroup,
                             (*elemDecl).substGroupNs);
        if substHead.is_null() {
            xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
                                     elemDecl as xmlSchemaBasicItemPtr,
                                     0 as xmlNodePtr,
                                     b"substitutionGroup\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     (*elemDecl).substGroup,
                                     (*elemDecl).substGroupNs,
                                     XML_SCHEMA_TYPE_ELEMENT,
                                     0 as *const std::os::raw::c_char);
        } else {
            xmlSchemaResolveElementReferences(substHead, ctxt);
            /*
	    * Set the "substitution group affiliation".
	    * NOTE that now we use the "refDecl" field for this.
	    */
            (*elemDecl).refDecl = substHead;
            /*
	    * The type definitions is set to:
	    * SPEC "...the {type definition} of the element
	    * declaration `resolved` to by the `actual value`
	    * of the substitutionGroup [attribute], if present"
	    */
            if (*elemDecl).subtypes.is_null() {
                (*elemDecl).subtypes = (*substHead).subtypes
            }
        }
    }
    /*
    * SPEC "The definition of anyType serves as the default type definition
    * for element declarations whose XML representation does not specify one."
    */
    if (*elemDecl).subtypes.is_null() && (*elemDecl).namedType.is_null() &&
           (*elemDecl).substGroup.is_null() {
        (*elemDecl).subtypes = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE)
    };
}
/* *
 * xmlSchemaResolveUnionMemberTypes:
 * @ctxt:  the schema parser context
 * @type:  the schema simple type definition
 *
 * Checks and builds the "member type definitions" property of the union
 * simple type. This handles part (1), part (2) is done in
 * xmlSchemaFinishMemberTypeDefinitionsProperty()
 *
 * Returns -1 in case of an internal error, 0 otherwise.
 */
unsafe extern "C" fn xmlSchemaResolveUnionMemberTypes(mut ctxt:
                                                          xmlSchemaParserCtxtPtr,
                                                      mut type_0:
                                                          xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut link: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut lastLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut newLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut memberType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    /*
    * SPEC (1) "If the <union> alternative is chosen, then [Definition:]
    * define the explicit members as the type definitions `resolved`
    * to by the items in the `actual value` of the memberTypes [attribute],
    * if any, followed by the type definitions corresponding to the
    * <simpleType>s among the [children] of <union>, if any."
    */
    /*
    * Resolve references.
    */
    link = (*type_0).memberTypes;
    lastLink = 0 as xmlSchemaTypeLinkPtr;
    while !link.is_null() {
        let mut name: *const xmlChar = 0 as *const xmlChar;
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        name = (*((*link).type_0 as xmlSchemaQNameRefPtr)).name;
        nsName = (*((*link).type_0 as xmlSchemaQNameRefPtr)).targetNamespace;
        memberType = xmlSchemaGetType((*ctxt).schema, name, nsName);
        if memberType.is_null() ||
               !((*memberType).type_0 as std::os::raw::c_uint ==
                     XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                     (*memberType).type_0 as std::os::raw::c_uint ==
                         XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint
                         &&
                         (*memberType).builtInType !=
                             XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
            xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
                                     type_0 as xmlSchemaBasicItemPtr,
                                     (*type_0).node,
                                     b"memberTypes\x00" as *const u8 as
                                         *const std::os::raw::c_char, name, nsName,
                                     XML_SCHEMA_TYPE_SIMPLE,
                                     0 as *const std::os::raw::c_char);
            /*
	    * Remove the member type link.
	    */
            if lastLink.is_null() {
                (*type_0).memberTypes = (*link).next
            } else { (*lastLink).next = (*link).next }
            newLink = link;
            link = (*link).next;
            xmlFree.expect("non-null function pointer")(newLink as
                                                            *mut std::os::raw::c_void);
        } else {
            (*link).type_0 = memberType;
            lastLink = link;
            link = (*link).next
        }
    }
    /*
    * Add local simple types,
    */
    memberType = (*type_0).subtypes;
    while !memberType.is_null() {
        link =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaTypeLink>()
                                                              as
                                                              std::os::raw::c_ulong)
                as xmlSchemaTypeLinkPtr;
        if link.is_null() {
            xmlSchemaPErrMemory(ctxt,
                                b"allocating a type link\x00" as *const u8 as
                                    *const std::os::raw::c_char, 0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
        (*link).type_0 = memberType;
        (*link).next = 0 as *mut _xmlSchemaTypeLink;
        if lastLink.is_null() {
            (*type_0).memberTypes = link
        } else { (*lastLink).next = link }
        lastLink = link;
        memberType = (*memberType).next
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaIsDerivedFromBuiltInType:
 * @ctxt:  the schema parser context
 * @type:  the type definition
 * @valType: the value type
 *
 *
 * Returns 1 if the type has the given value type, or
 * is derived from such a type.
 */
unsafe extern "C" fn xmlSchemaIsDerivedFromBuiltInType(mut type_0:
                                                           xmlSchemaTypePtr,
                                                       mut valType:
                                                           std::os::raw::c_int)
 -> std::os::raw::c_int {
    if type_0.is_null() { return 0 as std::os::raw::c_int }
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
           (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
        if (*type_0).builtInType == valType { return 1 as std::os::raw::c_int }
        if (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int
               || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as std::os::raw::c_int
           {
            return 0 as std::os::raw::c_int
        }
        return xmlSchemaIsDerivedFromBuiltInType((*type_0).subtypes, valType)
    }
    return xmlSchemaIsDerivedFromBuiltInType((*type_0).subtypes, valType);
}
/* *
 * xmlSchemaGetPrimitiveType:
 * @type:  the simpleType definition
 *
 * Returns the primitive type of the given type or
 * NULL in case of error.
 */
unsafe extern "C" fn xmlSchemaGetPrimitiveType(mut type_0: xmlSchemaTypePtr)
 -> xmlSchemaTypePtr {
    while !type_0.is_null() {
        /*
	* Note that anySimpleType is actually not a primitive type
	* but we need that here.
	*/
        if (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int
               ||
               (*type_0).flags & (1 as std::os::raw::c_int) << 14 as std::os::raw::c_int != 0
           {
            return type_0
        }
        type_0 = (*type_0).baseType
    }
    return 0 as xmlSchemaTypePtr;
}
/* *
 * xmlSchemaCloneWildcardNsConstraints:
 * @ctxt:  the schema parser context
 * @dest:  the destination wildcard
 * @source: the source wildcard
 *
 * Clones the namespace constraints of source
 * and assignes them to dest.
 * Returns -1 on internal error, 0 otherwise.
 */
unsafe extern "C" fn xmlSchemaCloneWildcardNsConstraints(mut ctxt:
                                                             xmlSchemaParserCtxtPtr,
                                                         mut dest:
                                                             xmlSchemaWildcardPtr,
                                                         mut source:
                                                             xmlSchemaWildcardPtr)
 -> std::os::raw::c_int {
    let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut last: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    if source.is_null() || dest.is_null() { return -(1 as std::os::raw::c_int) }
    (*dest).any = (*source).any;
    cur = (*source).nsSet;
    last = 0 as xmlSchemaWildcardNsPtr;
    while !cur.is_null() {
        tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
        if tmp.is_null() { return -(1 as std::os::raw::c_int) }
        (*tmp).value = (*cur).value;
        if last.is_null() { (*dest).nsSet = tmp } else { (*last).next = tmp }
        last = tmp;
        cur = (*cur).next
    }
    if !(*dest).negNsSet.is_null() {
        xmlSchemaFreeWildcardNsSet((*dest).negNsSet);
    }
    if !(*source).negNsSet.is_null() {
        (*dest).negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);
        if (*dest).negNsSet.is_null() { return -(1 as std::os::raw::c_int) }
        (*(*dest).negNsSet).value = (*(*source).negNsSet).value
    } else { (*dest).negNsSet = 0 as xmlSchemaWildcardNsPtr }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaUnionWildcards:
 * @ctxt:  the schema parser context
 * @completeWild:  the first wildcard
 * @curWild: the second wildcard
 *
 * Unions the namespace constraints of the given wildcards.
 * @completeWild will hold the resulting union.
 * Returns a positive error code on failure, -1 in case of an
 * internal error, 0 otherwise.
 */
unsafe extern "C" fn xmlSchemaUnionWildcards(mut ctxt: xmlSchemaParserCtxtPtr,
                                             mut completeWild:
                                                 xmlSchemaWildcardPtr,
                                             mut curWild:
                                                 xmlSchemaWildcardPtr)
 -> std::os::raw::c_int {
    let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut curB: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    /*
    * 1 If O1 and O2 are the same value, then that value must be the
    * value.
    */
    if (*completeWild).any == (*curWild).any &&
           ((*completeWild).nsSet ==
                0 as *mut std::os::raw::c_void as xmlSchemaWildcardNsPtr) as
               std::os::raw::c_int ==
               ((*curWild).nsSet ==
                    0 as *mut std::os::raw::c_void as xmlSchemaWildcardNsPtr) as
                   std::os::raw::c_int &&
           ((*completeWild).negNsSet ==
                0 as *mut std::os::raw::c_void as xmlSchemaWildcardNsPtr) as
               std::os::raw::c_int ==
               ((*curWild).negNsSet ==
                    0 as *mut std::os::raw::c_void as xmlSchemaWildcardNsPtr) as
                   std::os::raw::c_int {
        if (*completeWild).negNsSet.is_null() ||
               (*(*completeWild).negNsSet).value ==
                   (*(*curWild).negNsSet).value {
            if !(*completeWild).nsSet.is_null() {
                let mut found: std::os::raw::c_int = 0 as std::os::raw::c_int;
                /*
		* Check equality of sets.
		*/
                cur = (*completeWild).nsSet;
                while !cur.is_null() {
                    found = 0 as std::os::raw::c_int;
                    curB = (*curWild).nsSet;
                    while !curB.is_null() {
                        if (*cur).value == (*curB).value {
                            found = 1 as std::os::raw::c_int;
                            break ;
                        } else { curB = (*curB).next }
                    }
                    if found == 0 { break ; }
                    cur = (*cur).next
                }
                if found != 0 { return 0 as std::os::raw::c_int }
            } else { return 0 as std::os::raw::c_int }
        }
    }
    /*
    * 2 If either O1 or O2 is any, then any must be the value
    */
    if (*completeWild).any != (*curWild).any {
        if (*completeWild).any == 0 as std::os::raw::c_int {
            (*completeWild).any = 1 as std::os::raw::c_int;
            if !(*completeWild).nsSet.is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                (*completeWild).nsSet = 0 as xmlSchemaWildcardNsPtr
            }
            if !(*completeWild).negNsSet.is_null() {
                xmlFree.expect("non-null function pointer")((*completeWild).negNsSet
                                                                as
                                                                *mut std::os::raw::c_void);
                (*completeWild).negNsSet = 0 as xmlSchemaWildcardNsPtr
            }
        }
        return 0 as std::os::raw::c_int
    }
    /*
    * 3 If both O1 and O2 are sets of (namespace names or `absent`),
    * then the union of those sets must be the value.
    */
    if !(*completeWild).nsSet.is_null() && !(*curWild).nsSet.is_null() {
        let mut found_0: std::os::raw::c_int = 0;
        let mut start: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
        cur = (*curWild).nsSet;
        start = (*completeWild).nsSet;
        while !cur.is_null() {
            found_0 = 0 as std::os::raw::c_int;
            curB = start;
            while !curB.is_null() {
                if (*cur).value == (*curB).value {
                    found_0 = 1 as std::os::raw::c_int;
                    break ;
                } else { curB = (*curB).next }
            }
            if found_0 == 0 {
                tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
                if tmp.is_null() { return -(1 as std::os::raw::c_int) }
                (*tmp).value = (*cur).value;
                (*tmp).next = (*completeWild).nsSet;
                (*completeWild).nsSet = tmp
            }
            cur = (*cur).next
        }
        return 0 as std::os::raw::c_int
    }
    /*
    * 4 If the two are negations of different values (namespace names
    * or `absent`), then a pair of not and `absent` must be the value.
    */
    if !(*completeWild).negNsSet.is_null() && !(*curWild).negNsSet.is_null()
           &&
           (*(*completeWild).negNsSet).value != (*(*curWild).negNsSet).value {
        (*(*completeWild).negNsSet).value = 0 as *const xmlChar;
        return 0 as std::os::raw::c_int
    }
    /*
     * 5.
     */
    if !(*completeWild).negNsSet.is_null() &&
           !(*(*completeWild).negNsSet).value.is_null() &&
           !(*curWild).nsSet.is_null() ||
           !(*curWild).negNsSet.is_null() &&
               !(*(*curWild).negNsSet).value.is_null() &&
               !(*completeWild).nsSet.is_null() {
        let mut nsFound: std::os::raw::c_int = 0;
        let mut absentFound: std::os::raw::c_int = 0 as std::os::raw::c_int;
        if !(*completeWild).nsSet.is_null() {
            cur = (*completeWild).nsSet;
            curB = (*curWild).negNsSet
        } else { cur = (*curWild).nsSet; curB = (*completeWild).negNsSet }
        nsFound = 0 as std::os::raw::c_int;
        while !cur.is_null() {
            if (*cur).value.is_null() {
                absentFound = 1 as std::os::raw::c_int
            } else if (*cur).value == (*curB).value {
                nsFound = 1 as std::os::raw::c_int
            }
            if nsFound != 0 && absentFound != 0 { break ; }
            cur = (*cur).next
        }
        if nsFound != 0 && absentFound != 0 {
            /*
	    * 5.1 If the set S includes both the negated namespace
	    * name and `absent`, then any must be the value.
	    */
            (*completeWild).any = 1 as std::os::raw::c_int;
            if !(*completeWild).nsSet.is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                (*completeWild).nsSet = 0 as xmlSchemaWildcardNsPtr
            }
            if !(*completeWild).negNsSet.is_null() {
                xmlFree.expect("non-null function pointer")((*completeWild).negNsSet
                                                                as
                                                                *mut std::os::raw::c_void);
                (*completeWild).negNsSet = 0 as xmlSchemaWildcardNsPtr
            }
        } else if nsFound != 0 && absentFound == 0 {
            /*
	    * 5.2 If the set S includes the negated namespace name
	    * but not `absent`, then a pair of not and `absent` must
	    * be the value.
	    */
            if !(*completeWild).nsSet.is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                (*completeWild).nsSet = 0 as xmlSchemaWildcardNsPtr
            }
            if (*completeWild).negNsSet.is_null() {
                (*completeWild).negNsSet =
                    xmlSchemaNewWildcardNsConstraint(ctxt);
                if (*completeWild).negNsSet.is_null() {
                    return -(1 as std::os::raw::c_int)
                }
            }
            (*(*completeWild).negNsSet).value = 0 as *const xmlChar
        } else if nsFound == 0 && absentFound != 0 {
            /*
	    * 5.3 If the set S includes `absent` but not the negated
	    * namespace name, then the union is not expressible.
	    */
            xmlSchemaPErr(ctxt, (*completeWild).node,
                          XML_SCHEMAP_UNION_NOT_EXPRESSIBLE as std::os::raw::c_int,
                          b"The union of the wilcard is not expressible.\n\x00"
                              as *const u8 as *const std::os::raw::c_char,
                          0 as *const xmlChar, 0 as *const xmlChar);
            return XML_SCHEMAP_UNION_NOT_EXPRESSIBLE as std::os::raw::c_int
        } else {
            if nsFound == 0 && absentFound == 0 {
                /*
	    * 5.4 If the set S does not include either the negated namespace
	    * name or `absent`, then whichever of O1 or O2 is a pair of not
	    * and a namespace name must be the value.
	    */
                if (*completeWild).negNsSet.is_null() {
                    if !(*completeWild).nsSet.is_null() {
                        xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                        (*completeWild).nsSet = 0 as xmlSchemaWildcardNsPtr
                    }
                    (*completeWild).negNsSet =
                        xmlSchemaNewWildcardNsConstraint(ctxt);
                    if (*completeWild).negNsSet.is_null() {
                        return -(1 as std::os::raw::c_int)
                    }
                    (*(*completeWild).negNsSet).value =
                        (*(*curWild).negNsSet).value
                }
            }
        }
        return 0 as std::os::raw::c_int
    }
    /*
     * 6.
     */
    if !(*completeWild).negNsSet.is_null() &&
           (*(*completeWild).negNsSet).value.is_null() &&
           !(*curWild).nsSet.is_null() ||
           !(*curWild).negNsSet.is_null() &&
               (*(*curWild).negNsSet).value.is_null() &&
               !(*completeWild).nsSet.is_null() {
        if !(*completeWild).nsSet.is_null() {
            cur = (*completeWild).nsSet
        } else { cur = (*curWild).nsSet }
        while !cur.is_null() {
            if (*cur).value.is_null() {
                /*
		* 6.1 If the set S includes `absent`, then any must be the
		* value.
		*/
                (*completeWild).any = 1 as std::os::raw::c_int;
                if !(*completeWild).nsSet.is_null() {
                    xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                    (*completeWild).nsSet = 0 as xmlSchemaWildcardNsPtr
                }
                if !(*completeWild).negNsSet.is_null() {
                    xmlFree.expect("non-null function pointer")((*completeWild).negNsSet
                                                                    as
                                                                    *mut std::os::raw::c_void);
                    (*completeWild).negNsSet = 0 as xmlSchemaWildcardNsPtr
                }
                return 0 as std::os::raw::c_int
            }
            cur = (*cur).next
        }
        if (*completeWild).negNsSet.is_null() {
            /*
	    * 6.2 If the set S does not include `absent`, then a pair of not
	    * and `absent` must be the value.
	    */
            if !(*completeWild).nsSet.is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                (*completeWild).nsSet = 0 as xmlSchemaWildcardNsPtr
            }
            (*completeWild).negNsSet = xmlSchemaNewWildcardNsConstraint(ctxt);
            if (*completeWild).negNsSet.is_null() {
                return -(1 as std::os::raw::c_int)
            }
            (*(*completeWild).negNsSet).value = 0 as *const xmlChar
        }
        return 0 as std::os::raw::c_int
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaIntersectWildcards:
 * @ctxt:  the schema parser context
 * @completeWild:  the first wildcard
 * @curWild: the second wildcard
 *
 * Intersects the namespace constraints of the given wildcards.
 * @completeWild will hold the resulting intersection.
 * Returns a positive error code on failure, -1 in case of an
 * internal error, 0 otherwise.
 */
unsafe extern "C" fn xmlSchemaIntersectWildcards(mut ctxt:
                                                     xmlSchemaParserCtxtPtr,
                                                 mut completeWild:
                                                     xmlSchemaWildcardPtr,
                                                 mut curWild:
                                                     xmlSchemaWildcardPtr)
 -> std::os::raw::c_int {
    let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut curB: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut prev: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    /*
    * 1 If O1 and O2 are the same value, then that value must be the
    * value.
    */
    if (*completeWild).any == (*curWild).any &&
           ((*completeWild).nsSet ==
                0 as *mut std::os::raw::c_void as xmlSchemaWildcardNsPtr) as
               std::os::raw::c_int ==
               ((*curWild).nsSet ==
                    0 as *mut std::os::raw::c_void as xmlSchemaWildcardNsPtr) as
                   std::os::raw::c_int &&
           ((*completeWild).negNsSet ==
                0 as *mut std::os::raw::c_void as xmlSchemaWildcardNsPtr) as
               std::os::raw::c_int ==
               ((*curWild).negNsSet ==
                    0 as *mut std::os::raw::c_void as xmlSchemaWildcardNsPtr) as
                   std::os::raw::c_int {
        if (*completeWild).negNsSet.is_null() ||
               (*(*completeWild).negNsSet).value ==
                   (*(*curWild).negNsSet).value {
            if !(*completeWild).nsSet.is_null() {
                let mut found: std::os::raw::c_int = 0 as std::os::raw::c_int;
                /*
		* Check equality of sets.
		*/
                cur = (*completeWild).nsSet;
                while !cur.is_null() {
                    found = 0 as std::os::raw::c_int;
                    curB = (*curWild).nsSet;
                    while !curB.is_null() {
                        if (*cur).value == (*curB).value {
                            found = 1 as std::os::raw::c_int;
                            break ;
                        } else { curB = (*curB).next }
                    }
                    if found == 0 { break ; }
                    cur = (*cur).next
                }
                if found != 0 { return 0 as std::os::raw::c_int }
            } else { return 0 as std::os::raw::c_int }
        }
    }
    /*
    * 2 If either O1 or O2 is any, then the other must be the value.
    */
    if (*completeWild).any != (*curWild).any && (*completeWild).any != 0 {
        if xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild) ==
               -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
        return 0 as std::os::raw::c_int
    }
    /*
    * 3 If either O1 or O2 is a pair of not and a value (a namespace
    * name or `absent`) and the other is a set of (namespace names or
    * `absent`), then that set, minus the negated value if it was in
    * the set, minus `absent` if it was in the set, must be the value.
    */
    if !(*completeWild).negNsSet.is_null() && !(*curWild).nsSet.is_null() ||
           !(*curWild).negNsSet.is_null() && !(*completeWild).nsSet.is_null()
       {
        let mut neg: *const xmlChar = 0 as *const xmlChar;
        if (*completeWild).nsSet.is_null() {
            neg = (*(*completeWild).negNsSet).value;
            if xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild,
                                                   curWild) ==
                   -(1 as std::os::raw::c_int) {
                return -(1 as std::os::raw::c_int)
            }
        } else { neg = (*(*curWild).negNsSet).value }
        /*
	* Remove absent and negated.
	*/
        prev = 0 as xmlSchemaWildcardNsPtr;
        cur = (*completeWild).nsSet;
        while !cur.is_null() {
            if (*cur).value.is_null() {
                if prev.is_null() {
                    (*completeWild).nsSet = (*cur).next
                } else { (*prev).next = (*cur).next }
                xmlFree.expect("non-null function pointer")(cur as
                                                                *mut std::os::raw::c_void);
                break ;
            } else { prev = cur; cur = (*cur).next }
        }
        if !neg.is_null() {
            prev = 0 as xmlSchemaWildcardNsPtr;
            cur = (*completeWild).nsSet;
            while !cur.is_null() {
                if (*cur).value == neg {
                    if prev.is_null() {
                        (*completeWild).nsSet = (*cur).next
                    } else { (*prev).next = (*cur).next }
                    xmlFree.expect("non-null function pointer")(cur as
                                                                    *mut std::os::raw::c_void);
                    break ;
                } else { prev = cur; cur = (*cur).next }
            }
        }
        return 0 as std::os::raw::c_int
    }
    /*
    * 4 If both O1 and O2 are sets of (namespace names or `absent`),
    * then the intersection of those sets must be the value.
    */
    if !(*completeWild).nsSet.is_null() && !(*curWild).nsSet.is_null() {
        let mut found_0: std::os::raw::c_int = 0;
        cur = (*completeWild).nsSet;
        prev = 0 as xmlSchemaWildcardNsPtr;
        while !cur.is_null() {
            found_0 = 0 as std::os::raw::c_int;
            curB = (*curWild).nsSet;
            while !curB.is_null() {
                if (*cur).value == (*curB).value {
                    found_0 = 1 as std::os::raw::c_int;
                    break ;
                } else { curB = (*curB).next }
            }
            if found_0 == 0 {
                if prev.is_null() {
                    (*completeWild).nsSet = (*cur).next
                } else { (*prev).next = (*cur).next }
                tmp = (*cur).next;
                xmlFree.expect("non-null function pointer")(cur as
                                                                *mut std::os::raw::c_void);
                cur = tmp
            } else { prev = cur; cur = (*cur).next }
        }
        return 0 as std::os::raw::c_int
    }
    /* 5 If the two are negations of different namespace names,
    * then the intersection is not expressible
    */
    if !(*completeWild).negNsSet.is_null() && !(*curWild).negNsSet.is_null()
           &&
           (*(*completeWild).negNsSet).value != (*(*curWild).negNsSet).value
           && !(*(*completeWild).negNsSet).value.is_null() &&
           !(*(*curWild).negNsSet).value.is_null() {
        xmlSchemaPErr(ctxt, (*completeWild).node,
                      XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE as std::os::raw::c_int,
                      b"The intersection of the wilcard is not expressible.\n\x00"
                          as *const u8 as *const std::os::raw::c_char,
                      0 as *const xmlChar, 0 as *const xmlChar);
        return XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE as std::os::raw::c_int
    }
    /*
    * 6 If the one is a negation of a namespace name and the other
    * is a negation of `absent`, then the one which is the negation
    * of a namespace name must be the value.
    */
    if !(*completeWild).negNsSet.is_null() && !(*curWild).negNsSet.is_null()
           &&
           (*(*completeWild).negNsSet).value != (*(*curWild).negNsSet).value
           && (*(*completeWild).negNsSet).value.is_null() {
        (*(*completeWild).negNsSet).value = (*(*curWild).negNsSet).value
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaIsWildcardNsConstraintSubset:
 * @ctxt:  the schema parser context
 * @sub:  the first wildcard
 * @super: the second wildcard
 *
 * Schema Component Constraint: Wildcard Subset (cos-ns-subset)
 *
 * Returns 0 if the namespace constraint of @sub is an intensional
 * subset of @super, 1 otherwise.
 */
unsafe extern "C" fn xmlSchemaCheckCOSNSSubset(mut sub: xmlSchemaWildcardPtr,
                                               mut super_0:
                                                   xmlSchemaWildcardPtr)
 -> std::os::raw::c_int {
    /*
    * 1 super must be any.
    */
    if (*super_0).any != 0 { return 0 as std::os::raw::c_int }
    /*
    * 2.1 sub must be a pair of not and a namespace name or `absent`.
    * 2.2 super must be a pair of not and the same value.
    */
    if !(*sub).negNsSet.is_null() && !(*super_0).negNsSet.is_null() &&
           (*(*sub).negNsSet).value == (*(*super_0).negNsSet).value {
        return 0 as std::os::raw::c_int
    }
    /*
    * 3.1 sub must be a set whose members are either namespace names or `absent`.
    */
    if !(*sub).nsSet.is_null() {
        /*
	* 3.2.1 super must be the same set or a superset thereof.
	*/
        if !(*super_0).nsSet.is_null() {
            let mut cur: xmlSchemaWildcardNsPtr =
                0 as *mut xmlSchemaWildcardNs;
            let mut curB: xmlSchemaWildcardNsPtr =
                0 as *mut xmlSchemaWildcardNs;
            let mut found: std::os::raw::c_int = 0 as std::os::raw::c_int;
            cur = (*sub).nsSet;
            while !cur.is_null() {
                found = 0 as std::os::raw::c_int;
                curB = (*super_0).nsSet;
                while !curB.is_null() {
                    if (*cur).value == (*curB).value {
                        found = 1 as std::os::raw::c_int;
                        break ;
                    } else { curB = (*curB).next }
                }
                if found == 0 { return 1 as std::os::raw::c_int }
                cur = (*cur).next
            }
            if found != 0 { return 0 as std::os::raw::c_int }
        } else if !(*super_0).negNsSet.is_null() {
            let mut cur_0: xmlSchemaWildcardNsPtr =
                0 as *mut xmlSchemaWildcardNs;
            /*
	    * 3.2.2 super must be a pair of not and a namespace name or
	    * `absent` and that value must not be in sub's set.
	    */
            cur_0 = (*sub).nsSet;
            while !cur_0.is_null() {
                if (*cur_0).value == (*(*super_0).negNsSet).value {
                    return 1 as std::os::raw::c_int
                }
                cur_0 = (*cur_0).next
            }
            return 0 as std::os::raw::c_int
        }
    }
    return 1 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaGetEffectiveValueConstraint(mut attruse:
                                                              xmlSchemaAttributeUsePtr,
                                                          mut fixed:
                                                              *mut std::os::raw::c_int,
                                                          mut value:
                                                              *mut *const xmlChar,
                                                          mut val:
                                                              *mut xmlSchemaValPtr)
 -> std::os::raw::c_int {
    *fixed = 0 as std::os::raw::c_int;
    *value = 0 as *const xmlChar;
    if !val.is_null() { *val = 0 as xmlSchemaValPtr }
    if !(*attruse).defValue.is_null() {
        *value = (*attruse).defValue;
        if !val.is_null() { *val = (*attruse).defVal }
        if (*attruse).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 {
            *fixed = 1 as std::os::raw::c_int
        }
        return 1 as std::os::raw::c_int
    } else {
        if !(*attruse).attrDecl.is_null() &&
               !(*(*attruse).attrDecl).defValue.is_null() {
            *value = (*(*attruse).attrDecl).defValue;
            if !val.is_null() { *val = (*(*attruse).attrDecl).defVal }
            if (*(*attruse).attrDecl).flags &
                   (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int != 0 {
                *fixed = 1 as std::os::raw::c_int
            }
            return 1 as std::os::raw::c_int
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckCVCWildcardNamespace:
 * @wild:  the wildcard
 * @ns:  the namespace
 *
 * Validation Rule: Wildcard allows Namespace Name
 * (cvc-wildcard-namespace)
 *
 * Returns 0 if the given namespace matches the wildcard,
 * 1 otherwise and -1 on API errors.
 */
unsafe extern "C" fn xmlSchemaCheckCVCWildcardNamespace(mut wild:
                                                            xmlSchemaWildcardPtr,
                                                        mut ns:
                                                            *const xmlChar)
 -> std::os::raw::c_int {
    if wild.is_null() { return -(1 as std::os::raw::c_int) }
    if (*wild).any != 0 {
        return 0 as std::os::raw::c_int
    } else {
        if !(*wild).nsSet.is_null() {
            let mut cur: xmlSchemaWildcardNsPtr =
                0 as *mut xmlSchemaWildcardNs;
            cur = (*wild).nsSet;
            while !cur.is_null() {
                if xmlStrEqual((*cur).value, ns) != 0 {
                    return 0 as std::os::raw::c_int
                }
                cur = (*cur).next
            }
        } else if !(*wild).negNsSet.is_null() && !ns.is_null() &&
                      xmlStrEqual((*(*wild).negNsSet).value, ns) == 0 {
            return 0 as std::os::raw::c_int
        }
    }
    return 1 as std::os::raw::c_int;
}
/*
* Schema Component Constraint:
*   Derivation Valid (Restriction, Complex)
*   derivation-ok-restriction (2) - (4)
*
* ATTENTION:
* In XML Schema 1.1 this will be:
* Validation Rule:
*     Checking complex type subsumption (practicalSubsumption) (1, 2 and 3)
*
*/
unsafe extern "C" fn xmlSchemaCheckDerivationOKRestriction2to4(mut pctxt:
                                                                   xmlSchemaParserCtxtPtr,
                                                               mut action:
                                                                   std::os::raw::c_int,
                                                               mut item:
                                                                   xmlSchemaBasicItemPtr,
                                                               mut baseItem:
                                                                   xmlSchemaBasicItemPtr,
                                                               mut uses:
                                                                   xmlSchemaItemListPtr,
                                                               mut baseUses:
                                                                   xmlSchemaItemListPtr,
                                                               mut wild:
                                                                   xmlSchemaWildcardPtr,
                                                               mut baseWild:
                                                                   xmlSchemaWildcardPtr)
 -> std::os::raw::c_int {
    let mut cur: xmlSchemaAttributeUsePtr =
        0 as xmlSchemaAttributeUsePtr; /* err = 0; */
    let mut bcur: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut found: std::os::raw::c_int = 0;
    let mut bEffValue: *const xmlChar = 0 as *const xmlChar;
    let mut effFixed: std::os::raw::c_int = 0;
    if !uses.is_null() {
        i = 0 as std::os::raw::c_int;
        while i < (*uses).nbItems {
            cur =
                *(*uses).items.offset(i as isize) as xmlSchemaAttributeUsePtr;
            found = 0 as std::os::raw::c_int;
            if !baseUses.is_null() {
                j = 0 as std::os::raw::c_int;
                while j < (*baseUses).nbItems {
                    bcur =
                        *(*baseUses).items.offset(j as isize) as
                            xmlSchemaAttributeUsePtr;
                    if (*(*cur).attrDecl).name == (*(*bcur).attrDecl).name &&
                           (*(*cur).attrDecl).targetNamespace ==
                               (*(*bcur).attrDecl).targetNamespace {
                        /*
		    * (2.1) "If there is an attribute use in the {attribute
		    * uses} of the {base type definition} (call this B) whose
		    * {attribute declaration} has the same {name} and {target
		    * namespace}, then  all of the following must be true:"
		    */
                        found = 1 as std::os::raw::c_int;
                        if (*cur).occurs == 2 as std::os::raw::c_int &&
                               (*bcur).occurs == 1 as std::os::raw::c_int {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            /* err = pctxt->err; */
                            xmlSchemaPAttrUseErr4(pctxt,
                                                  XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1,
                                                  xmlSchemaGetComponentNode(item),
                                                  item, cur,
                                                  b"The \'optional\' attribute use is inconsistent with the corresponding \'required\' attribute use of the %s %s\x00"
                                                      as *const u8 as
                                                      *const std::os::raw::c_char,
                                                  if action ==
                                                         0 as std::os::raw::c_int {
                                                      b"base\x00" as *const u8
                                                          as
                                                          *const std::os::raw::c_char
                                                          as *const xmlChar
                                                  } else {
                                                      b"redefined\x00" as
                                                          *const u8 as
                                                          *const std::os::raw::c_char
                                                          as *const xmlChar
                                                  },
                                                  xmlSchemaGetComponentDesignation(&mut str,
                                                                                   baseItem
                                                                                       as
                                                                                       *mut std::os::raw::c_void),
                                                  0 as *const xmlChar,
                                                  0 as *const xmlChar);
                            if !str.is_null() {
                                xmlFree.expect("non-null function pointer")(str
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                str = 0 as *mut xmlChar
                            }
                        } else if xmlSchemaCheckCOSSTDerivedOK(pctxt as
                                                                   xmlSchemaAbstractCtxtPtr,
                                                               (*(*cur).attrDecl).subtypes,
                                                               (*(*bcur).attrDecl).subtypes,
                                                               0 as
                                                                   std::os::raw::c_int)
                                      != 0 as std::os::raw::c_int {
                            let mut strA: *mut xmlChar = 0 as *mut xmlChar;
                            let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                            let mut strC: *mut xmlChar = 0 as *mut xmlChar;
                            /*
			* (2.1.1) "one of the following must be true:"
			* (2.1.1.1) "B's {required} is false."
			* (2.1.1.2) "R's {required} is true."
			*/
                            /* err = pctxt->err; */
                            xmlSchemaPAttrUseErr4(pctxt,
                                                  XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2,
                                                  xmlSchemaGetComponentNode(item),
                                                  item, cur,
                                                  b"The attribute declaration\'s %s is not validly derived from the corresponding %s of the attribute declaration in the %s %s\x00"
                                                      as *const u8 as
                                                      *const std::os::raw::c_char,
                                                  xmlSchemaGetComponentDesignation(&mut strA,
                                                                                   (*(*cur).attrDecl).subtypes
                                                                                       as
                                                                                       *mut std::os::raw::c_void),
                                                  xmlSchemaGetComponentDesignation(&mut strB,
                                                                                   (*(*bcur).attrDecl).subtypes
                                                                                       as
                                                                                       *mut std::os::raw::c_void),
                                                  if action ==
                                                         0 as std::os::raw::c_int {
                                                      b"base\x00" as *const u8
                                                          as
                                                          *const std::os::raw::c_char
                                                          as *const xmlChar
                                                  } else {
                                                      b"redefined\x00" as
                                                          *const u8 as
                                                          *const std::os::raw::c_char
                                                          as *const xmlChar
                                                  },
                                                  xmlSchemaGetComponentDesignation(&mut strC,
                                                                                   baseItem
                                                                                       as
                                                                                       *mut std::os::raw::c_void));
                            if !strA.is_null() {
                                xmlFree.expect("non-null function pointer")(strA
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                strA = 0 as *mut xmlChar
                            }
                            if !strB.is_null() {
                                xmlFree.expect("non-null function pointer")(strB
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                strB = 0 as *mut xmlChar
                            }
                            if !strC.is_null() {
                                xmlFree.expect("non-null function pointer")(strC
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                strC = 0 as *mut xmlChar
                            }
                        } else {
                            /*
			* SPEC (2.1.2) "R's {attribute declaration}'s
			* {type definition} must be validly derived from
			* B's {type definition} given the empty set as
			* defined in Type Derivation OK (Simple) ($3.14.6)."
			*/
                            /* xmlSchemaGetComponentDesignation(&str, baseItem), */
                            /*
			* 2.1.3 [Definition:]  Let the effective value
			* constraint of an attribute use be its {value
			* constraint}, if present, otherwise its {attribute
			* declaration}'s {value constraint} .
			*/
                            xmlSchemaGetEffectiveValueConstraint(bcur,
                                                                 &mut effFixed,
                                                                 &mut bEffValue,
                                                                 0 as
                                                                     *mut xmlSchemaValPtr);
                            /*
			* 2.1.3 ... one of the following must be true
			*
			* 2.1.3.1 B's `effective value constraint` is
			* `absent` or default.
			*/
                            if !bEffValue.is_null() &&
                                   effFixed == 1 as std::os::raw::c_int {
                                let mut rEffValue: *const xmlChar =
                                    0 as *const xmlChar;
                                xmlSchemaGetEffectiveValueConstraint(bcur,
                                                                     &mut effFixed,
                                                                     &mut rEffValue,
                                                                     0 as
                                                                         *mut xmlSchemaValPtr);
                                /*
			    * 2.1.3.2 R's `effective value constraint` is
			    * fixed with the same string as B's.
			    * MAYBE TODO: Compare the computed values.
			    *       Hmm, it says "same string" so
			    *       string-equality might really be sufficient.
			    */
                                if effFixed == 0 as std::os::raw::c_int ||
                                       !(rEffValue == bEffValue) {
                                    let mut str_0: *mut xmlChar =
                                        0 as *mut xmlChar;
                                    xmlSchemaPAttrUseErr4(pctxt,
                                                          XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3,
                                                          xmlSchemaGetComponentNode(item),
                                                          item, cur,
                                                          b"The effective value constraint of the attribute use is inconsistent with its correspondent in the %s %s\x00"
                                                              as *const u8 as
                                                              *const std::os::raw::c_char,
                                                          if action ==
                                                                 0 as
                                                                     std::os::raw::c_int
                                                             {
                                                              b"base\x00" as
                                                                  *const u8 as
                                                                  *const std::os::raw::c_char
                                                                  as
                                                                  *const xmlChar
                                                          } else {
                                                              b"redefined\x00"
                                                                  as *const u8
                                                                  as
                                                                  *const std::os::raw::c_char
                                                                  as
                                                                  *const xmlChar
                                                          },
                                                          xmlSchemaGetComponentDesignation(&mut str_0,
                                                                                           baseItem
                                                                                               as
                                                                                               *mut std::os::raw::c_void),
                                                          0 as *const xmlChar,
                                                          0 as
                                                              *const xmlChar);
                                    if !str_0.is_null() {
                                        xmlFree.expect("non-null function pointer")(str_0
                                                                                        as
                                                                                        *mut std::os::raw::c_void);
                                        str_0 = 0 as *mut xmlChar
                                    }
                                    /* err = pctxt->err; */
                                }
                            }
                        }
                        break ;
                    } else { j += 1 }
                }
            }
            if found == 0 {
                /*
		* (2.2) "otherwise the {base type definition} must have an
		* {attribute wildcard} and the {target namespace} of the
		* R's {attribute declaration} must be `valid` with respect
		* to that wildcard, as defined in Wildcard allows Namespace
		* Name ($3.10.4)."
		*/
                if baseWild.is_null() ||
                       xmlSchemaCheckCVCWildcardNamespace(baseWild,
                                                          (*(*cur).attrDecl).targetNamespace)
                           != 0 as std::os::raw::c_int {
                    let mut str_1: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaPAttrUseErr4(pctxt,
                                          XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2,
                                          xmlSchemaGetComponentNode(item),
                                          item, cur,
                                          b"Neither a matching attribute use, nor a matching wildcard exists in the %s %s\x00"
                                              as *const u8 as
                                              *const std::os::raw::c_char,
                                          if action == 0 as std::os::raw::c_int {
                                              b"base\x00" as *const u8 as
                                                  *const std::os::raw::c_char as
                                                  *const xmlChar
                                          } else {
                                              b"redefined\x00" as *const u8 as
                                                  *const std::os::raw::c_char as
                                                  *const xmlChar
                                          },
                                          xmlSchemaGetComponentDesignation(&mut str_1,
                                                                           baseItem
                                                                               as
                                                                               *mut std::os::raw::c_void),
                                          0 as *const xmlChar,
                                          0 as *const xmlChar);
                    if !str_1.is_null() {
                        xmlFree.expect("non-null function pointer")(str_1 as
                                                                        *mut std::os::raw::c_void);
                        str_1 = 0 as *mut xmlChar
                    }
                    /* err = pctxt->err; */
                }
            }
            i += 1
        }
    }
    /*
    * SPEC derivation-ok-restriction (3):
    * (3) "For each attribute use in the {attribute uses} of the {base type
    * definition} whose {required} is true, there must be an attribute
    * use with an {attribute declaration} with the same {name} and
    * {target namespace} as its {attribute declaration} in the {attribute
    * uses} of the complex type definition itself whose {required} is true.
    */
    if !baseUses.is_null() {
        j = 0 as std::os::raw::c_int;
        while j < (*baseUses).nbItems {
            bcur =
                *(*baseUses).items.offset(j as isize) as
                    xmlSchemaAttributeUsePtr;
            if !((*bcur).occurs != 1 as std::os::raw::c_int) {
                found = 0 as std::os::raw::c_int;
                if !uses.is_null() {
                    i = 0 as std::os::raw::c_int;
                    while i < (*uses).nbItems {
                        cur =
                            *(*uses).items.offset(i as isize) as
                                xmlSchemaAttributeUsePtr;
                        if (*(*cur).attrDecl).name == (*(*bcur).attrDecl).name
                               &&
                               (*(*cur).attrDecl).targetNamespace ==
                                   (*(*bcur).attrDecl).targetNamespace {
                            found = 1 as std::os::raw::c_int;
                            break ;
                        } else { i += 1 }
                    }
                }
                if found == 0 {
                    let mut strA_0: *mut xmlChar = 0 as *mut xmlChar;
                    let mut strB_0: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomErr4(pctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3,
                                        0 as xmlNodePtr, item,
                                        b"A matching attribute use for the \'required\' %s of the %s %s is missing\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        xmlSchemaGetComponentDesignation(&mut strA_0,
                                                                         bcur
                                                                             as
                                                                             *mut std::os::raw::c_void),
                                        if action == 0 as std::os::raw::c_int {
                                            b"base\x00" as *const u8 as
                                                *const std::os::raw::c_char as
                                                *const xmlChar
                                        } else {
                                            b"redefined\x00" as *const u8 as
                                                *const std::os::raw::c_char as
                                                *const xmlChar
                                        },
                                        xmlSchemaGetComponentDesignation(&mut strB_0,
                                                                         baseItem
                                                                             as
                                                                             *mut std::os::raw::c_void),
                                        0 as *const xmlChar);
                    if !strA_0.is_null() {
                        xmlFree.expect("non-null function pointer")(strA_0 as
                                                                        *mut std::os::raw::c_void);
                        strA_0 = 0 as *mut xmlChar
                    }
                    if !strB_0.is_null() {
                        xmlFree.expect("non-null function pointer")(strB_0 as
                                                                        *mut std::os::raw::c_void);
                        strB_0 = 0 as *mut xmlChar
                    }
                }
            }
            j += 1
        }
    }
    /*
    * derivation-ok-restriction (4)
    */
    if !wild.is_null() {
        /*
	* (4) "If there is an {attribute wildcard}, all of the
	* following must be true:"
	*/
        if baseWild.is_null() {
            let mut str_2: *mut xmlChar = 0 as *mut xmlChar;
            /*
	    * (4.1) "The {base type definition} must also have one."
	    */
            xmlSchemaCustomErr4(pctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1,
                                0 as xmlNodePtr, item,
                                b"The %s has an attribute wildcard, but the %s %s \'%s\' does not have one\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                xmlSchemaGetComponentTypeStr(item),
                                if action == 0 as std::os::raw::c_int {
                                    b"base\x00" as *const u8 as
                                        *const std::os::raw::c_char as *const xmlChar
                                } else {
                                    b"redefined\x00" as *const u8 as
                                        *const std::os::raw::c_char as *const xmlChar
                                }, xmlSchemaGetComponentTypeStr(baseItem),
                                xmlSchemaGetComponentQName(&mut str_2,
                                                           baseItem as
                                                               *mut std::os::raw::c_void));
            if !str_2.is_null() {
                xmlFree.expect("non-null function pointer")(str_2 as
                                                                *mut std::os::raw::c_void);
                str_2 = 0 as *mut xmlChar
            }
            return (*pctxt).err
        } else {
            if (*baseWild).any == 0 as std::os::raw::c_int &&
                   xmlSchemaCheckCOSNSSubset(wild, baseWild) != 0 {
                let mut str_3: *mut xmlChar = 0 as *mut xmlChar;
                /*
	    * (4.2) "The complex type definition's {attribute wildcard}'s
	    * {namespace constraint} must be a subset of the {base type
	    * definition}'s {attribute wildcard}'s {namespace constraint},
	    * as defined by Wildcard Subset ($3.10.6)."
	    */
                xmlSchemaCustomErr4(pctxt as xmlSchemaAbstractCtxtPtr,
                                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2,
                                    0 as xmlNodePtr, item,
                                    b"The attribute wildcard is not a valid subset of the wildcard in the %s %s \'%s\'\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    if action == 0 as std::os::raw::c_int {
                                        b"base\x00" as *const u8 as
                                            *const std::os::raw::c_char as
                                            *const xmlChar
                                    } else {
                                        b"redefined\x00" as *const u8 as
                                            *const std::os::raw::c_char as
                                            *const xmlChar
                                    }, xmlSchemaGetComponentTypeStr(baseItem),
                                    xmlSchemaGetComponentQName(&mut str_3,
                                                               baseItem as
                                                                   *mut std::os::raw::c_void),
                                    0 as *const xmlChar);
                if !str_3.is_null() {
                    xmlFree.expect("non-null function pointer")(str_3 as
                                                                    *mut std::os::raw::c_void);
                    str_3 = 0 as *mut xmlChar
                }
                return (*pctxt).err
            }
        }
        /* 4.3 Unless the {base type definition} is the `ur-type
	* definition`, the complex type definition's {attribute
	* wildcard}'s {process contents} must be identical to or
	* stronger than the {base type definition}'s {attribute
	* wildcard}'s {process contents}, where strict is stronger
	* than lax is stronger than skip.
	*/
        if !((*baseItem).type_0 as std::os::raw::c_uint ==
                 XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                 (*(baseItem as xmlSchemaTypePtr)).builtInType ==
                     XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) &&
               (*wild).processContents < (*baseWild).processContents {
            let mut str_4: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaCustomErr4(pctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3,
                                0 as xmlNodePtr, baseItem,
                                b"The {process contents} of the attribute wildcard is weaker than the one in the %s %s \'%s\'\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                if action == 0 as std::os::raw::c_int {
                                    b"base\x00" as *const u8 as
                                        *const std::os::raw::c_char as *const xmlChar
                                } else {
                                    b"redefined\x00" as *const u8 as
                                        *const std::os::raw::c_char as *const xmlChar
                                }, xmlSchemaGetComponentTypeStr(baseItem),
                                xmlSchemaGetComponentQName(&mut str_4,
                                                           baseItem as
                                                               *mut std::os::raw::c_void),
                                0 as *const xmlChar);
            if !str_4.is_null() {
                xmlFree.expect("non-null function pointer")(str_4 as
                                                                *mut std::os::raw::c_void);
                str_4 = 0 as *mut xmlChar
            }
            return (*pctxt).err
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaFixupTypeAttributeUses:
 * @ctxt:  the schema parser context
 * @type:  the complex type definition
 *
 *
 * Builds the wildcard and the attribute uses on the given complex type.
 * Returns -1 if an internal error occurs, 0 otherwise.
 *
 * ATTENTION TODO: Experimantally this uses pointer comparisons for
 * strings, so recheck this if we start to hardcode some schemata, since
 * they might not be in the same dict.
 * NOTE: It is allowed to "extend" the xs:anyType type.
 */
unsafe extern "C" fn xmlSchemaFixupTypeAttributeUses(mut pctxt:
                                                         xmlSchemaParserCtxtPtr,
                                                     mut type_0:
                                                         xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut baseType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut uses: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut baseUses: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut prohibs: xmlSchemaItemListPtr = 0 as xmlSchemaItemListPtr;
    if (*type_0).baseType.is_null() {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaFixupTypeAttributeUses\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             b"no base type\x00" as *const u8 as
                                 *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    baseType = (*type_0).baseType;
    if (*baseType).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
           (*baseType).flags & (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
               0 as std::os::raw::c_int {
        if xmlSchemaTypeFixup(baseType, pctxt as xmlSchemaAbstractCtxtPtr) ==
               -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
    }
    uses = (*type_0).attrUses as xmlSchemaItemListPtr;
    baseUses = (*baseType).attrUses as xmlSchemaItemListPtr;
    /*
    * Expand attribute group references. And build the 'complete'
    * wildcard, i.e. intersect multiple wildcards.
    * Move attribute prohibitions into a separate list.
    */
    if !uses.is_null() {
        if (*type_0).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
            /*
	    * This one will transfer all attr. prohibitions
	    * into pctxt->attrProhibs.
	    */
            if xmlSchemaExpandAttributeGroupRefs(pctxt,
                                                 type_0 as
                                                     xmlSchemaBasicItemPtr,
                                                 &mut (*type_0).attributeWildcard,
                                                 uses, (*pctxt).attrProhibs)
                   == -(1 as std::os::raw::c_int) {
                xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaFixupTypeAttributeUses\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"failed to expand attributes\x00" as
                                         *const u8 as *const std::os::raw::c_char);
            }
            if (*(*pctxt).attrProhibs).nbItems != 0 as std::os::raw::c_int {
                prohibs = (*pctxt).attrProhibs
            }
        } else if xmlSchemaExpandAttributeGroupRefs(pctxt,
                                                    type_0 as
                                                        xmlSchemaBasicItemPtr,
                                                    &mut (*type_0).attributeWildcard,
                                                    uses,
                                                    0 as xmlSchemaItemListPtr)
                      == -(1 as std::os::raw::c_int) {
            xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaFixupTypeAttributeUses\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"failed to expand attributes\x00" as
                                     *const u8 as *const std::os::raw::c_char);
        }
    }
    /*
    * Inherit the attribute uses of the base type.
    */
    if !baseUses.is_null() {
        let mut i: std::os::raw::c_int = 0;
        let mut j: std::os::raw::c_int = 0;
        let mut pro: xmlSchemaAttributeUseProhibPtr =
            0 as *mut xmlSchemaAttributeUseProhib;
        if (*type_0).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
            let mut usesCount: std::os::raw::c_int = 0;
            let mut tmp: xmlSchemaAttributeUsePtr =
                0 as *mut xmlSchemaAttributeUse;
            if !uses.is_null() {
                usesCount = (*uses).nbItems
            } else { usesCount = 0 as std::os::raw::c_int }
            /* Restriction. */
            i = 0 as std::os::raw::c_int;
            loop  {
                if !(i < (*baseUses).nbItems) {
                    current_block = 1874315696050160458;
                    break ;
                }
                use_0 =
                    *(*baseUses).items.offset(i as isize) as
                        xmlSchemaAttributeUsePtr;
                if !prohibs.is_null() {
                    /*
		    * Filter out prohibited uses.
		    */
                    j = 0 as std::os::raw::c_int;
                    loop  {
                        if !(j < (*prohibs).nbItems) {
                            current_block = 572715077006366937;
                            break ;
                        }
                        pro =
                            *(*prohibs).items.offset(j as isize) as
                                xmlSchemaAttributeUseProhibPtr;
                        if (*(*use_0).attrDecl).name == (*pro).name &&
                               (*(*use_0).attrDecl).targetNamespace ==
                                   (*pro).targetNamespace {
                            current_block = 3275366147856559585;
                            break ;
                        }
                        j += 1
                    }
                } else { current_block = 572715077006366937; }
                match current_block {
                    572715077006366937 => {
                        if usesCount != 0 {
                            /*
		    * Filter out existing uses.
		    */
                            j = 0 as std::os::raw::c_int;
                            loop  {
                                if !(j < usesCount) {
                                    current_block = 11763295167351361500;
                                    break ;
                                }
                                tmp =
                                    *(*uses).items.offset(j as isize) as
                                        xmlSchemaAttributeUsePtr;
                                if (*(*use_0).attrDecl).name ==
                                       (*(*tmp).attrDecl).name &&
                                       (*(*use_0).attrDecl).targetNamespace ==
                                           (*(*tmp).attrDecl).targetNamespace
                                   {
                                    current_block = 3275366147856559585;
                                    break ;
                                }
                                j += 1
                            }
                        } else { current_block = 11763295167351361500; }
                        match current_block {
                            3275366147856559585 => { }
                            _ => {
                                if uses.is_null() {
                                    (*type_0).attrUses =
                                        xmlSchemaItemListCreate() as
                                            *mut std::os::raw::c_void;
                                    if (*type_0).attrUses.is_null() {
                                        current_block = 3589988947020675255;
                                        break ;
                                    }
                                    uses =
                                        (*type_0).attrUses as
                                            xmlSchemaItemListPtr
                                }
                                xmlSchemaItemListAddSize(uses,
                                                         2 as std::os::raw::c_int,
                                                         use_0 as
                                                             *mut std::os::raw::c_void);
                            }
                        }
                    }
                    _ => { }
                }
                i += 1
            }
        } else {
            /* Extension. */
            i = 0 as std::os::raw::c_int;
            loop  {
                if !(i < (*baseUses).nbItems) {
                    current_block = 1874315696050160458;
                    break ;
                }
                use_0 =
                    *(*baseUses).items.offset(i as isize) as
                        xmlSchemaAttributeUsePtr;
                if uses.is_null() {
                    (*type_0).attrUses =
                        xmlSchemaItemListCreate() as *mut std::os::raw::c_void;
                    if (*type_0).attrUses.is_null() {
                        current_block = 3589988947020675255;
                        break ;
                    }
                    uses = (*type_0).attrUses as xmlSchemaItemListPtr
                }
                xmlSchemaItemListAddSize(uses, (*baseUses).nbItems,
                                         use_0 as *mut std::os::raw::c_void);
                i += 1
            }
        }
    } else { current_block = 1874315696050160458; }
    match current_block {
        1874315696050160458 => {
            /*
    * Shrink attr. uses.
    */
            if !uses.is_null() {
                if (*uses).nbItems == 0 as std::os::raw::c_int {
                    xmlSchemaItemListFree(uses);
                    (*type_0).attrUses = 0 as *mut std::os::raw::c_void
                }
                /*
	* TODO: We could shrink the size of the array
	* to fit the actual number of items.
	*/
            }
            /*
    * Compute the complete wildcard.
    */
            if (*type_0).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
                if !(*baseType).attributeWildcard.is_null() {
                    /*
	    * (3.2.2.1) "If the `base wildcard` is non-`absent`, then
	    * the appropriate case among the following:"
	    */
                    if !(*type_0).attributeWildcard.is_null() {
                        /*
		* Union the complete wildcard with the base wildcard.
		* SPEC {attribute wildcard}
		* (3.2.2.1.2) "otherwise a wildcard whose {process contents}
		* and {annotation} are those of the `complete wildcard`,
		* and whose {namespace constraint} is the intensional union
		* of the {namespace constraint} of the `complete wildcard`
		* and of the `base wildcard`, as defined in Attribute
		* Wildcard Union ($3.10.6)."
		*/
                        if xmlSchemaUnionWildcards(pctxt,
                                                   (*type_0).attributeWildcard,
                                                   (*baseType).attributeWildcard)
                               == -(1 as std::os::raw::c_int) {
                            current_block = 3589988947020675255;
                        } else { current_block = 9705665520141849625; }
                    } else {
                        /*
		* (3.2.2.1.1) "If the `complete wildcard` is `absent`,
		* then the `base wildcard`."
		*/
                        (*type_0).attributeWildcard =
                            (*baseType).attributeWildcard;
                        current_block = 9705665520141849625;
                    }
                } else {
                    /*
	    * (3.2.2.2) "otherwise (the `base wildcard` is `absent`) the
	    * `complete wildcard`"
	    * NOOP
	    */
                    current_block = 9705665520141849625;
                }
            } else { current_block = 9705665520141849625; }
            match current_block {
                3589988947020675255 => { }
                _ =>
                /*
	* SPEC {attribute wildcard}
	* (3.1) "If the <restriction> alternative is chosen, then the
	* `complete wildcard`;"
	* NOOP
	*/
                {
                    return 0 as std::os::raw::c_int
                }
            }
        }
        _ => { }
    }
    return -(1 as std::os::raw::c_int);
}
/* *
 * xmlSchemaTypeFinalContains:
 * @schema:  the schema
 * @type:  the type definition
 * @final: the final
 *
 * Evaluates if a type definition contains the given "final".
 * This does take "finalDefault" into account as well.
 *
 * Returns 1 if the type does containt the given "final",
 * 0 otherwise.
 */
unsafe extern "C" fn xmlSchemaTypeFinalContains(mut type_0: xmlSchemaTypePtr,
                                                mut final_0: std::os::raw::c_int)
 -> std::os::raw::c_int {
    if type_0.is_null() { return 0 as std::os::raw::c_int }
    if (*type_0).flags & final_0 != 0 {
        return 1 as std::os::raw::c_int
    } else { return 0 as std::os::raw::c_int };
}
/* *
 * xmlSchemaGetUnionSimpleTypeMemberTypes:
 * @type:  the Union Simple Type
 *
 * Returns a list of member types of @type if existing,
 * returns NULL otherwise.
 */
unsafe extern "C" fn xmlSchemaGetUnionSimpleTypeMemberTypes(mut type_0:
                                                                xmlSchemaTypePtr)
 -> xmlSchemaTypeLinkPtr {
    while !type_0.is_null() &&
              (*type_0).type_0 as std::os::raw::c_uint ==
                  XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint {
        if !(*type_0).memberTypes.is_null() {
            return (*type_0).memberTypes
        } else { type_0 = (*type_0).baseType }
    }
    return 0 as xmlSchemaTypeLinkPtr;
}
/* *
 * xmlSchemaGetParticleTotalRangeMin:
 * @particle: the particle
 *
 * Schema Component Constraint: Effective Total Range
 * (all and sequence) + (choice)
 *
 * Returns the minimun Effective Total Range.
 */
unsafe extern "C" fn xmlSchemaGetParticleTotalRangeMin(mut particle:
                                                           xmlSchemaParticlePtr)
 -> std::os::raw::c_int {
    if (*particle).children.is_null() ||
           (*particle).minOccurs == 0 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    if (*(*particle).children).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_CHOICE as std::os::raw::c_int as std::os::raw::c_uint {
        let mut min: std::os::raw::c_int = -(1 as std::os::raw::c_int);
        let mut cur: std::os::raw::c_int = 0;
        let mut part: xmlSchemaParticlePtr =
            (*(*particle).children).children as xmlSchemaParticlePtr;
        if part.is_null() { return 0 as std::os::raw::c_int }
        while !part.is_null() {
            if (*(*part).children).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_ELEMENT as std::os::raw::c_int as std::os::raw::c_uint ||
                   (*(*part).children).type_0 as std::os::raw::c_uint ==
                       XML_SCHEMA_TYPE_ANY as std::os::raw::c_int as std::os::raw::c_uint {
                cur = (*part).minOccurs
            } else { cur = xmlSchemaGetParticleTotalRangeMin(part) }
            if cur == 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
            if min > cur || min == -(1 as std::os::raw::c_int) { min = cur }
            part = (*part).next as xmlSchemaParticlePtr
        }
        return (*particle).minOccurs * min
    } else {
        /* <all> and <sequence> */
        let mut sum: std::os::raw::c_int = 0 as std::os::raw::c_int;
        let mut part_0: xmlSchemaParticlePtr =
            (*(*particle).children).children as xmlSchemaParticlePtr;
        if part_0.is_null() { return 0 as std::os::raw::c_int }
        loop  {
            if (*(*part_0).children).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_ELEMENT as std::os::raw::c_int as std::os::raw::c_uint ||
                   (*(*part_0).children).type_0 as std::os::raw::c_uint ==
                       XML_SCHEMA_TYPE_ANY as std::os::raw::c_int as std::os::raw::c_uint {
                sum += (*part_0).minOccurs
            } else { sum += xmlSchemaGetParticleTotalRangeMin(part_0) }
            part_0 = (*part_0).next as xmlSchemaParticlePtr;
            if part_0.is_null() { break ; }
        }
        return (*particle).minOccurs * sum
    };
}
/* *
 * xmlSchemaIsParticleEmptiable:
 * @particle: the particle
 *
 * Schema Component Constraint: Particle Emptiable
 * Checks whether the given particle is emptiable.
 *
 * Returns 1 if emptiable, 0 otherwise.
 */
unsafe extern "C" fn xmlSchemaIsParticleEmptiable(mut particle:
                                                      xmlSchemaParticlePtr)
 -> std::os::raw::c_int {
    /*
    * SPEC (1) "Its {min occurs} is 0."
    */
    if particle.is_null() || (*particle).minOccurs == 0 as std::os::raw::c_int ||
           (*particle).children.is_null() {
        return 1 as std::os::raw::c_int
    }
    /*
    * SPEC (2) "Its {term} is a group and the minimum part of the
    * effective total range of that group, [...] is 0."
    */
    if (*(*particle).children).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_SEQUENCE as std::os::raw::c_int as std::os::raw::c_uint ||
           (*(*particle).children).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_CHOICE as std::os::raw::c_int as std::os::raw::c_uint ||
           (*(*particle).children).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_ALL as std::os::raw::c_int as std::os::raw::c_uint {
        if xmlSchemaGetParticleTotalRangeMin(particle) == 0 as std::os::raw::c_int {
            return 1 as std::os::raw::c_int
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckCOSSTDerivedOK:
 * @actxt: a context
 * @type:  the derived simple type definition
 * @baseType:  the base type definition
 * @subset: the subset of ('restriction', ect.)
 *
 * Schema Component Constraint:
 * Type Derivation OK (Simple) (cos-st-derived-OK)
 *
 * Checks wheter @type can be validly
 * derived from @baseType.
 *
 * Returns 0 on success, an positive error code otherwise.
 */
unsafe extern "C" fn xmlSchemaCheckCOSSTDerivedOK(mut actxt:
                                                      xmlSchemaAbstractCtxtPtr,
                                                  mut type_0:
                                                      xmlSchemaTypePtr,
                                                  mut baseType:
                                                      xmlSchemaTypePtr,
                                                  mut subset: std::os::raw::c_int)
 -> std::os::raw::c_int {
    /*
    * 1 They are the same type definition.
    * TODO: The identy check might have to be more complex than this.
    */
    if type_0 == baseType { return 0 as std::os::raw::c_int }
    /*
    * 2.1 restriction is not in the subset, or in the {final}
    * of its own {base type definition};
    *
    * NOTE that this will be used also via "xsi:type".
    *
    * TODO: Revise this, it looks strange. How can the "type"
    * not be fixed or *in* fixing?
    */
    if (*type_0).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
           (*type_0).flags & (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
               0 as std::os::raw::c_int {
        if xmlSchemaTypeFixup(type_0, actxt) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
    }
    if (*baseType).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
           (*baseType).flags & (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
               0 as std::os::raw::c_int {
        if xmlSchemaTypeFixup(baseType, actxt) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
    }
    if subset & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 ||
           xmlSchemaTypeFinalContains((*type_0).baseType,
                                      (1 as std::os::raw::c_int) << 10 as std::os::raw::c_int)
               != 0 {
        return XML_SCHEMAP_COS_ST_DERIVED_OK_2_1 as std::os::raw::c_int
    }
    /* 2.2 */
    if (*type_0).baseType == baseType {
        /*
	* 2.2.1 D's `base type definition` is B.
	*/
        return 0 as std::os::raw::c_int
    }
    /*
    * 2.2.2 D's `base type definition` is not the `ur-type definition`
    * and is validly derived from B given the subset, as defined by this
    * constraint.
    */
    if !((*(*type_0).baseType).type_0 as std::os::raw::c_uint ==
             XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
             (*(*type_0).baseType).builtInType ==
                 XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) &&
           xmlSchemaCheckCOSSTDerivedOK(actxt, (*type_0).baseType, baseType,
                                        subset) == 0 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    /*
    * 2.2.3 D's {variety} is list or union and B is the `simple ur-type
    * definition`.
    */
    if (*baseType).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
           (*baseType).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int
           &&
           ((*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 ||
                (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0)
       {
        return 0 as std::os::raw::c_int
    }
    /*
    * 2.2.4 B's {variety} is union and D is validly derived from a type
    * definition in B's {member type definitions} given the subset, as
    * defined by this constraint.
    *
    * NOTE: This seems not to involve built-in types, since there is no
    * built-in Union Simple Type.
    */
    if (*baseType).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
        let mut cur: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        cur = (*baseType).memberTypes;
        while !cur.is_null() {
            if (*(*cur).type_0).type_0 as std::os::raw::c_uint !=
                   XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                   (*(*cur).type_0).flags &
                       (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                if xmlSchemaTypeFixup((*cur).type_0, actxt) ==
                       -(1 as std::os::raw::c_int) {
                    return -(1 as std::os::raw::c_int)
                }
            }
            if xmlSchemaCheckCOSSTDerivedOK(actxt, type_0, (*cur).type_0,
                                            subset) == 0 as std::os::raw::c_int {
                /*
		* It just has to be validly derived from at least one
		* member-type.
		*/
                return 0 as std::os::raw::c_int
            }
            cur = (*cur).next
        }
    }
    return XML_SCHEMAP_COS_ST_DERIVED_OK_2_2 as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckTypeDefCircularInternal:
 * @pctxt:  the schema parser context
 * @ctxtType:  the type definition
 * @ancestor: an ancestor of @ctxtType
 *
 * Checks st-props-correct (2) + ct-props-correct (3).
 * Circular type definitions are not allowed.
 *
 * Returns XML_SCHEMAP_ST_PROPS_CORRECT_2 if the given type is
 * circular, 0 otherwise.
 */
unsafe extern "C" fn xmlSchemaCheckTypeDefCircularInternal(mut pctxt:
                                                               xmlSchemaParserCtxtPtr,
                                                           mut ctxtType:
                                                               xmlSchemaTypePtr,
                                                           mut ancestor:
                                                               xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    if ancestor.is_null() ||
           (*ancestor).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
        return 0 as std::os::raw::c_int
    }
    if ctxtType == ancestor {
        xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_ST_PROPS_CORRECT_2,
                            ctxtType as xmlSchemaBasicItemPtr,
                            xmlSchemaGetComponentNode(ctxtType as
                                                          xmlSchemaBasicItemPtr),
                            b"The definition is circular\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as *const xmlChar);
        return XML_SCHEMAP_ST_PROPS_CORRECT_2 as std::os::raw::c_int
    }
    if (*ancestor).flags & (1 as std::os::raw::c_int) << 16 as std::os::raw::c_int != 0 {
        /*
	* Avoid inifinite recursion on circular types not yet checked.
	*/
        return 0 as std::os::raw::c_int
    }
    (*ancestor).flags |= (1 as std::os::raw::c_int) << 16 as std::os::raw::c_int;
    ret =
        xmlSchemaCheckTypeDefCircularInternal(pctxt, ctxtType,
                                              (*ancestor).baseType);
    (*ancestor).flags ^= (1 as std::os::raw::c_int) << 16 as std::os::raw::c_int;
    return ret;
}
/* *
 * xmlSchemaCheckTypeDefCircular:
 * @item:  the complex/simple type definition
 * @ctxt:  the parser context
 * @name:  the name
 *
 * Checks for circular type definitions.
 */
unsafe extern "C" fn xmlSchemaCheckTypeDefCircular(mut item: xmlSchemaTypePtr,
                                                   mut ctxt:
                                                       xmlSchemaParserCtxtPtr) {
    if item.is_null() ||
           (*item).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint ||
           (*item).baseType.is_null() {
        return
    }
    xmlSchemaCheckTypeDefCircularInternal(ctxt, item, (*item).baseType);
}
/*
* Simple Type Definition Representation OK (src-simple-type) 4
*
* "4 Circular union type definition is disallowed. That is, if the
* <union> alternative is chosen, there must not be any entries in the
* memberTypes [attribute] at any depth which resolve to the component
* corresponding to the <simpleType>."
*
* Note that this should work on the *representation* of a component,
* thus assumes any union types in the member types not being yet
* substituted. At this stage we need the variety of the types
* to be already computed.
*/
unsafe extern "C" fn xmlSchemaCheckUnionTypeDefCircularRecur(mut pctxt:
                                                                 xmlSchemaParserCtxtPtr,
                                                             mut ctxType:
                                                                 xmlSchemaTypePtr,
                                                             mut members:
                                                                 xmlSchemaTypeLinkPtr)
 -> std::os::raw::c_int {
    let mut member: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut memberType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    member = members;
    while !member.is_null() {
        memberType = (*member).type_0;
        while !memberType.is_null() &&
                  (*memberType).type_0 as std::os::raw::c_uint !=
                      XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
            if memberType == ctxType {
                xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_SRC_SIMPLE_TYPE_4,
                                    ctxType as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"The union type definition is circular\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    0 as *const xmlChar);
                return XML_SCHEMAP_SRC_SIMPLE_TYPE_4 as std::os::raw::c_int
            }
            if (*memberType).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int !=
                   0 &&
                   (*memberType).flags &
                       (1 as std::os::raw::c_int) << 16 as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                let mut res: std::os::raw::c_int = 0;
                (*memberType).flags |=
                    (1 as std::os::raw::c_int) << 16 as std::os::raw::c_int;
                res =
                    xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, ctxType,
                                                            xmlSchemaGetUnionSimpleTypeMemberTypes(memberType));
                (*memberType).flags ^=
                    (1 as std::os::raw::c_int) << 16 as std::os::raw::c_int;
                if res != 0 as std::os::raw::c_int { return res }
            }
            memberType = (*memberType).baseType
        }
        member = (*member).next
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaCheckUnionTypeDefCircular(mut pctxt:
                                                            xmlSchemaParserCtxtPtr,
                                                        mut type_0:
                                                            xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    if (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int == 0 {
        return 0 as std::os::raw::c_int
    }
    return xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type_0,
                                                   (*type_0).memberTypes);
}
/* *
 * xmlSchemaResolveTypeReferences:
 * @item:  the complex/simple type definition
 * @ctxt:  the parser context
 * @name:  the name
 *
 * Resolvese type definition references
 */
unsafe extern "C" fn xmlSchemaResolveTypeReferences(mut typeDef:
                                                        xmlSchemaTypePtr,
                                                    mut ctxt:
                                                        xmlSchemaParserCtxtPtr) {
    if typeDef.is_null() { return }
    /*
    * Resolve the base type.
    */
    if (*typeDef).baseType.is_null() {
        (*typeDef).baseType =
            xmlSchemaGetType((*ctxt).schema, (*typeDef).base,
                             (*typeDef).baseNs);
        if (*typeDef).baseType.is_null() {
            xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
                                     typeDef as xmlSchemaBasicItemPtr,
                                     (*typeDef).node,
                                     b"base\x00" as *const u8 as
                                         *const std::os::raw::c_char, (*typeDef).base,
                                     (*typeDef).baseNs,
                                     XML_SCHEMA_TYPE_SIMPLE,
                                     0 as *const std::os::raw::c_char);
            return
        }
    }
    if (*typeDef).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
           (*typeDef).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*typeDef).builtInType != XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        if (*typeDef).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
            /*
	    * Resolve the memberTypes.
	    */
            xmlSchemaResolveUnionMemberTypes(ctxt, typeDef);
            return
        } else {
            if (*typeDef).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0
               {
                /*
	    * Resolve the itemType.
	    */
                if (*typeDef).subtypes.is_null() && !(*typeDef).base.is_null()
                   {
                    (*typeDef).subtypes =
                        xmlSchemaGetType((*ctxt).schema, (*typeDef).base,
                                         (*typeDef).baseNs);
                    if (*typeDef).subtypes.is_null() ||
                           !((*(*typeDef).subtypes).type_0 as std::os::raw::c_uint ==
                                 XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as
                                     std::os::raw::c_uint ||
                                 (*(*typeDef).subtypes).type_0 as std::os::raw::c_uint
                                     ==
                                     XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as
                                         std::os::raw::c_uint &&
                                     (*(*typeDef).subtypes).builtInType !=
                                         XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
                        (*typeDef).subtypes = 0 as xmlSchemaTypePtr;
                        xmlSchemaPResCompAttrErr(ctxt,
                                                 XML_SCHEMAP_SRC_RESOLVE,
                                                 typeDef as
                                                     xmlSchemaBasicItemPtr,
                                                 (*typeDef).node,
                                                 b"itemType\x00" as *const u8
                                                     as *const std::os::raw::c_char,
                                                 (*typeDef).base,
                                                 (*typeDef).baseNs,
                                                 XML_SCHEMA_TYPE_SIMPLE,
                                                 0 as *const std::os::raw::c_char);
                    }
                }
                return
            }
        }
    } else if !(*typeDef).subtypes.is_null() &&
                  (*(*typeDef).subtypes).type_0 as std::os::raw::c_uint ==
                      XML_SCHEMA_TYPE_PARTICLE as std::os::raw::c_int as std::os::raw::c_uint
                  &&
                  !(*((*typeDef).subtypes as
                          xmlSchemaParticlePtr)).children.is_null() &&
                  (*(*((*typeDef).subtypes as
                           xmlSchemaParticlePtr)).children).type_0 as
                      std::os::raw::c_uint ==
                      XML_SCHEMA_EXTRA_QNAMEREF as std::os::raw::c_int as std::os::raw::c_uint
     {
        let mut ref_0: xmlSchemaQNameRefPtr =
            (*((*typeDef).subtypes as xmlSchemaParticlePtr)).children as
                xmlSchemaQNameRefPtr;
        let mut groupDef: xmlSchemaModelGroupDefPtr =
            0 as *mut xmlSchemaModelGroupDef;
        /*
    * The ball of letters below means, that if we have a particle
    * which has a QName-helper component as its {term}, we want
    * to resolve it...
    */
        /*
	* URGENT TODO: Test this.
	*/
        let ref mut fresh17 =
            (*((*typeDef).subtypes as xmlSchemaParticlePtr)).children;
        *fresh17 = 0 as xmlSchemaTreeItemPtr;
        /*
	* Resolve the MG definition reference.
	*/
        groupDef =
            xmlSchemaGetNamedComponent((*ctxt).schema, (*ref_0).itemType,
                                       (*ref_0).name,
                                       (*ref_0).targetNamespace) as
                xmlSchemaModelGroupDefPtr;
        if groupDef.is_null() {
            xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
                                     0 as xmlSchemaBasicItemPtr,
                                     xmlSchemaGetComponentNode((*typeDef).subtypes
                                                                   as
                                                                   xmlSchemaParticlePtr
                                                                   as
                                                                   xmlSchemaBasicItemPtr),
                                     b"ref\x00" as *const u8 as
                                         *const std::os::raw::c_char, (*ref_0).name,
                                     (*ref_0).targetNamespace,
                                     (*ref_0).itemType,
                                     0 as *const std::os::raw::c_char);
            /* Remove the particle. */
            (*typeDef).subtypes = 0 as xmlSchemaTypePtr
        } else if (*(groupDef as xmlSchemaModelGroupPtr)).children.is_null() {
            /* Remove the particle. */
            (*typeDef).subtypes = 0 as xmlSchemaTypePtr
        } else {
            /*
	    * Assign the MG definition's {model group} to the
	    * particle's {term}.
	    */
            let ref mut fresh18 =
                (*((*typeDef).subtypes as xmlSchemaParticlePtr)).children;
            *fresh18 = (*(groupDef as xmlSchemaModelGroupPtr)).children;
            if (*(*(groupDef as xmlSchemaModelGroupPtr)).children).type_0 as
                   std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_ALL as std::os::raw::c_int as std::os::raw::c_uint {
                /*
		* SPEC cos-all-limited (1.2)
		* "1.2 the {term} property of a particle with
		* {max occurs}=1 which is part of a pair which constitutes
		* the {content type} of a complex type definition."
		*/
                if (*((*typeDef).subtypes as xmlSchemaParticlePtr)).maxOccurs
                       != 1 as std::os::raw::c_int {
                    xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAP_COS_ALL_LIMITED,
                                       xmlSchemaGetComponentNode((*typeDef).subtypes
                                                                     as
                                                                     xmlSchemaParticlePtr
                                                                     as
                                                                     xmlSchemaBasicItemPtr),
                                       0 as xmlSchemaBasicItemPtr,
                                       b"The particle\'s {max occurs} must be 1, since the reference resolves to an \'all\' model group\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       0 as *const xmlChar,
                                       0 as *const xmlChar);
                }
            }
        }
    };
}
/* *
 * xmlSchemaCheckSTPropsCorrect:
 * @ctxt:  the schema parser context
 * @type:  the simple type definition
 *
 * Checks st-props-correct.
 *
 * Returns 0 if the properties are correct,
 * if not, a positive error code and -1 on internal
 * errors.
 */
unsafe extern "C" fn xmlSchemaCheckSTPropsCorrect(mut ctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut type_0:
                                                      xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut baseType: xmlSchemaTypePtr = (*type_0).baseType;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    /* STATE: error funcs converted. */
    /*
    * Schema Component Constraint: Simple Type Definition Properties Correct
    *
    * NOTE: This is somehow redundant, since we actually built a simple type
    * to have all the needed information; this acts as an self test.
    */
    /* Base type: If the datatype has been `derived` by `restriction`
    * then the Simple Type Definition component from which it is `derived`,
    * otherwise the Simple Type Definition for anySimpleType ($4.1.6).
    */
    if baseType.is_null() {
        /*
	* TODO: Think about: "modulo the impact of Missing
	* Sub-components ($5.3)."
	*/
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_ST_PROPS_CORRECT_1,
                            type_0 as xmlSchemaBasicItemPtr, 0 as xmlNodePtr,
                            b"No base type existent\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as *const xmlChar);
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as std::os::raw::c_int
    }
    if !((*baseType).type_0 as std::os::raw::c_uint ==
             XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
             (*baseType).type_0 as std::os::raw::c_uint ==
                 XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                 (*baseType).builtInType !=
                     XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_ST_PROPS_CORRECT_1,
                            type_0 as xmlSchemaBasicItemPtr, 0 as xmlNodePtr,
                            b"The base type \'%s\' is not a simple type\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            xmlSchemaGetComponentQName(&mut str,
                                                       baseType as
                                                           *mut std::os::raw::c_void));
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as
                                                            *mut std::os::raw::c_void);
            str = 0 as *mut xmlChar
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as std::os::raw::c_int
    }
    if ((*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 ||
            (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0) &&
           (*type_0).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int ==
               0 as std::os::raw::c_int &&
           (!((*baseType).type_0 as std::os::raw::c_uint ==
                  XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                  (*baseType).builtInType ==
                      XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int) &&
                (*baseType).type_0 as std::os::raw::c_uint !=
                    XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint) {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_ST_PROPS_CORRECT_1,
                            type_0 as xmlSchemaBasicItemPtr, 0 as xmlNodePtr,
                            b"A type, derived by list or union, must have the simple ur-type definition as base type, not \'%s\'\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            xmlSchemaGetComponentQName(&mut str,
                                                       baseType as
                                                           *mut std::os::raw::c_void));
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as
                                                            *mut std::os::raw::c_void);
            str = 0 as *mut xmlChar
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as std::os::raw::c_int
    }
    /*
    * Variety: One of {atomic, list, union}.
    */
    if (*type_0).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int == 0 &&
           (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int == 0 &&
           (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int == 0 {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_ST_PROPS_CORRECT_1,
                            type_0 as xmlSchemaBasicItemPtr, 0 as xmlNodePtr,
                            b"The variety is absent\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as *const xmlChar);
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as std::os::raw::c_int
    }
    /* TODO: Finish this. Hmm, is this finished? */
    /*
    * 3 The {final} of the {base type definition} must not contain restriction.
    */
    if xmlSchemaTypeFinalContains(baseType,
                                  (1 as std::os::raw::c_int) << 10 as std::os::raw::c_int) !=
           0 {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_ST_PROPS_CORRECT_3,
                            type_0 as xmlSchemaBasicItemPtr, 0 as xmlNodePtr,
                            b"The \'final\' of its base type \'%s\' must not contain \'restriction\'\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            xmlSchemaGetComponentQName(&mut str,
                                                       baseType as
                                                           *mut std::os::raw::c_void));
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as
                                                            *mut std::os::raw::c_void);
            str = 0 as *mut xmlChar
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_3 as std::os::raw::c_int
    }
    /*
    * 2 All simple type definitions must be derived ultimately from the `simple
    * ur-type definition` (so circular definitions are disallowed). That is, it
    * must be possible to reach a built-in primitive datatype or the `simple
    * ur-type definition` by repeatedly following the {base type definition}.
    *
    * NOTE: this is done in xmlSchemaCheckTypeDefCircular().
    */
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckCOSSTRestricts:
 * @ctxt:  the schema parser context
 * @type:  the simple type definition
 *
 * Schema Component Constraint:
 * Derivation Valid (Restriction, Simple) (cos-st-restricts)

 * Checks if the given @type (simpleType) is derived validly by restriction.
 * STATUS:
 *
 * Returns -1 on internal errors, 0 if the type is validly derived,
 * a positive error code otherwise.
 */
unsafe extern "C" fn xmlSchemaCheckCOSSTRestricts(mut pctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut type_0:
                                                      xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if (*type_0).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaCheckCOSSTRestricts\x00" as *const u8
                                 as *const std::os::raw::c_char,
                             b"given type is not a user-derived simpleType\x00"
                                 as *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    if (*type_0).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0 {
        let mut primitive: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        /*
	* SPEC (1.3.2) "If there is a facet of the same kind in the {facets}
	* of the {base type definition} (call this BF),then the DF's {value}
	* must be a valid restriction of BF's {value} as defined in
	* [XML Schemas: Datatypes]."
	*
	* NOTE (1.3.2) Facet derivation constraints are currently handled in
	* xmlSchemaDeriveAndValidateFacets()
	*/
        if (*(*type_0).baseType).flags &
               (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int == 0 {
            xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_COS_ST_RESTRICTS_1_1,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"The base type \'%s\' is not an atomic simple type\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                xmlSchemaGetComponentQName(&mut str,
                                                           (*type_0).baseType
                                                               as
                                                               *mut std::os::raw::c_void));
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_1_1 as std::os::raw::c_int
        }
        if xmlSchemaTypeFinalContains((*type_0).baseType,
                                      (1 as std::os::raw::c_int) << 10 as std::os::raw::c_int)
               != 0 {
            xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_COS_ST_RESTRICTS_1_2,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"The final of its base type \'%s\' must not contain \'restriction\'\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                xmlSchemaGetComponentQName(&mut str,
                                                           (*type_0).baseType
                                                               as
                                                               *mut std::os::raw::c_void));
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_1_2 as std::os::raw::c_int
        }
        if !(*type_0).facets.is_null() {
            let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
            let mut ok: std::os::raw::c_int = 1 as std::os::raw::c_int;
            primitive = xmlSchemaGetPrimitiveType(type_0);
            if primitive.is_null() {
                xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaCheckCOSSTRestricts\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"failed to get primitive type\x00" as
                                         *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            facet = (*type_0).facets;
            loop  {
                if xmlSchemaIsBuiltInTypeFacet(primitive,
                                               (*facet).type_0 as std::os::raw::c_int)
                       == 0 as std::os::raw::c_int {
                    ok = 0 as std::os::raw::c_int;
                    xmlSchemaPIllegalFacetAtomicErr(pctxt,
                                                    XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1,
                                                    type_0, primitive, facet);
                }
                facet = (*facet).next;
                if facet.is_null() { break ; }
            }
            if ok == 0 as std::os::raw::c_int {
                return XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1 as std::os::raw::c_int
            }
        }
    } else if (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
        let mut itemType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
        itemType = (*type_0).subtypes;
        if itemType.is_null() ||
               !((*itemType).type_0 as std::os::raw::c_uint ==
                     XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                     (*itemType).type_0 as std::os::raw::c_uint ==
                         XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint
                         &&
                         (*itemType).builtInType !=
                             XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
            xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaCheckCOSSTRestricts\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"failed to evaluate the item type\x00" as
                                     *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        if (*itemType).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*itemType).flags & (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
            xmlSchemaTypeFixup(itemType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        /*
	* 1.1 The {base type definition} must be an atomic simple
	* type definition or a built-in primitive datatype.
	*/
        /* 1.2 The {final} of the {base type definition} must not contain
	* restriction.
	*/
	/* OPTIMIZE TODO : This is already done in xmlSchemaCheckStPropsCorrect */
        /*
	* 1.3.1 DF must be an allowed constraining facet for the {primitive
	* type definition}, as specified in the appropriate subsection of 3.2
	* Primitive datatypes.
	*/
        /*
	* 2.1 The {item type definition} must have a {variety} of atomic or
	* union (in which case all the {member type definitions}
	* must be atomic).
	*/
        if (*itemType).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int == 0 &&
               (*itemType).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int == 0
           {
            xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"The item type \'%s\' does not have a variety of atomic or union\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                xmlSchemaGetComponentQName(&mut str,
                                                           itemType as
                                                               *mut std::os::raw::c_void));
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_2_1 as std::os::raw::c_int
        } else {
            if (*itemType).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0
               {
                let mut member: xmlSchemaTypeLinkPtr =
                    0 as *mut xmlSchemaTypeLink;
                member = (*itemType).memberTypes;
                while !member.is_null() {
                    if (*(*member).type_0).flags &
                           (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int == 0 {
                        xmlSchemaPCustomErr(pctxt,
                                            XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
                                            type_0 as xmlSchemaBasicItemPtr,
                                            0 as xmlNodePtr,
                                            b"The item type is a union type, but the member type \'%s\' of this item type is not atomic\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            xmlSchemaGetComponentQName(&mut str,
                                                                       (*member).type_0
                                                                           as
                                                                           *mut std::os::raw::c_void));
                        if !str.is_null() {
                            xmlFree.expect("non-null function pointer")(str as
                                                                            *mut std::os::raw::c_void);
                            str = 0 as *mut xmlChar
                        }
                        return XML_SCHEMAP_COS_ST_RESTRICTS_2_1 as std::os::raw::c_int
                    }
                    member = (*member).next
                }
            }
        }
        if (*(*type_0).baseType).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*(*type_0).baseType).builtInType ==
                   XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int {
            let mut facet_0: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
            /*
	    * MAYBE TODO: (Hmm, not really) Datatypes states:
	    * A `list` datatype can be `derived` from an `atomic` datatype
	    * whose `lexical space` allows space (such as string or anyURI)or
	    * a `union` datatype any of whose {member type definitions}'s
	    * `lexical space` allows space.
	    */
            if xmlSchemaTypeFinalContains(itemType,
                                          (1 as std::os::raw::c_int) <<
                                              11 as std::os::raw::c_int) != 0 {
                xmlSchemaPCustomErr(pctxt,
                                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"The final of its item type \'%s\' must not contain \'list\'\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaGetComponentQName(&mut str,
                                                               itemType as
                                                                   *mut std::os::raw::c_void));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1 as std::os::raw::c_int
            }
            if !(*type_0).facets.is_null() {
                facet_0 = (*type_0).facets;
                loop  {
                    if (*facet_0).type_0 as std::os::raw::c_uint !=
                           XML_SCHEMA_FACET_WHITESPACE as std::os::raw::c_int as
                               std::os::raw::c_uint {
                        xmlSchemaPIllegalFacetListUnionErr(pctxt,
                                                           XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2,
                                                           type_0, facet_0);
                        return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2 as
                                   std::os::raw::c_int
                    }
                    facet_0 = (*facet_0).next;
                    if facet_0.is_null() { break ; }
                }
            }
        } else {
            /*
	    * This is the case if we have: <simpleType><list ..
	    */
	    /*
	    * 2.3.1
	    * 2.3.1.1 The {final} of the {item type definition} must not
	    * contain list.
	    */
            /*
	    * 2.3.1.2 The {facets} must only contain the whiteSpace
	    * facet component.
	    * OPTIMIZE TODO: the S4S already disallows any facet
	    * to be specified.
	    */
            /*
	    * This is the case if we have: <simpleType><restriction ...
	    * I.e. the variety of "list" is inherited.
	    */
	    /*
	    * 2.3.2
	    * 2.3.2.1 The {base type definition} must have a {variety} of list.
	    */
            if (*(*type_0).baseType).flags &
                   (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int == 0 {
                xmlSchemaPCustomErr(pctxt,
                                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"The base type \'%s\' must be a list type\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaGetComponentQName(&mut str,
                                                               (*type_0).baseType
                                                                   as
                                                                   *mut std::os::raw::c_void));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1 as std::os::raw::c_int
            }
            /*
	    * 2.3.2.2 The {final} of the {base type definition} must not
	    * contain restriction.
	    */
            if xmlSchemaTypeFinalContains((*type_0).baseType,
                                          (1 as std::os::raw::c_int) <<
                                              10 as std::os::raw::c_int) != 0 {
                xmlSchemaPCustomErr(pctxt,
                                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"The \'final\' of the base type \'%s\' must not contain \'restriction\'\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaGetComponentQName(&mut str,
                                                               (*type_0).baseType
                                                                   as
                                                                   *mut std::os::raw::c_void));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2 as std::os::raw::c_int
            }
            /*
	    * 2.3.2.3 The {item type definition} must be validly derived
	    * from the {base type definition}'s {item type definition} given
	    * the empty set, as defined in Type Derivation OK (Simple) ($3.14.6).
	    */
            let mut baseItemType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
            baseItemType = (*(*type_0).baseType).subtypes;
            if baseItemType.is_null() ||
                   !((*baseItemType).type_0 as std::os::raw::c_uint ==
                         XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint
                         ||
                         (*baseItemType).type_0 as std::os::raw::c_uint ==
                             XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as
                                 std::os::raw::c_uint &&
                             (*baseItemType).builtInType !=
                                 XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
                xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaCheckCOSSTRestricts\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"failed to eval the item type of a base type\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            if itemType != baseItemType &&
                   xmlSchemaCheckCOSSTDerivedOK(pctxt as
                                                    xmlSchemaAbstractCtxtPtr,
                                                itemType, baseItemType,
                                                0 as std::os::raw::c_int) !=
                       0 as std::os::raw::c_int {
                let mut strBIT: *mut xmlChar = 0 as *mut xmlChar;
                let mut strBT: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErrExt(pctxt,
                                       XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3,
                                       type_0 as xmlSchemaBasicItemPtr,
                                       0 as xmlNodePtr,
                                       b"The item type \'%s\' is not validly derived from the item type \'%s\' of the base type \'%s\'\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlSchemaGetComponentQName(&mut str,
                                                                  itemType as
                                                                      *mut std::os::raw::c_void),
                                       xmlSchemaGetComponentQName(&mut strBIT,
                                                                  baseItemType
                                                                      as
                                                                      *mut std::os::raw::c_void),
                                       xmlSchemaGetComponentQName(&mut strBT,
                                                                  (*type_0).baseType
                                                                      as
                                                                      *mut std::os::raw::c_void));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                if !strBIT.is_null() {
                    xmlFree.expect("non-null function pointer")(strBIT as
                                                                    *mut std::os::raw::c_void);
                    strBIT = 0 as *mut xmlChar
                }
                if !strBT.is_null() {
                    xmlFree.expect("non-null function pointer")(strBT as
                                                                    *mut std::os::raw::c_void);
                    strBT = 0 as *mut xmlChar
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3 as std::os::raw::c_int
            }
            if !(*type_0).facets.is_null() {
                let mut facet_1: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
                let mut ok_0: std::os::raw::c_int = 1 as std::os::raw::c_int;
                /*
		* SPEC (2.3.2.5) (same as 1.3.2)
		*
		* NOTE (2.3.2.5) This is currently done in
		* xmlSchemaDeriveAndValidateFacets()
		*/
                facet_1 = (*type_0).facets;
                loop  {
                    match (*facet_1).type_0 as std::os::raw::c_uint {
                        1009 | 1011 | 1010 | 1008 | 1006 | 1007 => { }
                        _ => {
                            xmlSchemaPIllegalFacetListUnionErr(pctxt,
                                                               XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4,
                                                               type_0,
                                                               facet_1);
                            /*
		* 2.3.2.4 Only length, minLength, maxLength, whiteSpace, pattern
		* and enumeration facet components are allowed among the {facets}.
		*/
                            /*
			    * We could return, but it's nicer to report all
			    * invalid facets.
			    */
                            ok_0 = 0 as std::os::raw::c_int
                        }
                    }
                    facet_1 = (*facet_1).next;
                    if facet_1.is_null() { break ; }
                }
                if ok_0 == 0 as std::os::raw::c_int {
                    return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4 as std::os::raw::c_int
                }
            }
        }
    } else if (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
        /*
	* 3.1 The {member type definitions} must all have {variety} of
	* atomic or list.
	*/
        let mut member_0: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        member_0 = (*type_0).memberTypes;
        while !member_0.is_null() {
            if (*(*member_0).type_0).type_0 as std::os::raw::c_uint !=
                   XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                   (*(*member_0).type_0).flags &
                       (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                xmlSchemaTypeFixup((*member_0).type_0,
                                   pctxt as xmlSchemaAbstractCtxtPtr);
            }
            if (*(*member_0).type_0).flags &
                   (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int == 0 &&
                   (*(*member_0).type_0).flags &
                       (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int == 0 {
                xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_COS_ST_RESTRICTS_3_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"The member type \'%s\' is neither an atomic, nor a list type\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaGetComponentQName(&mut str,
                                                               (*member_0).type_0
                                                                   as
                                                                   *mut std::os::raw::c_void));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_1 as std::os::raw::c_int
            }
            member_0 = (*member_0).next
        }
        /*
	* 3.3.1 If the {base type definition} is the `simple ur-type
	* definition`
	*/
        if (*(*type_0).baseType).builtInType ==
               XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int {
            /*
	    * 3.3.1.1 All of the {member type definitions} must have a
	    * {final} which does not contain union.
	    */
            member_0 = (*type_0).memberTypes;
            while !member_0.is_null() {
                if xmlSchemaTypeFinalContains((*member_0).type_0,
                                              (1 as std::os::raw::c_int) <<
                                                  12 as std::os::raw::c_int) != 0 {
                    xmlSchemaPCustomErr(pctxt,
                                        XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1,
                                        type_0 as xmlSchemaBasicItemPtr,
                                        0 as xmlNodePtr,
                                        b"The \'final\' of member type \'%s\' contains \'union\'\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        xmlSchemaGetComponentQName(&mut str,
                                                                   (*member_0).type_0
                                                                       as
                                                                       *mut std::os::raw::c_void));
                    if !str.is_null() {
                        xmlFree.expect("non-null function pointer")(str as
                                                                        *mut std::os::raw::c_void);
                        str = 0 as *mut xmlChar
                    }
                    return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1 as std::os::raw::c_int
                }
                member_0 = (*member_0).next
            }
            /*
	    * 3.3.1.2 The {facets} must be empty.
	    */
            if !(*type_0).facetSet.is_null() {
                xmlSchemaPCustomErr(pctxt,
                                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"No facets allowed\x00" as *const u8 as
                                        *const std::os::raw::c_char,
                                    0 as *const xmlChar);
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2 as std::os::raw::c_int
            }
        } else {
            /*
	    * 3.3.2.1 The {base type definition} must have a {variety} of union.
	    * I.e. the variety of "list" is inherited.
	    */
            if (*(*type_0).baseType).flags &
                   (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int == 0 {
                xmlSchemaPCustomErr(pctxt,
                                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"The base type \'%s\' is not a union type\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaGetComponentQName(&mut str,
                                                               (*type_0).baseType
                                                                   as
                                                                   *mut std::os::raw::c_void));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1 as std::os::raw::c_int
            }
            /*
	    * SPEC (3.3.2.5) (same as 1.3.2)
	    *
	    * NOTE (3.3.2.5) This is currently done in
	    * xmlSchemaDeriveAndValidateFacets()
	    */
            if xmlSchemaTypeFinalContains((*type_0).baseType,
                                          (1 as std::os::raw::c_int) <<
                                              10 as std::os::raw::c_int) != 0 {
                xmlSchemaPCustomErr(pctxt,
                                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"The \'final\' of its base type \'%s\' must not contain \'restriction\'\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaGetComponentQName(&mut str,
                                                               (*type_0).baseType
                                                                   as
                                                                   *mut std::os::raw::c_void));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2 as std::os::raw::c_int
            }
            let mut baseMember: xmlSchemaTypeLinkPtr =
                0 as *mut xmlSchemaTypeLink;
            if !(*type_0).memberTypes.is_null() {
                member_0 = (*type_0).memberTypes;
                baseMember =
                    xmlSchemaGetUnionSimpleTypeMemberTypes((*type_0).baseType);
                if member_0.is_null() && !baseMember.is_null() {
                    xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaCheckCOSSTRestricts\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char,
                                         b"different number of member types in base\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                }
                while !member_0.is_null() {
                    if baseMember.is_null() {
                        xmlSchemaInternalErr(pctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             b"xmlSchemaCheckCOSSTRestricts\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"different number of member types in base\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                    } else if (*member_0).type_0 != (*baseMember).type_0 &&
                                  xmlSchemaCheckCOSSTDerivedOK(pctxt as
                                                                   xmlSchemaAbstractCtxtPtr,
                                                               (*member_0).type_0,
                                                               (*baseMember).type_0,
                                                               0 as
                                                                   std::os::raw::c_int)
                                      != 0 as std::os::raw::c_int {
                        let mut strBMT: *mut xmlChar = 0 as *mut xmlChar;
                        let mut strBT_0: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaPCustomErrExt(pctxt,
                                               XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3,
                                               type_0 as
                                                   xmlSchemaBasicItemPtr,
                                               0 as xmlNodePtr,
                                               b"The member type %s is not validly derived from its corresponding member type %s of the base type %s\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               xmlSchemaGetComponentQName(&mut str,
                                                                          (*member_0).type_0
                                                                              as
                                                                              *mut std::os::raw::c_void),
                                               xmlSchemaGetComponentQName(&mut strBMT,
                                                                          (*baseMember).type_0
                                                                              as
                                                                              *mut std::os::raw::c_void),
                                               xmlSchemaGetComponentQName(&mut strBT_0,
                                                                          (*type_0).baseType
                                                                              as
                                                                              *mut std::os::raw::c_void));
                        if !str.is_null() {
                            xmlFree.expect("non-null function pointer")(str as
                                                                            *mut std::os::raw::c_void);
                            str = 0 as *mut xmlChar
                        }
                        if !strBMT.is_null() {
                            xmlFree.expect("non-null function pointer")(strBMT
                                                                            as
                                                                            *mut std::os::raw::c_void);
                            strBMT = 0 as *mut xmlChar
                        }
                        if !strBT_0.is_null() {
                            xmlFree.expect("non-null function pointer")(strBT_0
                                                                            as
                                                                            *mut std::os::raw::c_void);
                            strBT_0 = 0 as *mut xmlChar
                        }
                        return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3 as
                                   std::os::raw::c_int
                    }
                    member_0 = (*member_0).next;
                    if !baseMember.is_null() {
                        baseMember = (*baseMember).next
                    }
                }
            }
            if !(*type_0).facets.is_null() {
                let mut facet_2: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
                let mut ok_1: std::os::raw::c_int = 1 as std::os::raw::c_int;
                facet_2 = (*type_0).facets;
                loop  {
                    if (*facet_2).type_0 as std::os::raw::c_uint !=
                           XML_SCHEMA_FACET_PATTERN as std::os::raw::c_int as
                               std::os::raw::c_uint &&
                           (*facet_2).type_0 as std::os::raw::c_uint !=
                               XML_SCHEMA_FACET_ENUMERATION as std::os::raw::c_int as
                                   std::os::raw::c_uint {
                        xmlSchemaPIllegalFacetListUnionErr(pctxt,
                                                           XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4,
                                                           type_0, facet_2);
                        ok_1 = 0 as std::os::raw::c_int
                    }
                    facet_2 = (*facet_2).next;
                    if facet_2.is_null() { break ; }
                }
                if ok_1 == 0 as std::os::raw::c_int {
                    return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4 as std::os::raw::c_int
                }
            }
        }
    }
    return 0 as std::os::raw::c_int;
}
/*
	    * 3.3.2.2 The {final} of the {base type definition} must not contain restriction.
	    */
/*
	    * 3.3.2.3 The {member type definitions}, in order, must be validly
	    * derived from the corresponding type definitions in the {base
	    * type definition}'s {member type definitions} given the empty set,
	    * as defined in Type Derivation OK (Simple) ($3.14.6).
	    */
/*
		* OPTIMIZE: if the type is restricting, it has no local defined
		* member types and inherits the member types of the base type;
		* thus a check for equality can be skipped.
		*/
		/*
		* Even worse: I cannot see a scenario where a restricting
		* union simple type can have other member types as the member
		* types of it's base type. This check seems not necessary with
		* respect to the derivation process in libxml2.
		* But necessary if constructing types with an API.
		*/
/*
	    * 3.3.2.4 Only pattern and enumeration facet components are
	    * allowed among the {facets}.
	    */
/* *
 * xmlSchemaCheckSRCSimpleType:
 * @ctxt:  the schema parser context
 * @type:  the simple type definition
 *
 * Checks crc-simple-type constraints.
 *
 * Returns 0 if the constraints are satisfied,
 * if not a positive error code and -1 on internal
 * errors.
 */
unsafe extern "C" fn xmlSchemaCreateVCtxtOnPCtxt(mut ctxt:
                                                     xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    if (*ctxt).vctxt.is_null() {
        (*ctxt).vctxt = xmlSchemaNewValidCtxt(0 as xmlSchemaPtr);
        if (*ctxt).vctxt.is_null() {
            xmlSchemaPErr(ctxt, 0 as xmlNodePtr,
                          XML_SCHEMAP_INTERNAL as std::os::raw::c_int,
                          b"Internal error: xmlSchemaCreateVCtxtOnPCtxt, failed to create a temp. validation context.\n\x00"
                              as *const u8 as *const std::os::raw::c_char,
                          0 as *const xmlChar, 0 as *const xmlChar);
            return -(1 as std::os::raw::c_int)
        }
        /* TODO: Pass user data. */
        xmlSchemaSetValidErrors((*ctxt).vctxt, (*ctxt).error, (*ctxt).warning,
                                (*ctxt).errCtxt);
        xmlSchemaSetValidStructuredErrors((*ctxt).vctxt, (*ctxt).serror,
                                          (*ctxt).errCtxt);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaParseCheckCOSValidDefault:
 * @pctxt:  the schema parser context
 * @type:  the simple type definition
 * @value: the default value
 * @node: an optional node (the holder of the value)
 *
 * Schema Component Constraint: Element Default Valid (Immediate)
 * (cos-valid-default)
 * This will be used by the parser only. For the validator there's
 * an other version.
 *
 * Returns 0 if the constraints are satisfied,
 * if not, a positive error code and -1 on internal
 * errors.
 */
unsafe extern "C" fn xmlSchemaParseCheckCOSValidDefault(mut pctxt:
                                                            xmlSchemaParserCtxtPtr,
                                                        mut node: xmlNodePtr,
                                                        mut type_0:
                                                            xmlSchemaTypePtr,
                                                        mut value:
                                                            *const xmlChar,
                                                        mut val:
                                                            *mut xmlSchemaValPtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
    * cos-valid-default:
    * Schema Component Constraint: Element Default Valid (Immediate)
    * For a string to be a valid default with respect to a type
    * definition the appropriate case among the following must be true:
    */
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
           (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        /*
	* Complex type.
	*
	* SPEC (2.1) "its {content type} must be a simple type definition
	* or mixed."
	* SPEC (2.2.2) "If the {content type} is mixed, then the {content
	* type}'s particle must be `emptiable` as defined by
	* Particle Emptiable ($3.9.6)."
	*/
        if !((*type_0).contentType as std::os::raw::c_uint ==
                 XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                 (*type_0).contentType as std::os::raw::c_uint ==
                     XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as std::os::raw::c_uint)
               &&
               (!((*type_0).contentType as std::os::raw::c_uint ==
                      XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as std::os::raw::c_uint)
                    ||
                    xmlSchemaIsParticleEmptiable((*type_0).subtypes as
                                                     xmlSchemaParticlePtr) ==
                        0) {
            /* NOTE that this covers (2.2.2) as well. */
            xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_COS_VALID_DEFAULT_2_1,
                                type_0 as xmlSchemaBasicItemPtr,
                                (*type_0).node,
                                b"For a string to be a valid default, the type definition must be a simple type or a complex type with mixed content and a particle emptiable\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar);
            return XML_SCHEMAP_COS_VALID_DEFAULT_2_1 as std::os::raw::c_int
        }
    }
    /*
    * 1 If the type definition is a simple type definition, then the string
    * must be `valid` with respect to that definition as defined by String
    * Valid ($3.14.4).
    *
    * AND
    *
    * 2.2.1 If the {content type} is a simple type definition, then the
    * string must be `valid` with respect to that simple type definition
    * as defined by String Valid ($3.14.4).
    */
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
           (*type_0).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*type_0).builtInType != XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        ret =
            xmlSchemaVCheckCVCSimpleType(pctxt as xmlSchemaAbstractCtxtPtr,
                                         node, type_0, value, val,
                                         1 as std::os::raw::c_int, 1 as std::os::raw::c_int,
                                         0 as std::os::raw::c_int)
    } else if (*type_0).contentType as std::os::raw::c_uint ==
                  XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                  (*type_0).contentType as std::os::raw::c_uint ==
                      XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as std::os::raw::c_uint
     {
        ret =
            xmlSchemaVCheckCVCSimpleType(pctxt as xmlSchemaAbstractCtxtPtr,
                                         node, (*type_0).contentTypeDef,
                                         value, val, 1 as std::os::raw::c_int,
                                         1 as std::os::raw::c_int, 0 as std::os::raw::c_int)
    } else { return ret }
    if ret < 0 as std::os::raw::c_int {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaParseCheckCOSValidDefault\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             b"calling xmlSchemaVCheckCVCSimpleType()\x00" as
                                 *const u8 as *const std::os::raw::c_char);
    }
    return ret;
}
/* *
 * xmlSchemaCheckCTPropsCorrect:
 * @ctxt:  the schema parser context
 * @type:  the complex type definition
 *
 *.(4.6) Constraints on Complex Type Definition Schema Components
 * Schema Component Constraint:
 * Complex Type Definition Properties Correct (ct-props-correct)
 * STATUS: (seems) complete
 *
 * Returns 0 if the constraints are satisfied, a positive
 * error code if not and -1 if an internal error occurred.
 */
unsafe extern "C" fn xmlSchemaCheckCTPropsCorrect(mut pctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut type_0:
                                                      xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    /*
    * TODO: Correct the error code; XML_SCHEMAP_SRC_CT_1 is used temporarily.
    *
    * SPEC (1) "The values of the properties of a complex type definition must
    * be as described in the property tableau in The Complex Type Definition
    * Schema Component ($3.4.1), modulo the impact of Missing
    * Sub-components ($5.3)."
    */
    if !(*type_0).baseType.is_null() &&
           ((*(*type_0).baseType).type_0 as std::os::raw::c_uint ==
                XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                (*(*type_0).baseType).type_0 as std::os::raw::c_uint ==
                    XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                    (*(*type_0).baseType).builtInType !=
                        XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) &&
           (*type_0).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int ==
               0 as std::os::raw::c_int {
        /*
	* SPEC (2) "If the {base type definition} is a simple type definition,
	* the {derivation method} must be extension."
	*/
        xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAP_SRC_CT_1, 0 as xmlNodePtr,
                           type_0 as xmlSchemaBasicItemPtr,
                           b"If the base type is a simple type, the derivation method must be \'extension\'\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return XML_SCHEMAP_SRC_CT_1 as std::os::raw::c_int
    }
    /*
    * SPEC (3) "Circular definitions are disallowed, except for the `ur-type
    * definition`. That is, it must be possible to reach the `ur-type
    * definition` by repeatedly following the {base type definition}."
    *
    * NOTE (3) is done in xmlSchemaCheckTypeDefCircular().
    */
    /*
    * NOTE that (4) and (5) need the following:
    *   - attribute uses need to be already inherited (apply attr. prohibitions)
    *   - attribute group references need to be expanded already
    *   - simple types need to be typefixed already
    */
    if !(*type_0).attrUses.is_null() &&
           (*((*type_0).attrUses as xmlSchemaItemListPtr)).nbItems >
               1 as std::os::raw::c_int {
        let mut uses: xmlSchemaItemListPtr =
            (*type_0).attrUses as xmlSchemaItemListPtr;
        let mut use_0: xmlSchemaAttributeUsePtr =
            0 as *mut xmlSchemaAttributeUse;
        let mut tmp: xmlSchemaAttributeUsePtr =
            0 as *mut xmlSchemaAttributeUse;
        let mut i: std::os::raw::c_int = 0;
        let mut j: std::os::raw::c_int = 0;
        let mut hasId: std::os::raw::c_int = 0 as std::os::raw::c_int;
        i = (*uses).nbItems - 1 as std::os::raw::c_int;
        's_32:
            loop  {
                if !(i >= 0 as std::os::raw::c_int) {
                    current_block = 4090602189656566074;
                    break ;
                }
                use_0 =
                    *(*uses).items.offset(i as isize) as
                        xmlSchemaAttributeUsePtr;
                /*
	    * SPEC ct-props-correct
	    * (4) "Two distinct attribute declarations in the
	    * {attribute uses} must not have identical {name}s and
	    * {target namespace}s."
	    */
                if i > 0 as std::os::raw::c_int {
                    j = i - 1 as std::os::raw::c_int;
                    loop  {
                        if !(j >= 0 as std::os::raw::c_int) {
                            current_block = 18317007320854588510;
                            break ;
                        }
                        tmp =
                            *(*uses).items.offset(j as isize) as
                                xmlSchemaAttributeUsePtr;
                        if (*(*use_0).attrDecl).name ==
                               (*(*tmp).attrDecl).name &&
                               (*(*use_0).attrDecl).targetNamespace ==
                                   (*(*tmp).attrDecl).targetNamespace {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(pctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               XML_SCHEMAP_AG_PROPS_CORRECT,
                                               0 as xmlNodePtr,
                                               type_0 as
                                                   xmlSchemaBasicItemPtr,
                                               b"Duplicate %s\x00" as
                                                   *const u8 as
                                                   *const std::os::raw::c_char,
                                               xmlSchemaGetComponentDesignation(&mut str,
                                                                                use_0
                                                                                    as
                                                                                    *mut std::os::raw::c_void),
                                               0 as *const xmlChar);
                            if !str.is_null() {
                                xmlFree.expect("non-null function pointer")(str
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                str = 0 as *mut xmlChar
                            }
                            /*
			* Remove the duplicate.
			*/
                            if xmlSchemaItemListRemove(uses, i) ==
                                   -(1 as std::os::raw::c_int) {
                                current_block = 15336973443088606251;
                                break 's_32 ;
                            } else {
                                current_block = 2473556513754201174;
                                break ;
                            }
                        } else { j -= 1 }
                    }
                } else { current_block = 18317007320854588510; }
                match current_block {
                    18317007320854588510 =>
                    /*
	    * SPEC ct-props-correct
	    * (5) "Two distinct attribute declarations in the
	    * {attribute uses} must not have {type definition}s which
	    * are or are derived from ID."
	    */
                    {
                        if !(*(*use_0).attrDecl).subtypes.is_null() {
                            if xmlSchemaIsDerivedFromBuiltInType((*(*use_0).attrDecl).subtypes,
                                                                 XML_SCHEMAS_ID
                                                                     as
                                                                     std::os::raw::c_int)
                                   != 0 {
                                if hasId != 0 {
                                    let mut str_0: *mut xmlChar =
                                        0 as *mut xmlChar;
                                    xmlSchemaCustomErr(pctxt as
                                                           xmlSchemaAbstractCtxtPtr,
                                                       XML_SCHEMAP_AG_PROPS_CORRECT,
                                                       0 as xmlNodePtr,
                                                       type_0 as
                                                           xmlSchemaBasicItemPtr,
                                                       b"There must not exist more than one attribute declaration of type \'xs:ID\' (or derived from \'xs:ID\'). The %s violates this constraint\x00"
                                                           as *const u8 as
                                                           *const std::os::raw::c_char,
                                                       xmlSchemaGetComponentDesignation(&mut str_0,
                                                                                        use_0
                                                                                            as
                                                                                            *mut std::os::raw::c_void),
                                                       0 as *const xmlChar);
                                    if !str_0.is_null() {
                                        xmlFree.expect("non-null function pointer")(str_0
                                                                                        as
                                                                                        *mut std::os::raw::c_void);
                                        str_0 = 0 as *mut xmlChar
                                    }
                                    if xmlSchemaItemListRemove(uses, i) ==
                                           -(1 as std::os::raw::c_int) {
                                        current_block = 15336973443088606251;
                                        break ;
                                    }
                                }
                                hasId = 1 as std::os::raw::c_int
                            }
                        }
                    }
                    _ => { }
                }
                i -= 1
            }
        match current_block {
            4090602189656566074 => { }
            _ => { return -(1 as std::os::raw::c_int) }
        }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaAreEqualTypes(mut typeA: xmlSchemaTypePtr,
                                            mut typeB: xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    /*
    * TODO: This should implement component-identity
    * in the future.
    */
    if typeA.is_null() || typeB.is_null() { return 0 as std::os::raw::c_int }
    return (typeA == typeB) as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckCOSCTDerivedOK:
 * @ctxt:  the schema parser context
 * @type:  the to-be derived complex type definition
 * @baseType:  the base complex type definition
 * @set: the given set
 *
 * Schema Component Constraint:
 * Type Derivation OK (Complex) (cos-ct-derived-ok)
 *
 * STATUS: completed
 *
 * Returns 0 if the constraints are satisfied, or 1
 * if not.
 */
unsafe extern "C" fn xmlSchemaCheckCOSCTDerivedOK(mut actxt:
                                                      xmlSchemaAbstractCtxtPtr,
                                                  mut type_0:
                                                      xmlSchemaTypePtr,
                                                  mut baseType:
                                                      xmlSchemaTypePtr,
                                                  mut set: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut equal: std::os::raw::c_int = xmlSchemaAreEqualTypes(type_0, baseType);
    /* TODO: Error codes. */
    /*
    * SPEC "For a complex type definition (call it D, for derived)
    * to be validly derived from a type definition (call this
    * B, for base) given a subset of {extension, restriction}
    * all of the following must be true:"
    */
    if equal == 0 {
        /*
	* SPEC (1) "If B and D are not the same type definition, then the
	* {derivation method} of D must not be in the subset."
	*/
        if set & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 &&
               (*type_0).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0
               ||
               set & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 &&
                   (*type_0).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int !=
                       0 {
            return 1 as std::os::raw::c_int
        }
    } else {
        /*
	* SPEC (2.1) "B and D must be the same type definition."
	*/
        return 0 as std::os::raw::c_int
    }
    /*
    * SPEC (2.2) "B must be D's {base type definition}."
    */
    if (*type_0).baseType == baseType { return 0 as std::os::raw::c_int }
    /*
    * SPEC (2.3.1) "D's {base type definition} must not be the `ur-type
    * definition`."
    */
    if (*(*type_0).baseType).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
           (*(*type_0).baseType).builtInType ==
               XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        return 1 as std::os::raw::c_int
    }
    if (*(*type_0).baseType).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
           (*(*type_0).baseType).builtInType ==
               XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        /*
	* SPEC (2.3.2.1) "If D's {base type definition} is complex, then it
	* must be validly derived from B given the subset as defined by this
	* constraint."
	*/
        return xmlSchemaCheckCOSCTDerivedOK(actxt, (*type_0).baseType,
                                            baseType, set)
    } else {
        /*
	* SPEC (2.3.2.2) "If D's {base type definition} is simple, then it
	* must be validly derived from B given the subset as defined in Type
	* Derivation OK (Simple) ($3.14.6).
	*/
        return xmlSchemaCheckCOSSTDerivedOK(actxt, (*type_0).baseType,
                                            baseType, set)
    };
}
/* *
 * xmlSchemaCheckCOSDerivedOK:
 * @type:  the derived simple type definition
 * @baseType:  the base type definition
 *
 * Calls:
 * Type Derivation OK (Simple) AND Type Derivation OK (Complex)
 *
 * Checks wheter @type can be validly derived from @baseType.
 *
 * Returns 0 on success, an positive error code otherwise.
 */
unsafe extern "C" fn xmlSchemaCheckCOSDerivedOK(mut actxt:
                                                    xmlSchemaAbstractCtxtPtr,
                                                mut type_0: xmlSchemaTypePtr,
                                                mut baseType:
                                                    xmlSchemaTypePtr,
                                                mut set: std::os::raw::c_int)
 -> std::os::raw::c_int {
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
           (*type_0).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*type_0).builtInType != XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        return xmlSchemaCheckCOSSTDerivedOK(actxt, type_0, baseType, set)
    } else {
        return xmlSchemaCheckCOSCTDerivedOK(actxt, type_0, baseType, set)
    };
}
/* *
 * xmlSchemaCheckCOSCTExtends:
 * @ctxt:  the schema parser context
 * @type:  the complex type definition
 *
 * (3.4.6) Constraints on Complex Type Definition Schema Components
 * Schema Component Constraint:
 * Derivation Valid (Extension) (cos-ct-extends)
 *
 * STATUS:
 *   missing:
 *     (1.5)
 *     (1.4.3.2.2.2) "Particle Valid (Extension)"
 *
 * Returns 0 if the constraints are satisfied, a positive
 * error code if not and -1 if an internal error occurred.
 */
unsafe extern "C" fn xmlSchemaCheckCOSCTExtends(mut ctxt:
                                                    xmlSchemaParserCtxtPtr,
                                                mut type_0: xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut base: xmlSchemaTypePtr = (*type_0).baseType;
    /*
    * TODO: Correct the error code; XML_SCHEMAP_COS_CT_EXTENDS_1_1 is used
    * temporarily only.
    */
    /*
    * SPEC (1) "If the {base type definition} is a complex type definition,
    * then all of the following must be true:"
    */
    if (*base).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
           (*base).builtInType == XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        /*
	* SPEC (1.1) "The {final} of the {base type definition} must not
	* contain extension."
	*/
        if (*base).flags & (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int != 0 {
            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"The \'final\' of the base type definition contains \'extension\'\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar);
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as std::os::raw::c_int
        }
        /*
	* ATTENTION: The constrains (1.2) and (1.3) are not applied,
	* since they are automatically satisfied through the
	* inheriting mechanism.
	* Note that even if redefining components, the inheriting mechanism
	* is used.
	*/
        /*
	* SPEC (1.4) "One of the following must be true:"
	*/
        if !(!(*type_0).contentTypeDef.is_null() &&
                 (*type_0).contentTypeDef == (*base).contentTypeDef) {
            if !((*type_0).contentType as std::os::raw::c_uint ==
                     XML_SCHEMA_CONTENT_EMPTY as std::os::raw::c_int as std::os::raw::c_uint
                     &&
                     (*base).contentType as std::os::raw::c_uint ==
                         XML_SCHEMA_CONTENT_EMPTY as std::os::raw::c_int as
                             std::os::raw::c_uint) {
                /*
	    * SPEC (1.4.3) "All of the following must be true:"
	    */
                if (*type_0).subtypes.is_null() {
                    /*
		* SPEC 1.4.3.1 The {content type} of the complex type
		* definition itself must specify a particle.
		*/
                    xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                                        type_0 as xmlSchemaBasicItemPtr,
                                        0 as xmlNodePtr,
                                        b"The content type must specify a particle\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as *const xmlChar);
                    return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as std::os::raw::c_int
                }
                /*
	    * URGENT TODO (1.5)
	    */
                if !((*base).contentType as std::os::raw::c_uint ==
                         XML_SCHEMA_CONTENT_EMPTY as std::os::raw::c_int as
                             std::os::raw::c_uint) {
                    /*
	    * SPEC (1.4.3.2) "One of the following must be true:"
	    */
                    /*
		* SPEC (1.4.3.2.2) "All of the following must be true:"
		*/
                    if (*type_0).contentType as std::os::raw::c_uint !=
                           (*base).contentType as std::os::raw::c_uint ||
                           (*type_0).contentType as std::os::raw::c_uint !=
                               XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as
                                   std::os::raw::c_uint &&
                               (*type_0).contentType as std::os::raw::c_uint !=
                                   XML_SCHEMA_CONTENT_ELEMENTS as std::os::raw::c_int
                                       as std::os::raw::c_uint {
                        /*
		    * SPEC (1.4.3.2.2.1) "Both {content type}s must be mixed
		    * or both must be element-only."
		    */
                        xmlSchemaPCustomErr(ctxt,
                                            XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                                            type_0 as xmlSchemaBasicItemPtr,
                                            0 as xmlNodePtr,
                                            b"The content type of both, the type and its base type, must either \'mixed\' or \'element-only\'\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            0 as *const xmlChar);
                        return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as std::os::raw::c_int
                    }
                    /*
		* URGENT TODO SPEC (1.4.3.2.2.2) "The particle of the
		* complex type definition must be a `valid extension`
		* of the {base type definition}'s particle, as defined
		* in Particle Valid (Extension) ($3.9.6)."
		*
		* NOTE that we won't check "Particle Valid (Extension)",
		* since it is ensured by the derivation process in
		* xmlSchemaTypeFixup(). We need to implement this when heading
		* for a construction API
		* TODO: !! This is needed to be checked if redefining a type !!
		*/
                }
            }
        }
    } else {
        /*
	* SPEC (2) "If the {base type definition} is a simple type definition,
	* then all of the following must be true:"
	*/
        if (*type_0).contentTypeDef != base {
            /*
	    * SPEC (2.1) "The {content type} must be the same simple type
	    * definition."
	    */
            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"The content type must be the simple base type\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar);
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as std::os::raw::c_int
        }
        if (*base).flags & (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int != 0 {
            /*
	    * SPEC (2.2) "The {final} of the {base type definition} must not
	    * contain extension"
	    * NOTE that this is the same as (1.1).
	    */
            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"The \'final\' of the base type definition contains \'extension\'\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar);
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as std::os::raw::c_int
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckDerivationOKRestriction:
 * @ctxt:  the schema parser context
 * @type:  the complex type definition
 *
 * (3.4.6) Constraints on Complex Type Definition Schema Components
 * Schema Component Constraint:
 * Derivation Valid (Restriction, Complex) (derivation-ok-restriction)
 *
 * STATUS:
 *   missing:
 *     (5.4.2) ???
 *
 * ATTENTION:
 * In XML Schema 1.1 this will be:
 * Validation Rule: Checking complex type subsumption
 *
 * Returns 0 if the constraints are satisfied, a positive
 * error code if not and -1 if an internal error occurred.
 */
unsafe extern "C" fn xmlSchemaCheckDerivationOKRestriction(mut ctxt:
                                                               xmlSchemaParserCtxtPtr,
                                                           mut type_0:
                                                               xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    /*
    * TODO: Correct the error code; XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 is used
    * temporarily only.
    */
    base = (*type_0).baseType;
    if !((*base).type_0 as std::os::raw::c_uint ==
             XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
             (*base).builtInType == XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
        xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                           (*type_0).node, type_0 as xmlSchemaBasicItemPtr,
                           b"The base type must be a complex type\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return (*ctxt).err
    }
    if (*base).flags & (1 as std::os::raw::c_int) << 10 as std::os::raw::c_int != 0 {
        /*
	* SPEC (1) "The {base type definition} must be a complex type
	* definition whose {final} does not contain restriction."
	*/
        xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                           (*type_0).node, type_0 as xmlSchemaBasicItemPtr,
                           b"The \'final\' of the base type definition contains \'restriction\'\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return (*ctxt).err
    }
    /*
    * SPEC (2), (3) and (4)
    * Those are handled in a separate function, since the
    * same constraints are needed for redefinition of
    * attribute groups as well.
    */
    if xmlSchemaCheckDerivationOKRestriction2to4(ctxt, 0 as std::os::raw::c_int,
                                                 type_0 as
                                                     xmlSchemaBasicItemPtr,
                                                 base as
                                                     xmlSchemaBasicItemPtr,
                                                 (*type_0).attrUses as
                                                     xmlSchemaItemListPtr,
                                                 (*base).attrUses as
                                                     xmlSchemaItemListPtr,
                                                 (*type_0).attributeWildcard,
                                                 (*base).attributeWildcard) ==
           -(1 as std::os::raw::c_int) {
        return -(1 as std::os::raw::c_int)
    }
    /*
    * SPEC (5) "One of the following must be true:"
    */
    if !((*base).builtInType == XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
        if (*type_0).contentType as std::os::raw::c_uint ==
               XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
               (*type_0).contentType as std::os::raw::c_uint ==
                   XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
            /*
	* SPEC (5.2.1) "The {content type} of the complex type definition
	* must be a simple type definition"
	*
	* SPEC (5.2.2) "One of the following must be true:"
	*/
            if (*base).contentType as std::os::raw::c_uint ==
                   XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                   (*base).contentType as std::os::raw::c_uint ==
                       XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as std::os::raw::c_uint
               {
                let mut err: std::os::raw::c_int = 0;
                /*
	    * SPEC (5.2.2.1) "The {content type} of the {base type
	    * definition} must be a simple type definition from which
	    * the {content type} is validly derived given the empty
	    * set as defined in Type Derivation OK (Simple) ($3.14.6)."
	    *
	    * ATTENTION TODO: This seems not needed if the type implicitely
	    * derived from the base type.
	    *
	    */
                err =
                    xmlSchemaCheckCOSSTDerivedOK(ctxt as
                                                     xmlSchemaAbstractCtxtPtr,
                                                 (*type_0).contentTypeDef,
                                                 (*base).contentTypeDef,
                                                 0 as std::os::raw::c_int);
                if err != 0 as std::os::raw::c_int {
                    let mut strA: *mut xmlChar = 0 as *mut xmlChar;
                    let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                    if err == -(1 as std::os::raw::c_int) {
                        return -(1 as std::os::raw::c_int)
                    }
                    xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                                       0 as xmlNodePtr,
                                       type_0 as xmlSchemaBasicItemPtr,
                                       b"The {content type} %s is not validly derived from the base type\'s {content type} %s\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlSchemaGetComponentDesignation(&mut strA,
                                                                        (*type_0).contentTypeDef
                                                                            as
                                                                            *mut std::os::raw::c_void),
                                       xmlSchemaGetComponentDesignation(&mut strB,
                                                                        (*base).contentTypeDef
                                                                            as
                                                                            *mut std::os::raw::c_void));
                    if !strA.is_null() {
                        xmlFree.expect("non-null function pointer")(strA as
                                                                        *mut std::os::raw::c_void);
                        strA = 0 as *mut xmlChar
                    }
                    if !strB.is_null() {
                        xmlFree.expect("non-null function pointer")(strB as
                                                                        *mut std::os::raw::c_void);
                        strB = 0 as *mut xmlChar
                    }
                    return (*ctxt).err
                }
            } else if (*base).contentType as std::os::raw::c_uint ==
                          XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as
                              std::os::raw::c_uint &&
                          xmlSchemaIsParticleEmptiable((*base).subtypes as
                                                           xmlSchemaParticlePtr)
                              != 0 {
            } else {
                xmlSchemaPCustomErr(ctxt,
                                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"The content type of the base type must be either a simple type or \'mixed\' and an emptiable particle\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    0 as *const xmlChar);
                return (*ctxt).err
            }
        } else if (*type_0).contentType as std::os::raw::c_uint ==
                      XML_SCHEMA_CONTENT_EMPTY as std::os::raw::c_int as std::os::raw::c_uint
         {
            /*
	* SPEC (5.3.1) "The {content type} of the complex type itself must
	* be empty"
	*/
            if !((*base).contentType as std::os::raw::c_uint ==
                     XML_SCHEMA_CONTENT_EMPTY as std::os::raw::c_int as std::os::raw::c_uint)
               {
                if ((*base).contentType as std::os::raw::c_uint ==
                        XML_SCHEMA_CONTENT_ELEMENTS as std::os::raw::c_int as
                            std::os::raw::c_uint ||
                        (*base).contentType as std::os::raw::c_uint ==
                            XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as
                                std::os::raw::c_uint) &&
                       xmlSchemaIsParticleEmptiable((*base).subtypes as
                                                        xmlSchemaParticlePtr)
                           != 0 {
                } else {
                    xmlSchemaPCustomErr(ctxt,
                                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                                        type_0 as xmlSchemaBasicItemPtr,
                                        0 as xmlNodePtr,
                                        b"The content type of the base type must be either empty or \'mixed\' (or \'elements-only\') and an emptiable particle\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as *const xmlChar);
                    return (*ctxt).err
                }
            }
        } else if (*type_0).contentType as std::os::raw::c_uint ==
                      XML_SCHEMA_CONTENT_ELEMENTS as std::os::raw::c_int as
                          std::os::raw::c_uint ||
                      (*type_0).contentType as std::os::raw::c_uint ==
                          XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as
                              std::os::raw::c_uint {
            /*
	* SPEC (5.4.1.1) "The {content type} of the complex type definition
	* itself must be element-only"
	*/
            if (*type_0).contentType as std::os::raw::c_uint ==
                   XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as std::os::raw::c_uint &&
                   !((*base).contentType as std::os::raw::c_uint ==
                         XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as
                             std::os::raw::c_uint) {
                /*
	    * SPEC (5.4.1.2) "The {content type} of the complex type
	    * definition itself and of the {base type definition} must be
	    * mixed"
	    */
                xmlSchemaPCustomErr(ctxt,
                                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"If the content type is \'mixed\', then the content type of the base type must also be \'mixed\'\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    0 as *const xmlChar);
                return (*ctxt).err
            }
            /*
	* SPEC (5.4.2) "The particle of the complex type definition itself
	* must be a `valid restriction` of the particle of the {content
	* type} of the {base type definition} as defined in Particle Valid
	* (Restriction) ($3.9.6).
	*
	* URGENT TODO: (5.4.2)
	*/
        } else {
            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"The type is not a valid restriction of its base type\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar);
            return (*ctxt).err
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckCTComponent:
 * @ctxt:  the schema parser context
 * @type:  the complex type definition
 *
 * (3.4.6) Constraints on Complex Type Definition Schema Components
 *
 * Returns 0 if the constraints are satisfied, a positive
 * error code if not and -1 if an internal error occurred.
 */
unsafe extern "C" fn xmlSchemaCheckCTComponent(mut ctxt:
                                                   xmlSchemaParserCtxtPtr,
                                               mut type_0: xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    /*
    * Complex Type Definition Properties Correct
    */
    ret = xmlSchemaCheckCTPropsCorrect(ctxt, type_0);
    if ret != 0 as std::os::raw::c_int { return ret }
    if (*type_0).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
        ret = xmlSchemaCheckCOSCTExtends(ctxt, type_0)
    } else { ret = xmlSchemaCheckDerivationOKRestriction(ctxt, type_0) }
    return ret;
}
/* *
 * xmlSchemaCheckSRCCT:
 * @ctxt:  the schema parser context
 * @type:  the complex type definition
 *
 * (3.4.3) Constraints on XML Representations of Complex Type Definitions:
 * Schema Representation Constraint:
 * Complex Type Definition Representation OK (src-ct)
 *
 * Returns 0 if the constraints are satisfied, a positive
 * error code if not and -1 if an internal error occurred.
 */
unsafe extern "C" fn xmlSchemaCheckSRCCT(mut ctxt: xmlSchemaParserCtxtPtr,
                                         mut type_0: xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
    * TODO: Adjust the error codes here, as I used
    * XML_SCHEMAP_SRC_CT_1 only yet.
    */
    base = (*type_0).baseType;
    if !((*type_0).contentType as std::os::raw::c_uint ==
             XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
             (*type_0).contentType as std::os::raw::c_uint ==
                 XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as std::os::raw::c_uint) {
        /*
	* 1 If the <complexContent> alternative is chosen, the type definition
	* `resolved` to by the `actual value` of the base [attribute]
	* must be a complex type definition;
	*/
        if !((*base).type_0 as std::os::raw::c_uint ==
                 XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
                 (*base).builtInType == XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
            let mut str: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_CT_1,
                                type_0 as xmlSchemaBasicItemPtr,
                                (*type_0).node,
                                b"If using <complexContent>, the base type is expected to be a complex type. The base type \'%s\' is a simple type\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                xmlSchemaFormatQName(&mut str,
                                                     (*base).targetNamespace,
                                                     (*base).name));
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
            return XML_SCHEMAP_SRC_CT_1 as std::os::raw::c_int
        }
    } else {
        /*
	* SPEC
	* 2 If the <simpleContent> alternative is chosen, all of the
	* following must be true:
	* 2.1 The type definition `resolved` to by the `actual value` of the
	* base [attribute] must be one of the following:
	*/
        if (*base).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
               (*base).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                   (*base).builtInType != XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
            if (*type_0).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                /*
		* 2.1.3 only if the <extension> alternative is also
		* chosen, a simple type definition.
		*/
		/* TODO: Change error code to ..._SRC_CT_2_1_3. */
                xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_CT_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"If using <simpleContent> and <restriction>, the base type must be a complex type. The base type \'%s\' is a simple type\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaFormatQName(&mut str_0,
                                                         (*base).targetNamespace,
                                                         (*base).name));
                if !str_0.is_null() {
                    xmlFree.expect("non-null function pointer")(str_0 as
                                                                    *mut std::os::raw::c_void);
                    str_0 = 0 as *mut xmlChar
                }
                return XML_SCHEMAP_SRC_CT_1 as std::os::raw::c_int
            }
        } else if (*base).contentType as std::os::raw::c_uint ==
                      XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint
                      ||
                      (*base).contentType as std::os::raw::c_uint ==
                          XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as
                              std::os::raw::c_uint {
            /* Base type is a complex type. */
            /*
		* 2.1.1 a complex type definition whose {content type} is a
		* simple type definition;
		* PASS
		*/
            if (*base).contentTypeDef.is_null() {
                xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_INTERNAL,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"Internal error: xmlSchemaCheckSRCCT, \'%s\', base type has no content type\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    (*type_0).name);
                return -(1 as std::os::raw::c_int)
            }
        } else if (*base).contentType as std::os::raw::c_uint ==
                      XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as std::os::raw::c_uint
                      &&
                      (*type_0).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int
                          != 0 {
            /*
		* 2.1.2 only if the <restriction> alternative is also
		* chosen, a complex type definition whose {content type}
		* is mixed and a particle emptiable.
		*/
            if xmlSchemaIsParticleEmptiable((*base).subtypes as
                                                xmlSchemaParticlePtr) == 0 {
                ret = XML_SCHEMAP_SRC_CT_1 as std::os::raw::c_int
            } else if (*type_0).contentTypeDef.is_null() {
                let mut str_1: *mut xmlChar = 0 as *mut xmlChar;
                /*
		    * Attention: at this point the <simpleType> child is in
		    * ->contentTypeDef (put there during parsing).
		    */
                /*
		    * 2.2 If clause 2.1.2 above is satisfied, then there
		    * must be a <simpleType> among the [children] of
		    * <restriction>.
		    */
		    /* TODO: Change error code to ..._SRC_CT_2_2. */
                xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_CT_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"A <simpleType> is expected among the children of <restriction>, if <simpleContent> is used and the base type \'%s\' is a complex type\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaFormatQName(&mut str_1,
                                                         (*base).targetNamespace,
                                                         (*base).name));
                if !str_1.is_null() {
                    xmlFree.expect("non-null function pointer")(str_1 as
                                                                    *mut std::os::raw::c_void);
                    str_1 = 0 as *mut xmlChar
                }
                return XML_SCHEMAP_SRC_CT_1 as std::os::raw::c_int
            }
        } else { ret = XML_SCHEMAP_SRC_CT_1 as std::os::raw::c_int }
        if ret > 0 as std::os::raw::c_int {
            let mut str_2: *mut xmlChar = 0 as *mut xmlChar;
            if (*type_0).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
                xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_CT_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"If <simpleContent> and <restriction> is used, the base type must be a simple type or a complex type with mixed content and particle emptiable. The base type \'%s\' is none of those\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaFormatQName(&mut str_2,
                                                         (*base).targetNamespace,
                                                         (*base).name));
            } else {
                xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_CT_1,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    0 as xmlNodePtr,
                                    b"If <simpleContent> and <extension> is used, the base type must be a simple type. The base type \'%s\' is a complex type\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaFormatQName(&mut str_2,
                                                         (*base).targetNamespace,
                                                         (*base).name));
            }
            if !str_2.is_null() {
                xmlFree.expect("non-null function pointer")(str_2 as
                                                                *mut std::os::raw::c_void);
                str_2 = 0 as *mut xmlChar
            }
        }
    }
    /*
    * SPEC (3) "The corresponding complex type definition component must
    * satisfy the conditions set out in Constraints on Complex Type
    * Definition Schema Components ($3.4.6);"
    * NOTE (3) will be done in xmlSchemaTypeFixup().
    */
    /*
    * SPEC (4) If clause 2.2.1 or clause 2.2.2 in the correspondence specification
    * above for {attribute wildcard} is satisfied, the intensional
    * intersection must be expressible, as defined in Attribute Wildcard
    * Intersection ($3.10.6).
    * NOTE (4) is done in xmlSchemaFixupTypeAttributeUses().
    */
    return ret;
}
unsafe extern "C" fn xmlSchemaDeriveFacetErr(mut pctxt:
                                                 xmlSchemaParserCtxtPtr,
                                             mut facet1: xmlSchemaFacetPtr,
                                             mut facet2: xmlSchemaFacetPtr,
                                             mut lessGreater: std::os::raw::c_int,
                                             mut orEqual: std::os::raw::c_int,
                                             mut ofBase: std::os::raw::c_int) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    msg =
        xmlStrdup(b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString((*facet1).type_0));
    msg =
        xmlStrcat(msg,
                  b"\' has to be\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if lessGreater == 0 as std::os::raw::c_int {
        msg =
            xmlStrcat(msg,
                      b" equal to\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    if lessGreater == 1 as std::os::raw::c_int {
        msg =
            xmlStrcat(msg,
                      b" greater than\x00" as *const u8 as *const std::os::raw::c_char
                          as *mut xmlChar)
    } else {
        msg =
            xmlStrcat(msg,
                      b" less than\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    if orEqual != 0 {
        msg =
            xmlStrcat(msg,
                      b" or equal to\x00" as *const u8 as *const std::os::raw::c_char
                          as *mut xmlChar)
    }
    msg =
        xmlStrcat(msg,
                  b" \'\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString((*facet2).type_0));
    if ofBase != 0 {
        msg =
            xmlStrcat(msg,
                      b"\' of the base type\x00" as *const u8 as
                          *const std::os::raw::c_char as *mut xmlChar)
    } else {
        msg =
            xmlStrcat(msg,
                      b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar)
    }
    xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_INVALID_FACET_VALUE,
                        facet1 as xmlSchemaBasicItemPtr, 0 as xmlNodePtr,
                        msg as *const std::os::raw::c_char, 0 as *const xmlChar);
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut std::os::raw::c_void);
    };
}
/*
* xmlSchemaDeriveAndValidateFacets:
*
* Schema Component Constraint: Simple Type Restriction (Facets)
* (st-restrict-facets)
*/
unsafe extern "C" fn xmlSchemaDeriveAndValidateFacets(mut pctxt:
                                                          xmlSchemaParserCtxtPtr,
                                                      mut type_0:
                                                          xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut current_block: u64; /* err = 0, fixedErr; */
    let mut base: xmlSchemaTypePtr = (*type_0).baseType;
    let mut link: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
    let mut cur: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
    let mut last: xmlSchemaFacetLinkPtr = 0 as xmlSchemaFacetLinkPtr;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut bfacet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut flength: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut ftotdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut ffracdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmaxlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fminlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmininc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmaxinc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fminexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmaxexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bflength: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bftotdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bffracdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmaxlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfminlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmininc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmaxinc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfminexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmaxexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut res: std::os::raw::c_int = 0;
    /*
    * SPEC st-restrict-facets 1:
    * "The {variety} of R is the same as that of B."
    */
    /*
    * SPEC st-restrict-facets 2:
    * "If {variety} is atomic, the {primitive type definition}
    * of R is the same as that of B."
    *
    * NOTE: we leave 1 & 2 out for now, since this will be
    * satisfied by the derivation process.
    * CONSTRUCTION TODO: Maybe needed if using a construction API.
    */
    /*
    * SPEC st-restrict-facets 3:
    * "The {facets} of R are the union of S and the {facets}
    * of B, eliminating duplicates. To eliminate duplicates,
    * when a facet of the same kind occurs in both S and the
    * {facets} of B, the one in the {facets} of B is not
    * included, with the exception of enumeration and pattern
    * facets, for which multiple occurrences with distinct values
    * are allowed."
    */
    if (*type_0).facetSet.is_null() && (*base).facetSet.is_null() {
        return 0 as std::os::raw::c_int
    }
    last = (*type_0).facetSet;
    if !last.is_null() {
        while !(*last).next.is_null() { last = (*last).next }
    }
    cur = (*type_0).facetSet;
    while !cur.is_null() {
        facet = (*cur).facet;
        match (*facet).type_0 as std::os::raw::c_uint {
            1009 => { flength = facet }
            1011 => { fminlen = facet }
            1000 => { fmininc = facet }
            1001 => { fminexc = facet }
            1010 => { fmaxlen = facet }
            1002 => { fmaxinc = facet }
            1003 => { fmaxexc = facet }
            1004 => { ftotdig = facet }
            1005 => { ffracdig = facet }
            _ => { }
        }
        cur = (*cur).next
    }
    cur = (*base).facetSet;
    while !cur.is_null() {
        facet = (*cur).facet;
        match (*facet).type_0 as std::os::raw::c_uint {
            1009 => { bflength = facet }
            1011 => { bfminlen = facet }
            1000 => { bfmininc = facet }
            1001 => { bfminexc = facet }
            1010 => { bfmaxlen = facet }
            1002 => { bfmaxinc = facet }
            1003 => { bfmaxexc = facet }
            1004 => { bftotdig = facet }
            1005 => { bffracdig = facet }
            _ => { }
        }
        cur = (*cur).next
    }
    /*
    * length and minLength or maxLength (2.2) + (3.2)
    */
    if !flength.is_null() && (!fminlen.is_null() || !fmaxlen.is_null()) {
        xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_INVALID_FACET_VALUE,
                            flength as xmlSchemaBasicItemPtr, (*flength).node,
                            b"It is an error for both \'length\' and either of \'minLength\' or \'maxLength\' to be specified on the same type definition\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
    }
    /*
    * Mutual exclusions in the same derivation step.
    */
    if !fmaxinc.is_null() && !fmaxexc.is_null() {
        /*
	* SCC "maxInclusive and maxExclusive"
	*/
        xmlSchemaPCustomErrExt(pctxt, XML_SCHEMAP_INVALID_FACET_VALUE,
                               fmaxinc as xmlSchemaBasicItemPtr,
                               (*fmaxinc).node,
                               b"It is an error for both \'%s\' and \'%s\' to be specified on the same type definition\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlSchemaFacetTypeToString((*fmaxinc).type_0)
                                   as *mut xmlChar,
                               xmlSchemaFacetTypeToString((*fmaxexc).type_0)
                                   as *mut xmlChar, 0 as *const xmlChar);
    }
    if !fmininc.is_null() && !fminexc.is_null() {
        /*
	* SCC "minInclusive and minExclusive"
	*/
        xmlSchemaPCustomErrExt(pctxt, XML_SCHEMAP_INVALID_FACET_VALUE,
                               fmininc as xmlSchemaBasicItemPtr,
                               (*fmininc).node,
                               b"It is an error for both \'%s\' and \'%s\' to be specified on the same type definition\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlSchemaFacetTypeToString((*fmininc).type_0)
                                   as *mut xmlChar,
                               xmlSchemaFacetTypeToString((*fminexc).type_0)
                                   as *mut xmlChar, 0 as *const xmlChar);
    }
    if !flength.is_null() && !bflength.is_null() {
        /*
	* SCC "length valid restriction"
	* The values have to be equal.
	*/
        res = xmlSchemaCompareValues((*flength).val, (*bflength).val);
        if res == -(2 as std::os::raw::c_int) {
            current_block = 15174852955798048770;
        } else {
            if res != 0 as std::os::raw::c_int {
                xmlSchemaDeriveFacetErr(pctxt, flength, bflength,
                                        0 as std::os::raw::c_int, 0 as std::os::raw::c_int,
                                        1 as std::os::raw::c_int);
            }
            if res != 0 as std::os::raw::c_int && (*bflength).fixed != 0 {
                xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_INVALID_FACET_VALUE,
                                    flength as xmlSchemaBasicItemPtr,
                                    (*flength).node,
                                    b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    0 as *const xmlChar);
            }
            current_block = 317151059986244064;
        }
    } else { current_block = 317151059986244064; }
    match current_block {
        317151059986244064 => {
            if !fminlen.is_null() && !bfminlen.is_null() {
                /*
	* SCC "minLength valid restriction"
	* minLength >= BASE minLength
	*/
                res = xmlSchemaCompareValues((*fminlen).val, (*bfminlen).val);
                if res == -(2 as std::os::raw::c_int) {
                    current_block = 15174852955798048770;
                } else {
                    if res == -(1 as std::os::raw::c_int) {
                        xmlSchemaDeriveFacetErr(pctxt, fminlen, bfminlen,
                                                1 as std::os::raw::c_int,
                                                1 as std::os::raw::c_int,
                                                1 as std::os::raw::c_int);
                    }
                    if res != 0 as std::os::raw::c_int && (*bfminlen).fixed != 0 {
                        xmlSchemaPCustomErr(pctxt,
                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                            fminlen as xmlSchemaBasicItemPtr,
                                            (*fminlen).node,
                                            b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            0 as *const xmlChar);
                    }
                    current_block = 7385833325316299293;
                }
            } else { current_block = 7385833325316299293; }
            match current_block {
                15174852955798048770 => { }
                _ => {
                    if !fmaxlen.is_null() && !bfmaxlen.is_null() {
                        /*
	* SCC "maxLength valid restriction"
	* maxLength <= BASE minLength
	*/
                        res =
                            xmlSchemaCompareValues((*fmaxlen).val,
                                                   (*bfmaxlen).val);
                        if res == -(2 as std::os::raw::c_int) {
                            current_block = 15174852955798048770;
                        } else {
                            if res == 1 as std::os::raw::c_int {
                                xmlSchemaDeriveFacetErr(pctxt, fmaxlen,
                                                        bfmaxlen,
                                                        -(1 as std::os::raw::c_int),
                                                        1 as std::os::raw::c_int,
                                                        1 as std::os::raw::c_int);
                            }
                            if res != 0 as std::os::raw::c_int &&
                                   (*bfmaxlen).fixed != 0 {
                                xmlSchemaPCustomErr(pctxt,
                                                    XML_SCHEMAP_INVALID_FACET_VALUE,
                                                    fmaxlen as
                                                        xmlSchemaBasicItemPtr,
                                                    (*fmaxlen).node,
                                                    b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                                        as *const u8 as
                                                        *const std::os::raw::c_char,
                                                    0 as *const xmlChar);
                            }
                            current_block = 8732226822098929438;
                        }
                    } else { current_block = 8732226822098929438; }
                    match current_block {
                        15174852955798048770 => { }
                        _ => {
                            /*
    * SCC "length and minLength or maxLength"
    */
                            if flength.is_null() { flength = bflength }
                            if !flength.is_null() {
                                if fminlen.is_null() { fminlen = bfminlen }
                                if !fminlen.is_null() {
                                    /* (1.1) length >= minLength */
                                    res =
                                        xmlSchemaCompareValues((*flength).val,
                                                               (*fminlen).val);
                                    if res == -(2 as std::os::raw::c_int) {
                                        current_block = 15174852955798048770;
                                    } else {
                                        if res == -(1 as std::os::raw::c_int) {
                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                    flength,
                                                                    fminlen,
                                                                    1 as
                                                                        std::os::raw::c_int,
                                                                    1 as
                                                                        std::os::raw::c_int,
                                                                    0 as
                                                                        std::os::raw::c_int);
                                        }
                                        current_block = 2798392256336243897;
                                    }
                                } else {
                                    current_block = 2798392256336243897;
                                }
                                match current_block {
                                    15174852955798048770 => { }
                                    _ => {
                                        if fmaxlen.is_null() {
                                            fmaxlen = bfmaxlen
                                        }
                                        if !fmaxlen.is_null() {
                                            /* (2.1) length <= maxLength */
                                            res =
                                                xmlSchemaCompareValues((*flength).val,
                                                                       (*fmaxlen).val);
                                            if res == -(2 as std::os::raw::c_int) {
                                                current_block =
                                                    15174852955798048770;
                                            } else {
                                                if res == 1 as std::os::raw::c_int {
                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                            flength,
                                                                            fmaxlen,
                                                                            -(1
                                                                                  as
                                                                                  std::os::raw::c_int),
                                                                            1
                                                                                as
                                                                                std::os::raw::c_int,
                                                                            0
                                                                                as
                                                                                std::os::raw::c_int);
                                                }
                                                current_block =
                                                    2945622622075328793;
                                            }
                                        } else {
                                            current_block =
                                                2945622622075328793;
                                        }
                                    }
                                }
                            } else { current_block = 2945622622075328793; }
                            match current_block {
                                15174852955798048770 => { }
                                _ => {
                                    if !fmaxinc.is_null() {
                                        /*
	* "maxInclusive"
	*/
                                        if !fmininc.is_null() {
                                            /* SCC "maxInclusive >= minInclusive" */
                                            res =
                                                xmlSchemaCompareValues((*fmaxinc).val,
                                                                       (*fmininc).val);
                                            if res == -(2 as std::os::raw::c_int) {
                                                current_block =
                                                    15174852955798048770;
                                            } else {
                                                if res == -(1 as std::os::raw::c_int)
                                                   {
                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                            fmaxinc,
                                                                            fmininc,
                                                                            1
                                                                                as
                                                                                std::os::raw::c_int,
                                                                            1
                                                                                as
                                                                                std::os::raw::c_int,
                                                                            0
                                                                                as
                                                                                std::os::raw::c_int);
                                                }
                                                current_block =
                                                    3024367268842933116;
                                            }
                                        } else {
                                            current_block =
                                                3024367268842933116;
                                        }
                                        match current_block {
                                            15174852955798048770 => { }
                                            _ =>
                                            /*
	* SCC "maxInclusive valid restriction"
	*/
                                            {
                                                if !bfmaxinc.is_null() {
                                                    /* maxInclusive <= BASE maxInclusive */
                                                    res =
                                                        xmlSchemaCompareValues((*fmaxinc).val,
                                                                               (*bfmaxinc).val);
                                                    if res ==
                                                           -(2 as std::os::raw::c_int)
                                                       {
                                                        current_block =
                                                            15174852955798048770;
                                                    } else {
                                                        if res ==
                                                               1 as
                                                                   std::os::raw::c_int
                                                           {
                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                    fmaxinc,
                                                                                    bfmaxinc,
                                                                                    -(1
                                                                                          as
                                                                                          std::os::raw::c_int),
                                                                                    1
                                                                                        as
                                                                                        std::os::raw::c_int,
                                                                                    1
                                                                                        as
                                                                                        std::os::raw::c_int);
                                                        }
                                                        if res !=
                                                               0 as
                                                                   std::os::raw::c_int
                                                               &&
                                                               (*bfmaxinc).fixed
                                                                   != 0 {
                                                            xmlSchemaPCustomErr(pctxt,
                                                                                XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                fmaxinc
                                                                                    as
                                                                                    xmlSchemaBasicItemPtr,
                                                                                (*fmaxinc).node,
                                                                                b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                                                                    as
                                                                                    *const u8
                                                                                    as
                                                                                    *const std::os::raw::c_char,
                                                                                0
                                                                                    as
                                                                                    *const xmlChar);
                                                        }
                                                        current_block =
                                                            16778110326724371720;
                                                    }
                                                } else {
                                                    current_block =
                                                        16778110326724371720;
                                                }
                                                match current_block {
                                                    15174852955798048770 => {
                                                    }
                                                    _ => {
                                                        if !bfmaxexc.is_null()
                                                           {
                                                            /* maxInclusive < BASE maxExclusive */
                                                            res =
                                                                xmlSchemaCompareValues((*fmaxinc).val,
                                                                                       (*bfmaxexc).val);
                                                            if res ==
                                                                   -(2 as
                                                                         std::os::raw::c_int)
                                                               {
                                                                current_block
                                                                    =
                                                                    15174852955798048770;
                                                            } else {
                                                                if res !=
                                                                       -(1 as
                                                                             std::os::raw::c_int)
                                                                   {
                                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                                            fmaxinc,
                                                                                            bfmaxexc,
                                                                                            -(1
                                                                                                  as
                                                                                                  std::os::raw::c_int),
                                                                                            0
                                                                                                as
                                                                                                std::os::raw::c_int,
                                                                                            1
                                                                                                as
                                                                                                std::os::raw::c_int);
                                                                }
                                                                current_block
                                                                    =
                                                                    9180031981464905198;
                                                            }
                                                        } else {
                                                            current_block =
                                                                9180031981464905198;
                                                        }
                                                        match current_block {
                                                            15174852955798048770
                                                            => {
                                                            }
                                                            _ => {
                                                                if !bfmininc.is_null()
                                                                   {
                                                                    /* maxInclusive >= BASE minInclusive */
                                                                    res =
                                                                        xmlSchemaCompareValues((*fmaxinc).val,
                                                                                               (*bfmininc).val);
                                                                    if res ==
                                                                           -(2
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                       {
                                                                        current_block
                                                                            =
                                                                            15174852955798048770;
                                                                    } else {
                                                                        if res
                                                                               ==
                                                                               -(1
                                                                                     as
                                                                                     std::os::raw::c_int)
                                                                           {
                                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                                    fmaxinc,
                                                                                                    bfmininc,
                                                                                                    1
                                                                                                        as
                                                                                                        std::os::raw::c_int,
                                                                                                    1
                                                                                                        as
                                                                                                        std::os::raw::c_int,
                                                                                                    1
                                                                                                        as
                                                                                                        std::os::raw::c_int);
                                                                        }
                                                                        current_block
                                                                            =
                                                                            6584656659744957450;
                                                                    }
                                                                } else {
                                                                    current_block
                                                                        =
                                                                        6584656659744957450;
                                                                }
                                                                match current_block
                                                                    {
                                                                    15174852955798048770
                                                                    => {
                                                                    }
                                                                    _ => {
                                                                        if !bfminexc.is_null()
                                                                           {
                                                                            /* maxInclusive > BASE minExclusive */
                                                                            res
                                                                                =
                                                                                xmlSchemaCompareValues((*fmaxinc).val,
                                                                                                       (*bfminexc).val);
                                                                            if res
                                                                                   ==
                                                                                   -(2
                                                                                         as
                                                                                         std::os::raw::c_int)
                                                                               {
                                                                                current_block
                                                                                    =
                                                                                    15174852955798048770;
                                                                            } else {
                                                                                if res
                                                                                       !=
                                                                                       1
                                                                                           as
                                                                                           std::os::raw::c_int
                                                                                   {
                                                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                                                            fmaxinc,
                                                                                                            bfminexc,
                                                                                                            1
                                                                                                                as
                                                                                                                std::os::raw::c_int,
                                                                                                            0
                                                                                                                as
                                                                                                                std::os::raw::c_int,
                                                                                                            1
                                                                                                                as
                                                                                                                std::os::raw::c_int);
                                                                                }
                                                                                current_block
                                                                                    =
                                                                                    10938659635288570931;
                                                                            }
                                                                        } else {
                                                                            current_block
                                                                                =
                                                                                10938659635288570931;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        current_block = 10938659635288570931;
                                    }
                                    match current_block {
                                        15174852955798048770 => { }
                                        _ => {
                                            if !fmaxexc.is_null() {
                                                /*
	* "maxExclusive >= minExclusive"
	*/
                                                if !fminexc.is_null() {
                                                    res =
                                                        xmlSchemaCompareValues((*fmaxexc).val,
                                                                               (*fminexc).val);
                                                    if res ==
                                                           -(2 as std::os::raw::c_int)
                                                       {
                                                        current_block =
                                                            15174852955798048770;
                                                    } else {
                                                        if res ==
                                                               -(1 as
                                                                     std::os::raw::c_int)
                                                           {
                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                    fmaxexc,
                                                                                    fminexc,
                                                                                    1
                                                                                        as
                                                                                        std::os::raw::c_int,
                                                                                    1
                                                                                        as
                                                                                        std::os::raw::c_int,
                                                                                    0
                                                                                        as
                                                                                        std::os::raw::c_int);
                                                        }
                                                        current_block =
                                                            7545150590528655645;
                                                    }
                                                } else {
                                                    current_block =
                                                        7545150590528655645;
                                                }
                                                match current_block {
                                                    15174852955798048770 => {
                                                    }
                                                    _ =>
                                                    /*
	* "maxExclusive valid restriction"
	*/
                                                    {
                                                        if !bfmaxexc.is_null()
                                                           {
                                                            /* maxExclusive <= BASE maxExclusive */
                                                            res =
                                                                xmlSchemaCompareValues((*fmaxexc).val,
                                                                                       (*bfmaxexc).val);
                                                            if res ==
                                                                   -(2 as
                                                                         std::os::raw::c_int)
                                                               {
                                                                current_block
                                                                    =
                                                                    15174852955798048770;
                                                            } else {
                                                                if res ==
                                                                       1 as
                                                                           std::os::raw::c_int
                                                                   {
                                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                                            fmaxexc,
                                                                                            bfmaxexc,
                                                                                            -(1
                                                                                                  as
                                                                                                  std::os::raw::c_int),
                                                                                            1
                                                                                                as
                                                                                                std::os::raw::c_int,
                                                                                            1
                                                                                                as
                                                                                                std::os::raw::c_int);
                                                                }
                                                                if res !=
                                                                       0 as
                                                                           std::os::raw::c_int
                                                                       &&
                                                                       (*bfmaxexc).fixed
                                                                           !=
                                                                           0 {
                                                                    xmlSchemaPCustomErr(pctxt,
                                                                                        XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                        fmaxexc
                                                                                            as
                                                                                            xmlSchemaBasicItemPtr,
                                                                                        (*fmaxexc).node,
                                                                                        b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                                                                            as
                                                                                            *const u8
                                                                                            as
                                                                                            *const std::os::raw::c_char,
                                                                                        0
                                                                                            as
                                                                                            *const xmlChar);
                                                                }
                                                                current_block
                                                                    =
                                                                    1421636490742020198;
                                                            }
                                                        } else {
                                                            current_block =
                                                                1421636490742020198;
                                                        }
                                                        match current_block {
                                                            15174852955798048770
                                                            => {
                                                            }
                                                            _ => {
                                                                if !bfmaxinc.is_null()
                                                                   {
                                                                    /* maxExclusive <= BASE maxInclusive */
                                                                    res =
                                                                        xmlSchemaCompareValues((*fmaxexc).val,
                                                                                               (*bfmaxinc).val);
                                                                    if res ==
                                                                           -(2
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                       {
                                                                        current_block
                                                                            =
                                                                            15174852955798048770;
                                                                    } else {
                                                                        if res
                                                                               ==
                                                                               1
                                                                                   as
                                                                                   std::os::raw::c_int
                                                                           {
                                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                                    fmaxexc,
                                                                                                    bfmaxinc,
                                                                                                    -(1
                                                                                                          as
                                                                                                          std::os::raw::c_int),
                                                                                                    1
                                                                                                        as
                                                                                                        std::os::raw::c_int,
                                                                                                    1
                                                                                                        as
                                                                                                        std::os::raw::c_int);
                                                                        }
                                                                        current_block
                                                                            =
                                                                            12129449210080749085;
                                                                    }
                                                                } else {
                                                                    current_block
                                                                        =
                                                                        12129449210080749085;
                                                                }
                                                                match current_block
                                                                    {
                                                                    15174852955798048770
                                                                    => {
                                                                    }
                                                                    _ => {
                                                                        if !bfmininc.is_null()
                                                                           {
                                                                            /* maxExclusive > BASE minInclusive */
                                                                            res
                                                                                =
                                                                                xmlSchemaCompareValues((*fmaxexc).val,
                                                                                                       (*bfmininc).val);
                                                                            if res
                                                                                   ==
                                                                                   -(2
                                                                                         as
                                                                                         std::os::raw::c_int)
                                                                               {
                                                                                current_block
                                                                                    =
                                                                                    15174852955798048770;
                                                                            } else {
                                                                                if res
                                                                                       !=
                                                                                       1
                                                                                           as
                                                                                           std::os::raw::c_int
                                                                                   {
                                                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                                                            fmaxexc,
                                                                                                            bfmininc,
                                                                                                            1
                                                                                                                as
                                                                                                                std::os::raw::c_int,
                                                                                                            0
                                                                                                                as
                                                                                                                std::os::raw::c_int,
                                                                                                            1
                                                                                                                as
                                                                                                                std::os::raw::c_int);
                                                                                }
                                                                                current_block
                                                                                    =
                                                                                    11508203296038873488;
                                                                            }
                                                                        } else {
                                                                            current_block
                                                                                =
                                                                                11508203296038873488;
                                                                        }
                                                                        match current_block
                                                                            {
                                                                            15174852955798048770
                                                                            =>
                                                                            {
                                                                            }
                                                                            _
                                                                            =>
                                                                            {
                                                                                if !bfminexc.is_null()
                                                                                   {
                                                                                    /* maxExclusive > BASE minExclusive */
                                                                                    res
                                                                                        =
                                                                                        xmlSchemaCompareValues((*fmaxexc).val,
                                                                                                               (*bfminexc).val);
                                                                                    if res
                                                                                           ==
                                                                                           -(2
                                                                                                 as
                                                                                                 std::os::raw::c_int)
                                                                                       {
                                                                                        current_block
                                                                                            =
                                                                                            15174852955798048770;
                                                                                    } else {
                                                                                        if res
                                                                                               !=
                                                                                               1
                                                                                                   as
                                                                                                   std::os::raw::c_int
                                                                                           {
                                                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                                                    fmaxexc,
                                                                                                                    bfminexc,
                                                                                                                    1
                                                                                                                        as
                                                                                                                        std::os::raw::c_int,
                                                                                                                    0
                                                                                                                        as
                                                                                                                        std::os::raw::c_int,
                                                                                                                    1
                                                                                                                        as
                                                                                                                        std::os::raw::c_int);
                                                                                        }
                                                                                        current_block
                                                                                            =
                                                                                            5482373152242628851;
                                                                                    }
                                                                                } else {
                                                                                    current_block
                                                                                        =
                                                                                        5482373152242628851;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                current_block =
                                                    5482373152242628851;
                                            }
                                            match current_block {
                                                15174852955798048770 => { }
                                                _ => {
                                                    if !fminexc.is_null() {
                                                        /*
	* "minExclusive < maxInclusive"
	*/
                                                        if !fmaxinc.is_null()
                                                           {
                                                            res =
                                                                xmlSchemaCompareValues((*fminexc).val,
                                                                                       (*fmaxinc).val);
                                                            if res ==
                                                                   -(2 as
                                                                         std::os::raw::c_int)
                                                               {
                                                                current_block
                                                                    =
                                                                    15174852955798048770;
                                                            } else {
                                                                if res !=
                                                                       -(1 as
                                                                             std::os::raw::c_int)
                                                                   {
                                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                                            fminexc,
                                                                                            fmaxinc,
                                                                                            -(1
                                                                                                  as
                                                                                                  std::os::raw::c_int),
                                                                                            0
                                                                                                as
                                                                                                std::os::raw::c_int,
                                                                                            0
                                                                                                as
                                                                                                std::os::raw::c_int);
                                                                }
                                                                current_block
                                                                    =
                                                                    2925215368761540503;
                                                            }
                                                        } else {
                                                            current_block =
                                                                2925215368761540503;
                                                        }
                                                        match current_block {
                                                            15174852955798048770
                                                            => {
                                                            }
                                                            _ =>
                                                            /*
	* "minExclusive valid restriction"
	*/
                                                            {
                                                                if !bfminexc.is_null()
                                                                   {
                                                                    /* minExclusive >= BASE minExclusive */
                                                                    res =
                                                                        xmlSchemaCompareValues((*fminexc).val,
                                                                                               (*bfminexc).val);
                                                                    if res ==
                                                                           -(2
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                       {
                                                                        current_block
                                                                            =
                                                                            15174852955798048770;
                                                                    } else {
                                                                        if res
                                                                               ==
                                                                               -(1
                                                                                     as
                                                                                     std::os::raw::c_int)
                                                                           {
                                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                                    fminexc,
                                                                                                    bfminexc,
                                                                                                    1
                                                                                                        as
                                                                                                        std::os::raw::c_int,
                                                                                                    1
                                                                                                        as
                                                                                                        std::os::raw::c_int,
                                                                                                    1
                                                                                                        as
                                                                                                        std::os::raw::c_int);
                                                                        }
                                                                        if res
                                                                               !=
                                                                               0
                                                                                   as
                                                                                   std::os::raw::c_int
                                                                               &&
                                                                               (*bfminexc).fixed
                                                                                   !=
                                                                                   0
                                                                           {
                                                                            xmlSchemaPCustomErr(pctxt,
                                                                                                XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                fminexc
                                                                                                    as
                                                                                                    xmlSchemaBasicItemPtr,
                                                                                                (*fminexc).node,
                                                                                                b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                                                                                    as
                                                                                                    *const u8
                                                                                                    as
                                                                                                    *const std::os::raw::c_char,
                                                                                                0
                                                                                                    as
                                                                                                    *const xmlChar);
                                                                        }
                                                                        current_block
                                                                            =
                                                                            12299212226970775842;
                                                                    }
                                                                } else {
                                                                    current_block
                                                                        =
                                                                        12299212226970775842;
                                                                }
                                                                match current_block
                                                                    {
                                                                    15174852955798048770
                                                                    => {
                                                                    }
                                                                    _ => {
                                                                        if !bfmaxinc.is_null()
                                                                           {
                                                                            /* minExclusive <= BASE maxInclusive */
                                                                            res
                                                                                =
                                                                                xmlSchemaCompareValues((*fminexc).val,
                                                                                                       (*bfmaxinc).val);
                                                                            if res
                                                                                   ==
                                                                                   -(2
                                                                                         as
                                                                                         std::os::raw::c_int)
                                                                               {
                                                                                current_block
                                                                                    =
                                                                                    15174852955798048770;
                                                                            } else {
                                                                                if res
                                                                                       ==
                                                                                       1
                                                                                           as
                                                                                           std::os::raw::c_int
                                                                                   {
                                                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                                                            fminexc,
                                                                                                            bfmaxinc,
                                                                                                            -(1
                                                                                                                  as
                                                                                                                  std::os::raw::c_int),
                                                                                                            1
                                                                                                                as
                                                                                                                std::os::raw::c_int,
                                                                                                            1
                                                                                                                as
                                                                                                                std::os::raw::c_int);
                                                                                }
                                                                                current_block
                                                                                    =
                                                                                    16813369756331276724;
                                                                            }
                                                                        } else {
                                                                            current_block
                                                                                =
                                                                                16813369756331276724;
                                                                        }
                                                                        match current_block
                                                                            {
                                                                            15174852955798048770
                                                                            =>
                                                                            {
                                                                            }
                                                                            _
                                                                            =>
                                                                            {
                                                                                if !bfmininc.is_null()
                                                                                   {
                                                                                    /* minExclusive >= BASE minInclusive */
                                                                                    res
                                                                                        =
                                                                                        xmlSchemaCompareValues((*fminexc).val,
                                                                                                               (*bfmininc).val);
                                                                                    if res
                                                                                           ==
                                                                                           -(2
                                                                                                 as
                                                                                                 std::os::raw::c_int)
                                                                                       {
                                                                                        current_block
                                                                                            =
                                                                                            15174852955798048770;
                                                                                    } else {
                                                                                        if res
                                                                                               ==
                                                                                               -(1
                                                                                                     as
                                                                                                     std::os::raw::c_int)
                                                                                           {
                                                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                                                    fminexc,
                                                                                                                    bfmininc,
                                                                                                                    1
                                                                                                                        as
                                                                                                                        std::os::raw::c_int,
                                                                                                                    1
                                                                                                                        as
                                                                                                                        std::os::raw::c_int,
                                                                                                                    1
                                                                                                                        as
                                                                                                                        std::os::raw::c_int);
                                                                                        }
                                                                                        current_block
                                                                                            =
                                                                                            5267916556966421873;
                                                                                    }
                                                                                } else {
                                                                                    current_block
                                                                                        =
                                                                                        5267916556966421873;
                                                                                }
                                                                                match current_block
                                                                                    {
                                                                                    15174852955798048770
                                                                                    =>
                                                                                    {
                                                                                    }
                                                                                    _
                                                                                    =>
                                                                                    {
                                                                                        if !bfmaxexc.is_null()
                                                                                           {
                                                                                            /* minExclusive < BASE maxExclusive */
                                                                                            res
                                                                                                =
                                                                                                xmlSchemaCompareValues((*fminexc).val,
                                                                                                                       (*bfmaxexc).val);
                                                                                            if res
                                                                                                   ==
                                                                                                   -(2
                                                                                                         as
                                                                                                         std::os::raw::c_int)
                                                                                               {
                                                                                                current_block
                                                                                                    =
                                                                                                    15174852955798048770;
                                                                                            } else {
                                                                                                if res
                                                                                                       !=
                                                                                                       -(1
                                                                                                             as
                                                                                                             std::os::raw::c_int)
                                                                                                   {
                                                                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                                                                            fminexc,
                                                                                                                            bfmaxexc,
                                                                                                                            -(1
                                                                                                                                  as
                                                                                                                                  std::os::raw::c_int),
                                                                                                                            0
                                                                                                                                as
                                                                                                                                std::os::raw::c_int,
                                                                                                                            1
                                                                                                                                as
                                                                                                                                std::os::raw::c_int);
                                                                                                }
                                                                                                current_block
                                                                                                    =
                                                                                                    6091595930016798176;
                                                                                            }
                                                                                        } else {
                                                                                            current_block
                                                                                                =
                                                                                                6091595930016798176;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        current_block =
                                                            6091595930016798176;
                                                    }
                                                    match current_block {
                                                        15174852955798048770
                                                        => {
                                                        }
                                                        _ => {
                                                            if !fmininc.is_null()
                                                               {
                                                                /*
	* "minInclusive < maxExclusive"
	*/
                                                                if !fmaxexc.is_null()
                                                                   {
                                                                    res =
                                                                        xmlSchemaCompareValues((*fmininc).val,
                                                                                               (*fmaxexc).val);
                                                                    if res ==
                                                                           -(2
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                       {
                                                                        current_block
                                                                            =
                                                                            15174852955798048770;
                                                                    } else {
                                                                        if res
                                                                               !=
                                                                               -(1
                                                                                     as
                                                                                     std::os::raw::c_int)
                                                                           {
                                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                                    fmininc,
                                                                                                    fmaxexc,
                                                                                                    -(1
                                                                                                          as
                                                                                                          std::os::raw::c_int),
                                                                                                    0
                                                                                                        as
                                                                                                        std::os::raw::c_int,
                                                                                                    0
                                                                                                        as
                                                                                                        std::os::raw::c_int);
                                                                        }
                                                                        current_block
                                                                            =
                                                                            6497888915984600225;
                                                                    }
                                                                } else {
                                                                    current_block
                                                                        =
                                                                        6497888915984600225;
                                                                }
                                                                match current_block
                                                                    {
                                                                    15174852955798048770
                                                                    => {
                                                                    }
                                                                    _ =>
                                                                    /*
	* "minExclusive valid restriction"
	*/
                                                                    {
                                                                        if !bfmininc.is_null()
                                                                           {
                                                                            /* minInclusive >= BASE minInclusive */
                                                                            res
                                                                                =
                                                                                xmlSchemaCompareValues((*fmininc).val,
                                                                                                       (*bfmininc).val);
                                                                            if res
                                                                                   ==
                                                                                   -(2
                                                                                         as
                                                                                         std::os::raw::c_int)
                                                                               {
                                                                                current_block
                                                                                    =
                                                                                    15174852955798048770;
                                                                            } else {
                                                                                if res
                                                                                       ==
                                                                                       -(1
                                                                                             as
                                                                                             std::os::raw::c_int)
                                                                                   {
                                                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                                                            fmininc,
                                                                                                            bfmininc,
                                                                                                            1
                                                                                                                as
                                                                                                                std::os::raw::c_int,
                                                                                                            1
                                                                                                                as
                                                                                                                std::os::raw::c_int,
                                                                                                            1
                                                                                                                as
                                                                                                                std::os::raw::c_int);
                                                                                }
                                                                                if res
                                                                                       !=
                                                                                       0
                                                                                           as
                                                                                           std::os::raw::c_int
                                                                                       &&
                                                                                       (*bfmininc).fixed
                                                                                           !=
                                                                                           0
                                                                                   {
                                                                                    xmlSchemaPCustomErr(pctxt,
                                                                                                        XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                        fmininc
                                                                                                            as
                                                                                                            xmlSchemaBasicItemPtr,
                                                                                                        (*fmininc).node,
                                                                                                        b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                                                                                            as
                                                                                                            *const u8
                                                                                                            as
                                                                                                            *const std::os::raw::c_char,
                                                                                                        0
                                                                                                            as
                                                                                                            *const xmlChar);
                                                                                }
                                                                                current_block
                                                                                    =
                                                                                    9350489878244555550;
                                                                            }
                                                                        } else {
                                                                            current_block
                                                                                =
                                                                                9350489878244555550;
                                                                        }
                                                                        match current_block
                                                                            {
                                                                            15174852955798048770
                                                                            =>
                                                                            {
                                                                            }
                                                                            _
                                                                            =>
                                                                            {
                                                                                if !bfmaxinc.is_null()
                                                                                   {
                                                                                    /* minInclusive <= BASE maxInclusive */
                                                                                    res
                                                                                        =
                                                                                        xmlSchemaCompareValues((*fmininc).val,
                                                                                                               (*bfmaxinc).val);
                                                                                    if res
                                                                                           ==
                                                                                           -(2
                                                                                                 as
                                                                                                 std::os::raw::c_int)
                                                                                       {
                                                                                        current_block
                                                                                            =
                                                                                            15174852955798048770;
                                                                                    } else {
                                                                                        if res
                                                                                               ==
                                                                                               1
                                                                                                   as
                                                                                                   std::os::raw::c_int
                                                                                           {
                                                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                                                    fmininc,
                                                                                                                    bfmaxinc,
                                                                                                                    -(1
                                                                                                                          as
                                                                                                                          std::os::raw::c_int),
                                                                                                                    1
                                                                                                                        as
                                                                                                                        std::os::raw::c_int,
                                                                                                                    1
                                                                                                                        as
                                                                                                                        std::os::raw::c_int);
                                                                                        }
                                                                                        current_block
                                                                                            =
                                                                                            11364608634565542496;
                                                                                    }
                                                                                } else {
                                                                                    current_block
                                                                                        =
                                                                                        11364608634565542496;
                                                                                }
                                                                                match current_block
                                                                                    {
                                                                                    15174852955798048770
                                                                                    =>
                                                                                    {
                                                                                    }
                                                                                    _
                                                                                    =>
                                                                                    {
                                                                                        if !bfminexc.is_null()
                                                                                           {
                                                                                            /* minInclusive > BASE minExclusive */
                                                                                            res
                                                                                                =
                                                                                                xmlSchemaCompareValues((*fmininc).val,
                                                                                                                       (*bfminexc).val);
                                                                                            if res
                                                                                                   ==
                                                                                                   -(2
                                                                                                         as
                                                                                                         std::os::raw::c_int)
                                                                                               {
                                                                                                current_block
                                                                                                    =
                                                                                                    15174852955798048770;
                                                                                            } else {
                                                                                                if res
                                                                                                       !=
                                                                                                       1
                                                                                                           as
                                                                                                           std::os::raw::c_int
                                                                                                   {
                                                                                                    xmlSchemaDeriveFacetErr(pctxt,
                                                                                                                            fmininc,
                                                                                                                            bfminexc,
                                                                                                                            1
                                                                                                                                as
                                                                                                                                std::os::raw::c_int,
                                                                                                                            0
                                                                                                                                as
                                                                                                                                std::os::raw::c_int,
                                                                                                                            1
                                                                                                                                as
                                                                                                                                std::os::raw::c_int);
                                                                                                }
                                                                                                current_block
                                                                                                    =
                                                                                                    3304481414499905106;
                                                                                            }
                                                                                        } else {
                                                                                            current_block
                                                                                                =
                                                                                                3304481414499905106;
                                                                                        }
                                                                                        match current_block
                                                                                            {
                                                                                            15174852955798048770
                                                                                            =>
                                                                                            {
                                                                                            }
                                                                                            _
                                                                                            =>
                                                                                            {
                                                                                                if !bfmaxexc.is_null()
                                                                                                   {
                                                                                                    /* minInclusive < BASE maxExclusive */
                                                                                                    res
                                                                                                        =
                                                                                                        xmlSchemaCompareValues((*fmininc).val,
                                                                                                                               (*bfmaxexc).val);
                                                                                                    if res
                                                                                                           ==
                                                                                                           -(2
                                                                                                                 as
                                                                                                                 std::os::raw::c_int)
                                                                                                       {
                                                                                                        current_block
                                                                                                            =
                                                                                                            15174852955798048770;
                                                                                                    } else {
                                                                                                        if res
                                                                                                               !=
                                                                                                               -(1
                                                                                                                     as
                                                                                                                     std::os::raw::c_int)
                                                                                                           {
                                                                                                            xmlSchemaDeriveFacetErr(pctxt,
                                                                                                                                    fmininc,
                                                                                                                                    bfmaxexc,
                                                                                                                                    -(1
                                                                                                                                          as
                                                                                                                                          std::os::raw::c_int),
                                                                                                                                    0
                                                                                                                                        as
                                                                                                                                        std::os::raw::c_int,
                                                                                                                                    1
                                                                                                                                        as
                                                                                                                                        std::os::raw::c_int);
                                                                                                        }
                                                                                                        current_block
                                                                                                            =
                                                                                                            1707335883933721018;
                                                                                                    }
                                                                                                } else {
                                                                                                    current_block
                                                                                                        =
                                                                                                        1707335883933721018;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                current_block
                                                                    =
                                                                    1707335883933721018;
                                                            }
                                                            match current_block
                                                                {
                                                                15174852955798048770
                                                                => {
                                                                }
                                                                _ => {
                                                                    if !ftotdig.is_null()
                                                                           &&
                                                                           !bftotdig.is_null()
                                                                       {
                                                                        /*
	* SCC " totalDigits valid restriction"
	* totalDigits <= BASE totalDigits
	*/
                                                                        res =
                                                                            xmlSchemaCompareValues((*ftotdig).val,
                                                                                                   (*bftotdig).val);
                                                                        if res
                                                                               ==
                                                                               -(2
                                                                                     as
                                                                                     std::os::raw::c_int)
                                                                           {
                                                                            current_block
                                                                                =
                                                                                15174852955798048770;
                                                                        } else {
                                                                            if res
                                                                                   ==
                                                                                   1
                                                                                       as
                                                                                       std::os::raw::c_int
                                                                               {
                                                                                xmlSchemaDeriveFacetErr(pctxt,
                                                                                                        ftotdig,
                                                                                                        bftotdig,
                                                                                                        -(1
                                                                                                              as
                                                                                                              std::os::raw::c_int),
                                                                                                        1
                                                                                                            as
                                                                                                            std::os::raw::c_int,
                                                                                                        1
                                                                                                            as
                                                                                                            std::os::raw::c_int);
                                                                            }
                                                                            if res
                                                                                   !=
                                                                                   0
                                                                                       as
                                                                                       std::os::raw::c_int
                                                                                   &&
                                                                                   (*bftotdig).fixed
                                                                                       !=
                                                                                       0
                                                                               {
                                                                                xmlSchemaPCustomErr(pctxt,
                                                                                                    XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                    ftotdig
                                                                                                        as
                                                                                                        xmlSchemaBasicItemPtr,
                                                                                                    (*ftotdig).node,
                                                                                                    b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                                                                                        as
                                                                                                        *const u8
                                                                                                        as
                                                                                                        *const std::os::raw::c_char,
                                                                                                    0
                                                                                                        as
                                                                                                        *const xmlChar);
                                                                            }
                                                                            current_block
                                                                                =
                                                                                2606663910910355487;
                                                                        }
                                                                    } else {
                                                                        current_block
                                                                            =
                                                                            2606663910910355487;
                                                                    }
                                                                    match current_block
                                                                        {
                                                                        15174852955798048770
                                                                        => {
                                                                        }
                                                                        _ => {
                                                                            if !ffracdig.is_null()
                                                                                   &&
                                                                                   !bffracdig.is_null()
                                                                               {
                                                                                /*
	* SCC  "fractionDigits valid restriction"
	* fractionDigits <= BASE fractionDigits
	*/
                                                                                res
                                                                                    =
                                                                                    xmlSchemaCompareValues((*ffracdig).val,
                                                                                                           (*bffracdig).val);
                                                                                if res
                                                                                       ==
                                                                                       -(2
                                                                                             as
                                                                                             std::os::raw::c_int)
                                                                                   {
                                                                                    current_block
                                                                                        =
                                                                                        15174852955798048770;
                                                                                } else {
                                                                                    if res
                                                                                           ==
                                                                                           1
                                                                                               as
                                                                                               std::os::raw::c_int
                                                                                       {
                                                                                        xmlSchemaDeriveFacetErr(pctxt,
                                                                                                                ffracdig,
                                                                                                                bffracdig,
                                                                                                                -(1
                                                                                                                      as
                                                                                                                      std::os::raw::c_int),
                                                                                                                1
                                                                                                                    as
                                                                                                                    std::os::raw::c_int,
                                                                                                                1
                                                                                                                    as
                                                                                                                    std::os::raw::c_int);
                                                                                    }
                                                                                    if res
                                                                                           !=
                                                                                           0
                                                                                               as
                                                                                               std::os::raw::c_int
                                                                                           &&
                                                                                           (*bffracdig).fixed
                                                                                               !=
                                                                                               0
                                                                                       {
                                                                                        xmlSchemaPCustomErr(pctxt,
                                                                                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                            ffracdig
                                                                                                                as
                                                                                                                xmlSchemaBasicItemPtr,
                                                                                                            (*ffracdig).node,
                                                                                                            b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                                                                                                as
                                                                                                                *const u8
                                                                                                                as
                                                                                                                *const std::os::raw::c_char,
                                                                                                            0
                                                                                                                as
                                                                                                                *const xmlChar);
                                                                                    }
                                                                                    current_block
                                                                                        =
                                                                                        5913497314667414582;
                                                                                }
                                                                            } else {
                                                                                current_block
                                                                                    =
                                                                                    5913497314667414582;
                                                                            }
                                                                            match current_block
                                                                                {
                                                                                15174852955798048770
                                                                                =>
                                                                                {
                                                                                }
                                                                                _
                                                                                =>
                                                                                {
                                                                                    /*
    * SCC "fractionDigits less than or equal to totalDigits"
    */
                                                                                    if ftotdig.is_null()
                                                                                       {
                                                                                        ftotdig
                                                                                            =
                                                                                            bftotdig
                                                                                    }
                                                                                    if ffracdig.is_null()
                                                                                       {
                                                                                        ffracdig
                                                                                            =
                                                                                            bffracdig
                                                                                    }
                                                                                    if !ftotdig.is_null()
                                                                                           &&
                                                                                           !ffracdig.is_null()
                                                                                       {
                                                                                        res
                                                                                            =
                                                                                            xmlSchemaCompareValues((*ffracdig).val,
                                                                                                                   (*ftotdig).val);
                                                                                        if res
                                                                                               ==
                                                                                               -(2
                                                                                                     as
                                                                                                     std::os::raw::c_int)
                                                                                           {
                                                                                            current_block
                                                                                                =
                                                                                                15174852955798048770;
                                                                                        } else {
                                                                                            if res
                                                                                                   ==
                                                                                                   1
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                               {
                                                                                                xmlSchemaDeriveFacetErr(pctxt,
                                                                                                                        ffracdig,
                                                                                                                        ftotdig,
                                                                                                                        -(1
                                                                                                                              as
                                                                                                                              std::os::raw::c_int),
                                                                                                                        1
                                                                                                                            as
                                                                                                                            std::os::raw::c_int,
                                                                                                                        0
                                                                                                                            as
                                                                                                                            std::os::raw::c_int);
                                                                                            }
                                                                                            current_block
                                                                                                =
                                                                                                9190931632177426379;
                                                                                        }
                                                                                    } else {
                                                                                        current_block
                                                                                            =
                                                                                            9190931632177426379;
                                                                                    }
                                                                                    match current_block
                                                                                        {
                                                                                        15174852955798048770
                                                                                        =>
                                                                                        {
                                                                                        }
                                                                                        _
                                                                                        =>
                                                                                        {
                                                                                            /*
    * *Enumerations* won' be added here, since only the first set
    * of enumerations in the ancestor-or-self axis is used
    * for validation, plus we need to use the base type of those
    * enumerations for whitespace.
    *
    * *Patterns*: won't be add here, since they are ORed at
    * type level and ANDed at ancestor level. This will
    * happed during validation by walking the base axis
    * of the type.
    */
                                                                                            cur
                                                                                                =
                                                                                                (*base).facetSet;
                                                                                            while !cur.is_null()
                                                                                                  {
                                                                                                bfacet
                                                                                                    =
                                                                                                    (*cur).facet;
                                                                                                /*
	* Special handling of enumerations and patterns.
	* TODO: hmm, they should not appear in the set, so remove this.
	*/
                                                                                                if !((*bfacet).type_0
                                                                                                         as
                                                                                                         std::os::raw::c_uint
                                                                                                         ==
                                                                                                         XML_SCHEMA_FACET_PATTERN
                                                                                                             as
                                                                                                             std::os::raw::c_int
                                                                                                             as
                                                                                                             std::os::raw::c_uint
                                                                                                         ||
                                                                                                         (*bfacet).type_0
                                                                                                             as
                                                                                                             std::os::raw::c_uint
                                                                                                             ==
                                                                                                             XML_SCHEMA_FACET_ENUMERATION
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 std::os::raw::c_uint)
                                                                                                   {
                                                                                                    /*
	* Search for a duplicate facet in the current type.
	*/
                                                                                                    link
                                                                                                        =
                                                                                                        (*type_0).facetSet;
                                                                                                    /* err = 0; */
	/* fixedErr = 0; */
                                                                                                    while !link.is_null()
                                                                                                          {
                                                                                                        facet
                                                                                                            =
                                                                                                            (*link).facet;
                                                                                                        if (*facet).type_0
                                                                                                               as
                                                                                                               std::os::raw::c_uint
                                                                                                               ==
                                                                                                               (*bfacet).type_0
                                                                                                                   as
                                                                                                                   std::os::raw::c_uint
                                                                                                           {
                                                                                                            match (*facet).type_0
                                                                                                                      as
                                                                                                                      std::os::raw::c_uint
                                                                                                                {
                                                                                                                1008
                                                                                                                =>
                                                                                                                {
                                                                                                                    /*
			* The whitespace must be stronger.
			*/
                                                                                                                    if (*facet).whitespace
                                                                                                                           <
                                                                                                                           (*bfacet).whitespace
                                                                                                                       {
                                                                                                                        xmlSchemaPCustomErr(pctxt,
                                                                                                                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                                                            facet
                                                                                                                                                as
                                                                                                                                                xmlSchemaBasicItemPtr,
                                                                                                                                            (*facet).node,
                                                                                                                                            b"The \'whitespace\' value has to be equal to or stronger than the \'whitespace\' value of the base type\x00"
                                                                                                                                                as
                                                                                                                                                *const u8
                                                                                                                                                as
                                                                                                                                                *const std::os::raw::c_char,
                                                                                                                                            0
                                                                                                                                                as
                                                                                                                                                *const xmlChar);
                                                                                                                    }
                                                                                                                    if (*bfacet).fixed
                                                                                                                           !=
                                                                                                                           0
                                                                                                                           &&
                                                                                                                           (*facet).whitespace
                                                                                                                               !=
                                                                                                                               (*bfacet).whitespace
                                                                                                                       {
                                                                                                                        xmlSchemaPCustomErr(pctxt,
                                                                                                                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                                                            facet
                                                                                                                                                as
                                                                                                                                                xmlSchemaBasicItemPtr,
                                                                                                                                            (*facet).node,
                                                                                                                                            b"The base type\'s facet is \'fixed\', thus the value must not differ\x00"
                                                                                                                                                as
                                                                                                                                                *const u8
                                                                                                                                                as
                                                                                                                                                *const std::os::raw::c_char,
                                                                                                                                            0
                                                                                                                                                as
                                                                                                                                                *const xmlChar);
                                                                                                                    }
                                                                                                                }
                                                                                                                _
                                                                                                                =>
                                                                                                                {
                                                                                                                }
                                                                                                            }
                                                                                                            break
                                                                                                                ;
                                                                                                        } else {
                                                                                                            link
                                                                                                                =
                                                                                                                (*link).next
                                                                                                        }
                                                                                                    }
                                                                                                    /*
	* If no duplicate was found: add the base types's facet
	* to the set.
	*/
                                                                                                    if link.is_null()
                                                                                                       {
                                                                                                        link
                                                                                                            =
                                                                                                            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaFacetLink>()
                                                                                                                                                              as
                                                                                                                                                              std::os::raw::c_ulong)
                                                                                                                as
                                                                                                                xmlSchemaFacetLinkPtr;
                                                                                                        if link.is_null()
                                                                                                           {
                                                                                                            xmlSchemaPErrMemory(pctxt,
                                                                                                                                b"deriving facets, creating a facet link\x00"
                                                                                                                                    as
                                                                                                                                    *const u8
                                                                                                                                    as
                                                                                                                                    *const std::os::raw::c_char,
                                                                                                                                0
                                                                                                                                    as
                                                                                                                                    xmlNodePtr);
                                                                                                            return -(1
                                                                                                                         as
                                                                                                                         std::os::raw::c_int)
                                                                                                        }
                                                                                                        (*link).facet
                                                                                                            =
                                                                                                            (*cur).facet;
                                                                                                        (*link).next
                                                                                                            =
                                                                                                            0
                                                                                                                as
                                                                                                                *mut _xmlSchemaFacetLink;
                                                                                                        if last.is_null()
                                                                                                           {
                                                                                                            (*type_0).facetSet
                                                                                                                =
                                                                                                                link
                                                                                                        } else {
                                                                                                            (*last).next
                                                                                                                =
                                                                                                                link
                                                                                                        }
                                                                                                        last
                                                                                                            =
                                                                                                            link
                                                                                                    }
                                                                                                }
                                                                                                cur
                                                                                                    =
                                                                                                    (*cur).next
                                                                                            }
                                                                                            return 0
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => { }
    }
    xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                         b"xmlSchemaDeriveAndValidateFacets\x00" as *const u8
                             as *const std::os::raw::c_char,
                         b"an error occurred\x00" as *const u8 as
                             *const std::os::raw::c_char);
    return -(1 as std::os::raw::c_int);
}
unsafe extern "C" fn xmlSchemaFinishMemberTypeDefinitionsProperty(mut pctxt:
                                                                      xmlSchemaParserCtxtPtr,
                                                                  mut type_0:
                                                                      xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut link: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut lastLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut prevLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut subLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut newLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    /*
    * The actual value is then formed by replacing any union type
    * definition in the `explicit members` with the members of their
    * {member type definitions}, in order.
    *
    * TODO: There's a bug entry at
    * "http://lists.w3.org/Archives/Public/www-xml-schema-comments/2005JulSep/0287.html"
    * which indicates that we'll keep the union types the future.
    */
    link = (*type_0).memberTypes;
    while !link.is_null() {
        if (*(*link).type_0).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*(*link).type_0).flags &
                   (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int == 0 as std::os::raw::c_int
           {
            xmlSchemaTypeFixup((*link).type_0,
                               pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (*(*link).type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int !=
               0 {
            subLink = xmlSchemaGetUnionSimpleTypeMemberTypes((*link).type_0);
            if !subLink.is_null() {
                (*link).type_0 = (*subLink).type_0;
                if !(*subLink).next.is_null() {
                    lastLink = (*link).next;
                    subLink = (*subLink).next;
                    prevLink = link;
                    while !subLink.is_null() {
                        newLink =
                            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaTypeLink>()
                                                                              as
                                                                              std::os::raw::c_ulong)
                                as xmlSchemaTypeLinkPtr;
                        if newLink.is_null() {
                            xmlSchemaPErrMemory(pctxt,
                                                b"allocating a type link\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char,
                                                0 as xmlNodePtr);
                            return -(1 as std::os::raw::c_int)
                        }
                        (*newLink).type_0 = (*subLink).type_0;
                        (*prevLink).next = newLink;
                        prevLink = newLink;
                        (*newLink).next = lastLink;
                        subLink = (*subLink).next
                    }
                }
            }
        }
        link = (*link).next
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaTypeFixupOptimFacets(mut type_0:
                                                       xmlSchemaTypePtr) {
    let mut has: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut needVal: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut normVal: std::os::raw::c_int = 0 as std::os::raw::c_int;
    has =
        if (*(*type_0).baseType).flags &
               (1 as std::os::raw::c_int) << 27 as std::os::raw::c_int != 0 {
            1 as std::os::raw::c_int
        } else { 0 as std::os::raw::c_int };
    if has != 0 {
        needVal =
            if (*(*type_0).baseType).flags &
                   (1 as std::os::raw::c_int) << 21 as std::os::raw::c_int != 0 {
                1 as std::os::raw::c_int
            } else { 0 as std::os::raw::c_int };
        normVal =
            if (*(*type_0).baseType).flags &
                   (1 as std::os::raw::c_int) << 28 as std::os::raw::c_int != 0 {
                1 as std::os::raw::c_int
            } else { 0 as std::os::raw::c_int }
    }
    if !(*type_0).facets.is_null() {
        let mut fac: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        fac = (*type_0).facets;
        while !fac.is_null() {
            match (*fac).type_0 as std::os::raw::c_uint {
                1008 => { }
                1006 => { normVal = 1 as std::os::raw::c_int; has = 1 as std::os::raw::c_int }
                1007 => {
                    needVal = 1 as std::os::raw::c_int;
                    normVal = 1 as std::os::raw::c_int;
                    has = 1 as std::os::raw::c_int
                }
                _ => { has = 1 as std::os::raw::c_int }
            }
            fac = (*fac).next
        }
    }
    if normVal != 0 {
        (*type_0).flags |= (1 as std::os::raw::c_int) << 28 as std::os::raw::c_int
    }
    if needVal != 0 {
        (*type_0).flags |= (1 as std::os::raw::c_int) << 21 as std::os::raw::c_int
    }
    if has != 0 { (*type_0).flags |= (1 as std::os::raw::c_int) << 27 as std::os::raw::c_int }
    if has != 0 && needVal == 0 &&
           (*type_0).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0 {
        let mut prim: xmlSchemaTypePtr = xmlSchemaGetPrimitiveType(type_0);
        /*
	* OPTIMIZE VAL TODO: Some facets need a computed value.
	*/
        if (*prim).builtInType != XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int &&
               (*prim).builtInType != XML_SCHEMAS_STRING as std::os::raw::c_int {
            (*type_0).flags |= (1 as std::os::raw::c_int) << 21 as std::os::raw::c_int
        }
    };
}
unsafe extern "C" fn xmlSchemaTypeFixupWhitespace(mut type_0:
                                                      xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    /*
    * Evaluate the whitespace-facet value.
    */
    if (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
        (*type_0).flags |= (1 as std::os::raw::c_int) << 26 as std::os::raw::c_int;
        return 0 as std::os::raw::c_int
    } else {
        if (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
            return 0 as std::os::raw::c_int
        }
    }
    if !(*type_0).facetSet.is_null() {
        let mut lin: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
        lin = (*type_0).facetSet;
        while !lin.is_null() {
            if (*(*lin).facet).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_FACET_WHITESPACE as std::os::raw::c_int as std::os::raw::c_uint
               {
                match (*(*lin).facet).whitespace {
                    1 => {
                        (*type_0).flags |=
                            (1 as std::os::raw::c_int) << 24 as std::os::raw::c_int
                    }
                    2 => {
                        (*type_0).flags |=
                            (1 as std::os::raw::c_int) << 25 as std::os::raw::c_int
                    }
                    3 => {
                        (*type_0).flags |=
                            (1 as std::os::raw::c_int) << 26 as std::os::raw::c_int
                    }
                    _ => { return -(1 as std::os::raw::c_int) }
                }
                return 0 as std::os::raw::c_int
            }
            lin = (*lin).next
        }
    }
    /*
    * For all `atomic` datatypes other than string (and types `derived`
    * by `restriction` from it) the value of whiteSpace is fixed to
    * collapse
    */
    let mut anc: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    anc = (*type_0).baseType;
    while !anc.is_null() &&
              (*anc).builtInType != XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        if (*anc).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
            if (*anc).builtInType == XML_SCHEMAS_NORMSTRING as std::os::raw::c_int {
                (*type_0).flags |= (1 as std::os::raw::c_int) << 25 as std::os::raw::c_int
            } else if (*anc).builtInType == XML_SCHEMAS_STRING as std::os::raw::c_int
                          ||
                          (*anc).builtInType ==
                              XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int {
                (*type_0).flags |= (1 as std::os::raw::c_int) << 24 as std::os::raw::c_int
            } else {
                (*type_0).flags |= (1 as std::os::raw::c_int) << 26 as std::os::raw::c_int
            }
            break ;
        } else { anc = (*anc).baseType }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaFixupSimpleTypeStageOne(mut pctxt:
                                                          xmlSchemaParserCtxtPtr,
                                                      mut type_0:
                                                          xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    if (*type_0).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint {
        return 0 as std::os::raw::c_int
    }
    if !((*type_0).type_0 as std::os::raw::c_uint !=
             XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
             (*type_0).flags & (1 as std::os::raw::c_int) << 29 as std::os::raw::c_int ==
                 0 as std::os::raw::c_int) {
        return 0 as std::os::raw::c_int
    }
    (*type_0).flags |= (1 as std::os::raw::c_int) << 29 as std::os::raw::c_int;
    if (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
        /*
	* Corresponds to <simpleType><list>...
	*/
        if (*type_0).subtypes.is_null() {
            /*
	    * This one is really needed, so get out.
	    */
            xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaFixupSimpleTypeStageOne\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"list type has no item-type assigned\x00" as
                                     *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
    } else if (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
        /*
	* Corresponds to <simpleType><union>...
	*/
        if (*type_0).memberTypes.is_null() {
            /*
	    * This one is really needed, so get out.
	    */
            xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaFixupSimpleTypeStageOne\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"union type has no member-types assigned\x00"
                                     as *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
    } else {
        /*
	* Corresponds to <simpleType><restriction>...
	*/
        if (*type_0).baseType.is_null() {
            xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaFixupSimpleTypeStageOne\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"type has no base-type assigned\x00" as
                                     *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        if (*(*type_0).baseType).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*(*type_0).baseType).flags &
                   (1 as std::os::raw::c_int) << 29 as std::os::raw::c_int == 0 as std::os::raw::c_int
           {
            if xmlSchemaFixupSimpleTypeStageOne(pctxt, (*type_0).baseType) ==
                   -(1 as std::os::raw::c_int) {
                return -(1 as std::os::raw::c_int)
            }
        }
        /*
	* Variety
	* If the <restriction> alternative is chosen, then the
	* {variety} of the {base type definition}.
	*/
        if (*(*type_0).baseType).flags &
               (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0 {
            (*type_0).flags |= (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int
        } else if (*(*type_0).baseType).flags &
                      (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
            (*type_0).flags |= (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int;
            /*
	    * Inherit the itemType.
	    */
            (*type_0).subtypes = (*(*type_0).baseType).subtypes
        } else if (*(*type_0).baseType).flags &
                      (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
            (*type_0).flags |= (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int
            /*
	    * NOTE that we won't assign the memberTypes of the base,
	    * since this will make trouble when freeing them; we will
	    * use a lookup function to access them instead.
	    */
        }
    }
    return 0 as std::os::raw::c_int;
}
/*
* 3.14.6 Constraints on Simple Type Definition Schema Components
*/
unsafe extern "C" fn xmlSchemaFixupSimpleTypeStageTwo(mut pctxt:
                                                          xmlSchemaParserCtxtPtr,
                                                      mut type_0:
                                                          xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut res: std::os::raw::c_int = 0;
    let mut olderrs: std::os::raw::c_int = (*pctxt).nberrors;
    if (*type_0).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint {
        return -(1 as std::os::raw::c_int)
    }
    if !((*type_0).type_0 as std::os::raw::c_uint !=
             XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
             (*type_0).flags & (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
                 0 as std::os::raw::c_int) {
        return 0 as std::os::raw::c_int
    }
    (*type_0).flags |= (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int;
    (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
    if (*type_0).baseType.is_null() {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaFixupSimpleTypeStageTwo\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             b"missing baseType\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    } else {
        if (*(*type_0).baseType).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*(*type_0).baseType).flags &
                   (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int == 0 as std::os::raw::c_int
           {
            xmlSchemaTypeFixup((*type_0).baseType,
                               pctxt as xmlSchemaAbstractCtxtPtr);
        }
        /*
    * If a member type of a union is a union itself, we need to substitute
    * that member type for its member types.
    * NOTE that this might change in WXS 1.1; i.e. we will keep the union
    * types in WXS 1.1.
    */
        if !(*type_0).memberTypes.is_null() &&
               xmlSchemaFinishMemberTypeDefinitionsProperty(pctxt, type_0) ==
                   -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
        /*
    * SPEC src-simple-type 1
    * "The corresponding simple type definition, if any, must satisfy
    * the conditions set out in Constraints on Simple Type Definition
    * Schema Components ($3.14.6)."
    */
    /*
    * Schema Component Constraint: Simple Type Definition Properties Correct
    * (st-props-correct)
    */
        res = xmlSchemaCheckSTPropsCorrect(pctxt, type_0);
        if !(res == -(1 as std::os::raw::c_int)) {
            if res != 0 as std::os::raw::c_int {
                current_block = 14122743233969242769;
            } else {
                /*
    * Schema Component Constraint: Derivation Valid (Restriction, Simple)
    * (cos-st-restricts)
    */
                res = xmlSchemaCheckCOSSTRestricts(pctxt, type_0);
                if res == -(1 as std::os::raw::c_int) {
                    current_block = 1308815063512225514;
                } else if res != 0 as std::os::raw::c_int {
                    current_block = 14122743233969242769;
                } else {
                    /*
    * TODO: Removed the error report, since it got annoying to get an
    * extra error report, if anything failed until now.
    * Enable this if needed.
    *
    * xmlSchemaPErr(ctxt, type->node,
    *    XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
    *    "Simple type '%s' does not satisfy the constraints "
    *    "on simple type definitions.\n",
    *    type->name, NULL);
    */
    /*
    * Schema Component Constraint: Simple Type Restriction (Facets)
    * (st-restrict-facets)
    */
                    res = xmlSchemaCheckFacetValues(type_0, pctxt);
                    if res == -(1 as std::os::raw::c_int) {
                        current_block = 1308815063512225514;
                    } else if res != 0 as std::os::raw::c_int {
                        current_block = 14122743233969242769;
                    } else {
                        if !(*type_0).facetSet.is_null() ||
                               !(*(*type_0).baseType).facetSet.is_null() {
                            res =
                                xmlSchemaDeriveAndValidateFacets(pctxt,
                                                                 type_0);
                            if res == -(1 as std::os::raw::c_int) {
                                current_block = 1308815063512225514;
                            } else if res != 0 as std::os::raw::c_int {
                                current_block = 14122743233969242769;
                            } else { current_block = 4068382217303356765; }
                        } else { current_block = 4068382217303356765; }
                        match current_block {
                            14122743233969242769 => { }
                            1308815063512225514 => { }
                            _ => {
                                /*
    * Whitespace value.
    */
                                res = xmlSchemaTypeFixupWhitespace(type_0);
                                if res == -(1 as std::os::raw::c_int) {
                                    current_block = 1308815063512225514;
                                } else if res != 0 as std::os::raw::c_int {
                                    current_block = 14122743233969242769;
                                } else {
                                    xmlSchemaTypeFixupOptimFacets(type_0);
                                    current_block = 14122743233969242769;
                                }
                            }
                        }
                    }
                }
            }
            match current_block {
                1308815063512225514 => { }
                _ => {
                    if olderrs != (*pctxt).nberrors { return (*pctxt).err }
                    return 0 as std::os::raw::c_int
                }
            }
        }
    }
    return -(1 as std::os::raw::c_int);
}
unsafe extern "C" fn xmlSchemaFixupComplexType(mut pctxt:
                                                   xmlSchemaParserCtxtPtr,
                                               mut type_0: xmlSchemaTypePtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut res: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut olderrs: std::os::raw::c_int = (*pctxt).nberrors;
    let mut baseType: xmlSchemaTypePtr = (*type_0).baseType;
    if !((*type_0).type_0 as std::os::raw::c_uint !=
             XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
             (*type_0).flags & (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
                 0 as std::os::raw::c_int) {
        return 0 as std::os::raw::c_int
    }
    (*type_0).flags |= (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int;
    if baseType.is_null() {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaFixupComplexType\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"missing baseType\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    } else {
        /*
    * Fixup the base type.
    */
        if (*baseType).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*baseType).flags & (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
            xmlSchemaTypeFixup(baseType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (*baseType).flags & (1 as std::os::raw::c_int) << 23 as std::os::raw::c_int != 0 {
            /*
	* Skip fixup if the base type is invalid.
	* TODO: Generate a warning!
	*/
            return 0 as std::os::raw::c_int
        }
        /*
    * This basically checks if the base type can be derived.
    */
        res = xmlSchemaCheckSRCCT(pctxt, type_0);
        if !(res == -(1 as std::os::raw::c_int)) {
            if res != 0 as std::os::raw::c_int {
                current_block = 870511696101994442;
            } else {
                /*
    * Fixup the content type.
    */
                if (*type_0).contentType as std::os::raw::c_uint ==
                       XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as
                           std::os::raw::c_uint {
                    /*
	* Corresponds to <complexType><simpleContent>...
	*/
                    if ((*baseType).type_0 as std::os::raw::c_uint ==
                            XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as
                                std::os::raw::c_uint ||
                            (*baseType).builtInType ==
                                XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) &&
                           !(*baseType).contentTypeDef.is_null() &&
                           (*type_0).flags &
                               (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
                        let mut contentBase: xmlSchemaTypePtr =
                            0 as *mut xmlSchemaType;
                        let mut content: xmlSchemaTypePtr =
                            0 as *mut xmlSchemaType;
                        /*
	    * SPEC (1) If <restriction> + base type is <complexType>,
	    * "whose own {content type} is a simple type..."
	    */
                        if !(*type_0).contentTypeDef.is_null() {
                            /*
		* SPEC (1.1) "the simple type definition corresponding to the
		* <simpleType> among the [children] of <restriction> if there
		* is one;"
		* Note that this "<simpleType> among the [children]" was put
		* into ->contentTypeDef during parsing.
		*/
                            contentBase = (*type_0).contentTypeDef;
                            (*type_0).contentTypeDef = 0 as xmlSchemaTypePtr
                        } else {
                            /*
		* (1.2) "...otherwise (<restriction> has no <simpleType>
		* among its [children]), the simple type definition which
		* is the {content type} of the ... base type."
		*/
                            contentBase = (*baseType).contentTypeDef
                        }
                        /*
	    * SPEC
	    * "... a simple type definition which restricts the simple
	    * type definition identified in clause 1.1 or clause 1.2
	    * with a set of facet components"
	    *
	    * Create the anonymous simple type, which will be the content
	    * type of the complex type.
	    */
                        content =
                            xmlSchemaAddType(pctxt, (*pctxt).schema,
                                             XML_SCHEMA_TYPE_SIMPLE,
                                             0 as *const xmlChar,
                                             (*type_0).targetNamespace,
                                             (*type_0).node,
                                             0 as std::os::raw::c_int);
                        if content.is_null() {
                            current_block = 3637912971593881902;
                        } else {
                            /*
	    * We will use the same node as for the <complexType>
	    * to have it somehow anchored in the schema doc.
	    */
                            (*content).type_0 = XML_SCHEMA_TYPE_SIMPLE;
                            (*content).baseType = contentBase;
                            /*
	    * Move the facets, previously anchored on the
	    * complexType during parsing.
	    */
                            (*content).facets = (*type_0).facets;
                            (*type_0).facets = 0 as xmlSchemaFacetPtr;
                            (*content).facetSet = (*type_0).facetSet;
                            (*type_0).facetSet = 0 as xmlSchemaFacetLinkPtr;
                            (*type_0).contentTypeDef = content;
                            if (*contentBase).type_0 as std::os::raw::c_uint !=
                                   XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as
                                       std::os::raw::c_uint &&
                                   (*contentBase).flags &
                                       (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int
                                       == 0 as std::os::raw::c_int {
                                xmlSchemaTypeFixup(contentBase,
                                                   pctxt as
                                                       xmlSchemaAbstractCtxtPtr);
                            }
                            /*
	    * Fixup the newly created type. We don't need to check
	    * for circularity here.
	    */
                            res =
                                xmlSchemaFixupSimpleTypeStageOne(pctxt,
                                                                 content);
                            if res == -(1 as std::os::raw::c_int) {
                                current_block = 3637912971593881902;
                            } else if res != 0 as std::os::raw::c_int {
                                current_block = 870511696101994442;
                            } else {
                                res =
                                    xmlSchemaFixupSimpleTypeStageTwo(pctxt,
                                                                     content);
                                if res == -(1 as std::os::raw::c_int) {
                                    current_block = 3637912971593881902;
                                } else if res != 0 as std::os::raw::c_int {
                                    current_block = 870511696101994442;
                                } else {
                                    current_block = 5265702136860997526;
                                }
                            }
                        }
                    } else if ((*baseType).type_0 as std::os::raw::c_uint ==
                                   XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as
                                       std::os::raw::c_uint ||
                                   (*baseType).builtInType ==
                                       XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) &&
                                  (*baseType).contentType as std::os::raw::c_uint ==
                                      XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int
                                          as std::os::raw::c_uint &&
                                  (*type_0).flags &
                                      (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int
                                      != 0 {
                        /*
	    * SPEC (2) If <restriction> + base is a mixed <complexType> with
	    * an emptiable particle, then a simple type definition which
	    * restricts the <restriction>'s <simpleType> child.
	    */
                        if (*type_0).contentTypeDef.is_null() ||
                               (*(*type_0).contentTypeDef).baseType.is_null()
                           {
                            /*
		* TODO: Check if this ever happens.
		*/
                            xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_INTERNAL,
                                                type_0 as
                                                    xmlSchemaBasicItemPtr,
                                                0 as xmlNodePtr,
                                                b"Internal error: xmlSchemaTypeFixup, complex type \'%s\': the <simpleContent><restriction> is missing a <simpleType> child, but was not catched by xmlSchemaCheckSRCCT()\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char,
                                                (*type_0).name);
                            current_block = 3637912971593881902;
                        } else { current_block = 5265702136860997526; }
                    } else if ((*baseType).type_0 as std::os::raw::c_uint ==
                                   XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as
                                       std::os::raw::c_uint ||
                                   (*baseType).builtInType ==
                                       XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) &&
                                  (*type_0).flags &
                                      (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int
                                      != 0 {
                        /*
	    * SPEC (3) If <extension> + base is <complexType> with
	    * <simpleType> content, "...then the {content type} of that
	    * complex type definition"
	    */
                        if (*baseType).contentTypeDef.is_null() {
                            /*
		* TODO: Check if this ever happens. xmlSchemaCheckSRCCT
		* should have catched this already.
		*/
                            xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_INTERNAL,
                                                type_0 as
                                                    xmlSchemaBasicItemPtr,
                                                0 as xmlNodePtr,
                                                b"Internal error: xmlSchemaTypeFixup, complex type \'%s\': the <extension>ed base type is a complex type with no simple content type\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char,
                                                (*type_0).name);
                            current_block = 3637912971593881902;
                        } else {
                            (*type_0).contentTypeDef =
                                (*baseType).contentTypeDef;
                            current_block = 5265702136860997526;
                        }
                    } else if ((*baseType).type_0 as std::os::raw::c_uint ==
                                   XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as
                                       std::os::raw::c_uint ||
                                   (*baseType).type_0 as std::os::raw::c_uint ==
                                       XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as
                                           std::os::raw::c_uint &&
                                       (*baseType).builtInType !=
                                           XML_SCHEMAS_ANYTYPE as std::os::raw::c_int)
                                  &&
                                  (*type_0).flags &
                                      (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int
                                      != 0 {
                        /*
	    * SPEC (4) <extension> + base is <simpleType>
	    * "... then that simple type definition"
	    */
                        (*type_0).contentTypeDef = baseType;
                        current_block = 5265702136860997526;
                    } else {
                        /*
	    * TODO: Check if this ever happens.
	    */
                        xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_INTERNAL,
                                            type_0 as xmlSchemaBasicItemPtr,
                                            0 as xmlNodePtr,
                                            b"Internal error: xmlSchemaTypeFixup, complex type \'%s\' with <simpleContent>: unhandled derivation case\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            (*type_0).name);
                        current_block = 3637912971593881902;
                    }
                } else {
                    let mut dummySequence: std::os::raw::c_int = 0 as std::os::raw::c_int;
                    let mut particle: xmlSchemaParticlePtr =
                        (*type_0).subtypes as xmlSchemaParticlePtr;
                    /*
	* Corresponds to <complexType><complexContent>...
	*
	* NOTE that the effective mixed was already set during parsing of
	* <complexType> and <complexContent>; its flag value is
	* XML_SCHEMAS_TYPE_MIXED.
	*
	* Compute the "effective content":
	* (2.1.1) + (2.1.2) + (2.1.3)
	*/
                    if particle.is_null() ||
                           (*particle).type_0 as std::os::raw::c_uint ==
                               XML_SCHEMA_TYPE_PARTICLE as std::os::raw::c_int as
                                   std::os::raw::c_uint &&
                               ((*(*particle).children).type_0 as std::os::raw::c_uint
                                    ==
                                    XML_SCHEMA_TYPE_ALL as std::os::raw::c_int as
                                        std::os::raw::c_uint ||
                                    (*(*particle).children).type_0 as
                                        std::os::raw::c_uint ==
                                        XML_SCHEMA_TYPE_SEQUENCE as
                                            std::os::raw::c_int as std::os::raw::c_uint ||
                                    (*(*particle).children).type_0 as
                                        std::os::raw::c_uint ==
                                        XML_SCHEMA_TYPE_CHOICE as std::os::raw::c_int
                                            as std::os::raw::c_uint &&
                                        (*particle).minOccurs ==
                                            0 as std::os::raw::c_int) &&
                               (*(*particle).children).children.is_null() {
                        if (*type_0).flags &
                               (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 {
                            /*
		* SPEC (2.1.4) "If the `effective mixed` is true, then
		* a particle whose properties are as follows:..."
		*
		* Empty sequence model group with
		* minOccurs/maxOccurs = 1 (i.e. a "particle emptiable").
		* NOTE that we sill assign it the <complexType> node to
		* somehow anchor it in the doc.
		*/
                            if particle.is_null() ||
                                   (*(*particle).children).type_0 as
                                       std::os::raw::c_uint !=
                                       XML_SCHEMA_TYPE_SEQUENCE as std::os::raw::c_int
                                           as std::os::raw::c_uint {
                                /*
		    * Create the particle.
		    */
                                particle =
                                    xmlSchemaAddParticle(pctxt,
                                                         (*type_0).node,
                                                         1 as std::os::raw::c_int,
                                                         1 as std::os::raw::c_int);
                                if particle.is_null() {
                                    current_block = 3637912971593881902;
                                } else {
                                    /*
		    * Create the model group.
		    */
                                    /* URGENT TODO: avoid adding to pending items. */
                                    (*particle).children =
                                        xmlSchemaAddModelGroup(pctxt,
                                                               (*pctxt).schema,
                                                               XML_SCHEMA_TYPE_SEQUENCE,
                                                               (*type_0).node)
                                            as xmlSchemaTreeItemPtr;
                                    if (*particle).children.is_null() {
                                        current_block = 3637912971593881902;
                                    } else {
                                        (*type_0).subtypes =
                                            particle as xmlSchemaTypePtr;
                                        current_block = 17075014677070940716;
                                    }
                                }
                            } else { current_block = 17075014677070940716; }
                            match current_block {
                                3637912971593881902 => { }
                                _ => {
                                    dummySequence = 1 as std::os::raw::c_int;
                                    (*type_0).contentType =
                                        XML_SCHEMA_CONTENT_ELEMENTS;
                                    current_block = 4216521074440650966;
                                }
                            }
                        } else {
                            /*
		* SPEC (2.1.5) "otherwise empty"
		*/
                            (*type_0).contentType = XML_SCHEMA_CONTENT_EMPTY;
                            current_block = 4216521074440650966;
                        }
                    } else {
                        /*
	    * SPEC (2.2) "otherwise the particle corresponding to the
	    * <all>, <choice>, <group> or <sequence> among the
	    * [children]."
	    */
                        (*type_0).contentType = XML_SCHEMA_CONTENT_ELEMENTS;
                        current_block = 4216521074440650966;
                    }
                    match current_block {
                        3637912971593881902 => { }
                        _ =>
                        /*
	* Compute the "content type".
	*/
                        {
                            if (*type_0).flags &
                                   (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0
                               {
                                /*
	    * SPEC (3.1) "If <restriction>..."
	    * (3.1.1) + (3.1.2) */
                                if (*type_0).contentType as std::os::raw::c_uint !=
                                       XML_SCHEMA_CONTENT_EMPTY as std::os::raw::c_int
                                           as std::os::raw::c_uint {
                                    if (*type_0).flags &
                                           (1 as std::os::raw::c_int) <<
                                               0 as std::os::raw::c_int != 0 {
                                        (*type_0).contentType =
                                            XML_SCHEMA_CONTENT_MIXED
                                    }
                                }
                                current_block = 5265702136860997526;
                            } else if (*type_0).contentType as std::os::raw::c_uint ==
                                          XML_SCHEMA_CONTENT_EMPTY as
                                              std::os::raw::c_int as std::os::raw::c_uint {
                                /*
	    * SPEC (3.2) "If <extension>..."
	    */
                                /*
		* SPEC (3.2.1)
		* "If the `effective content` is empty, then the
		*  {content type} of the [...] base ..."
		*/
                                (*type_0).contentType =
                                    (*baseType).contentType;
                                (*type_0).subtypes = (*baseType).subtypes;
                                /*
		* NOTE that the effective mixed is ignored here.
		*/
                                (*type_0).contentTypeDef =
                                    (*baseType).contentTypeDef;
                                current_block = 5265702136860997526;
                            } else if (*baseType).contentType as std::os::raw::c_uint
                                          ==
                                          XML_SCHEMA_CONTENT_EMPTY as
                                              std::os::raw::c_int as std::os::raw::c_uint {
                                /*
		* Fixes bug #347316:
		* This is the case when the base type has a simple
		* type definition as content.
		*/
                                /*
		* SPEC (3.2.2)
		*/
                                if (*type_0).flags &
                                       (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
                                       != 0 {
                                    (*type_0).contentType =
                                        XML_SCHEMA_CONTENT_MIXED
                                }
                                current_block = 5265702136860997526;
                            } else {
                                /*
		* SPEC (3.2.3)
		*/
                                if (*type_0).flags &
                                       (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
                                       != 0 {
                                    (*type_0).contentType =
                                        XML_SCHEMA_CONTENT_MIXED
                                }
                                /*
		    * "A model group whose {compositor} is sequence and whose
		    * {particles} are..."
		    */
                                if !((*type_0).subtypes as
                                         xmlSchemaParticlePtr).is_null() &&
                                       !(*((*type_0).subtypes as
                                               xmlSchemaParticlePtr)).children.is_null()
                                       &&
                                       (*(*((*type_0).subtypes as
                                                xmlSchemaParticlePtr)).children).type_0
                                           as std::os::raw::c_uint ==
                                           XML_SCHEMA_TYPE_ALL as std::os::raw::c_int
                                               as std::os::raw::c_uint {
                                    /*
		    * SPEC cos-all-limited (1)
		    */
                                    xmlSchemaCustomErr(pctxt as
                                                           xmlSchemaAbstractCtxtPtr,
                                                       XML_SCHEMAP_COS_ALL_LIMITED,
                                                       xmlSchemaGetComponentNode(type_0
                                                                                     as
                                                                                     xmlSchemaBasicItemPtr),
                                                       0 as
                                                           xmlSchemaBasicItemPtr,
                                                       b"The type has an \'all\' model group in its {content type} and thus cannot be derived from a non-empty type, since this would produce a \'sequence\' model group containing the \'all\' model group; \'all\' model groups are not allowed to appear inside other model groups\x00"
                                                           as *const u8 as
                                                           *const std::os::raw::c_char,
                                                       0 as *const xmlChar,
                                                       0 as *const xmlChar);
                                    current_block = 5265702136860997526;
                                } else if !((*baseType).subtypes as
                                                xmlSchemaParticlePtr).is_null()
                                              &&
                                              !(*((*baseType).subtypes as
                                                      xmlSchemaParticlePtr)).children.is_null()
                                              &&
                                              (*(*((*baseType).subtypes as
                                                       xmlSchemaParticlePtr)).children).type_0
                                                  as std::os::raw::c_uint ==
                                                  XML_SCHEMA_TYPE_ALL as
                                                      std::os::raw::c_int as
                                                      std::os::raw::c_uint {
                                    /*
		    * SPEC cos-all-limited (1)
		    */
                                    xmlSchemaCustomErr(pctxt as
                                                           xmlSchemaAbstractCtxtPtr,
                                                       XML_SCHEMAP_COS_ALL_LIMITED,
                                                       xmlSchemaGetComponentNode(type_0
                                                                                     as
                                                                                     xmlSchemaBasicItemPtr),
                                                       0 as
                                                           xmlSchemaBasicItemPtr,
                                                       b"A type cannot be derived by extension from a type which has an \'all\' model group in its {content type}, since this would produce a \'sequence\' model group containing the \'all\' model group; \'all\' model groups are not allowed to appear inside other model groups\x00"
                                                           as *const u8 as
                                                           *const std::os::raw::c_char,
                                                       0 as *const xmlChar,
                                                       0 as *const xmlChar);
                                    current_block = 5265702136860997526;
                                } else if dummySequence == 0 {
                                    let mut effectiveContent:
                                            xmlSchemaTreeItemPtr =
                                        (*type_0).subtypes as
                                            xmlSchemaTreeItemPtr;
                                    /*
		    * This all will result in:
		    * new-particle
		    *   --> new-sequence(
		    *         new-particle
		    *           --> base-model,
		    *         this-particle
		    *	        --> this-model
		    *	    )
		    */
                                    /*
		    * Create the particle.
		    */
                                    particle =
                                        xmlSchemaAddParticle(pctxt,
                                                             (*type_0).node,
                                                             1 as std::os::raw::c_int,
                                                             1 as
                                                                 std::os::raw::c_int);
                                    if particle.is_null() {
                                        current_block = 3637912971593881902;
                                    } else {
                                        /*
		    * Create the "sequence" model group.
		    */
                                        (*particle).children =
                                            xmlSchemaAddModelGroup(pctxt,
                                                                   (*pctxt).schema,
                                                                   XML_SCHEMA_TYPE_SEQUENCE,
                                                                   (*type_0).node)
                                                as xmlSchemaTreeItemPtr;
                                        if (*particle).children.is_null() {
                                            current_block =
                                                3637912971593881902;
                                        } else {
                                            (*type_0).subtypes =
                                                particle as xmlSchemaTypePtr;
                                            /*
		    * SPEC "the particle of the {content type} of
		    * the ... base ..."
		    * Create a duplicate of the base type's particle
		    * and assign its "term" to it.
		    */
                                            (*(*particle).children).children =
                                                xmlSchemaAddParticle(pctxt,
                                                                     (*type_0).node,
                                                                     (*((*baseType).subtypes
                                                                            as
                                                                            xmlSchemaParticlePtr)).minOccurs,
                                                                     (*((*baseType).subtypes
                                                                            as
                                                                            xmlSchemaParticlePtr)).maxOccurs)
                                                    as xmlSchemaTreeItemPtr;
                                            if (*(*particle).children).children.is_null()
                                               {
                                                current_block =
                                                    3637912971593881902;
                                            } else {
                                                particle =
                                                    (*(*particle).children).children
                                                        as
                                                        xmlSchemaParticlePtr;
                                                (*particle).children =
                                                    (*((*baseType).subtypes as
                                                           xmlSchemaParticlePtr)).children;
                                                /*
		    * SPEC "followed by the `effective content`."
		    */
                                                (*particle).next =
                                                    effectiveContent;
                                                current_block =
                                                    5265702136860997526;
                                            }
                                        }
                                    }
                                } else {
                                    /*
		    * This is the case when there is already an empty
		    * <sequence> with minOccurs==maxOccurs==1.
		    * Just add the base types's content type.
		    * NOTE that, although we miss to add an intermediate
		    * <sequence>, this should produce no difference to
		    * neither the regex compilation of the content model,
		    * nor to the complex type contraints.
		    */
                                    (*(*particle).children).children =
                                        (*baseType).subtypes as
                                            xmlSchemaTreeItemPtr;
                                    current_block = 5265702136860997526;
                                }
                            }
                        }
                    }
                }
                match current_block {
                    3637912971593881902 => { }
                    870511696101994442 => { }
                    _ => {
                        /*
    * Now fixup attribute uses:
    *   - expand attr. group references
    *     - intersect attribute wildcards
    *   - inherit attribute uses of the base type
    *   - inherit or union attr. wildcards if extending
    *   - apply attr. use prohibitions if restricting
    */
                        res = xmlSchemaFixupTypeAttributeUses(pctxt, type_0);
                        if res == -(1 as std::os::raw::c_int) {
                            current_block = 3637912971593881902;
                        } else if res != 0 as std::os::raw::c_int {
                            current_block = 870511696101994442;
                        } else {
                            /*
    * Apply the complex type component constraints; this will not
    * check attributes, since this is done in
    * xmlSchemaFixupTypeAttributeUses().
    */
                            res = xmlSchemaCheckCTComponent(pctxt, type_0);
                            if res == -(1 as std::os::raw::c_int) {
                                current_block = 3637912971593881902;
                            } else if res != 0 as std::os::raw::c_int {
                                current_block = 870511696101994442;
                            } else if olderrs != (*pctxt).nberrors {
                                return (*pctxt).err
                            } else { return 0 as std::os::raw::c_int }
                        }
                    }
                }
            }
            match current_block {
                3637912971593881902 => { }
                _ => {
                    (*type_0).flags |=
                        (1 as std::os::raw::c_int) << 23 as std::os::raw::c_int;
                    return (*pctxt).err
                }
            }
        }
    }
    (*type_0).flags |= (1 as std::os::raw::c_int) << 23 as std::os::raw::c_int;
    return -(1 as std::os::raw::c_int);
}
/* *
 * xmlSchemaTypeFixup:
 * @typeDecl:  the schema type definition
 * @ctxt:  the schema parser context
 *
 * Fixes the content model of the type.
 * URGENT TODO: We need an int result!
 */
unsafe extern "C" fn xmlSchemaTypeFixup(mut type_0: xmlSchemaTypePtr,
                                        mut actxt: xmlSchemaAbstractCtxtPtr)
 -> std::os::raw::c_int {
    if type_0.is_null() { return 0 as std::os::raw::c_int }
    if (*actxt).type_0 != 1 as std::os::raw::c_int {
        xmlSchemaInternalErr(actxt,
                             b"xmlSchemaTypeFixup\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"this function needs a parser context\x00" as
                                 *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    if !((*type_0).type_0 as std::os::raw::c_uint !=
             XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
             (*type_0).flags & (1 as std::os::raw::c_int) << 22 as std::os::raw::c_int ==
                 0 as std::os::raw::c_int) {
        return 0 as std::os::raw::c_int
    }
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint {
        return xmlSchemaFixupComplexType(actxt as xmlSchemaParserCtxtPtr,
                                         type_0)
    } else {
        if (*type_0).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint {
            return xmlSchemaFixupSimpleTypeStageTwo(actxt as
                                                        xmlSchemaParserCtxtPtr,
                                                    type_0)
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckFacet:
 * @facet:  the facet
 * @typeDecl:  the schema type definition
 * @pctxt:  the schema parser context or NULL
 * @name: the optional name of the type
 *
 * Checks and computes the values of facets.
 *
 * Returns 0 if valid, a positive error code if not valid and
 *         -1 in case of an internal or API error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaCheckFacet(mut facet: xmlSchemaFacetPtr,
                                             mut typeDecl: xmlSchemaTypePtr,
                                             mut pctxt:
                                                 xmlSchemaParserCtxtPtr,
                                             mut name: *const xmlChar)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ctxtGiven: std::os::raw::c_int = 0;
    if facet.is_null() || typeDecl.is_null() { return -(1 as std::os::raw::c_int) }
    /*
    * TODO: will the parser context be given if used from
    * the relaxNG module?
    */
    if pctxt.is_null() {
        ctxtGiven = 0 as std::os::raw::c_int
    } else { ctxtGiven = 1 as std::os::raw::c_int }
    match (*facet).type_0 as std::os::raw::c_uint {
        1000 | 1001 | 1002 | 1003 | 1007 => {
            /*
                 * Okay we need to validate the value
                 * at that point.
                 */
            let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
            /* 4.3.5.5 Constraints on enumeration Schema Components
		* Schema Component Constraint: enumeration valid restriction
		* It is an `error` if any member of {value} is not in the
		* `value space` of {base type definition}.
		*
		* minInclusive, maxInclusive, minExclusive, maxExclusive:
		* The value `must` be in the
		* `value space` of the `base type`.
		*/
		/*
		* This function is intended to deliver a compiled value
		* on the facet. In this implementation of XML Schemata the
		* type holding a facet, won't be a built-in type.
		* Thus to ensure that other API
		* calls (relaxng) do work, if the given type is a built-in
		* type, we will assume that the given built-in type *is
		* already* the base type.
		*/
            if (*typeDecl).type_0 as std::os::raw::c_uint !=
                   XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
                base = (*typeDecl).baseType;
                if base.is_null() {
                    xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaCheckFacet\x00" as
                                             *const u8 as *const std::os::raw::c_char,
                                         b"a type user derived type has no base type\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    return -(1 as std::os::raw::c_int)
                }
            } else { base = typeDecl }
            if ctxtGiven == 0 {
                /*
		    * A context is needed if called from RelaxNG.
		    */
                pctxt =
                    xmlSchemaNewParserCtxt(b"*\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                if pctxt.is_null() { return -(1 as std::os::raw::c_int) }
            }
            /*
		* NOTE: This call does not check the content nodes,
		* since they are not available:
		* facet->node is just the node holding the facet
		* definition, *not* the attribute holding the *value*
		* of the facet.
		*/
            ret =
                xmlSchemaVCheckCVCSimpleType(pctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             (*facet).node, base,
                                             (*facet).value,
                                             &mut (*facet).val,
                                             1 as std::os::raw::c_int,
                                             1 as std::os::raw::c_int,
                                             0 as std::os::raw::c_int);
            if ret != 0 as std::os::raw::c_int {
                if ret < 0 as std::os::raw::c_int {
                    /* No error message for RelaxNG. */
                    if ctxtGiven != 0 {
                        xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                           XML_SCHEMAP_INTERNAL,
                                           (*facet).node,
                                           0 as xmlSchemaBasicItemPtr,
                                           b"Internal error: xmlSchemaCheckFacet, failed to validate the value \'%s\' of the facet \'%s\' against the base type\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           (*facet).value,
                                           xmlSchemaFacetTypeToString((*facet).type_0));
                    }
                    current_block = 279179736996436794;
                } else {
                    ret = XML_SCHEMAP_INVALID_FACET_VALUE as std::os::raw::c_int;
                    /* No error message for RelaxNG. */
                    if ctxtGiven != 0 {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                           ret as xmlParserErrors,
                                           (*facet).node,
                                           facet as xmlSchemaBasicItemPtr,
                                           b"The value \'%s\' of the facet does not validate against the base type \'%s\'\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           (*facet).value,
                                           xmlSchemaFormatQName(&mut str,
                                                                (*base).targetNamespace,
                                                                (*base).name));
                        if !str.is_null() {
                            xmlFree.expect("non-null function pointer")(str as
                                                                            *mut std::os::raw::c_void);
                            str = 0 as *mut xmlChar
                        }
                    }
                    current_block = 16490050146900870347;
                }
            } else {
                if (*facet).val.is_null() {
                    if ctxtGiven != 0 {
                        xmlSchemaInternalErr(pctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             b"xmlSchemaCheckFacet\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"value was not computed\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char);
                    }
                    (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                               b"Unimplemented block at %s:%d\n\x00"
                                                                                   as
                                                                                   *const u8
                                                                                   as
                                                                                   *const std::os::raw::c_char,
                                                                               b"xmlschemas.c\x00"
                                                                                   as
                                                                                   *const u8
                                                                                   as
                                                                                   *const std::os::raw::c_char,
                                                                               18779
                                                                                   as
                                                                                   std::os::raw::c_int);
                }
                current_block = 16490050146900870347;
            }
        }
        1006 => {
            (*facet).regexp = xmlRegexpCompile((*facet).value);
            if (*facet).regexp.is_null() {
                ret = XML_SCHEMAP_REGEXP_INVALID as std::os::raw::c_int;
                /* No error message for RelaxNG. */
                if ctxtGiven != 0 {
                    xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                       ret as xmlParserErrors, (*facet).node,
                                       typeDecl as xmlSchemaBasicItemPtr,
                                       b"The value \'%s\' of the facet \'pattern\' is not a valid regular expression\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       (*facet).value, 0 as *const xmlChar);
                }
            }
            current_block = 16490050146900870347;
        }
        1004 | 1005 | 1009 | 1010 | 1011 => {
            if (*facet).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_FACET_TOTALDIGITS as std::os::raw::c_int as std::os::raw::c_uint
               {
                ret =
                    xmlSchemaValidatePredefinedType(xmlSchemaGetBuiltInType(XML_SCHEMAS_PINTEGER),
                                                    (*facet).value,
                                                    &mut (*facet).val)
            } else {
                ret =
                    xmlSchemaValidatePredefinedType(xmlSchemaGetBuiltInType(XML_SCHEMAS_NNINTEGER),
                                                    (*facet).value,
                                                    &mut (*facet).val)
            }
            if ret != 0 as std::os::raw::c_int {
                if ret < 0 as std::os::raw::c_int {
                    /* No error message for RelaxNG. */
                    if ctxtGiven != 0 {
                        xmlSchemaInternalErr(pctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             b"xmlSchemaCheckFacet\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"validating facet value\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char);
                    }
                    current_block = 279179736996436794;
                } else {
                    ret = XML_SCHEMAP_INVALID_FACET_VALUE as std::os::raw::c_int;
                    /* No error message for RelaxNG. */
                    if ctxtGiven != 0 {
                        /* error code */
                        xmlSchemaCustomErr4(pctxt as xmlSchemaAbstractCtxtPtr,
                                            ret as xmlParserErrors,
                                            (*facet).node,
                                            typeDecl as xmlSchemaBasicItemPtr,
                                            b"The value \'%s\' of the facet \'%s\' is not a valid \'%s\'\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            (*facet).value,
                                            xmlSchemaFacetTypeToString((*facet).type_0),
                                            if (*facet).type_0 as std::os::raw::c_uint
                                                   !=
                                                   XML_SCHEMA_FACET_TOTALDIGITS
                                                       as std::os::raw::c_int as
                                                       std::os::raw::c_uint {
                                                b"nonNegativeInteger\x00" as
                                                    *const u8 as
                                                    *const std::os::raw::c_char as
                                                    *mut xmlChar
                                            } else {
                                                b"positiveInteger\x00" as
                                                    *const u8 as
                                                    *const std::os::raw::c_char as
                                                    *mut xmlChar
                                            }, 0 as *const xmlChar);
                    }
                    current_block = 16490050146900870347;
                }
            } else { current_block = 16490050146900870347; }
        }
        1008 => {
            if xmlStrEqual((*facet).value,
                           b"preserve\x00" as *const u8 as *const std::os::raw::c_char
                               as *mut xmlChar) != 0 {
                (*facet).whitespace = 1 as std::os::raw::c_int
            } else if xmlStrEqual((*facet).value,
                                  b"replace\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                (*facet).whitespace = 2 as std::os::raw::c_int
            } else if xmlStrEqual((*facet).value,
                                  b"collapse\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                (*facet).whitespace = 3 as std::os::raw::c_int
            } else {
                ret = XML_SCHEMAP_INVALID_FACET_VALUE as std::os::raw::c_int;
                /* No error message for RelaxNG. */
                if ctxtGiven != 0 {
                    /* error was previously: XML_SCHEMAP_INVALID_WHITE_SPACE */
                    xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                       ret as xmlParserErrors, (*facet).node,
                                       typeDecl as xmlSchemaBasicItemPtr,
                                       b"The value \'%s\' of the facet \'whitespace\' is not valid\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       (*facet).value, 0 as *const xmlChar);
                }
            }
            current_block = 16490050146900870347;
        }
        _ => { current_block = 16490050146900870347; }
    }
    match current_block {
        279179736996436794 => {
            if ctxtGiven == 0 && !pctxt.is_null() {
                xmlSchemaFreeParserCtxt(pctxt);
            }
            return -(1 as std::os::raw::c_int)
        }
        _ => {
            if ctxtGiven == 0 && !pctxt.is_null() {
                xmlSchemaFreeParserCtxt(pctxt);
            }
            return ret
        }
    };
}
/* *
 * xmlSchemaCheckFacetValues:
 * @typeDecl:  the schema type definition
 * @ctxt:  the schema parser context
 *
 * Checks the default values types, especially for facets
 */
unsafe extern "C" fn xmlSchemaCheckFacetValues(mut typeDecl: xmlSchemaTypePtr,
                                               mut pctxt:
                                                   xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut res: std::os::raw::c_int = 0;
    let mut olderrs: std::os::raw::c_int = (*pctxt).nberrors;
    let mut name: *const xmlChar = (*typeDecl).name;
    /*
    * NOTE: It is intended to use the facets list, instead
    * of facetSet.
    */
    if !(*typeDecl).facets.is_null() {
        let mut facet: xmlSchemaFacetPtr = (*typeDecl).facets;
        /*
	* Temporarily assign the "schema" to the validation context
	* of the parser context. This is needed for NOTATION validation.
	*/
        if (*pctxt).vctxt.is_null() {
            if xmlSchemaCreateVCtxtOnPCtxt(pctxt) == -(1 as std::os::raw::c_int) {
                return -(1 as std::os::raw::c_int)
            }
        }
        (*(*pctxt).vctxt).schema = (*pctxt).schema;
        loop  {
            if facet.is_null() {
                current_block = 7746791466490516765;
                break ;
            }
            res = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);
            if res == -(1 as std::os::raw::c_int) {
                current_block = 14713457856600425205;
                break ;
            }
            facet = (*facet).next
        }
        match current_block {
            14713457856600425205 => { return -(1 as std::os::raw::c_int) }
            _ => { (*(*pctxt).vctxt).schema = 0 as xmlSchemaPtr }
        }
    }
    if olderrs != (*pctxt).nberrors { return (*pctxt).err }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaGetCircModelGrDefRef:
 * @ctxtMGroup: the searched model group
 * @selfMGroup: the second searched model group
 * @particle: the first particle
 *
 * This one is intended to be used by
 * xmlSchemaCheckGroupDefCircular only.
 *
 * Returns the particle with the circular model group definition reference,
 * otherwise NULL.
 */
unsafe extern "C" fn xmlSchemaGetCircModelGrDefRef(mut groupDef:
                                                       xmlSchemaModelGroupDefPtr,
                                                   mut particle:
                                                       xmlSchemaTreeItemPtr)
 -> xmlSchemaTreeItemPtr {
    let mut circ: xmlSchemaTreeItemPtr = 0 as xmlSchemaTreeItemPtr;
    let mut term: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut gdef: xmlSchemaModelGroupDefPtr =
        0 as *mut xmlSchemaModelGroupDef;
    let mut current_block_13: u64;
    while !particle.is_null() {
        term = (*particle).children;
        if !term.is_null() {
            match (*term).type_0 as std::os::raw::c_uint {
                17 => {
                    current_block_13 = 9239236894132582812;
                    match current_block_13 {
                        2521863248840851667 => {
                            circ =
                                xmlSchemaGetCircModelGrDefRef(groupDef,
                                                              (*term).children);
                            if !circ.is_null() { return circ }
                        }
                        _ => {
                            gdef = term as xmlSchemaModelGroupDefPtr;
                            if gdef == groupDef { return particle }
                            /*
		* Mark this model group definition to avoid infinite
		* recursion on circular references not yet examined.
		*/
                            if !((*gdef).flags &
                                     (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int !=
                                     0) {
                                if !(*gdef).children.is_null() {
                                    (*gdef).flags |=
                                        (1 as std::os::raw::c_int) <<
                                            0 as std::os::raw::c_int;
                                    circ =
                                        xmlSchemaGetCircModelGrDefRef(groupDef,
                                                                      (*(*gdef).children).children);
                                    (*gdef).flags ^=
                                        (1 as std::os::raw::c_int) <<
                                            0 as std::os::raw::c_int;
                                    if !circ.is_null() { return circ }
                                }
                            }
                        }
                    }
                }
                6 | 7 | 8 => {
                    current_block_13 = 2521863248840851667;
                    match current_block_13 {
                        2521863248840851667 => {
                            circ =
                                xmlSchemaGetCircModelGrDefRef(groupDef,
                                                              (*term).children);
                            if !circ.is_null() { return circ }
                        }
                        _ => {
                            gdef = term as xmlSchemaModelGroupDefPtr;
                            if gdef == groupDef { return particle }
                            if !((*gdef).flags &
                                     (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int !=
                                     0) {
                                if !(*gdef).children.is_null() {
                                    (*gdef).flags |=
                                        (1 as std::os::raw::c_int) <<
                                            0 as std::os::raw::c_int;
                                    circ =
                                        xmlSchemaGetCircModelGrDefRef(groupDef,
                                                                      (*(*gdef).children).children);
                                    (*gdef).flags ^=
                                        (1 as std::os::raw::c_int) <<
                                            0 as std::os::raw::c_int;
                                    if !circ.is_null() { return circ }
                                }
                            }
                        }
                    }
                }
                _ => { }
            }
        }
        particle = (*particle).next
    }
    return 0 as xmlSchemaTreeItemPtr;
}
/* *
 * xmlSchemaCheckGroupDefCircular:
 * @item:  the model group definition
 * @ctxt:  the parser context
 * @name:  the name
 *
 * Checks for circular references to model group definitions.
 */
unsafe extern "C" fn xmlSchemaCheckGroupDefCircular(mut item:
                                                        xmlSchemaModelGroupDefPtr,
                                                    mut ctxt:
                                                        xmlSchemaParserCtxtPtr) {
    /*
    * Schema Component Constraint: Model Group Correct
    * 2 Circular groups are disallowed. That is, within the {particles}
    * of a group there must not be at any depth a particle whose {term}
    * is the group itself.
    */
    if item.is_null() ||
           (*item).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_TYPE_GROUP as std::os::raw::c_int as std::os::raw::c_uint ||
           (*item).children.is_null() {
        return
    }
    let mut circ: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    circ = xmlSchemaGetCircModelGrDefRef(item, (*(*item).children).children);
    if !circ.is_null() {
        let mut str: *mut xmlChar = 0 as *mut xmlChar;
        /*
	    * TODO: The error report is not adequate: this constraint
	    * is defined for model groups but not definitions, but since
	    * there cannot be any circular model groups without a model group
	    * definition (if not using a construction API), we check those
	    * defintions only.
	    */
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_MG_PROPS_CORRECT_2,
                            0 as xmlSchemaBasicItemPtr,
                            xmlSchemaGetComponentNode(circ as
                                                          xmlSchemaBasicItemPtr),
                            b"Circular reference to the model group definition \'%s\' defined\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            xmlSchemaFormatQName(&mut str,
                                                 (*item).targetNamespace,
                                                 (*item).name));
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as
                                                            *mut std::os::raw::c_void);
            str = 0 as *mut xmlChar
        }
        /*
	    * NOTE: We will cut the reference to avoid further
	    * confusion of the processor. This is a fatal error.
	    */
        (*circ).children = 0 as xmlSchemaTreeItemPtr
    };
}
/* *
 * xmlSchemaModelGroupToModelGroupDefFixup:
 * @ctxt:  the parser context
 * @mg:  the model group
 *
 * Assigns the model group of model group definitions to the "term"
 * of the referencing particle.
 * In xmlSchemaResolveModelGroupParticleReferences the model group
 * definitions were assigned to the "term", since needed for the
 * circularity check.
 *
 * Schema Component Constraint:
 *     All Group Limited (cos-all-limited) (1.2)
 */
unsafe extern "C" fn xmlSchemaModelGroupToModelGroupDefFixup(mut ctxt:
                                                                 xmlSchemaParserCtxtPtr,
                                                             mut mg:
                                                                 xmlSchemaModelGroupPtr) {
    let mut particle: xmlSchemaParticlePtr =
        (*mg).children as xmlSchemaParticlePtr;
    while !particle.is_null() {
        if (*particle).children.is_null() ||
               (*(*particle).children).type_0 as std::os::raw::c_uint !=
                   XML_SCHEMA_TYPE_GROUP as std::os::raw::c_int as std::os::raw::c_uint {
            particle = (*particle).next as xmlSchemaParticlePtr
        } else if (*((*particle).children as
                         xmlSchemaModelGroupPtr)).children.is_null() {
            /*
	    * TODO: Remove the particle.
	    */
            (*particle).children = 0 as xmlSchemaTreeItemPtr;
            particle = (*particle).next as xmlSchemaParticlePtr
        } else {
            /*
	* Assign the model group to the {term} of the particle.
	*/
            (*particle).children =
                (*((*particle).children as xmlSchemaModelGroupPtr)).children;
            particle = (*particle).next as xmlSchemaParticlePtr
        }
    };
}
/* *
 * xmlSchemaCheckAttrGroupCircularRecur:
 * @ctxtGr: the searched attribute group
 * @attr: the current attribute list to be processed
 *
 * This one is intended to be used by
 * xmlSchemaCheckAttrGroupCircular only.
 *
 * Returns the circular attribute grou reference, otherwise NULL.
 */
unsafe extern "C" fn xmlSchemaCheckAttrGroupCircularRecur(mut ctxtGr:
                                                              xmlSchemaAttributeGroupPtr,
                                                          mut list:
                                                              xmlSchemaItemListPtr)
 -> xmlSchemaQNameRefPtr {
    let mut gr: xmlSchemaAttributeGroupPtr =
        0 as *mut xmlSchemaAttributeGroup;
    let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut circ: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut i: std::os::raw::c_int = 0;
    /*
    * We will search for an attribute group reference which
    * references the context attribute group.
    */
    i = 0 as std::os::raw::c_int;
    while i < (*list).nbItems {
        ref_0 = *(*list).items.offset(i as isize) as xmlSchemaQNameRefPtr;
        if (*ref_0).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_EXTRA_QNAMEREF as std::os::raw::c_int as std::os::raw::c_uint &&
               (*ref_0).itemType as std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_ATTRIBUTEGROUP as std::os::raw::c_int as
                       std::os::raw::c_uint && !(*ref_0).item.is_null() {
            gr = (*ref_0).item as xmlSchemaAttributeGroupPtr;
            if gr == ctxtGr { return ref_0 }
            if !((*gr).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0) {
                /*
	    * Mark as visited to avoid infinite recursion on
	    * circular references not yet examined.
	    */
                if !(*gr).attrUses.is_null() &&
                       (*gr).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int !=
                           0 {
                    (*gr).flags |= (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int;
                    circ =
                        xmlSchemaCheckAttrGroupCircularRecur(ctxtGr,
                                                             (*gr).attrUses as
                                                                 xmlSchemaItemListPtr);
                    (*gr).flags ^= (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int;
                    if !circ.is_null() { return circ }
                }
            }
        }
        i += 1
    }
    return 0 as xmlSchemaQNameRefPtr;
}
/* *
 * xmlSchemaCheckAttrGroupCircular:
 * attrGr:  the attribute group definition
 * @ctxt:  the parser context
 * @name:  the name
 *
 * Checks for circular references of attribute groups.
 */
unsafe extern "C" fn xmlSchemaCheckAttrGroupCircular(mut attrGr:
                                                         xmlSchemaAttributeGroupPtr,
                                                     mut ctxt:
                                                         xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    /*
    * Schema Representation Constraint:
    * Attribute Group Definition Representation OK
    * 3 Circular group reference is disallowed outside <redefine>.
    * That is, unless this element information item's parent is
    * <redefine>, then among the [children], if any, there must
    * not be an <attributeGroup> with ref [attribute] which resolves
    * to the component corresponding to this <attributeGroup>. Indirect
    * circularity is also ruled out. That is, when QName resolution
    * (Schema Document) ($3.15.3) is applied to a `QName` arising from
    * any <attributeGroup>s with a ref [attribute] among the [children],
    * it must not be the case that a `QName` is encountered at any depth
    * which resolves to the component corresponding to this <attributeGroup>.
    */
    if (*attrGr).attrUses.is_null() {
        return 0 as std::os::raw::c_int
    } else {
        if (*attrGr).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int ==
               0 as std::os::raw::c_int {
            return 0 as std::os::raw::c_int
        } else {
            let mut circ: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
            circ =
                xmlSchemaCheckAttrGroupCircularRecur(attrGr,
                                                     (*attrGr).attrUses as
                                                         xmlSchemaItemListPtr);
            if !circ.is_null() {
                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                /*
	    * TODO: Report the referenced attr group as QName.
	    */
                xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3,
                                    0 as xmlSchemaBasicItemPtr,
                                    xmlSchemaGetComponentNode(circ as
                                                                  xmlSchemaBasicItemPtr),
                                    b"Circular reference to the attribute group \'%s\' defined\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    xmlSchemaGetComponentQName(&mut str,
                                                               attrGr as
                                                                   *mut std::os::raw::c_void));
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                /*
	    * NOTE: We will cut the reference to avoid further
	    * confusion of the processor.
	    * BADSPEC TODO: The spec should define how to process in this case.
	    */
                (*circ).item = 0 as xmlSchemaBasicItemPtr;
                return (*ctxt).err
            }
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaExpandAttributeGroupRefs:
 * @pctxt: the parser context
 * @node: the node of the component holding the attribute uses
 * @completeWild: the intersected wildcard to be returned
 * @list: the attribute uses
 *
 * Substitutes contained attribute group references
 * for their attribute uses. Wilcards are intersected.
 * Attribute use prohibitions are removed from the list
 * and returned via the @prohibs list.
 * Pointlessness of attr. prohibs, if a matching attr. decl
 * is existent a well, are checked.
 */
unsafe extern "C" fn xmlSchemaExpandAttributeGroupRefs(mut pctxt:
                                                           xmlSchemaParserCtxtPtr,
                                                       mut item:
                                                           xmlSchemaBasicItemPtr,
                                                       mut completeWild:
                                                           *mut xmlSchemaWildcardPtr,
                                                       mut list:
                                                           xmlSchemaItemListPtr,
                                                       mut prohibs:
                                                           xmlSchemaItemListPtr)
 -> std::os::raw::c_int {
    let mut gr: xmlSchemaAttributeGroupPtr =
        0 as *mut xmlSchemaAttributeGroup;
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut sublist: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut created: std::os::raw::c_int =
        if (*completeWild).is_null() {
            0 as std::os::raw::c_int
        } else { 1 as std::os::raw::c_int };
    if !prohibs.is_null() { (*prohibs).nbItems = 0 as std::os::raw::c_int }
    i = 0 as std::os::raw::c_int;
    while i < (*list).nbItems {
        use_0 = *(*list).items.offset(i as isize) as xmlSchemaAttributeUsePtr;
        if (*use_0).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as std::os::raw::c_int as std::os::raw::c_uint
           {
            if prohibs.is_null() {
                xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaExpandAttributeGroupRefs\x00"
                                         as *const u8 as *const std::os::raw::c_char,
                                     b"unexpected attr prohibition found\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            /*
	    * Remove from attribute uses.
	    */
            if xmlSchemaItemListRemove(list, i) == -(1 as std::os::raw::c_int) {
                return -(1 as std::os::raw::c_int)
            }
            i -= 1;
            /*
	    * Note that duplicate prohibitions were already
	    * handled at parsing time.
	    */
	    /*
	    * Add to list of prohibitions.
	    */
            xmlSchemaItemListAddSize(prohibs, 2 as std::os::raw::c_int,
                                     use_0 as *mut std::os::raw::c_void);
        } else if (*use_0).type_0 as std::os::raw::c_uint ==
                      XML_SCHEMA_EXTRA_QNAMEREF as std::os::raw::c_int as std::os::raw::c_uint
                      &&
                      (*(use_0 as xmlSchemaQNameRefPtr)).itemType as
                          std::os::raw::c_uint ==
                          XML_SCHEMA_TYPE_ATTRIBUTEGROUP as std::os::raw::c_int as
                              std::os::raw::c_uint {
            if (*(use_0 as xmlSchemaQNameRefPtr)).item.is_null() {
                return -(1 as std::os::raw::c_int)
            }
            gr =
                (*(use_0 as xmlSchemaQNameRefPtr)).item as
                    xmlSchemaAttributeGroupPtr;
            /*
	    * Expand the referenced attr. group.
	    * TODO: remove this, this is done in a previous step, so
	    * already done here.
	    */
            if (*gr).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
                if xmlSchemaAttributeGroupExpandRefs(pctxt, gr) ==
                       -(1 as std::os::raw::c_int) {
                    return -(1 as std::os::raw::c_int)
                }
            }
            /*
	    * Build the 'complete' wildcard; i.e. intersect multiple
	    * wildcards.
	    */
            if !(*gr).attributeWildcard.is_null() {
                if (*completeWild).is_null() {
                    *completeWild = (*gr).attributeWildcard
                } else {
                    if created == 0 {
                        let mut tmpWild: xmlSchemaWildcardPtr =
                            0 as *mut xmlSchemaWildcard;
                        /*
			* Copy the first encountered wildcard as context,
			* except for the annotation.
			*
			* Although the complete wildcard might not correspond
			* to any node in the schema, we will anchor it on
			* the node of the owner component.
			*/
                        tmpWild =
                            xmlSchemaAddWildcard(pctxt, (*pctxt).schema,
                                                 XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
                                                 xmlSchemaGetComponentNode(item));
                        if tmpWild.is_null() { return -(1 as std::os::raw::c_int) }
                        if xmlSchemaCloneWildcardNsConstraints(pctxt, tmpWild,
                                                               *completeWild)
                               == -(1 as std::os::raw::c_int) {
                            return -(1 as std::os::raw::c_int)
                        }
                        (*tmpWild).processContents =
                            (**completeWild).processContents;
                        *completeWild = tmpWild;
                        created = 1 as std::os::raw::c_int
                    }
                    if xmlSchemaIntersectWildcards(pctxt, *completeWild,
                                                   (*gr).attributeWildcard) ==
                           -(1 as std::os::raw::c_int) {
                        return -(1 as std::os::raw::c_int)
                    }
                }
            }
            /*
	    * Just remove the reference if the referenced group does not
	    * contain any attribute uses.
	    */
            sublist = (*gr).attrUses as xmlSchemaItemListPtr;
            if sublist.is_null() || (*sublist).nbItems == 0 as std::os::raw::c_int {
                if xmlSchemaItemListRemove(list, i) == -(1 as std::os::raw::c_int) {
                    return -(1 as std::os::raw::c_int)
                }
                i -= 1
            } else {
                /*
	    * Add the attribute uses.
	    */
                let ref mut fresh19 = *(*list).items.offset(i as isize);
                *fresh19 =
                    *(*sublist).items.offset(0 as std::os::raw::c_int as isize);
                if (*sublist).nbItems != 1 as std::os::raw::c_int {
                    j = 1 as std::os::raw::c_int;
                    while j < (*sublist).nbItems {
                        i += 1;
                        if xmlSchemaItemListInsert(list,
                                                   *(*sublist).items.offset(j
                                                                                as
                                                                                isize),
                                                   i) == -(1 as std::os::raw::c_int) {
                            return -(1 as std::os::raw::c_int)
                        }
                        j += 1
                    }
                }
            }
        }
        i += 1
    }
    /*
    * Handle pointless prohibitions of declared attributes.
    */
    if !prohibs.is_null() && (*prohibs).nbItems != 0 as std::os::raw::c_int &&
           (*list).nbItems != 0 as std::os::raw::c_int {
        let mut prohib: xmlSchemaAttributeUseProhibPtr =
            0 as *mut xmlSchemaAttributeUseProhib;
        i = (*prohibs).nbItems - 1 as std::os::raw::c_int;
        while i >= 0 as std::os::raw::c_int {
            prohib =
                *(*prohibs).items.offset(i as isize) as
                    xmlSchemaAttributeUseProhibPtr;
            j = 0 as std::os::raw::c_int;
            while j < (*list).nbItems {
                use_0 =
                    *(*list).items.offset(j as isize) as
                        xmlSchemaAttributeUsePtr;
                if (*prohib).name == (*(*use_0).attrDecl).name &&
                       (*prohib).targetNamespace ==
                           (*(*use_0).attrDecl).targetNamespace {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomWarning(pctxt as xmlSchemaAbstractCtxtPtr,
                                           XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                                           (*prohib).node,
                                           0 as xmlSchemaTypePtr,
                                           b"Skipping pointless attribute use prohibition \'%s\', since a corresponding attribute use exists already in the type definition\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlSchemaFormatQName(&mut str,
                                                                (*prohib).targetNamespace,
                                                                (*prohib).name),
                                           0 as *const xmlChar,
                                           0 as *const xmlChar);
                    if !str.is_null() {
                        xmlFree.expect("non-null function pointer")(str as
                                                                        *mut std::os::raw::c_void);
                        str = 0 as *mut xmlChar
                    }
                    /*
		    * Remove the prohibition.
		    */
                    if xmlSchemaItemListRemove(prohibs, i) ==
                           -(1 as std::os::raw::c_int) {
                        return -(1 as std::os::raw::c_int)
                    }
                    break ;
                } else { j += 1 }
            }
            i -= 1
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaAttributeGroupExpandRefs:
 * @pctxt:  the parser context
 * @attrGr:  the attribute group definition
 *
 * Computation of:
 * {attribute uses} property
 * {attribute wildcard} property
 *
 * Substitutes contained attribute group references
 * for their attribute uses. Wilcards are intersected.
 */
unsafe extern "C" fn xmlSchemaAttributeGroupExpandRefs(mut pctxt:
                                                           xmlSchemaParserCtxtPtr,
                                                       mut attrGr:
                                                           xmlSchemaAttributeGroupPtr)
 -> std::os::raw::c_int {
    if (*attrGr).attrUses.is_null() ||
           (*attrGr).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 {
        return 0 as std::os::raw::c_int
    }
    (*attrGr).flags |= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int;
    if xmlSchemaExpandAttributeGroupRefs(pctxt,
                                         attrGr as xmlSchemaBasicItemPtr,
                                         &mut (*attrGr).attributeWildcard,
                                         (*attrGr).attrUses as
                                             xmlSchemaItemListPtr,
                                         0 as xmlSchemaItemListPtr) ==
           -(1 as std::os::raw::c_int) {
        return -(1 as std::os::raw::c_int)
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaAttributeGroupExpandRefs:
 * @pctxt:  the parser context
 * @attrGr:  the attribute group definition
 *
 * Substitutes contained attribute group references
 * for their attribute uses. Wilcards are intersected.
 *
 * Schema Component Constraint:
 *    Attribute Group Definition Properties Correct (ag-props-correct)
 */
unsafe extern "C" fn xmlSchemaCheckAGPropsCorrect(mut pctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut attrGr:
                                                      xmlSchemaAttributeGroupPtr)
 -> std::os::raw::c_int {
    /*
    * SPEC ag-props-correct
    * (1) "The values of the properties of an attribute group definition
    * must be as described in the property tableau in The Attribute
    * Group Definition Schema Component ($3.6.1), modulo the impact of
    * Missing Sub-components ($5.3);"
    */
    if !(*attrGr).attrUses.is_null() &&
           (*((*attrGr).attrUses as xmlSchemaItemListPtr)).nbItems >
               1 as std::os::raw::c_int {
        let mut uses: xmlSchemaItemListPtr =
            (*attrGr).attrUses as xmlSchemaItemListPtr;
        let mut use_0: xmlSchemaAttributeUsePtr =
            0 as *mut xmlSchemaAttributeUse;
        let mut tmp: xmlSchemaAttributeUsePtr =
            0 as *mut xmlSchemaAttributeUse;
        let mut i: std::os::raw::c_int = 0;
        let mut j: std::os::raw::c_int = 0;
        let mut hasId: std::os::raw::c_int = 0 as std::os::raw::c_int;
        i = (*uses).nbItems - 1 as std::os::raw::c_int;
        while i >= 0 as std::os::raw::c_int {
            let mut current_block_27: u64;
            use_0 =
                *(*uses).items.offset(i as isize) as xmlSchemaAttributeUsePtr;
            /*
	    * SPEC ag-props-correct
	    * (2) "Two distinct members of the {attribute uses} must not have
	    * {attribute declaration}s both of whose {name}s match and whose
	    * {target namespace}s are identical."
	    */
            if i > 0 as std::os::raw::c_int {
                j = i - 1 as std::os::raw::c_int;
                loop  {
                    if !(j >= 0 as std::os::raw::c_int) {
                        current_block_27 = 12124785117276362961;
                        break ;
                    }
                    tmp =
                        *(*uses).items.offset(j as isize) as
                            xmlSchemaAttributeUsePtr;
                    if (*(*use_0).attrDecl).name == (*(*tmp).attrDecl).name &&
                           (*(*use_0).attrDecl).targetNamespace ==
                               (*(*tmp).attrDecl).targetNamespace {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                           XML_SCHEMAP_AG_PROPS_CORRECT,
                                           (*attrGr).node,
                                           attrGr as xmlSchemaBasicItemPtr,
                                           b"Duplicate %s\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlSchemaGetComponentDesignation(&mut str,
                                                                            use_0
                                                                                as
                                                                                *mut std::os::raw::c_void),
                                           0 as *const xmlChar);
                        if !str.is_null() {
                            xmlFree.expect("non-null function pointer")(str as
                                                                            *mut std::os::raw::c_void);
                            str = 0 as *mut xmlChar
                        }
                        /*
			* Remove the duplicate.
			*/
                        if xmlSchemaItemListRemove(uses, i) ==
                               -(1 as std::os::raw::c_int) {
                            return -(1 as std::os::raw::c_int)
                        }
                        current_block_27 = 7245201122033322888;
                        break ;
                    } else { j -= 1 }
                }
            } else { current_block_27 = 12124785117276362961; }
            match current_block_27 {
                12124785117276362961 => {
                    /*
	    * SPEC ag-props-correct
	    * (3) "Two distinct members of the {attribute uses} must not have
	    * {attribute declaration}s both of whose {type definition}s are or
	    * are derived from ID."
	    * TODO: Does 'derived' include member-types of unions?
	    */
                    if !(*(*use_0).attrDecl).subtypes.is_null() {
                        if xmlSchemaIsDerivedFromBuiltInType((*(*use_0).attrDecl).subtypes,
                                                             XML_SCHEMAS_ID as
                                                                 std::os::raw::c_int)
                               != 0 {
                            if hasId != 0 {
                                let mut str_0: *mut xmlChar =
                                    0 as *mut xmlChar;
                                xmlSchemaCustomErr(pctxt as
                                                       xmlSchemaAbstractCtxtPtr,
                                                   XML_SCHEMAP_AG_PROPS_CORRECT,
                                                   (*attrGr).node,
                                                   attrGr as
                                                       xmlSchemaBasicItemPtr,
                                                   b"There must not exist more than one attribute declaration of type \'xs:ID\' (or derived from \'xs:ID\'). The %s violates this constraint\x00"
                                                       as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   xmlSchemaGetComponentDesignation(&mut str_0,
                                                                                    use_0
                                                                                        as
                                                                                        *mut std::os::raw::c_void),
                                                   0 as *const xmlChar);
                                if !str_0.is_null() {
                                    xmlFree.expect("non-null function pointer")(str_0
                                                                                    as
                                                                                    *mut std::os::raw::c_void);
                                    str_0 = 0 as *mut xmlChar
                                }
                                if xmlSchemaItemListRemove(uses, i) ==
                                       -(1 as std::os::raw::c_int) {
                                    return -(1 as std::os::raw::c_int)
                                }
                            }
                            hasId = 1 as std::os::raw::c_int
                        }
                    }
                }
                _ => { }
            }
            i -= 1
        }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaResolveAttrGroupReferences:
 * @attrgrpDecl:  the schema attribute definition
 * @ctxt:  the schema parser context
 * @name:  the attribute name
 *
 * Resolves references to attribute group definitions.
 */
unsafe extern "C" fn xmlSchemaResolveAttrGroupReferences(mut ref_0:
                                                             xmlSchemaQNameRefPtr,
                                                         mut ctxt:
                                                             xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut group: xmlSchemaAttributeGroupPtr =
        0 as *mut xmlSchemaAttributeGroup;
    if !(*ref_0).item.is_null() { return 0 as std::os::raw::c_int }
    group =
        xmlSchemaGetAttributeGroup((*ctxt).schema, (*ref_0).name,
                                   (*ref_0).targetNamespace);
    if group.is_null() {
        xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
                                 0 as xmlSchemaBasicItemPtr, (*ref_0).node,
                                 b"ref\x00" as *const u8 as
                                     *const std::os::raw::c_char, (*ref_0).name,
                                 (*ref_0).targetNamespace, (*ref_0).itemType,
                                 0 as *const std::os::raw::c_char);
        return (*ctxt).err
    }
    (*ref_0).item = group as xmlSchemaBasicItemPtr;
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckAttrPropsCorrect:
 * @item:  an schema attribute declaration/use
 * @ctxt:  a schema parser context
 * @name:  the name of the attribute
 *
 *
 * Schema Component Constraint:
 *    Attribute Declaration Properties Correct (a-props-correct)
 *
 * Validates the value constraints of an attribute declaration/use.
 * NOTE that this needs the simle type definitions to be already
 *   builded and checked.
 */
unsafe extern "C" fn xmlSchemaCheckAttrPropsCorrect(mut pctxt:
                                                        xmlSchemaParserCtxtPtr,
                                                    mut attr:
                                                        xmlSchemaAttributePtr)
 -> std::os::raw::c_int {
    /*
    * SPEC a-props-correct (1)
    * "The values of the properties of an attribute declaration must
    * be as described in the property tableau in The Attribute
    * Declaration Schema Component ($3.2.1), modulo the impact of
    * Missing Sub-components ($5.3)."
    */
    if (*attr).subtypes.is_null() { return 0 as std::os::raw::c_int }
    if !(*attr).defValue.is_null() {
        let mut ret: std::os::raw::c_int = 0;
        /*
	* SPEC a-props-correct (3)
	* "If the {type definition} is or is derived from ID then there
	* must not be a {value constraint}."
	*/
        if xmlSchemaIsDerivedFromBuiltInType((*attr).subtypes,
                                             XML_SCHEMAS_ID as std::os::raw::c_int) !=
               0 {
            xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAP_A_PROPS_CORRECT_3, 0 as xmlNodePtr,
                               attr as xmlSchemaBasicItemPtr,
                               b"Value constraints are not allowed if the type definition is or is derived from xs:ID\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               0 as *const xmlChar, 0 as *const xmlChar);
            return (*pctxt).err
        }
        /*
	* SPEC a-props-correct (2)
	* "if there is a {value constraint}, the canonical lexical
	* representation of its value must be `valid` with respect
	* to the {type definition} as defined in String Valid ($3.14.4)."
	* TODO: Don't care about the *canonical* stuff here, this requirement
	* will be removed in WXS 1.1 anyway.
	*/
        ret =
            xmlSchemaVCheckCVCSimpleType(pctxt as xmlSchemaAbstractCtxtPtr,
                                         (*attr).node, (*attr).subtypes,
                                         (*attr).defValue,
                                         &mut (*attr).defVal,
                                         1 as std::os::raw::c_int, 1 as std::os::raw::c_int,
                                         0 as std::os::raw::c_int);
        if ret != 0 as std::os::raw::c_int {
            if ret < 0 as std::os::raw::c_int {
                xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaCheckAttrPropsCorrect\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"calling xmlSchemaVCheckCVCSimpleType()\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAP_A_PROPS_CORRECT_2, 0 as xmlNodePtr,
                               attr as xmlSchemaBasicItemPtr,
                               b"The value of the value constraint is not valid\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               0 as *const xmlChar, 0 as *const xmlChar);
            return (*pctxt).err
        }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaCheckSubstGroupCircular(mut elemDecl:
                                                          xmlSchemaElementPtr,
                                                      mut ancestor:
                                                          xmlSchemaElementPtr)
 -> xmlSchemaElementPtr {
    let mut ret: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    if (*ancestor).refDecl.is_null() { return 0 as xmlSchemaElementPtr }
    if (*ancestor).refDecl == elemDecl { return ancestor }
    if (*(*ancestor).refDecl).flags & (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int
           != 0 {
        return 0 as xmlSchemaElementPtr
    }
    (*(*ancestor).refDecl).flags |= (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int;
    ret = xmlSchemaCheckSubstGroupCircular(elemDecl, (*ancestor).refDecl);
    (*(*ancestor).refDecl).flags ^= (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int;
    return ret;
}
/* *
 * xmlSchemaCheckElemPropsCorrect:
 * @ctxt:  a schema parser context
 * @decl: the element declaration
 * @name:  the name of the attribute
 *
 * Schema Component Constraint:
 * Element Declaration Properties Correct (e-props-correct)
 *
 * STATUS:
 *   missing: (6)
 */
unsafe extern "C" fn xmlSchemaCheckElemPropsCorrect(mut pctxt:
                                                        xmlSchemaParserCtxtPtr,
                                                    mut elemDecl:
                                                        xmlSchemaElementPtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut typeDef: xmlSchemaTypePtr = (*elemDecl).subtypes;
    /*
    * SPEC (1) "The values of the properties of an element declaration
    * must be as described in the property tableau in The Element
    * Declaration Schema Component ($3.3.1), modulo the impact of Missing
    * Sub-components ($5.3)."
    */
    if !(*elemDecl).refDecl.is_null() {
        let mut head: xmlSchemaElementPtr = (*elemDecl).refDecl;
        let mut circ: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
        xmlSchemaCheckElementDeclComponent(head, pctxt);
        /*
	* SPEC (3) "If there is a non-`absent` {substitution group
	* affiliation}, then {scope} must be global."
	*/
        if (*elemDecl).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int ==
               0 as std::os::raw::c_int {
            xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_E_PROPS_CORRECT_3,
                                elemDecl as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"Only global element declarations can have a substitution group affiliation\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as *const xmlChar);
            ret = XML_SCHEMAP_E_PROPS_CORRECT_3 as std::os::raw::c_int
        }
        /*
	* TODO: SPEC (6) "Circular substitution groups are disallowed.
	* That is, it must not be possible to return to an element declaration
	* by repeatedly following the {substitution group affiliation}
	* property."
	*/
        if head == elemDecl {
            circ = head
        } else if !(*head).refDecl.is_null() {
            circ = xmlSchemaCheckSubstGroupCircular(head, head)
        } else { circ = 0 as xmlSchemaElementPtr }
        if !circ.is_null() {
            let mut strA: *mut xmlChar = 0 as *mut xmlChar;
            let mut strB: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaPCustomErrExt(pctxt, XML_SCHEMAP_E_PROPS_CORRECT_6,
                                   circ as xmlSchemaBasicItemPtr,
                                   0 as xmlNodePtr,
                                   b"The element declaration \'%s\' defines a circular substitution group to element declaration \'%s\'\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlSchemaGetComponentQName(&mut strA,
                                                              circ as
                                                                  *mut std::os::raw::c_void),
                                   xmlSchemaGetComponentQName(&mut strB,
                                                              head as
                                                                  *mut std::os::raw::c_void),
                                   0 as *const xmlChar);
            if !strA.is_null() {
                xmlFree.expect("non-null function pointer")(strA as
                                                                *mut std::os::raw::c_void);
                strA = 0 as *mut xmlChar
            }
            if !strB.is_null() {
                xmlFree.expect("non-null function pointer")(strB as
                                                                *mut std::os::raw::c_void);
                strB = 0 as *mut xmlChar
            }
            ret = XML_SCHEMAP_E_PROPS_CORRECT_6 as std::os::raw::c_int
        }
        /*
	* SPEC (4) "If there is a {substitution group affiliation},
	* the {type definition}
	* of the element declaration must be validly derived from the {type
	* definition} of the {substitution group affiliation}, given the value
	* of the {substitution group exclusions} of the {substitution group
	* affiliation}, as defined in Type Derivation OK (Complex) ($3.4.6)
	* (if the {type definition} is complex) or as defined in
	* Type Derivation OK (Simple) ($3.14.6) (if the {type definition} is
	* simple)."
	*
	* NOTE: {substitution group exclusions} means the values of the
	* attribute "final".
	*/
        if typeDef != (*(*elemDecl).refDecl).subtypes {
            let mut set: std::os::raw::c_int = 0 as std::os::raw::c_int;
            if (*head).flags & (1 as std::os::raw::c_int) << 15 as std::os::raw::c_int != 0 {
                set |= (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int
            }
            if (*head).flags & (1 as std::os::raw::c_int) << 16 as std::os::raw::c_int != 0 {
                set |= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
            }
            if xmlSchemaCheckCOSDerivedOK(pctxt as xmlSchemaAbstractCtxtPtr,
                                          typeDef, (*head).subtypes, set) !=
                   0 as std::os::raw::c_int {
                let mut strA_0: *mut xmlChar = 0 as *mut xmlChar;
                let mut strB_0: *mut xmlChar = 0 as *mut xmlChar;
                let mut strC: *mut xmlChar = 0 as *mut xmlChar;
                ret = XML_SCHEMAP_E_PROPS_CORRECT_4 as std::os::raw::c_int;
                xmlSchemaPCustomErrExt(pctxt, XML_SCHEMAP_E_PROPS_CORRECT_4,
                                       elemDecl as xmlSchemaBasicItemPtr,
                                       0 as xmlNodePtr,
                                       b"The type definition \'%s\' was either rejected by the substitution group affiliation \'%s\', or not validly derived from its type definition \'%s\'\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlSchemaGetComponentQName(&mut strA_0,
                                                                  typeDef as
                                                                      *mut std::os::raw::c_void),
                                       xmlSchemaGetComponentQName(&mut strB_0,
                                                                  head as
                                                                      *mut std::os::raw::c_void),
                                       xmlSchemaGetComponentQName(&mut strC,
                                                                  (*head).subtypes
                                                                      as
                                                                      *mut std::os::raw::c_void));
                if !strA_0.is_null() {
                    xmlFree.expect("non-null function pointer")(strA_0 as
                                                                    *mut std::os::raw::c_void);
                    strA_0 = 0 as *mut xmlChar
                }
                if !strB_0.is_null() {
                    xmlFree.expect("non-null function pointer")(strB_0 as
                                                                    *mut std::os::raw::c_void);
                    strB_0 = 0 as *mut xmlChar
                }
                if !strC.is_null() {
                    xmlFree.expect("non-null function pointer")(strC as
                                                                    *mut std::os::raw::c_void);
                    strC = 0 as *mut xmlChar
                }
            }
        }
    }
    /*
    * SPEC (5) "If the {type definition} or {type definition}'s
    * {content type}
    * is or is derived from ID then there must not be a {value constraint}.
    * Note: The use of ID as a type definition for elements goes beyond
    * XML 1.0, and should be avoided if backwards compatibility is desired"
    */
    if !(*elemDecl).value.is_null() &&
           (((*typeDef).type_0 as std::os::raw::c_uint ==
                 XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                 (*typeDef).type_0 as std::os::raw::c_uint ==
                     XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                     (*typeDef).builtInType !=
                         XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) &&
                xmlSchemaIsDerivedFromBuiltInType(typeDef,
                                                  XML_SCHEMAS_ID as
                                                      std::os::raw::c_int) != 0 ||
                ((*typeDef).type_0 as std::os::raw::c_uint ==
                     XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
                     (*typeDef).builtInType ==
                         XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) &&
                    ((*typeDef).contentType as std::os::raw::c_uint ==
                         XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as
                             std::os::raw::c_uint ||
                         (*typeDef).contentType as std::os::raw::c_uint ==
                             XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as
                                 std::os::raw::c_uint) &&
                    xmlSchemaIsDerivedFromBuiltInType((*typeDef).contentTypeDef,
                                                      XML_SCHEMAS_ID as
                                                          std::os::raw::c_int) != 0) {
        ret = XML_SCHEMAP_E_PROPS_CORRECT_5 as std::os::raw::c_int;
        xmlSchemaPCustomErr(pctxt, XML_SCHEMAP_E_PROPS_CORRECT_5,
                            elemDecl as xmlSchemaBasicItemPtr,
                            0 as xmlNodePtr,
                            b"The type definition (or type definition\'s content type) is or is derived from ID; value constraints are not allowed in conjunction with such a type definition\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
    } else if !(*elemDecl).value.is_null() {
        let mut vcret: std::os::raw::c_int = 0;
        let mut node: xmlNodePtr = 0 as xmlNodePtr;
        /*
	* SPEC (2) "If there is a {value constraint}, the canonical lexical
	* representation of its value must be `valid` with respect to the
	* {type definition} as defined in Element Default Valid (Immediate)
	* ($3.3.6)."
	*/
        if typeDef.is_null() {
            xmlSchemaPErr(pctxt, (*elemDecl).node,
                          XML_SCHEMAP_INTERNAL as std::os::raw::c_int,
                          b"Internal error: xmlSchemaCheckElemPropsCorrect, type is missing... skipping validation of the value constraint\x00"
                              as *const u8 as *const std::os::raw::c_char,
                          0 as *const xmlChar, 0 as *const xmlChar);
            return -(1 as std::os::raw::c_int)
        }
        if !(*elemDecl).node.is_null() {
            if (*elemDecl).flags & (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0
               {
                node =
                    xmlHasProp((*elemDecl).node as *const xmlNode,
                               b"fixed\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) as
                        xmlNodePtr
            } else {
                node =
                    xmlHasProp((*elemDecl).node as *const xmlNode,
                               b"default\x00" as *const u8 as
                                   *const std::os::raw::c_char as *mut xmlChar) as
                        xmlNodePtr
            }
        }
        vcret =
            xmlSchemaParseCheckCOSValidDefault(pctxt, node, typeDef,
                                               (*elemDecl).value,
                                               &mut (*elemDecl).defVal);
        if vcret != 0 as std::os::raw::c_int {
            if vcret < 0 as std::os::raw::c_int {
                xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaElemCheckValConstr\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"failed to validate the value constraint of an element declaration\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            return vcret
        }
    }
    return ret;
}
/* *
 * xmlSchemaCheckElemSubstGroup:
 * @ctxt:  a schema parser context
 * @decl: the element declaration
 * @name:  the name of the attribute
 *
 * Schema Component Constraint:
 * Substitution Group (cos-equiv-class)
 *
 * In Libxml2 the subst. groups will be precomputed, in terms of that
 * a list will be built for each subst. group head, holding all direct
 * referents to this head.
 * NOTE that this function needs:
 *   1. circular subst. groups to be checked beforehand
 *   2. the declaration's type to be derived from the head's type
 *
 * STATUS:
 *
 */
unsafe extern "C" fn xmlSchemaCheckElemSubstGroup(mut ctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut elemDecl:
                                                      xmlSchemaElementPtr) {
    if (*elemDecl).refDecl.is_null() ||
           (*elemDecl).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int != 0 {
        return
    }
    let mut head: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    let mut headType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut set: std::os::raw::c_int = 0;
    let mut methSet: std::os::raw::c_int = 0;
    let mut current_block_28: u64;
    /*
	* SPEC (2) "It is validly substitutable for HEAD subject to HEAD's
	* {disallowed substitutions} as the blocking constraint, as defined in
	* Substitution Group OK (Transitive) ($3.3.6)."
	*/
    head = (*elemDecl).refDecl;
    while !head.is_null() {
        set = 0 as std::os::raw::c_int;
        methSet = 0 as std::os::raw::c_int;
        /*
	    * The blocking constraints.
	    */
        if !((*head).flags & (1 as std::os::raw::c_int) << 13 as std::os::raw::c_int != 0) {
            headType = (*head).subtypes;
            type_0 = (*elemDecl).subtypes;
            if headType == type_0 {
                current_block_28 = 18327361199250901057;
            } else {
                if (*head).flags & (1 as std::os::raw::c_int) << 12 as std::os::raw::c_int !=
                       0 {
                    set |= (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int
                }
                if (*head).flags & (1 as std::os::raw::c_int) << 11 as std::os::raw::c_int !=
                       0 {
                    set |= (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int
                }
                /*
	    * SPEC: Substitution Group OK (Transitive) (2.3)
	    * "The set of all {derivation method}s involved in the
	    * derivation of D's {type definition} from C's {type definition}
	    * does not intersect with the union of the blocking constraint,
	    * C's {prohibited substitutions} (if C is complex, otherwise the
	    * empty set) and the {prohibited substitutions} (respectively the
	    * empty set) of any intermediate {type definition}s in the
	    * derivation of D's {type definition} from C's {type definition}."
	    */
	    /*
	    * OPTIMIZE TODO: Optimize this a bit, since, if traversing the
	    * subst.head axis, the methSet does not need to be computed for
	    * the full depth over and over.
	    */
	    /*
	    * The set of all {derivation method}s involved in the derivation
	    */
                while !type_0.is_null() && type_0 != headType {
                    if (*type_0).flags &
                           (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 &&
                           methSet & (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int
                               == 0 as std::os::raw::c_int {
                        methSet |= (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int
                    }
                    if (*type_0).flags &
                           (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 &&
                           methSet & (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int
                               == 0 as std::os::raw::c_int {
                        methSet |= (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int
                    }
                    type_0 = (*type_0).baseType
                }
                /*
	    * The {prohibited substitutions} of all intermediate types +
	    * the head's type.
	    */
                type_0 = (*(*elemDecl).subtypes).baseType;
                while !type_0.is_null() {
                    if !((*type_0).type_0 as std::os::raw::c_uint ==
                             XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as
                                 std::os::raw::c_uint ||
                             (*type_0).builtInType ==
                                 XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
                        break ;
                    }
                    if (*type_0).flags &
                           (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int != 0 &&
                           set & (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                        set |= (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int
                    }
                    if (*type_0).flags &
                           (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int != 0 &&
                           set & (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                        set |= (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int
                    }
                    if type_0 == headType { break ; }
                    type_0 = (*type_0).baseType
                }
                if set != 0 as std::os::raw::c_int &&
                       (set & (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int != 0 &&
                            methSet & (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int
                                != 0 ||
                            set & (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int != 0
                                &&
                                methSet &
                                    (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int !=
                                    0) {
                    current_block_28 = 735147466149431745;
                } else { current_block_28 = 18327361199250901057; }
            }
            match current_block_28 {
                735147466149431745 => { }
                _ => {
                    xmlSchemaAddElementSubstitutionMember(ctxt, head,
                                                          elemDecl);
                    if (*head).flags & (1 as std::os::raw::c_int) << 17 as std::os::raw::c_int
                           == 0 as std::os::raw::c_int {
                        (*head).flags |=
                            (1 as std::os::raw::c_int) << 17 as std::os::raw::c_int
                    }
                }
            }
        }
        head = (*head).refDecl
    };
}
/* enable when finished */
/* *
 * xmlSchemaCheckElementDeclComponent
 * @item:  an schema element declaration/particle
 * @ctxt:  a schema parser context
 * @name:  the name of the attribute
 *
 * Validates the value constraints of an element declaration.
 * Adds substitution group members.
 */
unsafe extern "C" fn xmlSchemaCheckElementDeclComponent(mut elemDecl:
                                                            xmlSchemaElementPtr,
                                                        mut ctxt:
                                                            xmlSchemaParserCtxtPtr) {
    if elemDecl.is_null() { return }
    if (*elemDecl).flags & (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int != 0 {
        return
    }
    (*elemDecl).flags |= (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int;
    if xmlSchemaCheckElemPropsCorrect(ctxt, elemDecl) == 0 as std::os::raw::c_int {
        /*
	* Adds substitution group members.
	*/
        xmlSchemaCheckElemSubstGroup(ctxt, elemDecl);
    };
}
/* *
 * xmlSchemaResolveModelGroupParticleReferences:
 * @particle:  a particle component
 * @ctxt:  a parser context
 *
 * Resolves references of a model group's {particles} to
 * model group definitions and to element declarations.
 */
unsafe extern "C" fn xmlSchemaResolveModelGroupParticleReferences(mut ctxt:
                                                                      xmlSchemaParserCtxtPtr,
                                                                  mut mg:
                                                                      xmlSchemaModelGroupPtr) {
    let mut particle: xmlSchemaParticlePtr =
        (*mg).children as xmlSchemaParticlePtr;
    let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut refItem: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    /*
    * URGENT TODO: Test this.
    */
    while !particle.is_null() {
        if !((*particle).children.is_null() ||
                 (*(*particle).children).type_0 as std::os::raw::c_uint !=
                     XML_SCHEMA_EXTRA_QNAMEREF as std::os::raw::c_int as std::os::raw::c_uint)
           {
            ref_0 = (*particle).children as xmlSchemaQNameRefPtr;
            /*
	* Resolve the reference.
	* NULL the {term} by default.
	*/
            (*particle).children = 0 as xmlSchemaTreeItemPtr;
            refItem =
                xmlSchemaGetNamedComponent((*ctxt).schema, (*ref_0).itemType,
                                           (*ref_0).name,
                                           (*ref_0).targetNamespace);
            if refItem.is_null() {
                xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
                                         0 as xmlSchemaBasicItemPtr,
                                         xmlSchemaGetComponentNode(particle as
                                                                       xmlSchemaBasicItemPtr),
                                         b"ref\x00" as *const u8 as
                                             *const std::os::raw::c_char,
                                         (*ref_0).name,
                                         (*ref_0).targetNamespace,
                                         (*ref_0).itemType,
                                         0 as *const std::os::raw::c_char);
            } else if (*refItem).type_0 as std::os::raw::c_uint ==
                          XML_SCHEMA_TYPE_GROUP as std::os::raw::c_int as std::os::raw::c_uint
             {
                if !(*(refItem as xmlSchemaModelGroupPtr)).children.is_null()
                   {
                    /*
	    * NOTE that we will assign the model group definition
	    * itself to the "term" of the particle. This will ease
	    * the check for circular model group definitions. After
	    * that the "term" will be assigned the model group of the
	    * model group definition.
	    */
                    if (*(*(refItem as
                                xmlSchemaModelGroupPtr)).children).type_0 as
                           std::os::raw::c_uint ==
                           XML_SCHEMA_TYPE_ALL as std::os::raw::c_int as std::os::raw::c_uint
                       {
                        /*
		* SPEC cos-all-limited (1)
		* SPEC cos-all-limited (1.2)
		* "It appears only as the value of one or both of the
		* following properties:"
		* (1.1) "the {model group} property of a model group
		*        definition."
		* (1.2) "the {term} property of a particle [... of] the "
		* {content type} of a complex type definition."
		*/
                        xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                                           XML_SCHEMAP_COS_ALL_LIMITED,
                                           xmlSchemaGetComponentNode(particle
                                                                         as
                                                                         xmlSchemaBasicItemPtr),
                                           0 as xmlSchemaBasicItemPtr,
                                           b"A model group definition is referenced, but it contains an \'all\' model group, which cannot be contained by model groups\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           0 as *const xmlChar,
                                           0 as *const xmlChar);
                    } else {
                        (*particle).children = refItem as xmlSchemaTreeItemPtr
                    }
                }
            } else {
                /*
	    * TODO: Are referenced element declarations the only
	    * other components we expect here?
	    */
                (*particle).children = refItem as xmlSchemaTreeItemPtr
            }
        }
        /* TODO: remove the particle. */
        particle = (*particle).next as xmlSchemaParticlePtr
    };
}
unsafe extern "C" fn xmlSchemaAreValuesEqual(mut x: xmlSchemaValPtr,
                                             mut y: xmlSchemaValPtr)
 -> std::os::raw::c_int {
    let mut tx: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ty: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ptx: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut pty: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ret: std::os::raw::c_int = 0;
    while !x.is_null() {
        /* Same types. */
        tx = xmlSchemaGetBuiltInType(xmlSchemaGetValType(x));
        ty = xmlSchemaGetBuiltInType(xmlSchemaGetValType(y));
        ptx = xmlSchemaGetPrimitiveType(tx);
        pty = xmlSchemaGetPrimitiveType(ty);
        /*
	* (1) if a datatype T' is `derived` by `restriction` from an
	* atomic datatype T then the `value space` of T' is a subset of
	* the `value space` of T. */
	/*
	* (2) if datatypes T' and T'' are `derived` by `restriction`
	* from a common atomic ancestor T then the `value space`s of T'
	* and T'' may overlap.
	*/
        if ptx != pty { return 0 as std::os::raw::c_int }
        /*
	* We assume computed values to be normalized, so do a fast
	* string comparison for string based types.
	*/
        if (*ptx).builtInType == XML_SCHEMAS_STRING as std::os::raw::c_int ||
               (*ptx).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                   (*ptx).builtInType ==
                       XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int {
            if xmlStrEqual(xmlSchemaValueGetAsString(x),
                           xmlSchemaValueGetAsString(y)) == 0 {
                return 0 as std::os::raw::c_int
            }
        } else {
            ret =
                xmlSchemaCompareValuesWhtsp(x, XML_SCHEMA_WHITESPACE_PRESERVE,
                                            y,
                                            XML_SCHEMA_WHITESPACE_PRESERVE);
            if ret == -(2 as std::os::raw::c_int) { return -(1 as std::os::raw::c_int) }
            if ret != 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
        }
        /*
	* Lists.
	*/
        x = xmlSchemaValueGetNext(x);
        if !x.is_null() {
            y = xmlSchemaValueGetNext(y);
            if y.is_null() { return 0 as std::os::raw::c_int }
        } else if !xmlSchemaValueGetNext(y).is_null() {
            return 0 as std::os::raw::c_int
        } else { return 1 as std::os::raw::c_int }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaResolveAttrUseReferences:
 * @item:  an attribute use
 * @ctxt:  a parser context
 *
 * Resolves the referenced attribute declaration.
 */
unsafe extern "C" fn xmlSchemaResolveAttrUseReferences(mut ause:
                                                           xmlSchemaAttributeUsePtr,
                                                       mut ctxt:
                                                           xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    if ctxt.is_null() || ause.is_null() { return -(1 as std::os::raw::c_int) }
    if (*ause).attrDecl.is_null() ||
           (*(*ause).attrDecl).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_EXTRA_QNAMEREF as std::os::raw::c_int as std::os::raw::c_uint {
        return 0 as std::os::raw::c_int
    }
    let mut ref_0: xmlSchemaQNameRefPtr =
        (*ause).attrDecl as xmlSchemaQNameRefPtr;
    /*
	* TODO: Evaluate, what errors could occur if the declaration is not
	* found.
	*/
    (*ause).attrDecl =
        xmlSchemaGetAttributeDecl((*ctxt).schema, (*ref_0).name,
                                  (*ref_0).targetNamespace);
    if (*ause).attrDecl.is_null() {
        xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
                                 ause as xmlSchemaBasicItemPtr, (*ause).node,
                                 b"ref\x00" as *const u8 as
                                     *const std::os::raw::c_char, (*ref_0).name,
                                 (*ref_0).targetNamespace,
                                 XML_SCHEMA_TYPE_ATTRIBUTE,
                                 0 as *const std::os::raw::c_char);
        return (*ctxt).err
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaCheckAttrUsePropsCorrect:
 * @ctxt:  a parser context
 * @use:  an attribute use
 *
 * Schema Component Constraint:
 * Attribute Use Correct (au-props-correct)
 *
 */
unsafe extern "C" fn xmlSchemaCheckAttrUsePropsCorrect(mut ctxt:
                                                           xmlSchemaParserCtxtPtr,
                                                       mut use_0:
                                                           xmlSchemaAttributeUsePtr)
 -> std::os::raw::c_int {
    if ctxt.is_null() || use_0.is_null() { return -(1 as std::os::raw::c_int) }
    if (*use_0).defValue.is_null() || (*use_0).attrDecl.is_null() ||
           (*(*use_0).attrDecl).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_TYPE_ATTRIBUTE as std::os::raw::c_int as std::os::raw::c_uint {
        return 0 as std::os::raw::c_int
    }
    /*
    * SPEC au-props-correct (1)
    * "The values of the properties of an attribute use must be as
    * described in the property tableau in The Attribute Use Schema
    * Component ($3.5.1), modulo the impact of Missing
    * Sub-components ($5.3)."
    */
    if !(*(*use_0).attrDecl).defValue.is_null() &&
           (*(*use_0).attrDecl).flags & (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int
               != 0 &&
           (*use_0).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int ==
               0 as std::os::raw::c_int {
        xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_AU_PROPS_CORRECT_2,
                            use_0 as xmlSchemaBasicItemPtr, 0 as xmlNodePtr,
                            b"The attribute declaration has a \'fixed\' value constraint , thus the attribute use must also have a \'fixed\' value constraint\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as *const xmlChar);
        return (*ctxt).err
    }
    /*
    * Compute and check the value constraint's value.
    */
    if !(*use_0).defVal.is_null() && !(*(*use_0).attrDecl).subtypes.is_null()
       {
        let mut ret: std::os::raw::c_int = 0;
        /*
	* TODO: The spec seems to be missing a check of the
	* value constraint of the attribute use. We will do it here.
	*/
	/*
	* SPEC a-props-correct (3)
	*/
        if xmlSchemaIsDerivedFromBuiltInType((*(*use_0).attrDecl).subtypes,
                                             XML_SCHEMAS_ID as std::os::raw::c_int) !=
               0 {
            xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAP_AU_PROPS_CORRECT, 0 as xmlNodePtr,
                               use_0 as xmlSchemaBasicItemPtr,
                               b"Value constraints are not allowed if the type definition is or is derived from xs:ID\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               0 as *const xmlChar, 0 as *const xmlChar);
            return (*ctxt).err
        }
        ret =
            xmlSchemaVCheckCVCSimpleType(ctxt as xmlSchemaAbstractCtxtPtr,
                                         (*use_0).node,
                                         (*(*use_0).attrDecl).subtypes,
                                         (*use_0).defValue,
                                         &mut (*use_0).defVal,
                                         1 as std::os::raw::c_int, 1 as std::os::raw::c_int,
                                         0 as std::os::raw::c_int);
        if ret != 0 as std::os::raw::c_int {
            if ret < 0 as std::os::raw::c_int {
                xmlSchemaInternalErr(ctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaCheckAttrUsePropsCorrect\x00"
                                         as *const u8 as *const std::os::raw::c_char,
                                     b"calling xmlSchemaVCheckCVCSimpleType()\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAP_AU_PROPS_CORRECT, 0 as xmlNodePtr,
                               use_0 as xmlSchemaBasicItemPtr,
                               b"The value of the value constraint is not valid\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               0 as *const xmlChar, 0 as *const xmlChar);
            return (*ctxt).err
        }
    }
    /*
    * SPEC au-props-correct (2)
    * "If the {attribute declaration} has a fixed
    * {value constraint}, then if the attribute use itself has a
    * {value constraint}, it must also be fixed and its value must match
    * that of the {attribute declaration}'s {value constraint}."
    */
    if !(*(*use_0).attrDecl).defVal.is_null() &&
           (*(*use_0).attrDecl).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
               == 0 as std::os::raw::c_int {
        if xmlSchemaAreValuesEqual((*use_0).defVal,
                                   (*(*use_0).attrDecl).defVal) == 0 {
            xmlSchemaPCustomErr(ctxt, XML_SCHEMAP_AU_PROPS_CORRECT_2,
                                use_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"The \'fixed\' value constraint of the attribute use must match the attribute declaration\'s value constraint \'%s\'\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                (*(*use_0).attrDecl).defValue);
        }
        return (*ctxt).err
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaResolveAttrTypeReferences:
 * @item:  an attribute declaration
 * @ctxt:  a parser context
 *
 * Resolves the referenced type definition component.
 */
unsafe extern "C" fn xmlSchemaResolveAttrTypeReferences(mut item:
                                                            xmlSchemaAttributePtr,
                                                        mut ctxt:
                                                            xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    /*
    * The simple type definition corresponding to the <simpleType> element
    * information item in the [children], if present, otherwise the simple
    * type definition `resolved` to by the `actual value` of the type
    * [attribute], if present, otherwise the `simple ur-type definition`.
    */
    if (*item).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0 {
        return 0 as std::os::raw::c_int
    }
    (*item).flags |= (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int;
    if !(*item).subtypes.is_null() { return 0 as std::os::raw::c_int }
    if !(*item).typeName.is_null() {
        let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        type_0 =
            xmlSchemaGetType((*ctxt).schema, (*item).typeName,
                             (*item).typeNs);
        if type_0.is_null() ||
               !((*type_0).type_0 as std::os::raw::c_uint ==
                     XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                     (*type_0).type_0 as std::os::raw::c_uint ==
                         XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint
                         &&
                         (*type_0).builtInType !=
                             XML_SCHEMAS_ANYTYPE as std::os::raw::c_int) {
            xmlSchemaPResCompAttrErr(ctxt, XML_SCHEMAP_SRC_RESOLVE,
                                     item as xmlSchemaBasicItemPtr,
                                     (*item).node,
                                     b"type\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     (*item).typeName, (*item).typeNs,
                                     XML_SCHEMA_TYPE_SIMPLE,
                                     0 as *const std::os::raw::c_char);
            return (*ctxt).err
        } else { (*item).subtypes = type_0 }
    } else {
        /*
	* The type defaults to the xs:anySimpleType.
	*/
        (*item).subtypes = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE)
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaResolveIDCKeyReferences:
 * @idc:  the identity-constraint definition
 * @ctxt:  the schema parser context
 * @name:  the attribute name
 *
 * Resolve keyRef references to key/unique IDCs.
 * Schema Component Constraint:
 *   Identity-constraint Definition Properties Correct (c-props-correct)
 */
unsafe extern "C" fn xmlSchemaResolveIDCKeyReferences(mut idc:
                                                          xmlSchemaIDCPtr,
                                                      mut pctxt:
                                                          xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    if (*idc).type_0 as std::os::raw::c_uint !=
           XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int as std::os::raw::c_uint {
        return 0 as std::os::raw::c_int
    }
    if !(*(*idc).ref_0).name.is_null() {
        (*(*idc).ref_0).item =
            xmlSchemaGetIDC((*pctxt).schema, (*(*idc).ref_0).name,
                            (*(*idc).ref_0).targetNamespace) as
                xmlSchemaBasicItemPtr;
        if (*(*idc).ref_0).item.is_null() {
            /*
	    * TODO: It is actually not an error to fail to resolve
	    * at this stage. BUT we need to be that strict!
	    */
            xmlSchemaPResCompAttrErr(pctxt, XML_SCHEMAP_SRC_RESOLVE,
                                     idc as xmlSchemaBasicItemPtr,
                                     (*idc).node,
                                     b"refer\x00" as *const u8 as
                                         *const std::os::raw::c_char,
                                     (*(*idc).ref_0).name,
                                     (*(*idc).ref_0).targetNamespace,
                                     XML_SCHEMA_TYPE_IDC_KEY,
                                     0 as *const std::os::raw::c_char);
            return (*pctxt).err
        } else {
            if (*(*(*idc).ref_0).item).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int as std::os::raw::c_uint {
                /*
	    * SPEC c-props-correct (1)
	    */
                xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                   XML_SCHEMAP_C_PROPS_CORRECT,
                                   0 as xmlNodePtr,
                                   idc as xmlSchemaBasicItemPtr,
                                   b"The keyref references a keyref\x00" as
                                       *const u8 as *const std::os::raw::c_char,
                                   0 as *const xmlChar, 0 as *const xmlChar);
                (*(*idc).ref_0).item = 0 as xmlSchemaBasicItemPtr;
                return (*pctxt).err
            } else {
                if (*idc).nbFields !=
                       (*((*(*idc).ref_0).item as xmlSchemaIDCPtr)).nbFields {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    let mut refer: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
                    refer = (*(*idc).ref_0).item as xmlSchemaIDCPtr;
                    /*
		* SPEC c-props-correct(2)
		* "If the {identity-constraint category} is keyref,
		* the cardinality of the {fields} must equal that of
		* the {fields} of the {referenced key}.
		*/
                    xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAP_C_PROPS_CORRECT,
                                       0 as xmlNodePtr,
                                       idc as xmlSchemaBasicItemPtr,
                                       b"The cardinality of the keyref differs from the cardinality of the referenced key/unique \'%s\'\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlSchemaFormatQName(&mut str,
                                                            (*refer).targetNamespace,
                                                            (*refer).name),
                                       0 as *const xmlChar);
                    if !str.is_null() {
                        xmlFree.expect("non-null function pointer")(str as
                                                                        *mut std::os::raw::c_void);
                        str = 0 as *mut xmlChar
                    }
                    return (*pctxt).err
                }
            }
        }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaResolveAttrUseProhibReferences(mut prohib:
                                                                 xmlSchemaAttributeUseProhibPtr,
                                                             mut pctxt:
                                                                 xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    if xmlSchemaGetAttributeDecl((*pctxt).schema, (*prohib).name,
                                 (*prohib).targetNamespace).is_null() {
        xmlSchemaPResCompAttrErr(pctxt, XML_SCHEMAP_SRC_RESOLVE,
                                 0 as xmlSchemaBasicItemPtr, (*prohib).node,
                                 b"ref\x00" as *const u8 as
                                     *const std::os::raw::c_char, (*prohib).name,
                                 (*prohib).targetNamespace,
                                 XML_SCHEMA_TYPE_ATTRIBUTE,
                                 0 as *const std::os::raw::c_char);
        return XML_SCHEMAP_SRC_RESOLVE as std::os::raw::c_int
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaCheckSRCRedefineFirst(mut pctxt:
                                                        xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut err: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut redef: xmlSchemaRedefPtr = (*(*pctxt).constructor).redefs;
    let mut prev: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut item: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut wasRedefined: std::os::raw::c_int = 0;
    if redef.is_null() { return 0 as std::os::raw::c_int }
    loop  {
        item = (*redef).item;
        /*
	* First try to locate the redefined component in the
	* schema graph starting with the redefined schema.
	* NOTE: According to this schema bug entry:
	*   http://lists.w3.org/Archives/Public/www-xml-schema-comments/2005OctDec/0019.html
	*   it's not clear if the referenced component needs to originate
	*   from the <redefine>d schema _document_ or the schema; the latter
	*   would include all imported and included sub-schemas of the
	*   <redefine>d schema. Currenlty we latter approach is used.
	*   SUPPLEMENT: It seems that the WG moves towards the latter
	*   approach, so we are doing it right.
	*
	*/
        prev =
            xmlSchemaFindRedefCompInGraph((*redef).targetBucket,
                                          (*item).type_0, (*redef).refName,
                                          (*redef).refTargetNs);
        if prev.is_null() {
            let mut str: *mut xmlChar = 0 as *mut xmlChar;
            let mut node: xmlNodePtr = 0 as *mut xmlNode;
            /*
	    * SPEC src-redefine:
	    * (6.2.1) "The `actual value` of its own name attribute plus
	    * target namespace must successfully `resolve` to a model
	    * group definition in I."
	    * (7.2.1) "The `actual value` of its own name attribute plus
	    * target namespace must successfully `resolve` to an attribute
	    * group definition in I."

	    *
	    * Note that, if we are redefining with the use of references
	    * to components, the spec assumes the src-resolve to be used;
	    * but this won't assure that we search only *inside* the
	    * redefined schema.
	    */
            if !(*redef).reference.is_null() {
                node = xmlSchemaGetComponentNode((*redef).reference)
            } else { node = xmlSchemaGetComponentNode(item) }
            xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAP_SRC_REDEFINE, node,
                               0 as xmlSchemaBasicItemPtr,
                               b"The %s \'%s\' to be redefined could not be found in the redefined schema\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlSchemaGetComponentTypeStr(item),
                               xmlSchemaFormatQName(&mut str,
                                                    (*redef).refTargetNs,
                                                    (*redef).refName));
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as
                                                                *mut std::os::raw::c_void);
                str = 0 as *mut xmlChar
            }
            err = (*pctxt).err;
            redef = (*redef).next
        } else {
            /*
	* TODO: Obtaining and setting the redefinition state is really
	* clumsy.
	*/
            wasRedefined = 0 as std::os::raw::c_int;
            match (*item).type_0 as std::os::raw::c_uint {
                5 | 4 => {
                    if (*(prev as xmlSchemaTypePtr)).flags &
                           (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int != 0 {
                        wasRedefined = 1 as std::os::raw::c_int
                    } else {
                        /* Mark it as redefined. */
                        (*(prev as xmlSchemaTypePtr)).flags |=
                            (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int;
                        /*
		* Assign the redefined type to the
		* base type of the redefining type.
		* TODO: How
		*/
                        let ref mut fresh20 =
                            (*(item as xmlSchemaTypePtr)).baseType;
                        *fresh20 = prev as xmlSchemaTypePtr
                    }
                }
                17 => {
                    if (*(prev as xmlSchemaModelGroupDefPtr)).flags &
                           (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
                        wasRedefined = 1 as std::os::raw::c_int
                    } else {
                        /* Mark it as redefined. */
                        (*(prev as xmlSchemaModelGroupDefPtr)).flags |=
                            (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int;
                        if !(*redef).reference.is_null() {
                            /*
		    * Overwrite the QName-reference with the
		    * referenced model group def.
		    */
                            let ref mut fresh21 =
                                (*((*redef).reference as
                                       xmlSchemaParticlePtr)).children;
                            *fresh21 = prev as xmlSchemaTreeItemPtr
                        }
                        (*redef).target = prev
                    }
                }
                16 => {
                    if (*(prev as xmlSchemaAttributeGroupPtr)).flags &
                           (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0 {
                        wasRedefined = 1 as std::os::raw::c_int
                    } else {
                        (*(prev as xmlSchemaAttributeGroupPtr)).flags |=
                            (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int;
                        if !(*redef).reference.is_null() {
                            /*
		    * Assign the redefined attribute group to the
		    * QName-reference component.
		    * This is the easy case, since we will just
		    * expand the redefined group.
		    */
                            let ref mut fresh22 =
                                (*((*redef).reference as
                                       xmlSchemaQNameRefPtr)).item;
                            *fresh22 = prev;
                            (*redef).target = 0 as xmlSchemaBasicItemPtr
                        } else {
                            /*
		    * This is the complicated case: we need
		    * to apply src-redefine (7.2.2) at a later
		    * stage, i.e. when attribute group references
		    * have beed expanded and simple types have
		    * beed fixed.
		    */
                            (*redef).target = prev
                        }
                    }
                }
                _ => {
                    xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaResolveRedefReferences\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char,
                                         b"Unexpected redefined component type\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    return -(1 as std::os::raw::c_int)
                }
            }
            if wasRedefined != 0 {
                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                let mut node_0: xmlNodePtr = 0 as *mut xmlNode;
                if !(*redef).reference.is_null() {
                    node_0 = xmlSchemaGetComponentNode((*redef).reference)
                } else { node_0 = xmlSchemaGetComponentNode((*redef).item) }
                xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                   XML_SCHEMAP_SRC_REDEFINE, node_0,
                                   0 as xmlSchemaBasicItemPtr,
                                   b"The referenced %s was already redefined. Multiple redefinition of the same component is not supported\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlSchemaGetComponentDesignation(&mut str_0,
                                                                    prev as
                                                                        *mut std::os::raw::c_void),
                                   0 as *const xmlChar);
                if !str_0.is_null() {
                    xmlFree.expect("non-null function pointer")(str_0 as
                                                                    *mut std::os::raw::c_void);
                    str_0 = 0 as *mut xmlChar
                }
                err = (*pctxt).err;
                redef = (*redef).next
            } else { redef = (*redef).next }
        }
        if redef.is_null() { break ; }
    }
    return err;
}
unsafe extern "C" fn xmlSchemaCheckSRCRedefineSecond(mut pctxt:
                                                         xmlSchemaParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut err: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut redef: xmlSchemaRedefPtr = (*(*pctxt).constructor).redefs;
    let mut item: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    if redef.is_null() { return 0 as std::os::raw::c_int }
    loop  {
        if (*redef).target.is_null() {
            redef = (*redef).next
        } else {
            item = (*redef).item;
            match (*item).type_0 as std::os::raw::c_uint {
                4 | 5 => {
                    /*
		* Since the spec wants the {name} of the redefined
		* type to be 'absent', we'll NULL it.
		*/
                    let ref mut fresh23 =
                        (*((*redef).target as xmlSchemaTypePtr)).name;
                    *fresh23 = 0 as *const xmlChar
                }
                16 => {
                    /*
		* SPEC src-redefine:
		* (7.2.2) "The {attribute uses} and {attribute wildcard} of
		* the attribute group definition which corresponds to it
		* per XML Representation of Attribute Group Definition Schema
		* Components ($3.6.2) must be `valid restrictions` of the
		* {attribute uses} and {attribute wildcard} of that attribute
		* group definition in I, as defined in clause 2, clause 3 and
		* clause 4 of Derivation Valid (Restriction, Complex)
		* ($3.4.6) (where references to the base type definition are
		* understood as references to the attribute group definition
		* in I)."
		*/
                    err =
                        xmlSchemaCheckDerivationOKRestriction2to4(pctxt,
                                                                  1 as
                                                                      std::os::raw::c_int,
                                                                  item,
                                                                  (*redef).target,
                                                                  (*(item as
                                                                         xmlSchemaAttributeGroupPtr)).attrUses
                                                                      as
                                                                      xmlSchemaItemListPtr,
                                                                  (*((*redef).target
                                                                         as
                                                                         xmlSchemaAttributeGroupPtr)).attrUses
                                                                      as
                                                                      xmlSchemaItemListPtr,
                                                                  (*(item as
                                                                         xmlSchemaAttributeGroupPtr)).attributeWildcard,
                                                                  (*((*redef).target
                                                                         as
                                                                         xmlSchemaAttributeGroupPtr)).attributeWildcard);
                    if err == -(1 as std::os::raw::c_int) {
                        return -(1 as std::os::raw::c_int)
                    }
                }
                17 | _ => { }
            }
            redef = (*redef).next
        }
        if redef.is_null() { break ; }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaAddComponents(mut pctxt: xmlSchemaParserCtxtPtr,
                                            mut bucket: xmlSchemaBucketPtr)
 -> std::os::raw::c_int {
    let mut item: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut err: std::os::raw::c_int = 0;
    let mut table: *mut xmlHashTablePtr = 0 as *mut xmlHashTablePtr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut i: std::os::raw::c_int = 0;
    /*
    * Add global components to the schema's hash tables.
    * This is the place where duplicate components will be
    * detected.
    * TODO: I think normally we should support imports of the
    *   same namespace from multiple locations. We don't do currently,
    *   but if we do then according to:
    *   http://www.w3.org/Bugs/Public/show_bug.cgi?id=2224
    *   we would need, if imported directly, to import redefined
    *   components as well to be able to catch clashing components.
    *   (I hope I'll still know what this means after some months :-()
    */
    if bucket.is_null() { return -(1 as std::os::raw::c_int) }
    if (*bucket).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
        return 0 as std::os::raw::c_int
    }
    (*bucket).flags |= (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int;
    let mut current_block_61: u64;
    i = 0 as std::os::raw::c_int;
    while i < (*(*bucket).globals).nbItems {
        item =
            *(*(*bucket).globals).items.offset(i as isize) as
                xmlSchemaBasicItemPtr;
        table = 0 as *mut xmlHashTablePtr;
        match (*item).type_0 as std::os::raw::c_uint {
            5 | 4 => {
                if (*(item as xmlSchemaTypePtr)).flags &
                       (1 as std::os::raw::c_int) << 30 as std::os::raw::c_int != 0 {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = (*(item as xmlSchemaTypePtr)).name;
                    if (*bucket).type_0 == 0 as std::os::raw::c_int ||
                           (*bucket).type_0 == 1 as std::os::raw::c_int {
                        table =
                            &mut (*(*(bucket as
                                          xmlSchemaImportPtr)).schema).typeDecl
                    } else {
                        table =
                            &mut (*(*(*(bucket as
                                            xmlSchemaIncludePtr)).ownerImport).schema).typeDecl
                    }
                    current_block_61 = 2500484646272006982;
                }
            }
            14 => {
                name = (*(item as xmlSchemaElementPtr)).name;
                if (*bucket).type_0 == 0 as std::os::raw::c_int ||
                       (*bucket).type_0 == 1 as std::os::raw::c_int {
                    table =
                        &mut (*(*(bucket as
                                      xmlSchemaImportPtr)).schema).elemDecl
                } else {
                    table =
                        &mut (*(*(*(bucket as
                                        xmlSchemaIncludePtr)).ownerImport).schema).elemDecl
                }
                current_block_61 = 2500484646272006982;
            }
            15 => {
                name = (*(item as xmlSchemaAttributePtr)).name;
                if (*bucket).type_0 == 0 as std::os::raw::c_int ||
                       (*bucket).type_0 == 1 as std::os::raw::c_int {
                    table =
                        &mut (*(*(bucket as
                                      xmlSchemaImportPtr)).schema).attrDecl
                } else {
                    table =
                        &mut (*(*(*(bucket as
                                        xmlSchemaIncludePtr)).ownerImport).schema).attrDecl
                }
                current_block_61 = 2500484646272006982;
            }
            17 => {
                if (*(item as xmlSchemaModelGroupDefPtr)).flags &
                       (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = (*(item as xmlSchemaModelGroupDefPtr)).name;
                    if (*bucket).type_0 == 0 as std::os::raw::c_int ||
                           (*bucket).type_0 == 1 as std::os::raw::c_int {
                        table =
                            &mut (*(*(bucket as
                                          xmlSchemaImportPtr)).schema).groupDecl
                    } else {
                        table =
                            &mut (*(*(*(bucket as
                                            xmlSchemaIncludePtr)).ownerImport).schema).groupDecl
                    }
                    current_block_61 = 2500484646272006982;
                }
            }
            16 => {
                if (*(item as xmlSchemaAttributeGroupPtr)).flags &
                       (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0 {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = (*(item as xmlSchemaAttributeGroupPtr)).name;
                    if (*bucket).type_0 == 0 as std::os::raw::c_int ||
                           (*bucket).type_0 == 1 as std::os::raw::c_int {
                        table =
                            &mut (*(*(bucket as
                                          xmlSchemaImportPtr)).schema).attrgrpDecl
                    } else {
                        table =
                            &mut (*(*(*(bucket as
                                            xmlSchemaIncludePtr)).ownerImport).schema).attrgrpDecl
                    }
                    current_block_61 = 2500484646272006982;
                }
            }
            23 | 22 | 24 => {
                name = (*(item as xmlSchemaIDCPtr)).name;
                if (*bucket).type_0 == 0 as std::os::raw::c_int ||
                       (*bucket).type_0 == 1 as std::os::raw::c_int {
                    table =
                        &mut (*(*(bucket as
                                      xmlSchemaImportPtr)).schema).idcDef
                } else {
                    table =
                        &mut (*(*(*(bucket as
                                        xmlSchemaIncludePtr)).ownerImport).schema).idcDef
                }
                current_block_61 = 2500484646272006982;
            }
            18 => {
                name = (*(item as xmlSchemaNotationPtr)).name;
                if (*bucket).type_0 == 0 as std::os::raw::c_int ||
                       (*bucket).type_0 == 1 as std::os::raw::c_int {
                    table =
                        &mut (*(*(bucket as
                                      xmlSchemaImportPtr)).schema).notaDecl
                } else {
                    table =
                        &mut (*(*(*(bucket as
                                        xmlSchemaIncludePtr)).ownerImport).schema).notaDecl
                }
                current_block_61 = 2500484646272006982;
            }
            _ => {
                xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaAddComponents\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"Unexpected global component type\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                current_block_61 = 6937071982253665452;
            }
        }
        match current_block_61 {
            2500484646272006982 => {
                if (*table).is_null() {
                    *table =
                        xmlHashCreateDict(10 as std::os::raw::c_int, (*pctxt).dict);
                    if (*table).is_null() {
                        xmlSchemaInternalErr(pctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             b"xmlSchemaAddComponents\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"failed to create a component hash table\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                        return -(1 as std::os::raw::c_int)
                    }
                }
                err =
                    xmlHashAddEntry(*table, name, item as *mut std::os::raw::c_void);
                if err != 0 as std::os::raw::c_int {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomErr(pctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAP_REDEFINED_TYPE,
                                       xmlSchemaGetComponentNode(item), item,
                                       b"A global %s \'%s\' does already exist\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlSchemaGetComponentTypeStr(item),
                                       xmlSchemaGetComponentQName(&mut str,
                                                                  item as
                                                                      *mut std::os::raw::c_void));
                    if !str.is_null() {
                        xmlFree.expect("non-null function pointer")(str as
                                                                        *mut std::os::raw::c_void);
                        str = 0 as *mut xmlChar
                    }
                }
            }
            _ => { }
        }
        i += 1
    }
    /*
    * Process imported/included schemas.
    */
    if !(*bucket).relations.is_null() {
        let mut rel: xmlSchemaSchemaRelationPtr = (*bucket).relations;
        loop  {
            if !(*rel).bucket.is_null() &&
                   (*(*rel).bucket).flags &
                       (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                if xmlSchemaAddComponents(pctxt, (*rel).bucket) ==
                       -(1 as std::os::raw::c_int) {
                    return -(1 as std::os::raw::c_int)
                }
            }
            rel = (*rel).next;
            if rel.is_null() { break ; }
        }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaFixupComponents(mut pctxt:
                                                  xmlSchemaParserCtxtPtr,
                                              mut rootBucket:
                                                  xmlSchemaBucketPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut con: xmlSchemaConstructionCtxtPtr = (*pctxt).constructor;
    let mut item: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut items: *mut xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItemPtr;
    let mut nbItems: std::os::raw::c_int = 0;
    let mut i: std::os::raw::c_int = 0;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut oldbucket: xmlSchemaBucketPtr = (*con).bucket;
    let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    if (*con).pending.is_null() ||
           (*(*con).pending).nbItems == 0 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    /*
    * Since xmlSchemaFixupComplexType() will create new particles
    * (local components), and those particle components need a bucket
    * on the constructor, we'll assure here that the constructor has
    * a bucket.
    * TODO: Think about storing locals _only_ on the main bucket.
    */
    if (*con).bucket.is_null() { (*con).bucket = rootBucket }
    /* TODO:
    * SPEC (src-redefine):
    * (6.2) "If it has no such self-reference, then all of the
    * following must be true:"

    * (6.2.2) The {model group} of the model group definition which
    * corresponds to it per XML Representation of Model Group
    * Definition Schema Components ($3.7.2) must be a `valid
    * restriction` of the {model group} of that model group definition
    * in I, as defined in Particle Valid (Restriction) ($3.9.6)."
    */
    xmlSchemaCheckSRCRedefineFirst(pctxt);
    /*
    * Add global components to the schemata's hash tables.
    */
    xmlSchemaAddComponents(pctxt, rootBucket);
    (*pctxt).ctxtType = 0 as xmlSchemaTypePtr;
    items = (*(*con).pending).items as *mut xmlSchemaTreeItemPtr;
    nbItems = (*(*con).pending).nbItems;
    /*
    * Now that we have parsed *all* the schema document(s) and converted
    * them to schema components, we can resolve references, apply component
    * constraints, create the FSA from the content model, etc.
    */
    /*
    * Resolve references of..
    *
    * 1. element declarations:
    *   - the type definition
    *   - the substitution group affiliation
    * 2. simple/complex types:
    *   - the base type definition
    *   - the memberTypes of union types
    *   - the itemType of list types
    * 3. attributes declarations and attribute uses:
    *   - the type definition
    *   - if an attribute use, then the attribute declaration
    * 4. attribute group references:
    *   - the attribute group definition
    * 5. particles:
    *   - the term of the particle (e.g. a model group)
    * 6. IDC key-references:
    *   - the referenced IDC 'key' or 'unique' definition
    * 7. Attribute prohibitions which had a "ref" attribute.
    */
    i = 0 as std::os::raw::c_int;
    loop  {
        if !(i < nbItems) { current_block = 1924505913685386279; break ; }
        item = *items.offset(i as isize);
        match (*item).type_0 as std::os::raw::c_uint {
            14 => {
                xmlSchemaResolveElementReferences(item as xmlSchemaElementPtr,
                                                  pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                    current_block = 1197269492106645053;
                    break ;
                }
            }
            5 | 4 => {
                xmlSchemaResolveTypeReferences(item as xmlSchemaTypePtr,
                                               pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                    current_block = 1197269492106645053;
                    break ;
                }
            }
            15 => {
                xmlSchemaResolveAttrTypeReferences(item as
                                                       xmlSchemaAttributePtr,
                                                   pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                    current_block = 1197269492106645053;
                    break ;
                }
            }
            26 => {
                xmlSchemaResolveAttrUseReferences(item as
                                                      xmlSchemaAttributeUsePtr,
                                                  pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                    current_block = 1197269492106645053;
                    break ;
                }
            }
            2000 => {
                if (*(item as xmlSchemaQNameRefPtr)).itemType as std::os::raw::c_uint
                       ==
                       XML_SCHEMA_TYPE_ATTRIBUTEGROUP as std::os::raw::c_int as
                           std::os::raw::c_uint {
                    xmlSchemaResolveAttrGroupReferences(item as
                                                            xmlSchemaQNameRefPtr,
                                                        pctxt);
                }
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                    current_block = 1197269492106645053;
                    break ;
                }
            }
            6 | 7 | 8 => {
                xmlSchemaResolveModelGroupParticleReferences(pctxt,
                                                             item as
                                                                 xmlSchemaModelGroupPtr);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                    current_block = 1197269492106645053;
                    break ;
                }
            }
            23 | 22 | 24 => {
                xmlSchemaResolveIDCKeyReferences(item as xmlSchemaIDCPtr,
                                                 pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                    current_block = 1197269492106645053;
                    break ;
                }
            }
            2001 => {
                /*
		* Handle attribue prohibition which had a
		* "ref" attribute.
		*/
                xmlSchemaResolveAttrUseProhibReferences(item as
                                                            xmlSchemaAttributeUseProhibPtr,
                                                        pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                    current_block = 1197269492106645053;
                    break ;
                }
            }
            _ => { }
        }
        i += 1
    }
    match current_block {
        1924505913685386279 => {
            if (*pctxt).nberrors != 0 as std::os::raw::c_int {
                current_block = 9139726475653744865;
            } else {
                /*
    * Now that all references are resolved we
    * can check for circularity of...
    * 1. the base axis of type definitions
    * 2. nested model group definitions
    * 3. nested attribute group definitions
    * TODO: check for circual substitution groups.
    */
                i = 0 as std::os::raw::c_int;
                loop  {
                    if !(i < nbItems) {
                        current_block = 7330218953828964527;
                        break ;
                    }
                    item = *items.offset(i as isize);
                    /*
	* Let's better stop on the first error here.
	*/
                    match (*item).type_0 as std::os::raw::c_uint {
                        5 | 4 => {
                            xmlSchemaCheckTypeDefCircular(item as
                                                              xmlSchemaTypePtr,
                                                          pctxt);
                            if (*pctxt).err ==
                                   XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                                current_block = 1197269492106645053;
                                break ;
                            }
                            if (*pctxt).nberrors != 0 as std::os::raw::c_int {
                                current_block = 9139726475653744865;
                                break ;
                            }
                        }
                        17 => {
                            xmlSchemaCheckGroupDefCircular(item as
                                                               xmlSchemaModelGroupDefPtr,
                                                           pctxt);
                            if (*pctxt).err ==
                                   XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                                current_block = 1197269492106645053;
                                break ;
                            }
                            if (*pctxt).nberrors != 0 as std::os::raw::c_int {
                                current_block = 9139726475653744865;
                                break ;
                            }
                        }
                        16 => {
                            xmlSchemaCheckAttrGroupCircular(item as
                                                                xmlSchemaAttributeGroupPtr,
                                                            pctxt);
                            if (*pctxt).err ==
                                   XML_SCHEMAP_INTERNAL as std::os::raw::c_int {
                                current_block = 1197269492106645053;
                                break ;
                            }
                            if (*pctxt).nberrors != 0 as std::os::raw::c_int {
                                current_block = 9139726475653744865;
                                break ;
                            }
                        }
                        _ => { }
                    }
                    i += 1
                }
                match current_block {
                    1197269492106645053 => { }
                    9139726475653744865 => { }
                    _ => {
                        if (*pctxt).nberrors != 0 as std::os::raw::c_int {
                            current_block = 9139726475653744865;
                        } else {
                            /*
    * Model group definition references:
    * Such a reference is reflected by a particle at the component
    * level. Until now the 'term' of such particles pointed
    * to the model group definition; this was done, in order to
    * ease circularity checks. Now we need to set the 'term' of
    * such particles to the model group of the model group definition.
    */
                            i = 0 as std::os::raw::c_int;
                            while i < nbItems {
                                item = *items.offset(i as isize);
                                match (*item).type_0 as std::os::raw::c_uint {
                                    6 | 7 => {
                                        xmlSchemaModelGroupToModelGroupDefFixup(pctxt,
                                                                                item
                                                                                    as
                                                                                    xmlSchemaModelGroupPtr);
                                    }
                                    _ => { }
                                }
                                i += 1
                            }
                            if (*pctxt).nberrors != 0 as std::os::raw::c_int {
                                current_block = 9139726475653744865;
                            } else {
                                /*
    * Expand attribute group references of attribute group definitions.
    */
                                i = 0 as std::os::raw::c_int;
                                loop  {
                                    if !(i < nbItems) {
                                        current_block = 2798392256336243897;
                                        break ;
                                    }
                                    item = *items.offset(i as isize);
                                    match (*item).type_0 as std::os::raw::c_uint {
                                        16 => {
                                            if (*(item as
                                                      xmlSchemaAttributeGroupPtr)).flags
                                                   &
                                                   (1 as std::os::raw::c_int) <<
                                                       0 as std::os::raw::c_int == 0
                                                   &&
                                                   (*(item as
                                                          xmlSchemaAttributeGroupPtr)).flags
                                                       &
                                                       (1 as std::os::raw::c_int) <<
                                                           4 as std::os::raw::c_int !=
                                                       0 {
                                                xmlSchemaAttributeGroupExpandRefs(pctxt,
                                                                                  item
                                                                                      as
                                                                                      xmlSchemaAttributeGroupPtr);
                                                if (*pctxt).err ==
                                                       XML_SCHEMAP_INTERNAL as
                                                           std::os::raw::c_int {
                                                    current_block =
                                                        1197269492106645053;
                                                    break ;
                                                }
                                            }
                                        }
                                        _ => { }
                                    }
                                    i += 1
                                }
                                match current_block {
                                    1197269492106645053 => { }
                                    _ => {
                                        if (*pctxt).nberrors !=
                                               0 as std::os::raw::c_int {
                                            current_block =
                                                9139726475653744865;
                                        } else {
                                            /*
    * First compute the variety of simple types. This is needed as
    * a seperate step, since otherwise we won't be able to detect
    * circular union types in all cases.
    */
                                            i = 0 as std::os::raw::c_int;
                                            loop  {
                                                if !(i < nbItems) {
                                                    current_block =
                                                        562309032768341766;
                                                    break ;
                                                }
                                                item =
                                                    *items.offset(i as isize);
                                                match (*item).type_0 as
                                                          std::os::raw::c_uint {
                                                    4 => {
                                                        if (*(item as
                                                                  xmlSchemaTypePtr)).type_0
                                                               as std::os::raw::c_uint
                                                               !=
                                                               XML_SCHEMA_TYPE_BASIC
                                                                   as
                                                                   std::os::raw::c_int
                                                                   as
                                                                   std::os::raw::c_uint
                                                               &&
                                                               (*(item as
                                                                      xmlSchemaTypePtr)).flags
                                                                   &
                                                                   (1 as
                                                                        std::os::raw::c_int)
                                                                       <<
                                                                       29 as
                                                                           std::os::raw::c_int
                                                                   ==
                                                                   0 as
                                                                       std::os::raw::c_int
                                                           {
                                                            xmlSchemaFixupSimpleTypeStageOne(pctxt,
                                                                                             item
                                                                                                 as
                                                                                                 xmlSchemaTypePtr);
                                                            if (*pctxt).err ==
                                                                   XML_SCHEMAP_INTERNAL
                                                                       as
                                                                       std::os::raw::c_int
                                                               {
                                                                current_block
                                                                    =
                                                                    1197269492106645053;
                                                                break ;
                                                            }
                                                        }
                                                    }
                                                    _ => { }
                                                }
                                                i += 1
                                            }
                                            match current_block {
                                                1197269492106645053 => { }
                                                _ => {
                                                    if (*pctxt).nberrors !=
                                                           0 as std::os::raw::c_int {
                                                        current_block =
                                                            9139726475653744865;
                                                    } else {
                                                        /*
    * Detect circular union types. Note that this needs the variety to
    * be already computed.
    */
                                                        i = 0 as std::os::raw::c_int;
                                                        loop  {
                                                            if !(i < nbItems)
                                                               {
                                                                current_block
                                                                    =
                                                                    14612007084265645573;
                                                                break ;
                                                            }
                                                            item =
                                                                *items.offset(i
                                                                                  as
                                                                                  isize);
                                                            match (*item).type_0
                                                                      as
                                                                      std::os::raw::c_uint
                                                                {
                                                                4 => {
                                                                    if !(*(item
                                                                               as
                                                                               xmlSchemaTypePtr)).memberTypes.is_null()
                                                                       {
                                                                        xmlSchemaCheckUnionTypeDefCircular(pctxt,
                                                                                                           item
                                                                                                               as
                                                                                                               xmlSchemaTypePtr);
                                                                        if (*pctxt).err
                                                                               ==
                                                                               XML_SCHEMAP_INTERNAL
                                                                                   as
                                                                                   std::os::raw::c_int
                                                                           {
                                                                            current_block
                                                                                =
                                                                                1197269492106645053;
                                                                            break
                                                                                ;
                                                                        }
                                                                    }
                                                                }
                                                                _ => { }
                                                            }
                                                            i += 1
                                                        }
                                                        match current_block {
                                                            1197269492106645053
                                                            => {
                                                            }
                                                            _ => {
                                                                if (*pctxt).nberrors
                                                                       !=
                                                                       0 as
                                                                           std::os::raw::c_int
                                                                   {
                                                                    current_block
                                                                        =
                                                                        9139726475653744865;
                                                                } else {
                                                                    /*
    * Do the complete type fixup for simple types.
    */
                                                                    i =
                                                                        0 as
                                                                            std::os::raw::c_int;
                                                                    loop  {
                                                                        if !(i
                                                                                 <
                                                                                 nbItems)
                                                                           {
                                                                            current_block
                                                                                =
                                                                                7079180960716815705;
                                                                            break
                                                                                ;
                                                                        }
                                                                        item =
                                                                            *items.offset(i
                                                                                              as
                                                                                              isize);
                                                                        match (*item).type_0
                                                                                  as
                                                                                  std::os::raw::c_uint
                                                                            {
                                                                            4
                                                                            =>
                                                                            {
                                                                                if (*(item
                                                                                          as
                                                                                          xmlSchemaTypePtr)).type_0
                                                                                       as
                                                                                       std::os::raw::c_uint
                                                                                       !=
                                                                                       XML_SCHEMA_TYPE_BASIC
                                                                                           as
                                                                                           std::os::raw::c_int
                                                                                           as
                                                                                           std::os::raw::c_uint
                                                                                       &&
                                                                                       (*(item
                                                                                              as
                                                                                              xmlSchemaTypePtr)).flags
                                                                                           &
                                                                                           (1
                                                                                                as
                                                                                                std::os::raw::c_int)
                                                                                               <<
                                                                                               22
                                                                                                   as
                                                                                                   std::os::raw::c_int
                                                                                           ==
                                                                                           0
                                                                                               as
                                                                                               std::os::raw::c_int
                                                                                   {
                                                                                    xmlSchemaFixupSimpleTypeStageTwo(pctxt,
                                                                                                                     item
                                                                                                                         as
                                                                                                                         xmlSchemaTypePtr);
                                                                                    if (*pctxt).err
                                                                                           ==
                                                                                           XML_SCHEMAP_INTERNAL
                                                                                               as
                                                                                               std::os::raw::c_int
                                                                                       {
                                                                                        current_block
                                                                                            =
                                                                                            1197269492106645053;
                                                                                        break
                                                                                            ;
                                                                                    }
                                                                                }
                                                                            }
                                                                            _
                                                                            =>
                                                                            {
                                                                            }
                                                                        }
                                                                        i += 1
                                                                    }
                                                                    match current_block
                                                                        {
                                                                        1197269492106645053
                                                                        => {
                                                                        }
                                                                        _ => {
                                                                            if (*pctxt).nberrors
                                                                                   !=
                                                                                   0
                                                                                       as
                                                                                       std::os::raw::c_int
                                                                               {
                                                                                current_block
                                                                                    =
                                                                                    9139726475653744865;
                                                                            } else {
                                                                                /*
    * At this point we need build and check all simple types.
    */
    /*
    * Apply contraints for attribute declarations.
    */
                                                                                i
                                                                                    =
                                                                                    0
                                                                                        as
                                                                                        std::os::raw::c_int;
                                                                                loop 
                                                                                     {
                                                                                    if !(i
                                                                                             <
                                                                                             nbItems)
                                                                                       {
                                                                                        current_block
                                                                                            =
                                                                                            5431927413890720344;
                                                                                        break
                                                                                            ;
                                                                                    }
                                                                                    item
                                                                                        =
                                                                                        *items.offset(i
                                                                                                          as
                                                                                                          isize);
                                                                                    match (*item).type_0
                                                                                              as
                                                                                              std::os::raw::c_uint
                                                                                        {
                                                                                        15
                                                                                        =>
                                                                                        {
                                                                                            xmlSchemaCheckAttrPropsCorrect(pctxt,
                                                                                                                           item
                                                                                                                               as
                                                                                                                               xmlSchemaAttributePtr);
                                                                                            if (*pctxt).err
                                                                                                   ==
                                                                                                   XML_SCHEMAP_INTERNAL
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                               {
                                                                                                current_block
                                                                                                    =
                                                                                                    1197269492106645053;
                                                                                                break
                                                                                                    ;
                                                                                            }
                                                                                        }
                                                                                        _
                                                                                        =>
                                                                                        {
                                                                                        }
                                                                                    }
                                                                                    i
                                                                                        +=
                                                                                        1
                                                                                }
                                                                                match current_block
                                                                                    {
                                                                                    1197269492106645053
                                                                                    =>
                                                                                    {
                                                                                    }
                                                                                    _
                                                                                    =>
                                                                                    {
                                                                                        if (*pctxt).nberrors
                                                                                               !=
                                                                                               0
                                                                                                   as
                                                                                                   std::os::raw::c_int
                                                                                           {
                                                                                            current_block
                                                                                                =
                                                                                                9139726475653744865;
                                                                                        } else {
                                                                                            /*
    * Apply constraints for attribute uses.
    */
                                                                                            i
                                                                                                =
                                                                                                0
                                                                                                    as
                                                                                                    std::os::raw::c_int;
                                                                                            loop 
                                                                                                 {
                                                                                                if !(i
                                                                                                         <
                                                                                                         nbItems)
                                                                                                   {
                                                                                                    current_block
                                                                                                        =
                                                                                                        6215370584428403858;
                                                                                                    break
                                                                                                        ;
                                                                                                }
                                                                                                item
                                                                                                    =
                                                                                                    *items.offset(i
                                                                                                                      as
                                                                                                                      isize);
                                                                                                match (*item).type_0
                                                                                                          as
                                                                                                          std::os::raw::c_uint
                                                                                                    {
                                                                                                    26
                                                                                                    =>
                                                                                                    {
                                                                                                        if !(*(item
                                                                                                                   as
                                                                                                                   xmlSchemaAttributeUsePtr)).defValue.is_null()
                                                                                                           {
                                                                                                            xmlSchemaCheckAttrUsePropsCorrect(pctxt,
                                                                                                                                              item
                                                                                                                                                  as
                                                                                                                                                  xmlSchemaAttributeUsePtr);
                                                                                                            if (*pctxt).err
                                                                                                                   ==
                                                                                                                   XML_SCHEMAP_INTERNAL
                                                                                                                       as
                                                                                                                       std::os::raw::c_int
                                                                                                               {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    1197269492106645053;
                                                                                                                break
                                                                                                                    ;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _
                                                                                                    =>
                                                                                                    {
                                                                                                    }
                                                                                                }
                                                                                                i
                                                                                                    +=
                                                                                                    1
                                                                                            }
                                                                                            match current_block
                                                                                                {
                                                                                                1197269492106645053
                                                                                                =>
                                                                                                {
                                                                                                }
                                                                                                _
                                                                                                =>
                                                                                                {
                                                                                                    if (*pctxt).nberrors
                                                                                                           !=
                                                                                                           0
                                                                                                               as
                                                                                                               std::os::raw::c_int
                                                                                                       {
                                                                                                        current_block
                                                                                                            =
                                                                                                            9139726475653744865;
                                                                                                    } else {
                                                                                                        /*
    * Apply constraints for attribute group definitions.
    */
                                                                                                        i
                                                                                                            =
                                                                                                            0
                                                                                                                as
                                                                                                                std::os::raw::c_int;
                                                                                                        loop 
                                                                                                             {
                                                                                                            if !(i
                                                                                                                     <
                                                                                                                     nbItems)
                                                                                                               {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    6662862405959679103;
                                                                                                                break
                                                                                                                    ;
                                                                                                            }
                                                                                                            item
                                                                                                                =
                                                                                                                *items.offset(i
                                                                                                                                  as
                                                                                                                                  isize);
                                                                                                            match (*item).type_0
                                                                                                                      as
                                                                                                                      std::os::raw::c_uint
                                                                                                                {
                                                                                                                16
                                                                                                                =>
                                                                                                                {
                                                                                                                    if !(*(item
                                                                                                                               as
                                                                                                                               xmlSchemaAttributeGroupPtr)).attrUses.is_null()
                                                                                                                           &&
                                                                                                                           (*((*(item
                                                                                                                                     as
                                                                                                                                     xmlSchemaAttributeGroupPtr)).attrUses
                                                                                                                                  as
                                                                                                                                  xmlSchemaItemListPtr)).nbItems
                                                                                                                               >
                                                                                                                               1
                                                                                                                                   as
                                                                                                                                   std::os::raw::c_int
                                                                                                                       {
                                                                                                                        xmlSchemaCheckAGPropsCorrect(pctxt,
                                                                                                                                                     item
                                                                                                                                                         as
                                                                                                                                                         xmlSchemaAttributeGroupPtr);
                                                                                                                        if (*pctxt).err
                                                                                                                               ==
                                                                                                                               XML_SCHEMAP_INTERNAL
                                                                                                                                   as
                                                                                                                                   std::os::raw::c_int
                                                                                                                           {
                                                                                                                            current_block
                                                                                                                                =
                                                                                                                                1197269492106645053;
                                                                                                                            break
                                                                                                                                ;
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                _
                                                                                                                =>
                                                                                                                {
                                                                                                                }
                                                                                                            }
                                                                                                            i
                                                                                                                +=
                                                                                                                1
                                                                                                        }
                                                                                                        match current_block
                                                                                                            {
                                                                                                            1197269492106645053
                                                                                                            =>
                                                                                                            {
                                                                                                            }
                                                                                                            _
                                                                                                            =>
                                                                                                            {
                                                                                                                if (*pctxt).nberrors
                                                                                                                       !=
                                                                                                                       0
                                                                                                                           as
                                                                                                                           std::os::raw::c_int
                                                                                                                   {
                                                                                                                    current_block
                                                                                                                        =
                                                                                                                        9139726475653744865;
                                                                                                                } else {
                                                                                                                    /*
    * Apply constraints for redefinitions.
    */
                                                                                                                    if !(*(*pctxt).constructor).redefs.is_null()
                                                                                                                       {
                                                                                                                        xmlSchemaCheckSRCRedefineSecond(pctxt);
                                                                                                                    }
                                                                                                                    if (*pctxt).nberrors
                                                                                                                           !=
                                                                                                                           0
                                                                                                                               as
                                                                                                                               std::os::raw::c_int
                                                                                                                       {
                                                                                                                        current_block
                                                                                                                            =
                                                                                                                            9139726475653744865;
                                                                                                                    } else {
                                                                                                                        /*
    * Complex types are builded and checked.
    */
                                                                                                                        i
                                                                                                                            =
                                                                                                                            0
                                                                                                                                as
                                                                                                                                std::os::raw::c_int;
                                                                                                                        loop 
                                                                                                                             {
                                                                                                                            if !(i
                                                                                                                                     <
                                                                                                                                     nbItems)
                                                                                                                               {
                                                                                                                                current_block
                                                                                                                                    =
                                                                                                                                    13598848910332274892;
                                                                                                                                break
                                                                                                                                    ;
                                                                                                                            }
                                                                                                                            item
                                                                                                                                =
                                                                                                                                *(*(*con).pending).items.offset(i
                                                                                                                                                                    as
                                                                                                                                                                    isize)
                                                                                                                                    as
                                                                                                                                    xmlSchemaTreeItemPtr;
                                                                                                                            match (*item).type_0
                                                                                                                                      as
                                                                                                                                      std::os::raw::c_uint
                                                                                                                                {
                                                                                                                                5
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    if (*(item
                                                                                                                                              as
                                                                                                                                              xmlSchemaTypePtr)).type_0
                                                                                                                                           as
                                                                                                                                           std::os::raw::c_uint
                                                                                                                                           !=
                                                                                                                                           XML_SCHEMA_TYPE_BASIC
                                                                                                                                               as
                                                                                                                                               std::os::raw::c_int
                                                                                                                                               as
                                                                                                                                               std::os::raw::c_uint
                                                                                                                                           &&
                                                                                                                                           (*(item
                                                                                                                                                  as
                                                                                                                                                  xmlSchemaTypePtr)).flags
                                                                                                                                               &
                                                                                                                                               (1
                                                                                                                                                    as
                                                                                                                                                    std::os::raw::c_int)
                                                                                                                                                   <<
                                                                                                                                                   22
                                                                                                                                                       as
                                                                                                                                                       std::os::raw::c_int
                                                                                                                                               ==
                                                                                                                                               0
                                                                                                                                                   as
                                                                                                                                                   std::os::raw::c_int
                                                                                                                                       {
                                                                                                                                        xmlSchemaFixupComplexType(pctxt,
                                                                                                                                                                  item
                                                                                                                                                                      as
                                                                                                                                                                      xmlSchemaTypePtr);
                                                                                                                                        if (*pctxt).err
                                                                                                                                               ==
                                                                                                                                               XML_SCHEMAP_INTERNAL
                                                                                                                                                   as
                                                                                                                                                   std::os::raw::c_int
                                                                                                                                           {
                                                                                                                                            current_block
                                                                                                                                                =
                                                                                                                                                1197269492106645053;
                                                                                                                                            break
                                                                                                                                                ;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                _
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                }
                                                                                                                            }
                                                                                                                            i
                                                                                                                                +=
                                                                                                                                1
                                                                                                                        }
                                                                                                                        match current_block
                                                                                                                            {
                                                                                                                            1197269492106645053
                                                                                                                            =>
                                                                                                                            {
                                                                                                                            }
                                                                                                                            _
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                if (*pctxt).nberrors
                                                                                                                                       !=
                                                                                                                                       0
                                                                                                                                           as
                                                                                                                                           std::os::raw::c_int
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        9139726475653744865;
                                                                                                                                } else {
                                                                                                                                    /*
    * The list could have changed, since xmlSchemaFixupComplexType()
    * will create particles and model groups in some cases.
    */
                                                                                                                                    items
                                                                                                                                        =
                                                                                                                                        (*(*con).pending).items
                                                                                                                                            as
                                                                                                                                            *mut xmlSchemaTreeItemPtr;
                                                                                                                                    nbItems
                                                                                                                                        =
                                                                                                                                        (*(*con).pending).nbItems;
                                                                                                                                    /*
    * Apply some constraints for element declarations.
    */
                                                                                                                                    i
                                                                                                                                        =
                                                                                                                                        0
                                                                                                                                            as
                                                                                                                                            std::os::raw::c_int;
                                                                                                                                    loop 
                                                                                                                                         {
                                                                                                                                        if !(i
                                                                                                                                                 <
                                                                                                                                                 nbItems)
                                                                                                                                           {
                                                                                                                                            current_block
                                                                                                                                                =
                                                                                                                                                2277602629737488951;
                                                                                                                                            break
                                                                                                                                                ;
                                                                                                                                        }
                                                                                                                                        item
                                                                                                                                            =
                                                                                                                                            *items.offset(i
                                                                                                                                                              as
                                                                                                                                                              isize);
                                                                                                                                        match (*item).type_0
                                                                                                                                                  as
                                                                                                                                                  std::os::raw::c_uint
                                                                                                                                            {
                                                                                                                                            14
                                                                                                                                            =>
                                                                                                                                            {
                                                                                                                                                elemDecl
                                                                                                                                                    =
                                                                                                                                                    item
                                                                                                                                                        as
                                                                                                                                                        xmlSchemaElementPtr;
                                                                                                                                                if (*elemDecl).flags
                                                                                                                                                       &
                                                                                                                                                       (1
                                                                                                                                                            as
                                                                                                                                                            std::os::raw::c_int)
                                                                                                                                                           <<
                                                                                                                                                           18
                                                                                                                                                               as
                                                                                                                                                               std::os::raw::c_int
                                                                                                                                                       ==
                                                                                                                                                       0
                                                                                                                                                           as
                                                                                                                                                           std::os::raw::c_int
                                                                                                                                                   {
                                                                                                                                                    xmlSchemaCheckElementDeclComponent(elemDecl,
                                                                                                                                                                                       pctxt);
                                                                                                                                                    if (*pctxt).err
                                                                                                                                                           ==
                                                                                                                                                           XML_SCHEMAP_INTERNAL
                                                                                                                                                               as
                                                                                                                                                               std::os::raw::c_int
                                                                                                                                                       {
                                                                                                                                                        current_block
                                                                                                                                                            =
                                                                                                                                                            1197269492106645053;
                                                                                                                                                        break
                                                                                                                                                            ;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            _
                                                                                                                                            =>
                                                                                                                                            {
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        i
                                                                                                                                            +=
                                                                                                                                            1
                                                                                                                                    }
                                                                                                                                    match current_block
                                                                                                                                        {
                                                                                                                                        1197269492106645053
                                                                                                                                        =>
                                                                                                                                        {
                                                                                                                                        }
                                                                                                                                        _
                                                                                                                                        =>
                                                                                                                                        {
                                                                                                                                            if (*pctxt).nberrors
                                                                                                                                                   !=
                                                                                                                                                   0
                                                                                                                                                       as
                                                                                                                                                       std::os::raw::c_int
                                                                                                                                               {
                                                                                                                                                current_block
                                                                                                                                                    =
                                                                                                                                                    9139726475653744865;
                                                                                                                                            } else {
                                                                                                                                                /*
    * Finally we can build the automaton from the content model of
    * complex types.
    */
                                                                                                                                                i
                                                                                                                                                    =
                                                                                                                                                    0
                                                                                                                                                        as
                                                                                                                                                        std::os::raw::c_int;
                                                                                                                                                while i
                                                                                                                                                          <
                                                                                                                                                          nbItems
                                                                                                                                                      {
                                                                                                                                                    item
                                                                                                                                                        =
                                                                                                                                                        *items.offset(i
                                                                                                                                                                          as
                                                                                                                                                                          isize);
                                                                                                                                                    match (*item).type_0
                                                                                                                                                              as
                                                                                                                                                              std::os::raw::c_uint
                                                                                                                                                        {
                                                                                                                                                        5
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            xmlSchemaBuildContentModel(item
                                                                                                                                                                                           as
                                                                                                                                                                                           xmlSchemaTypePtr,
                                                                                                                                                                                       pctxt);
                                                                                                                                                        }
                                                                                                                                                        _
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    i
                                                                                                                                                        +=
                                                                                                                                                        1
                                                                                                                                                }
                                                                                                                                                if (*pctxt).nberrors
                                                                                                                                                       !=
                                                                                                                                                       0
                                                                                                                                                           as
                                                                                                                                                           std::os::raw::c_int
                                                                                                                                                   {
                                                                                                                                                    current_block
                                                                                                                                                        =
                                                                                                                                                        9139726475653744865;
                                                                                                                                                } else {
                                                                                                                                                    current_block
                                                                                                                                                        =
                                                                                                                                                        13128250371090968211;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            match current_block {
                13128250371090968211 => { }
                1197269492106645053 => { }
                _ => {
                    ret = (*pctxt).err;
                    current_block = 13128250371090968211;
                }
            }
        }
        _ => { }
    }
    match current_block {
        1197269492106645053 => { ret = -(1 as std::os::raw::c_int) }
        _ => { }
    }
    /*
    * URGENT TODO: cos-element-consistent
    */
    /*
    * Reset the constructor. This is needed for XSI acquisition, since
    * those items will be processed over and over again for every XSI
    * if not cleared here.
    */
    (*con).bucket = oldbucket;
    (*(*con).pending).nbItems = 0 as std::os::raw::c_int;
    if !(*con).substGroups.is_null() {
        xmlHashFree((*con).substGroups,
                    Some(xmlSchemaSubstGroupFreeEntry as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *const xmlChar) -> ()));
        (*con).substGroups = 0 as xmlHashTablePtr
    }
    if !(*con).redefs.is_null() {
        xmlSchemaRedefListFree((*con).redefs);
        (*con).redefs = 0 as xmlSchemaRedefPtr
    }
    return ret;
}
/* *
 * xmlSchemaParse:
 * @ctxt:  a schema validation context
 *
 * parse a schema definition resource and build an internal
 * XML Shema struture which can be used to validate instances.
 *
 * Returns the internal XML Schema structure built from the resource or
 *         NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaParse(mut ctxt: xmlSchemaParserCtxtPtr)
 -> xmlSchemaPtr {
    let mut current_block: u64;
    let mut mainSchema: xmlSchemaPtr = 0 as xmlSchemaPtr;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    let mut res: std::os::raw::c_int = 0;
    /*
    * This one is used if the schema to be parsed was specified via
    * the API; i.e. not automatically by the validated instance document.
    */
    xmlSchemaInitTypes();
    if ctxt.is_null() { return 0 as xmlSchemaPtr }
    /* TODO: Init the context. Is this all we need?*/
    (*ctxt).nberrors = 0 as std::os::raw::c_int;
    (*ctxt).err = 0 as std::os::raw::c_int;
    (*ctxt).counter = 0 as std::os::raw::c_int;
    /* Create the *main* schema. */
    mainSchema = xmlSchemaNewSchema(ctxt);
    if !mainSchema.is_null() {
        /*
    * Create the schema constructor.
    */
        if (*ctxt).constructor.is_null() {
            (*ctxt).constructor =
                xmlSchemaConstructionCtxtCreate((*ctxt).dict);
            if (*ctxt).constructor.is_null() { return 0 as xmlSchemaPtr }
            /* Take ownership of the constructor to be able to free it. */
            (*ctxt).ownsConstructor = 1 as std::os::raw::c_int
        }
        (*(*ctxt).constructor).mainSchema = mainSchema;
        /*
    * Locate and add the schema document.
    */
        res =
            xmlSchemaAddSchemaDoc(ctxt, 0 as std::os::raw::c_int, (*ctxt).URL,
                                  (*ctxt).doc, (*ctxt).buffer, (*ctxt).size,
                                  0 as xmlNodePtr, 0 as *const xmlChar,
                                  0 as *const xmlChar, &mut bucket);
        if !(res == -(1 as std::os::raw::c_int)) {
            if res != 0 as std::os::raw::c_int {
                current_block = 8245264621206935446;
            } else if bucket.is_null() {
                /* TODO: Error code, actually we failed to *locate* the schema. */
                if !(*ctxt).URL.is_null() {
                    xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAP_FAILED_LOAD,
                                       0 as xmlNodePtr,
                                       0 as xmlSchemaBasicItemPtr,
                                       b"Failed to locate the main schema resource at \'%s\'\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char, (*ctxt).URL,
                                       0 as *const xmlChar);
                } else {
                    xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAP_FAILED_LOAD,
                                       0 as xmlNodePtr,
                                       0 as xmlSchemaBasicItemPtr,
                                       b"Failed to locate the main schema resource\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       0 as *const xmlChar,
                                       0 as *const xmlChar);
                }
                current_block = 8245264621206935446;
            } else if xmlSchemaParseNewDocWithContext(ctxt, mainSchema,
                                                      bucket) ==
                          -(1 as std::os::raw::c_int) {
                current_block = 10662487725856143911;
            } else if (*ctxt).nberrors != 0 as std::os::raw::c_int {
                current_block = 8245264621206935446;
            } else {
                (*mainSchema).doc = (*bucket).doc;
                (*mainSchema).preserve = (*ctxt).preserve;
                (*ctxt).schema = mainSchema;
                if xmlSchemaFixupComponents(ctxt,
                                            (*(*ctxt).constructor).mainBucket)
                       == -(1 as std::os::raw::c_int) {
                    current_block = 10662487725856143911;
                } else { current_block = 8245264621206935446; }
            }
            match current_block {
                10662487725856143911 => { }
                _ =>
                /* Then do the parsing for good. */
                /*
    * TODO: This is not nice, since we cannot distinguish from the
    * result if there was an internal error or not.
    */
                {
                    if (*ctxt).nberrors != 0 as std::os::raw::c_int {
                        if !mainSchema.is_null() {
                            xmlSchemaFree(mainSchema);
                            mainSchema = 0 as xmlSchemaPtr
                        }
                        if !(*ctxt).constructor.is_null() {
                            xmlSchemaConstructionCtxtFree((*ctxt).constructor);
                            (*ctxt).constructor =
                                0 as xmlSchemaConstructionCtxtPtr;
                            (*ctxt).ownsConstructor = 0 as std::os::raw::c_int
                        }
                    }
                    (*ctxt).schema = 0 as xmlSchemaPtr;
                    return mainSchema
                }
            }
        }
    }
    /*
    * Quite verbose, but should catch internal errors, which were
    * not communitated.
    */
    if !mainSchema.is_null() {
        xmlSchemaFree(mainSchema);
        mainSchema = 0 as xmlSchemaPtr
    }
    if !(*ctxt).constructor.is_null() {
        xmlSchemaConstructionCtxtFree((*ctxt).constructor);
        (*ctxt).constructor = 0 as xmlSchemaConstructionCtxtPtr;
        (*ctxt).ownsConstructor = 0 as std::os::raw::c_int
    }
    xmlSchemaInternalErr(ctxt as xmlSchemaAbstractCtxtPtr,
                         b"xmlSchemaParse\x00" as *const u8 as
                             *const std::os::raw::c_char,
                         b"An internal error occurred\x00" as *const u8 as
                             *const std::os::raw::c_char);
    (*ctxt).schema = 0 as xmlSchemaPtr;
    return 0 as xmlSchemaPtr;
}
/* *
 * xmlSchemaSetParserErrors:
 * @ctxt:  a schema validation context
 * @err:  the error callback
 * @warn:  the warning callback
 * @ctx:  contextual data for the callbacks
 *
 * Set the callback functions used to handle errors for a validation context
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetParserErrors(mut ctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut err:
                                                      xmlSchemaValidityErrorFunc,
                                                  mut warn:
                                                      xmlSchemaValidityWarningFunc,
                                                  mut ctx:
                                                      *mut std::os::raw::c_void) {
    if ctxt.is_null() { return }
    (*ctxt).error = err;
    (*ctxt).warning = warn;
    (*ctxt).errCtxt = ctx;
    if !(*ctxt).vctxt.is_null() {
        xmlSchemaSetValidErrors((*ctxt).vctxt, err, warn, ctx);
    };
}
/* *
 * xmlSchemaSetParserStructuredErrors:
 * @ctxt:  a schema parser context
 * @serror:  the structured error function
 * @ctx: the functions context
 *
 * Set the structured error callback
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetParserStructuredErrors(mut ctxt:
                                                                xmlSchemaParserCtxtPtr,
                                                            mut serror:
                                                                xmlStructuredErrorFunc,
                                                            mut ctx:
                                                                *mut std::os::raw::c_void) {
    if ctxt.is_null() { return }
    (*ctxt).serror = serror;
    (*ctxt).errCtxt = ctx;
    if !(*ctxt).vctxt.is_null() {
        xmlSchemaSetValidStructuredErrors((*ctxt).vctxt, serror, ctx);
    };
}
/* *
 * xmlSchemaGetParserErrors:
 * @ctxt:  a XMl-Schema parser context
 * @err: the error callback result
 * @warn: the warning callback result
 * @ctx: contextual data for the callbacks result
 *
 * Get the callback information used to handle errors for a parser context
 *
 * Returns -1 in case of failure, 0 otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaGetParserErrors(mut ctxt:
                                                      xmlSchemaParserCtxtPtr,
                                                  mut err:
                                                      *mut xmlSchemaValidityErrorFunc,
                                                  mut warn:
                                                      *mut xmlSchemaValidityWarningFunc,
                                                  mut ctx:
                                                      *mut *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    if !err.is_null() { *err = (*ctxt).error }
    if !warn.is_null() { *warn = (*ctxt).warning }
    if !ctx.is_null() { *ctx = (*ctxt).errCtxt }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaFacetTypeToString:
 * @type:  the facet type
 *
 * Convert the xmlSchemaTypeType to a char string.
 *
 * Returns the char string representation of the facet type if the
 *     type is a facet and an "Internal Error" string otherwise.
 */
unsafe extern "C" fn xmlSchemaFacetTypeToString(mut type_0: xmlSchemaTypeType)
 -> *const xmlChar {
    match type_0 as std::os::raw::c_uint {
        1006 => {
            return b"pattern\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1003 => {
            return b"maxExclusive\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1002 => {
            return b"maxInclusive\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1001 => {
            return b"minExclusive\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1000 => {
            return b"minInclusive\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1008 => {
            return b"whiteSpace\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1007 => {
            return b"enumeration\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1009 => {
            return b"length\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1010 => {
            return b"maxLength\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1011 => {
            return b"minLength\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1004 => {
            return b"totalDigits\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar
        }
        1005 => {
            return b"fractionDigits\x00" as *const u8 as *const std::os::raw::c_char
                       as *mut xmlChar
        }
        _ => { }
    }
    return b"Internal Error\x00" as *const u8 as *const std::os::raw::c_char as
               *mut xmlChar;
}
unsafe extern "C" fn xmlSchemaGetWhiteSpaceFacetValue(mut type_0:
                                                          xmlSchemaTypePtr)
 -> xmlSchemaWhitespaceValueType {
    /*
    * The normalization type can be changed only for types which are derived
    * from xsd:string.
    */
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
        /*
	* Note that we assume a whitespace of preserve for anySimpleType.
	*/
        if (*type_0).builtInType == XML_SCHEMAS_STRING as std::os::raw::c_int ||
               (*type_0).builtInType ==
                   XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int {
            return XML_SCHEMA_WHITESPACE_PRESERVE
        } else if (*type_0).builtInType ==
                      XML_SCHEMAS_NORMSTRING as std::os::raw::c_int {
            return XML_SCHEMA_WHITESPACE_REPLACE
        } else {
            /*
	    * For all `atomic` datatypes other than string (and types `derived`
	    * by `restriction` from it) the value of whiteSpace is fixed to
	    * collapse
	    * Note that this includes built-in list datatypes.
	    */
            return XML_SCHEMA_WHITESPACE_COLLAPSE
        }
    } else {
        if (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
            /*
	* For list types the facet "whiteSpace" is fixed to "collapse".
	*/
            return XML_SCHEMA_WHITESPACE_COLLAPSE
        } else {
            if (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
                return XML_SCHEMA_WHITESPACE_UNKNOWN
            } else {
                if (*type_0).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int !=
                       0 {
                    if (*type_0).flags &
                           (1 as std::os::raw::c_int) << 24 as std::os::raw::c_int != 0 {
                        return XML_SCHEMA_WHITESPACE_PRESERVE
                    } else if (*type_0).flags &
                                  (1 as std::os::raw::c_int) << 25 as std::os::raw::c_int != 0
                     {
                        return XML_SCHEMA_WHITESPACE_REPLACE
                    } else { return XML_SCHEMA_WHITESPACE_COLLAPSE }
                }
            }
        }
    }
    return 4294967295 as xmlSchemaWhitespaceValueType;
}
/* ***********************************************************************
 *									*
 *			Simple type validation				*
 *									*
 ************************************************************************/
/* ***********************************************************************
 *									*
 *			DOM Validation code				*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaAssembleByLocation:
 * @pctxt:  a schema parser context
 * @vctxt:  a schema validation context
 * @schema: the existing schema
 * @node: the node that fired the assembling
 * @nsName: the namespace name of the new schema
 * @location: the location of the schema
 *
 * Expands an existing schema by an additional schema.
 *
 * Returns 0 if the new schema is correct, a positive error code
 * number otherwise and -1 in case of an internal or API error.
 */
unsafe extern "C" fn xmlSchemaAssembleByLocation(mut vctxt:
                                                     xmlSchemaValidCtxtPtr,
                                                 mut schema: xmlSchemaPtr,
                                                 mut node: xmlNodePtr,
                                                 mut nsName: *const xmlChar,
                                                 mut location: *const xmlChar)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut pctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if vctxt.is_null() || schema.is_null() { return -(1 as std::os::raw::c_int) }
    if (*vctxt).pctxt.is_null() {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaAssembleByLocation\x00" as *const u8
                                 as *const std::os::raw::c_char,
                             b"no parser context available\x00" as *const u8
                                 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    pctxt = (*vctxt).pctxt;
    if (*pctxt).constructor.is_null() {
        xmlSchemaInternalErr(pctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaAssembleByLocation\x00" as *const u8
                                 as *const std::os::raw::c_char,
                             b"no constructor\x00" as *const u8 as
                                 *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    /*
    * Acquire the schema document.
    */
    location = xmlSchemaBuildAbsoluteURI((*pctxt).dict, location, node);
    /*
    * Note that we pass XML_SCHEMA_SCHEMA_IMPORT here;
    * the process will automatically change this to
    * XML_SCHEMA_SCHEMA_MAIN if it is the first schema document.
    */
    ret =
        xmlSchemaAddSchemaDoc(pctxt, 1 as std::os::raw::c_int, location,
                              0 as xmlDocPtr, 0 as *const std::os::raw::c_char,
                              0 as std::os::raw::c_int, node, 0 as *const xmlChar,
                              nsName, &mut bucket);
    if ret != 0 as std::os::raw::c_int { return ret }
    if bucket.is_null() {
        /*
	* Generate a warning that the document could not be located.
	*/
        xmlSchemaCustomWarning(vctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAV_MISC, node, 0 as xmlSchemaTypePtr,
                               b"The document at location \'%s\' could not be acquired\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               location, 0 as *const xmlChar,
                               0 as *const xmlChar);
        return ret
    }
    /*
    * The first located schema will be handled as if all other
    * schemas imported by XSI were imported by this first schema.
    */
    if !bucket.is_null() && (*(*pctxt).constructor).bucket.is_null() {
        (*(*pctxt).constructor).bucket = bucket
    }
    /*
    * TODO: Is this handled like an import? I.e. is it not an error
    * if the schema cannot be located?
    */
    if bucket.is_null() ||
           !(!(*bucket).doc.is_null() && (*bucket).parsed == 0 as std::os::raw::c_int)
       {
        return 0 as std::os::raw::c_int
    }
    /*
    * We will reuse the parser context for every schema imported
    * directly via XSI. So reset the context.
    */
    (*pctxt).nberrors = 0 as std::os::raw::c_int;
    (*pctxt).err = 0 as std::os::raw::c_int;
    (*pctxt).doc = (*bucket).doc;
    ret = xmlSchemaParseNewDocWithContext(pctxt, schema, bucket);
    if ret == -(1 as std::os::raw::c_int) {
        (*pctxt).doc = 0 as xmlDocPtr;
        (*pctxt).doc = 0 as xmlDocPtr;
        return -(1 as std::os::raw::c_int)
    } else {
        /* Paranoid error channelling. */
        if ret == 0 as std::os::raw::c_int && (*pctxt).nberrors != 0 as std::os::raw::c_int {
            ret = (*pctxt).err
        }
        if (*pctxt).nberrors == 0 as std::os::raw::c_int {
            /*
	* Only bother to fixup pending components, if there was
	* no error yet.
	* For every XSI acquired schema (and its sub-schemata) we will
	* fixup the components.
	*/
            xmlSchemaFixupComponents(pctxt, bucket);
            ret = (*pctxt).err;
            /*
	* Not nice, but we need somehow to channel the schema parser
	* error to the validation context.
	*/
            if ret != 0 as std::os::raw::c_int && (*vctxt).err == 0 as std::os::raw::c_int {
                (*vctxt).err = ret
            }
            (*vctxt).nberrors += (*pctxt).nberrors
        } else {
            /* Add to validation error sum. */
            (*vctxt).nberrors += (*pctxt).nberrors
        }
        (*pctxt).doc = 0 as xmlDocPtr;
        return ret
    };
}
unsafe extern "C" fn xmlSchemaGetMetaAttrInfo(mut vctxt:
                                                  xmlSchemaValidCtxtPtr,
                                              mut metaType: std::os::raw::c_int)
 -> xmlSchemaAttrInfoPtr {
    if (*vctxt).nbAttrInfos == 0 as std::os::raw::c_int {
        return 0 as xmlSchemaAttrInfoPtr
    }
    let mut i: std::os::raw::c_int = 0;
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    i = 0 as std::os::raw::c_int;
    while i < (*vctxt).nbAttrInfos {
        iattr = *(*vctxt).attrInfos.offset(i as isize);
        if (*iattr).metaType == metaType { return iattr }
        i += 1
    }
    return 0 as xmlSchemaAttrInfoPtr;
}
/* *
 * xmlSchemaAssembleByXSI:
 * @vctxt:  a schema validation context
 *
 * Expands an existing schema by an additional schema using
 * the xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute
 * of an instance. If xsi:noNamespaceSchemaLocation is used, @noNamespace
 * must be set to 1.
 *
 * Returns 0 if the new schema is correct, a positive error code
 * number otherwise and -1 in case of an internal or API error.
 */
unsafe extern "C" fn xmlSchemaAssembleByXSI(mut vctxt: xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut end: *const xmlChar = 0 as *const xmlChar;
    let mut nsname: *const xmlChar = 0 as *const xmlChar;
    let mut location: *const xmlChar = 0 as *const xmlChar;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    /*
    * Parse the value; we will assume an even number of values
    * to be given (this is how Xerces and XSV work).
    *
    * URGENT TODO: !! This needs to work for both
    * @noNamespaceSchemaLocation AND @schemaLocation on the same
    * element !!
    */
    iattr = xmlSchemaGetMetaAttrInfo(vctxt, 3 as std::os::raw::c_int);
    if iattr.is_null() {
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 4 as std::os::raw::c_int)
    }
    if iattr.is_null() { return 0 as std::os::raw::c_int }
    cur = (*iattr).value;
    loop 
         /*
	* TODO: Move the string parsing mechanism away from here.
	*/
         {
        if (*iattr).metaType == 3 as std::os::raw::c_int {
            /*
	    * Get the namespace name.
	    */
            while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                      0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                          *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                      *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                cur = cur.offset(1)
            } /* TODO: Don't use the schema's dict. */
            end = cur;
            while *end as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                      !(*end as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                            0x9 as std::os::raw::c_int <= *end as std::os::raw::c_int &&
                                *end as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                            *end as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
                end = end.offset(1)
            }
            if end == cur { break ; }
            count += 1;
            nsname =
                xmlDictLookup((*(*vctxt).schema).dict, cur,
                              end.offset_from(cur) as std::os::raw::c_long as
                                  std::os::raw::c_int);
            cur = end
        }
        /*
	* Get the URI.
	*/
        while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                  0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                      *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                  *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
            cur = cur.offset(1)
        }
        end = cur;
        while *end as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                  !(*end as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                        0x9 as std::os::raw::c_int <= *end as std::os::raw::c_int &&
                            *end as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                        *end as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
            end = end.offset(1)
        }
        if end == cur {
            if (*iattr).metaType == 3 as std::os::raw::c_int {
                /*
		* If using @schemaLocation then tuples are expected.
		* I.e. the namespace name *and* the document's URI.
		*/
                xmlSchemaCustomWarning(vctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAV_MISC, (*iattr).node,
                                       0 as xmlSchemaTypePtr,
                                       b"The value must consist of tuples: the target namespace name and the document\'s URI\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       0 as *const xmlChar,
                                       0 as *const xmlChar,
                                       0 as
                                           *const xmlChar); /* TODO: Don't use the schema's dict. */
            }
            break ;
        } else {
            count += 1;
            location =
                xmlDictLookup((*(*vctxt).schema).dict, cur,
                              end.offset_from(cur) as std::os::raw::c_long as
                                  std::os::raw::c_int);
            cur = end;
            ret =
                xmlSchemaAssembleByLocation(vctxt, (*vctxt).schema,
                                            (*iattr).node, nsname, location);
            if ret == -(1 as std::os::raw::c_int) {
                xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaAssembleByXSI\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"assembling schemata\x00" as *const u8
                                         as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            if !(*cur as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaLookupNamespace(mut vctxt:
                                                  xmlSchemaValidCtxtPtr,
                                              mut prefix: *const xmlChar)
 -> *const xmlChar {
    if !(*vctxt).sax.is_null() {
        let mut i: std::os::raw::c_int = 0;
        let mut j: std::os::raw::c_int = 0;
        let mut inode: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
        i = (*vctxt).depth;
        while i >= 0 as std::os::raw::c_int {
            if (**(*vctxt).elemInfos.offset(i as isize)).nbNsBindings !=
                   0 as std::os::raw::c_int {
                inode = *(*vctxt).elemInfos.offset(i as isize);
                j = 0 as std::os::raw::c_int;
                while j < (*inode).nbNsBindings * 2 as std::os::raw::c_int {
                    if prefix.is_null() &&
                           (*(*inode).nsBindings.offset(j as isize)).is_null()
                           ||
                           !prefix.is_null() &&
                               xmlStrEqual(prefix,
                                           *(*inode).nsBindings.offset(j as
                                                                           isize))
                                   != 0 {
                        /*
			* Note that the namespace bindings are already
			* in a string dict.
			*/
                        return *(*inode).nsBindings.offset((j +
                                                                1 as
                                                                    std::os::raw::c_int)
                                                               as isize)
                    }
                    j += 2 as std::os::raw::c_int
                }
            }
            i -= 1
        }
        return 0 as *const xmlChar
    } else if !(*vctxt).reader.is_null() {
        let mut nsName: *mut xmlChar = 0 as *mut xmlChar;
        nsName = xmlTextReaderLookupNamespace((*vctxt).reader, prefix);
        if !nsName.is_null() {
            let mut ret: *const xmlChar = 0 as *const xmlChar;
            ret = xmlDictLookup((*vctxt).dict, nsName, -(1 as std::os::raw::c_int));
            xmlFree.expect("non-null function pointer")(nsName as
                                                            *mut std::os::raw::c_void);
            return ret
        } else { return 0 as *const xmlChar }
    } else {
        let mut ns: xmlNsPtr = 0 as *mut xmlNs;
        if (*(*vctxt).inode).node.is_null() ||
               (*(*(*vctxt).inode).node).doc.is_null() {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaLookupNamespace\x00" as *const u8
                                     as *const std::os::raw::c_char,
                                 b"no node or node\'s doc avaliable\x00" as
                                     *const u8 as *const std::os::raw::c_char);
            return 0 as *const xmlChar
        }
        ns =
            xmlSearchNs((*(*(*vctxt).inode).node).doc, (*(*vctxt).inode).node,
                        prefix);
        if !ns.is_null() { return (*ns).href }
        return 0 as *const xmlChar
    };
}
/*
* This one works on the schema of the validation context.
*/
unsafe extern "C" fn xmlSchemaValidateNotation(mut vctxt:
                                                   xmlSchemaValidCtxtPtr,
                                               mut schema: xmlSchemaPtr,
                                               mut node: xmlNodePtr,
                                               mut value: *const xmlChar,
                                               mut val: *mut xmlSchemaValPtr,
                                               mut valNeeded: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    if !vctxt.is_null() && (*vctxt).schema.is_null() {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaValidateNotation\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"a schema is needed on the validation context\x00"
                                 as *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    ret = xmlValidateQName(value, 1 as std::os::raw::c_int);
    if ret != 0 as std::os::raw::c_int { return ret }
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    localName = xmlSplitQName2(value, &mut prefix);
    if !prefix.is_null() {
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        if !vctxt.is_null() {
            nsName = xmlSchemaLookupNamespace(vctxt, prefix)
        } else if !node.is_null() {
            let mut ns: xmlNsPtr = xmlSearchNs((*node).doc, node, prefix);
            if !ns.is_null() { nsName = (*ns).href }
        } else {
            xmlFree.expect("non-null function pointer")(prefix as
                                                            *mut std::os::raw::c_void);
            xmlFree.expect("non-null function pointer")(localName as
                                                            *mut std::os::raw::c_void);
            return 1 as std::os::raw::c_int
        }
        if nsName.is_null() {
            xmlFree.expect("non-null function pointer")(prefix as
                                                            *mut std::os::raw::c_void);
            xmlFree.expect("non-null function pointer")(localName as
                                                            *mut std::os::raw::c_void);
            return 1 as std::os::raw::c_int
        }
        if !xmlSchemaGetNotation(schema, localName, nsName).is_null() {
            if valNeeded != 0 && !val.is_null() {
                *val =
                    xmlSchemaNewNOTATIONValue(xmlStrdup(localName),
                                              xmlStrdup(nsName));
                if (*val).is_null() { ret = -(1 as std::os::raw::c_int) }
            }
        } else { ret = 1 as std::os::raw::c_int }
        xmlFree.expect("non-null function pointer")(prefix as
                                                        *mut std::os::raw::c_void);
        xmlFree.expect("non-null function pointer")(localName as
                                                        *mut std::os::raw::c_void);
    } else if !xmlSchemaGetNotation(schema, value,
                                    0 as *const xmlChar).is_null() {
        if valNeeded != 0 && !val.is_null() {
            *val =
                xmlSchemaNewNOTATIONValue(xmlStrdup(value),
                                          0 as *const xmlChar);
            if (*val).is_null() { ret = -(1 as std::os::raw::c_int) }
        }
    } else { return 1 as std::os::raw::c_int }
    return ret;
}
unsafe extern "C" fn xmlSchemaVAddNodeQName(mut vctxt: xmlSchemaValidCtxtPtr,
                                            mut lname: *const xmlChar,
                                            mut nsname: *const xmlChar)
 -> std::os::raw::c_int {
    let mut i: std::os::raw::c_int = 0;
    lname = xmlDictLookup((*vctxt).dict, lname, -(1 as std::os::raw::c_int));
    if lname.is_null() { return -(1 as std::os::raw::c_int) }
    if !nsname.is_null() {
        nsname = xmlDictLookup((*vctxt).dict, nsname, -(1 as std::os::raw::c_int));
        if nsname.is_null() { return -(1 as std::os::raw::c_int) }
    }
    i = 0 as std::os::raw::c_int;
    while i < (*(*vctxt).nodeQNames).nbItems {
        if *(*(*vctxt).nodeQNames).items.offset(i as isize) ==
               lname as *mut std::os::raw::c_void &&
               *(*(*vctxt).nodeQNames).items.offset((i + 1 as std::os::raw::c_int) as
                                                        isize) ==
                   nsname as *mut std::os::raw::c_void {
            /* Already there */
            return i
        }
        i += 2 as std::os::raw::c_int
    }
    /* Add new entry. */
    i = (*(*vctxt).nodeQNames).nbItems;
    xmlSchemaItemListAdd((*vctxt).nodeQNames, lname as *mut std::os::raw::c_void);
    xmlSchemaItemListAdd((*vctxt).nodeQNames, nsname as *mut std::os::raw::c_void);
    return i;
}
/* ***********************************************************************
 *									*
 *  Validation of identity-constraints (IDC)                            *
 *									*
 ************************************************************************/
/* *
 * xmlSchemaAugmentIDC:
 * @idcDef: the IDC definition
 *
 * Creates an augmented IDC definition item.
 *
 * Returns the item, or NULL on internal errors.
 */
unsafe extern "C" fn xmlSchemaAugmentIDC(mut payload: *mut std::os::raw::c_void,
                                         mut data: *mut std::os::raw::c_void,
                                         mut name: *const xmlChar) {
    let mut idcDef: xmlSchemaIDCPtr = payload as xmlSchemaIDCPtr;
    let mut vctxt: xmlSchemaValidCtxtPtr = data as xmlSchemaValidCtxtPtr;
    let mut aidc: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
    aidc =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaIDCAug>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaIDCAugPtr;
    if aidc.is_null() {
        xmlSchemaVErrMemory(vctxt,
                            b"xmlSchemaAugmentIDC: allocating an augmented IDC definition\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return
    }
    (*aidc).keyrefDepth = -(1 as std::os::raw::c_int);
    (*aidc).def = idcDef;
    (*aidc).next = 0 as xmlSchemaIDCAugPtr;
    if (*vctxt).aidcs.is_null() {
        (*vctxt).aidcs = aidc
    } else { (*aidc).next = (*vctxt).aidcs; (*vctxt).aidcs = aidc }
    /*
    * Save if we have keyrefs at all.
    */
    if (*vctxt).hasKeyrefs == 0 as std::os::raw::c_int &&
           (*idcDef).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int as std::os::raw::c_uint {
        (*vctxt).hasKeyrefs = 1 as std::os::raw::c_int
    };
}
/* *
 * xmlSchemaAugmentImportedIDC:
 * @imported: the imported schema
 *
 * Creates an augmented IDC definition for the imported schema.
 */
unsafe extern "C" fn xmlSchemaAugmentImportedIDC(mut payload:
                                                     *mut std::os::raw::c_void,
                                                 mut data: *mut std::os::raw::c_void,
                                                 mut name: *const xmlChar) {
    let mut imported: xmlSchemaImportPtr = payload as xmlSchemaImportPtr;
    let mut vctxt: xmlSchemaValidCtxtPtr = data as xmlSchemaValidCtxtPtr;
    if !(*(*imported).schema).idcDef.is_null() {
        xmlHashScan((*(*imported).schema).idcDef,
                    Some(xmlSchemaAugmentIDC as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *mut std::os::raw::c_void,
                                                  _: *const xmlChar) -> ()),
                    vctxt as *mut std::os::raw::c_void);
    };
}
/* *
 * xmlSchemaIDCNewBinding:
 * @idcDef: the IDC definition of this binding
 *
 * Creates a new IDC binding.
 *
 * Returns the new IDC binding, NULL on internal errors.
 */
unsafe extern "C" fn xmlSchemaIDCNewBinding(mut idcDef: xmlSchemaIDCPtr)
 -> xmlSchemaPSVIIDCBindingPtr {
    let mut ret: xmlSchemaPSVIIDCBindingPtr =
        0 as *mut xmlSchemaPSVIIDCBinding;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaPSVIIDCBinding>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaPSVIIDCBindingPtr;
    if ret.is_null() {
        xmlSchemaVErrMemory(0 as xmlSchemaValidCtxtPtr,
                            b"allocating a PSVI IDC binding item\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            0 as xmlNodePtr);
        return 0 as xmlSchemaPSVIIDCBindingPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaPSVIIDCBinding>() as std::os::raw::c_ulong);
    (*ret).definition = idcDef;
    return ret;
}
/* *
 * xmlSchemaIDCStoreNodeTableItem:
 * @vctxt: the WXS validation context
 * @item: the IDC node table item
 *
 * The validation context is used to store IDC node table items.
 * They are stored to avoid copying them if IDC node-tables are merged
 * with corresponding parent IDC node-tables (bubbling).
 *
 * Returns 0 if succeeded, -1 on internal errors.
 */
unsafe extern "C" fn xmlSchemaIDCStoreNodeTableItem(mut vctxt:
                                                        xmlSchemaValidCtxtPtr,
                                                    mut item:
                                                        xmlSchemaPSVIIDCNodePtr)
 -> std::os::raw::c_int {
    /*
    * Add to gobal list.
    */
    if (*vctxt).idcNodes.is_null() {
        (*vctxt).idcNodes =
            xmlMalloc.expect("non-null function pointer")((20 as std::os::raw::c_int
                                                               as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut xmlSchemaPSVIIDCNodePtr;
        if (*vctxt).idcNodes.is_null() {
            xmlSchemaVErrMemory(vctxt,
                                b"allocating the IDC node table item list\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
        (*vctxt).sizeIdcNodes = 20 as std::os::raw::c_int
    } else if (*vctxt).sizeIdcNodes <= (*vctxt).nbIdcNodes {
        (*vctxt).sizeIdcNodes *= 2 as std::os::raw::c_int;
        (*vctxt).idcNodes =
            xmlRealloc.expect("non-null function pointer")((*vctxt).idcNodes
                                                               as
                                                               *mut std::os::raw::c_void,
                                                           ((*vctxt).sizeIdcNodes
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut xmlSchemaPSVIIDCNodePtr;
        if (*vctxt).idcNodes.is_null() {
            xmlSchemaVErrMemory(vctxt,
                                b"re-allocating the IDC node table item list\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
    }
    let fresh24 = (*vctxt).nbIdcNodes;
    (*vctxt).nbIdcNodes = (*vctxt).nbIdcNodes + 1;
    let ref mut fresh25 = *(*vctxt).idcNodes.offset(fresh24 as isize);
    *fresh25 = item;
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaIDCStoreKey:
 * @vctxt: the WXS validation context
 * @item: the IDC key
 *
 * The validation context is used to store an IDC key.
 *
 * Returns 0 if succeeded, -1 on internal errors.
 */
unsafe extern "C" fn xmlSchemaIDCStoreKey(mut vctxt: xmlSchemaValidCtxtPtr,
                                          mut key: xmlSchemaPSVIIDCKeyPtr)
 -> std::os::raw::c_int {
    /*
    * Add to gobal list.
    */
    if (*vctxt).idcKeys.is_null() {
        (*vctxt).idcKeys =
            xmlMalloc.expect("non-null function pointer")((40 as std::os::raw::c_int
                                                               as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut xmlSchemaPSVIIDCKeyPtr;
        if (*vctxt).idcKeys.is_null() {
            xmlSchemaVErrMemory(vctxt,
                                b"allocating the IDC key storage list\x00" as
                                    *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
        (*vctxt).sizeIdcKeys = 40 as std::os::raw::c_int
    } else if (*vctxt).sizeIdcKeys <= (*vctxt).nbIdcKeys {
        (*vctxt).sizeIdcKeys *= 2 as std::os::raw::c_int;
        (*vctxt).idcKeys =
            xmlRealloc.expect("non-null function pointer")((*vctxt).idcKeys as
                                                               *mut std::os::raw::c_void,
                                                           ((*vctxt).sizeIdcKeys
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut xmlSchemaPSVIIDCKeyPtr;
        if (*vctxt).idcKeys.is_null() {
            xmlSchemaVErrMemory(vctxt,
                                b"re-allocating the IDC key storage list\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
    }
    let fresh26 = (*vctxt).nbIdcKeys;
    (*vctxt).nbIdcKeys = (*vctxt).nbIdcKeys + 1;
    let ref mut fresh27 = *(*vctxt).idcKeys.offset(fresh26 as isize);
    *fresh27 = key;
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaIDCAppendNodeTableItem:
 * @bind: the IDC binding
 * @ntItem: the node-table item
 *
 * Appends the IDC node-table item to the binding.
 *
 * Returns 0 on success and -1 on internal errors.
 */
unsafe extern "C" fn xmlSchemaIDCAppendNodeTableItem(mut bind:
                                                         xmlSchemaPSVIIDCBindingPtr,
                                                     mut ntItem:
                                                         xmlSchemaPSVIIDCNodePtr)
 -> std::os::raw::c_int {
    if (*bind).nodeTable.is_null() {
        (*bind).sizeNodes = 10 as std::os::raw::c_int;
        (*bind).nodeTable =
            xmlMalloc.expect("non-null function pointer")((10 as std::os::raw::c_int
                                                               as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut xmlSchemaPSVIIDCNodePtr;
        if (*bind).nodeTable.is_null() {
            xmlSchemaVErrMemory(0 as xmlSchemaValidCtxtPtr,
                                b"allocating an array of IDC node-table items\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
    } else if (*bind).sizeNodes <= (*bind).nbNodes {
        (*bind).sizeNodes *= 2 as std::os::raw::c_int;
        (*bind).nodeTable =
            xmlRealloc.expect("non-null function pointer")((*bind).nodeTable
                                                               as
                                                               *mut std::os::raw::c_void,
                                                           ((*bind).sizeNodes
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut xmlSchemaPSVIIDCNodePtr;
        if (*bind).nodeTable.is_null() {
            xmlSchemaVErrMemory(0 as xmlSchemaValidCtxtPtr,
                                b"re-allocating an array of IDC node-table items\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
    }
    let fresh28 = (*bind).nbNodes;
    (*bind).nbNodes = (*bind).nbNodes + 1;
    let ref mut fresh29 = *(*bind).nodeTable.offset(fresh28 as isize);
    *fresh29 = ntItem;
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaIDCAcquireBinding:
 * @vctxt: the WXS validation context
 * @matcher: the IDC matcher
 *
 * Looks up an PSVI IDC binding, for the IDC definition and
 * of the given matcher. If none found, a new one is created
 * and added to the IDC table.
 *
 * Returns an IDC binding or NULL on internal errors.
 */
unsafe extern "C" fn xmlSchemaIDCAcquireBinding(mut vctxt:
                                                    xmlSchemaValidCtxtPtr,
                                                mut matcher:
                                                    xmlSchemaIDCMatcherPtr)
 -> xmlSchemaPSVIIDCBindingPtr {
    let mut ielem: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
    ielem = *(*vctxt).elemInfos.offset((*matcher).depth as isize);
    if (*ielem).idcTable.is_null() {
        (*ielem).idcTable = xmlSchemaIDCNewBinding((*(*matcher).aidc).def);
        if (*ielem).idcTable.is_null() {
            return 0 as xmlSchemaPSVIIDCBindingPtr
        }
        return (*ielem).idcTable
    } else {
        let mut bind: xmlSchemaPSVIIDCBindingPtr =
            0 as xmlSchemaPSVIIDCBindingPtr;
        bind = (*ielem).idcTable;
        loop  {
            if (*bind).definition == (*(*matcher).aidc).def { return bind }
            if (*bind).next.is_null() {
                (*bind).next = xmlSchemaIDCNewBinding((*(*matcher).aidc).def);
                if (*bind).next.is_null() {
                    return 0 as xmlSchemaPSVIIDCBindingPtr
                }
                return (*bind).next
            }
            bind = (*bind).next;
            if bind.is_null() { break ; }
        }
    }
    return 0 as xmlSchemaPSVIIDCBindingPtr;
}
unsafe extern "C" fn xmlSchemaIDCAcquireTargetList(mut vctxt:
                                                       xmlSchemaValidCtxtPtr,
                                                   mut matcher:
                                                       xmlSchemaIDCMatcherPtr)
 -> xmlSchemaItemListPtr {
    if (*matcher).targets.is_null() {
        (*matcher).targets = xmlSchemaItemListCreate()
    }
    return (*matcher).targets;
}
/* *
 * xmlSchemaIDCFreeKey:
 * @key: the IDC key
 *
 * Frees an IDC key together with its compiled value.
 */
unsafe extern "C" fn xmlSchemaIDCFreeKey(mut key: xmlSchemaPSVIIDCKeyPtr) {
    if !(*key).val.is_null() { xmlSchemaFreeValue((*key).val); }
    xmlFree.expect("non-null function pointer")(key as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaIDCFreeBinding:
 *
 * Frees an IDC binding. Note that the node table-items
 * are not freed.
 */
unsafe extern "C" fn xmlSchemaIDCFreeBinding(mut bind:
                                                 xmlSchemaPSVIIDCBindingPtr) {
    if !(*bind).nodeTable.is_null() {
        xmlFree.expect("non-null function pointer")((*bind).nodeTable as
                                                        *mut std::os::raw::c_void);
    }
    if !(*bind).dupls.is_null() { xmlSchemaItemListFree((*bind).dupls); }
    xmlFree.expect("non-null function pointer")(bind as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaIDCFreeIDCTable:
 * @bind: the first IDC binding in the list
 *
 * Frees an IDC table, i.e. all the IDC bindings in the list.
 */
unsafe extern "C" fn xmlSchemaIDCFreeIDCTable(mut bind:
                                                  xmlSchemaPSVIIDCBindingPtr) {
    let mut prev: xmlSchemaPSVIIDCBindingPtr =
        0 as *mut xmlSchemaPSVIIDCBinding;
    while !bind.is_null() {
        prev = bind;
        bind = (*bind).next;
        xmlSchemaIDCFreeBinding(prev);
    };
}
/* *
 * xmlSchemaIDCFreeMatcherList:
 * @matcher: the first IDC matcher in the list
 *
 * Frees a list of IDC matchers.
 */
unsafe extern "C" fn xmlSchemaIDCFreeMatcherList(mut matcher:
                                                     xmlSchemaIDCMatcherPtr) {
    let mut next: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    while !matcher.is_null() {
        next = (*matcher).next;
        if !(*matcher).keySeqs.is_null() {
            let mut i: std::os::raw::c_int = 0;
            i = 0 as std::os::raw::c_int;
            while i < (*matcher).sizeKeySeqs {
                if !(*(*matcher).keySeqs.offset(i as isize)).is_null() {
                    xmlFree.expect("non-null function pointer")(*(*matcher).keySeqs.offset(i
                                                                                               as
                                                                                               isize)
                                                                    as
                                                                    *mut std::os::raw::c_void);
                }
                i += 1
            }
            xmlFree.expect("non-null function pointer")((*matcher).keySeqs as
                                                            *mut std::os::raw::c_void);
        }
        if !(*matcher).targets.is_null() {
            if (*matcher).idcType == XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int
               {
                let mut i_0: std::os::raw::c_int = 0;
                let mut idcNode: xmlSchemaPSVIIDCNodePtr =
                    0 as *mut xmlSchemaPSVIIDCNode;
                /*
		* Node-table items for keyrefs are not stored globally
		* to the validation context, since they are not bubbled.
		* We need to free them here.
		*/
                i_0 = 0 as std::os::raw::c_int;
                while i_0 < (*(*matcher).targets).nbItems {
                    idcNode =
                        *(*(*matcher).targets).items.offset(i_0 as isize) as
                            xmlSchemaPSVIIDCNodePtr;
                    xmlFree.expect("non-null function pointer")((*idcNode).keys
                                                                    as
                                                                    *mut std::os::raw::c_void);
                    xmlFree.expect("non-null function pointer")(idcNode as
                                                                    *mut std::os::raw::c_void);
                    i_0 += 1
                }
            }
            xmlSchemaItemListFree((*matcher).targets);
        }
        xmlFree.expect("non-null function pointer")(matcher as
                                                        *mut std::os::raw::c_void);
        matcher = next
    };
}
/* *
 * xmlSchemaIDCReleaseMatcherList:
 * @vctxt: the WXS validation context
 * @matcher: the first IDC matcher in the list
 *
 * Caches a list of IDC matchers for reuse.
 */
unsafe extern "C" fn xmlSchemaIDCReleaseMatcherList(mut vctxt:
                                                        xmlSchemaValidCtxtPtr,
                                                    mut matcher:
                                                        xmlSchemaIDCMatcherPtr) {
    let mut next: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    while !matcher.is_null() {
        next = (*matcher).next;
        if !(*matcher).keySeqs.is_null() {
            let mut i: std::os::raw::c_int = 0;
            /*
	    * Don't free the array, but only the content.
	    */
            i = 0 as std::os::raw::c_int;
            while i < (*matcher).sizeKeySeqs {
                if !(*(*matcher).keySeqs.offset(i as isize)).is_null() {
                    xmlFree.expect("non-null function pointer")(*(*matcher).keySeqs.offset(i
                                                                                               as
                                                                                               isize)
                                                                    as
                                                                    *mut std::os::raw::c_void);
                    let ref mut fresh30 =
                        *(*matcher).keySeqs.offset(i as isize);
                    *fresh30 = 0 as *mut xmlSchemaPSVIIDCKeyPtr
                }
                i += 1
            }
        }
        if !(*matcher).targets.is_null() {
            if (*matcher).idcType == XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int
               {
                let mut i_0: std::os::raw::c_int = 0;
                let mut idcNode: xmlSchemaPSVIIDCNodePtr =
                    0 as *mut xmlSchemaPSVIIDCNode;
                /*
		* Node-table items for keyrefs are not stored globally
		* to the validation context, since they are not bubbled.
		* We need to free them here.
		*/
                i_0 = 0 as std::os::raw::c_int;
                while i_0 < (*(*matcher).targets).nbItems {
                    idcNode =
                        *(*(*matcher).targets).items.offset(i_0 as isize) as
                            xmlSchemaPSVIIDCNodePtr;
                    xmlFree.expect("non-null function pointer")((*idcNode).keys
                                                                    as
                                                                    *mut std::os::raw::c_void);
                    xmlFree.expect("non-null function pointer")(idcNode as
                                                                    *mut std::os::raw::c_void);
                    i_0 += 1
                }
            }
            xmlSchemaItemListFree((*matcher).targets);
            (*matcher).targets = 0 as xmlSchemaItemListPtr
        }
        (*matcher).next = 0 as xmlSchemaIDCMatcherPtr;
        /*
	* Cache the matcher.
	*/
        if !(*vctxt).idcMatcherCache.is_null() {
            (*matcher).nextCached = (*vctxt).idcMatcherCache
        }
        (*vctxt).idcMatcherCache = matcher;
        matcher = next
    };
}
/* *
 * xmlSchemaIDCAddStateObject:
 * @vctxt: the WXS validation context
 * @matcher: the IDC matcher
 * @sel: the XPath information
 * @parent: the parent "selector" state object if any
 * @type: "selector" or "field"
 *
 * Creates/reuses and activates state objects for the given
 * XPath information; if the XPath expression consists of unions,
 * multiple state objects are created for every unioned expression.
 *
 * Returns 0 on success and -1 on internal errors.
 */
unsafe extern "C" fn xmlSchemaIDCAddStateObject(mut vctxt:
                                                    xmlSchemaValidCtxtPtr,
                                                mut matcher:
                                                    xmlSchemaIDCMatcherPtr,
                                                mut sel:
                                                    xmlSchemaIDCSelectPtr,
                                                mut type_0: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    /*
    * Reuse the state objects from the pool.
    */
    if !(*vctxt).xpathStatePool.is_null() {
        sto = (*vctxt).xpathStatePool;
        (*vctxt).xpathStatePool = (*sto).next;
        (*sto).next = 0 as xmlSchemaIDCStateObjPtr
    } else {
        /*
	* Create a new state object.
	*/
        sto =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaIDCStateObj>()
                                                              as
                                                              std::os::raw::c_ulong)
                as xmlSchemaIDCStateObjPtr;
        if sto.is_null() {
            xmlSchemaVErrMemory(0 as xmlSchemaValidCtxtPtr,
                                b"allocating an IDC state object\x00" as
                                    *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return -(1 as std::os::raw::c_int)
        }
        memset(sto as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
               ::std::mem::size_of::<xmlSchemaIDCStateObj>() as
                   std::os::raw::c_ulong);
    }
    /*
    * Add to global list.
    */
    if !(*vctxt).xpathStates.is_null() { (*sto).next = (*vctxt).xpathStates }
    (*vctxt).xpathStates = sto;
    /*
    * Free the old xpath validation context.
    */
    if !(*sto).xpathCtxt.is_null() {
        xmlFreeStreamCtxt((*sto).xpathCtxt as xmlStreamCtxtPtr);
    }
    /*
    * Create a new XPath (pattern) validation context.
    */
    (*sto).xpathCtxt =
        xmlPatternGetStreamCtxt((*sel).xpathComp as xmlPatternPtr) as
            *mut std::os::raw::c_void;
    if (*sto).xpathCtxt.is_null() {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaIDCAddStateObject\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"failed to create an XPath validation context\x00"
                                 as *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    (*sto).type_0 = type_0;
    (*sto).depth = (*vctxt).depth;
    (*sto).matcher = matcher;
    (*sto).sel = sel;
    (*sto).nbHistory = 0 as std::os::raw::c_int;
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaXPathEvaluate:
 * @vctxt: the WXS validation context
 * @nodeType: the nodeType of the current node
 *
 * Evaluates all active XPath state objects.
 *
 * Returns the number of IC "field" state objects which resolved to
 * this node, 0 if none resolved and -1 on internal errors.
 */
unsafe extern "C" fn xmlSchemaXPathEvaluate(mut vctxt: xmlSchemaValidCtxtPtr,
                                            mut nodeType: xmlElementType)
 -> std::os::raw::c_int {
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut head: xmlSchemaIDCStateObjPtr = 0 as xmlSchemaIDCStateObjPtr;
    let mut first: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut res: std::os::raw::c_int = 0;
    let mut resolved: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut depth: std::os::raw::c_int = (*vctxt).depth;
    if (*vctxt).xpathStates.is_null() { return 0 as std::os::raw::c_int }
    if nodeType as std::os::raw::c_uint ==
           XML_ATTRIBUTE_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        depth += 1
    }
    /*
    * Process all active XPath state objects.
    */
    first = (*vctxt).xpathStates;
    sto = first;
    while sto != head {
        if nodeType as std::os::raw::c_uint ==
               XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
            res =
                xmlStreamPush((*sto).xpathCtxt as xmlStreamCtxtPtr,
                              (*(*vctxt).inode).localName,
                              (*(*vctxt).inode).nsName)
        } else {
            res =
                xmlStreamPushAttr((*sto).xpathCtxt as xmlStreamCtxtPtr,
                                  (*(*vctxt).inode).localName,
                                  (*(*vctxt).inode).nsName)
        }
        if res == -(1 as std::os::raw::c_int) {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaXPathEvaluate\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 b"calling xmlStreamPush()\x00" as *const u8
                                     as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        if !(res == 0 as std::os::raw::c_int) {
            /*
	* Full match.
	*/
            /*
	* Register a match in the state object history.
	*/
            if (*sto).history.is_null() {
                (*sto).history =
                    xmlMalloc.expect("non-null function pointer")((5 as
                                                                       std::os::raw::c_int
                                                                       as
                                                                       std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_int>()
                                                                                                       as
                                                                                                       std::os::raw::c_ulong))
                        as *mut std::os::raw::c_int;
                if (*sto).history.is_null() {
                    xmlSchemaVErrMemory(0 as xmlSchemaValidCtxtPtr,
                                        b"allocating the state object history\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as xmlNodePtr);
                    return -(1 as std::os::raw::c_int)
                }
                (*sto).sizeHistory = 5 as std::os::raw::c_int
            } else if (*sto).sizeHistory <= (*sto).nbHistory {
                (*sto).sizeHistory *= 2 as std::os::raw::c_int;
                (*sto).history =
                    xmlRealloc.expect("non-null function pointer")((*sto).history
                                                                       as
                                                                       *mut std::os::raw::c_void,
                                                                   ((*sto).sizeHistory
                                                                        as
                                                                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_int>()
                                                                                                        as
                                                                                                        std::os::raw::c_ulong))
                        as *mut std::os::raw::c_int;
                if (*sto).history.is_null() {
                    xmlSchemaVErrMemory(0 as xmlSchemaValidCtxtPtr,
                                        b"re-allocating the state object history\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as xmlNodePtr);
                    return -(1 as std::os::raw::c_int)
                }
            }
            let fresh31 = (*sto).nbHistory;
            (*sto).nbHistory = (*sto).nbHistory + 1;
            *(*sto).history.offset(fresh31 as isize) = depth;
            if (*sto).type_0 == 1 as std::os::raw::c_int {
                let mut sel: xmlSchemaIDCSelectPtr =
                    0 as *mut xmlSchemaIDCSelect;
                /*
	    * Activate state objects for the IDC fields of
	    * the IDC selector.
	    */
                sel = (*(*(*(*sto).matcher).aidc).def).fields;
                while !sel.is_null() {
                    if xmlSchemaIDCAddStateObject(vctxt, (*sto).matcher, sel,
                                                  2 as std::os::raw::c_int) ==
                           -(1 as std::os::raw::c_int) {
                        return -(1 as std::os::raw::c_int)
                    }
                    sel = (*sel).next
                }
            } else if (*sto).type_0 == 2 as std::os::raw::c_int {
                /*
	    * An IDC key node was found by the IDC field.
	    */
                /*
	    * Notify that the character value of this node is
	    * needed.
	    */
                if resolved == 0 as std::os::raw::c_int {
                    if (*(*vctxt).inode).flags &
                           (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                        (*(*vctxt).inode).flags |=
                            (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int
                    }
                }
                resolved += 1
            }
        }
        if (*sto).next.is_null() {
            /*
	    * Evaluate field state objects created on this node as well.
	    */
            head = first;
            sto = (*vctxt).xpathStates
        } else { sto = (*sto).next }
    }
    return resolved;
}
unsafe extern "C" fn xmlSchemaFormatIDCKeySequence(mut vctxt:
                                                       xmlSchemaValidCtxtPtr,
                                                   mut buf: *mut *mut xmlChar,
                                                   mut seq:
                                                       *mut xmlSchemaPSVIIDCKeyPtr,
                                                   mut count: std::os::raw::c_int)
 -> *const xmlChar {
    let mut i: std::os::raw::c_int = 0;
    let mut res: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    *buf =
        xmlStrdup(b"[\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    i = 0 as std::os::raw::c_int;
    while i < count {
        *buf =
            xmlStrcat(*buf,
                      b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        res =
            xmlSchemaGetCanonValueWhtspExt((**seq.offset(i as isize)).val,
                                           xmlSchemaGetWhiteSpaceFacetValue((**seq.offset(i
                                                                                              as
                                                                                              isize)).type_0),
                                           &mut value);
        if res == 0 as std::os::raw::c_int {
            *buf = xmlStrcat(*buf, value)
        } else {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaFormatIDCKeySequence\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"failed to compute a canonical value\x00" as
                                     *const u8 as *const std::os::raw::c_char);
            *buf =
                xmlStrcat(*buf,
                          b"???\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar)
        }
        if i < count - 1 as std::os::raw::c_int {
            *buf =
                xmlStrcat(*buf,
                          b"\', \x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar)
        } else {
            *buf =
                xmlStrcat(*buf,
                          b"\'\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar)
        }
        if !value.is_null() {
            xmlFree.expect("non-null function pointer")(value as
                                                            *mut std::os::raw::c_void);
            value = 0 as *mut xmlChar
        }
        i += 1
    }
    *buf =
        xmlStrcat(*buf,
                  b"]\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    return *buf;
}
/* *
 * xmlSchemaXPathPop:
 * @vctxt: the WXS validation context
 *
 * Pops all XPath states.
 *
 * Returns 0 on success and -1 on internal errors.
 */
unsafe extern "C" fn xmlSchemaXPathPop(mut vctxt: xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut res: std::os::raw::c_int = 0;
    if (*vctxt).xpathStates.is_null() { return 0 as std::os::raw::c_int }
    sto = (*vctxt).xpathStates;
    loop  {
        res = xmlStreamPop((*sto).xpathCtxt as xmlStreamCtxtPtr);
        if res == -(1 as std::os::raw::c_int) { return -(1 as std::os::raw::c_int) }
        sto = (*sto).next;
        if sto.is_null() { break ; }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaXPathProcessHistory:
 * @vctxt: the WXS validation context
 * @type: the simple/complex type of the current node if any at all
 * @val: the precompiled value
 *
 * Processes and pops the history items of the IDC state objects.
 * IDC key-sequences are validated/created on IDC bindings.
 *
 * Returns 0 on success and -1 on internal errors.
 */
unsafe extern "C" fn xmlSchemaXPathProcessHistory(mut vctxt:
                                                      xmlSchemaValidCtxtPtr,
                                                  mut depth: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut nextsto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut res: std::os::raw::c_int = 0;
    let mut matchDepth: std::os::raw::c_int = 0;
    let mut key: xmlSchemaPSVIIDCKeyPtr = 0 as xmlSchemaPSVIIDCKeyPtr;
    let mut type_0: xmlSchemaTypePtr = (*(*vctxt).inode).typeDef;
    let mut simpleType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    if (*vctxt).xpathStates.is_null() { return 0 as std::os::raw::c_int }
    sto = (*vctxt).xpathStates;
    /*
    * Evaluate the state objects.
    */
    while !sto.is_null() {
        res =
            xmlStreamPop((*sto).xpathCtxt as
                             xmlStreamCtxtPtr); /* while (sto != NULL) */
        if res == -(1 as std::os::raw::c_int) {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaXPathProcessHistory\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"calling xmlStreamPop()\x00" as *const u8 as
                                     *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        if !((*sto).nbHistory == 0 as std::os::raw::c_int) {
            matchDepth =
                *(*sto).history.offset(((*sto).nbHistory - 1 as std::os::raw::c_int)
                                           as isize);
            /*
	* Only matches at the current depth are of interest.
	*/
            if matchDepth != depth {
                sto = (*sto).next; /* if selector */
                continue ;
            } else {
                if (*sto).type_0 == 2 as std::os::raw::c_int {
                    /*
	    * NOTE: According to
	    *   http://www.w3.org/Bugs/Public/show_bug.cgi?id=2198
	    *   ... the simple-content of complex types is also allowed.
	    */
                    if (*type_0).type_0 as std::os::raw::c_uint ==
                           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as
                               std::os::raw::c_uint ||
                           (*type_0).builtInType ==
                               XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
                        if (*type_0).contentType as std::os::raw::c_uint ==
                               XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as
                                   std::os::raw::c_uint ||
                               (*type_0).contentType as std::os::raw::c_uint ==
                                   XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as
                                       std::os::raw::c_uint {
                            /*
		    * Sanity check for complex types with simple content.
		    */
                            simpleType = (*type_0).contentTypeDef;
                            if simpleType.is_null() {
                                xmlSchemaInternalErr(vctxt as
                                                         xmlSchemaAbstractCtxtPtr,
                                                     b"xmlSchemaXPathProcessHistory\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char,
                                                     b"field resolves to a CT with simple content but the CT is missing the ST definition\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char);
                                return -(1 as std::os::raw::c_int)
                            }
                        } else { simpleType = 0 as xmlSchemaTypePtr }
                    } else { simpleType = type_0 }
                    if simpleType.is_null() {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        /*
		* Not qualified if the field resolves to a node of non
		* simple type.
		*/
                        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                           XML_SCHEMAV_CVC_IDC,
                                           0 as xmlNodePtr,
                                           (*(*(*sto).matcher).aidc).def as
                                               xmlSchemaBasicItemPtr,
                                           b"The XPath \'%s\' of a field of %s does evaluate to a node of non-simple type\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           (*(*sto).sel).xpath,
                                           xmlSchemaGetIDCDesignation(&mut str,
                                                                      (*(*(*sto).matcher).aidc).def));
                        if !str.is_null() {
                            xmlFree.expect("non-null function pointer")(str as
                                                                            *mut std::os::raw::c_void);
                            str = 0 as *mut xmlChar
                        }
                        (*sto).nbHistory -= 1;
                        current_block = 6025644545439772602;
                    } else if key.is_null() && (*(*vctxt).inode).val.is_null()
                     {
                        /*
		* Failed to provide the normalized value; maybe
		* the value was invalid.
		*/
                        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                           XML_SCHEMAV_CVC_IDC,
                                           0 as xmlNodePtr,
                                           (*(*(*sto).matcher).aidc).def as
                                               xmlSchemaBasicItemPtr,
                                           b"Warning: No precomputed value available, the value was either invalid or something strange happend\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           0 as *const xmlChar,
                                           0 as *const xmlChar);
                        (*sto).nbHistory -= 1;
                        current_block = 6025644545439772602;
                    } else {
                        let mut matcher: xmlSchemaIDCMatcherPtr =
                            (*sto).matcher;
                        let mut keySeq: *mut xmlSchemaPSVIIDCKeyPtr =
                            0 as *mut xmlSchemaPSVIIDCKeyPtr;
                        let mut pos: std::os::raw::c_int = 0;
                        let mut idx: std::os::raw::c_int = 0;
                        /*
		* The key will be anchored on the matcher's list of
		* key-sequences. The position in this list is determined
		* by the target node's depth relative to the matcher's
		* depth of creation (i.e. the depth of the scope element).
		*
		* Element        Depth    Pos   List-entries
		* <scope>          0              NULL
		*   <bar>          1              NULL
		*     <target/>    2       2      target
		*   <bar>
                * </scope>
		*
		* The size of the list is only dependant on the depth of
		* the tree.
		* An entry will be NULLed in selector_leave, i.e. when
		* we hit the target's
		*/
                        pos = (*sto).depth - (*matcher).depth;
                        idx = (*(*sto).sel).index;
                        /*
		* Create/grow the array of key-sequences.
		*/
                        if (*matcher).keySeqs.is_null() {
                            if pos > 9 as std::os::raw::c_int {
                                (*matcher).sizeKeySeqs =
                                    pos * 2 as std::os::raw::c_int
                            } else {
                                (*matcher).sizeKeySeqs = 10 as std::os::raw::c_int
                            }
                            (*matcher).keySeqs =
                                xmlMalloc.expect("non-null function pointer")(((*matcher).sizeKeySeqs
                                                                                   as
                                                                                   std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>()
                                                                                                                   as
                                                                                                                   std::os::raw::c_ulong))
                                    as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                            if (*matcher).keySeqs.is_null() {
                                xmlSchemaVErrMemory(0 as
                                                        xmlSchemaValidCtxtPtr,
                                                    b"allocating an array of key-sequences\x00"
                                                        as *const u8 as
                                                        *const std::os::raw::c_char,
                                                    0 as xmlNodePtr);
                                return -(1 as std::os::raw::c_int)
                            }
                            memset((*matcher).keySeqs as *mut std::os::raw::c_void,
                                   0 as std::os::raw::c_int,
                                   ((*matcher).sizeKeySeqs as
                                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>()
                                                                        as
                                                                        std::os::raw::c_ulong));
                        } else if pos >= (*matcher).sizeKeySeqs {
                            let mut i: std::os::raw::c_int = (*matcher).sizeKeySeqs;
                            (*matcher).sizeKeySeqs *= 2 as std::os::raw::c_int;
                            (*matcher).keySeqs =
                                xmlRealloc.expect("non-null function pointer")((*matcher).keySeqs
                                                                                   as
                                                                                   *mut std::os::raw::c_void,
                                                                               ((*matcher).sizeKeySeqs
                                                                                    as
                                                                                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>()
                                                                                                                    as
                                                                                                                    std::os::raw::c_ulong))
                                    as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                            if (*matcher).keySeqs.is_null() {
                                xmlSchemaVErrMemory(0 as
                                                        xmlSchemaValidCtxtPtr,
                                                    b"reallocating an array of key-sequences\x00"
                                                        as *const u8 as
                                                        *const std::os::raw::c_char,
                                                    0 as xmlNodePtr);
                                return -(1 as std::os::raw::c_int)
                            }
                            /*
		    * The array needs to be NULLed.
		    * TODO: Use memset?
		    */
                            while i < (*matcher).sizeKeySeqs {
                                let ref mut fresh32 =
                                    *(*matcher).keySeqs.offset(i as isize);
                                *fresh32 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                i += 1
                            }
                        }
                        /*
		* Get/create the key-sequence.
		*/
                        keySeq = *(*matcher).keySeqs.offset(pos as isize);
                        if keySeq.is_null() {
                            /*
		* Create a key-sequence.
		*/
                            keySeq =
                                xmlMalloc.expect("non-null function pointer")(((*(*(*matcher).aidc).def).nbFields
                                                                                   as
                                                                                   std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>()
                                                                                                                   as
                                                                                                                   std::os::raw::c_ulong))
                                    as *mut xmlSchemaPSVIIDCKeyPtr;
                            if keySeq.is_null() {
                                xmlSchemaVErrMemory(0 as
                                                        xmlSchemaValidCtxtPtr,
                                                    b"allocating an IDC key-sequence\x00"
                                                        as *const u8 as
                                                        *const std::os::raw::c_char,
                                                    0 as xmlNodePtr);
                                return -(1 as std::os::raw::c_int)
                            }
                            memset(keySeq as *mut std::os::raw::c_void,
                                   0 as std::os::raw::c_int,
                                   ((*(*(*matcher).aidc).def).nbFields as
                                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>()
                                                                        as
                                                                        std::os::raw::c_ulong));
                            let ref mut fresh33 =
                                *(*matcher).keySeqs.offset(pos as isize);
                            *fresh33 = keySeq;
                            current_block = 3870374623037567698;
                        } else if !(*keySeq.offset(idx as isize)).is_null() {
                            let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                            /*
		    * cvc-identity-constraint:
		    * 3 For each node in the `target node set` all
		    * of the {fields}, with that node as the context
		    * node, evaluate to either an empty node-set or
		    * a node-set with exactly one member, which must
		    * have a simple type.
		    *
		    * The key was already set; report an error.
		    */
                            xmlSchemaCustomErr(vctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               XML_SCHEMAV_CVC_IDC,
                                               0 as xmlNodePtr,
                                               (*(*matcher).aidc).def as
                                                   xmlSchemaBasicItemPtr,
                                               b"The XPath \'%s\' of a field of %s evaluates to a node-set with more than one member\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               (*(*sto).sel).xpath,
                                               xmlSchemaGetIDCDesignation(&mut str_0,
                                                                          (*(*matcher).aidc).def));
                            if !str_0.is_null() {
                                xmlFree.expect("non-null function pointer")(str_0
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                str_0 = 0 as *mut xmlChar
                            }
                            (*sto).nbHistory -= 1;
                            current_block = 6025644545439772602;
                        } else { current_block = 3870374623037567698; }
                        match current_block {
                            6025644545439772602 => { }
                            _ => {
                                /*
		* Create a key once per node only.
		*/
                                if key.is_null() {
                                    key =
                                        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaPSVIIDCKey>()
                                                                                          as
                                                                                          std::os::raw::c_ulong)
                                            as xmlSchemaPSVIIDCKeyPtr;
                                    if key.is_null() {
                                        xmlSchemaVErrMemory(0 as
                                                                xmlSchemaValidCtxtPtr,
                                                            b"allocating a IDC key\x00"
                                                                as *const u8
                                                                as
                                                                *const std::os::raw::c_char,
                                                            0 as xmlNodePtr);
                                        xmlFree.expect("non-null function pointer")(keySeq
                                                                                        as
                                                                                        *mut std::os::raw::c_void);
                                        let ref mut fresh34 =
                                            *(*matcher).keySeqs.offset(pos as
                                                                           isize);
                                        *fresh34 =
                                            0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                        return -(1 as std::os::raw::c_int)
                                    }
                                    /*
		    * Consume the compiled value.
		    */
                                    (*key).type_0 = simpleType;
                                    (*key).val = (*(*vctxt).inode).val;
                                    (*(*vctxt).inode).val =
                                        0 as xmlSchemaValPtr;
                                    /*
		    * Store the key in a global list.
		    */
                                    if xmlSchemaIDCStoreKey(vctxt, key) ==
                                           -(1 as std::os::raw::c_int) {
                                        xmlSchemaIDCFreeKey(key);
                                        return -(1 as std::os::raw::c_int)
                                    }
                                }
                                let ref mut fresh35 =
                                    *keySeq.offset(idx as isize);
                                *fresh35 = key;
                                current_block = 1587619384396752891;
                            }
                        }
                    }
                } else if (*sto).type_0 == 1 as std::os::raw::c_int {
                    let mut keySeq_0: *mut *mut xmlSchemaPSVIIDCKeyPtr =
                        0 as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                    /* xmlSchemaPSVIIDCBindingPtr bind; */
                    let mut ntItem: xmlSchemaPSVIIDCNodePtr =
                        0 as *mut xmlSchemaPSVIIDCNode;
                    let mut matcher_0: xmlSchemaIDCMatcherPtr =
                        0 as *mut xmlSchemaIDCMatcher;
                    let mut idc: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
                    let mut targets: xmlSchemaItemListPtr =
                        0 as *mut xmlSchemaItemList;
                    let mut pos_0: std::os::raw::c_int = 0;
                    let mut i_0: std::os::raw::c_int = 0;
                    let mut j: std::os::raw::c_int = 0;
                    let mut nbKeys: std::os::raw::c_int = 0;
                    /*
	    * Here we have the following scenario:
	    * An IDC 'selector' state object resolved to a target node,
	    * during the time this target node was in the
	    * ancestor-or-self axis, the 'field' state object(s) looked
	    * out for matching nodes to create a key-sequence for this
	    * target node. Now we are back to this target node and need
	    * to put the key-sequence, together with the target node
	    * itself, into the node-table of the corresponding IDC
	    * binding.
	    */
                    matcher_0 = (*sto).matcher;
                    idc = (*(*matcher_0).aidc).def;
                    nbKeys = (*idc).nbFields;
                    pos_0 = depth - (*matcher_0).depth;
                    /*
	    * Check if the matcher has any key-sequences at all, plus
	    * if it has a key-sequence for the current target node.
	    */
                    if (*matcher_0).keySeqs.is_null() ||
                           (*matcher_0).sizeKeySeqs <= pos_0 {
                        if (*idc).type_0 as std::os::raw::c_uint ==
                               XML_SCHEMA_TYPE_IDC_KEY as std::os::raw::c_int as
                                   std::os::raw::c_uint {
                            current_block = 1962330074042525963;
                        } else { current_block = 5786773664909485737; }
                    } else {
                        keySeq_0 =
                            &mut *(*matcher_0).keySeqs.offset(pos_0 as isize)
                                as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                        if (*keySeq_0).is_null() {
                            if (*idc).type_0 as std::os::raw::c_uint ==
                                   XML_SCHEMA_TYPE_IDC_KEY as std::os::raw::c_int as
                                       std::os::raw::c_uint {
                                current_block = 1962330074042525963;
                            } else { current_block = 5786773664909485737; }
                        } else {
                            i_0 = 0 as std::os::raw::c_int;
                            loop  {
                                if !(i_0 < nbKeys) {
                                    current_block = 14612007084265645573;
                                    break ;
                                }
                                if (*(*keySeq_0).offset(i_0 as
                                                            isize)).is_null()
                                   {
                                    /*
		    * Not qualified, if not all fields did resolve.
		    */
                                    if (*idc).type_0 as std::os::raw::c_uint ==
                                           XML_SCHEMA_TYPE_IDC_KEY as
                                               std::os::raw::c_int as std::os::raw::c_uint {
                                        current_block = 1962330074042525963;
                                        break ;
                                    } else {
                                        current_block = 5786773664909485737;
                                        break ;
                                    }
                                } else { i_0 += 1 }
                            }
                            match current_block {
                                1962330074042525963 => { }
                                5786773664909485737 => { }
                                _ => {
                                    /*
	    * All fields did resolve.
	    */
                                    /*
	    * 4.1 If the {identity-constraint category} is unique(/key),
	    * then no two members of the `qualified node set` have
	    * `key-sequences` whose members are pairwise equal, as
	    * defined by Equal in [XML Schemas: Datatypes].
	    *
	    * Get the IDC binding from the matcher and check for
	    * duplicate key-sequences.
	    */
                                    targets =
                                        xmlSchemaIDCAcquireTargetList(vctxt,
                                                                      matcher_0);
                                    if (*idc).type_0 as std::os::raw::c_uint !=
                                           XML_SCHEMA_TYPE_IDC_KEYREF as
                                               std::os::raw::c_int as std::os::raw::c_uint &&
                                           (*targets).nbItems !=
                                               0 as std::os::raw::c_int {
                                        let mut ckey: xmlSchemaPSVIIDCKeyPtr =
                                            0 as *mut xmlSchemaPSVIIDCKey;
                                        let mut bkey: xmlSchemaPSVIIDCKeyPtr =
                                            0 as *mut xmlSchemaPSVIIDCKey;
                                        let mut bkeySeq:
                                                *mut xmlSchemaPSVIIDCKeyPtr =
                                            0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                        i_0 = 0 as std::os::raw::c_int;
                                        res = 0 as std::os::raw::c_int;
                                        loop 
                                             /*
		* Compare the key-sequences, key by key.
		*/
                                             {
                                            bkeySeq =
                                                (*(*(*targets).items.offset(i_0
                                                                                as
                                                                                isize)
                                                       as
                                                       xmlSchemaPSVIIDCNodePtr)).keys;
                                            j = 0 as std::os::raw::c_int;
                                            while j < nbKeys {
                                                ckey =
                                                    *(*keySeq_0).offset(j as
                                                                            isize);
                                                bkey =
                                                    *bkeySeq.offset(j as
                                                                        isize);
                                                res =
                                                    xmlSchemaAreValuesEqual((*ckey).val,
                                                                            (*bkey).val);
                                                if res == -(1 as std::os::raw::c_int)
                                                   {
                                                    return -(1 as std::os::raw::c_int)
                                                } else {
                                                    if res == 0 as std::os::raw::c_int
                                                       {
                                                        break ;
                                                    }
                                                    j += 1
                                                }
                                            }
                                            if res == 1 as std::os::raw::c_int {
                                                break ;
                                            }
                                            i_0 += 1;
                                            if !(i_0 < (*targets).nbItems) {
                                                break ;
                                            }
                                        }
                                        if i_0 != (*targets).nbItems {
                                            let mut str_1: *mut xmlChar =
                                                0 as *mut xmlChar;
                                            let mut strB: *mut xmlChar =
                                                0 as *mut xmlChar;
                                            /*
		    * TODO: Try to report the key-sequence.
		    */
                                            xmlSchemaCustomErr(vctxt as
                                                                   xmlSchemaAbstractCtxtPtr,
                                                               XML_SCHEMAV_CVC_IDC,
                                                               0 as
                                                                   xmlNodePtr,
                                                               idc as
                                                                   xmlSchemaBasicItemPtr,
                                                               b"Duplicate key-sequence %s in %s\x00"
                                                                   as
                                                                   *const u8
                                                                   as
                                                                   *const std::os::raw::c_char,
                                                               xmlSchemaFormatIDCKeySequence(vctxt,
                                                                                             &mut str_1,
                                                                                             *keySeq_0,
                                                                                             nbKeys),
                                                               xmlSchemaGetIDCDesignation(&mut strB,
                                                                                          idc));
                                            if !str_1.is_null() {
                                                xmlFree.expect("non-null function pointer")(str_1
                                                                                                as
                                                                                                *mut std::os::raw::c_void);
                                                str_1 = 0 as *mut xmlChar
                                            }
                                            if !strB.is_null() {
                                                xmlFree.expect("non-null function pointer")(strB
                                                                                                as
                                                                                                *mut std::os::raw::c_void);
                                                strB = 0 as *mut xmlChar
                                            }
                                            current_block =
                                                5786773664909485737;
                                        } else {
                                            current_block =
                                                11529749468180514315;
                                        }
                                    } else {
                                        current_block = 11529749468180514315;
                                    }
                                    match current_block {
                                        5786773664909485737 => { }
                                        _ => {
                                            /*
	    * Add a node-table item to the IDC binding.
	    */
                                            ntItem =
                                                xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaPSVIIDCNode>()
                                                                                                  as
                                                                                                  std::os::raw::c_ulong)
                                                    as
                                                    xmlSchemaPSVIIDCNodePtr;
                                            if ntItem.is_null() {
                                                xmlSchemaVErrMemory(0 as
                                                                        xmlSchemaValidCtxtPtr,
                                                                    b"allocating an IDC node-table item\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const std::os::raw::c_char,
                                                                    0 as
                                                                        xmlNodePtr);
                                                xmlFree.expect("non-null function pointer")(*keySeq_0
                                                                                                as
                                                                                                *mut std::os::raw::c_void);
                                                *keySeq_0 =
                                                    0 as
                                                        *mut xmlSchemaPSVIIDCKeyPtr;
                                                return -(1 as std::os::raw::c_int)
                                            }
                                            memset(ntItem as
                                                       *mut std::os::raw::c_void,
                                                   0 as std::os::raw::c_int,
                                                   ::std::mem::size_of::<xmlSchemaPSVIIDCNode>()
                                                       as std::os::raw::c_ulong);
                                            /*
	    * Store the node-table item in a global list.
	    */
                                            if (*idc).type_0 as std::os::raw::c_uint
                                                   !=
                                                   XML_SCHEMA_TYPE_IDC_KEYREF
                                                       as std::os::raw::c_int as
                                                       std::os::raw::c_uint {
                                                if xmlSchemaIDCStoreNodeTableItem(vctxt,
                                                                                  ntItem)
                                                       == -(1 as std::os::raw::c_int)
                                                   {
                                                    xmlFree.expect("non-null function pointer")(ntItem
                                                                                                    as
                                                                                                    *mut std::os::raw::c_void);
                                                    xmlFree.expect("non-null function pointer")(*keySeq_0
                                                                                                    as
                                                                                                    *mut std::os::raw::c_void);
                                                    *keySeq_0 =
                                                        0 as
                                                            *mut xmlSchemaPSVIIDCKeyPtr;
                                                    return -(1 as std::os::raw::c_int)
                                                }
                                                (*ntItem).nodeQNameID =
                                                    -(1 as std::os::raw::c_int)
                                            } else {
                                                /*
		* Save a cached QName for this node on the IDC node, to be
		* able to report it, even if the node is not saved.
		*/
                                                (*ntItem).nodeQNameID =
                                                    xmlSchemaVAddNodeQName(vctxt,
                                                                           (*(*vctxt).inode).localName,
                                                                           (*(*vctxt).inode).nsName);
                                                if (*ntItem).nodeQNameID ==
                                                       -(1 as std::os::raw::c_int) {
                                                    xmlFree.expect("non-null function pointer")(ntItem
                                                                                                    as
                                                                                                    *mut std::os::raw::c_void);
                                                    xmlFree.expect("non-null function pointer")(*keySeq_0
                                                                                                    as
                                                                                                    *mut std::os::raw::c_void);
                                                    *keySeq_0 =
                                                        0 as
                                                            *mut xmlSchemaPSVIIDCKeyPtr;
                                                    return -(1 as std::os::raw::c_int)
                                                }
                                            }
                                            /*
	    * Init the node-table item: Save the node, position and
	    * consume the key-sequence.
	    */
                                            (*ntItem).node = (*vctxt).node;
                                            (*ntItem).nodeLine =
                                                (*(*vctxt).inode).nodeLine;
                                            (*ntItem).keys = *keySeq_0;
                                            *keySeq_0 =
                                                0 as
                                                    *mut xmlSchemaPSVIIDCKeyPtr;
                                            if xmlSchemaItemListAdd(targets,
                                                                    ntItem as
                                                                        *mut std::os::raw::c_void)
                                                   == -(1 as std::os::raw::c_int) {
                                                if (*idc).type_0 as
                                                       std::os::raw::c_uint ==
                                                       XML_SCHEMA_TYPE_IDC_KEYREF
                                                           as std::os::raw::c_int as
                                                           std::os::raw::c_uint {
                                                    /*
		    * Free the item, since keyref items won't be
		    * put on a global list.
		    */
                                                    xmlFree.expect("non-null function pointer")((*ntItem).keys
                                                                                                    as
                                                                                                    *mut std::os::raw::c_void);
                                                    xmlFree.expect("non-null function pointer")(ntItem
                                                                                                    as
                                                                                                    *mut std::os::raw::c_void);
                                                }
                                                return -(1 as std::os::raw::c_int)
                                            }
                                            current_block =
                                                5786773664909485737;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    match current_block {
                        1962330074042525963 =>
                        /*
			* All fields of a "key" IDC must resolve.
			*/
                        {
                            let mut str_2: *mut xmlChar = 0 as *mut xmlChar;
                            /*
		* 4.2.1 (KEY) The `target node set` and the
		* `qualified node set` are equal, that is, every
		* member of the `target node set` is also a member
		* of the `qualified node set` and vice versa.
		*/
                            xmlSchemaCustomErr(vctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               XML_SCHEMAV_CVC_IDC,
                                               0 as xmlNodePtr,
                                               idc as xmlSchemaBasicItemPtr,
                                               b"Not all fields of %s evaluate to a node\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               xmlSchemaGetIDCDesignation(&mut str_2,
                                                                          idc),
                                               0 as *const xmlChar);
                            if !str_2.is_null() {
                                xmlFree.expect("non-null function pointer")(str_2
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                str_2 = 0 as *mut xmlChar
                            }
                        }
                        _ => { }
                    }
                    /*
	    * Free the key-sequence if not added to the IDC table.
	    */
                    if !keySeq_0.is_null() && !(*keySeq_0).is_null() {
                        xmlFree.expect("non-null function pointer")(*keySeq_0
                                                                        as
                                                                        *mut std::os::raw::c_void);
                        *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr
                    }
                    current_block = 1587619384396752891;
                } else { current_block = 1587619384396752891; }
                match current_block {
                    6025644545439772602 => { }
                    _ => { (*sto).nbHistory -= 1 }
                }
            }
        }
        /*
	* Deregister state objects if they reach the depth of creation.
	*/
        if (*sto).nbHistory == 0 as std::os::raw::c_int && (*sto).depth == depth {
            if (*vctxt).xpathStates != sto {
                xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaXPathProcessHistory\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"The state object to be removed is not the first in the list\x00"
                                         as *const u8 as *const std::os::raw::c_char);
            }
            nextsto = (*sto).next;
            /*
	    * Unlink from the list of active XPath state objects.
	    */
            (*vctxt).xpathStates = (*sto).next;
            (*sto).next = (*vctxt).xpathStatePool;
            /*
	    * Link it to the pool of reusable state objects.
	    */
            (*vctxt).xpathStatePool = sto;
            sto = nextsto
        } else { sto = (*sto).next }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaIDCRegisterMatchers:
 * @vctxt: the WXS validation context
 * @elemDecl: the element declaration
 *
 * Creates helper objects to evaluate IDC selectors/fields
 * successively.
 *
 * Returns 0 if OK and -1 on internal errors.
 */
unsafe extern "C" fn xmlSchemaIDCRegisterMatchers(mut vctxt:
                                                      xmlSchemaValidCtxtPtr,
                                                  mut elemDecl:
                                                      xmlSchemaElementPtr)
 -> std::os::raw::c_int {
    let mut matcher: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    let mut last: xmlSchemaIDCMatcherPtr = 0 as xmlSchemaIDCMatcherPtr;
    let mut idc: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
    let mut refIdc: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
    let mut aidc: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
    idc = (*elemDecl).idcs as xmlSchemaIDCPtr;
    if idc.is_null() { return 0 as std::os::raw::c_int }
    if !(*(*vctxt).inode).idcMatchers.is_null() {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaIDCRegisterMatchers\x00" as *const u8
                                 as *const std::os::raw::c_char,
                             b"The chain of IDC matchers is expected to be empty\x00"
                                 as *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    loop  {
        if (*idc).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int as std::os::raw::c_uint {
            /*
	    * Since IDCs bubbles are expensive we need to know the
	    * depth at which the bubbles should stop; this will be
	    * the depth of the top-most keyref IDC. If no keyref
	    * references a key/unique IDC, the keyrefDepth will
	    * be -1, indicating that no bubbles are needed.
	    */
            refIdc = (*(*idc).ref_0).item as xmlSchemaIDCPtr;
            if !refIdc.is_null() {
                /*
		* Remember that we have keyrefs on this node.
		*/
                (*(*vctxt).inode).hasKeyrefs = 1 as std::os::raw::c_int;
                /*
		* Lookup the referenced augmented IDC info.
		*/
                aidc = (*vctxt).aidcs;
                while !aidc.is_null() {
                    if (*aidc).def == refIdc { break ; }
                    aidc = (*aidc).next
                }
                if aidc.is_null() {
                    xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaIDCRegisterMatchers\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char,
                                         b"Could not find an augmented IDC item for an IDC definition\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    return -(1 as std::os::raw::c_int)
                }
                if (*aidc).keyrefDepth == -(1 as std::os::raw::c_int) ||
                       (*vctxt).depth < (*aidc).keyrefDepth {
                    (*aidc).keyrefDepth = (*vctxt).depth
                }
            }
        }
        /*
	* Lookup the augmented IDC item for the IDC definition.
	*/
        aidc = (*vctxt).aidcs;
        while !aidc.is_null() {
            if (*aidc).def == idc { break ; }
            aidc = (*aidc).next
        }
        if aidc.is_null() {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaIDCRegisterMatchers\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"Could not find an augmented IDC item for an IDC definition\x00"
                                     as *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        /*
	* Create an IDC matcher for every IDC definition.
	*/
        if !(*vctxt).idcMatcherCache.is_null() {
            /*
	    * Reuse a cached matcher.
	    */
            matcher = (*vctxt).idcMatcherCache;
            (*vctxt).idcMatcherCache = (*matcher).nextCached;
            (*matcher).nextCached = 0 as xmlSchemaIDCMatcherPtr
        } else {
            matcher =
                xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaIDCMatcher>()
                                                                  as
                                                                  std::os::raw::c_ulong)
                    as xmlSchemaIDCMatcherPtr;
            if matcher.is_null() {
                xmlSchemaVErrMemory(vctxt,
                                    b"allocating an IDC matcher\x00" as
                                        *const u8 as *const std::os::raw::c_char,
                                    0 as xmlNodePtr);
                return -(1 as std::os::raw::c_int)
            }
            memset(matcher as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
                   ::std::mem::size_of::<xmlSchemaIDCMatcher>() as
                       std::os::raw::c_ulong);
        }
        if last.is_null() {
            (*(*vctxt).inode).idcMatchers = matcher
        } else { (*last).next = matcher }
        last = matcher;
        (*matcher).type_0 = 0 as std::os::raw::c_int;
        (*matcher).depth = (*vctxt).depth;
        (*matcher).aidc = aidc;
        (*matcher).idcType = (*(*aidc).def).type_0 as std::os::raw::c_int;
        /*
	* Init the automaton state object.
	*/
        if xmlSchemaIDCAddStateObject(vctxt, matcher, (*idc).selector,
                                      1 as std::os::raw::c_int) == -(1 as std::os::raw::c_int)
           {
            return -(1 as std::os::raw::c_int)
        }
        idc = (*idc).next;
        if idc.is_null() { break ; }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaIDCFillNodeTables(mut vctxt:
                                                    xmlSchemaValidCtxtPtr,
                                                mut ielem:
                                                    xmlSchemaNodeInfoPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut bind: xmlSchemaPSVIIDCBindingPtr =
        0 as *mut xmlSchemaPSVIIDCBinding;
    let mut res: std::os::raw::c_int = 0;
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut k: std::os::raw::c_int = 0;
    let mut nbTargets: std::os::raw::c_int = 0;
    let mut nbFields: std::os::raw::c_int = 0;
    let mut nbDupls: std::os::raw::c_int = 0;
    let mut nbNodeTable: std::os::raw::c_int = 0;
    let mut keys: *mut xmlSchemaPSVIIDCKeyPtr =
        0 as *mut xmlSchemaPSVIIDCKeyPtr;
    let mut ntkeys: *mut xmlSchemaPSVIIDCKeyPtr =
        0 as *mut xmlSchemaPSVIIDCKeyPtr;
    let mut targets: *mut xmlSchemaPSVIIDCNodePtr =
        0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut dupls: *mut xmlSchemaPSVIIDCNodePtr =
        0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut matcher: xmlSchemaIDCMatcherPtr = (*ielem).idcMatchers;
    's_17:
        loop 
             /* vctxt->createIDCNodeTables */
             {
            if matcher.is_null() {
                current_block = 15587532755333643506;
                break ;
            }
            /*
	* Skip keyref IDCs and empty IDC target-lists.
	*/
            if (*(*(*matcher).aidc).def).type_0 as std::os::raw::c_uint ==
                   XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int as std::os::raw::c_uint
                   ||
                   ((*matcher).targets.is_null() ||
                        (*(*matcher).targets).nbItems == 0 as std::os::raw::c_int) {
                matcher = (*matcher).next
            } else if (*vctxt).createIDCNodeTables == 0 &&
                          ((*(*matcher).aidc).keyrefDepth ==
                               -(1 as std::os::raw::c_int) ||
                               (*(*matcher).aidc).keyrefDepth >
                                   (*vctxt).depth) {
                matcher = (*matcher).next
            } else {
                /*
	* If we _want_ the IDC node-table to be created in any case
	* then do so. Otherwise create them only if keyrefs need them.
	*/
                /*
	* Get/create the IDC binding on this element for the IDC definition.
	*/
                bind = xmlSchemaIDCAcquireBinding(vctxt, matcher);
                if !((*bind).dupls.is_null() ||
                         (*(*bind).dupls).nbItems == 0 as std::os::raw::c_int) {
                    dupls =
                        (*(*bind).dupls).items as
                            *mut xmlSchemaPSVIIDCNodePtr;
                    nbDupls = (*(*bind).dupls).nbItems
                } else {
                    dupls = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                    nbDupls = 0 as std::os::raw::c_int
                }
                if !(*bind).nodeTable.is_null() {
                    nbNodeTable = (*bind).nbNodes
                } else { nbNodeTable = 0 as std::os::raw::c_int }
                if nbNodeTable == 0 as std::os::raw::c_int &&
                       nbDupls == 0 as std::os::raw::c_int {
                    /*
	    * Transfer all IDC target-nodes to the IDC node-table.
	    */
                    (*bind).nodeTable =
                        (*(*matcher).targets).items as
                            *mut xmlSchemaPSVIIDCNodePtr;
                    (*bind).sizeNodes = (*(*matcher).targets).sizeItems;
                    (*bind).nbNodes = (*(*matcher).targets).nbItems;
                    (*(*matcher).targets).items = 0 as *mut *mut std::os::raw::c_void;
                    (*(*matcher).targets).sizeItems = 0 as std::os::raw::c_int;
                    (*(*matcher).targets).nbItems = 0 as std::os::raw::c_int
                } else {
                    /*
	    * Compare the key-sequences and add to the IDC node-table.
	    */
                    nbTargets = (*(*matcher).targets).nbItems;
                    targets =
                        (*(*matcher).targets).items as
                            *mut xmlSchemaPSVIIDCNodePtr;
                    nbFields = (*(*(*matcher).aidc).def).nbFields;
                    i = 0 as std::os::raw::c_int;
                    loop  {
                        keys = (**targets.offset(i as isize)).keys;
                        if nbDupls != 0 {
                            /*
		    * Search in already found duplicates first.
		    */
                            j = 0 as std::os::raw::c_int;
                            loop  {
                                if nbFields == 1 as std::os::raw::c_int {
                                    res =
                                        xmlSchemaAreValuesEqual((**keys.offset(0
                                                                                   as
                                                                                   std::os::raw::c_int
                                                                                   as
                                                                                   isize)).val,
                                                                (**(**dupls.offset(j
                                                                                       as
                                                                                       isize)).keys.offset(0
                                                                                                               as
                                                                                                               std::os::raw::c_int
                                                                                                               as
                                                                                                               isize)).val);
                                    if res == -(1 as std::os::raw::c_int) {
                                        current_block = 8604174138995054011;
                                        break 's_17 ;
                                    }
                                    if res == 1 as std::os::raw::c_int {
                                        /*
				* Equal key-sequence.
				*/
                                        current_block = 2167675902518274849;
                                        break ;
                                    }
                                } else {
                                    res = 0 as std::os::raw::c_int;
                                    ntkeys =
                                        (**dupls.offset(j as isize)).keys;
                                    k = 0 as std::os::raw::c_int;
                                    while k < nbFields {
                                        res =
                                            xmlSchemaAreValuesEqual((**keys.offset(k
                                                                                       as
                                                                                       isize)).val,
                                                                    (**ntkeys.offset(k
                                                                                         as
                                                                                         isize)).val);
                                        if res == -(1 as std::os::raw::c_int) {
                                            current_block =
                                                8604174138995054011;
                                            break 's_17 ;
                                        }
                                        if res == 0 as std::os::raw::c_int { break ; }
                                        k += 1
                                    }
                                    /*
				    * One of the keys differs.
				    */
                                    if res == 1 as std::os::raw::c_int {
                                        current_block = 2167675902518274849;
                                        break ;
                                    }
                                }
                                j += 1;
                                if !(j < nbDupls) {
                                    current_block = 8151474771948790331;
                                    break ;
                                }
                            }
                        } else { current_block = 8151474771948790331; }
                        match current_block {
                            8151474771948790331 => {
                                if nbNodeTable != 0 {
                                    j = 0 as std::os::raw::c_int;
                                    loop  {
                                        if nbFields == 1 as std::os::raw::c_int {
                                            res =
                                                xmlSchemaAreValuesEqual((**keys.offset(0
                                                                                           as
                                                                                           std::os::raw::c_int
                                                                                           as
                                                                                           isize)).val,
                                                                        (**(**(*bind).nodeTable.offset(j
                                                                                                           as
                                                                                                           isize)).keys.offset(0
                                                                                                                                   as
                                                                                                                                   std::os::raw::c_int
                                                                                                                                   as
                                                                                                                                   isize)).val);
                                            if res == -(1 as std::os::raw::c_int) {
                                                current_block =
                                                    8604174138995054011;
                                                break 's_17 ;
                                            }
                                            if res == 0 as std::os::raw::c_int {
                                                /*
				* The key-sequence differs.
				*/
                                                current_block =
                                                    7214806563641714817;
                                            } else {
                                                current_block =
                                                    7858101417678297991;
                                            }
                                        } else {
                                            res = 0 as std::os::raw::c_int;
                                            ntkeys =
                                                (**(*bind).nodeTable.offset(j
                                                                                as
                                                                                isize)).keys;
                                            k = 0 as std::os::raw::c_int;
                                            loop  {
                                                if !(k < nbFields) {
                                                    current_block =
                                                        7858101417678297991;
                                                    break ;
                                                }
                                                res =
                                                    xmlSchemaAreValuesEqual((**keys.offset(k
                                                                                               as
                                                                                               isize)).val,
                                                                            (**ntkeys.offset(k
                                                                                                 as
                                                                                                 isize)).val);
                                                if res == -(1 as std::os::raw::c_int)
                                                   {
                                                    current_block =
                                                        8604174138995054011;
                                                    break 's_17 ;
                                                }
                                                if res == 0 as std::os::raw::c_int {
                                                    current_block =
                                                        7214806563641714817;
                                                    break ;
                                                }
                                                k += 1
                                            }
                                        }
                                        match current_block {
                                            7214806563641714817 =>
                                            /*
				    * One of the keys differs.
				    */
                                            {
                                                j += 1;
                                                if !(j < nbNodeTable) {
                                                    current_block =
                                                        16231175055492490595;
                                                    break ;
                                                }
                                            }
                                            _ =>
                                            /*
			* Add the duplicate to the list of duplicates.
			*/
                                            {
                                                if (*bind).dupls.is_null() {
                                                    (*bind).dupls =
                                                        xmlSchemaItemListCreate();
                                                    if (*bind).dupls.is_null()
                                                       {
                                                        current_block =
                                                            8604174138995054011;
                                                        break 's_17 ;
                                                    }
                                                }
                                                if xmlSchemaItemListAdd((*bind).dupls,
                                                                        *(*bind).nodeTable.offset(j
                                                                                                      as
                                                                                                      isize)
                                                                            as
                                                                            *mut std::os::raw::c_void)
                                                       == -(1 as std::os::raw::c_int)
                                                   {
                                                    current_block =
                                                        8604174138995054011;
                                                    break 's_17 ;
                                                }
                                                /*
			* Remove the duplicate entry from the IDC node-table.
			*/
                                                let ref mut fresh36 =
                                                    *(*bind).nodeTable.offset(j
                                                                                  as
                                                                                  isize);
                                                *fresh36 =
                                                    *(*bind).nodeTable.offset(((*bind).nbNodes
                                                                                   -
                                                                                   1
                                                                                       as
                                                                                       std::os::raw::c_int)
                                                                                  as
                                                                                  isize);
                                                (*bind).nbNodes -= 1;
                                                current_block =
                                                    2167675902518274849;
                                                break ;
                                            }
                                        }
                                    }
                                } else {
                                    current_block = 16231175055492490595;
                                }
                                match current_block {
                                    2167675902518274849 => { }
                                    _ =>
                                    /*
		* If everything is fine, then add the IDC target-node to
		* the IDC node-table.
		*/
                                    {
                                        if xmlSchemaIDCAppendNodeTableItem(bind,
                                                                           *targets.offset(i
                                                                                               as
                                                                                               isize))
                                               == -(1 as std::os::raw::c_int) {
                                            current_block =
                                                8604174138995054011;
                                            break 's_17 ;
                                        }
                                    }
                                }
                            }
                            _ => { }
                        }
                        /*
				* Equal key-sequence found.
				*/
                        i += 1;
                        if !(i < nbTargets) { break ; }
                    }
                }
                matcher = (*matcher).next
            }
        }
    match current_block {
        8604174138995054011 => { return -(1 as std::os::raw::c_int) }
        _ => { return 0 as std::os::raw::c_int }
    };
}
/* *
 * xmlSchemaBubbleIDCNodeTables:
 * @depth: the current tree depth
 *
 * Merges IDC bindings of an element at @depth into the corresponding IDC
 * bindings of its parent element. If a duplicate note-table entry is found,
 * both, the parent node-table entry and child entry are discarded from the
 * node-table of the parent.
 *
 * Returns 0 if OK and -1 on internal errors.
 */
unsafe extern "C" fn xmlSchemaBubbleIDCNodeTables(mut vctxt:
                                                      xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64; /* IDC bindings of the current node. */
    let mut bind: xmlSchemaPSVIIDCBindingPtr =
        0 as *mut xmlSchemaPSVIIDCBinding; /* parent IDC bindings. */
    let mut parTable: *mut xmlSchemaPSVIIDCBindingPtr =
        0 as *mut xmlSchemaPSVIIDCBindingPtr; /* node-table entries. */
    let mut parBind: xmlSchemaPSVIIDCBindingPtr =
        0 as xmlSchemaPSVIIDCBindingPtr;
    let mut node: xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNode;
    let mut parNode: xmlSchemaPSVIIDCNodePtr = 0 as xmlSchemaPSVIIDCNodePtr;
    let mut dupls: *mut xmlSchemaPSVIIDCNodePtr =
        0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut parNodes: *mut xmlSchemaPSVIIDCNodePtr =
        0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut aidc: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut k: std::os::raw::c_int = 0;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut nbFields: std::os::raw::c_int = 0;
    let mut oldNum: std::os::raw::c_int = 0;
    let mut oldDupls: std::os::raw::c_int = 0;
    bind = (*(*vctxt).inode).idcTable;
    if bind.is_null() {
        /* Fine, no table, no bubbles. */
        return 0 as std::os::raw::c_int
    }
    parTable =
        &mut (**(*vctxt).elemInfos.offset(((*vctxt).depth - 1 as std::os::raw::c_int)
                                              as isize)).idcTable;
    's_37:
        loop 
             /*
    * Walk all bindings; create new or add to existing bindings.
    * Remove duplicate key-sequences.
    */
             {
            if bind.is_null() { current_block = 7157669805658135323; break ; }
            if !((*bind).nbNodes == 0 as std::os::raw::c_int &&
                     ((*bind).dupls.is_null() ||
                          (*(*bind).dupls).nbItems == 0 as std::os::raw::c_int)) {
                /*
	* Check if the key/unique IDC table needs to be bubbled.
	*/
                if (*vctxt).createIDCNodeTables == 0 {
                    aidc = (*vctxt).aidcs;
                    loop  {
                        if (*aidc).def == (*bind).definition {
                            if (*aidc).keyrefDepth == -(1 as std::os::raw::c_int) ||
                                   (*aidc).keyrefDepth >= (*vctxt).depth {
                                current_block = 13717432963829418616;
                                break ;
                            } else {
                                current_block = 17833034027772472439;
                                break ;
                            }
                        } else {
                            aidc = (*aidc).next;
                            if aidc.is_null() {
                                current_block = 17833034027772472439;
                                break ;
                            }
                        }
                    }
                } else { current_block = 17833034027772472439; }
                match current_block {
                    13717432963829418616 => { }
                    _ => {
                        if !parTable.is_null() { parBind = *parTable }
                        /*
	* Search a matching parent binding for the
	* IDC definition.
	*/
                        while !parBind.is_null() {
                            if (*parBind).definition == (*bind).definition {
                                break ;
                            }
                            parBind = (*parBind).next
                        }
                        if !parBind.is_null() {
                            /*
	    * Compare every node-table entry of the child node,
	    * i.e. the key-sequence within, ...
	    */
                            oldNum =
                                (*parBind).nbNodes; /* Skip newly added items. */
                            if !((*parBind).dupls.is_null() ||
                                     (*(*parBind).dupls).nbItems ==
                                         0 as std::os::raw::c_int) {
                                oldDupls = (*(*parBind).dupls).nbItems;
                                dupls =
                                    (*(*parBind).dupls).items as
                                        *mut xmlSchemaPSVIIDCNodePtr
                            } else {
                                dupls = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                                oldDupls = 0 as std::os::raw::c_int
                            }
                            parNodes = (*parBind).nodeTable;
                            nbFields = (*(*bind).definition).nbFields;
                            i = 0 as std::os::raw::c_int;
                            while i < (*bind).nbNodes {
                                node = *(*bind).nodeTable.offset(i as isize);
                                if !node.is_null() {
                                    /*
		* ...with every key-sequence of the parent node, already
		* evaluated to be a duplicate key-sequence.
		*/
                                    if oldDupls != 0 {
                                        j = 0 as std::os::raw::c_int;
                                        while j < oldDupls {
                                            if nbFields == 1 as std::os::raw::c_int {
                                                ret =
                                                    xmlSchemaAreValuesEqual((**(*node).keys.offset(0
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                                       as
                                                                                                       isize)).val,
                                                                            (**(**dupls.offset(j
                                                                                                   as
                                                                                                   isize)).keys.offset(0
                                                                                                                           as
                                                                                                                           std::os::raw::c_int
                                                                                                                           as
                                                                                                                           isize)).val);
                                                if ret == -(1 as std::os::raw::c_int)
                                                   {
                                                    current_block =
                                                        6769810753510177370;
                                                    break 's_37 ;
                                                }
                                                if ret == 0 as std::os::raw::c_int {
                                                    j += 1;
                                                    continue ;
                                                }
                                            } else {
                                                parNode =
                                                    *dupls.offset(j as isize);
                                                k = 0 as std::os::raw::c_int;
                                                while k < nbFields {
                                                    ret =
                                                        xmlSchemaAreValuesEqual((**(*node).keys.offset(k
                                                                                                           as
                                                                                                           isize)).val,
                                                                                (**(*parNode).keys.offset(k
                                                                                                              as
                                                                                                              isize)).val);
                                                    if ret ==
                                                           -(1 as std::os::raw::c_int)
                                                       {
                                                        current_block =
                                                            6769810753510177370;
                                                        break 's_37 ;
                                                    }
                                                    if ret == 0 as std::os::raw::c_int
                                                       {
                                                        break ;
                                                    }
                                                    k += 1
                                                }
                                            }
                                            if ret == 1 as std::os::raw::c_int {
                                                break ;
                                            }
                                            j += 1
                                        }
                                        /* Duplicate found. */
                                        if j != oldDupls {
                                            current_block =
                                                14434620278749266018;
                                        } else {
                                            current_block =
                                                6721012065216013753;
                                        }
                                    } else {
                                        current_block = 6721012065216013753;
                                    }
                                    match current_block {
                                        14434620278749266018 => { }
                                        _ =>
                                        /*
		* ... and with every key-sequence of the parent node.
		*/
                                        {
                                            if oldNum != 0 {
                                                j = 0 as std::os::raw::c_int;
                                                while j < oldNum {
                                                    parNode =
                                                        *parNodes.offset(j as
                                                                             isize);
                                                    if nbFields ==
                                                           1 as std::os::raw::c_int {
                                                        ret =
                                                            xmlSchemaAreValuesEqual((**(*node).keys.offset(0
                                                                                                               as
                                                                                                               std::os::raw::c_int
                                                                                                               as
                                                                                                               isize)).val,
                                                                                    (**(*parNode).keys.offset(0
                                                                                                                  as
                                                                                                                  std::os::raw::c_int
                                                                                                                  as
                                                                                                                  isize)).val);
                                                        if ret ==
                                                               -(1 as
                                                                     std::os::raw::c_int)
                                                           {
                                                            current_block =
                                                                6769810753510177370;
                                                            break 's_37 ;
                                                        }
                                                        if ret ==
                                                               0 as
                                                                   std::os::raw::c_int
                                                           {
                                                            j += 1;
                                                            continue ;
                                                        }
                                                    } else {
                                                        k = 0 as std::os::raw::c_int;
                                                        while k < nbFields {
                                                            ret =
                                                                xmlSchemaAreValuesEqual((**(*node).keys.offset(k
                                                                                                                   as
                                                                                                                   isize)).val,
                                                                                        (**(*parNode).keys.offset(k
                                                                                                                      as
                                                                                                                      isize)).val);
                                                            if ret ==
                                                                   -(1 as
                                                                         std::os::raw::c_int)
                                                               {
                                                                current_block
                                                                    =
                                                                    6769810753510177370;
                                                                break 's_37 ;
                                                            }
                                                            if ret ==
                                                                   0 as
                                                                       std::os::raw::c_int
                                                               {
                                                                break ;
                                                            }
                                                            k += 1
                                                        }
                                                    }
                                                    if ret == 1 as std::os::raw::c_int
                                                       {
                                                        break ;
                                                    }
                                                    j += 1
                                                }
                                                /* Duplicate found. */
                                                if j != oldNum {
                                                    /*
			* Handle duplicates. Move the duplicate in
			* the parent's node-table to the list of
			* duplicates.
			*/
                                                    oldNum -= 1;
                                                    (*parBind).nbNodes -= 1;
                                                    /*
			* Move last old item to pos of duplicate.
			*/
                                                    let ref mut fresh37 =
                                                        *parNodes.offset(j as
                                                                             isize);
                                                    *fresh37 =
                                                        *parNodes.offset(oldNum
                                                                             as
                                                                             isize);
                                                    if (*parBind).nbNodes !=
                                                           oldNum {
                                                        /*
			    * If new items exist, move last new item to
			    * last of old items.
			    */
                                                        let ref mut fresh38 =
                                                            *parNodes.offset(oldNum
                                                                                 as
                                                                                 isize);
                                                        *fresh38 =
                                                            *parNodes.offset((*parBind).nbNodes
                                                                                 as
                                                                                 isize)
                                                    }
                                                    if (*parBind).dupls.is_null()
                                                       {
                                                        (*parBind).dupls =
                                                            xmlSchemaItemListCreate();
                                                        if (*parBind).dupls.is_null()
                                                           {
                                                            current_block =
                                                                6769810753510177370;
                                                            break 's_37 ;
                                                        }
                                                    }
                                                    xmlSchemaItemListAdd((*parBind).dupls,
                                                                         parNode
                                                                             as
                                                                             *mut std::os::raw::c_void);
                                                } else {
                                                    /*
			* Add the node-table entry (node and key-sequence) of
			* the child node to the node table of the parent node.
			*/
                                                    if (*parBind).nodeTable.is_null()
                                                       {
                                                        (*parBind).nodeTable =
                                                            xmlMalloc.expect("non-null function pointer")((10
                                                                                                               as
                                                                                                               std::os::raw::c_int
                                                                                                               as
                                                                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                                                                                               as
                                                                                                                                               std::os::raw::c_ulong))
                                                                as
                                                                *mut xmlSchemaPSVIIDCNodePtr;
                                                        if (*parBind).nodeTable.is_null()
                                                           {
                                                            xmlSchemaVErrMemory(0
                                                                                    as
                                                                                    xmlSchemaValidCtxtPtr,
                                                                                b"allocating IDC list of node-table items\x00"
                                                                                    as
                                                                                    *const u8
                                                                                    as
                                                                                    *const std::os::raw::c_char,
                                                                                0
                                                                                    as
                                                                                    xmlNodePtr);
                                                            current_block =
                                                                6769810753510177370;
                                                            break 's_37 ;
                                                        } else {
                                                            (*parBind).sizeNodes
                                                                =
                                                                1 as
                                                                    std::os::raw::c_int
                                                        }
                                                    } else if (*parBind).nbNodes
                                                                  >=
                                                                  (*parBind).sizeNodes
                                                     {
                                                        (*parBind).sizeNodes
                                                            *=
                                                            2 as std::os::raw::c_int;
                                                        (*parBind).nodeTable =
                                                            xmlRealloc.expect("non-null function pointer")((*parBind).nodeTable
                                                                                                               as
                                                                                                               *mut std::os::raw::c_void,
                                                                                                           ((*parBind).sizeNodes
                                                                                                                as
                                                                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                                                                                                as
                                                                                                                                                std::os::raw::c_ulong))
                                                                as
                                                                *mut xmlSchemaPSVIIDCNodePtr;
                                                        if (*parBind).nodeTable.is_null()
                                                           {
                                                            xmlSchemaVErrMemory(0
                                                                                    as
                                                                                    xmlSchemaValidCtxtPtr,
                                                                                b"re-allocating IDC list of node-table items\x00"
                                                                                    as
                                                                                    *const u8
                                                                                    as
                                                                                    *const std::os::raw::c_char,
                                                                                0
                                                                                    as
                                                                                    xmlNodePtr);
                                                            current_block =
                                                                6769810753510177370;
                                                            break 's_37 ;
                                                        }
                                                    }
                                                    parNodes =
                                                        (*parBind).nodeTable;
                                                    /*
			* Append the new node-table entry to the 'new node-table
			* entries' section.
			*/
                                                    let fresh39 =
                                                        (*parBind).nbNodes;
                                                    (*parBind).nbNodes =
                                                        (*parBind).nbNodes +
                                                            1;
                                                    let ref mut fresh40 =
                                                        *parNodes.offset(fresh39
                                                                             as
                                                                             isize);
                                                    *fresh40 = node
                                                }
                                            }
                                        }
                                    }
                                }
                                /* Duplicate found. Skip this entry. */
                                i += 1
                            }
                        } else {
                            /*
	    * No binding for the IDC was found: create a new one and
	    * copy all node-tables.
	    */
                            parBind =
                                xmlSchemaIDCNewBinding((*bind).definition);
                            if parBind.is_null() {
                                current_block = 6769810753510177370;
                                break ;
                            }
                            /*
	    * TODO: Hmm, how to optimize the initial number of
	    * allocated entries?
	    */
                            if (*bind).nbNodes != 0 as std::os::raw::c_int {
                                /*
		* Add all IDC node-table entries.
		*/
                                if (*vctxt).psviExposeIDCNodeTables == 0 {
                                    /*
		    * Just move the entries.
		    * NOTE: this is quite save here, since
		    * all the keyref lookups have already been
		    * performed.
		    */
                                    (*parBind).nodeTable = (*bind).nodeTable;
                                    (*bind).nodeTable =
                                        0 as *mut xmlSchemaPSVIIDCNodePtr;
                                    (*parBind).sizeNodes = (*bind).sizeNodes;
                                    (*bind).sizeNodes = 0 as std::os::raw::c_int;
                                    (*parBind).nbNodes = (*bind).nbNodes;
                                    (*bind).nbNodes = 0 as std::os::raw::c_int
                                } else {
                                    /*
		    * Copy the entries.
		    */
                                    (*parBind).nodeTable =
                                        xmlMalloc.expect("non-null function pointer")(((*bind).nbNodes
                                                                                           as
                                                                                           std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                                                                           as
                                                                                                                           std::os::raw::c_ulong))
                                            as *mut xmlSchemaPSVIIDCNodePtr;
                                    if (*parBind).nodeTable.is_null() {
                                        xmlSchemaVErrMemory(0 as
                                                                xmlSchemaValidCtxtPtr,
                                                            b"allocating an array of IDC node-table items\x00"
                                                                as *const u8
                                                                as
                                                                *const std::os::raw::c_char,
                                                            0 as xmlNodePtr);
                                        xmlSchemaIDCFreeBinding(parBind);
                                        current_block = 6769810753510177370;
                                        break ;
                                    } else {
                                        (*parBind).sizeNodes =
                                            (*bind).nbNodes;
                                        (*parBind).nbNodes = (*bind).nbNodes;
                                        memcpy((*parBind).nodeTable as
                                                   *mut std::os::raw::c_void,
                                               (*bind).nodeTable as
                                                   *const std::os::raw::c_void,
                                               ((*bind).nbNodes as
                                                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                                    as
                                                                                    std::os::raw::c_ulong));
                                    }
                                }
                            }
                            if !(*bind).dupls.is_null() {
                                /*
		* Move the duplicates.
		*/
                                if !(*parBind).dupls.is_null() {
                                    xmlSchemaItemListFree((*parBind).dupls);
                                }
                                (*parBind).dupls = (*bind).dupls;
                                (*bind).dupls = 0 as xmlSchemaItemListPtr
                            }
                            if !parTable.is_null() {
                                if (*parTable).is_null() {
                                    *parTable = parBind
                                } else {
                                    (*parBind).next = *parTable;
                                    *parTable = parBind
                                }
                            }
                        }
                    }
                }
            }
            bind = (*bind).next
        }
    match current_block {
        6769810753510177370 => { return -(1 as std::os::raw::c_int) }
        _ => { return 0 as std::os::raw::c_int }
    };
}
/* *
 * xmlSchemaCheckCVCIDCKeyRef:
 * @vctxt: the WXS validation context
 * @elemDecl: the element declaration
 *
 * Check the cvc-idc-keyref constraints.
 */
unsafe extern "C" fn xmlSchemaCheckCVCIDCKeyRef(mut vctxt:
                                                    xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut matcher: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    let mut bind: xmlSchemaPSVIIDCBindingPtr =
        0 as *mut xmlSchemaPSVIIDCBinding;
    matcher = (*(*vctxt).inode).idcMatchers;
    /*
    * Find a keyref.
    */
    while !matcher.is_null() {
        if (*matcher).idcType == XML_SCHEMA_TYPE_IDC_KEYREF as std::os::raw::c_int &&
               !(*matcher).targets.is_null() &&
               (*(*matcher).targets).nbItems != 0 {
            let mut i: std::os::raw::c_int = 0;
            let mut j: std::os::raw::c_int = 0;
            let mut k: std::os::raw::c_int = 0;
            let mut res: std::os::raw::c_int = 0;
            let mut nbFields: std::os::raw::c_int = 0;
            let mut hasDupls: std::os::raw::c_int = 0;
            let mut refKeys: *mut xmlSchemaPSVIIDCKeyPtr =
                0 as *mut xmlSchemaPSVIIDCKeyPtr;
            let mut keys: *mut xmlSchemaPSVIIDCKeyPtr =
                0 as *mut xmlSchemaPSVIIDCKeyPtr;
            let mut refNode: xmlSchemaPSVIIDCNodePtr =
                0 as xmlSchemaPSVIIDCNodePtr;
            nbFields = (*(*(*matcher).aidc).def).nbFields;
            /*
	    * Find the IDC node-table for the referenced IDC key/unique.
	    */
            bind = (*(*vctxt).inode).idcTable;
            while !bind.is_null() {
                if (*(*(*(*matcher).aidc).def).ref_0).item as xmlSchemaIDCPtr
                       == (*bind).definition {
                    break ;
                }
                bind = (*bind).next
            }
            hasDupls =
                if !bind.is_null() && !(*bind).dupls.is_null() &&
                       (*(*bind).dupls).nbItems != 0 {
                    1 as std::os::raw::c_int
                } else { 0 as std::os::raw::c_int };
            /*
	    * Search for a matching key-sequences.
	    */
            i = 0 as std::os::raw::c_int;
            while i < (*(*matcher).targets).nbItems {
                res = 0 as std::os::raw::c_int;
                refNode =
                    *(*(*matcher).targets).items.offset(i as isize) as
                        xmlSchemaPSVIIDCNodePtr;
                if !bind.is_null() {
                    refKeys = (*refNode).keys;
                    j = 0 as std::os::raw::c_int;
                    while j < (*bind).nbNodes {
                        keys = (**(*bind).nodeTable.offset(j as isize)).keys;
                        k = 0 as std::os::raw::c_int;
                        while k < nbFields {
                            res =
                                xmlSchemaAreValuesEqual((**keys.offset(k as
                                                                           isize)).val,
                                                        (**refKeys.offset(k as
                                                                              isize)).val);
                            if res == 0 as std::os::raw::c_int { break ; }
                            if res == -(1 as std::os::raw::c_int) {
                                return -(1 as std::os::raw::c_int)
                            }
                            k += 1
                        }
                        if res == 1 as std::os::raw::c_int { break ; }
                        j += 1
                    }
                    if res == 0 as std::os::raw::c_int && hasDupls != 0 {
                        /*
			* Search in duplicates
			*/
                        j = 0 as std::os::raw::c_int;
                        while j < (*(*bind).dupls).nbItems {
                            keys =
                                (*(*(*(*bind).dupls).items.offset(j as isize)
                                       as xmlSchemaPSVIIDCNodePtr)).keys;
                            k = 0 as std::os::raw::c_int;
                            while k < nbFields {
                                res =
                                    xmlSchemaAreValuesEqual((**keys.offset(k
                                                                               as
                                                                               isize)).val,
                                                            (**refKeys.offset(k
                                                                                  as
                                                                                  isize)).val);
                                if res == 0 as std::os::raw::c_int { break ; }
                                if res == -(1 as std::os::raw::c_int) {
                                    return -(1 as std::os::raw::c_int)
                                }
                                k += 1
                            }
                            if res == 1 as std::os::raw::c_int {
                                /*
				* Match in duplicates found.
				*/
                                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                                let mut strB: *mut xmlChar =
                                    0 as *mut xmlChar;
                                xmlSchemaKeyrefErr(vctxt, XML_SCHEMAV_CVC_IDC,
                                                   refNode,
                                                   (*(*matcher).aidc).def as
                                                       xmlSchemaTypePtr,
                                                   b"More than one match found for key-sequence %s of keyref \'%s\'\x00"
                                                       as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   xmlSchemaFormatIDCKeySequence(vctxt,
                                                                                 &mut str,
                                                                                 (*refNode).keys,
                                                                                 nbFields),
                                                   xmlSchemaGetComponentQName(&mut strB,
                                                                              (*(*matcher).aidc).def
                                                                                  as
                                                                                  *mut std::os::raw::c_void));
                                if !str.is_null() {
                                    xmlFree.expect("non-null function pointer")(str
                                                                                    as
                                                                                    *mut std::os::raw::c_void);
                                    str = 0 as *mut xmlChar
                                }
                                if !strB.is_null() {
                                    xmlFree.expect("non-null function pointer")(strB
                                                                                    as
                                                                                    *mut std::os::raw::c_void);
                                    strB = 0 as *mut xmlChar
                                }
                                break ;
                            } else { j += 1 }
                        }
                    }
                }
                if res == 0 as std::os::raw::c_int {
                    let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                    let mut strB_0: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaKeyrefErr(vctxt, XML_SCHEMAV_CVC_IDC, refNode,
                                       (*(*matcher).aidc).def as
                                           xmlSchemaTypePtr,
                                       b"No match found for key-sequence %s of keyref \'%s\'\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlSchemaFormatIDCKeySequence(vctxt,
                                                                     &mut str_0,
                                                                     (*refNode).keys,
                                                                     nbFields),
                                       xmlSchemaGetComponentQName(&mut strB_0,
                                                                  (*(*matcher).aidc).def
                                                                      as
                                                                      *mut std::os::raw::c_void));
                    if !str_0.is_null() {
                        xmlFree.expect("non-null function pointer")(str_0 as
                                                                        *mut std::os::raw::c_void);
                        str_0 = 0 as *mut xmlChar
                    }
                    if !strB_0.is_null() {
                        xmlFree.expect("non-null function pointer")(strB_0 as
                                                                        *mut std::os::raw::c_void);
                        strB_0 = 0 as *mut xmlChar
                    }
                }
                i += 1
            }
        }
        matcher = (*matcher).next
    }
    /* TODO: Return an error if any error encountered. */
    return 0 as std::os::raw::c_int;
}
/* ***********************************************************************
 *									*
 *			XML Reader validation code                      *
 *									*
 ************************************************************************/
unsafe extern "C" fn xmlSchemaGetFreshAttrInfo(mut vctxt:
                                                   xmlSchemaValidCtxtPtr)
 -> xmlSchemaAttrInfoPtr {
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    /*
    * Grow/create list of attribute infos.
    */
    if (*vctxt).attrInfos.is_null() {
        (*vctxt).attrInfos =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaAttrInfoPtr>()
                                                              as
                                                              std::os::raw::c_ulong)
                as *mut xmlSchemaAttrInfoPtr;
        (*vctxt).sizeAttrInfos = 1 as std::os::raw::c_int;
        if (*vctxt).attrInfos.is_null() {
            xmlSchemaVErrMemory(vctxt,
                                b"allocating attribute info list\x00" as
                                    *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return 0 as xmlSchemaAttrInfoPtr
        }
    } else if (*vctxt).sizeAttrInfos <= (*vctxt).nbAttrInfos {
        (*vctxt).sizeAttrInfos += 1;
        (*vctxt).attrInfos =
            xmlRealloc.expect("non-null function pointer")((*vctxt).attrInfos
                                                               as
                                                               *mut std::os::raw::c_void,
                                                           ((*vctxt).sizeAttrInfos
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaAttrInfoPtr>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut xmlSchemaAttrInfoPtr;
        if (*vctxt).attrInfos.is_null() {
            xmlSchemaVErrMemory(vctxt,
                                b"re-allocating attribute info list\x00" as
                                    *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return 0 as xmlSchemaAttrInfoPtr
        }
    } else {
        let fresh41 = (*vctxt).nbAttrInfos;
        (*vctxt).nbAttrInfos = (*vctxt).nbAttrInfos + 1;
        iattr = *(*vctxt).attrInfos.offset(fresh41 as isize);
        if !(*iattr).localName.is_null() {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaGetFreshAttrInfo\x00" as *const u8
                                     as *const std::os::raw::c_char,
                                 b"attr info not cleared\x00" as *const u8 as
                                     *const std::os::raw::c_char);
            return 0 as xmlSchemaAttrInfoPtr
        }
        (*iattr).nodeType = XML_ATTRIBUTE_NODE as std::os::raw::c_int;
        return iattr
    }
    /*
    * Create an attribute info.
    */
    iattr =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaAttrInfo>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaAttrInfoPtr;
    if iattr.is_null() {
        xmlSchemaVErrMemory(vctxt,
                            b"creating new attribute info\x00" as *const u8 as
                                *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaAttrInfoPtr
    }
    memset(iattr as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaAttrInfo>() as std::os::raw::c_ulong);
    (*iattr).nodeType = XML_ATTRIBUTE_NODE as std::os::raw::c_int;
    let fresh42 = (*vctxt).nbAttrInfos;
    (*vctxt).nbAttrInfos = (*vctxt).nbAttrInfos + 1;
    let ref mut fresh43 = *(*vctxt).attrInfos.offset(fresh42 as isize);
    *fresh43 = iattr;
    return iattr;
}
unsafe extern "C" fn xmlSchemaValidatorPushAttribute(mut vctxt:
                                                         xmlSchemaValidCtxtPtr,
                                                     mut attrNode: xmlNodePtr,
                                                     mut nodeLine:
                                                         std::os::raw::c_int,
                                                     mut localName:
                                                         *const xmlChar,
                                                     mut nsName:
                                                         *const xmlChar,
                                                     mut ownedNames:
                                                         std::os::raw::c_int,
                                                     mut value: *mut xmlChar,
                                                     mut ownedValue:
                                                         std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut attr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    attr = xmlSchemaGetFreshAttrInfo(vctxt);
    if attr.is_null() {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaPushAttribute\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"calling xmlSchemaGetFreshAttrInfo()\x00" as
                                 *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    (*attr).node = attrNode;
    (*attr).nodeLine = nodeLine;
    (*attr).state = 1 as std::os::raw::c_int;
    (*attr).localName = localName;
    (*attr).nsName = nsName;
    if ownedNames != 0 {
        (*attr).flags |= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
    }
    /*
    * Evaluate if it's an XSI attribute.
    */
    if !nsName.is_null() {
        if xmlStrEqual(localName,
                       b"nil\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 2 as std::os::raw::c_int
            }
        } else if xmlStrEqual(localName,
                              b"type\x00" as *const u8 as *const std::os::raw::c_char
                                  as *mut xmlChar) != 0 {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 1 as std::os::raw::c_int
            }
        } else if xmlStrEqual(localName,
                              b"schemaLocation\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar) != 0 {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 3 as std::os::raw::c_int
            }
        } else if xmlStrEqual(localName,
                              b"noNamespaceSchemaLocation\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar) != 0 {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 4 as std::os::raw::c_int
            }
        } else if xmlStrEqual((*attr).nsName, xmlNamespaceNs) != 0 {
            (*attr).metaType = 5 as std::os::raw::c_int
        }
    }
    (*attr).value = value;
    if ownedValue != 0 {
        (*attr).flags |= (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int
    }
    if (*attr).metaType != 0 as std::os::raw::c_int {
        (*attr).state = 17 as std::os::raw::c_int
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaClearElemInfo:
 * @vctxt: the WXS validation context
 * @ielem: the element information item
 */
unsafe extern "C" fn xmlSchemaClearElemInfo(mut vctxt: xmlSchemaValidCtxtPtr,
                                            mut ielem: xmlSchemaNodeInfoPtr) {
    (*ielem).hasKeyrefs = 0 as std::os::raw::c_int;
    (*ielem).appliedXPath = 0 as std::os::raw::c_int;
    if (*ielem).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 {
        if !(*ielem).localName.is_null() {
            xmlFree.expect("non-null function pointer")((*ielem).localName as
                                                            *mut xmlChar as
                                                            *mut std::os::raw::c_void);
            (*ielem).localName = 0 as *const xmlChar
        }
        if !(*ielem).nsName.is_null() {
            xmlFree.expect("non-null function pointer")((*ielem).nsName as
                                                            *mut xmlChar as
                                                            *mut std::os::raw::c_void);
            (*ielem).nsName = 0 as *const xmlChar
        }
    } else {
        (*ielem).localName = 0 as *const xmlChar;
        (*ielem).nsName = 0 as *const xmlChar
    }
    if (*ielem).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
        if !(*ielem).value.is_null() {
            xmlFree.expect("non-null function pointer")((*ielem).value as
                                                            *mut xmlChar as
                                                            *mut std::os::raw::c_void);
            (*ielem).value = 0 as *const xmlChar
        }
    } else { (*ielem).value = 0 as *const xmlChar }
    if !(*ielem).val.is_null() {
        /*
	* PSVI TODO: Be careful not to free it when the value is
	* exposed via PSVI.
	*/
        xmlSchemaFreeValue((*ielem).val);
        (*ielem).val = 0 as xmlSchemaValPtr
    }
    if !(*ielem).idcMatchers.is_null() {
        /*
	* REVISIT OPTIMIZE TODO: Use a pool of IDC matchers.
	*   Does it work?
	*/
        xmlSchemaIDCReleaseMatcherList(vctxt, (*ielem).idcMatchers);
        (*ielem).idcMatchers = 0 as xmlSchemaIDCMatcherPtr
    }
    if !(*ielem).idcTable.is_null() {
        /*
	* OPTIMIZE TODO: Use a pool of IDC tables??.
	*/
        xmlSchemaIDCFreeIDCTable((*ielem).idcTable);
        (*ielem).idcTable = 0 as xmlSchemaPSVIIDCBindingPtr
    }
    if !(*ielem).regexCtxt.is_null() {
        xmlRegFreeExecCtxt((*ielem).regexCtxt);
        (*ielem).regexCtxt = 0 as xmlRegExecCtxtPtr
    }
    if !(*ielem).nsBindings.is_null() {
        xmlFree.expect("non-null function pointer")((*ielem).nsBindings as
                                                        *mut *mut xmlChar as
                                                        *mut std::os::raw::c_void);
        (*ielem).nsBindings = 0 as *mut *const xmlChar;
        (*ielem).nbNsBindings = 0 as std::os::raw::c_int;
        (*ielem).sizeNsBindings = 0 as std::os::raw::c_int
    };
}
/* *
 * xmlSchemaGetFreshElemInfo:
 * @vctxt: the schema validation context
 *
 * Creates/reuses and initializes the element info item for
 * the currect tree depth.
 *
 * Returns the element info item or NULL on API or internal errors.
 */
unsafe extern "C" fn xmlSchemaGetFreshElemInfo(mut vctxt:
                                                   xmlSchemaValidCtxtPtr)
 -> xmlSchemaNodeInfoPtr {
    let mut info: xmlSchemaNodeInfoPtr = 0 as xmlSchemaNodeInfoPtr;
    if (*vctxt).depth > (*vctxt).sizeElemInfos {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaGetFreshElemInfo\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"inconsistent depth encountered\x00" as
                                 *const u8 as *const std::os::raw::c_char);
        return 0 as xmlSchemaNodeInfoPtr
    }
    if (*vctxt).elemInfos.is_null() {
        (*vctxt).elemInfos =
            xmlMalloc.expect("non-null function pointer")((10 as std::os::raw::c_int
                                                               as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaNodeInfoPtr>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut xmlSchemaNodeInfoPtr;
        if (*vctxt).elemInfos.is_null() {
            xmlSchemaVErrMemory(vctxt,
                                b"allocating the element info array\x00" as
                                    *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return 0 as xmlSchemaNodeInfoPtr
        }
        memset((*vctxt).elemInfos as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
               (10 as std::os::raw::c_int as
                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaNodeInfoPtr>()
                                                    as std::os::raw::c_ulong));
        (*vctxt).sizeElemInfos = 10 as std::os::raw::c_int
    } else if (*vctxt).sizeElemInfos <= (*vctxt).depth {
        let mut i: std::os::raw::c_int = (*vctxt).sizeElemInfos;
        (*vctxt).sizeElemInfos *= 2 as std::os::raw::c_int;
        (*vctxt).elemInfos =
            xmlRealloc.expect("non-null function pointer")((*vctxt).elemInfos
                                                               as
                                                               *mut std::os::raw::c_void,
                                                           ((*vctxt).sizeElemInfos
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlSchemaNodeInfoPtr>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut xmlSchemaNodeInfoPtr;
        if (*vctxt).elemInfos.is_null() {
            xmlSchemaVErrMemory(vctxt,
                                b"re-allocating the element info array\x00" as
                                    *const u8 as *const std::os::raw::c_char,
                                0 as xmlNodePtr);
            return 0 as xmlSchemaNodeInfoPtr
        }
        /*
	* We need the new memory to be NULLed.
	* TODO: Use memset instead?
	*/
        while i < (*vctxt).sizeElemInfos {
            let ref mut fresh44 = *(*vctxt).elemInfos.offset(i as isize);
            *fresh44 = 0 as xmlSchemaNodeInfoPtr;
            i += 1
        }
    } else { info = *(*vctxt).elemInfos.offset((*vctxt).depth as isize) }
    if info.is_null() {
        info =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaNodeInfo>()
                                                              as
                                                              std::os::raw::c_ulong)
                as xmlSchemaNodeInfoPtr;
        if info.is_null() {
            xmlSchemaVErrMemory(vctxt,
                                b"allocating an element info\x00" as *const u8
                                    as *const std::os::raw::c_char, 0 as xmlNodePtr);
            return 0 as xmlSchemaNodeInfoPtr
        }
        let ref mut fresh45 =
            *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
        *fresh45 = info
    } else if !(*info).localName.is_null() {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaGetFreshElemInfo\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"elem info has not been cleared\x00" as
                                 *const u8 as *const std::os::raw::c_char);
        return 0 as xmlSchemaNodeInfoPtr
    }
    memset(info as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaNodeInfo>() as std::os::raw::c_ulong);
    (*info).nodeType = XML_ELEMENT_NODE as std::os::raw::c_int;
    (*info).depth = (*vctxt).depth;
    return info;
}
unsafe extern "C" fn xmlSchemaValidateFacets(mut actxt:
                                                 xmlSchemaAbstractCtxtPtr,
                                             mut node: xmlNodePtr,
                                             mut type_0: xmlSchemaTypePtr,
                                             mut valType: xmlSchemaValType,
                                             mut value: *const xmlChar,
                                             mut val: xmlSchemaValPtr,
                                             mut length: std::os::raw::c_ulong,
                                             mut fireErrors: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut ret: std::os::raw::c_int = 0;
    let mut error: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut tmpType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut facetLink: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut len: std::os::raw::c_ulong = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    let mut ws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    /*
    * In Libxml2, derived built-in types have currently no explicit facets.
    */
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
        return 0 as std::os::raw::c_int
    }
    /*
    * NOTE: Do not jump away, if the facetSet of the given type is
    * empty: until now, "pattern" and "enumeration" facets of the
    * *base types* need to be checked as well.
    */
    if !(*type_0).facetSet.is_null() {
        if (*type_0).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int == 0 {
            if (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
                current_block = 570994425937333858;
            } else { current_block = 5009689627068510803; }
        } else {
            /*
    * Whitespace handling is only of importance for string-based
    * types.
    */
            tmpType = xmlSchemaGetPrimitiveType(type_0);
            if (*tmpType).builtInType == XML_SCHEMAS_STRING as std::os::raw::c_int ||
                   (*tmpType).type_0 as std::os::raw::c_uint ==
                       XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
                       (*tmpType).builtInType ==
                           XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int {
                ws = xmlSchemaGetWhiteSpaceFacetValue(type_0)
            } else { ws = XML_SCHEMA_WHITESPACE_COLLAPSE }
            /*
    * If the value was not computed (for string or
    * anySimpleType based types), then use the provided
    * type.
    */
            if !val.is_null() { valType = xmlSchemaGetValType(val) }
            ret = 0 as std::os::raw::c_int;
            let mut current_block_25: u64;
            facetLink = (*type_0).facetSet;
            while !facetLink.is_null() {
                /*
	* Skip the pattern "whiteSpace": it is used to
	* format the character content beforehand.
	*/
                match (*(*facetLink).facet).type_0 as std::os::raw::c_uint {
                    1008 | 1006 | 1007 => {
                        current_block_25 = 15652330335145281839;
                    }
                    1009 | 1011 | 1010 => {
                        ret =
                            xmlSchemaValidateLengthFacetWhtsp((*facetLink).facet,
                                                              valType, value,
                                                              val, &mut len,
                                                              ws);
                        current_block_25 = 2719512138335094285;
                    }
                    _ => {
                        ret =
                            xmlSchemaValidateFacetWhtsp((*facetLink).facet,
                                                        ws, valType, value,
                                                        val, ws);
                        current_block_25 = 2719512138335094285;
                    }
                }
                match current_block_25 {
                    2719512138335094285 => {
                        if ret < 0 as std::os::raw::c_int {
                            xmlSchemaInternalErr(actxt,
                                                 b"xmlSchemaValidateFacets\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 b"validating against a atomic type facet\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char);
                            return -(1 as std::os::raw::c_int)
                        } else {
                            if ret > 0 as std::os::raw::c_int {
                                if fireErrors != 0 {
                                    xmlSchemaFacetErr(actxt,
                                                      ret as xmlParserErrors,
                                                      node, value, len,
                                                      type_0,
                                                      (*facetLink).facet,
                                                      0 as
                                                          *const std::os::raw::c_char,
                                                      0 as *const xmlChar,
                                                      0 as *const xmlChar);
                                } else { return ret }
                                if error == 0 as std::os::raw::c_int { error = ret }
                            }
                        }
                        ret = 0 as std::os::raw::c_int
                    }
                    _ => { }
                }
                facetLink = (*facetLink).next
            }
            current_block = 570994425937333858;
        }
        match current_block {
            5009689627068510803 => { }
            _ => {
                if !((*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int
                         == 0) {
                    /*
    * "length", "minLength" and "maxLength" of list types.
    */
                    ret = 0 as std::os::raw::c_int;
                    facetLink = (*type_0).facetSet;
                    while !facetLink.is_null() {
                        match (*(*facetLink).facet).type_0 as std::os::raw::c_uint {
                            1009 | 1011 | 1010 => {
                                ret =
                                    xmlSchemaValidateListSimpleTypeFacet((*facetLink).facet,
                                                                         value,
                                                                         length,
                                                                         0 as
                                                                             *mut std::os::raw::c_ulong);
                                if ret < 0 as std::os::raw::c_int {
                                    xmlSchemaInternalErr(actxt,
                                                         b"xmlSchemaValidateFacets\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char,
                                                         b"validating against a list type facet\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char);
                                    return -(1 as std::os::raw::c_int)
                                } else {
                                    if ret > 0 as std::os::raw::c_int {
                                        if fireErrors != 0 {
                                            xmlSchemaFacetErr(actxt,
                                                              ret as
                                                                  xmlParserErrors,
                                                              node, value,
                                                              length, type_0,
                                                              (*facetLink).facet,
                                                              0 as
                                                                  *const std::os::raw::c_char,
                                                              0 as
                                                                  *const xmlChar,
                                                              0 as
                                                                  *const xmlChar);
                                        } else { return ret }
                                        if error == 0 as std::os::raw::c_int {
                                            error = ret
                                        }
                                    }
                                }
                                ret = 0 as std::os::raw::c_int
                            }
                            _ => { }
                        }
                        facetLink = (*facetLink).next
                    }
                }
            }
        }
    }
    if error >= 0 as std::os::raw::c_int {
        let mut found: std::os::raw::c_int = 0 as std::os::raw::c_int;
        /*
	* Process enumerations. Facet values are in the value space
	* of the defining type's base type. This seems to be a bug in the
	* XML Schema 1.0 spec. Use the whitespace type of the base type.
	* Only the first set of enumerations in the ancestor-or-self axis
	* is used for validation.
	*/
        ret = 0 as std::os::raw::c_int;
        tmpType = type_0;
        loop  {
            facet = (*tmpType).facets;
            while !facet.is_null() {
                if !((*facet).type_0 as std::os::raw::c_uint !=
                         XML_SCHEMA_FACET_ENUMERATION as std::os::raw::c_int as
                             std::os::raw::c_uint) {
                    found = 1 as std::os::raw::c_int;
                    ret = xmlSchemaAreValuesEqual((*facet).val, val);
                    if ret == 1 as std::os::raw::c_int { break ; }
                    if ret < 0 as std::os::raw::c_int {
                        xmlSchemaInternalErr(actxt,
                                             b"xmlSchemaValidateFacets\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"validating against an enumeration facet\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                        return -(1 as std::os::raw::c_int)
                    }
                }
                facet = (*facet).next
            }
            if ret != 0 as std::os::raw::c_int { break ; }
            /*
	    * Break on the first set of enumerations. Any additional
	    *  enumerations which might be existent on the ancestors
	    *  of the current type are restricted by this set; thus
	    *  *must* *not* be taken into account.
	    */
            if found != 0 { break ; }
            tmpType = (*tmpType).baseType;
            if !(!tmpType.is_null() &&
                     (*tmpType).type_0 as std::os::raw::c_uint !=
                         XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint)
               {
                break ;
            }
        }
        if found != 0 && ret == 0 as std::os::raw::c_int {
            ret = XML_SCHEMAV_CVC_ENUMERATION_VALID as std::os::raw::c_int;
            if fireErrors != 0 {
                xmlSchemaFacetErr(actxt, ret as xmlParserErrors, node, value,
                                  0 as std::os::raw::c_int as std::os::raw::c_ulong, type_0,
                                  0 as xmlSchemaFacetPtr,
                                  0 as *const std::os::raw::c_char,
                                  0 as *const xmlChar, 0 as *const xmlChar);
            } else { return ret }
            if error == 0 as std::os::raw::c_int { error = ret }
        }
    }
    if error >= 0 as std::os::raw::c_int {
        let mut found_0: std::os::raw::c_int = 0;
        /*
	* Process patters. Pattern facets are ORed at type level
	* and ANDed if derived. Walk the base type axis.
	*/
        tmpType = type_0;
        facet = 0 as xmlSchemaFacetPtr;
        loop  {
            found_0 = 0 as std::os::raw::c_int;
            facetLink = (*tmpType).facetSet;
            while !facetLink.is_null() {
                if !((*(*facetLink).facet).type_0 as std::os::raw::c_uint !=
                         XML_SCHEMA_FACET_PATTERN as std::os::raw::c_int as
                             std::os::raw::c_uint) {
                    found_0 = 1 as std::os::raw::c_int;
                    /*
		* NOTE that for patterns, @value needs to be the
		* normalized vaule.
		*/
                    ret = xmlRegexpExec((*(*facetLink).facet).regexp, value);
                    if ret == 1 as std::os::raw::c_int { break ; }
                    if ret < 0 as std::os::raw::c_int {
                        xmlSchemaInternalErr(actxt,
                                             b"xmlSchemaValidateFacets\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"validating against a pattern facet\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                        return -(1 as std::os::raw::c_int)
                    } else {
                        /*
		    * Save the last non-validating facet.
		    */
                        facet = (*facetLink).facet
                    }
                }
                facetLink = (*facetLink).next
            }
            if found_0 != 0 && ret != 1 as std::os::raw::c_int {
                ret = XML_SCHEMAV_CVC_PATTERN_VALID as std::os::raw::c_int;
                if fireErrors != 0 {
                    xmlSchemaFacetErr(actxt, ret as xmlParserErrors, node,
                                      value,
                                      0 as std::os::raw::c_int as std::os::raw::c_ulong,
                                      type_0, facet, 0 as *const std::os::raw::c_char,
                                      0 as *const xmlChar,
                                      0 as *const xmlChar);
                } else { return ret }
                if error == 0 as std::os::raw::c_int { error = ret }
                break ;
            } else {
                tmpType = (*tmpType).baseType;
                if !(!tmpType.is_null() &&
                         (*tmpType).type_0 as std::os::raw::c_uint !=
                             XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as
                                 std::os::raw::c_uint) {
                    break ;
                }
            }
        }
    }
    return error;
}
unsafe extern "C" fn xmlSchemaNormalizeValue(mut type_0: xmlSchemaTypePtr,
                                             mut value: *const xmlChar)
 -> *mut xmlChar {
    match xmlSchemaGetWhiteSpaceFacetValue(type_0) as std::os::raw::c_uint {
        3 => { return xmlSchemaCollapseString(value) }
        2 => { return xmlSchemaWhiteSpaceReplace(value) }
        _ => { return 0 as *mut xmlChar }
    };
}
unsafe extern "C" fn xmlSchemaValidateQName(mut vctxt: xmlSchemaValidCtxtPtr,
                                            mut value: *const xmlChar,
                                            mut val: *mut xmlSchemaValPtr,
                                            mut valNeeded: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    let mut nsName: *const xmlChar = 0 as *const xmlChar;
    let mut local: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    ret = xmlValidateQName(value, 1 as std::os::raw::c_int);
    if ret != 0 as std::os::raw::c_int {
        if ret == -(1 as std::os::raw::c_int) {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaValidateQName\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 b"calling xmlValidateQName()\x00" as
                                     *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        return XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as std::os::raw::c_int
    }
    /*
    * NOTE: xmlSplitQName2 will always return a duplicated
    * strings.
    */
    local = xmlSplitQName2(value, &mut prefix);
    if local.is_null() { local = xmlStrdup(value) }
    /*
    * OPTIMIZE TODO: Use flags for:
    *  - is there any namespace binding?
    *  - is there a default namespace?
    */
    nsName = xmlSchemaLookupNamespace(vctxt, prefix);
    if !prefix.is_null() {
        xmlFree.expect("non-null function pointer")(prefix as
                                                        *mut std::os::raw::c_void);
        /*
	* A namespace must be found if the prefix is
	* NOT NULL.
	*/
        if nsName.is_null() {
            ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as std::os::raw::c_int;
            xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                               ret as xmlParserErrors, 0 as xmlNodePtr,
                               xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as
                                   xmlSchemaBasicItemPtr,
                               b"The QName value \'%s\' has no corresponding namespace declaration in scope\x00"
                                   as *const u8 as *const std::os::raw::c_char, value,
                               0 as *const xmlChar);
            if !local.is_null() {
                xmlFree.expect("non-null function pointer")(local as
                                                                *mut std::os::raw::c_void);
            }
            return ret
        }
    }
    if valNeeded != 0 && !val.is_null() {
        if !nsName.is_null() {
            *val = xmlSchemaNewQNameValue(xmlStrdup(nsName), local)
        } else { *val = xmlSchemaNewQNameValue(0 as *const xmlChar, local) }
    } else {
        xmlFree.expect("non-null function pointer")(local as
                                                        *mut std::os::raw::c_void);
    }
    return 0 as std::os::raw::c_int;
}
/*
* cvc-simple-type
*/
unsafe extern "C" fn xmlSchemaVCheckCVCSimpleType(mut actxt:
                                                      xmlSchemaAbstractCtxtPtr,
                                                  mut node: xmlNodePtr,
                                                  mut type_0:
                                                      xmlSchemaTypePtr,
                                                  mut value: *const xmlChar,
                                                  mut retVal:
                                                      *mut xmlSchemaValPtr,
                                                  mut fireErrors: std::os::raw::c_int,
                                                  mut normalize: std::os::raw::c_int,
                                                  mut isNormalized:
                                                      std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut valNeeded: std::os::raw::c_int =
        if !retVal.is_null() { 1 as std::os::raw::c_int } else { 0 as std::os::raw::c_int };
    let mut val: xmlSchemaValPtr = 0 as xmlSchemaValPtr;
    /* xmlSchemaWhitespaceValueType ws; */
    let mut normValue: *mut xmlChar = 0 as *mut xmlChar;
    if !retVal.is_null() && !(*retVal).is_null() {
        xmlSchemaFreeValue(*retVal);
        *retVal = 0 as xmlSchemaValPtr
    }
    /*
    * 3.14.4 Simple Type Definition Validation Rules
    * Validation Rule: String Valid
    */
    /*
    * 1 It is schema-valid with respect to that definition as defined
    * by Datatype Valid in [XML Schemas: Datatypes].
    */
    /*
    * 2.1 If The definition is ENTITY or is validly derived from ENTITY given
    * the empty set, as defined in Type Derivation OK (Simple) ($3.14.6), then
    * the string must be a `declared entity name`.
    */
    /*
    * 2.2 If The definition is ENTITIES or is validly derived from ENTITIES
    * given the empty set, as defined in Type Derivation OK (Simple) ($3.14.6),
    * then every whitespace-delimited substring of the string must be a `declared
    * entity name`.
    */
    /*
    * 2.3 otherwise no further condition applies.
    */
    if valNeeded == 0 &&
           (*type_0).flags & (1 as std::os::raw::c_int) << 21 as std::os::raw::c_int != 0 {
        valNeeded = 1 as std::os::raw::c_int
    } /* The built-in type. */
    if value.is_null() {
        value = b"\x00" as *const u8 as *const std::os::raw::c_char as *mut xmlChar
    }
    if (*type_0).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
           (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as std::os::raw::c_int
           || (*type_0).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int != 0 {
        let mut biType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        /*
	* SPEC (1.2.1) "if {variety} is `atomic` then the string must `match`
	* a literal in the `lexical space` of {base type definition}"
	*/
	/*
	* Whitespace-normalize.
	*/
        if isNormalized == 0 &&
               (normalize != 0 ||
                    (*type_0).flags & (1 as std::os::raw::c_int) << 28 as std::os::raw::c_int
                        != 0) {
            normValue = xmlSchemaNormalizeValue(type_0, value);
            if !normValue.is_null() { value = normValue }
            isNormalized = 1 as std::os::raw::c_int
        }
        if (*type_0).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint {
            /*
	    * Get the built-in type.
	    */
            biType = (*type_0).baseType;
            while !biType.is_null() &&
                      (*biType).type_0 as std::os::raw::c_uint !=
                          XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint
                  {
                biType = (*biType).baseType
            }
            if biType.is_null() {
                xmlSchemaInternalErr(actxt,
                                     b"xmlSchemaVCheckCVCSimpleType\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"could not get the built-in type\x00" as
                                         *const u8 as *const std::os::raw::c_char);
                current_block = 12658999593757842117;
            } else { current_block = 9828876828309294594; }
        } else { biType = type_0; current_block = 9828876828309294594; }
        match current_block {
            12658999593757842117 => { }
            _ =>
            /*
	* NOTATIONs need to be processed here, since they need
	* to lookup in the hashtable of NOTATION declarations of the schema.
	*/
            {
                if (*actxt).type_0 == 2 as std::os::raw::c_int {
                    match (*biType).builtInType {
                        28 => {
                            ret =
                                xmlSchemaValidateNotation(actxt as
                                                              xmlSchemaValidCtxtPtr,
                                                          (*(actxt as
                                                                 xmlSchemaValidCtxtPtr)).schema,
                                                          0 as xmlNodePtr,
                                                          value, &mut val,
                                                          valNeeded)
                        }
                        21 => {
                            ret =
                                xmlSchemaValidateQName(actxt as
                                                           xmlSchemaValidCtxtPtr,
                                                       value, &mut val,
                                                       valNeeded)
                        }
                        _ => {
                            /* ws = xmlSchemaGetWhiteSpaceFacetValue(type); */
                            if valNeeded != 0 {
                                ret =
                                    xmlSchemaValPredefTypeNodeNoNorm(biType,
                                                                     value,
                                                                     &mut val,
                                                                     node)
                            } else {
                                ret =
                                    xmlSchemaValPredefTypeNodeNoNorm(biType,
                                                                     value,
                                                                     0 as
                                                                         *mut xmlSchemaValPtr,
                                                                     node)
                            }
                        }
                    }
                    current_block = 16799951812150840583;
                } else if (*actxt).type_0 == 1 as std::os::raw::c_int {
                    match (*biType).builtInType {
                        28 => {
                            ret =
                                xmlSchemaValidateNotation(0 as
                                                              xmlSchemaValidCtxtPtr,
                                                          (*(actxt as
                                                                 xmlSchemaParserCtxtPtr)).schema,
                                                          node, value,
                                                          &mut val, valNeeded)
                        }
                        _ => {
                            /* ws = xmlSchemaGetWhiteSpaceFacetValue(type); */
                            if valNeeded != 0 {
                                ret =
                                    xmlSchemaValPredefTypeNodeNoNorm(biType,
                                                                     value,
                                                                     &mut val,
                                                                     node)
                            } else {
                                ret =
                                    xmlSchemaValPredefTypeNodeNoNorm(biType,
                                                                     value,
                                                                     0 as
                                                                         *mut xmlSchemaValPtr,
                                                                     node)
                            }
                        }
                    }
                    current_block = 16799951812150840583;
                } else {
                    /*
	    * Validation via a public API is not implemented yet.
	    */
                    (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                               b"Unimplemented block at %s:%d\n\x00"
                                                                                   as
                                                                                   *const u8
                                                                                   as
                                                                                   *const std::os::raw::c_char,
                                                                               b"xmlschemas.c\x00"
                                                                                   as
                                                                                   *const u8
                                                                                   as
                                                                                   *const std::os::raw::c_char,
                                                                               24636
                                                                                   as
                                                                                   std::os::raw::c_int);
                    current_block = 12658999593757842117;
                }
                match current_block {
                    12658999593757842117 => { }
                    _ => {
                        if ret != 0 as std::os::raw::c_int {
                            if ret < 0 as std::os::raw::c_int {
                                xmlSchemaInternalErr(actxt,
                                                     b"xmlSchemaVCheckCVCSimpleType\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char,
                                                     b"validating against a built-in type\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char);
                                current_block = 12658999593757842117;
                            } else {
                                if (*type_0).flags &
                                       (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int
                                       != 0 {
                                    ret =
                                        XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2
                                            as std::os::raw::c_int
                                } else {
                                    ret =
                                        XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1
                                            as std::os::raw::c_int
                                }
                                current_block = 13826291924415791078;
                            }
                        } else { current_block = 13826291924415791078; }
                        match current_block {
                            12658999593757842117 => { }
                            _ => {
                                if ret == 0 as std::os::raw::c_int &&
                                       (*type_0).flags &
                                           (1 as std::os::raw::c_int) <<
                                               27 as std::os::raw::c_int != 0 {
                                    /*
	    * Check facets.
	    */
                                    ret =
                                        xmlSchemaValidateFacets(actxt, node,
                                                                type_0,
                                                                (*biType).builtInType
                                                                    as
                                                                    xmlSchemaValType,
                                                                value, val,
                                                                0 as
                                                                    std::os::raw::c_int
                                                                    as
                                                                    std::os::raw::c_ulong,
                                                                fireErrors);
                                    if ret != 0 as std::os::raw::c_int {
                                        if ret < 0 as std::os::raw::c_int {
                                            xmlSchemaInternalErr(actxt,
                                                                 b"xmlSchemaVCheckCVCSimpleType\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const std::os::raw::c_char,
                                                                 b"validating facets of atomic simple type\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const std::os::raw::c_char);
                                            current_block =
                                                12658999593757842117;
                                        } else {
                                            if (*type_0).flags &
                                                   (1 as std::os::raw::c_int) <<
                                                       6 as std::os::raw::c_int != 0 {
                                                ret =
                                                    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2
                                                        as std::os::raw::c_int
                                            } else {
                                                ret =
                                                    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1
                                                        as std::os::raw::c_int
                                            }
                                            current_block =
                                                15594603006322722090;
                                        }
                                    } else {
                                        current_block = 15594603006322722090;
                                    }
                                } else {
                                    current_block = 15594603006322722090;
                                }
                                match current_block {
                                    12658999593757842117 => { }
                                    _ => {
                                        if fireErrors != 0 &&
                                               ret > 0 as std::os::raw::c_int {
                                            xmlSchemaSimpleTypeErr(actxt,
                                                                   ret as
                                                                       xmlParserErrors,
                                                                   node,
                                                                   value,
                                                                   type_0,
                                                                   1 as
                                                                       std::os::raw::c_int);
                                        }
                                        current_block = 8953117030348968745;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else if (*type_0).flags & (1 as std::os::raw::c_int) << 6 as std::os::raw::c_int != 0 {
        let mut itemType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        let mut cur: *const xmlChar = 0 as *const xmlChar;
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut tmpValue: *mut xmlChar = 0 as *mut xmlChar;
        let mut len: std::os::raw::c_ulong = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
        let mut prevVal: xmlSchemaValPtr = 0 as xmlSchemaValPtr;
        let mut curVal: xmlSchemaValPtr = 0 as xmlSchemaValPtr;
        /* 1.2.2 if {variety} is `list` then the string must be a sequence
	* of white space separated tokens, each of which `match`es a literal
	* in the `lexical space` of {item type definition}
	*/
	/*
	* Note that XML_SCHEMAS_TYPE_NORMVALUENEEDED will be set if
	* the list type has an enum or pattern facet.
	*/
        if isNormalized == 0 &&
               (normalize != 0 ||
                    (*type_0).flags & (1 as std::os::raw::c_int) << 28 as std::os::raw::c_int
                        != 0) {
            normValue = xmlSchemaNormalizeValue(type_0, value);
            if !normValue.is_null() { value = normValue }
            isNormalized = 1 as std::os::raw::c_int
        }
        /*
	* VAL TODO: Optimize validation of empty values.
	* VAL TODO: We do not have computed values for lists.
	*/
        itemType = (*type_0).subtypes;
        cur = value;
        loop  {
            while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                      0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                          *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                      *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                cur = cur.offset(1)
            }
            end = cur;
            while *end as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                      !(*end as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                            0x9 as std::os::raw::c_int <= *end as std::os::raw::c_int &&
                                *end as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                            *end as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
                end = end.offset(1)
            }
            if end == cur { current_block = 4804377075063615140; break ; }
            tmpValue =
                xmlStrndup(cur,
                           end.offset_from(cur) as std::os::raw::c_long as
                               std::os::raw::c_int);
            len = len.wrapping_add(1);
            if valNeeded != 0 {
                ret =
                    xmlSchemaVCheckCVCSimpleType(actxt, node, itemType,
                                                 tmpValue, &mut curVal,
                                                 fireErrors, 0 as std::os::raw::c_int,
                                                 1 as std::os::raw::c_int)
            } else {
                ret =
                    xmlSchemaVCheckCVCSimpleType(actxt, node, itemType,
                                                 tmpValue,
                                                 0 as *mut xmlSchemaValPtr,
                                                 fireErrors, 0 as std::os::raw::c_int,
                                                 1 as std::os::raw::c_int)
            }
            if !tmpValue.is_null() {
                xmlFree.expect("non-null function pointer")(tmpValue as
                                                                *mut std::os::raw::c_void);
                tmpValue = 0 as *mut xmlChar
            }
            if !curVal.is_null() {
                /*
		* Add to list of computed values.
		*/
                if val.is_null() {
                    val = curVal
                } else { xmlSchemaValueAppend(prevVal, curVal); }
                prevVal = curVal;
                curVal = 0 as xmlSchemaValPtr
            }
            if ret != 0 as std::os::raw::c_int {
                if ret < 0 as std::os::raw::c_int {
                    xmlSchemaInternalErr(actxt,
                                         b"xmlSchemaVCheckCVCSimpleType\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char,
                                         b"validating an item of list simple type\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    current_block = 12658999593757842117;
                    break ;
                } else {
                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as std::os::raw::c_int;
                    current_block = 4804377075063615140;
                    break ;
                }
            } else {
                cur = end;
                if !(*cur as std::os::raw::c_int != 0 as std::os::raw::c_int) {
                    current_block = 4804377075063615140;
                    break ;
                }
            }
        }
        match current_block {
            12658999593757842117 => { }
            _ => {
                if !tmpValue.is_null() {
                    xmlFree.expect("non-null function pointer")(tmpValue as
                                                                    *mut std::os::raw::c_void);
                    tmpValue = 0 as *mut xmlChar
                }
                if ret == 0 as std::os::raw::c_int &&
                       (*type_0).flags &
                           (1 as std::os::raw::c_int) << 27 as std::os::raw::c_int != 0 {
                    /*
	    * Apply facets (pattern, enumeration).
	    */
                    ret =
                        xmlSchemaValidateFacets(actxt, node, type_0,
                                                XML_SCHEMAS_UNKNOWN, value,
                                                val, len, fireErrors);
                    if ret != 0 as std::os::raw::c_int {
                        if ret < 0 as std::os::raw::c_int {
                            xmlSchemaInternalErr(actxt,
                                                 b"xmlSchemaVCheckCVCSimpleType\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 b"validating facets of list simple type\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char);
                            current_block = 12658999593757842117;
                        } else {
                            ret =
                                XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as
                                    std::os::raw::c_int;
                            current_block = 8533724845731836612;
                        }
                    } else { current_block = 8533724845731836612; }
                } else { current_block = 8533724845731836612; }
                match current_block {
                    12658999593757842117 => { }
                    _ => {
                        if fireErrors != 0 && ret > 0 as std::os::raw::c_int {
                            /*
	    * Report the normalized value.
	    */
                            normalize = 1 as std::os::raw::c_int;
                            if isNormalized == 0 &&
                                   (normalize != 0 ||
                                        (*type_0).flags &
                                            (1 as std::os::raw::c_int) <<
                                                28 as std::os::raw::c_int != 0) {
                                normValue =
                                    xmlSchemaNormalizeValue(type_0, value);
                                if !normValue.is_null() { value = normValue }
                                isNormalized = 1 as std::os::raw::c_int
                            }
                            xmlSchemaSimpleTypeErr(actxt,
                                                   ret as xmlParserErrors,
                                                   node, value, type_0,
                                                   1 as std::os::raw::c_int);
                        }
                        current_block = 8953117030348968745;
                    }
                }
            }
        }
    } else if (*type_0).flags & (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int != 0 {
        let mut memberLink: xmlSchemaTypeLinkPtr =
            0 as *mut xmlSchemaTypeLink;
        /*
	* TODO: For all datatypes `derived` by `union`  whiteSpace does
	* not apply directly; however, the normalization behavior of `union`
	* types is controlled by the value of whiteSpace on that one of the
	* `memberTypes` against which the `union` is successfully validated.
	*
	* This means that the value is normalized by the first validating
	* member type, then the facets of the union type are applied. This
	* needs changing of the value!
	*/
        /*
	* 1.2.3 if {variety} is `union` then the string must `match` a
	* literal in the `lexical space` of at least one member of
	* {member type definitions}
	*/
        memberLink = xmlSchemaGetUnionSimpleTypeMemberTypes(type_0);
        if memberLink.is_null() {
            xmlSchemaInternalErr(actxt,
                                 b"xmlSchemaVCheckCVCSimpleType\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"union simple type has no member types\x00"
                                     as *const u8 as *const std::os::raw::c_char);
            current_block = 12658999593757842117;
        } else {
            /*
	* Always normalize union type values, since we currently
	* cannot store the whitespace information with the value
	* itself; otherwise a later value-comparison would be
	* not possible.
	*/
            while !memberLink.is_null() {
                if valNeeded != 0 {
                    ret =
                        xmlSchemaVCheckCVCSimpleType(actxt, node,
                                                     (*memberLink).type_0,
                                                     value, &mut val,
                                                     0 as std::os::raw::c_int,
                                                     1 as std::os::raw::c_int,
                                                     0 as std::os::raw::c_int)
                } else {
                    ret =
                        xmlSchemaVCheckCVCSimpleType(actxt, node,
                                                     (*memberLink).type_0,
                                                     value,
                                                     0 as
                                                         *mut xmlSchemaValPtr,
                                                     0 as std::os::raw::c_int,
                                                     1 as std::os::raw::c_int,
                                                     0 as std::os::raw::c_int)
                }
                if ret <= 0 as std::os::raw::c_int { break ; }
                memberLink = (*memberLink).next
            }
            if ret != 0 as std::os::raw::c_int {
                if ret < 0 as std::os::raw::c_int {
                    xmlSchemaInternalErr(actxt,
                                         b"xmlSchemaVCheckCVCSimpleType\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char,
                                         b"validating members of union simple type\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    current_block = 12658999593757842117;
                } else {
                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3 as std::os::raw::c_int;
                    current_block = 4871270227279186910;
                }
            } else { current_block = 4871270227279186910; }
            match current_block {
                12658999593757842117 => { }
                _ =>
                /*
	* Apply facets (pattern, enumeration).
	*/
                {
                    if ret == 0 as std::os::raw::c_int &&
                           (*type_0).flags &
                               (1 as std::os::raw::c_int) << 27 as std::os::raw::c_int != 0 {
                        /*
	    * The normalization behavior of `union` types is controlled by
	    * the value of whiteSpace on that one of the `memberTypes`
	    * against which the `union` is successfully validated.
	    */
                        if isNormalized == 0 &&
                               (normalize != 0 ||
                                    (*type_0).flags &
                                        (1 as std::os::raw::c_int) <<
                                            28 as std::os::raw::c_int != 0) {
                            normValue =
                                xmlSchemaNormalizeValue((*memberLink).type_0,
                                                        value);
                            if !normValue.is_null() { value = normValue }
                            isNormalized = 1 as std::os::raw::c_int
                        }
                        ret =
                            xmlSchemaValidateFacets(actxt, node, type_0,
                                                    XML_SCHEMAS_UNKNOWN,
                                                    value, val,
                                                    0 as std::os::raw::c_int as
                                                        std::os::raw::c_ulong,
                                                    fireErrors);
                        if ret != 0 as std::os::raw::c_int {
                            if ret < 0 as std::os::raw::c_int {
                                xmlSchemaInternalErr(actxt,
                                                     b"xmlSchemaVCheckCVCSimpleType\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char,
                                                     b"validating facets of union simple type\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char);
                                current_block = 12658999593757842117;
                            } else {
                                ret =
                                    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3 as
                                        std::os::raw::c_int;
                                current_block = 7198204517578597543;
                            }
                        } else { current_block = 7198204517578597543; }
                    } else { current_block = 7198204517578597543; }
                    match current_block {
                        12658999593757842117 => { }
                        _ => {
                            if fireErrors != 0 && ret > 0 as std::os::raw::c_int {
                                xmlSchemaSimpleTypeErr(actxt,
                                                       ret as xmlParserErrors,
                                                       node, value, type_0,
                                                       1 as std::os::raw::c_int);
                            }
                            current_block = 8953117030348968745;
                        }
                    }
                }
            }
        }
    } else { current_block = 8953117030348968745; }
    match current_block {
        12658999593757842117 => {
            if !normValue.is_null() {
                xmlFree.expect("non-null function pointer")(normValue as
                                                                *mut std::os::raw::c_void);
            }
            if !val.is_null() { xmlSchemaFreeValue(val); }
            return -(1 as std::os::raw::c_int)
        }
        _ => {
            if !normValue.is_null() {
                xmlFree.expect("non-null function pointer")(normValue as
                                                                *mut std::os::raw::c_void);
            }
            if ret == 0 as std::os::raw::c_int {
                if !retVal.is_null() {
                    *retVal = val
                } else if !val.is_null() { xmlSchemaFreeValue(val); }
            } else if !val.is_null() { xmlSchemaFreeValue(val); }
            return ret
        }
    };
}
unsafe extern "C" fn xmlSchemaVExpandQName(mut vctxt: xmlSchemaValidCtxtPtr,
                                           mut value: *const xmlChar,
                                           mut nsName: *mut *const xmlChar,
                                           mut localName: *mut *const xmlChar)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if nsName.is_null() || localName.is_null() { return -(1 as std::os::raw::c_int) }
    *nsName = 0 as *const xmlChar;
    *localName = 0 as *const xmlChar;
    ret = xmlValidateQName(value, 1 as std::os::raw::c_int);
    if ret == -(1 as std::os::raw::c_int) { return -(1 as std::os::raw::c_int) }
    if ret > 0 as std::os::raw::c_int {
        xmlSchemaSimpleTypeErr(vctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1,
                               0 as xmlNodePtr, value,
                               xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
                               1 as std::os::raw::c_int);
        return 1 as std::os::raw::c_int
    }
    let mut local: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    /*
	* NOTE: xmlSplitQName2 will return a duplicated
	* string.
	*/
    local = xmlSplitQName2(value, &mut prefix);
    if local.is_null() {
        *localName = xmlDictLookup((*vctxt).dict, value, -(1 as std::os::raw::c_int))
    } else {
        *localName = xmlDictLookup((*vctxt).dict, local, -(1 as std::os::raw::c_int));
        xmlFree.expect("non-null function pointer")(local as
                                                        *mut std::os::raw::c_void);
    }
    *nsName = xmlSchemaLookupNamespace(vctxt, prefix);
    if !prefix.is_null() {
        xmlFree.expect("non-null function pointer")(prefix as
                                                        *mut std::os::raw::c_void);
        /*
	    * A namespace must be found if the prefix is NOT NULL.
	    */
        if (*nsName).is_null() {
            xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1,
                               0 as xmlNodePtr,
                               xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as
                                   xmlSchemaBasicItemPtr,
                               b"The QName value \'%s\' has no corresponding namespace declaration in scope\x00"
                                   as *const u8 as *const std::os::raw::c_char, value,
                               0 as *const xmlChar);
            return 2 as std::os::raw::c_int
        }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaProcessXSIType(mut vctxt: xmlSchemaValidCtxtPtr,
                                             mut iattr: xmlSchemaAttrInfoPtr,
                                             mut localType:
                                                 *mut xmlSchemaTypePtr,
                                             mut elemDecl:
                                                 xmlSchemaElementPtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
    * cvc-elt (3.3.4) : (4)
    * AND
    * Schema-Validity Assessment (Element) (cvc-assess-elt)
    *   (1.2.1.2.1) - (1.2.1.2.4)
    * Handle 'xsi:type'.
    */
    if localType.is_null() { return -(1 as std::os::raw::c_int) }
    *localType = 0 as xmlSchemaTypePtr;
    if iattr.is_null() {
        return 0 as std::os::raw::c_int
    } else {
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        let mut local: *const xmlChar = 0 as *const xmlChar;
        /*
	* TODO: We should report a *warning* that the type was overriden
	* by the instance.
	*/
        (*vctxt).inode = iattr as xmlSchemaNodeInfoPtr;
        /*
	* (cvc-elt) (3.3.4) : (4.1)
	* (cvc-assess-elt) (1.2.1.2.2)
	*/
        ret =
            xmlSchemaVExpandQName(vctxt, (*iattr).value, &mut nsName,
                                  &mut local);
        if ret != 0 as std::os::raw::c_int {
            if ret < 0 as std::os::raw::c_int {
                xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaValidateElementByDeclaration\x00"
                                         as *const u8 as *const std::os::raw::c_char,
                                     b"calling xmlSchemaQNameExpand() to validate the attribute \'xsi:type\'\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                (*vctxt).inode =
                    *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
                return -(1 as std::os::raw::c_int)
            }
        } else {
            /*
	* (cvc-elt) (3.3.4) : (4.2)
	* (cvc-assess-elt) (1.2.1.2.3)
	*/
            *localType = xmlSchemaGetType((*vctxt).schema, local, nsName);
            if (*localType).is_null() {
                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                   XML_SCHEMAV_CVC_ELT_4_2, 0 as xmlNodePtr,
                                   xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME)
                                       as xmlSchemaBasicItemPtr,
                                   b"The QName value \'%s\' of the xsi:type attribute does not resolve to a type definition\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlSchemaFormatQName(&mut str, nsName,
                                                        local),
                                   0 as *const xmlChar);
                if !str.is_null() {
                    xmlFree.expect("non-null function pointer")(str as
                                                                    *mut std::os::raw::c_void);
                    str = 0 as *mut xmlChar
                }
                ret = (*vctxt).err
            } else if !elemDecl.is_null() {
                let mut set: std::os::raw::c_int = 0 as std::os::raw::c_int;
                /*
	    * SPEC cvc-elt (3.3.4) : (4.3) (Type Derivation OK)
	    * "The `local type definition` must be validly
	    * derived from the {type definition} given the union of
	    * the {disallowed substitutions} and the {type definition}'s
	    * {prohibited substitutions}, as defined in
	    * Type Derivation OK (Complex) ($3.4.6)
	    * (if it is a complex type definition),
	    * or given {disallowed substitutions} as defined in Type
	    * Derivation OK (Simple) ($3.14.6) (if it is a simple type
	    * definition)."
	    *
	    * {disallowed substitutions}: the "block" on the element decl.
	    * {prohibited substitutions}: the "block" on the type def.
	    */
	    /*
	    * OPTIMIZE TODO: We could map types already evaluated
	    * to be validly derived from other types to avoid checking
	    * this over and over for the same types.
	    */
                if (*elemDecl).flags & (1 as std::os::raw::c_int) << 11 as std::os::raw::c_int
                       != 0 ||
                       (*(*elemDecl).subtypes).flags &
                           (1 as std::os::raw::c_int) << 18 as std::os::raw::c_int != 0 {
                    set |= (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int
                }
                if (*elemDecl).flags & (1 as std::os::raw::c_int) << 12 as std::os::raw::c_int
                       != 0 ||
                       (*(*elemDecl).subtypes).flags &
                           (1 as std::os::raw::c_int) << 19 as std::os::raw::c_int != 0 {
                    set |= (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
                }
                /*
	    * REMOVED and CHANGED since this produced a parser context
	    * which adds to the string dict of the schema. So this would
	    * change the schema and we don't want this. We don't need
	    * the parser context anymore.
	    *
	    * if ((vctxt->pctxt == NULL) &&
	    *	(xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -1))
	    *	    return (-1);
	    */
                if xmlSchemaCheckCOSDerivedOK(vctxt as
                                                  xmlSchemaAbstractCtxtPtr,
                                              *localType,
                                              (*elemDecl).subtypes, set) !=
                       0 as std::os::raw::c_int {
                    let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAV_CVC_ELT_4_3,
                                       0 as xmlNodePtr,
                                       0 as xmlSchemaBasicItemPtr,
                                       b"The type definition \'%s\', specified by xsi:type, is blocked or not validly derived from the type definition of the element declaration\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlSchemaFormatQName(&mut str_0,
                                                            (**localType).targetNamespace,
                                                            (**localType).name),
                                       0 as *const xmlChar);
                    if !str_0.is_null() {
                        xmlFree.expect("non-null function pointer")(str_0 as
                                                                        *mut std::os::raw::c_void);
                        str_0 = 0 as *mut xmlChar
                    }
                    ret = (*vctxt).err;
                    *localType = 0 as xmlSchemaTypePtr
                }
            }
        }
        (*vctxt).inode = *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
        return ret
    };
}
unsafe extern "C" fn xmlSchemaValidateElemDecl(mut vctxt:
                                                   xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut elemDecl: xmlSchemaElementPtr = (*(*vctxt).inode).decl;
    let mut actualType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    /*
    * cvc-elt (3.3.4) : 1
    */
    if elemDecl.is_null() {
        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAV_CVC_ELT_1, 0 as xmlNodePtr,
                           0 as xmlSchemaBasicItemPtr,
                           b"No matching declaration available\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return (*vctxt).err
    }
    actualType = (*elemDecl).subtypes;
    /*
    * cvc-elt (3.3.4) : 2
    */
    if (*elemDecl).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int != 0 {
        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAV_CVC_ELT_2, 0 as xmlNodePtr,
                           0 as xmlSchemaBasicItemPtr,
                           b"The element declaration is abstract\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return (*vctxt).err
    }
    if actualType.is_null() {
        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAV_CVC_TYPE_1, 0 as xmlNodePtr,
                           0 as xmlSchemaBasicItemPtr,
                           b"The type definition is absent\x00" as *const u8
                               as *const std::os::raw::c_char, 0 as *const xmlChar,
                           0 as *const xmlChar);
        return XML_SCHEMAV_CVC_TYPE_1 as std::os::raw::c_int
    }
    if (*vctxt).nbAttrInfos != 0 as std::os::raw::c_int {
        let mut ret: std::os::raw::c_int = 0;
        let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
        /*
	* cvc-elt (3.3.4) : 3
	* Handle 'xsi:nil'.
	*/
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 2 as std::os::raw::c_int);
        if !iattr.is_null() {
            (*vctxt).inode = iattr as xmlSchemaNodeInfoPtr;
            /*
	    * Validate the value.
	    */
            ret =
                xmlSchemaVCheckCVCSimpleType(vctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             0 as xmlNodePtr,
                                             xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
                                             (*iattr).value,
                                             &mut (*iattr).val,
                                             1 as std::os::raw::c_int,
                                             0 as std::os::raw::c_int,
                                             0 as std::os::raw::c_int);
            (*vctxt).inode =
                *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
            if ret < 0 as std::os::raw::c_int {
                xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaValidateElemDecl\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"calling xmlSchemaVCheckCVCSimpleType() to validate the attribute \'xsi:nil\'\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            if ret == 0 as std::os::raw::c_int {
                if (*elemDecl).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int
                       == 0 as std::os::raw::c_int {
                    /*
		    * cvc-elt (3.3.4) : 3.1
		    */
                    xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                       XML_SCHEMAV_CVC_ELT_3_1,
                                       0 as xmlNodePtr,
                                       0 as xmlSchemaBasicItemPtr,
                                       b"The element is not \'nillable\'\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       0 as *const xmlChar,
                                       0 as *const xmlChar);
                    /* Does not return an error on purpose. */
                } else if xmlSchemaValueGetAsBoolean((*iattr).val) != 0 {
                    /*
			* cvc-elt (3.3.4) : 3.2.2
			*/
                    if (*elemDecl).flags &
                           (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0 &&
                           !(*elemDecl).value.is_null() {
                        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                           XML_SCHEMAV_CVC_ELT_3_2_2,
                                           0 as xmlNodePtr,
                                           0 as xmlSchemaBasicItemPtr,
                                           b"The element cannot be \'nilled\' because there is a fixed value constraint defined for it\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           0 as *const xmlChar,
                                           0 as *const xmlChar);
                        /* Does not return an error on purpose. */
                    } else {
                        (*(*vctxt).inode).flags |=
                            (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int
                    }
                }
            }
        }
        /*
	* cvc-elt (3.3.4) : 4
	* Handle 'xsi:type'.
	*/
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as std::os::raw::c_int);
        if !iattr.is_null() {
            let mut localType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
            ret =
                xmlSchemaProcessXSIType(vctxt, iattr, &mut localType,
                                        elemDecl);
            if ret != 0 as std::os::raw::c_int {
                if ret == -(1 as std::os::raw::c_int) {
                    xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaValidateElemDecl\x00" as
                                             *const u8 as *const std::os::raw::c_char,
                                         b"calling xmlSchemaProcessXSIType() to process the attribute \'xsi:type\'\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    return -(1 as std::os::raw::c_int)
                }
                /* Does not return an error on purpose. */
            }
            if !localType.is_null() {
                (*(*vctxt).inode).flags |=
                    (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int;
                actualType = localType
            }
        }
    }
    /*
    * IDC: Register identity-constraint XPath matchers.
    */
    if !(*elemDecl).idcs.is_null() &&
           xmlSchemaIDCRegisterMatchers(vctxt, elemDecl) ==
               -(1 as std::os::raw::c_int) {
        return -(1 as std::os::raw::c_int)
    }
    /*
    * No actual type definition.
    */
    if actualType.is_null() {
        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAV_CVC_TYPE_1, 0 as xmlNodePtr,
                           0 as xmlSchemaBasicItemPtr,
                           b"The type definition is absent\x00" as *const u8
                               as *const std::os::raw::c_char, 0 as *const xmlChar,
                           0 as *const xmlChar);
        return XML_SCHEMAV_CVC_TYPE_1 as std::os::raw::c_int
    }
    /*
    * Remember the actual type definition.
    */
    (*(*vctxt).inode).typeDef = actualType;
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaVAttributesSimple(mut vctxt:
                                                    xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut i: std::os::raw::c_int = 0;
    /*
    * SPEC cvc-type (3.1.1)
    * "The attributes of must be empty, excepting those whose namespace
    * name is identical to http://www.w3.org/2001/XMLSchema-instance and
    * whose local name is one of type, nil, schemaLocation or
    * noNamespaceSchemaLocation."
    */
    if (*vctxt).nbAttrInfos == 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    i = 0 as std::os::raw::c_int;
    while i < (*vctxt).nbAttrInfos {
        iattr = *(*vctxt).attrInfos.offset(i as isize);
        if (*iattr).metaType == 0 {
            (*vctxt).inode = iattr as xmlSchemaNodeInfoPtr;
            xmlSchemaIllegalAttrErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                    XML_SCHEMAV_CVC_TYPE_3_1_1, iattr,
                                    0 as xmlNodePtr);
            ret = XML_SCHEMAV_CVC_TYPE_3_1_1 as std::os::raw::c_int
        }
        i += 1
    }
    (*vctxt).inode = *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
    return ret;
}
/*
* Cleanup currently used attribute infos.
*/
unsafe extern "C" fn xmlSchemaClearAttrInfos(mut vctxt:
                                                 xmlSchemaValidCtxtPtr) {
    let mut i: std::os::raw::c_int = 0;
    let mut attr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    if (*vctxt).nbAttrInfos == 0 as std::os::raw::c_int { return }
    i = 0 as std::os::raw::c_int;
    while i < (*vctxt).nbAttrInfos {
        attr = *(*vctxt).attrInfos.offset(i as isize);
        if (*attr).flags & (1 as std::os::raw::c_int) << 0 as std::os::raw::c_int != 0 {
            if !(*attr).localName.is_null() {
                xmlFree.expect("non-null function pointer")((*attr).localName
                                                                as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            if !(*attr).nsName.is_null() {
                xmlFree.expect("non-null function pointer")((*attr).nsName as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
        }
        if (*attr).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int != 0 {
            if !(*attr).value.is_null() {
                xmlFree.expect("non-null function pointer")((*attr).value as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
        }
        if !(*attr).val.is_null() {
            xmlSchemaFreeValue((*attr).val);
            (*attr).val = 0 as xmlSchemaValPtr
        }
        memset(attr as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
               ::std::mem::size_of::<xmlSchemaAttrInfo>() as std::os::raw::c_ulong);
        i += 1
    }
    (*vctxt).nbAttrInfos = 0 as std::os::raw::c_int;
}
/*
* 3.4.4 Complex Type Definition Validation Rules
*   Element Locally Valid (Complex Type) (cvc-complex-type)
* 3.2.4 Attribute Declaration Validation Rules
*   Validation Rule: Attribute Locally Valid (cvc-attribute)
*   Attribute Locally Valid (Use) (cvc-au)
*
* Only "assessed" attribute information items will be visible to
* IDCs. I.e. not "lax" (without declaration) and "skip" wild attributes.
*/
unsafe extern "C" fn xmlSchemaVAttributesComplex(mut vctxt:
                                                     xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut type_0: xmlSchemaTypePtr = (*(*vctxt).inode).typeDef;
    let mut attrUseList: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut attrUse: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    let mut attrDecl: xmlSchemaAttributePtr = 0 as xmlSchemaAttributePtr;
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    let mut tmpiattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut found: std::os::raw::c_int = 0;
    let mut nbAttrs: std::os::raw::c_int = 0;
    let mut nbUses: std::os::raw::c_int = 0;
    let mut xpathRes: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut res: std::os::raw::c_int = 0;
    let mut wildIDs: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut fixed: std::os::raw::c_int = 0;
    let mut defAttrOwnerElem: xmlNodePtr = 0 as xmlNodePtr;
    /*
    * SPEC (cvc-attribute)
    * (1) "The declaration must not be `absent` (see Missing
    * Sub-components ($5.3) for how this can fail to be
    * the case)."
    * (2) "Its {type definition} must not be absent."
    *
    * NOTE (1) + (2): This is not handled here, since we currently do not
    * allow validation against schemas which have missing sub-components.
    *
    * SPEC (cvc-complex-type)
    * (3) "For each attribute information item in the element information
    * item's [attributes] excepting those whose [namespace name] is
    * identical to http://www.w3.org/2001/XMLSchema-instance and whose
    * [local name] is one of type, nil, schemaLocation or
    * noNamespaceSchemaLocation, the appropriate case among the following
    * must be true:
    *
    */
    attrUseList = (*type_0).attrUses as xmlSchemaItemListPtr;
    /*
    * @nbAttrs is the number of attributes present in the instance.
    */
    nbAttrs = (*vctxt).nbAttrInfos;
    if !attrUseList.is_null() {
        nbUses = (*attrUseList).nbItems
    } else { nbUses = 0 as std::os::raw::c_int }
    i = 0 as std::os::raw::c_int;
    while i < nbUses {
        found = 0 as std::os::raw::c_int;
        attrUse =
            *(*attrUseList).items.offset(i as isize) as
                xmlSchemaAttributeUsePtr;
        attrDecl = (*attrUse).attrDecl;
        j = 0 as std::os::raw::c_int;
        while j < nbAttrs {
            iattr = *(*vctxt).attrInfos.offset(j as isize);
            /*
	    * SPEC (cvc-complex-type) (3)
	    * Skip meta attributes.
	    */
            if !((*iattr).metaType != 0) {
                if !(*(*iattr).localName.offset(0 as std::os::raw::c_int as isize) as
                         std::os::raw::c_int !=
                         *(*attrDecl).name.offset(0 as std::os::raw::c_int as isize)
                             as std::os::raw::c_int) {
                    if !(xmlStrEqual((*iattr).localName, (*attrDecl).name) ==
                             0) {
                        if !(xmlStrEqual((*iattr).nsName,
                                         (*attrDecl).targetNamespace) == 0) {
                            found = 1 as std::os::raw::c_int;
                            /*
	    * SPEC (cvc-complex-type)
	    * (3.1) "If there is among the {attribute uses} an attribute
	    * use with an {attribute declaration} whose {name} matches
	    * the attribute information item's [local name] and whose
	    * {target namespace} is identical to the attribute information
	    * item's [namespace name] (where an `absent` {target namespace}
	    * is taken to be identical to a [namespace name] with no value),
	    * then the attribute information must be `valid` with respect
	    * to that attribute use as per Attribute Locally Valid (Use)
	    * ($3.5.4). In this case the {attribute declaration} of that
	    * attribute use is the `context-determined declaration` for the
	    * attribute information item with respect to Schema-Validity
	    * Assessment (Attribute) ($3.2.4) and
	    * Assessment Outcome (Attribute) ($3.2.5).
	    */
                            (*iattr).state = 2 as std::os::raw::c_int;
                            (*iattr).use_0 = attrUse;
                            /*
	    * Context-determined declaration.
	    */
                            (*iattr).decl = attrDecl;
                            (*iattr).typeDef = (*attrDecl).subtypes;
                            break ;
                        }
                    }
                }
            }
            j += 1
        }
        if !(found != 0) {
            if (*attrUse).occurs == 1 as std::os::raw::c_int {
                /*
	    * Handle non-existent, required attributes.
	    *
	    * SPEC (cvc-complex-type)
	    * (4) "The {attribute declaration} of each attribute use in
	    * the {attribute uses} whose {required} is true matches one
	    * of the attribute information items in the element information
	    * item's [attributes] as per clause 3.1 above."
	    */
                tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);
                if tmpiattr.is_null() {
                    xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaVAttributesComplex\x00" as
                                             *const u8 as *const std::os::raw::c_char,
                                         b"calling xmlSchemaGetFreshAttrInfo()\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    return -(1 as std::os::raw::c_int)
                }
                (*tmpiattr).state = 4 as std::os::raw::c_int;
                (*tmpiattr).use_0 = attrUse;
                (*tmpiattr).decl = attrDecl
            } else if (*attrUse).occurs == 2 as std::os::raw::c_int &&
                          (!(*attrUse).defValue.is_null() ||
                               !(*attrDecl).defValue.is_null()) {
                /*
	    * Handle non-existent, optional, default/fixed attributes.
	    */
                tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);
                if tmpiattr.is_null() {
                    xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaVAttributesComplex\x00" as
                                             *const u8 as *const std::os::raw::c_char,
                                         b"calling xmlSchemaGetFreshAttrInfo()\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    return -(1 as std::os::raw::c_int)
                }
                (*tmpiattr).state = 8 as std::os::raw::c_int;
                (*tmpiattr).use_0 = attrUse;
                (*tmpiattr).decl = attrDecl;
                (*tmpiattr).typeDef = (*attrDecl).subtypes;
                (*tmpiattr).localName = (*attrDecl).name;
                (*tmpiattr).nsName = (*attrDecl).targetNamespace
            }
        }
        i += 1
    }
    if (*vctxt).nbAttrInfos == 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    /*
    * Validate against the wildcard.
    */
    if !(*type_0).attributeWildcard.is_null() {
        /*
	* SPEC (cvc-complex-type)
	* (3.2.1) "There must be an {attribute wildcard}."
	*/
        i = 0 as std::os::raw::c_int;
        while i < nbAttrs {
            iattr = *(*vctxt).attrInfos.offset(i as isize);
            /*
	    * SPEC (cvc-complex-type) (3)
	    * Skip meta attributes.
	    */
            if !((*iattr).state != 1 as std::os::raw::c_int) {
                /*
	    * SPEC (cvc-complex-type)
	    * (3.2.2) "The attribute information item must be `valid` with
	    * respect to it as defined in Item Valid (Wildcard) ($3.10.4)."
	    *
	    * SPEC Item Valid (Wildcard) (cvc-wildcard)
	    * "... its [namespace name] must be `valid` with respect to
	    * the wildcard constraint, as defined in Wildcard allows
	    * Namespace Name ($3.10.4)."
	    */
                if xmlSchemaCheckCVCWildcardNamespace((*type_0).attributeWildcard,
                                                      (*iattr).nsName) ==
                       0 as std::os::raw::c_int {
                    /*
		* Handle processContents.
		*
		* SPEC (cvc-wildcard):
		* processContents | context-determined declaration:
		* "strict"          "mustFind"
		* "lax"             "none"
		* "skip"            "skip"
		*/
                    if (*(*type_0).attributeWildcard).processContents ==
                           1 as std::os::raw::c_int {
                        /*
		    * context-determined declaration = "skip"
		    *
		    * SPEC PSVI Assessment Outcome (Attribute)
		    * [validity] = "notKnown"
		    * [validation attempted] = "none"
		    */
                        (*iattr).state = 13 as std::os::raw::c_int
                    } else {
                        /*
		* Find an attribute declaration.
		*/
                        (*iattr).decl =
                            xmlSchemaGetAttributeDecl((*vctxt).schema,
                                                      (*iattr).localName,
                                                      (*iattr).nsName);
                        if !(*iattr).decl.is_null() {
                            (*iattr).state = 2 as std::os::raw::c_int;
                            /*
		    * SPEC (cvc-complex-type)
		    * (5) "Let [Definition:]  the wild IDs be the set of
		    * all attribute information item to which clause 3.2
		    * applied and whose `validation` resulted in a
		    * `context-determined declaration` of mustFind or no
		    * `context-determined declaration` at all, and whose
		    * [local name] and [namespace name] resolve (as
		    * defined by QName resolution (Instance) ($3.15.4)) to
		    * an attribute declaration whose {type definition} is
		    * or is derived from ID. Then all of the following
		    * must be true:"
		    */
                            (*iattr).typeDef = (*(*iattr).decl).subtypes;
                            if xmlSchemaIsDerivedFromBuiltInType((*iattr).typeDef,
                                                                 XML_SCHEMAS_ID
                                                                     as
                                                                     std::os::raw::c_int)
                                   != 0 {
                                /*
			* SPEC (5.1) "There must be no more than one
			* item in `wild IDs`."
			*/
                                if wildIDs != 0 as std::os::raw::c_int {
                                    /* VAL TODO */
                                    (*iattr).state = 15 as std::os::raw::c_int;
                                    (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                                               b"Unimplemented block at %s:%d\n\x00"
                                                                                                   as
                                                                                                   *const u8
                                                                                                   as
                                                                                                   *const std::os::raw::c_char,
                                                                                               b"xmlschemas.c\x00"
                                                                                                   as
                                                                                                   *const u8
                                                                                                   as
                                                                                                   *const std::os::raw::c_char,
                                                                                               25449
                                                                                                   as
                                                                                                   std::os::raw::c_int);
                                } else {
                                    wildIDs += 1;
                                    /*
			* SPEC (cvc-complex-type)
			* (5.2) "If `wild IDs` is non-empty, there must not
			* be any attribute uses among the {attribute uses}
			* whose {attribute declaration}'s {type definition}
			* is or is derived from ID."
			*/
                                    if !attrUseList.is_null() {
                                        j = 0 as std::os::raw::c_int;
                                        while j < (*attrUseList).nbItems {
                                            if xmlSchemaIsDerivedFromBuiltInType((*(*(*(*attrUseList).items.offset(j
                                                                                                                       as
                                                                                                                       isize)
                                                                                          as
                                                                                          xmlSchemaAttributeUsePtr)).attrDecl).subtypes,
                                                                                 XML_SCHEMAS_ID
                                                                                     as
                                                                                     std::os::raw::c_int)
                                                   != 0 {
                                                /* URGENT VAL TODO: implement */
                                                (*iattr).state =
                                                    16 as std::os::raw::c_int;
                                                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                                                           b"Unimplemented block at %s:%d\n\x00"
                                                                                                               as
                                                                                                               *const u8
                                                                                                               as
                                                                                                               *const std::os::raw::c_char,
                                                                                                           b"xmlschemas.c\x00"
                                                                                                               as
                                                                                                               *const u8
                                                                                                               as
                                                                                                               *const std::os::raw::c_char,
                                                                                                           25467
                                                                                                               as
                                                                                                               std::os::raw::c_int);
                                                break ;
                                            } else { j += 1 }
                                        }
                                    }
                                }
                            }
                        } else if (*(*type_0).attributeWildcard).processContents
                                      == 2 as std::os::raw::c_int {
                            (*iattr).state = 14 as std::os::raw::c_int
                            /*
		    * SPEC PSVI Assessment Outcome (Attribute)
		    * [validity] = "notKnown"
		    * [validation attempted] = "none"
		    */
                        } else { (*iattr).state = 10 as std::os::raw::c_int }
                    }
                }
            }
            i += 1
        }
    }
    if (*vctxt).nbAttrInfos == 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    /*
    * Get the owner element; needed for creation of default attributes.
    * This fixes bug #341337, reported by David Grohmann.
    */
    if (*vctxt).options & XML_SCHEMA_VAL_VC_I_CREATE as std::os::raw::c_int != 0 {
        let mut ielem: xmlSchemaNodeInfoPtr =
            *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
        if !ielem.is_null() && !(*ielem).node.is_null() &&
               !(*(*ielem).node).doc.is_null() {
            defAttrOwnerElem = (*ielem).node
        }
    }
    /*
    * Validate values, create default attributes, evaluate IDCs.
    */
    i = 0 as std::os::raw::c_int;
    's_457:
        loop  {
            if !(i < (*vctxt).nbAttrInfos) {
                current_block = 12463749970033092792;
                break ;
            }
            iattr = *(*vctxt).attrInfos.offset(i as isize);
            /*
	* VAL TODO: Note that we won't try to resolve IDCs to
	* "lax" and "skip" validated attributes. Check what to
	* do in this case.
	*/
            if !((*iattr).state != 2 as std::os::raw::c_int &&
                     (*iattr).state != 8 as std::os::raw::c_int) {
                /*
	* VAL TODO: What to do if the type definition is missing?
	*/
                if (*iattr).typeDef.is_null() {
                    (*iattr).state = 6 as std::os::raw::c_int
                } else {
                    (*vctxt).inode = iattr as xmlSchemaNodeInfoPtr;
                    fixed = 0 as std::os::raw::c_int;
                    xpathRes = 0 as std::os::raw::c_int;
                    if !(*vctxt).xpathStates.is_null() {
                        /*
	    * Evaluate IDCs.
	    */
                        xpathRes =
                            xmlSchemaXPathEvaluate(vctxt, XML_ATTRIBUTE_NODE);
                        if xpathRes == -(1 as std::os::raw::c_int) {
                            xmlSchemaInternalErr(vctxt as
                                                     xmlSchemaAbstractCtxtPtr,
                                                 b"xmlSchemaVAttributesComplex\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 b"calling xmlSchemaXPathEvaluate()\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char);
                            current_block = 12191576274297033447;
                            break ;
                        }
                    }
                    if (*iattr).state == 8 as std::os::raw::c_int {
                        /*
	    * Default/fixed attributes.
	    * We need the value only if we need to resolve IDCs or
	    * will create default attributes.
	    */
                        if xpathRes != 0 || !defAttrOwnerElem.is_null() {
                            if !(*(*iattr).use_0).defValue.is_null() {
                                (*iattr).value =
                                    (*(*iattr).use_0).defValue as
                                        *mut xmlChar;
                                (*iattr).val = (*(*iattr).use_0).defVal
                            } else {
                                (*iattr).value =
                                    (*(*iattr).decl).defValue as *mut xmlChar;
                                (*iattr).val = (*(*iattr).decl).defVal
                            }
                            /*
		* IDCs will consume the precomputed default value,
		* so we need to clone it.
		*/
                            if (*iattr).val.is_null() {
                                xmlSchemaInternalErr(vctxt as
                                                         xmlSchemaAbstractCtxtPtr,
                                                     b"xmlSchemaVAttributesComplex\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char,
                                                     b"default/fixed value on an attribute use was not precomputed\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char);
                                current_block = 12191576274297033447;
                                break ;
                            } else {
                                (*iattr).val =
                                    xmlSchemaCopyValue((*iattr).val);
                                if (*iattr).val.is_null() {
                                    xmlSchemaInternalErr(vctxt as
                                                             xmlSchemaAbstractCtxtPtr,
                                                         b"xmlSchemaVAttributesComplex\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char,
                                                         b"calling xmlSchemaCopyValue()\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char);
                                    current_block = 12191576274297033447;
                                    break ;
                                }
                            }
                        }
                        /*
	    * PSVI: Add the default attribute to the current element.
	    * VAL TODO: Should we use the *normalized* value? This currently
	    *   uses the *initial* value.
	    */
                        if !defAttrOwnerElem.is_null() {
                            let mut normValue: *mut xmlChar =
                                0 as *mut xmlChar;
                            let mut value: *const xmlChar =
                                0 as *const xmlChar;
                            value = (*iattr).value;
                            /*
		* Normalize the value.
		*/
                            normValue =
                                xmlSchemaNormalizeValue((*iattr).typeDef,
                                                        (*iattr).value);
                            if !normValue.is_null() { value = normValue }
                            if (*iattr).nsName.is_null() {
                                if xmlNewProp(defAttrOwnerElem,
                                              (*iattr).localName,
                                              value).is_null() {
                                    xmlSchemaInternalErr(vctxt as
                                                             xmlSchemaAbstractCtxtPtr,
                                                         b"xmlSchemaVAttributesComplex\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char,
                                                         b"calling xmlNewProp()\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char);
                                    if !normValue.is_null() {
                                        xmlFree.expect("non-null function pointer")(normValue
                                                                                        as
                                                                                        *mut std::os::raw::c_void);
                                    }
                                    current_block = 12191576274297033447;
                                    break ;
                                }
                            } else {
                                let mut ns: xmlNsPtr = 0 as *mut xmlNs;
                                ns =
                                    xmlSearchNsByHref((*defAttrOwnerElem).doc,
                                                      defAttrOwnerElem,
                                                      (*iattr).nsName);
                                if ns.is_null() {
                                    let mut prefix: [xmlChar; 12] = [0; 12];
                                    let mut counter: std::os::raw::c_int =
                                        0 as std::os::raw::c_int;
                                    loop 
                                         /*
			* Create a namespace declaration on the validation
			* root node if no namespace declaration is in scope.
			*/
                                         {
                                        let fresh46 = counter;
                                        counter = counter + 1;
                                        snprintf(prefix.as_mut_ptr() as
                                                     *mut std::os::raw::c_char,
                                                 12 as std::os::raw::c_int as
                                                     std::os::raw::c_ulong,
                                                 b"p%d\x00" as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 fresh46);
                                        ns =
                                            xmlSearchNs((*defAttrOwnerElem).doc,
                                                        defAttrOwnerElem,
                                                        prefix.as_mut_ptr());
                                        if counter > 1000 as std::os::raw::c_int {
                                            xmlSchemaInternalErr(vctxt as
                                                                     xmlSchemaAbstractCtxtPtr,
                                                                 b"xmlSchemaVAttributesComplex\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const std::os::raw::c_char,
                                                                 b"could not compute a ns prefix for a default/fixed attribute\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const std::os::raw::c_char);
                                            if !normValue.is_null() {
                                                xmlFree.expect("non-null function pointer")(normValue
                                                                                                as
                                                                                                *mut std::os::raw::c_void);
                                            }
                                            current_block =
                                                12191576274297033447;
                                            break 's_457 ;
                                        } else if ns.is_null() { break ; }
                                    }
                                    ns =
                                        xmlNewNs((*vctxt).validationRoot,
                                                 (*iattr).nsName,
                                                 prefix.as_mut_ptr())
                                }
                                /*
		    * TODO:
		    * http://lists.w3.org/Archives/Public/www-xml-schema-comments/2005JulSep/0406.html
		    * If we have QNames: do we need to ensure there's a
		    * prefix defined for the QName?
		    */
                                xmlNewNsProp(defAttrOwnerElem, ns,
                                             (*iattr).localName, value);
                            }
                            if !normValue.is_null() {
                                xmlFree.expect("non-null function pointer")(normValue
                                                                                as
                                                                                *mut std::os::raw::c_void);
                            }
                        }
                    } else {
                        /*
	* Validate the value.
	*/
                        if !(*vctxt).value.is_null() {
                            /*
	    * Free last computed value; just for safety reasons.
	    */
                            xmlSchemaFreeValue((*vctxt).value);
                            (*vctxt).value = 0 as xmlSchemaValPtr
                        }
                        /*
	* Note that the attribute *use* can be unavailable, if
	* the attribute was a wild attribute.
	*/
                        if (*(*iattr).decl).flags &
                               (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int != 0 ||
                               !(*iattr).use_0.is_null() &&
                                   (*(*iattr).use_0).flags &
                                       (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int
                                       != 0 {
                            fixed = 1 as std::os::raw::c_int
                        } else { fixed = 0 as std::os::raw::c_int }
                        /*
	* SPEC (cvc-attribute)
	* (3) "The item's `normalized value` must be locally `valid`
	* with respect to that {type definition} as per
	* String Valid ($3.14.4)."
	*
	* VAL TODO: Do we already have the
	* "normalized attribute value" here?
	*/
                        if xpathRes != 0 || fixed != 0 {
                            (*iattr).flags |=
                                (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int;
                            /*
	    * Request a computed value.
	    */
                            res =
                                xmlSchemaVCheckCVCSimpleType(vctxt as
                                                                 xmlSchemaAbstractCtxtPtr,
                                                             (*iattr).node,
                                                             (*iattr).typeDef,
                                                             (*iattr).value,
                                                             &mut (*iattr).val,
                                                             1 as std::os::raw::c_int,
                                                             1 as std::os::raw::c_int,
                                                             0 as std::os::raw::c_int)
                        } else {
                            res =
                                xmlSchemaVCheckCVCSimpleType(vctxt as
                                                                 xmlSchemaAbstractCtxtPtr,
                                                             (*iattr).node,
                                                             (*iattr).typeDef,
                                                             (*iattr).value,
                                                             0 as
                                                                 *mut xmlSchemaValPtr,
                                                             1 as std::os::raw::c_int,
                                                             0 as std::os::raw::c_int,
                                                             0 as std::os::raw::c_int)
                        }
                        if res != 0 as std::os::raw::c_int {
                            if res == -(1 as std::os::raw::c_int) {
                                xmlSchemaInternalErr(vctxt as
                                                         xmlSchemaAbstractCtxtPtr,
                                                     b"xmlSchemaVAttributesComplex\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char,
                                                     b"calling xmlSchemaStreamValidateSimpleTypeValue()\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char);
                                current_block = 12191576274297033447;
                                break ;
                            } else { (*iattr).state = 5 as std::os::raw::c_int }
                        } else if fixed != 0 {
                            /*
	    * SPEC Attribute Locally Valid (Use) (cvc-au)
	    * "For an attribute information item to be `valid`
	    * with respect to an attribute use its *normalized*
	    * value must match the *canonical* lexical
	    * representation of the attribute use's {value
	    * constraint}value, if it is present and fixed."
	    *
	    * VAL TODO: The requirement for the *canonical* value
	    * will be removed in XML Schema 1.1.
	    */
	    /*
	    * SPEC Attribute Locally Valid (cvc-attribute)
	    * (4) "The item's *actual* value must match the *value* of
	    * the {value constraint}, if it is present and fixed."
	    */
                            if (*iattr).val.is_null() {
                                /* VAL TODO: A value was not precomputed. */
                                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                                           b"Unimplemented block at %s:%d\n\x00"
                                                                                               as
                                                                                               *const u8
                                                                                               as
                                                                                               *const std::os::raw::c_char,
                                                                                           b"xmlschemas.c\x00"
                                                                                               as
                                                                                               *const u8
                                                                                               as
                                                                                               *const std::os::raw::c_char,
                                                                                           25721
                                                                                               as
                                                                                               std::os::raw::c_int);
                            } else if !(*iattr).use_0.is_null() &&
                                          !(*(*iattr).use_0).defValue.is_null()
                             {
                                if (*(*iattr).use_0).defVal.is_null() {
                                    /* VAL TODO: A default value was not precomputed. */
                                    (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                                               b"Unimplemented block at %s:%d\n\x00"
                                                                                                   as
                                                                                                   *const u8
                                                                                                   as
                                                                                                   *const std::os::raw::c_char,
                                                                                               b"xmlschemas.c\x00"
                                                                                                   as
                                                                                                   *const u8
                                                                                                   as
                                                                                                   *const std::os::raw::c_char,
                                                                                               25728
                                                                                                   as
                                                                                                   std::os::raw::c_int);
                                } else {
                                    (*iattr).vcValue =
                                        (*(*iattr).use_0).defValue;
                                    /*
		if (xmlSchemaCompareValuesWhtsp(attr->val,
		    (xmlSchemaWhitespaceValueType) ws,
		    attr->use->defVal,
		    (xmlSchemaWhitespaceValueType) ws) != 0) {
		*/
                                    if xmlSchemaAreValuesEqual((*iattr).val,
                                                               (*(*iattr).use_0).defVal)
                                           == 0 {
                                        (*iattr).state = 7 as std::os::raw::c_int
                                    }
                                }
                            } else if (*(*iattr).decl).defVal.is_null() {
                                /* VAL TODO: A default value was not precomputed. */
                                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                                           b"Unimplemented block at %s:%d\n\x00"
                                                                                               as
                                                                                               *const u8
                                                                                               as
                                                                                               *const std::os::raw::c_char,
                                                                                           b"xmlschemas.c\x00"
                                                                                               as
                                                                                               *const u8
                                                                                               as
                                                                                               *const std::os::raw::c_char,
                                                                                           25743
                                                                                               as
                                                                                               std::os::raw::c_int);
                            } else {
                                (*iattr).vcValue = (*(*iattr).decl).defValue;
                                /*
		if (xmlSchemaCompareValuesWhtsp(attr->val,
		    (xmlSchemaWhitespaceValueType) ws,
		    attrDecl->defVal,
		    (xmlSchemaWhitespaceValueType) ws) != 0) {
		*/
                                if xmlSchemaAreValuesEqual((*iattr).val,
                                                           (*(*iattr).decl).defVal)
                                       == 0 {
                                    (*iattr).state = 7 as std::os::raw::c_int
                                }
                            }
                            /*
	    * [validity] = "valid"
	    */
                        }
                    }
                    /*
	* Evaluate IDCs.
	*/
                    if xpathRes != 0 {
                        if xmlSchemaXPathProcessHistory(vctxt,
                                                        (*vctxt).depth +
                                                            1 as std::os::raw::c_int)
                               == -(1 as std::os::raw::c_int) {
                            xmlSchemaInternalErr(vctxt as
                                                     xmlSchemaAbstractCtxtPtr,
                                                 b"xmlSchemaVAttributesComplex\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 b"calling xmlSchemaXPathEvaluate()\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char);
                            current_block = 12191576274297033447;
                            break ;
                        }
                    } else if !(*vctxt).xpathStates.is_null() {
                        xmlSchemaXPathPop(vctxt);
                    }
                }
            }
            i += 1
        }
    match current_block {
        12191576274297033447 => {
            (*vctxt).inode =
                *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
            return -(1 as std::os::raw::c_int)
        }
        _ => {
            /*
    * Report errors.
    */
            i = 0 as std::os::raw::c_int;
            while i < (*vctxt).nbAttrInfos {
                iattr = *(*vctxt).attrInfos.offset(i as isize);
                if !((*iattr).state == 17 as std::os::raw::c_int ||
                         (*iattr).state == 2 as std::os::raw::c_int ||
                         (*iattr).state == 13 as std::os::raw::c_int ||
                         (*iattr).state == 14 as std::os::raw::c_int) {
                    (*vctxt).inode = iattr as xmlSchemaNodeInfoPtr;
                    match (*iattr).state {
                        4 => {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            (*vctxt).inode =
                                *(*vctxt).elemInfos.offset((*vctxt).depth as
                                                               isize);
                            xmlSchemaCustomErr(vctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               XML_SCHEMAV_CVC_COMPLEX_TYPE_4,
                                               0 as xmlNodePtr,
                                               0 as xmlSchemaBasicItemPtr,
                                               b"The attribute \'%s\' is required but missing\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               xmlSchemaFormatQName(&mut str,
                                                                    (*(*iattr).decl).targetNamespace,
                                                                    (*(*iattr).decl).name),
                                               0 as *const xmlChar);
                            if !str.is_null() {
                                xmlFree.expect("non-null function pointer")(str
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                str = 0 as *mut xmlChar
                            }
                        }
                        6 => {
                            xmlSchemaCustomErr(vctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               XML_SCHEMAV_CVC_ATTRIBUTE_2,
                                               0 as xmlNodePtr,
                                               0 as xmlSchemaBasicItemPtr,
                                               b"The type definition is absent\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               0 as *const xmlChar,
                                               0 as *const xmlChar);
                        }
                        7 => {
                            xmlSchemaCustomErr(vctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               XML_SCHEMAV_CVC_AU,
                                               0 as xmlNodePtr,
                                               0 as xmlSchemaBasicItemPtr,
                                               b"The value \'%s\' does not match the fixed value constraint \'%s\'\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               (*iattr).value,
                                               (*iattr).vcValue);
                        }
                        10 => {
                            xmlSchemaCustomErr(vctxt as
                                                   xmlSchemaAbstractCtxtPtr,
                                               XML_SCHEMAV_CVC_WILDCARD,
                                               0 as xmlNodePtr,
                                               0 as xmlSchemaBasicItemPtr,
                                               b"No matching global attribute declaration available, but demanded by the strict wildcard\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               0 as *const xmlChar,
                                               0 as *const xmlChar);
                        }
                        1 => {
                            if !((*iattr).metaType != 0) {
                                /*
		* MAYBE VAL TODO: One might report different error messages
		* for the following errors.
		*/
                                if (*type_0).attributeWildcard.is_null() {
                                    xmlSchemaIllegalAttrErr(vctxt as
                                                                xmlSchemaAbstractCtxtPtr,
                                                            XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1,
                                                            iattr,
                                                            0 as xmlNodePtr);
                                } else {
                                    xmlSchemaIllegalAttrErr(vctxt as
                                                                xmlSchemaAbstractCtxtPtr,
                                                            XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2,
                                                            iattr,
                                                            0 as xmlNodePtr);
                                }
                            }
                        }
                        _ => { }
                    }
                }
                i += 1
            }
            (*vctxt).inode =
                *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
            return 0 as std::os::raw::c_int
        }
    };
}
unsafe extern "C" fn xmlSchemaValidateElemWildcard(mut vctxt:
                                                       xmlSchemaValidCtxtPtr,
                                                   mut skip: *mut std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut wild: xmlSchemaWildcardPtr =
        (*(*vctxt).inode).decl as xmlSchemaWildcardPtr;
    /*
    * The namespace of the element was already identified to be
    * matching the wildcard.
    */
    if skip.is_null() || wild.is_null() ||
           (*wild).type_0 as std::os::raw::c_uint !=
               XML_SCHEMA_TYPE_ANY as std::os::raw::c_int as std::os::raw::c_uint {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaValidateElemWildcard\x00" as *const u8
                                 as *const std::os::raw::c_char,
                             b"bad arguments\x00" as *const u8 as
                                 *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    *skip = 0 as std::os::raw::c_int;
    if (*wild).processContents == 1 as std::os::raw::c_int {
        /*
	* URGENT VAL TODO: Either we need to position the stream to the
	* next sibling, or walk the whole subtree.
	*/
        *skip = 1 as std::os::raw::c_int;
        return 0 as std::os::raw::c_int
    }
    let mut decl: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    decl =
        xmlSchemaGetElem((*vctxt).schema, (*(*vctxt).inode).localName,
                         (*(*vctxt).inode).nsName);
    if !decl.is_null() {
        (*(*vctxt).inode).decl = decl;
        return 0 as std::os::raw::c_int
    }
    if (*wild).processContents == 3 as std::os::raw::c_int {
        /* VAL TODO: Change to proper error code. */
        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAV_CVC_ELT_1, 0 as xmlNodePtr,
                           0 as xmlSchemaBasicItemPtr,
                           b"No matching global element declaration available, but demanded by the strict wildcard\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return (*vctxt).err
    }
    if (*vctxt).nbAttrInfos != 0 as std::os::raw::c_int {
        let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
        /*
	* SPEC Validation Rule: Schema-Validity Assessment (Element)
	* (1.2.1.2.1) - (1.2.1.2.3 )
	*
	* Use the xsi:type attribute for the type definition.
	*/
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as std::os::raw::c_int);
        if !iattr.is_null() {
            if xmlSchemaProcessXSIType(vctxt, iattr,
                                       &mut (*(*vctxt).inode).typeDef,
                                       0 as xmlSchemaElementPtr) ==
                   -(1 as std::os::raw::c_int) {
                xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                     b"xmlSchemaValidateElemWildcard\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"calling xmlSchemaProcessXSIType() to process the attribute \'xsi:nil\'\x00"
                                         as *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            /*
	    * Don't return an error on purpose.
	    */
            return 0 as std::os::raw::c_int
        }
    }
    /*
    * SPEC Validation Rule: Schema-Validity Assessment (Element)
    *
    * Fallback to "anyType".
    */
    (*(*vctxt).inode).typeDef = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
    return 0 as std::os::raw::c_int;
}
/*
* xmlSchemaCheckCOSValidDefault:
*
* This will be called if: not nilled, no content and a default/fixed
* value is provided.
*/
unsafe extern "C" fn xmlSchemaCheckCOSValidDefault(mut vctxt:
                                                       xmlSchemaValidCtxtPtr,
                                                   mut value: *const xmlChar,
                                                   mut val:
                                                       *mut xmlSchemaValPtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut inode: xmlSchemaNodeInfoPtr = (*vctxt).inode;
    /*
    * cos-valid-default:
    * Schema Component Constraint: Element Default Valid (Immediate)
    * For a string to be a valid default with respect to a type
    * definition the appropriate case among the following must be true:
    */
    if (*(*inode).typeDef).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint ||
           (*(*inode).typeDef).builtInType ==
               XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        /*
	* Complex type.
	*
	* SPEC (2.1) "its {content type} must be a simple type definition
	* or mixed."
	* SPEC (2.2.2) "If the {content type} is mixed, then the {content
	* type}'s particle must be `emptiable` as defined by
	* Particle Emptiable ($3.9.6)."
	*/
        if !((*(*inode).typeDef).contentType as std::os::raw::c_uint ==
                 XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                 (*(*inode).typeDef).contentType as std::os::raw::c_uint ==
                     XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as std::os::raw::c_uint)
               &&
               (!((*(*inode).typeDef).contentType as std::os::raw::c_uint ==
                      XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as std::os::raw::c_uint)
                    ||
                    xmlSchemaIsParticleEmptiable((*(*inode).typeDef).subtypes
                                                     as xmlSchemaParticlePtr)
                        == 0) {
            ret = XML_SCHEMAP_COS_VALID_DEFAULT_2_1 as std::os::raw::c_int;
            /* NOTE that this covers (2.2.2) as well. */
            xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                               ret as xmlParserErrors, 0 as xmlNodePtr,
                               0 as xmlSchemaBasicItemPtr,
                               b"For a string to be a valid default, the type definition must be a simple type or a complex type with simple content or mixed content and a particle emptiable\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               0 as *const xmlChar, 0 as *const xmlChar);
            return ret
        }
    }
    /*
    * 1 If the type definition is a simple type definition, then the string
    * must be `valid` with respect to that definition as defined by String
    * Valid ($3.14.4).
    *
    * AND
    *
    * 2.2.1 If the {content type} is a simple type definition, then the
    * string must be `valid` with respect to that simple type definition
    * as defined by String Valid ($3.14.4).
    */
    if (*(*inode).typeDef).type_0 as std::os::raw::c_uint ==
           XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
           (*(*inode).typeDef).type_0 as std::os::raw::c_uint ==
               XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as std::os::raw::c_uint &&
               (*(*inode).typeDef).builtInType !=
                   XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
        ret =
            xmlSchemaVCheckCVCSimpleType(vctxt as xmlSchemaAbstractCtxtPtr,
                                         0 as xmlNodePtr, (*inode).typeDef,
                                         value, val, 1 as std::os::raw::c_int,
                                         1 as std::os::raw::c_int, 0 as std::os::raw::c_int)
    } else if (*(*inode).typeDef).contentType as std::os::raw::c_uint ==
                  XML_SCHEMA_CONTENT_SIMPLE as std::os::raw::c_int as std::os::raw::c_uint ||
                  (*(*inode).typeDef).contentType as std::os::raw::c_uint ==
                      XML_SCHEMA_CONTENT_BASIC as std::os::raw::c_int as std::os::raw::c_uint
     {
        ret =
            xmlSchemaVCheckCVCSimpleType(vctxt as xmlSchemaAbstractCtxtPtr,
                                         0 as xmlNodePtr,
                                         (*(*inode).typeDef).contentTypeDef,
                                         value, val, 1 as std::os::raw::c_int,
                                         1 as std::os::raw::c_int, 0 as std::os::raw::c_int)
    }
    if ret < 0 as std::os::raw::c_int {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaCheckCOSValidDefault\x00" as *const u8
                                 as *const std::os::raw::c_char,
                             b"calling xmlSchemaVCheckCVCSimpleType()\x00" as
                                 *const u8 as *const std::os::raw::c_char);
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaVContentModelCallback(mut exec:
                                                        xmlRegExecCtxtPtr,
                                                    mut name: *const xmlChar,
                                                    mut transdata:
                                                        *mut std::os::raw::c_void,
                                                    mut inputdata:
                                                        *mut std::os::raw::c_void) {
    let mut item: xmlSchemaElementPtr = transdata as xmlSchemaElementPtr;
    let mut inode: xmlSchemaNodeInfoPtr = inputdata as xmlSchemaNodeInfoPtr;
    (*inode).decl = item;
}
unsafe extern "C" fn xmlSchemaValidatorPushElem(mut vctxt:
                                                    xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    (*vctxt).inode = xmlSchemaGetFreshElemInfo(vctxt);
    if (*vctxt).inode.is_null() {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaValidatorPushElem\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"calling xmlSchemaGetFreshElemInfo()\x00" as
                                 *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    (*vctxt).nbAttrInfos = 0 as std::os::raw::c_int;
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaVCheckINodeDataType(mut vctxt:
                                                      xmlSchemaValidCtxtPtr,
                                                  mut inode:
                                                      xmlSchemaNodeInfoPtr,
                                                  mut type_0:
                                                      xmlSchemaTypePtr,
                                                  mut value: *const xmlChar)
 -> std::os::raw::c_int {
    if (*inode).flags & (1 as std::os::raw::c_int) << 4 as std::os::raw::c_int != 0 {
        return xmlSchemaVCheckCVCSimpleType(vctxt as xmlSchemaAbstractCtxtPtr,
                                            0 as xmlNodePtr, type_0, value,
                                            &mut (*inode).val,
                                            1 as std::os::raw::c_int,
                                            1 as std::os::raw::c_int,
                                            0 as std::os::raw::c_int)
    } else {
        return xmlSchemaVCheckCVCSimpleType(vctxt as xmlSchemaAbstractCtxtPtr,
                                            0 as xmlNodePtr, type_0, value,
                                            0 as *mut xmlSchemaValPtr,
                                            1 as std::os::raw::c_int,
                                            0 as std::os::raw::c_int,
                                            0 as std::os::raw::c_int)
    };
}
/*
* Process END of element.
*/
unsafe extern "C" fn xmlSchemaValidatorPopElem(mut vctxt:
                                                   xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut inode: xmlSchemaNodeInfoPtr = (*vctxt).inode;
    if (*vctxt).nbAttrInfos != 0 as std::os::raw::c_int {
        xmlSchemaClearAttrInfos(vctxt);
    }
    if (*inode).flags & (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int != 0 {
        /*
	* This element was not expected;
	* we will not validate child elements of broken parents.
	* Skip validation of all content of the parent.
	*/
        (*vctxt).skipDepth = (*vctxt).depth - 1 as std::os::raw::c_int;
        current_block = 16019120858690786560;
    } else if (*inode).typeDef.is_null() ||
                  (*inode).flags & (1 as std::os::raw::c_int) << 10 as std::os::raw::c_int !=
                      0 {
        current_block = 16019120858690786560;
    } else {
        /*
    * Check the content model.
    */
        if (*(*inode).typeDef).contentType as std::os::raw::c_uint ==
               XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as std::os::raw::c_uint ||
               (*(*inode).typeDef).contentType as std::os::raw::c_uint ==
                   XML_SCHEMA_CONTENT_ELEMENTS as std::os::raw::c_int as std::os::raw::c_uint
           {
            /*
	* Workaround for "anyType".
	*/
            if (*(*inode).typeDef).builtInType ==
                   XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
                current_block = 13912423640042695756;
            } else if (*inode).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int
                          == 0 as std::os::raw::c_int {
                let mut values: [*mut xmlChar; 10] = [0 as *mut xmlChar; 10];
                let mut terminal: std::os::raw::c_int = 0;
                let mut nbval: std::os::raw::c_int = 10 as std::os::raw::c_int;
                let mut nbneg: std::os::raw::c_int = 0;
                if (*inode).regexCtxt.is_null() {
                    /*
		* Create the regex context.
		*/
                    (*inode).regexCtxt =
                        xmlRegNewExecCtxt((*(*inode).typeDef).contModel,
                                          Some(xmlSchemaVContentModelCallback
                                                   as
                                                   unsafe extern "C" fn(_:
                                                                            xmlRegExecCtxtPtr,
                                                                        _:
                                                                            *const xmlChar,
                                                                        _:
                                                                            *mut std::os::raw::c_void,
                                                                        _:
                                                                            *mut std::os::raw::c_void)
                                                       -> ()),
                                          vctxt as *mut std::os::raw::c_void);
                    if (*inode).regexCtxt.is_null() {
                        xmlSchemaInternalErr(vctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             b"xmlSchemaValidatorPopElem\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"failed to create a regex context\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                        current_block = 7353773722474535819;
                    } else { current_block = 15976848397966268834; }
                } else { current_block = 15976848397966268834; }
                match current_block {
                    7353773722474535819 => { }
                    _ =>
                    /*
	     * Do not check further content if the node has been nilled
	     */
                    {
                        if (*inode).flags &
                               (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
                            ret = 0 as std::os::raw::c_int
                        } else {
                            /*
	    * Get hold of the still expected content, since a further
	    * call to xmlRegExecPushString() will lose this information.
	    */
                            xmlRegExecNextValues((*inode).regexCtxt,
                                                 &mut nbval, &mut nbneg,
                                                 &mut *values.as_mut_ptr().offset(0
                                                                                      as
                                                                                      std::os::raw::c_int
                                                                                      as
                                                                                      isize),
                                                 &mut terminal);
                            ret =
                                xmlRegExecPushString((*inode).regexCtxt,
                                                     0 as *const xmlChar,
                                                     0 as *mut std::os::raw::c_void);
                            if ret < 0 as std::os::raw::c_int ||
                                   ret == 0 as std::os::raw::c_int &&
                                       (*inode).flags &
                                           (1 as std::os::raw::c_int) <<
                                               2 as std::os::raw::c_int == 0 {
                                /*
		* Still missing something.
		*/
                                ret = 1 as std::os::raw::c_int;
                                (*inode).flags |=
                                    (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int;
                                xmlSchemaComplexTypeErr(vctxt as
                                                            xmlSchemaAbstractCtxtPtr,
                                                        XML_SCHEMAV_ELEMENT_CONTENT,
                                                        0 as xmlNodePtr,
                                                        0 as xmlSchemaTypePtr,
                                                        b"Missing child element(s)\x00"
                                                            as *const u8 as
                                                            *const std::os::raw::c_char,
                                                        nbval, nbneg,
                                                        values.as_mut_ptr());
                            } else {
                                /*
		* Content model is satisfied.
		*/
                                ret = 0 as std::os::raw::c_int
                            }
                        }
                        current_block = 16056818154263879898;
                    }
                }
            } else { current_block = 16056818154263879898; }
        } else { current_block = 16056818154263879898; }
        match current_block {
            7353773722474535819 => { }
            _ => {
                match current_block {
                    16056818154263879898 => {
                        if (*(*inode).typeDef).contentType as std::os::raw::c_uint ==
                               XML_SCHEMA_CONTENT_ELEMENTS as std::os::raw::c_int as
                                   std::os::raw::c_uint {
                            current_block = 16019120858690786560;
                        } else { current_block = 13912423640042695756; }
                    }
                    _ => { }
                }
                match current_block {
                    16019120858690786560 => { }
                    _ => {
                        if !(*vctxt).value.is_null() {
                            xmlSchemaFreeValue((*vctxt).value);
                            (*vctxt).value = 0 as xmlSchemaValPtr
                        }
                        /*
    * Check character content.
    */
                        if (*inode).decl.is_null() {
                            /*
	* Speedup if no declaration exists.
	*/
                            if (*(*inode).typeDef).type_0 as std::os::raw::c_uint ==
                                   XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as
                                       std::os::raw::c_uint ||
                                   (*(*inode).typeDef).type_0 as std::os::raw::c_uint
                                       ==
                                       XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as
                                           std::os::raw::c_uint &&
                                       (*(*inode).typeDef).builtInType !=
                                           XML_SCHEMAS_ANYTYPE as std::os::raw::c_int
                               {
                                ret =
                                    xmlSchemaVCheckINodeDataType(vctxt, inode,
                                                                 (*inode).typeDef,
                                                                 (*inode).value)
                            } else if (*(*inode).typeDef).contentType as
                                          std::os::raw::c_uint ==
                                          XML_SCHEMA_CONTENT_SIMPLE as
                                              std::os::raw::c_int as std::os::raw::c_uint ||
                                          (*(*inode).typeDef).contentType as
                                              std::os::raw::c_uint ==
                                              XML_SCHEMA_CONTENT_BASIC as
                                                  std::os::raw::c_int as std::os::raw::c_uint
                             {
                                ret =
                                    xmlSchemaVCheckINodeDataType(vctxt, inode,
                                                                 (*(*inode).typeDef).contentTypeDef,
                                                                 (*inode).value)
                            }
                            if ret < 0 as std::os::raw::c_int {
                                xmlSchemaInternalErr(vctxt as
                                                         xmlSchemaAbstractCtxtPtr,
                                                     b"xmlSchemaValidatorPopElem\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char,
                                                     b"calling xmlSchemaVCheckCVCSimpleType()\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char);
                                current_block = 7353773722474535819;
                            } else { current_block = 16019120858690786560; }
                        } else if !(*(*inode).decl).value.is_null() &&
                                      (*inode).flags &
                                          (1 as std::os::raw::c_int) <<
                                              5 as std::os::raw::c_int != 0 &&
                                      (*inode).flags &
                                          (1 as std::os::raw::c_int) <<
                                              2 as std::os::raw::c_int == 0 {
                            /*
    * cvc-elt (3.3.4) : 5
    * The appropriate case among the following must be true:
    */
    /*
    * cvc-elt (3.3.4) : 5.1
    * If the declaration has a {value constraint},
    * the item has neither element nor character [children] and
    * clause 3.2 has not applied, then all of the following must be true:
    */
                            /*
	* cvc-elt (3.3.4) : 5.1.1
	* If the `actual type definition` is a `local type definition`
	* then the canonical lexical representation of the {value constraint}
	* value must be a valid default for the `actual type definition` as
	* defined in Element Default Valid (Immediate) ($3.3.6).
	*/
	/*
	* NOTE: 'local' above means types acquired by xsi:type.
	* NOTE: Although the *canonical* value is stated, it is not
	* relevant if canonical or not. Additionally XML Schema 1.1
	* will removed this requirement as well.
	*/
                            if (*inode).flags &
                                   (1 as std::os::raw::c_int) << 3 as std::os::raw::c_int != 0
                               {
                                ret =
                                    xmlSchemaCheckCOSValidDefault(vctxt,
                                                                  (*(*inode).decl).value,
                                                                  &mut (*inode).val);
                                if ret != 0 as std::os::raw::c_int {
                                    if ret < 0 as std::os::raw::c_int {
                                        xmlSchemaInternalErr(vctxt as
                                                                 xmlSchemaAbstractCtxtPtr,
                                                             b"xmlSchemaValidatorPopElem\x00"
                                                                 as *const u8
                                                                 as
                                                                 *const std::os::raw::c_char,
                                                             b"calling xmlSchemaCheckCOSValidDefault()\x00"
                                                                 as *const u8
                                                                 as
                                                                 *const std::os::raw::c_char);
                                        current_block = 7353773722474535819;
                                    } else {
                                        current_block = 16019120858690786560;
                                    }
                                } else {
                                    /*
	    * Stop here, to avoid redundant validation of the value
	    * (see following).
	    */
                                    current_block = 15901906649395726399;
                                }
                            } else {
                                /*
	* cvc-elt (3.3.4) : 5.1.2
	* The element information item with the canonical lexical
	* representation of the {value constraint} value used as its
	* `normalized value` must be `valid` with respect to the
	* `actual type definition` as defined by Element Locally Valid (Type)
	* ($3.3.4).
	*/
                                if (*(*inode).typeDef).type_0 as std::os::raw::c_uint
                                       ==
                                       XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int
                                           as std::os::raw::c_uint ||
                                       (*(*inode).typeDef).type_0 as
                                           std::os::raw::c_uint ==
                                           XML_SCHEMA_TYPE_BASIC as
                                               std::os::raw::c_int as std::os::raw::c_uint &&
                                           (*(*inode).typeDef).builtInType !=
                                               XML_SCHEMAS_ANYTYPE as
                                                   std::os::raw::c_int {
                                    ret =
                                        xmlSchemaVCheckINodeDataType(vctxt,
                                                                     inode,
                                                                     (*inode).typeDef,
                                                                     (*(*inode).decl).value)
                                } else if (*(*inode).typeDef).contentType as
                                              std::os::raw::c_uint ==
                                              XML_SCHEMA_CONTENT_SIMPLE as
                                                  std::os::raw::c_int as std::os::raw::c_uint
                                              ||
                                              (*(*inode).typeDef).contentType
                                                  as std::os::raw::c_uint ==
                                                  XML_SCHEMA_CONTENT_BASIC as
                                                      std::os::raw::c_int as
                                                      std::os::raw::c_uint {
                                    ret =
                                        xmlSchemaVCheckINodeDataType(vctxt,
                                                                     inode,
                                                                     (*(*inode).typeDef).contentTypeDef,
                                                                     (*(*inode).decl).value)
                                }
                                if ret != 0 as std::os::raw::c_int {
                                    if ret < 0 as std::os::raw::c_int {
                                        xmlSchemaInternalErr(vctxt as
                                                                 xmlSchemaAbstractCtxtPtr,
                                                             b"xmlSchemaValidatorPopElem\x00"
                                                                 as *const u8
                                                                 as
                                                                 *const std::os::raw::c_char,
                                                             b"calling xmlSchemaVCheckCVCSimpleType()\x00"
                                                                 as *const u8
                                                                 as
                                                                 *const std::os::raw::c_char);
                                        current_block = 7353773722474535819;
                                    } else {
                                        current_block = 16019120858690786560;
                                    }
                                } else {
                                    current_block = 15901906649395726399;
                                }
                            }
                            match current_block {
                                16019120858690786560 => { }
                                7353773722474535819 => { }
                                _ =>
                                /*
	* PSVI: Create a text node on the instance element.
	*/
                                {
                                    if (*vctxt).options &
                                           XML_SCHEMA_VAL_VC_I_CREATE as
                                               std::os::raw::c_int != 0 &&
                                           !(*inode).node.is_null() {
                                        let mut textChild: xmlNodePtr =
                                            0 as *mut xmlNode;
                                        let mut normValue: *mut xmlChar =
                                            0 as *mut xmlChar;
                                        /*
	    * VAL TODO: Normalize the value.
	    */
                                        normValue =
                                            xmlSchemaNormalizeValue((*inode).typeDef,
                                                                    (*(*inode).decl).value);
                                        if !normValue.is_null() {
                                            textChild = xmlNewText(normValue);
                                            xmlFree.expect("non-null function pointer")(normValue
                                                                                            as
                                                                                            *mut std::os::raw::c_void);
                                        } else {
                                            textChild =
                                                xmlNewText((*(*inode).decl).value)
                                        }
                                        if textChild.is_null() {
                                            xmlSchemaInternalErr(vctxt as
                                                                     xmlSchemaAbstractCtxtPtr,
                                                                 b"xmlSchemaValidatorPopElem\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const std::os::raw::c_char,
                                                                 b"calling xmlNewText()\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const std::os::raw::c_char);
                                            current_block =
                                                7353773722474535819;
                                        } else {
                                            xmlAddChild((*inode).node,
                                                        textChild);
                                            current_block =
                                                16019120858690786560;
                                        }
                                    } else {
                                        current_block = 16019120858690786560;
                                    }
                                }
                            }
                        } else if (*inode).flags &
                                      (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int
                                      == 0 {
                            /*
	* 5.2.1 The element information item must be `valid` with respect
	* to the `actual type definition` as defined by Element Locally
	* Valid (Type) ($3.3.4).
	*/
                            if (*(*inode).typeDef).type_0 as std::os::raw::c_uint ==
                                   XML_SCHEMA_TYPE_SIMPLE as std::os::raw::c_int as
                                       std::os::raw::c_uint ||
                                   (*(*inode).typeDef).type_0 as std::os::raw::c_uint
                                       ==
                                       XML_SCHEMA_TYPE_BASIC as std::os::raw::c_int as
                                           std::os::raw::c_uint &&
                                       (*(*inode).typeDef).builtInType !=
                                           XML_SCHEMAS_ANYTYPE as std::os::raw::c_int
                               {
                                /*
	    * SPEC (cvc-type) (3.1)
	    * "If the type definition is a simple type definition, ..."
	    * (3.1.3) "If clause 3.2 of Element Locally Valid
	    * (Element) ($3.3.4) did not apply, then the `normalized value`
	    * must be `valid` with respect to the type definition as defined
	    * by String Valid ($3.14.4).
	    */
                                ret =
                                    xmlSchemaVCheckINodeDataType(vctxt, inode,
                                                                 (*inode).typeDef,
                                                                 (*inode).value)
                            } else if (*(*inode).typeDef).contentType as
                                          std::os::raw::c_uint ==
                                          XML_SCHEMA_CONTENT_SIMPLE as
                                              std::os::raw::c_int as std::os::raw::c_uint ||
                                          (*(*inode).typeDef).contentType as
                                              std::os::raw::c_uint ==
                                              XML_SCHEMA_CONTENT_BASIC as
                                                  std::os::raw::c_int as std::os::raw::c_uint
                             {
                                /*
	    * SPEC (cvc-type) (3.2) "If the type definition is a complex type
	    * definition, then the element information item must be
	    * `valid` with respect to the type definition as per
	    * Element Locally Valid (Complex Type) ($3.4.4);"
	    *
	    * SPEC (cvc-complex-type) (2.2)
	    * "If the {content type} is a simple type definition, ...
	    * the `normalized value` of the element information item is
	    * `valid` with respect to that simple type definition as
	    * defined by String Valid ($3.14.4)."
	    */
                                ret =
                                    xmlSchemaVCheckINodeDataType(vctxt, inode,
                                                                 (*(*inode).typeDef).contentTypeDef,
                                                                 (*inode).value)
                            }
                            if ret != 0 as std::os::raw::c_int {
                                if ret < 0 as std::os::raw::c_int {
                                    xmlSchemaInternalErr(vctxt as
                                                             xmlSchemaAbstractCtxtPtr,
                                                         b"xmlSchemaValidatorPopElem\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char,
                                                         b"calling xmlSchemaVCheckCVCSimpleType()\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char);
                                    current_block = 7353773722474535819;
                                } else {
                                    current_block = 16019120858690786560;
                                }
                            } else if !(*(*inode).decl).value.is_null() &&
                                          (*(*inode).decl).flags &
                                              (1 as std::os::raw::c_int) <<
                                                  3 as std::os::raw::c_int != 0 {
                                /*
	* 5.2.2 If there is a fixed {value constraint} and clause 3.2 has
	* not applied, all of the following must be true:
	*/
                                /*
	    * TODO: We will need a computed value, when comparison is
	    * done on computed values.
	    */
	    /*
	    * 5.2.2.1 The element information item must have no element
	    * information item [children].
	    */
                                if (*inode).flags &
                                       (1 as std::os::raw::c_int) << 7 as std::os::raw::c_int
                                       != 0 {
                                    ret =
                                        XML_SCHEMAV_CVC_ELT_5_2_2_1 as
                                            std::os::raw::c_int;
                                    xmlSchemaCustomErr(vctxt as
                                                           xmlSchemaAbstractCtxtPtr,
                                                       ret as xmlParserErrors,
                                                       0 as xmlNodePtr,
                                                       0 as
                                                           xmlSchemaBasicItemPtr,
                                                       b"The content must not containt element nodes since there is a fixed value constraint\x00"
                                                           as *const u8 as
                                                           *const std::os::raw::c_char,
                                                       0 as *const xmlChar,
                                                       0 as *const xmlChar);
                                } else if (*(*inode).typeDef).contentType as
                                              std::os::raw::c_uint ==
                                              XML_SCHEMA_CONTENT_MIXED as
                                                  std::os::raw::c_int as std::os::raw::c_uint
                                 {
                                    /*
		* 5.2.2.2 The appropriate case among the following must
		* be true:
		*/
                                    /*
		    * 5.2.2.2.1 If the {content type} of the `actual type
		    * definition` is mixed, then the *initial value* of the
		    * item must match the canonical lexical representation
		    * of the {value constraint} value.
		    *
		    * ... the *initial value* of an element information
		    * item is the string composed of, in order, the
		    * [character code] of each character information item in
		    * the [children] of that element information item.
		    */
                                    if xmlStrEqual((*inode).value,
                                                   (*(*inode).decl).value) ==
                                           0 {
                                        /*
			* VAL TODO: Report invalid & expected values as well.
			* VAL TODO: Implement the canonical stuff.
			*/
                                        ret =
                                            XML_SCHEMAV_CVC_ELT_5_2_2_2_1 as
                                                std::os::raw::c_int;
                                        xmlSchemaCustomErr(vctxt as
                                                               xmlSchemaAbstractCtxtPtr,
                                                           ret as
                                                               xmlParserErrors,
                                                           0 as xmlNodePtr,
                                                           0 as
                                                               xmlSchemaBasicItemPtr,
                                                           b"The initial value \'%s\' does not match the fixed value constraint \'%s\'\x00"
                                                               as *const u8 as
                                                               *const std::os::raw::c_char,
                                                           (*inode).value,
                                                           (*(*inode).decl).value);
                                    }
                                } else if (*(*inode).typeDef).contentType as
                                              std::os::raw::c_uint ==
                                              XML_SCHEMA_CONTENT_SIMPLE as
                                                  std::os::raw::c_int as std::os::raw::c_uint
                                              ||
                                              (*(*inode).typeDef).contentType
                                                  as std::os::raw::c_uint ==
                                                  XML_SCHEMA_CONTENT_BASIC as
                                                      std::os::raw::c_int as
                                                      std::os::raw::c_uint {
                                    /*
		    * 5.2.2.2.2 If the {content type} of the `actual type
		    * definition` is a simple type definition, then the
		    * *actual value* of the item must match the canonical
		    * lexical representation of the {value constraint} value.
		    */
		    /*
		    * VAL TODO: *actual value* is the normalized value, impl.
		    *           this.
		    * VAL TODO: Report invalid & expected values as well.
		    * VAL TODO: Implement a comparison with the computed values.
		    */
                                    if xmlStrEqual((*inode).value,
                                                   (*(*inode).decl).value) ==
                                           0 {
                                        ret =
                                            XML_SCHEMAV_CVC_ELT_5_2_2_2_2 as
                                                std::os::raw::c_int;
                                        xmlSchemaCustomErr(vctxt as
                                                               xmlSchemaAbstractCtxtPtr,
                                                           ret as
                                                               xmlParserErrors,
                                                           0 as xmlNodePtr,
                                                           0 as
                                                               xmlSchemaBasicItemPtr,
                                                           b"The actual value \'%s\' does not match the fixed value constraint \'%s\'\x00"
                                                               as *const u8 as
                                                               *const std::os::raw::c_char,
                                                           (*inode).value,
                                                           (*(*inode).decl).value);
                                    }
                                }
                                current_block = 16019120858690786560;
                            } else { current_block = 16019120858690786560; }
                        } else { current_block = 16019120858690786560; }
                    }
                }
            }
        }
    }
    match current_block {
        16019120858690786560 =>
        /*
	* 1. the type definition might be missing if the element was
	*    error prone
	* 2. it might be abstract.
	*/
        {
            if (*vctxt).depth < 0 as std::os::raw::c_int {
                /* TODO: raise error? */
                return 0 as std::os::raw::c_int
            }
            if (*vctxt).depth == (*vctxt).skipDepth {
                (*vctxt).skipDepth = -(1 as std::os::raw::c_int)
            }
            /*
    * Evaluate the history of XPath state objects.
    */
            if !((*inode).appliedXPath != 0 &&
                     xmlSchemaXPathProcessHistory(vctxt, (*vctxt).depth) ==
                         -(1 as std::os::raw::c_int)) {
                /*
    * MAYBE TODO:
    * SPEC (6) "The element information item must be `valid` with
    * respect to each of the {identity-constraint definitions} as per
    * Identity-constraint Satisfied ($3.11.4)."
    */
    /*
    * PSVI TODO: If we expose IDC node-tables via PSVI then the tables
    *   need to be built in any case.
    *   We will currently build IDC node-tables and bubble them only if
    *   keyrefs do exist.
    */
                /*
    * Add the current IDC target-nodes to the IDC node-tables.
    */
                if !(*inode).idcMatchers.is_null() &&
                       ((*vctxt).hasKeyrefs != 0 ||
                            (*vctxt).createIDCNodeTables != 0) {
                    if xmlSchemaIDCFillNodeTables(vctxt, inode) ==
                           -(1 as std::os::raw::c_int) {
                        current_block = 7353773722474535819;
                    } else { current_block = 6665878751423064961; }
                } else { current_block = 6665878751423064961; }
                match current_block {
                    7353773722474535819 => { }
                    _ =>
                    /*
    * Validate IDC keyrefs.
    */
                    {
                        if (*(*vctxt).inode).hasKeyrefs != 0 {
                            if xmlSchemaCheckCVCIDCKeyRef(vctxt) ==
                                   -(1 as std::os::raw::c_int) {
                                current_block = 7353773722474535819;
                            } else { current_block = 8225018548522317130; }
                        } else { current_block = 8225018548522317130; }
                        match current_block {
                            7353773722474535819 => { }
                            _ =>
                            /*
    * Merge/free the IDC table.
    */
                            {
                                if !(*inode).idcTable.is_null() {
                                    if (*vctxt).depth > 0 as std::os::raw::c_int &&
                                           ((*vctxt).hasKeyrefs != 0 ||
                                                (*vctxt).createIDCNodeTables
                                                    != 0) {
                                        /*
	    * Merge the IDC node table with the table of the parent node.
	    */
                                        if xmlSchemaBubbleIDCNodeTables(vctxt)
                                               == -(1 as std::os::raw::c_int) {
                                            current_block =
                                                7353773722474535819;
                                        } else {
                                            current_block =
                                                5636883459695696059;
                                        }
                                    } else {
                                        current_block = 5636883459695696059;
                                    }
                                } else {
                                    current_block = 5636883459695696059;
                                }
                                match current_block {
                                    7353773722474535819 => { }
                                    _ => {
                                        /*
    * Clear the current ielem.
    * VAL TODO: Don't free the PSVI IDC tables if they are
    * requested for the PSVI.
    */
                                        xmlSchemaClearElemInfo(vctxt, inode);
                                        /*
    * Skip further processing if we are on the validation root.
    */
                                        if (*vctxt).depth == 0 as std::os::raw::c_int
                                           {
                                            (*vctxt).depth -= 1;
                                            (*vctxt).inode =
                                                0 as xmlSchemaNodeInfoPtr;
                                            return 0 as std::os::raw::c_int
                                        }
                                        /*
    * Reset the keyrefDepth if needed.
    */
                                        if !(*vctxt).aidcs.is_null() {
                                            let mut aidc: xmlSchemaIDCAugPtr =
                                                (*vctxt).aidcs;
                                            loop  {
                                                if (*aidc).keyrefDepth ==
                                                       (*vctxt).depth {
                                                    /*
		* A 'keyrefDepth' of a key/unique IDC matches the current
		* depth, this means that we are leaving the scope of the
		* top-most keyref IDC which refers to this IDC.
		*/
                                                    (*aidc).keyrefDepth =
                                                        -(1 as std::os::raw::c_int)
                                                }
                                                aidc = (*aidc).next;
                                                if aidc.is_null() { break ; }
                                            }
                                        }
                                        (*vctxt).depth -= 1;
                                        (*vctxt).inode =
                                            *(*vctxt).elemInfos.offset((*vctxt).depth
                                                                           as
                                                                           isize);
                                        /*
    * VAL TODO: 7 If the element information item is the `validation root`, it must be
    * `valid` per Validation Root Valid (ID/IDREF) ($3.3.4).
    */
                                        return ret
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => { }
    }
    (*vctxt).err = -(1 as std::os::raw::c_int);
    return -(1 as std::os::raw::c_int);
}
/*
* 3.4.4 Complex Type Definition Validation Rules
* Validation Rule: Element Locally Valid (Complex Type) (cvc-complex-type)
*/
unsafe extern "C" fn xmlSchemaValidateChildElem(mut vctxt:
                                                    xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut pielem: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
    let mut ptype: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if (*vctxt).depth <= 0 as std::os::raw::c_int {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaValidateChildElem\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"not intended for the validation root\x00" as
                                 *const u8 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    pielem =
        *(*vctxt).elemInfos.offset(((*vctxt).depth - 1 as std::os::raw::c_int) as
                                       isize);
    if (*pielem).flags & (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int != 0 {
        (*pielem).flags ^= (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int
    }
    /*
    * Handle 'nilled' elements.
    */
    if (*pielem).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
        /*
	* SPEC (cvc-elt) (3.3.4) : (3.2.1)
	*/
        (*vctxt).inode =
            *(*vctxt).elemInfos.offset(((*vctxt).depth - 1 as std::os::raw::c_int) as
                                           isize);
        ret = XML_SCHEMAV_CVC_ELT_3_2_1 as std::os::raw::c_int;
        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                           ret as xmlParserErrors, 0 as xmlNodePtr,
                           0 as xmlSchemaBasicItemPtr,
                           b"Neither character nor element content is allowed, because the element was \'nilled\'\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        (*vctxt).inode = *(*vctxt).elemInfos.offset((*vctxt).depth as isize)
    } else {
        ptype = (*pielem).typeDef;
        if (*ptype).builtInType == XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
            /*
	* Workaround for "anyType": we have currently no content model
	* assigned for "anyType", so handle it explicitely.
	* "anyType" has an unbounded, lax "any" wildcard.
	*/
            (*(*vctxt).inode).decl =
                xmlSchemaGetElem((*vctxt).schema, (*(*vctxt).inode).localName,
                                 (*(*vctxt).inode).nsName);
            if (*(*vctxt).inode).decl.is_null() {
                let mut iattr: xmlSchemaAttrInfoPtr =
                    0 as *mut xmlSchemaAttrInfo;
                /*
	    * Process "xsi:type".
	    * SPEC (cvc-assess-elt) (1.2.1.2.1) - (1.2.1.2.3)
	    */
                iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as std::os::raw::c_int);
                if !iattr.is_null() {
                    ret =
                        xmlSchemaProcessXSIType(vctxt, iattr,
                                                &mut (*(*vctxt).inode).typeDef,
                                                0 as xmlSchemaElementPtr);
                    if ret != 0 as std::os::raw::c_int {
                        if ret == -(1 as std::os::raw::c_int) {
                            xmlSchemaInternalErr(vctxt as
                                                     xmlSchemaAbstractCtxtPtr,
                                                 b"xmlSchemaValidateChildElem\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 b"calling xmlSchemaProcessXSIType() to process the attribute \'xsi:nil\'\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char);
                            return -(1 as std::os::raw::c_int)
                        }
                        return ret
                    }
                } else {
                    /*
		 * Fallback to "anyType".
		 *
		 * SPEC (cvc-assess-elt)
		 * "If the item cannot be `strictly assessed`, [...]
		 * an element information item's schema validity may be laxly
		 * assessed if its `context-determined declaration` is not
		 * skip by `validating` with respect to the `ur-type
		 * definition` as per Element Locally Valid (Type) ($3.3.4)."
		*/
                    (*(*vctxt).inode).typeDef =
                        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE)
                }
            }
            return 0 as std::os::raw::c_int
        }
        match (*ptype).contentType as std::os::raw::c_uint {
            1 => {
                /*
	    * SPEC (2.1) "If the {content type} is empty, then the
	    * element information item has no character or element
	    * information item [children]."
	    */
                (*vctxt).inode =
                    *(*vctxt).elemInfos.offset(((*vctxt).depth -
                                                    1 as std::os::raw::c_int) as
                                                   isize);
                ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1 as std::os::raw::c_int;
                xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                   ret as xmlParserErrors, 0 as xmlNodePtr,
                                   0 as xmlSchemaBasicItemPtr,
                                   b"Element content is not allowed, because the content type is empty\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   0 as *const xmlChar, 0 as *const xmlChar);
                (*vctxt).inode =
                    *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
                current_block = 8521305010027848949;
            }
            3 | 2 => {
                let mut regexCtxt: xmlRegExecCtxtPtr =
                    0 as *mut xmlRegExecCtxt;
                let mut values: [*mut xmlChar; 10] = [0 as *mut xmlChar; 10];
                let mut terminal: std::os::raw::c_int = 0;
                let mut nbval: std::os::raw::c_int = 10 as std::os::raw::c_int;
                let mut nbneg: std::os::raw::c_int = 0;
                /* VAL TODO: Optimized "anyType" validation.*/
                if (*ptype).contModel.is_null() {
                    xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaValidateChildElem\x00" as
                                             *const u8 as *const std::os::raw::c_char,
                                         b"type has elem content but no content model\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    return -(1 as std::os::raw::c_int)
                }
                /*
	    * Safety belf for evaluation if the cont. model was already
	    * examined to be invalid.
	    */
                if (*pielem).flags & (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int !=
                       0 {
                    xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaValidateChildElem\x00" as
                                             *const u8 as *const std::os::raw::c_char,
                                         b"validating elem, but elem content is already invalid\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    return -(1 as std::os::raw::c_int)
                }
                regexCtxt = (*pielem).regexCtxt;
                if regexCtxt.is_null() {
                    /*
		* Create the regex context.
		*/
                    regexCtxt =
                        xmlRegNewExecCtxt((*ptype).contModel,
                                          Some(xmlSchemaVContentModelCallback
                                                   as
                                                   unsafe extern "C" fn(_:
                                                                            xmlRegExecCtxtPtr,
                                                                        _:
                                                                            *const xmlChar,
                                                                        _:
                                                                            *mut std::os::raw::c_void,
                                                                        _:
                                                                            *mut std::os::raw::c_void)
                                                       -> ()),
                                          vctxt as *mut std::os::raw::c_void);
                    if regexCtxt.is_null() {
                        xmlSchemaInternalErr(vctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             b"xmlSchemaValidateChildElem\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"failed to create a regex context\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                        return -(1 as std::os::raw::c_int)
                    }
                    (*pielem).regexCtxt = regexCtxt
                }
                /*
	    * SPEC (2.4) "If the {content type} is element-only or mixed,
	    * then the sequence of the element information item's
	    * element information item [children], if any, taken in
	    * order, is `valid` with respect to the {content type}'s
	    * particle, as defined in Element Sequence Locally Valid
	    * (Particle) ($3.9.4)."
	    */
                ret =
                    xmlRegExecPushString2(regexCtxt,
                                          (*(*vctxt).inode).localName,
                                          (*(*vctxt).inode).nsName,
                                          (*vctxt).inode as
                                              *mut std::os::raw::c_void);
                if (*vctxt).err == XML_SCHEMAV_INTERNAL as std::os::raw::c_int {
                    xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaValidateChildElem\x00" as
                                             *const u8 as *const std::os::raw::c_char,
                                         b"calling xmlRegExecPushString2()\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    return -(1 as std::os::raw::c_int)
                }
                if ret < 0 as std::os::raw::c_int {
                    xmlRegExecErrInfo(regexCtxt, 0 as *mut *const xmlChar,
                                      &mut nbval, &mut nbneg,
                                      &mut *values.as_mut_ptr().offset(0 as
                                                                           std::os::raw::c_int
                                                                           as
                                                                           isize),
                                      &mut terminal);
                    xmlSchemaComplexTypeErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                            XML_SCHEMAV_ELEMENT_CONTENT,
                                            0 as xmlNodePtr,
                                            0 as xmlSchemaTypePtr,
                                            b"This element is not expected\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char, nbval,
                                            nbneg, values.as_mut_ptr());
                    ret = (*vctxt).err;
                    current_block = 8521305010027848949;
                } else {
                    ret = 0 as std::os::raw::c_int;
                    current_block = 3879520548144599102;
                }
            }
            4 | 6 => {
                (*vctxt).inode =
                    *(*vctxt).elemInfos.offset(((*vctxt).depth -
                                                    1 as std::os::raw::c_int) as
                                                   isize);
                if (*ptype).type_0 as std::os::raw::c_uint ==
                       XML_SCHEMA_TYPE_COMPLEX as std::os::raw::c_int as std::os::raw::c_uint
                       ||
                       (*ptype).builtInType ==
                           XML_SCHEMAS_ANYTYPE as std::os::raw::c_int {
                    /*
		* SPEC (cvc-complex-type) (2.2)
		* "If the {content type} is a simple type definition, then
		* the element information item has no element information
		* item [children], ..."
		*/
                    ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2 as std::os::raw::c_int;
                    xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                       ret as xmlParserErrors,
                                       0 as xmlNodePtr,
                                       0 as xmlSchemaBasicItemPtr,
                                       b"Element content is not allowed, because the content type is a simple type definition\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       0 as *const xmlChar,
                                       0 as *const xmlChar);
                } else {
                    /*
		* SPEC (cvc-type) (3.1.2) "The element information item must
		* have no element information item [children]."
		*/
                    ret = XML_SCHEMAV_CVC_TYPE_3_1_2 as std::os::raw::c_int;
                    xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                       ret as xmlParserErrors,
                                       0 as xmlNodePtr,
                                       0 as xmlSchemaBasicItemPtr,
                                       b"Element content is not allowed, because the type definition is simple\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       0 as *const xmlChar,
                                       0 as *const xmlChar);
                }
                (*vctxt).inode =
                    *(*vctxt).elemInfos.offset((*vctxt).depth as isize);
                ret = (*vctxt).err;
                current_block = 8521305010027848949;
            }
            _ => { current_block = 3879520548144599102; }
        }
        match current_block { 8521305010027848949 => { } _ => { return ret } }
    }
    /*
    * Pop this element and set the skipDepth to skip
    * all further content of the parent element.
    */
    (*vctxt).skipDepth = (*vctxt).depth;
    (*(*vctxt).inode).flags |= (1 as std::os::raw::c_int) << 9 as std::os::raw::c_int;
    (*pielem).flags |= (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int;
    return ret;
}
unsafe extern "C" fn xmlSchemaVPushText(mut vctxt: xmlSchemaValidCtxtPtr,
                                        mut nodeType: std::os::raw::c_int,
                                        mut value: *const xmlChar,
                                        mut len: std::os::raw::c_int,
                                        mut mode: std::os::raw::c_int,
                                        mut consumed: *mut std::os::raw::c_int)
 -> std::os::raw::c_int {
    /*
    * Unfortunately we have to duplicate the text sometimes.
    * OPTIMIZE: Maybe we could skip it, if:
    *   1. content type is simple
    *   2. whitespace is "collapse"
    *   3. it consists of whitespace only
    *
    * Process character content.
    */
    if !consumed.is_null() { *consumed = 0 as std::os::raw::c_int }
    if (*(*vctxt).inode).flags & (1 as std::os::raw::c_int) << 2 as std::os::raw::c_int != 0 {
        /*
	* SPEC cvc-elt (3.3.4 - 3.2.1)
	* "The element information item must have no character or
	* element information item [children]."
	*/
        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAV_CVC_ELT_3_2_1, 0 as xmlNodePtr,
                           0 as xmlSchemaBasicItemPtr,
                           b"Neither character nor element content is allowed because the element is \'nilled\'\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return (*vctxt).err
    }
    /*
    * SPEC (2.1) "If the {content type} is empty, then the
    * element information item has no character or element
    * information item [children]."
    */
    if (*(*(*vctxt).inode).typeDef).contentType as std::os::raw::c_uint ==
           XML_SCHEMA_CONTENT_EMPTY as std::os::raw::c_int as std::os::raw::c_uint {
        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1, 0 as xmlNodePtr,
                           0 as xmlSchemaBasicItemPtr,
                           b"Character content is not allowed, because the content type is empty\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return (*vctxt).err
    }
    if (*(*(*vctxt).inode).typeDef).contentType as std::os::raw::c_uint ==
           XML_SCHEMA_CONTENT_ELEMENTS as std::os::raw::c_int as std::os::raw::c_uint {
        if nodeType != XML_TEXT_NODE as std::os::raw::c_int ||
               xmlSchemaIsBlank(value as *mut xmlChar, len) == 0 {
            /*
	    * SPEC cvc-complex-type (2.3)
	    * "If the {content type} is element-only, then the
	    * element information item has no character information
	    * item [children] other than those whose [character
	    * code] is defined as a white space in [XML 1.0 (Second
	    * Edition)]."
	    */
            xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                               XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3,
                               0 as xmlNodePtr, 0 as xmlSchemaBasicItemPtr,
                               b"Character content other than whitespace is not allowed because the content type is \'element-only\'\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               0 as *const xmlChar, 0 as *const xmlChar);
            return (*vctxt).err
        }
        return 0 as std::os::raw::c_int
    }
    if value.is_null() ||
           *value.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
               0 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    /*
    * Save the value.
    * NOTE that even if the content type is *mixed*, we need the
    * *initial value* for default/fixed value constraints.
    */
    if (*(*(*vctxt).inode).typeDef).contentType as std::os::raw::c_uint ==
           XML_SCHEMA_CONTENT_MIXED as std::os::raw::c_int as std::os::raw::c_uint &&
           ((*(*vctxt).inode).decl.is_null() ||
                (*(*(*vctxt).inode).decl).value.is_null()) {
        return 0 as std::os::raw::c_int
    }
    if (*(*vctxt).inode).value.is_null() {
        /*
	* Set the value.
	*/
        match mode {
            1 => {
                /*
		* When working on a tree.
		*/
                (*(*vctxt).inode).value = value
            }
            2 => {
                /*
		* When working with the reader.
		* The value will be freed by the element info.
		*/
                (*(*vctxt).inode).value = value;
                if !consumed.is_null() { *consumed = 1 as std::os::raw::c_int }
                (*(*vctxt).inode).flags |=
                    (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int
            }
            3 => {
                /*
		* When working with SAX.
		* The value will be freed by the element info.
		*/
                if len != -(1 as std::os::raw::c_int) {
                    (*(*vctxt).inode).value = xmlStrndup(value, len)
                } else { (*(*vctxt).inode).value = xmlStrdup(value) }
                (*(*vctxt).inode).flags |=
                    (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int
            }
            _ => { }
        }
    } else {
        if len < 0 as std::os::raw::c_int { len = xmlStrlen(value) }
        /*
	* Concat the value.
	*/
        if (*(*vctxt).inode).flags & (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int !=
               0 {
            (*(*vctxt).inode).value =
                xmlStrncat((*(*vctxt).inode).value as *mut xmlChar, value,
                           len)
        } else {
            (*(*vctxt).inode).value =
                xmlStrncatNew((*(*vctxt).inode).value, value, len);
            (*(*vctxt).inode).flags |= (1 as std::os::raw::c_int) << 1 as std::os::raw::c_int
        }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaValidateElem(mut vctxt: xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if (*vctxt).skipDepth != -(1 as std::os::raw::c_int) &&
           (*vctxt).depth >= (*vctxt).skipDepth {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaValidateElem\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             b"in skip-state\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    } else {
        if (*vctxt).xsiAssemble != 0 {
            /*
	* We will stop validation if there was an error during
	* dynamic schema construction.
	* Note that we simply set @skipDepth to 0, this could
	* mean that a streaming document via SAX would be
	* still read to the end but it won't be validated any more.
	* TODO: If we are sure how to stop the validation at once
	*   for all input scenarios, then this should be changed to
	*   instantly stop the validation.
	*/
            ret = xmlSchemaAssembleByXSI(vctxt);
            if ret != 0 as std::os::raw::c_int {
                if ret == -(1 as std::os::raw::c_int) {
                    current_block = 9692229121900504993;
                } else { (*vctxt).skipDepth = 0 as std::os::raw::c_int; return ret }
            } else {
                /*
         * Augment the IDC definitions for the main schema and all imported ones
         * NOTE: main schema is the first in the imported list
         */
                xmlHashScan((*(*vctxt).schema).schemasImports,
                            Some(xmlSchemaAugmentImportedIDC as
                                     unsafe extern "C" fn(_:
                                                              *mut std::os::raw::c_void,
                                                          _:
                                                              *mut std::os::raw::c_void,
                                                          _: *const xmlChar)
                                         -> ()), vctxt as *mut std::os::raw::c_void);
                current_block = 13536709405535804910;
            }
        } else { current_block = 13536709405535804910; }
        match current_block {
            9692229121900504993 => { }
            _ => {
                if (*vctxt).depth > 0 as std::os::raw::c_int {
                    /*
	* Validate this element against the content model
	* of the parent.
	*/
                    ret = xmlSchemaValidateChildElem(vctxt);
                    if ret != 0 as std::os::raw::c_int {
                        if ret < 0 as std::os::raw::c_int {
                            xmlSchemaInternalErr(vctxt as
                                                     xmlSchemaAbstractCtxtPtr,
                                                 b"xmlSchemaValidateElem\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 b"calling xmlSchemaStreamValidateChildElement()\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char);
                            current_block = 9692229121900504993;
                        } else { current_block = 15835345499683014541; }
                    } else if (*vctxt).depth == (*vctxt).skipDepth {
                        current_block = 15835345499683014541;
                    } else if (*(*vctxt).inode).decl.is_null() &&
                                  (*(*vctxt).inode).typeDef.is_null() {
                        xmlSchemaInternalErr(vctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             b"xmlSchemaValidateElem\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"the child element was valid but neither the declaration nor the type was set\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                        current_block = 9692229121900504993;
                    } else { current_block = 16924917904204750491; }
                } else {
                    /*
	* Get the declaration of the validation root.
	*/
                    (*(*vctxt).inode).decl =
                        xmlSchemaGetElem((*vctxt).schema,
                                         (*(*vctxt).inode).localName,
                                         (*(*vctxt).inode).nsName);
                    if (*(*vctxt).inode).decl.is_null() {
                        ret = XML_SCHEMAV_CVC_ELT_1 as std::os::raw::c_int;
                        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                           ret as xmlParserErrors,
                                           0 as xmlNodePtr,
                                           0 as xmlSchemaBasicItemPtr,
                                           b"No matching global declaration available for the validation root\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           0 as *const xmlChar,
                                           0 as *const xmlChar);
                        current_block = 15835345499683014541;
                    } else { current_block = 16924917904204750491; }
                }
                match current_block {
                    9692229121900504993 => { }
                    _ => {
                        match current_block {
                            16924917904204750491 => {
                                if (*(*vctxt).inode).decl.is_null() {
                                    current_block = 1537582386995143792;
                                } else {
                                    if (*(*(*vctxt).inode).decl).type_0 as
                                           std::os::raw::c_uint ==
                                           XML_SCHEMA_TYPE_ANY as std::os::raw::c_int
                                               as std::os::raw::c_uint {
                                        let mut skip: std::os::raw::c_int = 0;
                                        /*
	* Wildcards.
	*/
                                        ret =
                                            xmlSchemaValidateElemWildcard(vctxt,
                                                                          &mut skip);
                                        if ret != 0 as std::os::raw::c_int {
                                            if ret < 0 as std::os::raw::c_int {
                                                xmlSchemaInternalErr(vctxt as
                                                                         xmlSchemaAbstractCtxtPtr,
                                                                     b"xmlSchemaValidateElem\x00"
                                                                         as
                                                                         *const u8
                                                                         as
                                                                         *const std::os::raw::c_char,
                                                                     b"calling xmlSchemaValidateElemWildcard()\x00"
                                                                         as
                                                                         *const u8
                                                                         as
                                                                         *const std::os::raw::c_char);
                                                current_block =
                                                    9692229121900504993;
                                            } else {
                                                current_block =
                                                    15835345499683014541;
                                            }
                                        } else if skip != 0 {
                                            (*vctxt).skipDepth =
                                                (*vctxt).depth;
                                            current_block =
                                                15835345499683014541;
                                        } else if (*(*(*vctxt).inode).decl).type_0
                                                      as std::os::raw::c_uint !=
                                                      XML_SCHEMA_TYPE_ELEMENT
                                                          as std::os::raw::c_int as
                                                          std::os::raw::c_uint {
                                            /*
	* The declaration might be set by the wildcard validation,
	* when the processContents is "lax" or "strict".
	*/
                                            /*
	    * Clear the "decl" field to not confuse further processing.
	    */
                                            (*(*vctxt).inode).decl =
                                                0 as xmlSchemaElementPtr;
                                            current_block =
                                                1537582386995143792;
                                        } else {
                                            current_block =
                                                790185930182612747;
                                        }
                                    } else {
                                        current_block = 790185930182612747;
                                    }
                                    match current_block {
                                        15835345499683014541 => { }
                                        9692229121900504993 => { }
                                        1537582386995143792 => { }
                                        _ => {
                                            /*
    * Validate against the declaration.
    */
                                            ret =
                                                xmlSchemaValidateElemDecl(vctxt);
                                            if ret != 0 as std::os::raw::c_int {
                                                if ret < 0 as std::os::raw::c_int {
                                                    xmlSchemaInternalErr(vctxt
                                                                             as
                                                                             xmlSchemaAbstractCtxtPtr,
                                                                         b"xmlSchemaValidateElem\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const std::os::raw::c_char,
                                                                         b"calling xmlSchemaValidateElemDecl()\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const std::os::raw::c_char);
                                                    current_block =
                                                        9692229121900504993;
                                                } else {
                                                    current_block =
                                                        15835345499683014541;
                                                }
                                            } else {
                                                current_block =
                                                    1537582386995143792;
                                            }
                                        }
                                    }
                                }
                                match current_block {
                                    15835345499683014541 => { }
                                    9692229121900504993 => { }
                                    _ =>
                                    /*
    * Validate against the type definition.
    */
                                    {
                                        if (*(*vctxt).inode).typeDef.is_null()
                                           {
                                            (*(*vctxt).inode).flags |=
                                                (1 as std::os::raw::c_int) <<
                                                    10 as std::os::raw::c_int;
                                            ret =
                                                XML_SCHEMAV_CVC_TYPE_1 as
                                                    std::os::raw::c_int;
                                            xmlSchemaCustomErr(vctxt as
                                                                   xmlSchemaAbstractCtxtPtr,
                                                               ret as
                                                                   xmlParserErrors,
                                                               0 as
                                                                   xmlNodePtr,
                                                               0 as
                                                                   xmlSchemaBasicItemPtr,
                                                               b"The type definition is absent\x00"
                                                                   as
                                                                   *const u8
                                                                   as
                                                                   *const std::os::raw::c_char,
                                                               0 as
                                                                   *const xmlChar,
                                                               0 as
                                                                   *const xmlChar);
                                            current_block =
                                                15835345499683014541;
                                        } else if (*(*(*vctxt).inode).typeDef).flags
                                                      &
                                                      (1 as std::os::raw::c_int) <<
                                                          20 as std::os::raw::c_int !=
                                                      0 {
                                            (*(*vctxt).inode).flags |=
                                                (1 as std::os::raw::c_int) <<
                                                    10 as std::os::raw::c_int;
                                            ret =
                                                XML_SCHEMAV_CVC_TYPE_2 as
                                                    std::os::raw::c_int;
                                            xmlSchemaCustomErr(vctxt as
                                                                   xmlSchemaAbstractCtxtPtr,
                                                               ret as
                                                                   xmlParserErrors,
                                                               0 as
                                                                   xmlNodePtr,
                                                               0 as
                                                                   xmlSchemaBasicItemPtr,
                                                               b"The type definition is abstract\x00"
                                                                   as
                                                                   *const u8
                                                                   as
                                                                   *const std::os::raw::c_char,
                                                               0 as
                                                                   *const xmlChar,
                                                               0 as
                                                                   *const xmlChar);
                                            current_block =
                                                15835345499683014541;
                                        } else {
                                            /*
    * Evaluate IDCs. Do it here, since new IDC matchers are registered
    * during validation against the declaration. This must be done
    * _before_ attribute validation.
    */
                                            if !(*vctxt).xpathStates.is_null()
                                               {
                                                ret =
                                                    xmlSchemaXPathEvaluate(vctxt,
                                                                           XML_ELEMENT_NODE);
                                                (*(*vctxt).inode).appliedXPath
                                                    = 1 as std::os::raw::c_int;
                                                if ret == -(1 as std::os::raw::c_int)
                                                   {
                                                    xmlSchemaInternalErr(vctxt
                                                                             as
                                                                             xmlSchemaAbstractCtxtPtr,
                                                                         b"xmlSchemaValidateElem\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const std::os::raw::c_char,
                                                                         b"calling xmlSchemaXPathEvaluate()\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const std::os::raw::c_char);
                                                    current_block =
                                                        9692229121900504993;
                                                } else {
                                                    current_block =
                                                        1874315696050160458;
                                                }
                                            } else {
                                                current_block =
                                                    1874315696050160458;
                                            }
                                            match current_block {
                                                9692229121900504993 => { }
                                                _ => {
                                                    /*
    * Validate attributes.
    */
                                                    if (*(*(*vctxt).inode).typeDef).type_0
                                                           as std::os::raw::c_uint ==
                                                           XML_SCHEMA_TYPE_COMPLEX
                                                               as std::os::raw::c_int
                                                               as std::os::raw::c_uint
                                                           ||
                                                           (*(*(*vctxt).inode).typeDef).builtInType
                                                               ==
                                                               XML_SCHEMAS_ANYTYPE
                                                                   as
                                                                   std::os::raw::c_int
                                                       {
                                                        if (*vctxt).nbAttrInfos
                                                               !=
                                                               0 as
                                                                   std::os::raw::c_int
                                                               ||
                                                               !(*(*(*vctxt).inode).typeDef).attrUses.is_null()
                                                           {
                                                            ret =
                                                                xmlSchemaVAttributesComplex(vctxt)
                                                        }
                                                    } else if (*vctxt).nbAttrInfos
                                                                  !=
                                                                  0 as
                                                                      std::os::raw::c_int
                                                     {
                                                        ret =
                                                            xmlSchemaVAttributesSimple(vctxt)
                                                    }
                                                    /*
    * Clear registered attributes.
    */
                                                    if (*vctxt).nbAttrInfos !=
                                                           0 as std::os::raw::c_int {
                                                        xmlSchemaClearAttrInfos(vctxt);
                                                    }
                                                    if ret ==
                                                           -(1 as std::os::raw::c_int)
                                                       {
                                                        xmlSchemaInternalErr(vctxt
                                                                                 as
                                                                                 xmlSchemaAbstractCtxtPtr,
                                                                             b"xmlSchemaValidateElem\x00"
                                                                                 as
                                                                                 *const u8
                                                                                 as
                                                                                 *const std::os::raw::c_char,
                                                                             b"calling attributes validation\x00"
                                                                                 as
                                                                                 *const u8
                                                                                 as
                                                                                 *const std::os::raw::c_char);
                                                        current_block =
                                                            9692229121900504993;
                                                    } else {
                                                        /*
    * Don't return an error if attributes are invalid on purpose.
    */
                                                        ret =
                                                            0 as std::os::raw::c_int;
                                                        current_block =
                                                            15835345499683014541;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => { }
                        }
                        match current_block {
                            9692229121900504993 => { }
                            _ => {
                                if ret != 0 as std::os::raw::c_int {
                                    (*vctxt).skipDepth = (*vctxt).depth
                                }
                                return ret
                            }
                        }
                    }
                }
            }
        }
    }
    return -(1 as std::os::raw::c_int);
}
/* ***********************************************************************
 *									*
 *			SAX validation handlers				*
 *									*
 ************************************************************************/
/*
* Process text content.
*/
unsafe extern "C" fn xmlSchemaSAXHandleText(mut ctx: *mut std::os::raw::c_void,
                                            mut ch: *const xmlChar,
                                            mut len: std::os::raw::c_int) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    if (*vctxt).depth < 0 as std::os::raw::c_int { return }
    if (*vctxt).skipDepth != -(1 as std::os::raw::c_int) &&
           (*vctxt).depth >= (*vctxt).skipDepth {
        return
    }
    if (*(*vctxt).inode).flags & (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int != 0 {
        (*(*vctxt).inode).flags ^= (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int
    }
    if xmlSchemaVPushText(vctxt, XML_TEXT_NODE as std::os::raw::c_int, ch, len,
                          3 as std::os::raw::c_int, 0 as *mut std::os::raw::c_int) ==
           -(1 as std::os::raw::c_int) {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaSAXHandleCDataSection\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             b"calling xmlSchemaVPushText()\x00" as *const u8
                                 as *const std::os::raw::c_char);
        (*vctxt).err = -(1 as std::os::raw::c_int);
        xmlStopParser((*vctxt).parserCtxt);
    };
}
/*
* Process CDATA content.
*/
unsafe extern "C" fn xmlSchemaSAXHandleCDataSection(mut ctx:
                                                        *mut std::os::raw::c_void,
                                                    mut ch: *const xmlChar,
                                                    mut len: std::os::raw::c_int) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    if (*vctxt).depth < 0 as std::os::raw::c_int { return }
    if (*vctxt).skipDepth != -(1 as std::os::raw::c_int) &&
           (*vctxt).depth >= (*vctxt).skipDepth {
        return
    }
    if (*(*vctxt).inode).flags & (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int != 0 {
        (*(*vctxt).inode).flags ^= (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int
    }
    if xmlSchemaVPushText(vctxt, XML_CDATA_SECTION_NODE as std::os::raw::c_int, ch,
                          len, 3 as std::os::raw::c_int, 0 as *mut std::os::raw::c_int) ==
           -(1 as std::os::raw::c_int) {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaSAXHandleCDataSection\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             b"calling xmlSchemaVPushText()\x00" as *const u8
                                 as *const std::os::raw::c_char);
        (*vctxt).err = -(1 as std::os::raw::c_int);
        xmlStopParser((*vctxt).parserCtxt);
    };
}
unsafe extern "C" fn xmlSchemaSAXHandleReference(mut ctx: *mut std::os::raw::c_void,
                                                 mut name: *const xmlChar) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    if (*vctxt).depth < 0 as std::os::raw::c_int { return }
    if (*vctxt).skipDepth != -(1 as std::os::raw::c_int) &&
           (*vctxt).depth >= (*vctxt).skipDepth {
        return
    }
    /* SAX VAL TODO: What to do here? */
    (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                               b"Unimplemented block at %s:%d\n\x00"
                                                                   as
                                                                   *const u8
                                                                   as
                                                                   *const std::os::raw::c_char,
                                                               b"xmlschemas.c\x00"
                                                                   as
                                                                   *const u8
                                                                   as
                                                                   *const std::os::raw::c_char,
                                                               27324 as
                                                                   std::os::raw::c_int);
}
unsafe extern "C" fn xmlSchemaSAXHandleStartElementNs(mut ctx:
                                                          *mut std::os::raw::c_void,
                                                      mut localname:
                                                          *const xmlChar,
                                                      mut prefix:
                                                          *const xmlChar,
                                                      mut URI: *const xmlChar,
                                                      mut nb_namespaces:
                                                          std::os::raw::c_int,
                                                      mut namespaces:
                                                          *mut *const xmlChar,
                                                      mut nb_attributes:
                                                          std::os::raw::c_int,
                                                      mut nb_defaulted:
                                                          std::os::raw::c_int,
                                                      mut attributes:
                                                          *mut *const xmlChar) {
    let mut current_block: u64;
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    let mut ret: std::os::raw::c_int = 0;
    let mut ielem: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    /*
    * SAX VAL TODO: What to do with nb_defaulted?
    */
    /*
    * Skip elements if inside a "skip" wildcard or invalid.
    */
    (*vctxt).depth += 1;
    if (*vctxt).skipDepth != -(1 as std::os::raw::c_int) &&
           (*vctxt).depth >= (*vctxt).skipDepth {
        return
    }
    /*
    * Push the element.
    */
    if xmlSchemaValidatorPushElem(vctxt) == -(1 as std::os::raw::c_int) {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaSAXHandleStartElementNs\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             b"calling xmlSchemaValidatorPushElem()\x00" as
                                 *const u8 as *const std::os::raw::c_char);
    } else {
        ielem = (*vctxt).inode;
        /*
    * TODO: Is this OK?
    */
        (*ielem).nodeLine =
            xmlSAX2GetLineNumber((*vctxt).parserCtxt as *mut std::os::raw::c_void);
        (*ielem).localName = localname;
        (*ielem).nsName = URI;
        (*ielem).flags |= (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int;
        /*
    * Register namespaces on the elem info.
    */
        if nb_namespaces != 0 as std::os::raw::c_int {
            /*
	* Although the parser builds its own namespace list,
	* we have no access to it, so we'll use an own one.
	*/
            i = 0 as std::os::raw::c_int;
            j = 0 as std::os::raw::c_int;
            loop  {
                if !(i < nb_namespaces) {
                    current_block = 14434620278749266018;
                    break ;
                }
                /*
	    * Store prefix and namespace name.
	    */
                if (*ielem).nsBindings.is_null() {
                    (*ielem).nsBindings =
                        xmlMalloc.expect("non-null function pointer")((10 as
                                                                           std::os::raw::c_int
                                                                           as
                                                                           std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                           as
                                                                                                           std::os::raw::c_ulong))
                            as *mut *const xmlChar;
                    if (*ielem).nsBindings.is_null() {
                        xmlSchemaVErrMemory(vctxt,
                                            b"allocating namespace bindings for SAX validation\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            0 as xmlNodePtr);
                        current_block = 16893852718821109251;
                        break ;
                    } else {
                        (*ielem).nbNsBindings = 0 as std::os::raw::c_int;
                        (*ielem).sizeNsBindings = 5 as std::os::raw::c_int
                    }
                } else if (*ielem).sizeNsBindings <= (*ielem).nbNsBindings {
                    (*ielem).sizeNsBindings *= 2 as std::os::raw::c_int;
                    (*ielem).nsBindings =
                        xmlRealloc.expect("non-null function pointer")((*ielem).nsBindings
                                                                           as
                                                                           *mut std::os::raw::c_void,
                                                                       (((*ielem).sizeNsBindings
                                                                             *
                                                                             2
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                            as
                                                                            std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                            as
                                                                                                            std::os::raw::c_ulong))
                            as *mut *const xmlChar;
                    if (*ielem).nsBindings.is_null() {
                        xmlSchemaVErrMemory(vctxt,
                                            b"re-allocating namespace bindings for SAX validation\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            0 as xmlNodePtr);
                        current_block = 16893852718821109251;
                        break ;
                    }
                }
                let ref mut fresh47 =
                    *(*ielem).nsBindings.offset(((*ielem).nbNsBindings *
                                                     2 as std::os::raw::c_int) as
                                                    isize);
                *fresh47 = *namespaces.offset(j as isize);
                if *(*namespaces.offset((j + 1 as std::os::raw::c_int) as
                                            isize)).offset(0 as std::os::raw::c_int as
                                                               isize) as
                       std::os::raw::c_int == 0 as std::os::raw::c_int {
                    /*
		* Handle xmlns="".
		*/
                    let ref mut fresh48 =
                        *(*ielem).nsBindings.offset(((*ielem).nbNsBindings *
                                                         2 as std::os::raw::c_int +
                                                         1 as std::os::raw::c_int) as
                                                        isize);
                    *fresh48 = 0 as *const xmlChar
                } else {
                    let ref mut fresh49 =
                        *(*ielem).nsBindings.offset(((*ielem).nbNsBindings *
                                                         2 as std::os::raw::c_int +
                                                         1 as std::os::raw::c_int) as
                                                        isize);
                    *fresh49 =
                        *namespaces.offset((j + 1 as std::os::raw::c_int) as isize)
                }
                (*ielem).nbNsBindings += 1;
                i += 1;
                j += 2 as std::os::raw::c_int
            }
        } else { current_block = 14434620278749266018; }
        match current_block {
            16893852718821109251 => { }
            _ =>
            /*
    * Register attributes.
    * SAX VAL TODO: We are not adding namespace declaration
    * attributes yet.
    */
            {
                if nb_attributes != 0 as std::os::raw::c_int {
                    let mut valueLen: std::os::raw::c_int = 0;
                    let mut k: std::os::raw::c_int = 0;
                    let mut l: std::os::raw::c_int = 0;
                    let mut value: *mut xmlChar = 0 as *mut xmlChar;
                    j = 0 as std::os::raw::c_int;
                    i = 0 as std::os::raw::c_int;
                    loop  {
                        if !(i < nb_attributes) {
                            current_block = 9241535491006583629;
                            break ;
                        }
                        /*
	    * Duplicate the value, changing any &#38; to a literal ampersand.
	    *
	    * libxml2 differs from normal SAX here in that it escapes all ampersands
	    * as &#38; instead of delivering the raw converted string. Changing the
	    * behavior at this point would break applications that use this API, so
	    * we are forced to work around it.
	    */
                        valueLen =
                            (*attributes.offset((j + 4 as std::os::raw::c_int) as
                                                    isize)).offset_from(*attributes.offset((j
                                                                                                         +
                                                                                                         3
                                                                                                             as
                                                                                                             std::os::raw::c_int)
                                                                                                        as
                                                                                                        isize))
                                as std::os::raw::c_long as std::os::raw::c_int;
                        value =
                            xmlMallocAtomic.expect("non-null function pointer")((valueLen
                                                                                     +
                                                                                     1
                                                                                         as
                                                                                         std::os::raw::c_int)
                                                                                    as
                                                                                    size_t)
                                as *mut xmlChar;
                        if value.is_null() {
                            xmlSchemaVErrMemory(vctxt,
                                                b"allocating string for decoded attribute\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char,
                                                0 as xmlNodePtr);
                            current_block = 16893852718821109251;
                            break ;
                        } else {
                            k = 0 as std::os::raw::c_int;
                            l = 0 as std::os::raw::c_int;
                            while k < valueLen {
                                if k < valueLen - 4 as std::os::raw::c_int &&
                                       *(*attributes.offset((j +
                                                                 3 as
                                                                     std::os::raw::c_int)
                                                                as
                                                                isize)).offset((k
                                                                                    +
                                                                                    0
                                                                                        as
                                                                                        std::os::raw::c_int)
                                                                                   as
                                                                                   isize)
                                           as std::os::raw::c_int == '&' as i32 &&
                                       *(*attributes.offset((j +
                                                                 3 as
                                                                     std::os::raw::c_int)
                                                                as
                                                                isize)).offset((k
                                                                                    +
                                                                                    1
                                                                                        as
                                                                                        std::os::raw::c_int)
                                                                                   as
                                                                                   isize)
                                           as std::os::raw::c_int == '#' as i32 &&
                                       *(*attributes.offset((j +
                                                                 3 as
                                                                     std::os::raw::c_int)
                                                                as
                                                                isize)).offset((k
                                                                                    +
                                                                                    2
                                                                                        as
                                                                                        std::os::raw::c_int)
                                                                                   as
                                                                                   isize)
                                           as std::os::raw::c_int == '3' as i32 &&
                                       *(*attributes.offset((j +
                                                                 3 as
                                                                     std::os::raw::c_int)
                                                                as
                                                                isize)).offset((k
                                                                                    +
                                                                                    3
                                                                                        as
                                                                                        std::os::raw::c_int)
                                                                                   as
                                                                                   isize)
                                           as std::os::raw::c_int == '8' as i32 &&
                                       *(*attributes.offset((j +
                                                                 3 as
                                                                     std::os::raw::c_int)
                                                                as
                                                                isize)).offset((k
                                                                                    +
                                                                                    4
                                                                                        as
                                                                                        std::os::raw::c_int)
                                                                                   as
                                                                                   isize)
                                           as std::os::raw::c_int == ';' as i32 {
                                    *value.offset(l as isize) =
                                        '&' as i32 as xmlChar;
                                    k += 5 as std::os::raw::c_int
                                } else {
                                    *value.offset(l as isize) =
                                        *(*attributes.offset((j +
                                                                  3 as
                                                                      std::os::raw::c_int)
                                                                 as
                                                                 isize)).offset(k
                                                                                    as
                                                                                    isize);
                                    k += 1
                                }
                                l += 1
                            }
                            *value.offset(l as isize) =
                                '\u{0}' as i32 as xmlChar;
                            /*
	    * TODO: Set the node line.
	    */
                            ret =
                                xmlSchemaValidatorPushAttribute(vctxt,
                                                                0 as
                                                                    xmlNodePtr,
                                                                (*ielem).nodeLine,
                                                                *attributes.offset(j
                                                                                       as
                                                                                       isize),
                                                                *attributes.offset((j
                                                                                        +
                                                                                        2
                                                                                            as
                                                                                            std::os::raw::c_int)
                                                                                       as
                                                                                       isize),
                                                                0 as
                                                                    std::os::raw::c_int,
                                                                value,
                                                                1 as
                                                                    std::os::raw::c_int);
                            if ret == -(1 as std::os::raw::c_int) {
                                xmlSchemaInternalErr(vctxt as
                                                         xmlSchemaAbstractCtxtPtr,
                                                     b"xmlSchemaSAXHandleStartElementNs\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char,
                                                     b"calling xmlSchemaValidatorPushAttribute()\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char);
                                current_block = 16893852718821109251;
                                break ;
                            } else { i += 1; j += 5 as std::os::raw::c_int }
                        }
                    }
                } else { current_block = 9241535491006583629; }
                match current_block {
                    16893852718821109251 => { }
                    _ => {
                        /*
    * Validate the element.
    */
                        ret = xmlSchemaValidateElem(vctxt);
                        if ret != 0 as std::os::raw::c_int {
                            if ret == -(1 as std::os::raw::c_int) {
                                xmlSchemaInternalErr(vctxt as
                                                         xmlSchemaAbstractCtxtPtr,
                                                     b"xmlSchemaSAXHandleStartElementNs\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char,
                                                     b"calling xmlSchemaValidateElem()\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char);
                                current_block = 16893852718821109251;
                            } else { current_block = 13334677043321711631; }
                        } else { current_block = 13334677043321711631; }
                        match current_block {
                            16893852718821109251 => { }
                            _ => { return }
                        }
                    }
                }
            }
        }
    }
    (*vctxt).err = -(1 as std::os::raw::c_int);
    xmlStopParser((*vctxt).parserCtxt);
}
unsafe extern "C" fn xmlSchemaSAXHandleEndElementNs(mut ctx:
                                                        *mut std::os::raw::c_void,
                                                    mut localname:
                                                        *const xmlChar,
                                                    mut prefix:
                                                        *const xmlChar,
                                                    mut URI: *const xmlChar) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    let mut res: std::os::raw::c_int = 0;
    /*
    * Skip elements if inside a "skip" wildcard or if invalid.
    */
    if (*vctxt).skipDepth != -(1 as std::os::raw::c_int) {
        if (*vctxt).depth > (*vctxt).skipDepth {
            (*vctxt).depth -= 1;
            return
        } else { (*vctxt).skipDepth = -(1 as std::os::raw::c_int) }
    }
    /*
    * SAX VAL TODO: Just a temporary check.
    */
    if xmlStrEqual((*(*vctxt).inode).localName, localname) == 0 ||
           xmlStrEqual((*(*vctxt).inode).nsName, URI) == 0 {
        xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                             b"xmlSchemaSAXHandleEndElementNs\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             b"elem pop mismatch\x00" as *const u8 as
                                 *const std::os::raw::c_char);
    }
    res = xmlSchemaValidatorPopElem(vctxt);
    if res != 0 as std::os::raw::c_int {
        if res < 0 as std::os::raw::c_int {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaSAXHandleEndElementNs\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"calling xmlSchemaValidatorPopElem()\x00" as
                                     *const u8 as *const std::os::raw::c_char);
            (*vctxt).err = -(1 as std::os::raw::c_int);
            xmlStopParser((*vctxt).parserCtxt);
            return
        }
    };
}
/* ***********************************************************************
 *									*
 *			Validation interfaces				*
 *									*
 ************************************************************************/
/* *
 * xmlSchemaNewValidCtxt:
 * @schema:  a precompiled XML Schemas
 *
 * Create an XML Schemas validation context based on the given schema.
 *
 * Returns the validation context or NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewValidCtxt(mut schema: xmlSchemaPtr)
 -> xmlSchemaValidCtxtPtr {
    let mut ret: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaValidCtxt>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaValidCtxtPtr;
    if ret.is_null() {
        xmlSchemaVErrMemory(0 as xmlSchemaValidCtxtPtr,
                            b"allocating validation context\x00" as *const u8
                                as *const std::os::raw::c_char, 0 as xmlNodePtr);
        return 0 as xmlSchemaValidCtxtPtr
    }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaValidCtxt>() as std::os::raw::c_ulong);
    (*ret).type_0 = 2 as std::os::raw::c_int;
    (*ret).dict = xmlDictCreate();
    (*ret).nodeQNames = xmlSchemaItemListCreate();
    (*ret).schema = schema;
    return ret;
}
/* *
 * xmlSchemaValidateSetFilename:
 * @vctxt: the schema validation context
 * @filename: the file name
 *
 * Workaround to provide file error reporting information when this is
 * not provided by current APIs
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateSetFilename(mut vctxt:
                                                          xmlSchemaValidCtxtPtr,
                                                      mut filename:
                                                          *const std::os::raw::c_char) {
    if vctxt.is_null() { return }
    if !(*vctxt).filename.is_null() {
        xmlFree.expect("non-null function pointer")((*vctxt).filename as
                                                        *mut std::os::raw::c_void);
    }
    if !filename.is_null() {
        (*vctxt).filename =
            xmlStrdup(filename as *const xmlChar) as *mut std::os::raw::c_char
    } else { (*vctxt).filename = 0 as *mut std::os::raw::c_char };
}
/* *
 * xmlSchemaClearValidCtxt:
 * @vctxt: the schema validation context
 *
 * Free the resources associated to the schema validation context;
 * leaves some fields alive intended for reuse of the context.
 */
unsafe extern "C" fn xmlSchemaClearValidCtxt(mut vctxt:
                                                 xmlSchemaValidCtxtPtr) {
    if vctxt.is_null() { return }
    /*
    * TODO: Should we clear the flags?
    *   Might be problematic if one reuses the context
    *   and assumes that the options remain the same.
    */
    (*vctxt).flags = 0 as std::os::raw::c_int;
    (*vctxt).validationRoot = 0 as xmlNodePtr;
    (*vctxt).doc = 0 as xmlDocPtr;
    (*vctxt).reader = 0 as xmlTextReaderPtr;
    (*vctxt).hasKeyrefs = 0 as std::os::raw::c_int;
    if !(*vctxt).value.is_null() {
        xmlSchemaFreeValue((*vctxt).value);
        (*vctxt).value = 0 as xmlSchemaValPtr
    }
    /*
    * Augmented IDC information.
    */
    if !(*vctxt).aidcs.is_null() {
        let mut cur: xmlSchemaIDCAugPtr = (*vctxt).aidcs;
        let mut next: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
        loop  {
            next = (*cur).next;
            xmlFree.expect("non-null function pointer")(cur as
                                                            *mut std::os::raw::c_void);
            cur = next;
            if cur.is_null() { break ; }
        }
        (*vctxt).aidcs = 0 as xmlSchemaIDCAugPtr
    }
    if !(*vctxt).idcMatcherCache.is_null() {
        let mut matcher: xmlSchemaIDCMatcherPtr = (*vctxt).idcMatcherCache;
        let mut tmp: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
        while !matcher.is_null() {
            tmp = matcher;
            matcher = (*matcher).nextCached;
            xmlSchemaIDCFreeMatcherList(tmp);
        }
        (*vctxt).idcMatcherCache = 0 as xmlSchemaIDCMatcherPtr
    }
    if !(*vctxt).idcNodes.is_null() {
        let mut i: std::os::raw::c_int = 0;
        let mut item: xmlSchemaPSVIIDCNodePtr =
            0 as *mut xmlSchemaPSVIIDCNode;
        i = 0 as std::os::raw::c_int;
        while i < (*vctxt).nbIdcNodes {
            item = *(*vctxt).idcNodes.offset(i as isize);
            xmlFree.expect("non-null function pointer")((*item).keys as
                                                            *mut std::os::raw::c_void);
            xmlFree.expect("non-null function pointer")(item as
                                                            *mut std::os::raw::c_void);
            i += 1
        }
        xmlFree.expect("non-null function pointer")((*vctxt).idcNodes as
                                                        *mut std::os::raw::c_void);
        (*vctxt).idcNodes = 0 as *mut xmlSchemaPSVIIDCNodePtr;
        (*vctxt).nbIdcNodes = 0 as std::os::raw::c_int;
        (*vctxt).sizeIdcNodes = 0 as std::os::raw::c_int
    }
    /*
    * Note that we won't delete the XPath state pool here.
    */
    if !(*vctxt).xpathStates.is_null() {
        xmlSchemaFreeIDCStateObjList((*vctxt).xpathStates);
        (*vctxt).xpathStates = 0 as xmlSchemaIDCStateObjPtr
    }
    /*
    * Attribute info.
    */
    if (*vctxt).nbAttrInfos != 0 as std::os::raw::c_int {
        xmlSchemaClearAttrInfos(vctxt);
    }
    /*
    * Element info.
    */
    if !(*vctxt).elemInfos.is_null() {
        let mut i_0: std::os::raw::c_int = 0;
        let mut ei: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
        i_0 = 0 as std::os::raw::c_int;
        while i_0 < (*vctxt).sizeElemInfos {
            ei = *(*vctxt).elemInfos.offset(i_0 as isize);
            if ei.is_null() { break ; }
            xmlSchemaClearElemInfo(vctxt, ei);
            i_0 += 1
        }
    }
    xmlSchemaItemListClear((*vctxt).nodeQNames);
    /* Recreate the dict. */
    xmlDictFree((*vctxt).dict);
    /*
    * TODO: Is is save to recreate it? Do we have a scenario
    * where the user provides the dict?
    */
    (*vctxt).dict = xmlDictCreate();
    if !(*vctxt).filename.is_null() {
        xmlFree.expect("non-null function pointer")((*vctxt).filename as
                                                        *mut std::os::raw::c_void);
        (*vctxt).filename = 0 as *mut std::os::raw::c_char
    };
}
/* *
 * xmlSchemaFreeValidCtxt:
 * @ctxt:  the schema validation context
 *
 * Free the resources associated to the schema validation context
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeValidCtxt(mut ctxt:
                                                    xmlSchemaValidCtxtPtr) {
    if ctxt.is_null() { return }
    if !(*ctxt).value.is_null() { xmlSchemaFreeValue((*ctxt).value); }
    if !(*ctxt).pctxt.is_null() { xmlSchemaFreeParserCtxt((*ctxt).pctxt); }
    if !(*ctxt).idcNodes.is_null() {
        let mut i: std::os::raw::c_int = 0;
        let mut item: xmlSchemaPSVIIDCNodePtr =
            0 as *mut xmlSchemaPSVIIDCNode;
        i = 0 as std::os::raw::c_int;
        while i < (*ctxt).nbIdcNodes {
            item = *(*ctxt).idcNodes.offset(i as isize);
            xmlFree.expect("non-null function pointer")((*item).keys as
                                                            *mut std::os::raw::c_void);
            xmlFree.expect("non-null function pointer")(item as
                                                            *mut std::os::raw::c_void);
            i += 1
        }
        xmlFree.expect("non-null function pointer")((*ctxt).idcNodes as
                                                        *mut std::os::raw::c_void);
    }
    if !(*ctxt).idcKeys.is_null() {
        let mut i_0: std::os::raw::c_int = 0;
        i_0 = 0 as std::os::raw::c_int;
        while i_0 < (*ctxt).nbIdcKeys {
            xmlSchemaIDCFreeKey(*(*ctxt).idcKeys.offset(i_0 as isize));
            i_0 += 1
        }
        xmlFree.expect("non-null function pointer")((*ctxt).idcKeys as
                                                        *mut std::os::raw::c_void);
    }
    if !(*ctxt).xpathStates.is_null() {
        xmlSchemaFreeIDCStateObjList((*ctxt).xpathStates);
        (*ctxt).xpathStates = 0 as xmlSchemaIDCStateObjPtr
    }
    if !(*ctxt).xpathStatePool.is_null() {
        xmlSchemaFreeIDCStateObjList((*ctxt).xpathStatePool);
        (*ctxt).xpathStatePool = 0 as xmlSchemaIDCStateObjPtr
    }
    /*
    * Augmented IDC information.
    */
    if !(*ctxt).aidcs.is_null() {
        let mut cur: xmlSchemaIDCAugPtr = (*ctxt).aidcs;
        let mut next: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
        loop  {
            next = (*cur).next;
            xmlFree.expect("non-null function pointer")(cur as
                                                            *mut std::os::raw::c_void);
            cur = next;
            if cur.is_null() { break ; }
        }
    }
    if !(*ctxt).attrInfos.is_null() {
        let mut i_1: std::os::raw::c_int = 0;
        let mut attr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
        /* Just a paranoid call to the cleanup. */
        if (*ctxt).nbAttrInfos != 0 as std::os::raw::c_int {
            xmlSchemaClearAttrInfos(ctxt);
        }
        i_1 = 0 as std::os::raw::c_int;
        while i_1 < (*ctxt).sizeAttrInfos {
            attr = *(*ctxt).attrInfos.offset(i_1 as isize);
            xmlFree.expect("non-null function pointer")(attr as
                                                            *mut std::os::raw::c_void);
            i_1 += 1
        }
        xmlFree.expect("non-null function pointer")((*ctxt).attrInfos as
                                                        *mut std::os::raw::c_void);
    }
    if !(*ctxt).elemInfos.is_null() {
        let mut i_2: std::os::raw::c_int = 0;
        let mut ei: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
        i_2 = 0 as std::os::raw::c_int;
        while i_2 < (*ctxt).sizeElemInfos {
            ei = *(*ctxt).elemInfos.offset(i_2 as isize);
            if ei.is_null() { break ; }
            xmlSchemaClearElemInfo(ctxt, ei);
            xmlFree.expect("non-null function pointer")(ei as
                                                            *mut std::os::raw::c_void);
            i_2 += 1
        }
        xmlFree.expect("non-null function pointer")((*ctxt).elemInfos as
                                                        *mut std::os::raw::c_void);
    }
    if !(*ctxt).nodeQNames.is_null() {
        xmlSchemaItemListFree((*ctxt).nodeQNames);
    }
    if !(*ctxt).dict.is_null() { xmlDictFree((*ctxt).dict); }
    if !(*ctxt).filename.is_null() {
        xmlFree.expect("non-null function pointer")((*ctxt).filename as
                                                        *mut std::os::raw::c_void);
    }
    xmlFree.expect("non-null function pointer")(ctxt as *mut std::os::raw::c_void);
}
/* *
 * xmlSchemaIsValid:
 * @ctxt: the schema validation context
 *
 * Check if any error was detected during validation.
 *
 * Returns 1 if valid so far, 0 if errors were detected, and -1 in case
 *         of internal error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaIsValid(mut ctxt: xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    return ((*ctxt).err == 0 as std::os::raw::c_int) as std::os::raw::c_int;
}
/* *
 * xmlSchemaSetValidErrors:
 * @ctxt:  a schema validation context
 * @err:  the error function
 * @warn: the warning function
 * @ctx: the functions context
 *
 * Set the error and warning callback informations
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetValidErrors(mut ctxt:
                                                     xmlSchemaValidCtxtPtr,
                                                 mut err:
                                                     xmlSchemaValidityErrorFunc,
                                                 mut warn:
                                                     xmlSchemaValidityWarningFunc,
                                                 mut ctx: *mut std::os::raw::c_void) {
    if ctxt.is_null() { return }
    (*ctxt).error = err;
    (*ctxt).warning = warn;
    (*ctxt).errCtxt = ctx;
    if !(*ctxt).pctxt.is_null() {
        xmlSchemaSetParserErrors((*ctxt).pctxt, err, warn, ctx);
    };
}
/* *
 * xmlSchemaSetValidStructuredErrors:
 * @ctxt:  a schema validation context
 * @serror:  the structured error function
 * @ctx: the functions context
 *
 * Set the structured error callback
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetValidStructuredErrors(mut ctxt:
                                                               xmlSchemaValidCtxtPtr,
                                                           mut serror:
                                                               xmlStructuredErrorFunc,
                                                           mut ctx:
                                                               *mut std::os::raw::c_void) {
    if ctxt.is_null() { return }
    (*ctxt).serror = serror;
    (*ctxt).error = None;
    (*ctxt).warning = None;
    (*ctxt).errCtxt = ctx;
    if !(*ctxt).pctxt.is_null() {
        xmlSchemaSetParserStructuredErrors((*ctxt).pctxt, serror, ctx);
    };
}
/* *
 * xmlSchemaGetValidErrors:
 * @ctxt: a XML-Schema validation context
 * @err: the error function result
 * @warn: the warning function result
 * @ctx: the functions context result
 *
 * Get the error and warning callback informations
 *
 * Returns -1 in case of error and 0 otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaGetValidErrors(mut ctxt:
                                                     xmlSchemaValidCtxtPtr,
                                                 mut err:
                                                     *mut xmlSchemaValidityErrorFunc,
                                                 mut warn:
                                                     *mut xmlSchemaValidityWarningFunc,
                                                 mut ctx:
                                                     *mut *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    if !err.is_null() { *err = (*ctxt).error }
    if !warn.is_null() { *warn = (*ctxt).warning }
    if !ctx.is_null() { *ctx = (*ctxt).errCtxt }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaSetValidOptions:
 * @ctxt:	a schema validation context
 * @options: a combination of xmlSchemaValidOption
 *
 * Sets the options to be used during the validation.
 *
 * Returns 0 in case of success, -1 in case of an
 * API error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetValidOptions(mut ctxt:
                                                      xmlSchemaValidCtxtPtr,
                                                  mut options: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut i: std::os::raw::c_int = 0;
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    /*
    * WARNING: Change the start value if adding to the
    * xmlSchemaValidOption.
    * TODO: Is there an other, more easy to maintain,
    * way?
    */
    i = 1 as std::os::raw::c_int;
    while i <
              ::std::mem::size_of::<std::os::raw::c_int>() as std::os::raw::c_ulong as
                  std::os::raw::c_int * 8 as std::os::raw::c_int {
        if options & (1 as std::os::raw::c_int) << i != 0 {
            return -(1 as std::os::raw::c_int)
        }
        i += 1
    }
    (*ctxt).options = options;
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlSchemaValidCtxtGetOptions:
 * @ctxt: a schema validation context
 *
 * Get the validation context options.
 *
 * Returns the option combination or -1 on error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidCtxtGetOptions(mut ctxt:
                                                          xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    if ctxt.is_null() {
        return -(1 as std::os::raw::c_int)
    } else { return (*ctxt).options };
}
unsafe extern "C" fn xmlSchemaVDocWalk(mut vctxt: xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ielem: xmlSchemaNodeInfoPtr = 0 as xmlSchemaNodeInfoPtr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut valRoot: xmlNodePtr = 0 as *mut xmlNode;
    let mut nsName: *const xmlChar = 0 as *const xmlChar;
    /* DOC VAL TODO: Move this to the start function. */
    if !(*vctxt).validationRoot.is_null() {
        valRoot = (*vctxt).validationRoot
    } else { valRoot = xmlDocGetRootElement((*vctxt).doc as *const xmlDoc) }
    if valRoot.is_null() {
        /* VAL TODO: Error code? */
        xmlSchemaCustomErr(vctxt as xmlSchemaAbstractCtxtPtr,
                           XML_ERR_INTERNAL_ERROR, 0 as xmlNodePtr,
                           0 as xmlSchemaBasicItemPtr,
                           b"The document has no document element\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return 1 as std::os::raw::c_int
    }
    (*vctxt).depth = -(1 as std::os::raw::c_int);
    (*vctxt).validationRoot = valRoot;
    node = valRoot;
    's_62:
        loop  {
            if node.is_null() {
                current_block = 17924451600171856673;
                break ;
            }
            if (*vctxt).skipDepth != -(1 as std::os::raw::c_int) &&
                   (*vctxt).depth >= (*vctxt).skipDepth {
                current_block = 16625201057675567771;
            } else {
                if (*node).type_0 as std::os::raw::c_uint ==
                       XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
                    /*
	    * Init the node-info.
	    */
                    (*vctxt).depth += 1;
                    if xmlSchemaValidatorPushElem(vctxt) ==
                           -(1 as std::os::raw::c_int) {
                        current_block = 5895246523861168621;
                        break ;
                    }
                    ielem = (*vctxt).inode;
                    (*ielem).node = node;
                    (*ielem).nodeLine = (*node).line as std::os::raw::c_int;
                    (*ielem).localName = (*node).name;
                    if !(*node).ns.is_null() {
                        (*ielem).nsName = (*(*node).ns).href
                    }
                    (*ielem).flags |= (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int;
                    /*
	    * Register attributes.
	    * DOC VAL TODO: We do not register namespace declaration
	    * attributes yet.
	    */
                    (*vctxt).nbAttrInfos = 0 as std::os::raw::c_int;
                    if !(*node).properties.is_null() {
                        attr = (*node).properties;
                        loop  {
                            if !(*attr).ns.is_null() {
                                nsName = (*(*attr).ns).href
                            } else { nsName = 0 as *const xmlChar }
                            ret =
                                xmlSchemaValidatorPushAttribute(vctxt,
                                                                attr as
                                                                    xmlNodePtr,
                                                                (*ielem).nodeLine,
                                                                (*attr).name,
                                                                nsName,
                                                                0 as
                                                                    std::os::raw::c_int,
                                                                xmlNodeListGetString((*attr).doc,
                                                                                     (*attr).children,
                                                                                     1
                                                                                         as
                                                                                         std::os::raw::c_int),
                                                                1 as
                                                                    std::os::raw::c_int);
                            if ret == -(1 as std::os::raw::c_int) {
                                xmlSchemaInternalErr(vctxt as
                                                         xmlSchemaAbstractCtxtPtr,
                                                     b"xmlSchemaDocWalk\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char,
                                                     b"calling xmlSchemaValidatorPushAttribute()\x00"
                                                         as *const u8 as
                                                         *const std::os::raw::c_char);
                                current_block = 5895246523861168621;
                                break 's_62 ;
                            } else {
                                attr = (*attr).next;
                                if attr.is_null() { break ; }
                            }
                        }
                    }
                    /*
	    * Validate the element.
	    */
                    ret = xmlSchemaValidateElem(vctxt);
                    if ret != 0 as std::os::raw::c_int {
                        if ret == -(1 as std::os::raw::c_int) {
                            xmlSchemaInternalErr(vctxt as
                                                     xmlSchemaAbstractCtxtPtr,
                                                 b"xmlSchemaDocWalk\x00" as
                                                     *const u8 as
                                                     *const std::os::raw::c_char,
                                                 b"calling xmlSchemaValidateElem()\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char);
                            current_block = 5895246523861168621;
                            break ;
                        }
                        current_block = 3560353928293617701;
                    } else if (*vctxt).skipDepth != -(1 as std::os::raw::c_int) &&
                                  (*vctxt).depth >= (*vctxt).skipDepth {
                        current_block = 3560353928293617701;
                    } else { current_block = 17233182392562552756; }
                } else if (*node).type_0 as std::os::raw::c_uint ==
                              XML_TEXT_NODE as std::os::raw::c_int as std::os::raw::c_uint ||
                              (*node).type_0 as std::os::raw::c_uint ==
                                  XML_CDATA_SECTION_NODE as std::os::raw::c_int as
                                      std::os::raw::c_uint {
                    /*
	    * Process character content.
	    */
                    if !ielem.is_null() &&
                           (*ielem).flags &
                               (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int != 0 {
                        (*ielem).flags ^=
                            (1 as std::os::raw::c_int) << 5 as std::os::raw::c_int
                    }
                    ret =
                        xmlSchemaVPushText(vctxt,
                                           (*node).type_0 as std::os::raw::c_int,
                                           (*node).content,
                                           -(1 as std::os::raw::c_int),
                                           1 as std::os::raw::c_int,
                                           0 as *mut std::os::raw::c_int);
                    if ret < 0 as std::os::raw::c_int {
                        xmlSchemaInternalErr(vctxt as
                                                 xmlSchemaAbstractCtxtPtr,
                                             b"xmlSchemaVDocWalk\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char,
                                             b"calling xmlSchemaVPushText()\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char);
                        current_block = 5895246523861168621;
                        break ;
                    } else { current_block = 17233182392562552756; }
                    /*
	    * DOC VAL TODO: Should we skip further validation of the
	    * element content here?
	    */
                } else if (*node).type_0 as std::os::raw::c_uint ==
                              XML_ENTITY_NODE as std::os::raw::c_int as std::os::raw::c_uint
                              ||
                              (*node).type_0 as std::os::raw::c_uint ==
                                  XML_ENTITY_REF_NODE as std::os::raw::c_int as
                                      std::os::raw::c_uint {
                    /*
	    * DOC VAL TODO: What to do with entities?
	    */
                    xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                         b"xmlSchemaVDocWalk\x00" as *const u8
                                             as *const std::os::raw::c_char,
                                         b"there is at least one entity reference in the node-tree currently being validated. Processing of entities with this XML Schema processor is not supported (yet). Please substitute entities before validation.\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char);
                    current_block = 5895246523861168621;
                    break ;
                } else { current_block = 3560353928293617701; }
                match current_block {
                    3560353928293617701 => { }
                    _ =>
                    /*
	* Walk the doc.
	*/
                    {
                        if !(*node).children.is_null() {
                            node = (*node).children;
                            continue ;
                        } else { current_block = 3560353928293617701; }
                    }
                }
            }
            loop  {
                match current_block {
                    16625201057675567771 => {
                        if !(*node).next.is_null() {
                            node = (*node).next;
                            break ;
                        } else {
                            node = (*node).parent;
                            current_block = 3560353928293617701;
                        }
                    }
                    _ => {
                        if !((*node).type_0 as std::os::raw::c_uint ==
                                 XML_ELEMENT_NODE as std::os::raw::c_int as
                                     std::os::raw::c_uint) {
                            current_block = 16625201057675567771;
                            continue ;
                            /*
	    * DOC VAL TODO: XInclude nodes, etc.
	    */
                        }
                        if node != (*(*vctxt).inode).node {
                            xmlSchemaInternalErr(vctxt as
                                                     xmlSchemaAbstractCtxtPtr,
                                                 b"xmlSchemaVDocWalk\x00" as
                                                     *const u8 as
                                                     *const std::os::raw::c_char,
                                                 b"element position mismatch\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char);
                            current_block = 5895246523861168621;
                            break 's_62 ;
                        } else {
                            ret = xmlSchemaValidatorPopElem(vctxt);
                            if ret != 0 as std::os::raw::c_int {
                                if ret < 0 as std::os::raw::c_int {
                                    xmlSchemaInternalErr(vctxt as
                                                             xmlSchemaAbstractCtxtPtr,
                                                         b"xmlSchemaVDocWalk\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char,
                                                         b"calling xmlSchemaValidatorPopElem()\x00"
                                                             as *const u8 as
                                                             *const std::os::raw::c_char);
                                    current_block = 5895246523861168621;
                                    break 's_62 ;
                                }
                            }
                            if node == valRoot {
                                current_block = 17924451600171856673;
                                break 's_62 ;
                            } else { current_block = 16625201057675567771; }
                        }
                    }
                }
            }
        }
    match current_block {
        5895246523861168621 => { return -(1 as std::os::raw::c_int) }
        _ => { return ret }
    };
}
unsafe extern "C" fn xmlSchemaPreRun(mut vctxt: xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    /*
	    * Leaving the scope of an element.
	    */
    /*
    * Some initialization.
    */
    (*vctxt).err = 0 as std::os::raw::c_int;
    (*vctxt).nberrors = 0 as std::os::raw::c_int;
    (*vctxt).depth = -(1 as std::os::raw::c_int);
    (*vctxt).skipDepth = -(1 as std::os::raw::c_int);
    (*vctxt).xsiAssemble = 0 as std::os::raw::c_int;
    (*vctxt).hasKeyrefs = 0 as std::os::raw::c_int;
    (*vctxt).createIDCNodeTables = 0 as std::os::raw::c_int;
    /*
    * Create a schema + parser if necessary.
    */
    if (*vctxt).schema.is_null() {
        let mut pctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
        (*vctxt).xsiAssemble = 1 as std::os::raw::c_int;
        /*
	* If not schema was given then we will create a schema
	* dynamically using XSI schema locations.
	*
	* Create the schema parser context.
	*/
        if (*vctxt).pctxt.is_null() &&
               xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
        pctxt = (*vctxt).pctxt;
        (*pctxt).xsiAssemble = 1 as std::os::raw::c_int;
        /*
	* Create the schema.
	*/
        (*vctxt).schema = xmlSchemaNewSchema(pctxt);
        if (*vctxt).schema.is_null() { return -(1 as std::os::raw::c_int) }
        /*
	* Create the schema construction context.
	*/
        (*pctxt).constructor = xmlSchemaConstructionCtxtCreate((*pctxt).dict);
        if (*pctxt).constructor.is_null() { return -(1 as std::os::raw::c_int) }
        (*(*pctxt).constructor).mainSchema = (*vctxt).schema;
        /*
	* Take ownership of the constructor to be able to free it.
	*/
        (*pctxt).ownsConstructor = 1 as std::os::raw::c_int
    }
    /*
    * Augment the IDC definitions for the main schema and all imported ones
    * NOTE: main schema if the first in the imported list
    */
    xmlHashScan((*(*vctxt).schema).schemasImports,
                Some(xmlSchemaAugmentImportedIDC as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *mut std::os::raw::c_void,
                                              _: *const xmlChar) -> ()),
                vctxt as *mut std::os::raw::c_void);
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlSchemaPostRun(mut vctxt: xmlSchemaValidCtxtPtr) {
    if (*vctxt).xsiAssemble != 0 {
        if !(*vctxt).schema.is_null() {
            xmlSchemaFree((*vctxt).schema);
            (*vctxt).schema = 0 as xmlSchemaPtr
        }
    }
    xmlSchemaClearValidCtxt(vctxt);
}
unsafe extern "C" fn xmlSchemaVStart(mut vctxt: xmlSchemaValidCtxtPtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if xmlSchemaPreRun(vctxt) < 0 as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    if !(*vctxt).doc.is_null() {
        /*
	 * Tree validation.
	 */
        ret = xmlSchemaVDocWalk(vctxt)
    } else if (*vctxt).reader.is_null() {
        if !(*vctxt).sax.is_null() && !(*vctxt).parserCtxt.is_null() {
            /*
	 * SAX validation.
	 */
            ret = xmlParseDocument((*vctxt).parserCtxt)
        } else {
            xmlSchemaInternalErr(vctxt as xmlSchemaAbstractCtxtPtr,
                                 b"xmlSchemaVStart\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                                 b"no instance to validate\x00" as *const u8
                                     as *const std::os::raw::c_char);
            ret = -(1 as std::os::raw::c_int)
        }
    }
    xmlSchemaPostRun(vctxt);
    if ret == 0 as std::os::raw::c_int { ret = (*vctxt).err }
    return ret;
}
/* *
 * xmlSchemaValidateOneElement:
 * @ctxt:  a schema validation context
 * @elem:  an element node
 *
 * Validate a branch of a tree, starting with the given @elem.
 *
 * Returns 0 if the element and its subtree is valid, a positive error
 * code number otherwise and -1 in case of an internal or API error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateOneElement(mut ctxt:
                                                         xmlSchemaValidCtxtPtr,
                                                     mut elem: xmlNodePtr)
 -> std::os::raw::c_int {
    if ctxt.is_null() || elem.is_null() ||
           (*elem).type_0 as std::os::raw::c_uint !=
               XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        return -(1 as std::os::raw::c_int)
    }
    if (*ctxt).schema.is_null() { return -(1 as std::os::raw::c_int) }
    (*ctxt).doc = (*elem).doc;
    (*ctxt).node = elem;
    (*ctxt).validationRoot = elem;
    return xmlSchemaVStart(ctxt);
}
/* *
 * xmlSchemaValidateDoc:
 * @ctxt:  a schema validation context
 * @doc:  a parsed document tree
 *
 * Validate a document tree in memory.
 *
 * Returns 0 if the document is schemas valid, a positive error code
 *     number otherwise and -1 in case of internal or API error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateDoc(mut ctxt: xmlSchemaValidCtxtPtr,
                                              mut doc: xmlDocPtr)
 -> std::os::raw::c_int {
    if ctxt.is_null() || doc.is_null() { return -(1 as std::os::raw::c_int) }
    (*ctxt).doc = doc;
    (*ctxt).node = xmlDocGetRootElement(doc as *const xmlDoc);
    if (*ctxt).node.is_null() {
        xmlSchemaCustomErr(ctxt as xmlSchemaAbstractCtxtPtr,
                           XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING,
                           doc as xmlNodePtr, 0 as xmlSchemaBasicItemPtr,
                           b"The document has no document element\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           0 as *const xmlChar, 0 as *const xmlChar);
        return (*ctxt).err
    }
    (*ctxt).validationRoot = (*ctxt).node;
    return xmlSchemaVStart(ctxt);
}
// struct _xmlSchemaSAXPlug {
//     unsigned int magic;
//     /* the original callbacks informations */
//     xmlSAXHandlerPtr     *user_sax_ptr;
//     xmlSAXHandlerPtr      user_sax;
//     void                **user_data_ptr;
//     void                 *user_data;
//     /* the block plugged back and validation informations */
//     xmlSAXHandler         schemas_sax;
//     xmlSchemaValidCtxtPtr ctxt;
// };
/* All those functions just bounces to the user provided SAX handlers */
unsafe extern "C" fn internalSubsetSplit(mut ctx: *mut std::os::raw::c_void,
                                         mut name: *const xmlChar,
                                         mut ExternalID: *const xmlChar,
                                         mut SystemID: *const xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).internalSubset.is_some() {
        (*(*ctxt).user_sax).internalSubset.expect("non-null function pointer")((*ctxt).user_data,
                                                                               name,
                                                                               ExternalID,
                                                                               SystemID);
    };
}
unsafe extern "C" fn isStandaloneSplit(mut ctx: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).isStandalone.is_some() {
        return (*(*ctxt).user_sax).isStandalone.expect("non-null function pointer")((*ctxt).user_data)
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn hasInternalSubsetSplit(mut ctx: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).hasInternalSubset.is_some() {
        return (*(*ctxt).user_sax).hasInternalSubset.expect("non-null function pointer")((*ctxt).user_data)
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn hasExternalSubsetSplit(mut ctx: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).hasExternalSubset.is_some() {
        return (*(*ctxt).user_sax).hasExternalSubset.expect("non-null function pointer")((*ctxt).user_data)
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn externalSubsetSplit(mut ctx: *mut std::os::raw::c_void,
                                         mut name: *const xmlChar,
                                         mut ExternalID: *const xmlChar,
                                         mut SystemID: *const xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).externalSubset.is_some() {
        (*(*ctxt).user_sax).externalSubset.expect("non-null function pointer")((*ctxt).user_data,
                                                                               name,
                                                                               ExternalID,
                                                                               SystemID);
    };
}
unsafe extern "C" fn resolveEntitySplit(mut ctx: *mut std::os::raw::c_void,
                                        mut publicId: *const xmlChar,
                                        mut systemId: *const xmlChar)
 -> xmlParserInputPtr {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).resolveEntity.is_some() {
        return (*(*ctxt).user_sax).resolveEntity.expect("non-null function pointer")((*ctxt).user_data,
                                                                                     publicId,
                                                                                     systemId)
    }
    return 0 as xmlParserInputPtr;
}
unsafe extern "C" fn getEntitySplit(mut ctx: *mut std::os::raw::c_void,
                                    mut name: *const xmlChar)
 -> xmlEntityPtr {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).getEntity.is_some() {
        return (*(*ctxt).user_sax).getEntity.expect("non-null function pointer")((*ctxt).user_data,
                                                                                 name)
    }
    return 0 as xmlEntityPtr;
}
unsafe extern "C" fn getParameterEntitySplit(mut ctx: *mut std::os::raw::c_void,
                                             mut name: *const xmlChar)
 -> xmlEntityPtr {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).getParameterEntity.is_some() {
        return (*(*ctxt).user_sax).getParameterEntity.expect("non-null function pointer")((*ctxt).user_data,
                                                                                          name)
    }
    return 0 as xmlEntityPtr;
}
unsafe extern "C" fn entityDeclSplit(mut ctx: *mut std::os::raw::c_void,
                                     mut name: *const xmlChar,
                                     mut type_0: std::os::raw::c_int,
                                     mut publicId: *const xmlChar,
                                     mut systemId: *const xmlChar,
                                     mut content: *mut xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).entityDecl.is_some() {
        (*(*ctxt).user_sax).entityDecl.expect("non-null function pointer")((*ctxt).user_data,
                                                                           name,
                                                                           type_0,
                                                                           publicId,
                                                                           systemId,
                                                                           content);
    };
}
unsafe extern "C" fn attributeDeclSplit(mut ctx: *mut std::os::raw::c_void,
                                        mut elem: *const xmlChar,
                                        mut name: *const xmlChar,
                                        mut type_0: std::os::raw::c_int,
                                        mut def: std::os::raw::c_int,
                                        mut defaultValue: *const xmlChar,
                                        mut tree: xmlEnumerationPtr) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).attributeDecl.is_some() {
        (*(*ctxt).user_sax).attributeDecl.expect("non-null function pointer")((*ctxt).user_data,
                                                                              elem,
                                                                              name,
                                                                              type_0,
                                                                              def,
                                                                              defaultValue,
                                                                              tree);
    } else { xmlFreeEnumeration(tree); };
}
unsafe extern "C" fn elementDeclSplit(mut ctx: *mut std::os::raw::c_void,
                                      mut name: *const xmlChar,
                                      mut type_0: std::os::raw::c_int,
                                      mut content: xmlElementContentPtr) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).elementDecl.is_some() {
        (*(*ctxt).user_sax).elementDecl.expect("non-null function pointer")((*ctxt).user_data,
                                                                            name,
                                                                            type_0,
                                                                            content);
    };
}
unsafe extern "C" fn notationDeclSplit(mut ctx: *mut std::os::raw::c_void,
                                       mut name: *const xmlChar,
                                       mut publicId: *const xmlChar,
                                       mut systemId: *const xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).notationDecl.is_some() {
        (*(*ctxt).user_sax).notationDecl.expect("non-null function pointer")((*ctxt).user_data,
                                                                             name,
                                                                             publicId,
                                                                             systemId);
    };
}
unsafe extern "C" fn unparsedEntityDeclSplit(mut ctx: *mut std::os::raw::c_void,
                                             mut name: *const xmlChar,
                                             mut publicId: *const xmlChar,
                                             mut systemId: *const xmlChar,
                                             mut notationName:
                                                 *const xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).unparsedEntityDecl.is_some() {
        (*(*ctxt).user_sax).unparsedEntityDecl.expect("non-null function pointer")((*ctxt).user_data,
                                                                                   name,
                                                                                   publicId,
                                                                                   systemId,
                                                                                   notationName);
    };
}
unsafe extern "C" fn setDocumentLocatorSplit(mut ctx: *mut std::os::raw::c_void,
                                             mut loc: xmlSAXLocatorPtr) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).setDocumentLocator.is_some() {
        (*(*ctxt).user_sax).setDocumentLocator.expect("non-null function pointer")((*ctxt).user_data,
                                                                                   loc);
    };
}
unsafe extern "C" fn startDocumentSplit(mut ctx: *mut std::os::raw::c_void) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).startDocument.is_some() {
        (*(*ctxt).user_sax).startDocument.expect("non-null function pointer")((*ctxt).user_data);
    };
}
unsafe extern "C" fn endDocumentSplit(mut ctx: *mut std::os::raw::c_void) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).endDocument.is_some() {
        (*(*ctxt).user_sax).endDocument.expect("non-null function pointer")((*ctxt).user_data);
    };
}
unsafe extern "C" fn processingInstructionSplit(mut ctx: *mut std::os::raw::c_void,
                                                mut target: *const xmlChar,
                                                mut data: *const xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).processingInstruction.is_some() {
        (*(*ctxt).user_sax).processingInstruction.expect("non-null function pointer")((*ctxt).user_data,
                                                                                      target,
                                                                                      data);
    };
}
unsafe extern "C" fn commentSplit(mut ctx: *mut std::os::raw::c_void,
                                  mut value: *const xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).comment.is_some() {
        (*(*ctxt).user_sax).comment.expect("non-null function pointer")((*ctxt).user_data,
                                                                        value);
    };
}
/*
 * Varargs error callbacks to the user application, harder ...
 */
// static void XMLCDECL
// warningSplit(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...) {
//     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
//     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&
//         (ctxt->user_sax->warning != NULL)) {
// 	TODO
//     }
// }
// static void XMLCDECL
// errorSplit(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...) {
//     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
//     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&
//         (ctxt->user_sax->error != NULL)) {
// 	TODO
//     }
// }
// static void XMLCDECL
// fatalErrorSplit(void *ctx, const char *msg ATTRIBUTE_UNUSED, ...) {
//     xmlSchemaSAXPlugPtr ctxt = (xmlSchemaSAXPlugPtr) ctx;
//     if ((ctxt != NULL) && (ctxt->user_sax != NULL) &&
//         (ctxt->user_sax->fatalError != NULL)) {
// 	TODO
//     }
// }
/*
 * Those are function where both the user handler and the schemas handler
 * need to be called.
 */
unsafe extern "C" fn charactersSplit(mut ctx: *mut std::os::raw::c_void,
                                     mut ch: *const xmlChar,
                                     mut len: std::os::raw::c_int) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() { return }
    if !(*ctxt).user_sax.is_null() && (*(*ctxt).user_sax).characters.is_some()
       {
        (*(*ctxt).user_sax).characters.expect("non-null function pointer")((*ctxt).user_data,
                                                                           ch,
                                                                           len);
    }
    if !(*ctxt).ctxt.is_null() {
        xmlSchemaSAXHandleText((*ctxt).ctxt as *mut std::os::raw::c_void, ch, len);
    };
}
unsafe extern "C" fn ignorableWhitespaceSplit(mut ctx: *mut std::os::raw::c_void,
                                              mut ch: *const xmlChar,
                                              mut len: std::os::raw::c_int) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() { return }
    if !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).ignorableWhitespace.is_some() {
        (*(*ctxt).user_sax).ignorableWhitespace.expect("non-null function pointer")((*ctxt).user_data,
                                                                                    ch,
                                                                                    len);
    }
    if !(*ctxt).ctxt.is_null() {
        xmlSchemaSAXHandleText((*ctxt).ctxt as *mut std::os::raw::c_void, ch, len);
    };
}
unsafe extern "C" fn cdataBlockSplit(mut ctx: *mut std::os::raw::c_void,
                                     mut value: *const xmlChar,
                                     mut len: std::os::raw::c_int) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() { return }
    if !(*ctxt).user_sax.is_null() && (*(*ctxt).user_sax).cdataBlock.is_some()
       {
        (*(*ctxt).user_sax).cdataBlock.expect("non-null function pointer")((*ctxt).user_data,
                                                                           value,
                                                                           len);
    }
    if !(*ctxt).ctxt.is_null() {
        xmlSchemaSAXHandleCDataSection((*ctxt).ctxt as *mut std::os::raw::c_void,
                                       value, len);
    };
}
unsafe extern "C" fn referenceSplit(mut ctx: *mut std::os::raw::c_void,
                                    mut name: *const xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() { return }
    if !ctxt.is_null() && !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).reference.is_some() {
        (*(*ctxt).user_sax).reference.expect("non-null function pointer")((*ctxt).user_data,
                                                                          name);
    }
    if !(*ctxt).ctxt.is_null() {
        xmlSchemaSAXHandleReference((*ctxt).user_data, name);
    };
}
unsafe extern "C" fn startElementNsSplit(mut ctx: *mut std::os::raw::c_void,
                                         mut localname: *const xmlChar,
                                         mut prefix: *const xmlChar,
                                         mut URI: *const xmlChar,
                                         mut nb_namespaces: std::os::raw::c_int,
                                         mut namespaces: *mut *const xmlChar,
                                         mut nb_attributes: std::os::raw::c_int,
                                         mut nb_defaulted: std::os::raw::c_int,
                                         mut attributes:
                                             *mut *const xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() { return }
    if !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).startElementNs.is_some() {
        (*(*ctxt).user_sax).startElementNs.expect("non-null function pointer")((*ctxt).user_data,
                                                                               localname,
                                                                               prefix,
                                                                               URI,
                                                                               nb_namespaces,
                                                                               namespaces,
                                                                               nb_attributes,
                                                                               nb_defaulted,
                                                                               attributes);
    }
    if !(*ctxt).ctxt.is_null() {
        xmlSchemaSAXHandleStartElementNs((*ctxt).ctxt as *mut std::os::raw::c_void,
                                         localname, prefix, URI,
                                         nb_namespaces, namespaces,
                                         nb_attributes, nb_defaulted,
                                         attributes);
    };
}
unsafe extern "C" fn endElementNsSplit(mut ctx: *mut std::os::raw::c_void,
                                       mut localname: *const xmlChar,
                                       mut prefix: *const xmlChar,
                                       mut URI: *const xmlChar) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() { return }
    if !(*ctxt).user_sax.is_null() &&
           (*(*ctxt).user_sax).endElementNs.is_some() {
        (*(*ctxt).user_sax).endElementNs.expect("non-null function pointer")((*ctxt).user_data,
                                                                             localname,
                                                                             prefix,
                                                                             URI);
    }
    if !(*ctxt).ctxt.is_null() {
        xmlSchemaSAXHandleEndElementNs((*ctxt).ctxt as *mut std::os::raw::c_void,
                                       localname, prefix, URI);
    };
}
/* *
 * xmlSchemaSAXPlug:
 * @ctxt:  a schema validation context
 * @sax:  a pointer to the original xmlSAXHandlerPtr
 * @user_data:  a pointer to the original SAX user data pointer
 *
 * Plug a SAX based validation layer in a SAX parsing event flow.
 * The original @saxptr and @dataptr data are replaced by new pointers
 * but the calls to the original will be maintained.
 *
 * Returns a pointer to a data structure needed to unplug the validation layer
 *         or NULL in case of errors.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSAXPlug(mut ctxt: xmlSchemaValidCtxtPtr,
                                          mut sax: *mut xmlSAXHandlerPtr,
                                          mut user_data:
                                              *mut *mut std::os::raw::c_void)
 -> xmlSchemaSAXPlugPtr {
    let mut ret: xmlSchemaSAXPlugPtr = 0 as *mut xmlSchemaSAXPlugStruct;
    let mut old_sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    if ctxt.is_null() || sax.is_null() || user_data.is_null() {
        return 0 as xmlSchemaSAXPlugPtr
    }
    /*
     * We only allow to plug into SAX2 event streams
     */
    old_sax = *sax;
    if !old_sax.is_null() &&
           (*old_sax).initialized != 0xdeedbeaf as std::os::raw::c_uint {
        return 0 as xmlSchemaSAXPlugPtr
    }
    if !old_sax.is_null() && (*old_sax).startElementNs.is_none() &&
           (*old_sax).endElementNs.is_none() &&
           ((*old_sax).startElement.is_some() ||
                (*old_sax).endElement.is_some()) {
        return 0 as xmlSchemaSAXPlugPtr
    }
    /*
     * everything seems right allocate the local data needed for that layer
     */
    ret =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaSAXPlugStruct>()
                                                          as std::os::raw::c_ulong) as
            xmlSchemaSAXPlugPtr;
    if ret.is_null() { return 0 as xmlSchemaSAXPlugPtr }
    memset(ret as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlSchemaSAXPlugStruct>() as std::os::raw::c_ulong);
    (*ret).magic = 0xdc43ba21 as std::os::raw::c_uint;
    (*ret).schemas_sax.initialized = 0xdeedbeaf as std::os::raw::c_uint;
    (*ret).ctxt = ctxt;
    (*ret).user_sax_ptr = sax;
    (*ret).user_sax = old_sax;
    if old_sax.is_null() {
        /*
	 * go direct, no need for the split block and functions.
	 */
        (*ret).schemas_sax.startElementNs =
            Some(xmlSchemaSAXHandleStartElementNs as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar,
                                          _: *const xmlChar,
                                          _: *const xmlChar, _: std::os::raw::c_int,
                                          _: *mut *const xmlChar,
                                          _: std::os::raw::c_int, _: std::os::raw::c_int,
                                          _: *mut *const xmlChar) -> ());
        (*ret).schemas_sax.endElementNs =
            Some(xmlSchemaSAXHandleEndElementNs as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar,
                                          _: *const xmlChar,
                                          _: *const xmlChar) -> ());
        /*
	 * Note that we use the same text-function for both, to prevent
	 * the parser from testing for ignorable whitespace.
	 */
        (*ret).schemas_sax.ignorableWhitespace =
            Some(xmlSchemaSAXHandleText as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar, _: std::os::raw::c_int)
                         -> ());
        (*ret).schemas_sax.characters =
            Some(xmlSchemaSAXHandleText as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar, _: std::os::raw::c_int)
                         -> ());
        (*ret).schemas_sax.cdataBlock =
            Some(xmlSchemaSAXHandleCDataSection as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar, _: std::os::raw::c_int)
                         -> ());
        (*ret).schemas_sax.reference =
            Some(xmlSchemaSAXHandleReference as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar) -> ());
        (*ret).user_data = ctxt as *mut std::os::raw::c_void;
        *user_data = ctxt as *mut std::os::raw::c_void
    } else {
        /*
        * for each callback unused by Schemas initialize it to the Split
	* routine only if non NULL in the user block, this can speed up
	* things at the SAX level.
	*/
        if (*old_sax).internalSubset.is_some() {
            (*ret).schemas_sax.internalSubset =
                Some(internalSubsetSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: *const xmlChar,
                                              _: *const xmlChar) -> ())
        }
        if (*old_sax).isStandalone.is_some() {
            (*ret).schemas_sax.isStandalone =
                Some(isStandaloneSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                             -> std::os::raw::c_int)
        }
        if (*old_sax).hasInternalSubset.is_some() {
            (*ret).schemas_sax.hasInternalSubset =
                Some(hasInternalSubsetSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                             -> std::os::raw::c_int)
        }
        if (*old_sax).hasExternalSubset.is_some() {
            (*ret).schemas_sax.hasExternalSubset =
                Some(hasExternalSubsetSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                             -> std::os::raw::c_int)
        }
        if (*old_sax).resolveEntity.is_some() {
            (*ret).schemas_sax.resolveEntity =
                Some(resolveEntitySplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: *const xmlChar)
                             -> xmlParserInputPtr)
        }
        if (*old_sax).getEntity.is_some() {
            (*ret).schemas_sax.getEntity =
                Some(getEntitySplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar)
                             -> xmlEntityPtr)
        }
        if (*old_sax).entityDecl.is_some() {
            (*ret).schemas_sax.entityDecl =
                Some(entityDeclSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: std::os::raw::c_int,
                                              _: *const xmlChar,
                                              _: *const xmlChar,
                                              _: *mut xmlChar) -> ())
        }
        if (*old_sax).notationDecl.is_some() {
            (*ret).schemas_sax.notationDecl =
                Some(notationDeclSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: *const xmlChar,
                                              _: *const xmlChar) -> ())
        }
        if (*old_sax).attributeDecl.is_some() {
            (*ret).schemas_sax.attributeDecl =
                Some(attributeDeclSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: *const xmlChar,
                                              _: std::os::raw::c_int, _: std::os::raw::c_int,
                                              _: *const xmlChar,
                                              _: xmlEnumerationPtr) -> ())
        }
        if (*old_sax).elementDecl.is_some() {
            (*ret).schemas_sax.elementDecl =
                Some(elementDeclSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: std::os::raw::c_int,
                                              _: xmlElementContentPtr) -> ())
        }
        if (*old_sax).unparsedEntityDecl.is_some() {
            (*ret).schemas_sax.unparsedEntityDecl =
                Some(unparsedEntityDeclSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: *const xmlChar,
                                              _: *const xmlChar,
                                              _: *const xmlChar) -> ())
        }
        if (*old_sax).setDocumentLocator.is_some() {
            (*ret).schemas_sax.setDocumentLocator =
                Some(setDocumentLocatorSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: xmlSAXLocatorPtr) -> ())
        }
        if (*old_sax).startDocument.is_some() {
            (*ret).schemas_sax.startDocument =
                Some(startDocumentSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ())
        }
        if (*old_sax).endDocument.is_some() {
            (*ret).schemas_sax.endDocument =
                Some(endDocumentSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ())
        }
        if (*old_sax).processingInstruction.is_some() {
            (*ret).schemas_sax.processingInstruction =
                Some(processingInstructionSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: *const xmlChar) -> ())
        }
        if (*old_sax).comment.is_some() {
            (*ret).schemas_sax.comment =
                Some(commentSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar) -> ())
        }
        if (*old_sax).warning.is_some() {
            (*ret).schemas_sax.warning =
                Some(warningSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const std::os::raw::c_char, _: ...)
                             -> ())
        }
        if (*old_sax).error.is_some() {
            (*ret).schemas_sax.error =
                Some(errorSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const std::os::raw::c_char, _: ...)
                             -> ())
        }
        if (*old_sax).fatalError.is_some() {
            (*ret).schemas_sax.fatalError =
                Some(fatalErrorSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const std::os::raw::c_char, _: ...)
                             -> ())
        }
        if (*old_sax).getParameterEntity.is_some() {
            (*ret).schemas_sax.getParameterEntity =
                Some(getParameterEntitySplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar)
                             -> xmlEntityPtr)
        }
        if (*old_sax).externalSubset.is_some() {
            (*ret).schemas_sax.externalSubset =
                Some(externalSubsetSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: *const xmlChar,
                                              _: *const xmlChar) -> ())
        }
        /*
	 * the 6 schemas callback have to go to the splitter functions
	 * Note that we use the same text-function for ignorableWhitespace
	 * if possible, to prevent the parser from testing for ignorable
	 * whitespace.
	 */
        (*ret).schemas_sax.characters =
            Some(charactersSplit as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar, _: std::os::raw::c_int)
                         -> ());
        if (*old_sax).ignorableWhitespace.is_some() &&
               (*old_sax).ignorableWhitespace != (*old_sax).characters {
            (*ret).schemas_sax.ignorableWhitespace =
                Some(ignorableWhitespaceSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: std::os::raw::c_int) -> ())
        } else {
            (*ret).schemas_sax.ignorableWhitespace =
                Some(charactersSplit as
                         unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                              _: *const xmlChar,
                                              _: std::os::raw::c_int) -> ())
        }
        (*ret).schemas_sax.cdataBlock =
            Some(cdataBlockSplit as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar, _: std::os::raw::c_int)
                         -> ());
        (*ret).schemas_sax.reference =
            Some(referenceSplit as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar) -> ());
        (*ret).schemas_sax.startElementNs =
            Some(startElementNsSplit as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar,
                                          _: *const xmlChar,
                                          _: *const xmlChar, _: std::os::raw::c_int,
                                          _: *mut *const xmlChar,
                                          _: std::os::raw::c_int, _: std::os::raw::c_int,
                                          _: *mut *const xmlChar) -> ());
        (*ret).schemas_sax.endElementNs =
            Some(endElementNsSplit as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar,
                                          _: *const xmlChar,
                                          _: *const xmlChar) -> ());
        (*ret).user_data_ptr = user_data;
        (*ret).user_data = *user_data;
        *user_data = ret as *mut std::os::raw::c_void
    }
    /*
     * plug the pointers back.
     */
    *sax = &mut (*ret).schemas_sax;
    (*ctxt).sax = *sax;
    (*ctxt).flags |= 1 as std::os::raw::c_int;
    xmlSchemaPreRun(ctxt);
    return ret;
}
/* *
 * xmlSchemaSAXUnplug:
 * @plug:  a data structure returned by xmlSchemaSAXPlug
 *
 * Unplug a SAX based validation layer in a SAX parsing event flow.
 * The original pointers used in the call are restored.
 *
 * Returns 0 in case of success and -1 in case of failure.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSAXUnplug(mut plug: xmlSchemaSAXPlugPtr)
 -> std::os::raw::c_int {
    let mut sax: *mut xmlSAXHandlerPtr = 0 as *mut xmlSAXHandlerPtr;
    let mut user_data: *mut *mut std::os::raw::c_void = 0 as *mut *mut std::os::raw::c_void;
    if plug.is_null() || (*plug).magic != 0xdc43ba21 as std::os::raw::c_uint {
        return -(1 as std::os::raw::c_int)
    }
    (*plug).magic = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    xmlSchemaPostRun((*plug).ctxt);
    /* restore the data */
    sax = (*plug).user_sax_ptr;
    *sax = (*plug).user_sax;
    if !(*plug).user_sax.is_null() {
        user_data = (*plug).user_data_ptr;
        *user_data = (*plug).user_data
    }
    /* free and return */
    xmlFree.expect("non-null function pointer")(plug as *mut std::os::raw::c_void);
    return 0 as std::os::raw::c_int;
}
/*
 * Interface to insert Schemas SAX validation in a SAX stream
 */
/* *
 * xmlSchemaValidateSetLocator:
 * @vctxt: a schema validation context
 * @f: the locator function pointer
 * @ctxt: the locator context
 *
 * Allows to set a locator function to the validation context,
 * which will be used to provide file and line information since
 * those are not provided as part of the SAX validation flow
 * Setting @f to NULL disable the locator.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateSetLocator(mut vctxt:
                                                         xmlSchemaValidCtxtPtr,
                                                     mut f:
                                                         xmlSchemaValidityLocatorFunc,
                                                     mut ctxt:
                                                         *mut std::os::raw::c_void) {
    if vctxt.is_null() { return }
    (*vctxt).locFunc = f;
    (*vctxt).locCtxt = ctxt;
}
/* *
 * xmlSchemaValidateStreamLocator:
 * @ctx: the xmlTextReaderPtr used
 * @file: returned file information
 * @line: returned line information
 *
 * Internal locator function for the readers
 *
 * Returns 0 in case the Schema validation could be (des)activated and
 *         -1 in case of error.
 */
unsafe extern "C" fn xmlSchemaValidateStreamLocator(mut ctx:
                                                        *mut std::os::raw::c_void,
                                                    mut file:
                                                        *mut *const std::os::raw::c_char,
                                                    mut line:
                                                        *mut std::os::raw::c_ulong)
 -> std::os::raw::c_int {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    if ctx.is_null() || file.is_null() && line.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    if !file.is_null() { *file = 0 as *const std::os::raw::c_char }
    if !line.is_null() { *line = 0 as std::os::raw::c_int as std::os::raw::c_ulong }
    ctxt = ctx as xmlParserCtxtPtr;
    if !(*ctxt).input.is_null() {
        if !file.is_null() { *file = (*(*ctxt).input).filename }
        if !line.is_null() { *line = (*(*ctxt).input).line as std::os::raw::c_ulong }
        return 0 as std::os::raw::c_int
    }
    return -(1 as std::os::raw::c_int);
}
/* *
 * xmlSchemaValidateStream:
 * @ctxt:  a schema validation context
 * @input:  the input to use for reading the data
 * @enc:  an optional encoding information
 * @sax:  a SAX handler for the resulting events
 * @user_data:  the context to provide to the SAX handler.
 *
 * Validate an input based on a flow of SAX event from the parser
 * and forward the events to the @sax handler with the provided @user_data
 * the user provided @sax handler must be a SAX2 one.
 *
 * Returns 0 if the document is schemas valid, a positive error code
 *     number otherwise and -1 in case of internal or API error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateStream(mut ctxt:
                                                     xmlSchemaValidCtxtPtr,
                                                 mut input:
                                                     xmlParserInputBufferPtr,
                                                 mut enc: xmlCharEncoding,
                                                 mut sax: xmlSAXHandlerPtr,
                                                 mut user_data:
                                                     *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut plug: xmlSchemaSAXPlugPtr = 0 as xmlSchemaSAXPlugPtr;
    let mut old_sax: xmlSAXHandlerPtr = 0 as xmlSAXHandlerPtr;
    let mut pctxt: xmlParserCtxtPtr = 0 as xmlParserCtxtPtr;
    let mut inputStream: xmlParserInputPtr = 0 as xmlParserInputPtr;
    let mut ret: std::os::raw::c_int = 0;
    if ctxt.is_null() || input.is_null() { return -(1 as std::os::raw::c_int) }
    /*
     * prepare the parser
     */
    pctxt = xmlNewParserCtxt();
    if pctxt.is_null() { return -(1 as std::os::raw::c_int) }
    old_sax = (*pctxt).sax;
    (*pctxt).sax = sax;
    (*pctxt).userData = user_data;
    (*pctxt).linenumbers = 1 as std::os::raw::c_int;
    xmlSchemaValidateSetLocator(ctxt,
                                Some(xmlSchemaValidateStreamLocator as
                                         unsafe extern "C" fn(_:
                                                                  *mut std::os::raw::c_void,
                                                              _:
                                                                  *mut *const std::os::raw::c_char,
                                                              _:
                                                                  *mut std::os::raw::c_ulong)
                                             -> std::os::raw::c_int),
                                pctxt as *mut std::os::raw::c_void);
    inputStream = xmlNewIOInputStream(pctxt, input, enc);
    if inputStream.is_null() {
        ret = -(1 as std::os::raw::c_int)
    } else {
        inputPush(pctxt, inputStream);
        (*ctxt).parserCtxt = pctxt;
        (*ctxt).input = input;
        /*
     * Plug the validation and launch the parsing
     */
        plug =
            xmlSchemaSAXPlug(ctxt, &mut (*pctxt).sax, &mut (*pctxt).userData);
        if plug.is_null() {
            ret = -(1 as std::os::raw::c_int)
        } else {
            (*ctxt).input = input;
            (*ctxt).enc = enc;
            (*ctxt).sax = (*pctxt).sax;
            (*ctxt).flags |= 1 as std::os::raw::c_int;
            ret = xmlSchemaVStart(ctxt);
            if ret == 0 as std::os::raw::c_int &&
                   (*(*ctxt).parserCtxt).wellFormed == 0 {
                ret = (*(*ctxt).parserCtxt).errNo;
                if ret == 0 as std::os::raw::c_int { ret = 1 as std::os::raw::c_int }
            }
        }
    }
    (*ctxt).parserCtxt = 0 as xmlParserCtxtPtr;
    (*ctxt).sax = 0 as xmlSAXHandlerPtr;
    (*ctxt).input = 0 as xmlParserInputBufferPtr;
    if !plug.is_null() { xmlSchemaSAXUnplug(plug); }
    /* cleanup */
    if !pctxt.is_null() { (*pctxt).sax = old_sax; xmlFreeParserCtxt(pctxt); }
    return ret;
}
/* *
 * xmlSchemaValidateFile:
 * @ctxt: a schema validation context
 * @filename: the URI of the instance
 * @options: a future set of options, currently unused
 *
 * Do a schemas validation of the given resource, it will use the
 * SAX streamable validation internally.
 *
 * Returns 0 if the document is valid, a positive error code
 *     number otherwise and -1 in case of an internal or API error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateFile(mut ctxt:
                                                   xmlSchemaValidCtxtPtr,
                                               mut filename:
                                                   *const std::os::raw::c_char,
                                               mut options: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    if ctxt.is_null() || filename.is_null() { return -(1 as std::os::raw::c_int) }
    input =
        xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
    if input.is_null() { return -(1 as std::os::raw::c_int) }
    ret =
        xmlSchemaValidateStream(ctxt, input, XML_CHAR_ENCODING_NONE,
                                0 as xmlSAXHandlerPtr,
                                0 as *mut std::os::raw::c_void);
    return ret;
}
/*
 * Summary: incomplete XML Schemas structure implementation
 * Description: interface to the XML Schemas handling and schema validity
 *              checking, it is incomplete right now.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * This error codes are obsolete; not used any more.
 */
/*
* ATTENTION: Change xmlSchemaSetValidOptions's check
* for invalid values, if adding to the validation
* options below.
*/
/* *
 * xmlSchemaValidOption:
 *
 * This is the set of XML Schema validation options.
 */
/* Default/fixed: create an attribute node
	* or an element's text node on the instance.
	*/
/*
    XML_SCHEMA_VAL_XSI_ASSEMBLE			= 1<<1,
	* assemble schemata using
	* xsi:schemaLocation and
	* xsi:noNamespaceSchemaLocation
*/
/* *
 * The schemas related types are kept internal
 */
/* *
 * xmlSchemaValidityErrorFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of an error callback from an XSD validation
 */
/* *
 * xmlSchemaValidityWarningFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of a warning callback from an XSD validation
 */
/* *
 * A schemas validation context
 */
/* *
 * xmlSchemaValidityLocatorFunc:
 * @ctx: user provided context
 * @file: returned file information
 * @line: returned line information
 *
 * A schemas validation locator, a callback called by the validator.
 * This is used when file or node informations are not available
 * to find out what file and line number are affected
 *
 * Returns: 0 in case of success and -1 in case of error
 */
/*
 * Interfaces for parsing.
 */
/* LIBXML_OUTPUT_ENABLED */
/*
 * Interfaces for validating
 */
/* *
 * xmlSchemaValidCtxtGetParserCtxt:
 * @ctxt: a schema validation context
 *
 * allow access to the parser context of the schema validation context
 *
 * Returns the parser context of the schema validation context or NULL
 *         in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidCtxtGetParserCtxt(mut ctxt:
                                                             xmlSchemaValidCtxtPtr)
 -> xmlParserCtxtPtr {
    if ctxt.is_null() { return 0 as xmlParserCtxtPtr }
    return (*ctxt).parserCtxt;
}
/* LIBXML_SCHEMAS_ENABLED */
/* __INCLUDE_ELFGCCHACK */
