
extern "C" {
    pub type _xmlDict;
    pub type _xmlHashTable;
    pub type _xmlBuf;
    pub type _xmlAutomataState;
    pub type _xmlAutomata;
    pub type _xmlValidState;
    #[no_mangle]
    fn vsnprintf(_: *mut std::os::raw::c_char, _: std::os::raw::c_ulong,
                 _: *const std::os::raw::c_char, _: ::std::ffi::VaList)
     -> std::os::raw::c_int;
    /*
 * Summary: interface for all global variables of the library
 * Description: all the global variables and thread handling for
 *              those variables is handled by this module.
 *
 * The bottom of this file is automatically generated by build_glob.py
 * based on the description file global.data
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
 */
    /* *
 * xmlParserInputBufferCreateFilenameFunc:
 * @URI: the URI to read from
 * @enc: the requested source encoding
 *
 * Signature for the function doing the lookup for a suitable input method
 * corresponding to an URI.
 *
 * Returns the new xmlParserInputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /* *
 * xmlOutputBufferCreateFilenameFunc:
 * @URI: the URI to write to
 * @enc: the requested target encoding
 *
 * Signature for the function doing the lookup for a suitable output method
 * corresponding to an URI.
 *
 * Returns the new xmlOutputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /*
 * Externally global symbols which need to be protected for backwards
 * compatibility support.
 */
    /* *
 * xmlRegisterNodeFunc:
 * @node: the current node
 *
 * Signature for the registration callback of a created node
 */
    /* *
 * xmlDeregisterNodeFunc:
 * @node: the current node
 *
 * Signature for the deregistration callback of a discarded node
 */
    /* * DOC_DISABLE */
/*
 * In general the memory allocation entry points are not kept
 * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED
 *    - xmlMalloc
 *    - xmlMallocAtomic
 *    - xmlRealloc
 *    - xmlMemStrdup
 *    - xmlFree
 */
    /* !LIBXML_THREAD_ALLOC_ENABLED */
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    #[no_mangle]
    fn __xmlGenericError() -> *mut xmlGenericErrorFunc;
    #[no_mangle]
    fn __xmlGenericErrorContext() -> *mut *mut std::os::raw::c_void;
    #[no_mangle]
    static mut xmlMalloc: xmlMallocFunc;
    #[no_mangle]
    static mut xmlRealloc: xmlReallocFunc;
    #[no_mangle]
    static mut xmlMallocAtomic: xmlMallocFunc;
    #[no_mangle]
    fn memcpy(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_void, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn strncmp(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char,
               _: std::os::raw::c_ulong) -> std::os::raw::c_int;
    /* LIBXML_LEGACY_ENABLED */
    /*
 * internal only
 */
    #[no_mangle]
    fn xmlErrMemory(ctxt: xmlParserCtxtPtr, extra: *const std::os::raw::c_char);
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: std::os::raw::c_uint,
    pub fp_offset: std::os::raw::c_uint,
    pub overflow_arg_area: *mut std::os::raw::c_void,
    pub reg_save_area: *mut std::os::raw::c_void,
}
/*
 * Summary: set of routines to process strings
 * Description: type and interfaces needed for the internal string handling
 *              of the library, especially UTF8 processing.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlChar:
 *
 * This is a basic byte in an UTF-8 encoded string.
 * It's unsigned allowing to pinpoint case where char * are assigned
 * to xmlChar * (possibly making serialization back impossible).
 */
pub type xmlChar = std::os::raw::c_uchar;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
pub type xmlParserCtxt = _xmlParserCtxt;
/* *
 * xmlParserCtxt:
 *
 * The parser context.
 * NOTE This doesn't completely define the parser state, the (current ?)
 *      design of the parser uses recursive function calls since this allow
 *      and easy mapping from the production rules of the specification
 *      to the actual code. The drawback is that the actual function call
 *      also reflect the parser state. However most of the parsing routines
 *      takes as the only argument the parser context pointer, so migrating
 *      to a state based parser for progressive parsing shouldn't be too hard.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserCtxt {
    pub sax: *mut _xmlSAXHandler,
    pub userData: *mut std::os::raw::c_void,
    pub myDoc: xmlDocPtr,
    pub wellFormed: std::os::raw::c_int,
    pub replaceEntities: std::os::raw::c_int,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub html: std::os::raw::c_int,
    pub input: xmlParserInputPtr,
    pub inputNr: std::os::raw::c_int,
    pub inputMax: std::os::raw::c_int,
    pub inputTab: *mut xmlParserInputPtr,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub record_info: std::os::raw::c_int,
    pub node_seq: xmlParserNodeInfoSeq,
    pub errNo: std::os::raw::c_int,
    pub hasExternalSubset: std::os::raw::c_int,
    pub hasPErefs: std::os::raw::c_int,
    pub external: std::os::raw::c_int,
    pub valid: std::os::raw::c_int,
    pub validate: std::os::raw::c_int,
    pub vctxt: xmlValidCtxt,
    pub instate: xmlParserInputState,
    pub token: std::os::raw::c_int,
    pub directory: *mut std::os::raw::c_char,
    pub name: *const xmlChar,
    pub nameNr: std::os::raw::c_int,
    pub nameMax: std::os::raw::c_int,
    pub nameTab: *mut *const xmlChar,
    pub nbChars: std::os::raw::c_long,
    pub checkIndex: std::os::raw::c_long,
    pub keepBlanks: std::os::raw::c_int,
    pub disableSAX: std::os::raw::c_int,
    pub inSubset: std::os::raw::c_int,
    pub intSubName: *const xmlChar,
    pub extSubURI: *mut xmlChar,
    pub extSubSystem: *mut xmlChar,
    pub space: *mut std::os::raw::c_int,
    pub spaceNr: std::os::raw::c_int,
    pub spaceMax: std::os::raw::c_int,
    pub spaceTab: *mut std::os::raw::c_int,
    pub depth: std::os::raw::c_int,
    pub entity: xmlParserInputPtr,
    pub charset: std::os::raw::c_int,
    pub nodelen: std::os::raw::c_int,
    pub nodemem: std::os::raw::c_int,
    pub pedantic: std::os::raw::c_int,
    pub _private: *mut std::os::raw::c_void,
    pub loadsubset: std::os::raw::c_int,
    pub linenumbers: std::os::raw::c_int,
    pub catalogs: *mut std::os::raw::c_void,
    pub recovery: std::os::raw::c_int,
    pub progressive: std::os::raw::c_int,
    pub dict: xmlDictPtr,
    pub atts: *mut *const xmlChar,
    pub maxatts: std::os::raw::c_int,
    pub docdict: std::os::raw::c_int,
    pub str_xml: *const xmlChar,
    pub str_xmlns: *const xmlChar,
    pub str_xml_ns: *const xmlChar,
    pub sax2: std::os::raw::c_int,
    pub nsNr: std::os::raw::c_int,
    pub nsMax: std::os::raw::c_int,
    pub nsTab: *mut *const xmlChar,
    pub attallocs: *mut std::os::raw::c_int,
    pub pushTab: *mut *mut std::os::raw::c_void,
    pub attsDefault: xmlHashTablePtr,
    pub attsSpecial: xmlHashTablePtr,
    pub nsWellFormed: std::os::raw::c_int,
    pub options: std::os::raw::c_int,
    pub dictNames: std::os::raw::c_int,
    pub freeElemsNr: std::os::raw::c_int,
    pub freeElems: xmlNodePtr,
    pub freeAttrsNr: std::os::raw::c_int,
    pub freeAttrs: xmlAttrPtr,
    pub lastError: xmlError,
    pub parseMode: xmlParserMode,
    pub nbentities: std::os::raw::c_ulong,
    pub sizeentities: std::os::raw::c_ulong,
    pub nodeInfo: *mut xmlParserNodeInfo,
    pub nodeInfoNr: std::os::raw::c_int,
    pub nodeInfoMax: std::os::raw::c_int,
    pub nodeInfoTab: *mut xmlParserNodeInfo,
    pub input_id: std::os::raw::c_int,
    pub sizeentcopy: std::os::raw::c_ulong,
}
/* an unique identifier for the entity */
/* *
 * xmlParserNodeInfo:
 *
 * The parser can be asked to collect Node informations, i.e. at what
 * place in the file they were detected.
 * NOTE: This is off by default and not very well tested.
 */
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfo {
    pub node: *const _xmlNode,
    pub begin_pos: std::os::raw::c_ulong,
    pub begin_line: std::os::raw::c_ulong,
    pub end_pos: std::os::raw::c_ulong,
    pub end_line: std::os::raw::c_ulong,
}
/* The line number if attr is not available */
/* *
 * xmlNode:
 *
 * A node in an XML tree.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNode {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub content: *mut xmlChar,
    pub properties: *mut _xmlAttr,
    pub nsDef: *mut xmlNs,
    pub psvi: *mut std::os::raw::c_void,
    pub line: std::os::raw::c_ushort,
    pub extra: std::os::raw::c_ushort,
}
pub type xmlNs = _xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNs {
    pub next: *mut _xmlNs,
    pub type_0: xmlNsType,
    pub href: *const xmlChar,
    pub prefix: *const xmlChar,
    pub _private: *mut std::os::raw::c_void,
    pub context: *mut _xmlDoc,
}
/* *
 * xmlDoc:
 *
 * An XML document.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDoc {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *mut std::os::raw::c_char,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub compression: std::os::raw::c_int,
    pub standalone: std::os::raw::c_int,
    pub intSubset: *mut _xmlDtd,
    pub extSubset: *mut _xmlDtd,
    pub oldNs: *mut _xmlNs,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub ids: *mut std::os::raw::c_void,
    pub refs: *mut std::os::raw::c_void,
    pub URL: *const xmlChar,
    pub charset: std::os::raw::c_int,
    pub dict: *mut _xmlDict,
    pub psvi: *mut std::os::raw::c_void,
    pub parseFlags: std::os::raw::c_int,
    pub properties: std::os::raw::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDtd {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDoc,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub notations: *mut std::os::raw::c_void,
    pub elements: *mut std::os::raw::c_void,
    pub attributes: *mut std::os::raw::c_void,
    pub entities: *mut std::os::raw::c_void,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub pentities: *mut std::os::raw::c_void,
}
pub type xmlElementType = std::os::raw::c_uint;
pub const XML_DOCB_DOCUMENT_NODE: xmlElementType = 21;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
pub type xmlNsType = xmlElementType;
/* Hash table for param entities if any */
/* *
 * xmlAttr:
 *
 * An attribute on an XML node.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttr {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlAttr,
    pub prev: *mut _xmlAttr,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub atype: xmlAttributeType,
    pub psvi: *mut std::os::raw::c_void,
}
pub type xmlAttributeType = std::os::raw::c_uint;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = std::os::raw::c_uint;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
pub type xmlError = _xmlError;
/* *
 * xmlError:
 *
 * An XML Error instance.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlError {
    pub domain: std::os::raw::c_int,
    pub code: std::os::raw::c_int,
    pub message: *mut std::os::raw::c_char,
    pub level: xmlErrorLevel,
    pub file: *mut std::os::raw::c_char,
    pub line: std::os::raw::c_int,
    pub str1: *mut std::os::raw::c_char,
    pub str2: *mut std::os::raw::c_char,
    pub str3: *mut std::os::raw::c_char,
    pub int1: std::os::raw::c_int,
    pub int2: std::os::raw::c_int,
    pub ctxt: *mut std::os::raw::c_void,
    pub node: *mut std::os::raw::c_void,
}
pub type xmlErrorLevel = std::os::raw::c_uint;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
pub type xmlAttrPtr = *mut xmlAttr;
pub type xmlAttr = _xmlAttr;
pub type xmlNodePtr = *mut xmlNode;
pub type xmlNode = _xmlNode;
pub type xmlHashTablePtr = *mut xmlHashTable;
pub type xmlHashTable = _xmlHashTable;
pub type xmlDictPtr = *mut xmlDict;
pub type xmlDict = _xmlDict;
pub type xmlParserInputPtr = *mut xmlParserInput;
pub type xmlParserInput = _xmlParserInput;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInput {
    pub buf: xmlParserInputBufferPtr,
    pub filename: *const std::os::raw::c_char,
    pub directory: *const std::os::raw::c_char,
    pub base: *const xmlChar,
    pub cur: *const xmlChar,
    pub end: *const xmlChar,
    pub length: std::os::raw::c_int,
    pub line: std::os::raw::c_int,
    pub col: std::os::raw::c_int,
    pub consumed: std::os::raw::c_ulong,
    pub free: xmlParserInputDeallocate,
    pub encoding: *const xmlChar,
    pub version: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub id: std::os::raw::c_int,
}
/*
 * Summary: the core parser module
 * Description: Interfaces, constants and types related to the XML parser
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * XML_DEFAULT_VERSION:
 *
 * The default version of XML used: 1.0
 */
/* *
 * xmlParserInput:
 *
 * An xmlParserInput is an input flow for the XML processor.
 * Each entity parsed is associated an xmlParserInput (except the
 * few predefined ones). This is the case both for internal entities
 * - in which case the flow is already completely in memory - or
 * external entities - in which case we use the buf structure for
 * progressive reading and I18N conversions to the internal UTF-8 format.
 */
/* *
 * xmlParserInputDeallocate:
 * @str:  the string to deallocate
 *
 * Callback for freeing some parser input allocations.
 */
pub type xmlParserInputDeallocate
    =
    Option<unsafe extern "C" fn(_: *mut xmlChar) -> ()>;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInputBuffer {
    pub context: *mut std::os::raw::c_void,
    pub readcallback: xmlInputReadCallback,
    pub closecallback: xmlInputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub raw: xmlBufPtr,
    pub compressed: std::os::raw::c_int,
    pub error: std::os::raw::c_int,
    pub rawconsumed: std::os::raw::c_ulong,
}
pub type xmlBufPtr = *mut xmlBuf;
pub type xmlBuf = _xmlBuf;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
/* *
 * xmlCharEncodingInputFunc:
 * @out:  a pointer to an array of bytes to store the UTF-8 result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of chars in the original encoding
 * @inlen:  the length of @in
 *
 * Take a block of chars in the original encoding and try to convert
 * it to an UTF-8 block of chars out.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets consumed.
 */
/* *
 * xmlCharEncodingOutputFunc:
 * @out:  a pointer to an array of bytes to store the result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of UTF-8 chars
 * @inlen:  the length of @in
 *
 * Take a block of UTF-8 chars in and try to convert it to another
 * encoding.
 * Note: a first call designed to produce heading info is called with
 * in = NULL. If stateful this should also initialize the encoder state.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets produced.
 */
/*
 * Block defining the handlers for non UTF-8 encodings.
 * If iconv is supported, there are two extra fields.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlCharEncodingHandler {
    pub name: *mut std::os::raw::c_char,
    pub input: xmlCharEncodingInputFunc,
    pub output: xmlCharEncodingOutputFunc,
    pub iconv_in: iconv_t,
    pub iconv_out: iconv_t,
}
pub type iconv_t = *mut std::os::raw::c_void;
pub type xmlCharEncodingOutputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
pub type xmlCharEncodingInputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
pub type xmlInputCloseCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type xmlInputReadCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_char,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
pub type xmlParserInputState = std::os::raw::c_int;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
pub type xmlValidCtxt = _xmlValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlValidCtxt {
    pub userData: *mut std::os::raw::c_void,
    pub error: xmlValidityErrorFunc,
    pub warning: xmlValidityWarningFunc,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub finishDtd: std::os::raw::c_uint,
    pub doc: xmlDocPtr,
    pub valid: std::os::raw::c_int,
    pub vstate: *mut xmlValidState,
    pub vstateNr: std::os::raw::c_int,
    pub vstateMax: std::os::raw::c_int,
    pub vstateTab: *mut xmlValidState,
    pub am: xmlAutomataPtr,
    pub state: xmlAutomataStatePtr,
}
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataPtr = *mut xmlAutomata;
pub type xmlAutomata = _xmlAutomata;
pub type xmlValidState = _xmlValidState;
pub type xmlDocPtr = *mut xmlDoc;
pub type xmlDoc = _xmlDoc;
pub type xmlValidityWarningFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlValidityErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfoSeq {
    pub maximum: std::os::raw::c_ulong,
    pub length: std::os::raw::c_ulong,
    pub buffer: *mut xmlParserNodeInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandler {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: std::os::raw::c_uint,
    pub _private: *mut std::os::raw::c_void,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub serror: xmlStructuredErrorFunc,
}
pub type xmlStructuredErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlErrorPtr) -> ()>;
pub type xmlErrorPtr = *mut xmlError;
/* *
 * endElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 *
 * SAX2 callback when an element end has been detected by the parser.
 * It provides the namespace informations for the element.
 */
pub type endElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
/* ***********************************************************************
 *									*
 *			The SAX version 2 API extensions		*
 *									*
 ************************************************************************/
/* *
 * XML_SAX2_MAGIC:
 *
 * Special constant found in SAX2 blocks initialized fields
 */
/* *
 * startElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 * @nb_namespaces:  number of namespace definitions on that node
 * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
 * @nb_attributes:  the number of attributes on that node
 * @nb_defaulted:  the number of defaulted attributes. The defaulted
 *                  ones are at the end of the array
 * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
 *               attribute values.
 *
 * SAX2 callback when an element start has been detected by the parser.
 * It provides the namespace informations for the element, as well as
 * the new namespace declarations on the element.
 */
pub type startElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *mut *const xmlChar,
                                _: std::os::raw::c_int, _: std::os::raw::c_int,
                                _: *mut *const xmlChar) -> ()>;
/* *
 * externalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on external subset declaration.
 */
pub type externalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
/* *
 * cdataBlockSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  The pcdata content
 * @len:  the block length
 *
 * Called when a pcdata block has been parsed.
 */
pub type cdataBlockSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
/* *
 * getParameterEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get a parameter entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
pub type getParameterEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type xmlEntityPtr = *mut xmlEntity;
pub type xmlEntity = _xmlEntity;
/*
 * Summary: interface for the XML entities handling
 * Description: this module provides some of the entity API needed
 *              for the parser and applications.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * The different valid entity types.
 */
/*
 * An unit of storage for an entity, contains the string, the value
 * and the linkind data needed for the linking in the hash table.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEntity {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub orig: *mut xmlChar,
    pub content: *mut xmlChar,
    pub length: std::os::raw::c_int,
    pub etype: xmlEntityType,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub nexte: *mut _xmlEntity,
    pub URI: *const xmlChar,
    pub owner: std::os::raw::c_int,
    pub checked: std::os::raw::c_int,
}
pub type xmlEntityType = std::os::raw::c_uint;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
/* *
 * fatalErrorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format fatal error messages, callback.
 * Note: so far fatalError() SAX callbacks are not used, error()
 *       get all the callbacks for errors.
 */
pub type fatalErrorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
/* *
 * errorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format an error messages, callback.
 */
pub type errorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
/* *
 * warningSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format a warning messages, callback.
 */
pub type warningSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
/* *
 * commentSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  the comment content
 *
 * A comment has been parsed.
 */
pub type commentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
/* *
 * processingInstructionSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @target:  the target name
 * @data: the PI data's
 *
 * A processing instruction has been parsed.
 */
pub type processingInstructionSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
/* *
 * ignorableWhitespaceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some ignorable whitespaces from the parser.
 * UNUSED: by default the DOM building will use characters.
 */
pub type ignorableWhitespaceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
/* *
 * charactersSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some chars from the parser.
 */
pub type charactersSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
/* *
 * referenceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The entity name
 *
 * Called when an entity reference is detected.
 */
pub type referenceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
/* *
 * endElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name
 *
 * Called when the end of an element has been detected.
 */
pub type endElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
/* *
 * startElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name, including namespace prefix
 * @atts:  An array of name/value attributes pairs, NULL terminated
 *
 * Called when an opening tag has been processed.
 */
pub type startElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *mut *const xmlChar) -> ()>;
/* *
 * endDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document end has been detected.
 */
pub type endDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
/* *
 * startDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document start being processed.
 */
pub type startDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
/* *
 * setDocumentLocatorSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @loc: A SAX Locator
 *
 * Receive the document locator at startup, actually xmlDefaultSAXLocator.
 * Everything is available on the context, so this is useless in our case.
 */
pub type setDocumentLocatorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlSAXLocatorPtr)
               -> ()>;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXLocator = _xmlSAXLocator;
/* volume of entity copy */
/* *
 * xmlSAXLocator:
 *
 * A SAX Locator.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXLocator {
    pub getPublicId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getSystemId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getLineNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                  -> std::os::raw::c_int>,
    pub getColumnNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                    -> std::os::raw::c_int>,
}
/* *
 * unparsedEntityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the entity
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @notationName: the name of the notation
 *
 * What to do when an unparsed entity declaration is parsed.
 */
pub type unparsedEntityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
/* *
 * elementDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the element name
 * @type:  the element type
 * @content: the element value tree
 *
 * An element definition has been parsed.
 */
pub type elementDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: xmlElementContentPtr)
               -> ()>;
pub type xmlElementContentPtr = *mut xmlElementContent;
pub type xmlElementContent = _xmlElementContent;
/* Element holding the attribute */
/* *
 * xmlElementContentType:
 *
 * Possible definitions of element content types.
 */
/* *
 * xmlElementContentOccur:
 *
 * Possible definitions of element content occurrences.
 */
/* *
 * xmlElementContent:
 *
 * An XML Element content as stored after parsing an element definition
 * in a DTD.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElementContent {
    pub type_0: xmlElementContentType,
    pub ocur: xmlElementContentOccur,
    pub name: *const xmlChar,
    pub c1: *mut _xmlElementContent,
    pub c2: *mut _xmlElementContent,
    pub parent: *mut _xmlElementContent,
    pub prefix: *const xmlChar,
}
pub type xmlElementContentOccur = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
/* *
 * attributeDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @elem:  the name of the element
 * @fullname:  the attribute name
 * @type:  the attribute type
 * @def:  the type of default value
 * @defaultValue: the attribute default value
 * @tree:  the tree of enumerated value set
 *
 * An attribute definition has been parsed.
 */
pub type attributeDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: std::os::raw::c_int,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: xmlEnumerationPtr) -> ()>;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
pub type xmlEnumeration = _xmlEnumeration;
/* *
 * xmlEnumeration:
 *
 * List structure used when there is an enumeration in DTDs.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEnumeration {
    pub next: *mut _xmlEnumeration,
    pub name: *const xmlChar,
}
/* *
 * notationDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the notation
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * What to do when a notation declaration has been parsed.
 */
pub type notationDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
/* *
 * entityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the entity name
 * @type:  the entity type
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @content: the entity value (without processing).
 *
 * An entity definition has been parsed.
 */
pub type entityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: *const xmlChar, _: *mut xmlChar) -> ()>;
/* *
 * getEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get an entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
pub type getEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
/* *
 * xmlSAXHandler:
 *
 * A SAX handler is bunch of callbacks called by the parser when processing
 * of the input generate data or structure informations.
 */
/* *
 * resolveEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * Callback:
 * The entity loader, to control the loading of external entities,
 * the application can either:
 *    - override this resolveEntity() callback in the SAX block
 *    - or better use the xmlSetExternalEntityLoader() function to
 *      set up it's own entity resolution routine
 *
 * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
 */
pub type resolveEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlParserInputPtr>;
/* *
 * hasExternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an external subset?
 *
 * Returns 1 if true
 */
pub type hasExternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
/* *
 * hasInternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an internal subset.
 *
 * Returns 1 if true
 */
pub type hasInternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
/* *
 * isStandaloneSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Is this document tagged standalone?
 *
 * Returns 1 if true
 */
pub type isStandaloneSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
/* *
 * internalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on internal subset declaration.
 */
pub type internalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type xmlMallocFunc
    =
    Option<unsafe extern "C" fn(_: size_t) -> *mut std::os::raw::c_void>;
pub type size_t = std::os::raw::c_ulong;
pub type xmlReallocFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: size_t)
               -> *mut std::os::raw::c_void>;
pub type xmlGenericErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
/*
 * string.c : an XML string utilities module
 *
 * This module provides various utility functions for manipulating
 * the xmlChar* type. All functions named xmlStr* have been moved here
 * from the parser.c file (their original home).
 *
 * See Copyright for the status of this software.
 *
 * UTF8 string routines from:
 * William Brack <wbrack@mmm.com.hk>
 *
 * daniel@veillard.com
 */
/* ***********************************************************************
 *                                                                      *
 *                Commodity functions to handle xmlChars                *
 *                                                                      *
 ************************************************************************/
/* *
 * xmlStrndup:
 * @cur:  the input xmlChar *
 * @len:  the len of @cur
 *
 * a strndup for array of xmlChar's
 *
 * Returns a new xmlChar * or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrndup(mut cur: *const xmlChar,
                                    mut len: std::os::raw::c_int) -> *mut xmlChar {
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    if cur.is_null() || len < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    ret =
        xmlMallocAtomic.expect("non-null function pointer")(((len +
                                                                  1 as
                                                                      std::os::raw::c_int)
                                                                 as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if ret.is_null() {
        xmlErrMemory(0 as xmlParserCtxtPtr, 0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    memcpy(ret as *mut std::os::raw::c_void, cur as *const std::os::raw::c_void,
           (len as
                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                as std::os::raw::c_ulong));
    *ret.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
    return ret;
}
/* *
 * xmlStrdup:
 * @cur:  the input xmlChar *
 *
 * a strdup for array of xmlChar's. Since they are supposed to be
 * encoded in UTF-8 or an encoding with 8bit based chars, we assume
 * a termination mark of '0'.
 *
 * Returns a new xmlChar * or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrdup(mut cur: *const xmlChar) -> *mut xmlChar {
    let mut p: *const xmlChar = cur; /* non input consuming */
    if cur.is_null() { return 0 as *mut xmlChar }
    while *p as std::os::raw::c_int != 0 as std::os::raw::c_int { p = p.offset(1) }
    return xmlStrndup(cur,
                      p.offset_from(cur) as std::os::raw::c_long as
                          std::os::raw::c_int);
}
/* *
 * xmlCharStrndup:
 * @cur:  the input char *
 * @len:  the len of @cur
 *
 * a strndup for char's to xmlChar's
 *
 * Returns a new xmlChar * or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCharStrndup(mut cur: *const std::os::raw::c_char,
                                        mut len: std::os::raw::c_int)
 -> *mut xmlChar {
    let mut i: std::os::raw::c_int = 0;
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    if cur.is_null() || len < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    ret =
        xmlMallocAtomic.expect("non-null function pointer")(((len +
                                                                  1 as
                                                                      std::os::raw::c_int)
                                                                 as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if ret.is_null() {
        xmlErrMemory(0 as xmlParserCtxtPtr, 0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    i = 0 as std::os::raw::c_int;
    while i < len {
        *ret.offset(i as isize) = *cur.offset(i as isize) as xmlChar;
        if *ret.offset(i as isize) as std::os::raw::c_int == 0 as std::os::raw::c_int {
            return ret
        }
        i += 1
    }
    *ret.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
    return ret;
}
/* *
 * xmlCharStrdup:
 * @cur:  the input char *
 *
 * a strdup for char's to xmlChar's
 *
 * Returns a new xmlChar * or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCharStrdup(mut cur: *const std::os::raw::c_char)
 -> *mut xmlChar {
    let mut p: *const std::os::raw::c_char = cur; /* non input consuming */
    if cur.is_null() { return 0 as *mut xmlChar }
    while *p as std::os::raw::c_int != '\u{0}' as i32 { p = p.offset(1) }
    return xmlCharStrndup(cur,
                          p.offset_from(cur) as std::os::raw::c_long as
                              std::os::raw::c_int);
}
/* *
 * xmlStrcmp:
 * @str1:  the first xmlChar *
 * @str2:  the second xmlChar *
 *
 * a strcmp for xmlChar's
 *
 * Returns the integer result of the comparison
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrcmp(mut str1: *const xmlChar,
                                   mut str2: *const xmlChar) -> std::os::raw::c_int {
    let mut tmp: std::os::raw::c_int = 0;
    if str1 == str2 { return 0 as std::os::raw::c_int }
    if str1.is_null() { return -(1 as std::os::raw::c_int) }
    if str2.is_null() { return 1 as std::os::raw::c_int }
    loop  {
        let fresh0 = str1;
        str1 = str1.offset(1);
        tmp = *fresh0 as std::os::raw::c_int - *str2 as std::os::raw::c_int;
        if tmp != 0 as std::os::raw::c_int { return tmp }
        let fresh1 = str2;
        str2 = str2.offset(1);
        if !(*fresh1 as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlStrEqual:
 * @str1:  the first xmlChar *
 * @str2:  the second xmlChar *
 *
 * Check if both strings are equal of have same content.
 * Should be a bit more readable and faster than xmlStrcmp()
 *
 * Returns 1 if they are equal, 0 if they are different
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrEqual(mut str1: *const xmlChar,
                                     mut str2: *const xmlChar)
 -> std::os::raw::c_int {
    if str1 == str2 { return 1 as std::os::raw::c_int }
    if str1.is_null() { return 0 as std::os::raw::c_int }
    if str2.is_null() { return 0 as std::os::raw::c_int }
    loop  {
        let fresh2 = str1;
        str1 = str1.offset(1);
        if *fresh2 as std::os::raw::c_int != *str2 as std::os::raw::c_int {
            return 0 as std::os::raw::c_int
        }
        let fresh3 = str2;
        str2 = str2.offset(1);
        if !(*fresh3 != 0) { break ; }
    }
    return 1 as std::os::raw::c_int;
}
/* *
 * xmlStrQEqual:
 * @pref:  the prefix of the QName
 * @name:  the localname of the QName
 * @str:  the second xmlChar *
 *
 * Check if a QName is Equal to a given string
 *
 * Returns 1 if they are equal, 0 if they are different
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrQEqual(mut pref: *const xmlChar,
                                      mut name: *const xmlChar,
                                      mut str: *const xmlChar)
 -> std::os::raw::c_int {
    if pref.is_null() { return xmlStrEqual(name, str) }
    if name.is_null() { return 0 as std::os::raw::c_int }
    if str.is_null() { return 0 as std::os::raw::c_int }
    loop  {
        let fresh4 = pref;
        pref = pref.offset(1);
        if *fresh4 as std::os::raw::c_int != *str as std::os::raw::c_int {
            return 0 as std::os::raw::c_int
        }
        let fresh5 = str;
        str = str.offset(1);
        if !(*fresh5 as std::os::raw::c_int != 0 && *pref as std::os::raw::c_int != 0) {
            break ;
        }
    }
    let fresh6 = str;
    str = str.offset(1);
    if *fresh6 as std::os::raw::c_int != ':' as i32 { return 0 as std::os::raw::c_int }
    loop  {
        let fresh7 = name;
        name = name.offset(1);
        if *fresh7 as std::os::raw::c_int != *str as std::os::raw::c_int {
            return 0 as std::os::raw::c_int
        }
        let fresh8 = str;
        str = str.offset(1);
        if !(*fresh8 != 0) { break ; }
    }
    return 1 as std::os::raw::c_int;
}
/* *
 * xmlStrncmp:
 * @str1:  the first xmlChar *
 * @str2:  the second xmlChar *
 * @len:  the max comparison length
 *
 * a strncmp for xmlChar's
 *
 * Returns the integer result of the comparison
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrncmp(mut str1: *const xmlChar,
                                    mut str2: *const xmlChar,
                                    mut len: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut tmp: std::os::raw::c_int = 0;
    if len <= 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    if str1 == str2 { return 0 as std::os::raw::c_int }
    if str1.is_null() { return -(1 as std::os::raw::c_int) }
    if str2.is_null() { return 1 as std::os::raw::c_int }
    tmp =
        strncmp(str1 as *const std::os::raw::c_char, str2 as *const std::os::raw::c_char,
                len as std::os::raw::c_ulong);
    return tmp;
}
static mut casemap: [xmlChar; 256] =
    [0 as std::os::raw::c_int as xmlChar, 0x1 as std::os::raw::c_int as xmlChar,
     0x2 as std::os::raw::c_int as xmlChar, 0x3 as std::os::raw::c_int as xmlChar,
     0x4 as std::os::raw::c_int as xmlChar, 0x5 as std::os::raw::c_int as xmlChar,
     0x6 as std::os::raw::c_int as xmlChar, 0x7 as std::os::raw::c_int as xmlChar,
     0x8 as std::os::raw::c_int as xmlChar, 0x9 as std::os::raw::c_int as xmlChar,
     0xa as std::os::raw::c_int as xmlChar, 0xb as std::os::raw::c_int as xmlChar,
     0xc as std::os::raw::c_int as xmlChar, 0xd as std::os::raw::c_int as xmlChar,
     0xe as std::os::raw::c_int as xmlChar, 0xf as std::os::raw::c_int as xmlChar,
     0x10 as std::os::raw::c_int as xmlChar, 0x11 as std::os::raw::c_int as xmlChar,
     0x12 as std::os::raw::c_int as xmlChar, 0x13 as std::os::raw::c_int as xmlChar,
     0x14 as std::os::raw::c_int as xmlChar, 0x15 as std::os::raw::c_int as xmlChar,
     0x16 as std::os::raw::c_int as xmlChar, 0x17 as std::os::raw::c_int as xmlChar,
     0x18 as std::os::raw::c_int as xmlChar, 0x19 as std::os::raw::c_int as xmlChar,
     0x1a as std::os::raw::c_int as xmlChar, 0x1b as std::os::raw::c_int as xmlChar,
     0x1c as std::os::raw::c_int as xmlChar, 0x1d as std::os::raw::c_int as xmlChar,
     0x1e as std::os::raw::c_int as xmlChar, 0x1f as std::os::raw::c_int as xmlChar,
     0x20 as std::os::raw::c_int as xmlChar, 0x21 as std::os::raw::c_int as xmlChar,
     0x22 as std::os::raw::c_int as xmlChar, 0x23 as std::os::raw::c_int as xmlChar,
     0x24 as std::os::raw::c_int as xmlChar, 0x25 as std::os::raw::c_int as xmlChar,
     0x26 as std::os::raw::c_int as xmlChar, 0x27 as std::os::raw::c_int as xmlChar,
     0x28 as std::os::raw::c_int as xmlChar, 0x29 as std::os::raw::c_int as xmlChar,
     0x2a as std::os::raw::c_int as xmlChar, 0x2b as std::os::raw::c_int as xmlChar,
     0x2c as std::os::raw::c_int as xmlChar, 0x2d as std::os::raw::c_int as xmlChar,
     0x2e as std::os::raw::c_int as xmlChar, 0x2f as std::os::raw::c_int as xmlChar,
     0x30 as std::os::raw::c_int as xmlChar, 0x31 as std::os::raw::c_int as xmlChar,
     0x32 as std::os::raw::c_int as xmlChar, 0x33 as std::os::raw::c_int as xmlChar,
     0x34 as std::os::raw::c_int as xmlChar, 0x35 as std::os::raw::c_int as xmlChar,
     0x36 as std::os::raw::c_int as xmlChar, 0x37 as std::os::raw::c_int as xmlChar,
     0x38 as std::os::raw::c_int as xmlChar, 0x39 as std::os::raw::c_int as xmlChar,
     0x3a as std::os::raw::c_int as xmlChar, 0x3b as std::os::raw::c_int as xmlChar,
     0x3c as std::os::raw::c_int as xmlChar, 0x3d as std::os::raw::c_int as xmlChar,
     0x3e as std::os::raw::c_int as xmlChar, 0x3f as std::os::raw::c_int as xmlChar,
     0x40 as std::os::raw::c_int as xmlChar, 0x61 as std::os::raw::c_int as xmlChar,
     0x62 as std::os::raw::c_int as xmlChar, 0x63 as std::os::raw::c_int as xmlChar,
     0x64 as std::os::raw::c_int as xmlChar, 0x65 as std::os::raw::c_int as xmlChar,
     0x66 as std::os::raw::c_int as xmlChar, 0x67 as std::os::raw::c_int as xmlChar,
     0x68 as std::os::raw::c_int as xmlChar, 0x69 as std::os::raw::c_int as xmlChar,
     0x6a as std::os::raw::c_int as xmlChar, 0x6b as std::os::raw::c_int as xmlChar,
     0x6c as std::os::raw::c_int as xmlChar, 0x6d as std::os::raw::c_int as xmlChar,
     0x6e as std::os::raw::c_int as xmlChar, 0x6f as std::os::raw::c_int as xmlChar,
     0x70 as std::os::raw::c_int as xmlChar, 0x71 as std::os::raw::c_int as xmlChar,
     0x72 as std::os::raw::c_int as xmlChar, 0x73 as std::os::raw::c_int as xmlChar,
     0x74 as std::os::raw::c_int as xmlChar, 0x75 as std::os::raw::c_int as xmlChar,
     0x76 as std::os::raw::c_int as xmlChar, 0x77 as std::os::raw::c_int as xmlChar,
     0x78 as std::os::raw::c_int as xmlChar, 0x79 as std::os::raw::c_int as xmlChar,
     0x7a as std::os::raw::c_int as xmlChar, 0x7b as std::os::raw::c_int as xmlChar,
     0x5c as std::os::raw::c_int as xmlChar, 0x5d as std::os::raw::c_int as xmlChar,
     0x5e as std::os::raw::c_int as xmlChar, 0x5f as std::os::raw::c_int as xmlChar,
     0x60 as std::os::raw::c_int as xmlChar, 0x61 as std::os::raw::c_int as xmlChar,
     0x62 as std::os::raw::c_int as xmlChar, 0x63 as std::os::raw::c_int as xmlChar,
     0x64 as std::os::raw::c_int as xmlChar, 0x65 as std::os::raw::c_int as xmlChar,
     0x66 as std::os::raw::c_int as xmlChar, 0x67 as std::os::raw::c_int as xmlChar,
     0x68 as std::os::raw::c_int as xmlChar, 0x69 as std::os::raw::c_int as xmlChar,
     0x6a as std::os::raw::c_int as xmlChar, 0x6b as std::os::raw::c_int as xmlChar,
     0x6c as std::os::raw::c_int as xmlChar, 0x6d as std::os::raw::c_int as xmlChar,
     0x6e as std::os::raw::c_int as xmlChar, 0x6f as std::os::raw::c_int as xmlChar,
     0x70 as std::os::raw::c_int as xmlChar, 0x71 as std::os::raw::c_int as xmlChar,
     0x72 as std::os::raw::c_int as xmlChar, 0x73 as std::os::raw::c_int as xmlChar,
     0x74 as std::os::raw::c_int as xmlChar, 0x75 as std::os::raw::c_int as xmlChar,
     0x76 as std::os::raw::c_int as xmlChar, 0x77 as std::os::raw::c_int as xmlChar,
     0x78 as std::os::raw::c_int as xmlChar, 0x79 as std::os::raw::c_int as xmlChar,
     0x7a as std::os::raw::c_int as xmlChar, 0x7b as std::os::raw::c_int as xmlChar,
     0x7c as std::os::raw::c_int as xmlChar, 0x7d as std::os::raw::c_int as xmlChar,
     0x7e as std::os::raw::c_int as xmlChar, 0x7f as std::os::raw::c_int as xmlChar,
     0x80 as std::os::raw::c_int as xmlChar, 0x81 as std::os::raw::c_int as xmlChar,
     0x82 as std::os::raw::c_int as xmlChar, 0x83 as std::os::raw::c_int as xmlChar,
     0x84 as std::os::raw::c_int as xmlChar, 0x85 as std::os::raw::c_int as xmlChar,
     0x86 as std::os::raw::c_int as xmlChar, 0x87 as std::os::raw::c_int as xmlChar,
     0x88 as std::os::raw::c_int as xmlChar, 0x89 as std::os::raw::c_int as xmlChar,
     0x8a as std::os::raw::c_int as xmlChar, 0x8b as std::os::raw::c_int as xmlChar,
     0x8c as std::os::raw::c_int as xmlChar, 0x8d as std::os::raw::c_int as xmlChar,
     0x8e as std::os::raw::c_int as xmlChar, 0x8f as std::os::raw::c_int as xmlChar,
     0x90 as std::os::raw::c_int as xmlChar, 0x91 as std::os::raw::c_int as xmlChar,
     0x92 as std::os::raw::c_int as xmlChar, 0x93 as std::os::raw::c_int as xmlChar,
     0x94 as std::os::raw::c_int as xmlChar, 0x95 as std::os::raw::c_int as xmlChar,
     0x96 as std::os::raw::c_int as xmlChar, 0x97 as std::os::raw::c_int as xmlChar,
     0x98 as std::os::raw::c_int as xmlChar, 0x99 as std::os::raw::c_int as xmlChar,
     0x9a as std::os::raw::c_int as xmlChar, 0x9b as std::os::raw::c_int as xmlChar,
     0x9c as std::os::raw::c_int as xmlChar, 0x9d as std::os::raw::c_int as xmlChar,
     0x9e as std::os::raw::c_int as xmlChar, 0x9f as std::os::raw::c_int as xmlChar,
     0xa0 as std::os::raw::c_int as xmlChar, 0xa1 as std::os::raw::c_int as xmlChar,
     0xa2 as std::os::raw::c_int as xmlChar, 0xa3 as std::os::raw::c_int as xmlChar,
     0xa4 as std::os::raw::c_int as xmlChar, 0xa5 as std::os::raw::c_int as xmlChar,
     0xa6 as std::os::raw::c_int as xmlChar, 0xa7 as std::os::raw::c_int as xmlChar,
     0xa8 as std::os::raw::c_int as xmlChar, 0xa9 as std::os::raw::c_int as xmlChar,
     0xaa as std::os::raw::c_int as xmlChar, 0xab as std::os::raw::c_int as xmlChar,
     0xac as std::os::raw::c_int as xmlChar, 0xad as std::os::raw::c_int as xmlChar,
     0xae as std::os::raw::c_int as xmlChar, 0xaf as std::os::raw::c_int as xmlChar,
     0xb0 as std::os::raw::c_int as xmlChar, 0xb1 as std::os::raw::c_int as xmlChar,
     0xb2 as std::os::raw::c_int as xmlChar, 0xb3 as std::os::raw::c_int as xmlChar,
     0xb4 as std::os::raw::c_int as xmlChar, 0xb5 as std::os::raw::c_int as xmlChar,
     0xb6 as std::os::raw::c_int as xmlChar, 0xb7 as std::os::raw::c_int as xmlChar,
     0xb8 as std::os::raw::c_int as xmlChar, 0xb9 as std::os::raw::c_int as xmlChar,
     0xba as std::os::raw::c_int as xmlChar, 0xbb as std::os::raw::c_int as xmlChar,
     0xbc as std::os::raw::c_int as xmlChar, 0xbd as std::os::raw::c_int as xmlChar,
     0xbe as std::os::raw::c_int as xmlChar, 0xbf as std::os::raw::c_int as xmlChar,
     0xc0 as std::os::raw::c_int as xmlChar, 0xc1 as std::os::raw::c_int as xmlChar,
     0xc2 as std::os::raw::c_int as xmlChar, 0xc3 as std::os::raw::c_int as xmlChar,
     0xc4 as std::os::raw::c_int as xmlChar, 0xc5 as std::os::raw::c_int as xmlChar,
     0xc6 as std::os::raw::c_int as xmlChar, 0xc7 as std::os::raw::c_int as xmlChar,
     0xc8 as std::os::raw::c_int as xmlChar, 0xc9 as std::os::raw::c_int as xmlChar,
     0xca as std::os::raw::c_int as xmlChar, 0xcb as std::os::raw::c_int as xmlChar,
     0xcc as std::os::raw::c_int as xmlChar, 0xcd as std::os::raw::c_int as xmlChar,
     0xce as std::os::raw::c_int as xmlChar, 0xcf as std::os::raw::c_int as xmlChar,
     0xd0 as std::os::raw::c_int as xmlChar, 0xd1 as std::os::raw::c_int as xmlChar,
     0xd2 as std::os::raw::c_int as xmlChar, 0xd3 as std::os::raw::c_int as xmlChar,
     0xd4 as std::os::raw::c_int as xmlChar, 0xd5 as std::os::raw::c_int as xmlChar,
     0xd6 as std::os::raw::c_int as xmlChar, 0xd7 as std::os::raw::c_int as xmlChar,
     0xd8 as std::os::raw::c_int as xmlChar, 0xd9 as std::os::raw::c_int as xmlChar,
     0xda as std::os::raw::c_int as xmlChar, 0xdb as std::os::raw::c_int as xmlChar,
     0xdc as std::os::raw::c_int as xmlChar, 0xdd as std::os::raw::c_int as xmlChar,
     0xde as std::os::raw::c_int as xmlChar, 0xdf as std::os::raw::c_int as xmlChar,
     0xe0 as std::os::raw::c_int as xmlChar, 0xe1 as std::os::raw::c_int as xmlChar,
     0xe2 as std::os::raw::c_int as xmlChar, 0xe3 as std::os::raw::c_int as xmlChar,
     0xe4 as std::os::raw::c_int as xmlChar, 0xe5 as std::os::raw::c_int as xmlChar,
     0xe6 as std::os::raw::c_int as xmlChar, 0xe7 as std::os::raw::c_int as xmlChar,
     0xe8 as std::os::raw::c_int as xmlChar, 0xe9 as std::os::raw::c_int as xmlChar,
     0xea as std::os::raw::c_int as xmlChar, 0xeb as std::os::raw::c_int as xmlChar,
     0xec as std::os::raw::c_int as xmlChar, 0xed as std::os::raw::c_int as xmlChar,
     0xee as std::os::raw::c_int as xmlChar, 0xef as std::os::raw::c_int as xmlChar,
     0xf0 as std::os::raw::c_int as xmlChar, 0xf1 as std::os::raw::c_int as xmlChar,
     0xf2 as std::os::raw::c_int as xmlChar, 0xf3 as std::os::raw::c_int as xmlChar,
     0xf4 as std::os::raw::c_int as xmlChar, 0xf5 as std::os::raw::c_int as xmlChar,
     0xf6 as std::os::raw::c_int as xmlChar, 0xf7 as std::os::raw::c_int as xmlChar,
     0xf8 as std::os::raw::c_int as xmlChar, 0xf9 as std::os::raw::c_int as xmlChar,
     0xfa as std::os::raw::c_int as xmlChar, 0xfb as std::os::raw::c_int as xmlChar,
     0xfc as std::os::raw::c_int as xmlChar, 0xfd as std::os::raw::c_int as xmlChar,
     0xfe as std::os::raw::c_int as xmlChar, 0xff as std::os::raw::c_int as xmlChar];
/* *
 * xmlStrcasecmp:
 * @str1:  the first xmlChar *
 * @str2:  the second xmlChar *
 *
 * a strcasecmp for xmlChar's
 *
 * Returns the integer result of the comparison
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrcasecmp(mut str1: *const xmlChar,
                                       mut str2: *const xmlChar)
 -> std::os::raw::c_int {
    let mut tmp: std::os::raw::c_int = 0;
    if str1 == str2 { return 0 as std::os::raw::c_int }
    if str1.is_null() { return -(1 as std::os::raw::c_int) }
    if str2.is_null() { return 1 as std::os::raw::c_int }
    loop  {
        let fresh9 = str1;
        str1 = str1.offset(1);
        tmp =
            casemap[*fresh9 as usize] as std::os::raw::c_int -
                casemap[*str2 as usize] as std::os::raw::c_int;
        if tmp != 0 as std::os::raw::c_int { return tmp }
        let fresh10 = str2;
        str2 = str2.offset(1);
        if !(*fresh10 as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlStrncasecmp:
 * @str1:  the first xmlChar *
 * @str2:  the second xmlChar *
 * @len:  the max comparison length
 *
 * a strncasecmp for xmlChar's
 *
 * Returns the integer result of the comparison
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrncasecmp(mut str1: *const xmlChar,
                                        mut str2: *const xmlChar,
                                        mut len: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut tmp: std::os::raw::c_int = 0;
    if len <= 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    if str1 == str2 { return 0 as std::os::raw::c_int }
    if str1.is_null() { return -(1 as std::os::raw::c_int) }
    if str2.is_null() { return 1 as std::os::raw::c_int }
    loop  {
        let fresh11 = str1;
        str1 = str1.offset(1);
        tmp =
            casemap[*fresh11 as usize] as std::os::raw::c_int -
                casemap[*str2 as usize] as std::os::raw::c_int;
        if tmp != 0 as std::os::raw::c_int || { len -= 1; (len) == 0 as std::os::raw::c_int }
           {
            return tmp
        }
        let fresh12 = str2;
        str2 = str2.offset(1);
        if !(*fresh12 as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlStrchr:
 * @str:  the xmlChar * array
 * @val:  the xmlChar to search
 *
 * a strchr for xmlChar's
 *
 * Returns the xmlChar * for the first occurrence or NULL.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrchr(mut str: *const xmlChar, mut val: xmlChar)
 -> *const xmlChar {
    if str.is_null() { return 0 as *const xmlChar }
    while *str as std::os::raw::c_int != 0 as std::os::raw::c_int {
        /* non input consuming */
        if *str as std::os::raw::c_int == val as std::os::raw::c_int {
            return str as *mut xmlChar
        }
        str = str.offset(1)
    }
    return 0 as *const xmlChar;
}
/* *
 * xmlStrstr:
 * @str:  the xmlChar * array (haystack)
 * @val:  the xmlChar to search (needle)
 *
 * a strstr for xmlChar's
 *
 * Returns the xmlChar * for the first occurrence or NULL.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrstr(mut str: *const xmlChar,
                                   mut val: *const xmlChar)
 -> *const xmlChar {
    let mut n: std::os::raw::c_int = 0;
    if str.is_null() { return 0 as *const xmlChar }
    if val.is_null() { return 0 as *const xmlChar }
    n = xmlStrlen(val);
    if n == 0 as std::os::raw::c_int { return str }
    while *str as std::os::raw::c_int != 0 as std::os::raw::c_int {
        /* non input consuming */
        if *str as std::os::raw::c_int == *val as std::os::raw::c_int {
            if xmlStrncmp(str, val, n) == 0 { return str }
        }
        str = str.offset(1)
    }
    return 0 as *const xmlChar;
}
/* *
 * xmlStrcasestr:
 * @str:  the xmlChar * array (haystack)
 * @val:  the xmlChar to search (needle)
 *
 * a case-ignoring strstr for xmlChar's
 *
 * Returns the xmlChar * for the first occurrence or NULL.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrcasestr(mut str: *const xmlChar,
                                       mut val: *const xmlChar)
 -> *const xmlChar {
    let mut n: std::os::raw::c_int = 0;
    if str.is_null() { return 0 as *const xmlChar }
    if val.is_null() { return 0 as *const xmlChar }
    n = xmlStrlen(val);
    if n == 0 as std::os::raw::c_int { return str }
    while *str as std::os::raw::c_int != 0 as std::os::raw::c_int {
        /* non input consuming */
        if casemap[*str as usize] as std::os::raw::c_int ==
               casemap[*val as usize] as std::os::raw::c_int {
            if xmlStrncasecmp(str, val, n) == 0 { return str }
        }
        str = str.offset(1)
    }
    return 0 as *const xmlChar;
}
/* *
 * xmlStrsub:
 * @str:  the xmlChar * array (haystack)
 * @start:  the index of the first char (zero based)
 * @len:  the length of the substring
 *
 * Extract a substring of a given string
 *
 * Returns the xmlChar * for the first occurrence or NULL.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrsub(mut str: *const xmlChar,
                                   mut start: std::os::raw::c_int,
                                   mut len: std::os::raw::c_int) -> *mut xmlChar {
    let mut i: std::os::raw::c_int = 0;
    if str.is_null() { return 0 as *mut xmlChar }
    if start < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    if len < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    i = 0 as std::os::raw::c_int;
    while i < start {
        if *str as std::os::raw::c_int == 0 as std::os::raw::c_int {
            return 0 as *mut xmlChar
        }
        str = str.offset(1);
        i += 1
    }
    if *str as std::os::raw::c_int == 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    return xmlStrndup(str, len);
}
/* *
 * xmlStrlen:
 * @str:  the xmlChar * array
 *
 * length of a xmlChar's string
 *
 * Returns the number of xmlChar contained in the ARRAY.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrlen(mut str: *const xmlChar) -> std::os::raw::c_int {
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if str.is_null() { return 0 as std::os::raw::c_int }
    while *str as std::os::raw::c_int != 0 as std::os::raw::c_int {
        /* non input consuming */
        str = str.offset(1);
        len += 1
    }
    return len;
}
/* *
 * xmlStrncat:
 * @cur:  the original xmlChar * array
 * @add:  the xmlChar * array added
 * @len:  the length of @add
 *
 * a strncat for array of xmlChar's, it will extend @cur with the len
 * first bytes of @add. Note that if @len < 0 then this is an API error
 * and NULL will be returned.
 *
 * Returns a new xmlChar *, the original @cur is reallocated and should
 * not be freed.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrncat(mut cur: *mut xmlChar,
                                    mut add: *const xmlChar,
                                    mut len: std::os::raw::c_int) -> *mut xmlChar {
    let mut size: std::os::raw::c_int = 0;
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    if add.is_null() || len == 0 as std::os::raw::c_int { return cur }
    if len < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    if cur.is_null() { return xmlStrndup(add, len) }
    size = xmlStrlen(cur);
    if size < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    ret =
        xmlRealloc.expect("non-null function pointer")(cur as
                                                           *mut std::os::raw::c_void,
                                                       ((size + len +
                                                             1 as std::os::raw::c_int)
                                                            as
                                                            std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                            as
                                                                                            std::os::raw::c_ulong))
            as *mut xmlChar;
    if ret.is_null() {
        xmlErrMemory(0 as xmlParserCtxtPtr, 0 as *const std::os::raw::c_char);
        return cur
    }
    memcpy(&mut *ret.offset(size as isize) as *mut xmlChar as
               *mut std::os::raw::c_void, add as *const std::os::raw::c_void,
           (len as
                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                as std::os::raw::c_ulong));
    *ret.offset((size + len) as isize) = 0 as std::os::raw::c_int as xmlChar;
    return ret;
}
/* *
 * xmlStrncatNew:
 * @str1:  first xmlChar string
 * @str2:  second xmlChar string
 * @len:  the len of @str2 or < 0
 *
 * same as xmlStrncat, but creates a new string.  The original
 * two strings are not freed. If @len is < 0 then the length
 * will be calculated automatically.
 *
 * Returns a new xmlChar * or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrncatNew(mut str1: *const xmlChar,
                                       mut str2: *const xmlChar,
                                       mut len: std::os::raw::c_int) -> *mut xmlChar {
    let mut size: std::os::raw::c_int = 0;
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    if len < 0 as std::os::raw::c_int {
        len = xmlStrlen(str2);
        if len < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    }
    if str2.is_null() || len == 0 as std::os::raw::c_int { return xmlStrdup(str1) }
    if str1.is_null() { return xmlStrndup(str2, len) }
    size = xmlStrlen(str1);
    if size < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    ret =
        xmlMalloc.expect("non-null function pointer")(((size + len +
                                                            1 as std::os::raw::c_int)
                                                           as
                                                           std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                           as
                                                                                           std::os::raw::c_ulong))
            as *mut xmlChar;
    if ret.is_null() {
        xmlErrMemory(0 as xmlParserCtxtPtr, 0 as *const std::os::raw::c_char);
        return xmlStrndup(str1, size)
    }
    memcpy(ret as *mut std::os::raw::c_void, str1 as *const std::os::raw::c_void,
           (size as
                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                as std::os::raw::c_ulong));
    memcpy(&mut *ret.offset(size as isize) as *mut xmlChar as
               *mut std::os::raw::c_void, str2 as *const std::os::raw::c_void,
           (len as
                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                as std::os::raw::c_ulong));
    *ret.offset((size + len) as isize) = 0 as std::os::raw::c_int as xmlChar;
    return ret;
}
/* *
 * xmlStrcat:
 * @cur:  the original xmlChar * array
 * @add:  the xmlChar * array added
 *
 * a strcat for array of xmlChar's. Since they are supposed to be
 * encoded in UTF-8 or an encoding with 8bit based chars, we assume
 * a termination mark of '0'.
 *
 * Returns a new xmlChar * containing the concatenated string. The original
 * @cur is reallocated and should not be freed.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrcat(mut cur: *mut xmlChar,
                                   mut add: *const xmlChar) -> *mut xmlChar {
    let mut p: *const xmlChar = add; /* non input consuming */
    if add.is_null() { return cur }
    if cur.is_null() { return xmlStrdup(add) }
    while *p as std::os::raw::c_int != 0 as std::os::raw::c_int { p = p.offset(1) }
    return xmlStrncat(cur, add,
                      p.offset_from(add) as std::os::raw::c_long as
                          std::os::raw::c_int);
}
/* *
 * xmlStrPrintf:
 * @buf:   the result buffer.
 * @len:   the result buffer length.
 * @msg:   the message with printf formatting.
 * @...:   extra parameters for the message.
 *
 * Formats @msg and places result into @buf.
 *
 * Returns the number of characters written to @buf or -1 if an error occurs.
 */
// int XMLCDECL
// xmlStrPrintf(xmlChar *buf, int len, const char *msg, ...) {
//     va_list args;
//     int ret;
//     if((buf == NULL) || (msg == NULL)) {
//         return(-1);
//     }
//     va_start(args, msg);
//     ret = vsnprintf((char *) buf, len, (const char *) msg, args);
//     va_end(args);
//     buf[len - 1] = 0; /* be safe ! */
//     return(ret);
// }
/* *
 * xmlStrVPrintf:
 * @buf:   the result buffer.
 * @len:   the result buffer length.
 * @msg:   the message with printf formatting.
 * @ap:    extra parameters for the message.
 *
 * Formats @msg and places result into @buf.
 *
 * Returns the number of characters written to @buf or -1 if an error occurs.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStrVPrintf(mut buf: *mut xmlChar,
                                       mut len: std::os::raw::c_int,
                                       mut msg: *const std::os::raw::c_char,
                                       mut ap: ::std::ffi::VaList)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0; /* be safe ! */
    if buf.is_null() || msg.is_null() { return -(1 as std::os::raw::c_int) }
    ret =
        vsnprintf(buf as *mut std::os::raw::c_char, len as std::os::raw::c_ulong, msg,
                  ap.as_va_list());
    *buf.offset((len - 1 as std::os::raw::c_int) as isize) =
        0 as std::os::raw::c_int as xmlChar;
    return ret;
}
/* ***********************************************************************
 *                                                                      *
 *              Generic UTF8 handling routines                          *
 *                                                                      *
 * From rfc2044: encoding of the Unicode values on UTF-8:               *
 *                                                                      *
 * UCS-4 range (hex.)           UTF-8 octet sequence (binary)           *
 * 0000 0000-0000 007F   0xxxxxxx                                       *
 * 0000 0080-0000 07FF   110xxxxx 10xxxxxx                              *
 * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx                     *
 *                                                                      *
 * I hope we won't use values > 0xFFFF anytime soon !                   *
 *                                                                      *
 ************************************************************************/
/* *
 * xmlUTF8Size:
 * @utf: pointer to the UTF8 character
 *
 * calculates the internal size of a UTF8 character
 *
 * returns the numbers of bytes in the character, -1 on format error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlUTF8Size(mut utf: *const xmlChar) -> std::os::raw::c_int {
    let mut mask: xmlChar = 0;
    let mut len: std::os::raw::c_int = 0;
    if utf.is_null() { return -(1 as std::os::raw::c_int) }
    if (*utf as std::os::raw::c_int) < 0x80 as std::os::raw::c_int { return 1 as std::os::raw::c_int }
    /* check valid UTF8 character */
    if *utf as std::os::raw::c_int & 0x40 as std::os::raw::c_int == 0 {
        return -(1 as std::os::raw::c_int)
    }
    /* determine number of bytes in char */
    len = 2 as std::os::raw::c_int;
    mask = 0x20 as std::os::raw::c_int as xmlChar;
    while mask as std::os::raw::c_int != 0 as std::os::raw::c_int {
        if *utf as std::os::raw::c_int & mask as std::os::raw::c_int == 0 { return len }
        len += 1;
        mask = (mask as std::os::raw::c_int >> 1 as std::os::raw::c_int) as xmlChar
    }
    return -(1 as std::os::raw::c_int);
}
/* *
 * xmlUTF8Charcmp:
 * @utf1: pointer to first UTF8 char
 * @utf2: pointer to second UTF8 char
 *
 * compares the two UCS4 values
 *
 * returns result of the compare as with xmlStrncmp
 */
#[no_mangle]
pub unsafe extern "C" fn xmlUTF8Charcmp(mut utf1: *const xmlChar,
                                        mut utf2: *const xmlChar)
 -> std::os::raw::c_int {
    if utf1.is_null() {
        if utf2.is_null() { return 0 as std::os::raw::c_int }
        return -(1 as std::os::raw::c_int)
    }
    return xmlStrncmp(utf1, utf2, xmlUTF8Size(utf1));
}
/* *
 * xmlUTF8Strlen:
 * @utf:  a sequence of UTF-8 encoded bytes
 *
 * compute the length of an UTF8 string, it doesn't do a full UTF8
 * checking of the content of the string.
 *
 * Returns the number of characters in the string or -1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlUTF8Strlen(mut utf: *const xmlChar)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if utf.is_null() { return -(1 as std::os::raw::c_int) }
    while *utf as std::os::raw::c_int != 0 as std::os::raw::c_int {
        if *utf.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int &
               0x80 as std::os::raw::c_int != 0 {
            if *utf.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int &
                   0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int {
                return -(1 as std::os::raw::c_int)
            }
            if *utf.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int &
                   0xe0 as std::os::raw::c_int == 0xe0 as std::os::raw::c_int {
                if *utf.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int &
                       0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int {
                    return -(1 as std::os::raw::c_int)
                }
                if *utf.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int &
                       0xf0 as std::os::raw::c_int == 0xf0 as std::os::raw::c_int {
                    if *utf.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int &
                           0xf8 as std::os::raw::c_int != 0xf0 as std::os::raw::c_int ||
                           *utf.offset(3 as std::os::raw::c_int as isize) as
                               std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                               0x80 as std::os::raw::c_int {
                        return -(1 as std::os::raw::c_int)
                    }
                    utf = utf.offset(4 as std::os::raw::c_int as isize)
                } else { utf = utf.offset(3 as std::os::raw::c_int as isize) }
            } else { utf = utf.offset(2 as std::os::raw::c_int as isize) }
        } else { utf = utf.offset(1) }
        ret += 1
    }
    return ret;
}
/* *
 * xmlGetUTF8Char:
 * @utf:  a sequence of UTF-8 encoded bytes
 * @len:  a pointer to the minimum number of bytes present in
 *        the sequence.  This is used to assure the next character
 *        is completely contained within the sequence.
 *
 * Read the first UTF8 character from @utf
 *
 * Returns the char value or -1 in case of error, and sets *len to
 *        the actual number of bytes consumed (0 in case of error)
 */
#[no_mangle]
pub unsafe extern "C" fn xmlGetUTF8Char(mut utf: *const std::os::raw::c_uchar,
                                        mut len: *mut std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut c: std::os::raw::c_uint = 0;
    if !utf.is_null() {
        if !len.is_null() {
            if !(*len < 1 as std::os::raw::c_int) {
                c = *utf.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_uint;
                if c & 0x80 as std::os::raw::c_int as std::os::raw::c_uint != 0 {
                    if *len < 2 as std::os::raw::c_int {
                        current_block = 606673952348435995;
                    } else if *utf.offset(1 as std::os::raw::c_int as isize) as
                                  std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                                  0x80 as std::os::raw::c_int {
                        current_block = 606673952348435995;
                    } else if c & 0xe0 as std::os::raw::c_int as std::os::raw::c_uint ==
                                  0xe0 as std::os::raw::c_int as std::os::raw::c_uint {
                        if *len < 3 as std::os::raw::c_int {
                            current_block = 606673952348435995;
                        } else if *utf.offset(2 as std::os::raw::c_int as isize) as
                                      std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                                      0x80 as std::os::raw::c_int {
                            current_block = 606673952348435995;
                        } else if c & 0xf0 as std::os::raw::c_int as std::os::raw::c_uint ==
                                      0xf0 as std::os::raw::c_int as std::os::raw::c_uint {
                            if *len < 4 as std::os::raw::c_int {
                                current_block = 606673952348435995;
                            } else if c & 0xf8 as std::os::raw::c_int as std::os::raw::c_uint
                                          !=
                                          0xf0 as std::os::raw::c_int as std::os::raw::c_uint
                                          ||
                                          *utf.offset(3 as std::os::raw::c_int as
                                                          isize) as
                                              std::os::raw::c_int &
                                              0xc0 as std::os::raw::c_int !=
                                              0x80 as std::os::raw::c_int {
                                current_block = 606673952348435995;
                            } else {
                                *len = 4 as std::os::raw::c_int;
                                /* 4-byte code */
                                c =
                                    ((*utf.offset(0 as std::os::raw::c_int as isize)
                                          as std::os::raw::c_int & 0x7 as std::os::raw::c_int)
                                         << 18 as std::os::raw::c_int) as
                                        std::os::raw::c_uint;
                                c |=
                                    ((*utf.offset(1 as std::os::raw::c_int as isize)
                                          as std::os::raw::c_int &
                                          0x3f as std::os::raw::c_int) <<
                                         12 as std::os::raw::c_int) as std::os::raw::c_uint;
                                c |=
                                    ((*utf.offset(2 as std::os::raw::c_int as isize)
                                          as std::os::raw::c_int &
                                          0x3f as std::os::raw::c_int) <<
                                         6 as std::os::raw::c_int) as std::os::raw::c_uint;
                                c |=
                                    (*utf.offset(3 as std::os::raw::c_int as isize) as
                                         std::os::raw::c_int & 0x3f as std::os::raw::c_int) as
                                        std::os::raw::c_uint;
                                current_block = 11932355480408055363;
                            }
                        } else {
                            /* 3-byte code */
                            *len = 3 as std::os::raw::c_int;
                            c =
                                ((*utf.offset(0 as std::os::raw::c_int as isize) as
                                      std::os::raw::c_int & 0xf as std::os::raw::c_int) <<
                                     12 as std::os::raw::c_int) as std::os::raw::c_uint;
                            c |=
                                ((*utf.offset(1 as std::os::raw::c_int as isize) as
                                      std::os::raw::c_int & 0x3f as std::os::raw::c_int) <<
                                     6 as std::os::raw::c_int) as std::os::raw::c_uint;
                            c |=
                                (*utf.offset(2 as std::os::raw::c_int as isize) as
                                     std::os::raw::c_int & 0x3f as std::os::raw::c_int) as
                                    std::os::raw::c_uint;
                            current_block = 11932355480408055363;
                        }
                    } else {
                        /* 2-byte code */
                        *len = 2 as std::os::raw::c_int;
                        c =
                            ((*utf.offset(0 as std::os::raw::c_int as isize) as
                                  std::os::raw::c_int & 0x1f as std::os::raw::c_int) <<
                                 6 as std::os::raw::c_int) as std::os::raw::c_uint;
                        c |=
                            (*utf.offset(1 as std::os::raw::c_int as isize) as
                                 std::os::raw::c_int & 0x3f as std::os::raw::c_int) as
                                std::os::raw::c_uint;
                        current_block = 11932355480408055363;
                    }
                } else {
                    /* 1-byte code */
                    *len = 1 as std::os::raw::c_int;
                    current_block = 11932355480408055363;
                }
                match current_block {
                    606673952348435995 => { }
                    _ => { return c as std::os::raw::c_int }
                }
            }
        }
    }
    if !len.is_null() { *len = 0 as std::os::raw::c_int }
    return -(1 as std::os::raw::c_int);
}
/* *
 * xmlCheckUTF8:
 * @utf: Pointer to putative UTF-8 encoded string.
 *
 * Checks @utf for being valid UTF-8. @utf is assumed to be
 * null-terminated. This function is not super-strict, as it will
 * allow longer UTF-8 sequences than necessary. Note that Java is
 * capable of producing these sequences if provoked. Also note, this
 * routine checks for the 4-byte maximum size, but does not check for
 * 0x10ffff maximum value.
 *
 * Return value: true if @utf is valid.
 **/
#[no_mangle]
pub unsafe extern "C" fn xmlCheckUTF8(mut utf: *const std::os::raw::c_uchar)
 -> std::os::raw::c_int {
    let mut ix: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_uchar = 0;
    if utf.is_null() { return 0 as std::os::raw::c_int }
    /*
     * utf is a string of 1, 2, 3 or 4 bytes.  The valid strings
     * are as follows (in "bit format"):
     *    0xxxxxxx                                      valid 1-byte
     *    110xxxxx 10xxxxxx                             valid 2-byte
     *    1110xxxx 10xxxxxx 10xxxxxx                    valid 3-byte
     *    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx           valid 4-byte
     */
    ix = 0 as std::os::raw::c_int;
    loop  {
        c = *utf.offset(ix as isize);
        if !(c != 0) { break ; }
        /* string is 0-terminated */
        if c as std::os::raw::c_int & 0x80 as std::os::raw::c_int == 0 as std::os::raw::c_int {
            /* 1-byte code, starts with 10 */
            ix += 1
        } else if c as std::os::raw::c_int & 0xe0 as std::os::raw::c_int ==
                      0xc0 as std::os::raw::c_int {
            /* 2-byte code, starts with 110 */
            if *utf.offset((ix + 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int &
                   0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int {
                return 0 as std::os::raw::c_int
            }
            ix += 2 as std::os::raw::c_int
        } else if c as std::os::raw::c_int & 0xf0 as std::os::raw::c_int ==
                      0xe0 as std::os::raw::c_int {
            /* 3-byte code, starts with 1110 */
            if *utf.offset((ix + 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int &
                   0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int ||
                   *utf.offset((ix + 2 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                       0x80 as std::os::raw::c_int {
                return 0 as std::os::raw::c_int
            } /* unknown encoding */
            ix += 3 as std::os::raw::c_int
        } else if c as std::os::raw::c_int & 0xf8 as std::os::raw::c_int ==
                      0xf0 as std::os::raw::c_int {
            /* 4-byte code, starts with 11110 */
            if *utf.offset((ix + 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int &
                   0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int ||
                   *utf.offset((ix + 2 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                       0x80 as std::os::raw::c_int ||
                   *utf.offset((ix + 3 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                       0x80 as std::os::raw::c_int {
                return 0 as std::os::raw::c_int
            }
            ix += 4 as std::os::raw::c_int
        } else { return 0 as std::os::raw::c_int }
    }
    return 1 as std::os::raw::c_int;
}
/* *
 * xmlUTF8Strsize:
 * @utf:  a sequence of UTF-8 encoded bytes
 * @len:  the number of characters in the array
 *
 * storage size of an UTF8 string
 * the behaviour is not guaranteed if the input string is not UTF-8
 *
 * Returns the storage size of
 * the first 'len' characters of ARRAY
 */
#[no_mangle]
pub unsafe extern "C" fn xmlUTF8Strsize(mut utf: *const xmlChar,
                                        mut len: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut ptr: *const xmlChar = utf;
    let mut ch: xmlChar = 0;
    if utf.is_null() { return 0 as std::os::raw::c_int }
    if len <= 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    loop  {
        let fresh13 = len;
        len = len - 1;
        if !(fresh13 > 0 as std::os::raw::c_int) { break ; }
        if *ptr == 0 { break ; }
        let fresh14 = ptr;
        ptr = ptr.offset(1);
        ch = *fresh14;
        if ch as std::os::raw::c_int & 0x80 as std::os::raw::c_int != 0 {
            loop  {
                ch = ((ch as std::os::raw::c_int) << 1 as std::os::raw::c_int) as xmlChar;
                if !(ch as std::os::raw::c_int & 0x80 as std::os::raw::c_int != 0) { break ; }
                if *ptr as std::os::raw::c_int == 0 as std::os::raw::c_int { break ; }
                ptr = ptr.offset(1)
            }
        }
    }
    return ptr.offset_from(utf) as std::os::raw::c_long as std::os::raw::c_int;
}
/* *
 * xmlUTF8Strndup:
 * @utf:  the input UTF8 *
 * @len:  the len of @utf (in chars)
 *
 * a strndup for array of UTF8's
 *
 * Returns a new UTF8 * or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlUTF8Strndup(mut utf: *const xmlChar,
                                        mut len: std::os::raw::c_int)
 -> *mut xmlChar {
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    let mut i: std::os::raw::c_int = 0;
    if utf.is_null() || len < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    i = xmlUTF8Strsize(utf, len);
    ret =
        xmlMallocAtomic.expect("non-null function pointer")(((i +
                                                                  1 as
                                                                      std::os::raw::c_int)
                                                                 as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if ret.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"malloc of %ld byte failed\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   (len +
                                                                        1 as
                                                                            std::os::raw::c_int)
                                                                       as
                                                                       std::os::raw::c_long
                                                                       *
                                                                       ::std::mem::size_of::<xmlChar>()
                                                                           as
                                                                           std::os::raw::c_ulong
                                                                           as
                                                                           std::os::raw::c_long);
        return 0 as *mut xmlChar
    }
    memcpy(ret as *mut std::os::raw::c_void, utf as *const std::os::raw::c_void,
           (i as
                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                as std::os::raw::c_ulong));
    *ret.offset(i as isize) = 0 as std::os::raw::c_int as xmlChar;
    return ret;
}
/* *
 * xmlUTF8Strpos:
 * @utf:  the input UTF8 *
 * @pos:  the position of the desired UTF8 char (in chars)
 *
 * a function to provide the equivalent of fetching a
 * character from a string array
 *
 * Returns a pointer to the UTF8 character or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlUTF8Strpos(mut utf: *const xmlChar,
                                       mut pos: std::os::raw::c_int)
 -> *const xmlChar {
    let mut ch: xmlChar = 0;
    if utf.is_null() { return 0 as *const xmlChar }
    if pos < 0 as std::os::raw::c_int { return 0 as *const xmlChar }
    loop  {
        let fresh15 = pos;
        pos = pos - 1;
        if !(fresh15 != 0) { break ; }
        let fresh16 = utf;
        utf = utf.offset(1);
        ch = *fresh16;
        if ch as std::os::raw::c_int == 0 as std::os::raw::c_int {
            return 0 as *const xmlChar
        }
        if ch as std::os::raw::c_int & 0x80 as std::os::raw::c_int != 0 {
            /* if not simple ascii, verify proper format */
            if ch as std::os::raw::c_int & 0xc0 as std::os::raw::c_int != 0xc0 as std::os::raw::c_int
               {
                return 0 as *const xmlChar
            }
            loop 
                 /* then skip over remaining bytes for this char */
                 {
                ch = ((ch as std::os::raw::c_int) << 1 as std::os::raw::c_int) as xmlChar;
                if !(ch as std::os::raw::c_int & 0x80 as std::os::raw::c_int != 0) { break ; }
                let fresh17 = utf;
                utf = utf.offset(1);
                if *fresh17 as std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                       0x80 as std::os::raw::c_int {
                    return 0 as *const xmlChar
                }
            }
        }
    }
    return utf as *mut xmlChar;
}
/* *
 * xmlUTF8Strloc:
 * @utf:  the input UTF8 *
 * @utfchar:  the UTF8 character to be found
 *
 * a function to provide the relative location of a UTF8 char
 *
 * Returns the relative character position of the desired char
 * or -1 if not found
 */
#[no_mangle]
pub unsafe extern "C" fn xmlUTF8Strloc(mut utf: *const xmlChar,
                                       mut utfchar: *const xmlChar)
 -> std::os::raw::c_int {
    let mut i: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut ch: xmlChar = 0;
    if utf.is_null() || utfchar.is_null() { return -(1 as std::os::raw::c_int) }
    size = xmlUTF8Strsize(utfchar, 1 as std::os::raw::c_int);
    i = 0 as std::os::raw::c_int;
    loop  {
        ch = *utf;
        if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
        if xmlStrncmp(utf, utfchar, size) == 0 as std::os::raw::c_int { return i }
        utf = utf.offset(1);
        if ch as std::os::raw::c_int & 0x80 as std::os::raw::c_int != 0 {
            /* if not simple ascii, verify proper format */
            if ch as std::os::raw::c_int & 0xc0 as std::os::raw::c_int != 0xc0 as std::os::raw::c_int
               {
                return -(1 as std::os::raw::c_int)
            }
            loop 
                 /* then skip over remaining bytes for this char */
                 {
                ch = ((ch as std::os::raw::c_int) << 1 as std::os::raw::c_int) as xmlChar;
                if !(ch as std::os::raw::c_int & 0x80 as std::os::raw::c_int != 0) { break ; }
                let fresh18 = utf;
                utf = utf.offset(1);
                if *fresh18 as std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                       0x80 as std::os::raw::c_int {
                    return -(1 as std::os::raw::c_int)
                }
            }
        }
        i += 1
    }
    return -(1 as std::os::raw::c_int);
}
/* *
 * BAD_CAST:
 *
 * Macro to cast a string to an xmlChar * when one know its safe.
 */
/*
 * xmlChar handling
 */
/* *
 * xmlUTF8Strsub:
 * @utf:  a sequence of UTF-8 encoded bytes
 * @start: relative pos of first char
 * @len:   total number to copy
 *
 * Create a substring from a given UTF-8 string
 * Note:  positions are given in units of UTF-8 chars
 *
 * Returns a pointer to a newly created string
 * or NULL if any problem
 */
#[no_mangle]
pub unsafe extern "C" fn xmlUTF8Strsub(mut utf: *const xmlChar,
                                       mut start: std::os::raw::c_int,
                                       mut len: std::os::raw::c_int) -> *mut xmlChar {
    let mut i: std::os::raw::c_int = 0;
    let mut ch: xmlChar = 0;
    if utf.is_null() { return 0 as *mut xmlChar }
    if start < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    if len < 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    /*
     * Skip over any leading chars
     */
    i = 0 as std::os::raw::c_int;
    while i < start {
        let fresh19 = utf;
        utf = utf.offset(1);
        ch = *fresh19;
        if ch as std::os::raw::c_int == 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
        if ch as std::os::raw::c_int & 0x80 as std::os::raw::c_int != 0 {
            /* if not simple ascii, verify proper format */
            if ch as std::os::raw::c_int & 0xc0 as std::os::raw::c_int != 0xc0 as std::os::raw::c_int
               {
                return 0 as *mut xmlChar
            }
            loop 
                 /* then skip over remaining bytes for this char */
                 {
                ch = ((ch as std::os::raw::c_int) << 1 as std::os::raw::c_int) as xmlChar;
                if !(ch as std::os::raw::c_int & 0x80 as std::os::raw::c_int != 0) { break ; }
                let fresh20 = utf;
                utf = utf.offset(1);
                if *fresh20 as std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                       0x80 as std::os::raw::c_int {
                    return 0 as *mut xmlChar
                }
            }
        }
        i += 1
    }
    return xmlUTF8Strndup(utf, len);
}
/* *
 * xmlEscapeFormatString:
 * @msg:  a pointer to the string in which to escape '%' characters.
 * Must be a heap-allocated buffer created by libxml2 that may be
 * returned, or that may be freed and replaced.
 *
 * Replaces the string pointed to by 'msg' with an escaped string.
 * Returns the same string with all '%' characters escaped.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlEscapeFormatString(mut msg: *mut *mut xmlChar)
 -> *mut xmlChar {
    let mut msgPtr: *mut xmlChar = 0 as *mut xmlChar;
    let mut result: *mut xmlChar = 0 as *mut xmlChar;
    let mut resultPtr: *mut xmlChar = 0 as *mut xmlChar;
    let mut count: size_t = 0 as std::os::raw::c_int as size_t;
    let mut msgLen: size_t = 0 as std::os::raw::c_int as size_t;
    let mut resultLen: size_t = 0 as std::os::raw::c_int as size_t;
    if msg.is_null() || (*msg).is_null() { return 0 as *mut xmlChar }
    msgPtr = *msg;
    while *msgPtr as std::os::raw::c_int != '\u{0}' as i32 {
        msgLen = msgLen.wrapping_add(1);
        if *msgPtr as std::os::raw::c_int == '%' as i32 {
            count = count.wrapping_add(1)
        }
        msgPtr = msgPtr.offset(1)
    }
    if count == 0 as std::os::raw::c_int as std::os::raw::c_ulong { return *msg }
    resultLen =
        msgLen.wrapping_add(count).wrapping_add(1 as std::os::raw::c_int as
                                                    std::os::raw::c_ulong);
    result =
        xmlMallocAtomic.expect("non-null function pointer")(resultLen.wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                       as
                                                                                       std::os::raw::c_ulong))
            as *mut xmlChar;
    if result.is_null() {
        /* Clear *msg to prevent format string vulnerabilities in
           out-of-memory situations. */
        xmlFree.expect("non-null function pointer")(*msg as
                                                        *mut std::os::raw::c_void);
        *msg = 0 as *mut xmlChar;
        xmlErrMemory(0 as xmlParserCtxtPtr, 0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    msgPtr = *msg;
    resultPtr = result;
    while *msgPtr as std::os::raw::c_int != '\u{0}' as i32 {
        *resultPtr = *msgPtr;
        if *msgPtr as std::os::raw::c_int == '%' as i32 {
            resultPtr = resultPtr.offset(1);
            *resultPtr = '%' as i32 as xmlChar
        }
        msgPtr = msgPtr.offset(1);
        resultPtr = resultPtr.offset(1)
    }
    *result.offset(resultLen.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_ulong)
                       as isize) = '\u{0}' as i32 as xmlChar;
    xmlFree.expect("non-null function pointer")(*msg as *mut std::os::raw::c_void);
    *msg = result;
    return *msg;
}
/* __INCLUDE_ELFGCCHACK */
