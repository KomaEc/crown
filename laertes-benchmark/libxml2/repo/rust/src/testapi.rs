
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type _xmlBuf;
    /*
 * Summary: string dictionary
 * Description: dictionary of reusable strings, just used to avoid allocation
 *         and freeing operations.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * The dictionary.
 */
    pub type _xmlDict;
    pub type _xmlHashTable;
    pub type _xmlAutomataState;
    pub type _xmlAutomata;
    pub type _xmlValidState;
    /*
 * Summary: regular expressions handling
 * Description: basic API for libxml regular expressions handling used
 *              for XML Schemas and validation.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlRegexpPtr:
 *
 * A libxml regular expression, they can actually be far more complex
 * thank the POSIX regex expressions.
 */
    pub type _xmlRegexp;
    /* *
 * xmlRegExecCtxtPtr:
 *
 * A libxml progressive regular expression evaluation context
 */
    pub type _xmlRegExecCtxt;
    /*
 * Formal regular expression handling
 * Its goal is to do some formal work on content models
 */
    /* expressions are used within a context */
    pub type _xmlExpCtxt;
    /* Expressions are trees but the tree is opaque */
    pub type _xmlExpNode;
    /*
 * Summary: lists interfaces
 * Description: this module implement the list support used in
 * various place in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>
 */
    pub type _xmlLink;
    pub type _xmlList;
    /*
 * Summary: implementation of the Relax-NG validation
 * Description: implementation of the Relax-NG validation
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    pub type _xmlRelaxNG;
    /* *
 * A schemas validation context
 */
    pub type _xmlRelaxNGParserCtxt;
    pub type _xmlRelaxNGValidCtxt;
    /* *
 * A schemas validation context
 */
    pub type _xmlSchemaParserCtxt;
    pub type _xmlSchemaValidCtxt;
    pub type _xmlPattern;
    pub type _xmlXIncludeCtxt;
    /* streaming interfaces */
    pub type _xmlStreamCtxt;
    pub type _xmlXPathCompExpr;
    pub type _xmlTextWriter;
    pub type _xmlSchemaVal;
    pub type _xmlSaveCtxt;
    pub type _xmlModule;
    pub type _xmlSchematronValidCtxt;
    pub type _xmlCatalog;
    #[no_mangle]
    fn fclose(__stream: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fopen(__filename: *const std::os::raw::c_char, __modes: *const std::os::raw::c_char)
     -> *mut FILE;
    #[no_mangle]
    fn printf(_: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    /*
 * Summary: set of routines to process strings
 * Description: type and interfaces needed for the internal string handling
 *              of the library, especially UTF8 processing.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlChar:
 *
 * This is a basic byte in an UTF-8 encoded string.
 * It's unsigned allowing to pinpoint case where char * are assigned
 * to xmlChar * (possibly making serialization back impossible).
 */
    /* *
 * BAD_CAST:
 *
 * Macro to cast a string to an xmlChar * when one know its safe.
 */
    /*
 * xmlChar handling
 */
    #[no_mangle]
    fn xmlUTF8Strndup(utf: *const xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrncatNew(str1: *const xmlChar, str2: *const xmlChar,
                     len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlGetUTF8Char(utf: *const std::os::raw::c_uchar, len: *mut std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCheckUTF8(utf: *const std::os::raw::c_uchar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUTF8Strsize(utf: *const xmlChar, len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrndup(cur: *const xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrlen(str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrQEqual(pref: *const xmlChar, name: *const xmlChar,
                    str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrncasecmp(str1: *const xmlChar, str2: *const xmlChar,
                      len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcasecmp(str1: *const xmlChar, str2: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrncmp(str1: *const xmlChar, str2: *const xmlChar,
                  len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcmp(str1: *const xmlChar, str2: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcasestr(str: *const xmlChar, val: *const xmlChar)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlStrstr(str: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
    #[no_mangle]
    fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrchr(str: *const xmlChar, val: xmlChar) -> *const xmlChar;
    #[no_mangle]
    fn xmlStrsub(str: *const xmlChar, start: std::os::raw::c_int, len: std::os::raw::c_int)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlCharStrdup(cur: *const std::os::raw::c_char) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCharStrndup(cur: *const std::os::raw::c_char, len: std::os::raw::c_int)
     -> *mut xmlChar;
    #[no_mangle]
    fn snprintf(_: *mut std::os::raw::c_char, _: std::os::raw::c_ulong,
                _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    /*
 * Summary: compile-time version informations
 * Description: compile-time version informations for the XML library
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * use those to be sure nothing nasty will happen if
 * your library and includes mismatch
 */
    #[no_mangle]
    fn xmlCheckVersion(version: std::os::raw::c_int);
    #[no_mangle]
    fn xmlUTF8Strpos(utf: *const xmlChar, pos: std::os::raw::c_int) -> *const xmlChar;
    #[no_mangle]
    fn xmlUTF8Strloc(utf: *const xmlChar, utfchar: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUTF8Strsub(utf: *const xmlChar, start: std::os::raw::c_int,
                     len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlUTF8Strlen(utf: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUTF8Size(utf: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUTF8Charcmp(utf1: *const xmlChar, utf2: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufContent(buf: *const xmlBuf) -> *mut xmlChar;
    #[no_mangle]
    fn xmlBufEnd(buf: xmlBufPtr) -> *mut xmlChar;
    /*
 * Initializer
 */
    #[no_mangle]
    fn xmlInitializeDict() -> std::os::raw::c_int;
    /*
 * Constructor and destructor.
 */
    #[no_mangle]
    fn xmlDictCreate() -> xmlDictPtr;
    #[no_mangle]
    fn xmlDictCreateSub(sub: xmlDictPtr) -> xmlDictPtr;
    #[no_mangle]
    fn xmlDictReference(dict: xmlDictPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDictFree(dict: xmlDictPtr);
    /*
 * Lookup of entry in the dictionary.
 */
    #[no_mangle]
    fn xmlDictLookup(dict: xmlDictPtr, name: *const xmlChar, len: std::os::raw::c_int)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlDictExists(dict: xmlDictPtr, name: *const xmlChar, len: std::os::raw::c_int)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlDictQLookup(dict: xmlDictPtr, prefix: *const xmlChar,
                      name: *const xmlChar) -> *const xmlChar;
    #[no_mangle]
    fn xmlDictOwns(dict: xmlDictPtr, str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDictSize(dict: xmlDictPtr) -> std::os::raw::c_int;
    /*
 * Cleanup function
 */
    #[no_mangle]
    fn xmlDictCleanup();
    #[no_mangle]
    fn xmlRegexpExec(comp: xmlRegexpPtr, value: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegexpPrint(output: *mut FILE, regexp: xmlRegexpPtr);
    #[no_mangle]
    fn xmlRegexpIsDeterminist(comp: xmlRegexpPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegExecPushString(exec: xmlRegExecCtxtPtr, value: *const xmlChar,
                            data: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegExecPushString2(exec: xmlRegExecCtxtPtr, value: *const xmlChar,
                             value2: *const xmlChar, data: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegExecNextValues(exec: xmlRegExecCtxtPtr, nbval: *mut std::os::raw::c_int,
                            nbneg: *mut std::os::raw::c_int,
                            values: *mut *mut xmlChar,
                            terminal: *mut std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegExecErrInfo(exec: xmlRegExecCtxtPtr, string: *mut *const xmlChar,
                         nbval: *mut std::os::raw::c_int, nbneg: *mut std::os::raw::c_int,
                         values: *mut *mut xmlChar,
                         terminal: *mut std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlExpCtxtNbNodes(ctxt: xmlExpCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlExpCtxtNbCons(ctxt: xmlExpCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlExpRef(expr: xmlExpNodePtr);
    /*
 * The really interesting APIs
 */
    #[no_mangle]
    fn xmlExpIsNillable(expr: xmlExpNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlExpMaxToken(expr: xmlExpNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlExpGetLanguage(ctxt: xmlExpCtxtPtr, expr: xmlExpNodePtr,
                         langList: *mut *const xmlChar, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlExpGetStart(ctxt: xmlExpCtxtPtr, expr: xmlExpNodePtr,
                      tokList: *mut *const xmlChar, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlExpSubsume(ctxt: xmlExpCtxtPtr, expr: xmlExpNodePtr,
                     sub: xmlExpNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlExpDump(buf: xmlBufferPtr, expr: xmlExpNodePtr);
    /* *
 * xmlChildrenNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children."
 */
    /* *
 * xmlRootNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children".
 */
    /*
 * Variables.
 */
    /*
 * Some helper functions
 */
    #[no_mangle]
    fn xmlValidateNCName(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateQName(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateName(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNMToken(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBuildQName(ncname: *const xmlChar, prefix: *const xmlChar,
                     memory: *mut xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlSplitQName2(name: *const xmlChar, prefix: *mut *mut xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlSplitQName3(name: *const xmlChar, len: *mut std::os::raw::c_int)
     -> *const xmlChar;
    /*
 * Handling Buffers, the old ones see @xmlBuf for the new ones.
 */
    #[no_mangle]
    fn xmlSetBufferAllocationScheme(scheme: xmlBufferAllocationScheme);
    #[no_mangle]
    fn xmlGetBufferAllocationScheme() -> xmlBufferAllocationScheme;
    #[no_mangle]
    fn xmlBufferCreate() -> xmlBufferPtr;
    #[no_mangle]
    fn xmlBufferCreateStatic(mem: *mut std::os::raw::c_void, size: size_t)
     -> xmlBufferPtr;
    #[no_mangle]
    fn xmlBufferResize(buf: xmlBufferPtr, size: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufferFree(buf: xmlBufferPtr);
    #[no_mangle]
    fn xmlBufferAdd(buf: xmlBufferPtr, str: *const xmlChar, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufferAddHead(buf: xmlBufferPtr, str: *const xmlChar,
                        len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufferCat(buf: xmlBufferPtr, str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufferCCat(buf: xmlBufferPtr, str: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufferShrink(buf: xmlBufferPtr, len: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufferGrow(buf: xmlBufferPtr, len: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufferEmpty(buf: xmlBufferPtr);
    #[no_mangle]
    fn xmlBufferContent(buf: *const xmlBuffer) -> *const xmlChar;
    #[no_mangle]
    fn xmlBufferDetach(buf: xmlBufferPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlBufferSetAllocationScheme(buf: xmlBufferPtr,
                                    scheme: xmlBufferAllocationScheme);
    #[no_mangle]
    fn xmlBufferLength(buf: *const xmlBuffer) -> std::os::raw::c_int;
    /*
 * Creating/freeing new structures.
 */
    #[no_mangle]
    fn xmlCreateIntSubset(doc: xmlDocPtr, name: *const xmlChar,
                          ExternalID: *const xmlChar,
                          SystemID: *const xmlChar) -> xmlDtdPtr;
    #[no_mangle]
    fn xmlNewDtd(doc: xmlDocPtr, name: *const xmlChar,
                 ExternalID: *const xmlChar, SystemID: *const xmlChar)
     -> xmlDtdPtr;
    #[no_mangle]
    fn xmlGetIntSubset(doc: *const xmlDoc) -> xmlDtdPtr;
    /* LIBXML_LEGACY_ENABLED */
    #[no_mangle]
    fn xmlNewNs(node: xmlNodePtr, href: *const xmlChar,
                prefix: *const xmlChar) -> xmlNsPtr;
    #[no_mangle]
    fn xmlFreeNs(cur: xmlNsPtr);
    #[no_mangle]
    fn xmlFreeNsList(cur: xmlNsPtr);
    #[no_mangle]
    fn xmlNewDoc(version: *const xmlChar) -> xmlDocPtr;
    #[no_mangle]
    fn xmlFreeDoc(cur: xmlDocPtr);
    #[no_mangle]
    fn xmlNewDocProp(doc: xmlDocPtr, name: *const xmlChar,
                     value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlNewProp(node: xmlNodePtr, name: *const xmlChar,
                  value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlNewNsProp(node: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar,
                    value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlNewNsPropEatName(node: xmlNodePtr, ns: xmlNsPtr, name: *mut xmlChar,
                           value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlCopyProp(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlCopyPropList(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlCopyDtd(dtd: xmlDtdPtr) -> xmlDtdPtr;
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlCopyDoc(doc: xmlDocPtr, recursive: std::os::raw::c_int) -> xmlDocPtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
    /*
 * Creating new nodes.
 */
    #[no_mangle]
    fn xmlNewDocNode(doc: xmlDocPtr, ns: xmlNsPtr, name: *const xmlChar,
                     content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocNodeEatName(doc: xmlDocPtr, ns: xmlNsPtr, name: *mut xmlChar,
                            content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewNode(ns: xmlNsPtr, name: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewNodeEatName(ns: xmlNsPtr, name: *mut xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewChild(parent: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar,
                   content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocText(doc: *const xmlDoc, content: *const xmlChar)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewText(content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocPI(doc: xmlDocPtr, name: *const xmlChar,
                   content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewPI(name: *const xmlChar, content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocTextLen(doc: xmlDocPtr, content: *const xmlChar,
                        len: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewTextLen(content: *const xmlChar, len: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocComment(doc: xmlDocPtr, content: *const xmlChar)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewComment(content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewCDataBlock(doc: xmlDocPtr, content: *const xmlChar,
                        len: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewCharRef(doc: xmlDocPtr, name: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewReference(doc: *const xmlDoc, name: *const xmlChar)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlCopyNode(node: xmlNodePtr, recursive: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlDocCopyNode(node: xmlNodePtr, doc: xmlDocPtr,
                      recursive: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlDocCopyNodeList(doc: xmlDocPtr, node: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlCopyNodeList(node: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewTextChild(parent: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar,
                       content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocRawNode(doc: xmlDocPtr, ns: xmlNsPtr, name: *const xmlChar,
                        content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocFragment(doc: xmlDocPtr) -> xmlNodePtr;
    /* LIBXML_TREE_ENABLED */
    /*
 * Navigating.
 */
    #[no_mangle]
    fn xmlGetLineNo(node: *const xmlNode) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlGetNodePath(node: *const xmlNode) -> *mut xmlChar;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
    #[no_mangle]
    fn xmlDocGetRootElement(doc: *const xmlDoc) -> xmlNodePtr;
    #[no_mangle]
    fn xmlGetLastChild(parent: *const xmlNode) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNodeIsText(node: *const xmlNode) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsBlankNode(node: *const xmlNode) -> std::os::raw::c_int;
    /*
 * Changing the structure.
 */
    #[no_mangle]
    fn xmlDocSetRootElement(doc: xmlDocPtr, root: xmlNodePtr) -> xmlNodePtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
    #[no_mangle]
    fn xmlNodeSetName(cur: xmlNodePtr, name: *const xmlChar);
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlAddChild(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlAddChildList(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlReplaceNode(old: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
    #[no_mangle]
    fn xmlAddPrevSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
    /* LIBXML_TREE_ENABLED || LIBXML_HTML_ENABLED || LIBXML_SCHEMAS_ENABLED */
    #[no_mangle]
    fn xmlAddSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlAddNextSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlUnlinkNode(cur: xmlNodePtr);
    #[no_mangle]
    fn xmlTextMerge(first: xmlNodePtr, second: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlTextConcat(node: xmlNodePtr, content: *const xmlChar,
                     len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlFreeNodeList(cur: xmlNodePtr);
    #[no_mangle]
    fn xmlFreeNode(cur: xmlNodePtr);
    /*
 * Namespaces.
 */
    #[no_mangle]
    fn xmlSearchNs(doc: xmlDocPtr, node: xmlNodePtr,
                   nameSpace: *const xmlChar) -> xmlNsPtr;
    #[no_mangle]
    fn xmlSearchNsByHref(doc: xmlDocPtr, node: xmlNodePtr,
                         href: *const xmlChar) -> xmlNsPtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) */
    #[no_mangle]
    fn xmlSetNs(node: xmlNodePtr, ns: xmlNsPtr);
    #[no_mangle]
    fn xmlCopyNamespace(cur: xmlNsPtr) -> xmlNsPtr;
    #[no_mangle]
    fn xmlCopyNamespaceList(cur: xmlNsPtr) -> xmlNsPtr;
    /*
 * Changing the content.
 */
    #[no_mangle]
    fn xmlSetProp(node: xmlNodePtr, name: *const xmlChar,
                  value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlSetNsProp(node: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar,
                    value: *const xmlChar) -> xmlAttrPtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \
	  defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
    #[no_mangle]
    fn xmlGetNoNsProp(node: *const xmlNode, name: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlGetProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlHasProp(node: *const xmlNode, name: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlHasNsProp(node: *const xmlNode, name: *const xmlChar,
                    nameSpace: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlGetNsProp(node: *const xmlNode, name: *const xmlChar,
                    nameSpace: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStringGetNodeList(doc: *const xmlDoc, value: *const xmlChar)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlStringLenGetNodeList(doc: *const xmlDoc, value: *const xmlChar,
                               len: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNodeListGetString(doc: xmlDocPtr, list: *const xmlNode,
                            inLine: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeListGetRawString(doc: *const xmlDoc, list: *const xmlNode,
                               inLine: std::os::raw::c_int) -> *mut xmlChar;
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlNodeSetContent(cur: xmlNodePtr, content: *const xmlChar);
    #[no_mangle]
    fn xmlNodeSetContentLen(cur: xmlNodePtr, content: *const xmlChar,
                            len: std::os::raw::c_int);
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlNodeAddContent(cur: xmlNodePtr, content: *const xmlChar);
    #[no_mangle]
    fn xmlNodeAddContentLen(cur: xmlNodePtr, content: *const xmlChar,
                            len: std::os::raw::c_int);
    #[no_mangle]
    fn xmlNodeGetContent(cur: *const xmlNode) -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeBufGetContent(buffer: xmlBufferPtr, cur: *const xmlNode)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufGetNodeContent(buf: xmlBufPtr, cur: *const xmlNode)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNodeGetLang(cur: *const xmlNode) -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeGetSpacePreserve(cur: *const xmlNode) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNodeSetLang(cur: xmlNodePtr, lang: *const xmlChar);
    #[no_mangle]
    fn xmlNodeSetSpacePreserve(cur: xmlNodePtr, val: std::os::raw::c_int);
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlNodeGetBase(doc: *const xmlDoc, cur: *const xmlNode)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeSetBase(cur: xmlNodePtr, uri: *const xmlChar);
    /*
 * Removing content.
 */
    #[no_mangle]
    fn xmlRemoveProp(cur: xmlAttrPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUnsetNsProp(node: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUnsetProp(node: xmlNodePtr, name: *const xmlChar) -> std::os::raw::c_int;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
    /*
 * Internal, don't use.
 */
    #[no_mangle]
    fn xmlBufferWriteCHAR(buf: xmlBufferPtr, string: *const xmlChar);
    #[no_mangle]
    fn xmlBufferWriteChar(buf: xmlBufferPtr, string: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlBufferWriteQuotedString(buf: xmlBufferPtr, string: *const xmlChar);
    #[no_mangle]
    fn xmlAttrSerializeTxtContent(buf: xmlBufferPtr, doc: xmlDocPtr,
                                  attr: xmlAttrPtr, string: *const xmlChar);
    /* LIBXML_OUTPUT_ENABLED */
    /*
 * Namespace handling.
 */
    #[no_mangle]
    fn xmlReconciliateNs(doc: xmlDocPtr, tree: xmlNodePtr) -> std::os::raw::c_int;
    /*
 * Saving.
 */
    #[no_mangle]
    fn xmlDocDumpFormatMemory(cur: xmlDocPtr, mem: *mut *mut xmlChar,
                              size: *mut std::os::raw::c_int, format: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDocDumpMemory(cur: xmlDocPtr, mem: *mut *mut xmlChar,
                        size: *mut std::os::raw::c_int);
    #[no_mangle]
    fn xmlDocDumpMemoryEnc(out_doc: xmlDocPtr, doc_txt_ptr: *mut *mut xmlChar,
                           doc_txt_len: *mut std::os::raw::c_int,
                           txt_encoding: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlDocDumpFormatMemoryEnc(out_doc: xmlDocPtr,
                                 doc_txt_ptr: *mut *mut xmlChar,
                                 doc_txt_len: *mut std::os::raw::c_int,
                                 txt_encoding: *const std::os::raw::c_char,
                                 format: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDocFormatDump(f: *mut FILE, cur: xmlDocPtr, format: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlElemDump(f: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
    #[no_mangle]
    fn xmlSaveFile(filename: *const std::os::raw::c_char, cur: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSaveFormatFile(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                         format: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNodeDump(buf: xmlBufferPtr, doc: xmlDocPtr, cur: xmlNodePtr,
                   level: std::os::raw::c_int, format: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSaveFileTo(buf: xmlOutputBufferPtr, cur: xmlDocPtr,
                     encoding: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSaveFormatFileTo(buf: xmlOutputBufferPtr, cur: xmlDocPtr,
                           encoding: *const std::os::raw::c_char, format: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNodeDumpOutput(buf: xmlOutputBufferPtr, doc: xmlDocPtr,
                         cur: xmlNodePtr, level: std::os::raw::c_int,
                         format: std::os::raw::c_int, encoding: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlSaveFormatFileEnc(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                            encoding: *const std::os::raw::c_char,
                            format: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSaveFileEnc(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                      encoding: *const std::os::raw::c_char) -> std::os::raw::c_int;
    /* LIBXML_OUTPUT_ENABLED */
    /*
 * XHTML
 */
    #[no_mangle]
    fn xmlIsXHTML(systemID: *const xmlChar, publicID: *const xmlChar)
     -> std::os::raw::c_int;
    /*
 * Compression.
 */
    #[no_mangle]
    fn xmlGetDocCompressMode(doc: *const xmlDoc) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSetDocCompressMode(doc: xmlDocPtr, mode: std::os::raw::c_int);
    #[no_mangle]
    fn xmlGetCompressMode() -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSetCompressMode(mode: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDOMWrapReconcileNamespaces(ctxt: xmlDOMWrapCtxtPtr,
                                     elem: xmlNodePtr, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDOMWrapAdoptNode(ctxt: xmlDOMWrapCtxtPtr, sourceDoc: xmlDocPtr,
                           node: xmlNodePtr, destDoc: xmlDocPtr,
                           destParent: xmlNodePtr, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDOMWrapRemoveNode(ctxt: xmlDOMWrapCtxtPtr, doc: xmlDocPtr,
                            node: xmlNodePtr, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDOMWrapCloneNode(ctxt: xmlDOMWrapCtxtPtr, sourceDoc: xmlDocPtr,
                           node: xmlNodePtr, clonedNode: *mut xmlNodePtr,
                           destDoc: xmlDocPtr, destParent: xmlNodePtr,
                           deep: std::os::raw::c_int, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    /*
 * 5 interfaces from DOM ElementTraversal, but different in entities
 * traversal.
 */
    #[no_mangle]
    fn xmlChildElementCount(parent: xmlNodePtr) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn xmlNextElementSibling(node: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlFirstElementChild(parent: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlLastElementChild(parent: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlPreviousElementSibling(node: xmlNodePtr) -> xmlNodePtr;
    /*
 * These are specific to the XML debug memory wrapper.
 */
    #[no_mangle]
    fn xmlMemUsed() -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlMemBlocks() -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlMemoryDump();
    /*
 * Constructor and destructor.
 */
    #[no_mangle]
    fn xmlHashCreate(size: std::os::raw::c_int) -> xmlHashTablePtr;
    #[no_mangle]
    fn xmlHashFree(table: xmlHashTablePtr, f: xmlHashDeallocator);
    #[no_mangle]
    fn xmlHashDefaultDeallocator(entry: *mut std::os::raw::c_void,
                                 name: *const xmlChar);
    /*
 * Add a new entry to the hash table.
 */
    #[no_mangle]
    fn xmlHashAddEntry(table: xmlHashTablePtr, name: *const xmlChar,
                       userdata: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashUpdateEntry(table: xmlHashTablePtr, name: *const xmlChar,
                          userdata: *mut std::os::raw::c_void, f: xmlHashDeallocator)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashAddEntry2(table: xmlHashTablePtr, name: *const xmlChar,
                        name2: *const xmlChar, userdata: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashUpdateEntry2(table: xmlHashTablePtr, name: *const xmlChar,
                           name2: *const xmlChar, userdata: *mut std::os::raw::c_void,
                           f: xmlHashDeallocator) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashAddEntry3(table: xmlHashTablePtr, name: *const xmlChar,
                        name2: *const xmlChar, name3: *const xmlChar,
                        userdata: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashUpdateEntry3(table: xmlHashTablePtr, name: *const xmlChar,
                           name2: *const xmlChar, name3: *const xmlChar,
                           userdata: *mut std::os::raw::c_void, f: xmlHashDeallocator)
     -> std::os::raw::c_int;
    /*
 * Remove an entry from the hash table.
 */
    #[no_mangle]
    fn xmlHashRemoveEntry(table: xmlHashTablePtr, name: *const xmlChar,
                          f: xmlHashDeallocator) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashRemoveEntry2(table: xmlHashTablePtr, name: *const xmlChar,
                           name2: *const xmlChar, f: xmlHashDeallocator)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashRemoveEntry3(table: xmlHashTablePtr, name: *const xmlChar,
                           name2: *const xmlChar, name3: *const xmlChar,
                           f: xmlHashDeallocator) -> std::os::raw::c_int;
    /*
 * Retrieve the userdata.
 */
    #[no_mangle]
    fn xmlHashLookup(table: xmlHashTablePtr, name: *const xmlChar)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashLookup2(table: xmlHashTablePtr, name: *const xmlChar,
                      name2: *const xmlChar) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashLookup3(table: xmlHashTablePtr, name: *const xmlChar,
                      name2: *const xmlChar, name3: *const xmlChar)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashQLookup(table: xmlHashTablePtr, name: *const xmlChar,
                      prefix: *const xmlChar) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashQLookup2(table: xmlHashTablePtr, name: *const xmlChar,
                       prefix: *const xmlChar, name2: *const xmlChar,
                       prefix2: *const xmlChar) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashQLookup3(table: xmlHashTablePtr, name: *const xmlChar,
                       prefix: *const xmlChar, name2: *const xmlChar,
                       prefix2: *const xmlChar, name3: *const xmlChar,
                       prefix3: *const xmlChar) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashSize(table: xmlHashTablePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn initGenericErrorDefaultFunc(handler: *mut xmlGenericErrorFunc);
    #[no_mangle]
    fn xmlSetStructuredErrorFunc(ctx: *mut std::os::raw::c_void,
                                 handler: xmlStructuredErrorFunc);
    #[no_mangle]
    fn xmlParserPrintFileInfo(input: xmlParserInputPtr);
    #[no_mangle]
    fn xmlParserPrintFileContext(input: xmlParserInputPtr);
    #[no_mangle]
    fn xmlResetLastError();
    #[no_mangle]
    fn xmlCtxtResetLastError(ctx: *mut std::os::raw::c_void);
    #[no_mangle]
    fn xmlResetError(err: xmlErrorPtr);
    #[no_mangle]
    fn xmlCopyError(from: xmlErrorPtr, to: xmlErrorPtr) -> std::os::raw::c_int;
    /* Creation/Deletion */
    #[no_mangle]
    fn xmlListCreate(deallocator: xmlListDeallocator,
                     compare: xmlListDataCompare) -> xmlListPtr;
    #[no_mangle]
    fn xmlListDelete(l: xmlListPtr);
    /* Basic Operators */
    #[no_mangle]
    fn xmlListSearch(l: xmlListPtr, data: *mut std::os::raw::c_void)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlListReverseSearch(l: xmlListPtr, data: *mut std::os::raw::c_void)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlListInsert(l: xmlListPtr, data: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlListAppend(l: xmlListPtr, data: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlListRemoveFirst(l: xmlListPtr, data: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlListRemoveLast(l: xmlListPtr, data: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlListRemoveAll(l: xmlListPtr, data: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlListClear(l: xmlListPtr);
    #[no_mangle]
    fn xmlListEmpty(l: xmlListPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlListSize(l: xmlListPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlListPopFront(l: xmlListPtr);
    #[no_mangle]
    fn xmlListPopBack(l: xmlListPtr);
    #[no_mangle]
    fn xmlListPushFront(l: xmlListPtr, data: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlListPushBack(l: xmlListPtr, data: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    /* Advanced Operators */
    #[no_mangle]
    fn xmlListReverse(l: xmlListPtr);
    #[no_mangle]
    fn xmlListSort(l: xmlListPtr);
    #[no_mangle]
    fn xmlListMerge(l1: xmlListPtr, l2: xmlListPtr);
    #[no_mangle]
    fn xmlListCopy(cur: xmlListPtr, old: xmlListPtr) -> std::os::raw::c_int;
    /* Link operators */
    #[no_mangle]
    fn xmlLinkGetData(lk: xmlLinkPtr) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlAutomataSetFinalState(am: xmlAutomataPtr,
                                state: xmlAutomataStatePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlAutomataNewCounter(am: xmlAutomataPtr, min: std::os::raw::c_int,
                             max: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlAutomataIsDeterminist(am: xmlAutomataPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDumpNotationDecl(buf: xmlBufferPtr, nota: xmlNotationPtr);
    #[no_mangle]
    fn xmlDumpNotationTable(buf: xmlBufferPtr, table: xmlNotationTablePtr);
    /* LIBXML_OUTPUT_ENABLED */
    /* Element Content */
/* the non Doc version are being deprecated */
    #[no_mangle]
    fn xmlNewElementContent(name: *const xmlChar,
                            type_0: xmlElementContentType)
     -> xmlElementContentPtr;
    #[no_mangle]
    fn xmlCopyElementContent(content: xmlElementContentPtr)
     -> xmlElementContentPtr;
    #[no_mangle]
    fn xmlFreeElementContent(cur: xmlElementContentPtr);
    /* the new versions with doc argument */
    #[no_mangle]
    fn xmlNewDocElementContent(doc: xmlDocPtr, name: *const xmlChar,
                               type_0: xmlElementContentType)
     -> xmlElementContentPtr;
    #[no_mangle]
    fn xmlCopyDocElementContent(doc: xmlDocPtr, content: xmlElementContentPtr)
     -> xmlElementContentPtr;
    #[no_mangle]
    fn xmlFreeDocElementContent(doc: xmlDocPtr, cur: xmlElementContentPtr);
    #[no_mangle]
    fn xmlSnprintfElementContent(buf: *mut std::os::raw::c_char, size: std::os::raw::c_int,
                                 content: xmlElementContentPtr,
                                 englob: std::os::raw::c_int);
    /* DEPRECATED */
    #[no_mangle]
    fn xmlSprintfElementContent(buf: *mut std::os::raw::c_char,
                                content: xmlElementContentPtr,
                                englob: std::os::raw::c_int);
    /* LIBXML_OUTPUT_ENABLED */
    /* DEPRECATED */
    /* Element */
    #[no_mangle]
    fn xmlAddElementDecl(ctxt: xmlValidCtxtPtr, dtd: xmlDtdPtr,
                         name: *const xmlChar, type_0: xmlElementTypeVal,
                         content: xmlElementContentPtr) -> xmlElementPtr;
    #[no_mangle]
    fn xmlDumpElementTable(buf: xmlBufferPtr, table: xmlElementTablePtr);
    #[no_mangle]
    fn xmlDumpElementDecl(buf: xmlBufferPtr, elem: xmlElementPtr);
    /* LIBXML_TREE_ENABLED */
    /* Attribute */
    #[no_mangle]
    fn xmlAddAttributeDecl(ctxt: xmlValidCtxtPtr, dtd: xmlDtdPtr,
                           elem: *const xmlChar, name: *const xmlChar,
                           ns: *const xmlChar, type_0: xmlAttributeType,
                           def: xmlAttributeDefault,
                           defaultValue: *const xmlChar,
                           tree: xmlEnumerationPtr) -> xmlAttributePtr;
    #[no_mangle]
    fn xmlDumpAttributeTable(buf: xmlBufferPtr, table: xmlAttributeTablePtr);
    #[no_mangle]
    fn xmlDumpAttributeDecl(buf: xmlBufferPtr, attr: xmlAttributePtr);
    #[no_mangle]
    fn xmlGetID(doc: xmlDocPtr, ID: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlIsID(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRemoveID(doc: xmlDocPtr, attr: xmlAttrPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsRef(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRemoveRef(doc: xmlDocPtr, attr: xmlAttrPtr) -> std::os::raw::c_int;
    /* *
 * The public function calls related to validity checking.
 */
    /* Allocate/Release Validation Contexts */
    #[no_mangle]
    fn xmlNewValidCtxt() -> xmlValidCtxtPtr;
    #[no_mangle]
    fn xmlFreeValidCtxt(_: xmlValidCtxtPtr);
    #[no_mangle]
    fn xmlValidateRoot(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateElementDecl(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                              elem: xmlElementPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidNormalizeAttributeValue(doc: xmlDocPtr, elem: xmlNodePtr,
                                       name: *const xmlChar,
                                       value: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlValidCtxtNormalizeAttributeValue(ctxt: xmlValidCtxtPtr,
                                           doc: xmlDocPtr, elem: xmlNodePtr,
                                           name: *const xmlChar,
                                           value: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlValidateAttributeDecl(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                                attr: xmlAttributePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateAttributeValue(type_0: xmlAttributeType,
                                 value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNotationDecl(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                               nota: xmlNotationPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateDtd(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr, dtd: xmlDtdPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateDtdFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateDocument(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateElement(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                          elem: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateOneElement(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                             elem: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateOneAttribute(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                               elem: xmlNodePtr, attr: xmlAttrPtr,
                               value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateOneNamespace(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                               elem: xmlNodePtr, prefix: *const xmlChar,
                               ns: xmlNsPtr, value: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateDocumentFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    /* LIBXML_VALID_ENABLED */
    #[no_mangle]
    fn xmlValidateNotationUse(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                              notationName: *const xmlChar) -> std::os::raw::c_int;
    /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */
    #[no_mangle]
    fn xmlIsMixedElement(doc: xmlDocPtr, name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlGetDtdAttrDesc(dtd: xmlDtdPtr, elem: *const xmlChar,
                         name: *const xmlChar) -> xmlAttributePtr;
    #[no_mangle]
    fn xmlGetDtdQAttrDesc(dtd: xmlDtdPtr, elem: *const xmlChar,
                          name: *const xmlChar, prefix: *const xmlChar)
     -> xmlAttributePtr;
    #[no_mangle]
    fn xmlGetDtdQElementDesc(dtd: xmlDtdPtr, name: *const xmlChar,
                             prefix: *const xmlChar) -> xmlElementPtr;
    #[no_mangle]
    fn xmlGetDtdElementDesc(dtd: xmlDtdPtr, name: *const xmlChar)
     -> xmlElementPtr;
    #[no_mangle]
    fn xmlValidGetPotentialChildren(ctree: *mut xmlElementContent,
                                    names: *mut *const xmlChar,
                                    len: *mut std::os::raw::c_int, max: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidGetValidElements(prev: *mut xmlNode, next: *mut xmlNode,
                                names: *mut *const xmlChar, max: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNameValue(value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNamesValue(value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNmtokenValue(value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNmtokensValue(value: *const xmlChar) -> std::os::raw::c_int;
    /*
 * Validation based on the regexp support
 */
    #[no_mangle]
    fn xmlValidBuildContentModel(ctxt: xmlValidCtxtPtr, elem: xmlElementPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidatePushElement(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                              elem: xmlNodePtr, qname: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidatePushCData(ctxt: xmlValidCtxtPtr, data: *const xmlChar,
                            len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidatePopElement(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                             elem: xmlNodePtr, qname: *const xmlChar)
     -> std::os::raw::c_int;
    /*
 * External functions:
 */
    #[no_mangle]
    fn xmlInitializePredefinedEntities();
    /* LIBXML_LEGACY_ENABLED */
    #[no_mangle]
    fn xmlNewEntity(doc: xmlDocPtr, name: *const xmlChar, type_0: std::os::raw::c_int,
                    ExternalID: *const xmlChar, SystemID: *const xmlChar,
                    content: *const xmlChar) -> xmlEntityPtr;
    #[no_mangle]
    fn xmlAddDocEntity(doc: xmlDocPtr, name: *const xmlChar,
                       type_0: std::os::raw::c_int, ExternalID: *const xmlChar,
                       SystemID: *const xmlChar, content: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlAddDtdEntity(doc: xmlDocPtr, name: *const xmlChar,
                       type_0: std::os::raw::c_int, ExternalID: *const xmlChar,
                       SystemID: *const xmlChar, content: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlGetPredefinedEntity(name: *const xmlChar) -> xmlEntityPtr;
    #[no_mangle]
    fn xmlGetDocEntity(doc: *const xmlDoc, name: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlGetDtdEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
    #[no_mangle]
    fn xmlGetParameterEntity(doc: xmlDocPtr, name: *const xmlChar)
     -> xmlEntityPtr;
    /* LIBXML_LEGACY_ENABLED */
    #[no_mangle]
    fn xmlEncodeEntitiesReentrant(doc: xmlDocPtr, input: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlEncodeSpecialChars(doc: *const xmlDoc, input: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlDumpEntitiesTable(buf: xmlBufferPtr, table: xmlEntitiesTablePtr);
    #[no_mangle]
    fn xmlDumpEntityDecl(buf: xmlBufferPtr, ent: xmlEntityPtr);
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn xmlCleanupPredefinedEntities();
    /* LIBXML_ICONV_ENABLED */
    /* LIBXML_ICU_ENABLED */
    /*
 * Interfaces for encoding handlers.
 */
    #[no_mangle]
    fn xmlInitCharEncodingHandlers();
    #[no_mangle]
    fn xmlCleanupCharEncodingHandlers();
    #[no_mangle]
    fn xmlRegisterCharEncodingHandler(handler: xmlCharEncodingHandlerPtr);
    /*
 * Interfaces for encoding names and aliases.
 */
    #[no_mangle]
    fn xmlAddEncodingAlias(name: *const std::os::raw::c_char,
                           alias: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDelEncodingAlias(alias: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlGetEncodingAlias(alias: *const std::os::raw::c_char) -> *const std::os::raw::c_char;
    #[no_mangle]
    fn xmlCleanupEncodingAliases();
    #[no_mangle]
    fn xmlParseCharEncoding(name: *const std::os::raw::c_char) -> xmlCharEncoding;
    #[no_mangle]
    fn xmlGetCharEncodingName(enc: xmlCharEncoding) -> *const std::os::raw::c_char;
    /*
 * Interfaces directly used by the parsers.
 */
    #[no_mangle]
    fn xmlDetectCharEncoding(in_0: *const std::os::raw::c_uchar, len: std::os::raw::c_int)
     -> xmlCharEncoding;
    #[no_mangle]
    fn xmlCharEncOutFunc(handler: *mut xmlCharEncodingHandler,
                         out: xmlBufferPtr, in_0: xmlBufferPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCharEncInFunc(handler: *mut xmlCharEncodingHandler,
                        out: xmlBufferPtr, in_0: xmlBufferPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCharEncFirstLine(handler: *mut xmlCharEncodingHandler,
                           out: xmlBufferPtr, in_0: xmlBufferPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCharEncCloseFunc(handler: *mut xmlCharEncodingHandler)
     -> std::os::raw::c_int;
    /*
 * Export a few useful functions
 */
    #[no_mangle]
    fn UTF8Toisolat1(out: *mut std::os::raw::c_uchar, outlen: *mut std::os::raw::c_int,
                     in_0: *const std::os::raw::c_uchar, inlen: *mut std::os::raw::c_int)
     -> std::os::raw::c_int;
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn isolat1ToUTF8(out: *mut std::os::raw::c_uchar, outlen: *mut std::os::raw::c_int,
                     in_0: *const std::os::raw::c_uchar, inlen: *mut std::os::raw::c_int)
     -> std::os::raw::c_int;
    /* LIBXML_OUTPUT_ENABLED */
    /*
 * Interfaces for input
 */
    #[no_mangle]
    fn xmlCleanupInputCallbacks();
    #[no_mangle]
    fn xmlPopInputCallbacks() -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegisterDefaultInputCallbacks();
    #[no_mangle]
    fn xmlAllocParserInputBuffer(enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateFilename(URI: *const std::os::raw::c_char,
                                          enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateFile(file: *mut FILE, enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateFd(fd: std::os::raw::c_int, enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateMem(mem: *const std::os::raw::c_char,
                                     size: std::os::raw::c_int, enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateStatic(mem: *const std::os::raw::c_char,
                                        size: std::os::raw::c_int,
                                        enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferRead(in_0: xmlParserInputBufferPtr,
                                len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParserInputBufferGrow(in_0: xmlParserInputBufferPtr,
                                len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParserInputBufferPush(in_0: xmlParserInputBufferPtr,
                                len: std::os::raw::c_int, buf: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlFreeParserInputBuffer(in_0: xmlParserInputBufferPtr);
    /*
 * Interfaces for output
 */
    #[no_mangle]
    fn xmlCleanupOutputCallbacks();
    #[no_mangle]
    fn xmlRegisterDefaultOutputCallbacks();
    #[no_mangle]
    fn xmlAllocOutputBuffer(encoder: xmlCharEncodingHandlerPtr)
     -> xmlOutputBufferPtr;
    #[no_mangle]
    fn xmlOutputBufferCreateFilename(URI: *const std::os::raw::c_char,
                                     encoder: xmlCharEncodingHandlerPtr,
                                     compression: std::os::raw::c_int)
     -> xmlOutputBufferPtr;
    #[no_mangle]
    fn xmlOutputBufferCreateFile(file: *mut FILE,
                                 encoder: xmlCharEncodingHandlerPtr)
     -> xmlOutputBufferPtr;
    #[no_mangle]
    fn xmlOutputBufferCreateBuffer(buffer: xmlBufferPtr,
                                   encoder: xmlCharEncodingHandlerPtr)
     -> xmlOutputBufferPtr;
    #[no_mangle]
    fn xmlOutputBufferCreateFd(fd: std::os::raw::c_int,
                               encoder: xmlCharEncodingHandlerPtr)
     -> xmlOutputBufferPtr;
    /* Couple of APIs to get the output without digging into the buffers */
    #[no_mangle]
    fn xmlOutputBufferGetContent(out: xmlOutputBufferPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlOutputBufferWrite(out: xmlOutputBufferPtr, len: std::os::raw::c_int,
                            buf: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlOutputBufferWriteString(out: xmlOutputBufferPtr,
                                  str: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlOutputBufferFlush(out: xmlOutputBufferPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlOutputBufferClose(out: xmlOutputBufferPtr) -> std::os::raw::c_int;
    /*  This function only exists if HTTP support built into the library  */
    #[no_mangle]
    fn xmlRegisterHTTPPostCallbacks();
    /* LIBXML_HTTP_ENABLED */
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn xmlCheckHTTPInput(ctxt: xmlParserCtxtPtr, ret: xmlParserInputPtr)
     -> xmlParserInputPtr;
    /*
 * A predefined entity loader disabling network accesses
 */
    #[no_mangle]
    fn xmlNoNetExternalEntityLoader(URL: *const std::os::raw::c_char,
                                    ID: *const std::os::raw::c_char,
                                    ctxt: xmlParserCtxtPtr)
     -> xmlParserInputPtr;
    /*
 * xmlNormalizeWindowsPath is obsolete, don't use it.
 * Check xmlCanonicPath in uri.h for a better alternative.
 */
    #[no_mangle]
    fn xmlNormalizeWindowsPath(path: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCheckFilename(path: *const std::os::raw::c_char) -> std::os::raw::c_int;
    /* *
 * Default 'file://' protocol callbacks
 */
    #[no_mangle]
    fn xmlFileMatch(filename: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlFileOpen(filename: *const std::os::raw::c_char) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlFileRead(context: *mut std::os::raw::c_void, buffer: *mut std::os::raw::c_char,
                   len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlFileClose(context: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    /* *
 * Default 'http://' protocol callbacks
 */
    #[no_mangle]
    fn xmlIOHTTPMatch(filename: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIOHTTPOpen(filename: *const std::os::raw::c_char) -> *mut std::os::raw::c_void;
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn xmlIOHTTPRead(context: *mut std::os::raw::c_void, buffer: *mut std::os::raw::c_char,
                     len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIOHTTPClose(context: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    /* LIBXML_HTTP_ENABLED */
    /* *
 * Default 'ftp://' protocol callbacks
 */
    #[no_mangle]
    fn xmlIOFTPMatch(filename: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIOFTPOpen(filename: *const std::os::raw::c_char) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlIOFTPRead(context: *mut std::os::raw::c_void, buffer: *mut std::os::raw::c_char,
                    len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIOFTPClose(context: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    /*
 * Init/Cleanup
 */
    #[no_mangle]
    fn xmlInitParser();
    #[no_mangle]
    fn xmlCleanupParser();
    /*
 * Input functions
 */
    #[no_mangle]
    fn xmlParserInputRead(in_0: xmlParserInputPtr, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParserInputGrow(in_0: xmlParserInputPtr, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    /*
 * Basic parsing Interfaces
 */
    #[no_mangle]
    fn xmlParseDoc(cur: *const xmlChar) -> xmlDocPtr;
    #[no_mangle]
    fn xmlParseFile(filename: *const std::os::raw::c_char) -> xmlDocPtr;
    #[no_mangle]
    fn xmlParseMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int)
     -> xmlDocPtr;
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlSubstituteEntitiesDefault(val: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlKeepBlanksDefault(val: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStopParser(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlPedanticParserDefault(val: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlLineNumbersDefault(val: std::os::raw::c_int) -> std::os::raw::c_int;
    /*
 * Recovery mode
 */
    #[no_mangle]
    fn xmlRecoverDoc(cur: *const xmlChar) -> xmlDocPtr;
    #[no_mangle]
    fn xmlRecoverMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlRecoverFile(filename: *const std::os::raw::c_char) -> xmlDocPtr;
    /* LIBXML_SAX1_ENABLED */
    /*
 * Less common routines and SAX interfaces
 */
    #[no_mangle]
    fn xmlParseDocument(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParseExtParsedEnt(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAXUserParseFile(sax: xmlSAXHandlerPtr,
                           user_data: *mut std::os::raw::c_void,
                           filename: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAXUserParseMemory(sax: xmlSAXHandlerPtr,
                             user_data: *mut std::os::raw::c_void,
                             buffer: *const std::os::raw::c_char, size: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAXParseDoc(sax: xmlSAXHandlerPtr, cur: *const xmlChar,
                      recovery: std::os::raw::c_int) -> xmlDocPtr;
    #[no_mangle]
    fn xmlSAXParseMemory(sax: xmlSAXHandlerPtr, buffer: *const std::os::raw::c_char,
                         size: std::os::raw::c_int, recovery: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlSAXParseMemoryWithData(sax: xmlSAXHandlerPtr,
                                 buffer: *const std::os::raw::c_char,
                                 size: std::os::raw::c_int, recovery: std::os::raw::c_int,
                                 data: *mut std::os::raw::c_void) -> xmlDocPtr;
    #[no_mangle]
    fn xmlSAXParseFile(sax: xmlSAXHandlerPtr, filename: *const std::os::raw::c_char,
                       recovery: std::os::raw::c_int) -> xmlDocPtr;
    #[no_mangle]
    fn xmlSAXParseFileWithData(sax: xmlSAXHandlerPtr,
                               filename: *const std::os::raw::c_char,
                               recovery: std::os::raw::c_int, data: *mut std::os::raw::c_void)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlSAXParseEntity(sax: xmlSAXHandlerPtr, filename: *const std::os::raw::c_char)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlParseEntity(filename: *const std::os::raw::c_char) -> xmlDocPtr;
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlSAXParseDTD(sax: xmlSAXHandlerPtr, ExternalID: *const xmlChar,
                      SystemID: *const xmlChar) -> xmlDtdPtr;
    #[no_mangle]
    fn xmlParseDTD(ExternalID: *const xmlChar, SystemID: *const xmlChar)
     -> xmlDtdPtr;
    #[no_mangle]
    fn xmlIOParseDTD(sax: xmlSAXHandlerPtr, input: xmlParserInputBufferPtr,
                     enc: xmlCharEncoding) -> xmlDtdPtr;
    /* LIBXML_VALID_ENABLE */
    #[no_mangle]
    fn xmlParseBalancedChunkMemory(doc: xmlDocPtr, sax: xmlSAXHandlerPtr,
                                   user_data: *mut std::os::raw::c_void,
                                   depth: std::os::raw::c_int, string: *const xmlChar,
                                   lst: *mut xmlNodePtr) -> std::os::raw::c_int;
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlParseInNodeContext(node: xmlNodePtr, data: *const std::os::raw::c_char,
                             datalen: std::os::raw::c_int, options: std::os::raw::c_int,
                             lst: *mut xmlNodePtr) -> xmlParserErrors;
    #[no_mangle]
    fn xmlParseBalancedChunkMemoryRecover(doc: xmlDocPtr,
                                          sax: xmlSAXHandlerPtr,
                                          user_data: *mut std::os::raw::c_void,
                                          depth: std::os::raw::c_int,
                                          string: *const xmlChar,
                                          lst: *mut xmlNodePtr,
                                          recover: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParseExternalEntity(doc: xmlDocPtr, sax: xmlSAXHandlerPtr,
                              user_data: *mut std::os::raw::c_void,
                              depth: std::os::raw::c_int, URL: *const xmlChar,
                              ID: *const xmlChar, lst: *mut xmlNodePtr)
     -> std::os::raw::c_int;
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlParseCtxtExternalEntity(ctx: xmlParserCtxtPtr, URL: *const xmlChar,
                                  ID: *const xmlChar, lst: *mut xmlNodePtr)
     -> std::os::raw::c_int;
    /*
 * Parser contexts handling.
 */
    #[no_mangle]
    fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlInitParserCtxt(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlClearParserCtxt(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlFreeParserCtxt(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlSetupParserForBuffer(ctxt: xmlParserCtxtPtr, buffer: *const xmlChar,
                               filename: *const std::os::raw::c_char);
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlCreateDocParserCtxt(cur: *const xmlChar) -> xmlParserCtxtPtr;
    /*
 * Reading/setting optional parsing features.
 */
    #[no_mangle]
    fn xmlGetFeaturesList(len: *mut std::os::raw::c_int,
                          result: *mut *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlGetFeature(ctxt: xmlParserCtxtPtr, name: *const std::os::raw::c_char,
                     result: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSetFeature(ctxt: xmlParserCtxtPtr, name: *const std::os::raw::c_char,
                     value: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    /* LIBXML_LEGACY_ENABLED */
    /*
 * Interfaces for the Push mode.
 */
    #[no_mangle]
    fn xmlCreatePushParserCtxt(sax: xmlSAXHandlerPtr,
                               user_data: *mut std::os::raw::c_void,
                               chunk: *const std::os::raw::c_char, size: std::os::raw::c_int,
                               filename: *const std::os::raw::c_char)
     -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlParseChunk(ctxt: xmlParserCtxtPtr, chunk: *const std::os::raw::c_char,
                     size: std::os::raw::c_int, terminate: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNewIOInputStream(ctxt: xmlParserCtxtPtr,
                           input: xmlParserInputBufferPtr,
                           enc: xmlCharEncoding) -> xmlParserInputPtr;
    /*
 * Node infos.
 */
    #[no_mangle]
    fn xmlParserFindNodeInfo(ctxt: xmlParserCtxtPtr, node: xmlNodePtr)
     -> *const xmlParserNodeInfo;
    #[no_mangle]
    fn xmlInitNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
    #[no_mangle]
    fn xmlClearNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
    #[no_mangle]
    fn xmlParserFindNodeInfoIndex(seq: xmlParserNodeInfoSeqPtr,
                                  node: xmlNodePtr) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn xmlParserAddNodeInfo(ctxt: xmlParserCtxtPtr,
                            info: xmlParserNodeInfoPtr);
    #[no_mangle]
    fn xmlLoadExternalEntity(URL: *const std::os::raw::c_char,
                             ID: *const std::os::raw::c_char, ctxt: xmlParserCtxtPtr)
     -> xmlParserInputPtr;
    /*
 * Index lookup, actually implemented in the encoding module
 */
    #[no_mangle]
    fn xmlByteConsumed(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlCtxtReset(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlCtxtResetPush(ctxt: xmlParserCtxtPtr, chunk: *const std::os::raw::c_char,
                        size: std::os::raw::c_int, filename: *const std::os::raw::c_char,
                        encoding: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCtxtUseOptions(ctxt: xmlParserCtxtPtr, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReadDoc(cur: *const xmlChar, URL: *const std::os::raw::c_char,
                  encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlReadFile(URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                   options: std::os::raw::c_int) -> xmlDocPtr;
    #[no_mangle]
    fn xmlReadMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int,
                     URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                     options: std::os::raw::c_int) -> xmlDocPtr;
    #[no_mangle]
    fn xmlCtxtReadDoc(ctxt: xmlParserCtxtPtr, cur: *const xmlChar,
                      URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                      options: std::os::raw::c_int) -> xmlDocPtr;
    #[no_mangle]
    fn xmlCtxtReadFile(ctxt: xmlParserCtxtPtr, filename: *const std::os::raw::c_char,
                       encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlCtxtReadMemory(ctxt: xmlParserCtxtPtr, buffer: *const std::os::raw::c_char,
                         size: std::os::raw::c_int, URL: *const std::os::raw::c_char,
                         encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlHasFeature(feature: xmlFeature) -> std::os::raw::c_int;
    #[no_mangle]
    fn putenv(__string: *mut std::os::raw::c_char) -> std::os::raw::c_int;
    /*
 * Summary: SAX2 parser interface used to build the DOM tree
 * Description: those are the default SAX2 interfaces used by
 *              the library when building DOM tree.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    #[no_mangle]
    fn xmlSAX2GetPublicId(ctx: *mut std::os::raw::c_void) -> *const xmlChar;
    #[no_mangle]
    fn xmlSAX2GetSystemId(ctx: *mut std::os::raw::c_void) -> *const xmlChar;
    #[no_mangle]
    fn xmlSAX2SetDocumentLocator(ctx: *mut std::os::raw::c_void,
                                 loc: xmlSAXLocatorPtr);
    #[no_mangle]
    fn xmlSAX2GetLineNumber(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAX2GetColumnNumber(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAX2IsStandalone(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAX2HasInternalSubset(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAX2HasExternalSubset(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAX2InternalSubset(ctx: *mut std::os::raw::c_void, name: *const xmlChar,
                             ExternalID: *const xmlChar,
                             SystemID: *const xmlChar);
    #[no_mangle]
    fn xmlSAX2ExternalSubset(ctx: *mut std::os::raw::c_void, name: *const xmlChar,
                             ExternalID: *const xmlChar,
                             SystemID: *const xmlChar);
    #[no_mangle]
    fn xmlSAX2GetEntity(ctx: *mut std::os::raw::c_void, name: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlSAX2GetParameterEntity(ctx: *mut std::os::raw::c_void, name: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlSAX2ResolveEntity(ctx: *mut std::os::raw::c_void, publicId: *const xmlChar,
                            systemId: *const xmlChar) -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlSAX2EntityDecl(ctx: *mut std::os::raw::c_void, name: *const xmlChar,
                         type_0: std::os::raw::c_int, publicId: *const xmlChar,
                         systemId: *const xmlChar, content: *mut xmlChar);
    #[no_mangle]
    fn xmlSAX2AttributeDecl(ctx: *mut std::os::raw::c_void, elem: *const xmlChar,
                            fullname: *const xmlChar, type_0: std::os::raw::c_int,
                            def: std::os::raw::c_int, defaultValue: *const xmlChar,
                            tree: xmlEnumerationPtr);
    #[no_mangle]
    fn xmlSAX2ElementDecl(ctx: *mut std::os::raw::c_void, name: *const xmlChar,
                          type_0: std::os::raw::c_int, content: xmlElementContentPtr);
    #[no_mangle]
    fn xmlSAX2NotationDecl(ctx: *mut std::os::raw::c_void, name: *const xmlChar,
                           publicId: *const xmlChar,
                           systemId: *const xmlChar);
    #[no_mangle]
    fn xmlSAX2UnparsedEntityDecl(ctx: *mut std::os::raw::c_void, name: *const xmlChar,
                                 publicId: *const xmlChar,
                                 systemId: *const xmlChar,
                                 notationName: *const xmlChar);
    #[no_mangle]
    fn xmlSAX2StartDocument(ctx: *mut std::os::raw::c_void);
    #[no_mangle]
    fn xmlSAX2EndDocument(ctx: *mut std::os::raw::c_void);
    #[no_mangle]
    fn xmlSAX2StartElement(ctx: *mut std::os::raw::c_void, fullname: *const xmlChar,
                           atts: *mut *const xmlChar);
    #[no_mangle]
    fn xmlSAX2EndElement(ctx: *mut std::os::raw::c_void, name: *const xmlChar);
    /* LIBXML_SAX1_ENABLED or LIBXML_HTML_ENABLED or LIBXML_LEGACY_ENABLED */
    #[no_mangle]
    fn xmlSAX2StartElementNs(ctx: *mut std::os::raw::c_void,
                             localname: *const xmlChar,
                             prefix: *const xmlChar, URI: *const xmlChar,
                             nb_namespaces: std::os::raw::c_int,
                             namespaces: *mut *const xmlChar,
                             nb_attributes: std::os::raw::c_int,
                             nb_defaulted: std::os::raw::c_int,
                             attributes: *mut *const xmlChar);
    #[no_mangle]
    fn xmlSAX2EndElementNs(ctx: *mut std::os::raw::c_void, localname: *const xmlChar,
                           prefix: *const xmlChar, URI: *const xmlChar);
    #[no_mangle]
    fn xmlSAX2Reference(ctx: *mut std::os::raw::c_void, name: *const xmlChar);
    #[no_mangle]
    fn xmlSAX2Characters(ctx: *mut std::os::raw::c_void, ch: *const xmlChar,
                         len: std::os::raw::c_int);
    #[no_mangle]
    fn xmlSAX2IgnorableWhitespace(ctx: *mut std::os::raw::c_void, ch: *const xmlChar,
                                  len: std::os::raw::c_int);
    #[no_mangle]
    fn xmlSAX2ProcessingInstruction(ctx: *mut std::os::raw::c_void,
                                    target: *const xmlChar,
                                    data: *const xmlChar);
    #[no_mangle]
    fn xmlSAX2Comment(ctx: *mut std::os::raw::c_void, value: *const xmlChar);
    #[no_mangle]
    fn xmlSAX2CDataBlock(ctx: *mut std::os::raw::c_void, value: *const xmlChar,
                         len: std::os::raw::c_int);
    #[no_mangle]
    fn xmlSAXDefaultVersion(version: std::os::raw::c_int) -> std::os::raw::c_int;
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlSAXVersion(hdlr: *mut xmlSAXHandler, version: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAX2InitDefaultSAXHandler(hdlr: *mut xmlSAXHandler,
                                    warning: std::os::raw::c_int);
    #[no_mangle]
    fn xmlSAX2InitHtmlDefaultSAXHandler(hdlr: *mut xmlSAXHandler);
    #[no_mangle]
    fn htmlDefaultSAXHandlerInit();
    #[no_mangle]
    fn xmlSAX2InitDocbDefaultSAXHandler(hdlr: *mut xmlSAXHandler);
    #[no_mangle]
    fn docbDefaultSAXHandlerInit();
    #[no_mangle]
    fn xmlDefaultSAXHandlerInit();
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    #[no_mangle]
    fn __xmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
    #[no_mangle]
    fn xmlRelaxNGInitTypes() -> std::os::raw::c_int;
    /*
 * Interfaces for parsing.
 */
    #[no_mangle]
    fn xmlRelaxNGNewParserCtxt(URL: *const std::os::raw::c_char)
     -> xmlRelaxNGParserCtxtPtr;
    #[no_mangle]
    fn xmlRelaxNGNewMemParserCtxt(buffer: *const std::os::raw::c_char,
                                  size: std::os::raw::c_int)
     -> xmlRelaxNGParserCtxtPtr;
    #[no_mangle]
    fn xmlRelaxNGNewDocParserCtxt(doc: xmlDocPtr) -> xmlRelaxNGParserCtxtPtr;
    #[no_mangle]
    fn xmlRelaxParserSetFlag(ctxt: xmlRelaxNGParserCtxtPtr, flag: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGFreeParserCtxt(ctxt: xmlRelaxNGParserCtxtPtr);
    #[no_mangle]
    fn xmlRelaxNGGetParserErrors(ctxt: xmlRelaxNGParserCtxtPtr,
                                 err: *mut xmlRelaxNGValidityErrorFunc,
                                 warn: *mut xmlRelaxNGValidityWarningFunc,
                                 ctx: *mut *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGDump(output: *mut FILE, schema: xmlRelaxNGPtr);
    #[no_mangle]
    fn xmlRelaxNGDumpTree(output: *mut FILE, schema: xmlRelaxNGPtr);
    #[no_mangle]
    fn xmlRelaxNGGetValidErrors(ctxt: xmlRelaxNGValidCtxtPtr,
                                err: *mut xmlRelaxNGValidityErrorFunc,
                                warn: *mut xmlRelaxNGValidityWarningFunc,
                                ctx: *mut *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGValidateDoc(ctxt: xmlRelaxNGValidCtxtPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    /*
 * Interfaces for progressive validation when possible
 */
    #[no_mangle]
    fn xmlRelaxNGValidatePushElement(ctxt: xmlRelaxNGValidCtxtPtr,
                                     doc: xmlDocPtr, elem: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGValidatePushCData(ctxt: xmlRelaxNGValidCtxtPtr,
                                   data: *const xmlChar, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGValidatePopElement(ctxt: xmlRelaxNGValidCtxtPtr,
                                    doc: xmlDocPtr, elem: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGValidateFullElement(ctxt: xmlRelaxNGValidCtxtPtr,
                                     doc: xmlDocPtr, elem: xmlNodePtr)
     -> std::os::raw::c_int;
    /*
 * Interfaces for parsing.
 */
    #[no_mangle]
    fn xmlSchemaNewParserCtxt(URL: *const std::os::raw::c_char)
     -> xmlSchemaParserCtxtPtr;
    #[no_mangle]
    fn xmlSchemaNewMemParserCtxt(buffer: *const std::os::raw::c_char,
                                 size: std::os::raw::c_int) -> xmlSchemaParserCtxtPtr;
    #[no_mangle]
    fn xmlSchemaNewDocParserCtxt(doc: xmlDocPtr) -> xmlSchemaParserCtxtPtr;
    #[no_mangle]
    fn xmlSchemaFreeParserCtxt(ctxt: xmlSchemaParserCtxtPtr);
    #[no_mangle]
    fn xmlSchemaGetParserErrors(ctxt: xmlSchemaParserCtxtPtr,
                                err: *mut xmlSchemaValidityErrorFunc,
                                warn: *mut xmlSchemaValidityWarningFunc,
                                ctx: *mut *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaIsValid(ctxt: xmlSchemaValidCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaDump(output: *mut FILE, schema: xmlSchemaPtr);
    #[no_mangle]
    fn xmlSchemaGetValidErrors(ctxt: xmlSchemaValidCtxtPtr,
                               err: *mut xmlSchemaValidityErrorFunc,
                               warn: *mut xmlSchemaValidityWarningFunc,
                               ctx: *mut *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaSetValidOptions(ctxt: xmlSchemaValidCtxtPtr,
                                options: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateSetFilename(vctxt: xmlSchemaValidCtxtPtr,
                                    filename: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlSchemaValidCtxtGetOptions(ctxt: xmlSchemaValidCtxtPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateDoc(ctxt: xmlSchemaValidCtxtPtr, instance: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateOneElement(ctxt: xmlSchemaValidCtxtPtr,
                                   elem: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateStream(ctxt: xmlSchemaValidCtxtPtr,
                               input: xmlParserInputBufferPtr,
                               enc: xmlCharEncoding, sax: xmlSAXHandlerPtr,
                               user_data: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateFile(ctxt: xmlSchemaValidCtxtPtr,
                             filename: *const std::os::raw::c_char,
                             options: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidCtxtGetParserCtxt(ctxt: xmlSchemaValidCtxtPtr)
     -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlSchemaSAXUnplug(plug: xmlSchemaSAXPlugPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNewTextReader(input: xmlParserInputBufferPtr,
                        URI: *const std::os::raw::c_char) -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlNewTextReaderFilename(URI: *const std::os::raw::c_char) -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlFreeTextReader(reader: xmlTextReaderPtr);
    #[no_mangle]
    fn xmlTextReaderSetup(reader: xmlTextReaderPtr,
                          input: xmlParserInputBufferPtr,
                          URL: *const std::os::raw::c_char,
                          encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderRead(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderReadAttributeValue(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderAttributeCount(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderDepth(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderHasAttributes(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderHasValue(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderIsDefault(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderIsEmptyElement(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderNodeType(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderQuoteChar(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderReadState(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderIsNamespaceDecl(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderConstBaseUri(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstLocalName(reader: xmlTextReaderPtr)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstName(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstNamespaceUri(reader: xmlTextReaderPtr)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstPrefix(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstXmlLang(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstString(reader: xmlTextReaderPtr, str: *const xmlChar)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstValue(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderBaseUri(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderLocalName(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderName(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderNamespaceUri(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderPrefix(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderXmlLang(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderValue(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderClose(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderGetAttributeNo(reader: xmlTextReaderPtr, no: std::os::raw::c_int)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderGetAttribute(reader: xmlTextReaderPtr,
                                 name: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderGetAttributeNs(reader: xmlTextReaderPtr,
                                   localName: *const xmlChar,
                                   namespaceURI: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderGetRemainder(reader: xmlTextReaderPtr)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlTextReaderLookupNamespace(reader: xmlTextReaderPtr,
                                    prefix: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderMoveToAttributeNo(reader: xmlTextReaderPtr,
                                      no: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToAttribute(reader: xmlTextReaderPtr,
                                    name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToAttributeNs(reader: xmlTextReaderPtr,
                                      localName: *const xmlChar,
                                      namespaceURI: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToFirstAttribute(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToNextAttribute(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToElement(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderNormalization(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderConstEncoding(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderSetParserProp(reader: xmlTextReaderPtr, prop: std::os::raw::c_int,
                                  value: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderGetParserProp(reader: xmlTextReaderPtr, prop: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderCurrentNode(reader: xmlTextReaderPtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlTextReaderGetParserLineNumber(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderGetParserColumnNumber(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderPreserve(reader: xmlTextReaderPtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlTextReaderPreservePattern(reader: xmlTextReaderPtr,
                                    pattern: *const xmlChar,
                                    namespaces: *mut *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderCurrentDoc(reader: xmlTextReaderPtr) -> xmlDocPtr;
    #[no_mangle]
    fn xmlTextReaderExpand(reader: xmlTextReaderPtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlTextReaderNext(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderNextSibling(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderIsValid(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderRelaxNGValidate(reader: xmlTextReaderPtr,
                                    rng: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderRelaxNGValidateCtxt(reader: xmlTextReaderPtr,
                                        ctxt: xmlRelaxNGValidCtxtPtr,
                                        options: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderRelaxNGSetSchema(reader: xmlTextReaderPtr,
                                     schema: xmlRelaxNGPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderSchemaValidate(reader: xmlTextReaderPtr,
                                   xsd: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderSchemaValidateCtxt(reader: xmlTextReaderPtr,
                                       ctxt: xmlSchemaValidCtxtPtr,
                                       options: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderSetSchema(reader: xmlTextReaderPtr, schema: xmlSchemaPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderConstXmlVersion(reader: xmlTextReaderPtr)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderStandalone(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderByteConsumed(reader: xmlTextReaderPtr) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlReaderWalker(doc: xmlDocPtr) -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlReaderForDoc(cur: *const xmlChar, URL: *const std::os::raw::c_char,
                       encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlReaderForFile(filename: *const std::os::raw::c_char,
                        encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlReaderForMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int,
                          URL: *const std::os::raw::c_char,
                          encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlReaderNewWalker(reader: xmlTextReaderPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReaderNewDoc(reader: xmlTextReaderPtr, cur: *const xmlChar,
                       URL: *const std::os::raw::c_char,
                       encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReaderNewFile(reader: xmlTextReaderPtr,
                        filename: *const std::os::raw::c_char,
                        encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReaderNewMemory(reader: xmlTextReaderPtr,
                          buffer: *const std::os::raw::c_char, size: std::os::raw::c_int,
                          URL: *const std::os::raw::c_char,
                          encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderLocatorLineNumber(locator: xmlTextReaderLocatorPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderLocatorBaseURI(locator: xmlTextReaderLocatorPtr)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderGetErrorHandler(reader: xmlTextReaderPtr,
                                    f: *mut xmlTextReaderErrorFunc,
                                    arg: *mut *mut std::os::raw::c_void);
    /*
 * Init
 */
    #[no_mangle]
    fn xmlNanoFTPInit();
    #[no_mangle]
    fn xmlNanoFTPCleanup();
    /*
 * Creating/freeing contexts.
 */
    #[no_mangle]
    fn xmlNanoFTPNewCtxt(URL: *const std::os::raw::c_char) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlNanoFTPFreeCtxt(ctx: *mut std::os::raw::c_void);
    /*
 * Opening/closing session connections.
 */
    #[no_mangle]
    fn xmlNanoFTPOpen(URL: *const std::os::raw::c_char) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlNanoFTPClose(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoFTPQuit(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoFTPScanProxy(URL: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlNanoFTPProxy(host: *const std::os::raw::c_char, port: std::os::raw::c_int,
                       user: *const std::os::raw::c_char, passwd: *const std::os::raw::c_char,
                       type_0: std::os::raw::c_int);
    #[no_mangle]
    fn xmlNanoFTPUpdateURL(ctx: *mut std::os::raw::c_void, URL: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    /*
 * Rather internal commands.
 */
    #[no_mangle]
    fn xmlNanoFTPGetResponse(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoFTPCheckResponse(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    /*
 * CD/DIR/GET handlers.
 */
    #[no_mangle]
    fn xmlNanoFTPCwd(ctx: *mut std::os::raw::c_void, directory: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoFTPDele(ctx: *mut std::os::raw::c_void, file: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoFTPCloseConnection(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoFTPRead(ctx: *mut std::os::raw::c_void, dest: *mut std::os::raw::c_void,
                      len: std::os::raw::c_int) -> std::os::raw::c_int;
    /*
 * standalone processing
 */
    #[no_mangle]
    fn xmlXIncludeProcess(doc: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeProcessFlags(doc: xmlDocPtr, flags: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeProcessFlagsData(doc: xmlDocPtr, flags: std::os::raw::c_int,
                                   data: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeProcessTreeFlagsData(tree: xmlNodePtr, flags: std::os::raw::c_int,
                                       data: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeProcessTree(tree: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeProcessTreeFlags(tree: xmlNodePtr, flags: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeSetFlags(ctxt: xmlXIncludeCtxtPtr, flags: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeProcessNode(ctxt: xmlXIncludeCtxtPtr, tree: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlPatternMatch(comp: xmlPatternPtr, node: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlPatternStreamable(comp: xmlPatternPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlPatternMaxDepth(comp: xmlPatternPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlPatternMinDepth(comp: xmlPatternPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlPatternFromRoot(comp: xmlPatternPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStreamPushNode(stream: xmlStreamCtxtPtr, name: *const xmlChar,
                         ns: *const xmlChar, nodeType: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStreamPush(stream: xmlStreamCtxtPtr, name: *const xmlChar,
                     ns: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStreamPushAttr(stream: xmlStreamCtxtPtr, name: *const xmlChar,
                         ns: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStreamPop(stream: xmlStreamCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStreamWantsAnyNode(stream: xmlStreamCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn strncpy(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strcmp(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn memset(_: *mut std::os::raw::c_void, _: std::os::raw::c_int, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn strlen(_: *const std::os::raw::c_char) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn htmlEntityLookup(name: *const xmlChar) -> *const htmlEntityDesc;
    #[no_mangle]
    fn htmlEntityValueLookup(value: std::os::raw::c_uint) -> *const htmlEntityDesc;
    #[no_mangle]
    fn htmlIsAutoClosed(doc: htmlDocPtr, elem: htmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlAutoCloseTag(doc: htmlDocPtr, name: *const xmlChar,
                        elem: htmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlParseEntityRef(ctxt: htmlParserCtxtPtr, str: *mut *const xmlChar)
     -> *const htmlEntityDesc;
    #[no_mangle]
    fn htmlParseCharRef(ctxt: htmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlParseElement(ctxt: htmlParserCtxtPtr);
    #[no_mangle]
    fn htmlNewParserCtxt() -> htmlParserCtxtPtr;
    #[no_mangle]
    fn htmlCreateMemoryParserCtxt(buffer: *const std::os::raw::c_char,
                                  size: std::os::raw::c_int) -> htmlParserCtxtPtr;
    #[no_mangle]
    fn htmlParseDocument(ctxt: htmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlSAXParseDoc(cur: *const xmlChar, encoding: *const std::os::raw::c_char,
                       sax: htmlSAXHandlerPtr, userData: *mut std::os::raw::c_void)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlParseDoc(cur: *const xmlChar, encoding: *const std::os::raw::c_char)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlSAXParseFile(filename: *const std::os::raw::c_char,
                        encoding: *const std::os::raw::c_char, sax: htmlSAXHandlerPtr,
                        userData: *mut std::os::raw::c_void) -> htmlDocPtr;
    #[no_mangle]
    fn htmlParseFile(filename: *const std::os::raw::c_char,
                     encoding: *const std::os::raw::c_char) -> htmlDocPtr;
    #[no_mangle]
    fn UTF8ToHtml(out: *mut std::os::raw::c_uchar, outlen: *mut std::os::raw::c_int,
                  in_0: *const std::os::raw::c_uchar, inlen: *mut std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlEncodeEntities(out: *mut std::os::raw::c_uchar, outlen: *mut std::os::raw::c_int,
                          in_0: *const std::os::raw::c_uchar, inlen: *mut std::os::raw::c_int,
                          quoteChar: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlIsScriptAttribute(name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlHandleOmittedElem(val: std::os::raw::c_int) -> std::os::raw::c_int;
    /* *
 * Interfaces for the Push mode.
 */
    #[no_mangle]
    fn htmlCreatePushParserCtxt(sax: htmlSAXHandlerPtr,
                                user_data: *mut std::os::raw::c_void,
                                chunk: *const std::os::raw::c_char, size: std::os::raw::c_int,
                                filename: *const std::os::raw::c_char,
                                enc: xmlCharEncoding) -> htmlParserCtxtPtr;
    #[no_mangle]
    fn htmlParseChunk(ctxt: htmlParserCtxtPtr, chunk: *const std::os::raw::c_char,
                      size: std::os::raw::c_int, terminate: std::os::raw::c_int)
     -> std::os::raw::c_int;
    /* LIBXML_PUSH_ENABLED */
    #[no_mangle]
    fn htmlFreeParserCtxt(ctxt: htmlParserCtxtPtr);
    #[no_mangle]
    fn htmlCtxtReset(ctxt: htmlParserCtxtPtr);
    #[no_mangle]
    fn htmlCtxtUseOptions(ctxt: htmlParserCtxtPtr, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlReadDoc(cur: *const xmlChar, URL: *const std::os::raw::c_char,
                   encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlReadFile(URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                    options: std::os::raw::c_int) -> htmlDocPtr;
    #[no_mangle]
    fn htmlReadMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int,
                      URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                      options: std::os::raw::c_int) -> htmlDocPtr;
    #[no_mangle]
    fn htmlCtxtReadDoc(ctxt: xmlParserCtxtPtr, cur: *const xmlChar,
                       URL: *const std::os::raw::c_char,
                       encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlCtxtReadFile(ctxt: xmlParserCtxtPtr, filename: *const std::os::raw::c_char,
                        encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlCtxtReadMemory(ctxt: xmlParserCtxtPtr, buffer: *const std::os::raw::c_char,
                          size: std::os::raw::c_int, URL: *const std::os::raw::c_char,
                          encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> htmlDocPtr;
    /* Using htmlElemDesc rather than name here, to emphasise the fact
   that otherwise there's a lookup overhead
*/
    #[no_mangle]
    fn htmlAttrAllowed(_: *const htmlElemDesc, _: *const xmlChar,
                       _: std::os::raw::c_int) -> htmlStatus;
    #[no_mangle]
    fn htmlElementAllowedHere(_: *const htmlElemDesc, _: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlElementStatusHere(_: *const htmlElemDesc, _: *const htmlElemDesc)
     -> htmlStatus;
    #[no_mangle]
    fn htmlNodeStatus(_: htmlNodePtr, _: std::os::raw::c_int) -> htmlStatus;
    /*
 * Summary: specific APIs to process HTML tree, especially serialization
 * Description: this module implements a few function needed to process
 *              tree in an HTML specific way.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * HTML_TEXT_NODE:
 *
 * Macro. A text node in a HTML document is really implemented
 * the same way as a text node in an XML document.
 */
    /* *
 * HTML_ENTITY_REF_NODE:
 *
 * Macro. An entity reference in a HTML document is really implemented
 * the same way as an entity reference in an XML document.
 */
    /* *
 * HTML_COMMENT_NODE:
 *
 * Macro. A comment in a HTML document is really implemented
 * the same way as a comment in an XML document.
 */
    /* *
 * HTML_PRESERVE_NODE:
 *
 * Macro. A preserved node in a HTML document is really implemented
 * the same way as a CDATA section in an XML document.
 */
    /* *
 * HTML_PI_NODE:
 *
 * Macro. A processing instruction in a HTML document is really implemented
 * the same way as a processing instruction in an XML document.
 */
    #[no_mangle]
    fn htmlNewDoc(URI: *const xmlChar, ExternalID: *const xmlChar)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlNewDocNoDtD(URI: *const xmlChar, ExternalID: *const xmlChar)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlGetMetaEncoding(doc: htmlDocPtr) -> *const xmlChar;
    #[no_mangle]
    fn htmlSetMetaEncoding(doc: htmlDocPtr, encoding: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlDocDumpMemory(cur: xmlDocPtr, mem: *mut *mut xmlChar,
                         size: *mut std::os::raw::c_int);
    #[no_mangle]
    fn htmlDocDumpMemoryFormat(cur: xmlDocPtr, mem: *mut *mut xmlChar,
                               size: *mut std::os::raw::c_int, format: std::os::raw::c_int);
    #[no_mangle]
    fn htmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlSaveFile(filename: *const std::os::raw::c_char, cur: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlNodeDump(buf: xmlBufferPtr, doc: xmlDocPtr, cur: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlNodeDumpFile(out: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
    #[no_mangle]
    fn htmlNodeDumpFileFormat(out: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr,
                              encoding: *const std::os::raw::c_char,
                              format: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlSaveFileEnc(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                       encoding: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlSaveFileFormat(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                          encoding: *const std::os::raw::c_char, format: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlNodeDumpFormatOutput(buf: xmlOutputBufferPtr, doc: xmlDocPtr,
                                cur: xmlNodePtr,
                                encoding: *const std::os::raw::c_char,
                                format: std::os::raw::c_int);
    #[no_mangle]
    fn htmlDocContentDumpOutput(buf: xmlOutputBufferPtr, cur: xmlDocPtr,
                                encoding: *const std::os::raw::c_char);
    #[no_mangle]
    fn htmlDocContentDumpFormatOutput(buf: xmlOutputBufferPtr, cur: xmlDocPtr,
                                      encoding: *const std::os::raw::c_char,
                                      format: std::os::raw::c_int);
    #[no_mangle]
    fn htmlNodeDumpOutput(buf: xmlOutputBufferPtr, doc: xmlDocPtr,
                          cur: xmlNodePtr, encoding: *const std::os::raw::c_char);
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn htmlIsBooleanAttr(name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlConvertSGMLCatalog(catal: xmlCatalogPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlACatalogAdd(catal: xmlCatalogPtr, type_0: *const xmlChar,
                      orig: *const xmlChar, replace: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlACatalogRemove(catal: xmlCatalogPtr, value: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlACatalogResolve(catal: xmlCatalogPtr, pubID: *const xmlChar,
                          sysID: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlACatalogResolveSystem(catal: xmlCatalogPtr, sysID: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlACatalogResolvePublic(catal: xmlCatalogPtr, pubID: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlACatalogResolveURI(catal: xmlCatalogPtr, URI: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlACatalogDump(catal: xmlCatalogPtr, out: *mut FILE);
    #[no_mangle]
    fn xmlCatalogIsEmpty(catal: xmlCatalogPtr) -> std::os::raw::c_int;
    /*
 * Global operations.
 */
    #[no_mangle]
    fn xmlInitializeCatalog();
    #[no_mangle]
    fn xmlLoadCatalog(filename: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlLoadCatalogs(paths: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlCatalogCleanup();
    #[no_mangle]
    fn xmlCatalogDump(out: *mut FILE);
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn xmlCatalogResolve(pubID: *const xmlChar, sysID: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogResolveSystem(sysID: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogResolvePublic(pubID: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogResolveURI(URI: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogAdd(type_0: *const xmlChar, orig: *const xmlChar,
                     replace: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCatalogRemove(value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParseCatalogFile(filename: *const std::os::raw::c_char) -> xmlDocPtr;
    #[no_mangle]
    fn xmlCatalogConvert() -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCatalogLocalResolve(catalogs: *mut std::os::raw::c_void,
                              pubID: *const xmlChar, sysID: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogLocalResolveURI(catalogs: *mut std::os::raw::c_void,
                                 URI: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogSetDefaultPrefer(prefer: xmlCatalogPrefer)
     -> xmlCatalogPrefer;
    #[no_mangle]
    fn xmlCatalogSetDefaults(allow: xmlCatalogAllow);
    #[no_mangle]
    fn xmlCatalogGetDefaults() -> xmlCatalogAllow;
    /* *
 * Range checking routine
 */
    #[no_mangle]
    fn xmlCharInRange(val: std::os::raw::c_uint, group: *const xmlChRangeGroup)
     -> std::os::raw::c_int;
    /* *
 * xmlIsPubidChar_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
    /* *
 * xmlIsPubidCharQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
    #[no_mangle]
    fn xmlIsBaseChar(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsBlank(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsChar(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsCombining(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsDigit(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsExtender(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsIdeographic(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsPubidChar(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    /*
 * Summary: minimal HTTP implementation
 * Description: minimal HTTP implementation allowing to fetch resources
 *              like external subset.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    #[no_mangle]
    fn xmlNanoHTTPInit();
    #[no_mangle]
    fn xmlNanoHTTPCleanup();
    #[no_mangle]
    fn xmlNanoHTTPScanProxy(URL: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlNanoHTTPFetch(URL: *const std::os::raw::c_char,
                        filename: *const std::os::raw::c_char,
                        contentType: *mut *mut std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoHTTPOpen(URL: *const std::os::raw::c_char,
                       contentType: *mut *mut std::os::raw::c_char)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlNanoHTTPOpenRedir(URL: *const std::os::raw::c_char,
                            contentType: *mut *mut std::os::raw::c_char,
                            redir: *mut *mut std::os::raw::c_char)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlNanoHTTPReturnCode(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoHTTPAuthHeader(ctx: *mut std::os::raw::c_void) -> *const std::os::raw::c_char;
    #[no_mangle]
    fn xmlNanoHTTPContentLength(ctx: *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoHTTPEncoding(ctx: *mut std::os::raw::c_void) -> *const std::os::raw::c_char;
    #[no_mangle]
    fn xmlNanoHTTPMimeType(ctx: *mut std::os::raw::c_void) -> *const std::os::raw::c_char;
    #[no_mangle]
    fn xmlNanoHTTPRead(ctx: *mut std::os::raw::c_void, dest: *mut std::os::raw::c_void,
                       len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNanoHTTPSave(ctxt: *mut std::os::raw::c_void, filename: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn xmlNanoHTTPClose(ctx: *mut std::os::raw::c_void);
    /*
 * Function to finish the work of the macros where needed.
 */
    #[no_mangle]
    fn xmlIsLetter(c: std::os::raw::c_int) -> std::os::raw::c_int;
    /* *
 * Parser context.
 */
    #[no_mangle]
    fn xmlCreateFileParserCtxt(filename: *const std::os::raw::c_char)
     -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlCreateURLParserCtxt(filename: *const std::os::raw::c_char,
                              options: std::os::raw::c_int) -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlCreateMemoryParserCtxt(buffer: *const std::os::raw::c_char,
                                 size: std::os::raw::c_int) -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlCreateEntityParserCtxt(URL: *const xmlChar, ID: *const xmlChar,
                                 base: *const xmlChar) -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlSwitchEncoding(ctxt: xmlParserCtxtPtr, enc: xmlCharEncoding)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSwitchToEncoding(ctxt: xmlParserCtxtPtr,
                           handler: xmlCharEncodingHandlerPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSwitchInputEncoding(ctxt: xmlParserCtxtPtr,
                              input: xmlParserInputPtr,
                              handler: xmlCharEncodingHandlerPtr)
     -> std::os::raw::c_int;
    /* *
 * Input Streams.
 */
    #[no_mangle]
    fn xmlNewStringInputStream(ctxt: xmlParserCtxtPtr, buffer: *const xmlChar)
     -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlNewEntityInputStream(ctxt: xmlParserCtxtPtr, entity: xmlEntityPtr)
     -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlPushInput(ctxt: xmlParserCtxtPtr, input: xmlParserInputPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlPopInput(ctxt: xmlParserCtxtPtr) -> xmlChar;
    #[no_mangle]
    fn xmlFreeInputStream(input: xmlParserInputPtr);
    #[no_mangle]
    fn xmlNewInputFromFile(ctxt: xmlParserCtxtPtr,
                           filename: *const std::os::raw::c_char)
     -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlNewInputStream(ctxt: xmlParserCtxtPtr) -> xmlParserInputPtr;
    /* *
 * Namespaces.
 */
    #[no_mangle]
    fn xmlSplitQName(ctxt: xmlParserCtxtPtr, name: *const xmlChar,
                     prefix: *mut *mut xmlChar) -> *mut xmlChar;
    /* *
 * XML_SUBSTITUTE_NONE:
 *
 * If no entities need to be substituted.
 */
    /* *
 * XML_SUBSTITUTE_REF:
 *
 * Whether general entities need to be substituted.
 */
    /* *
 * XML_SUBSTITUTE_PEREF:
 *
 * Whether parameter entities need to be substituted.
 */
    /* *
 * XML_SUBSTITUTE_BOTH:
 *
 * Both general and parameter entities need to be substituted.
 */
    #[no_mangle]
    fn xmlStringDecodeEntities(ctxt: xmlParserCtxtPtr, str: *const xmlChar,
                               what: std::os::raw::c_int, end: xmlChar, end2: xmlChar,
                               end3: xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStringLenDecodeEntities(ctxt: xmlParserCtxtPtr, str: *const xmlChar,
                                  len: std::os::raw::c_int, what: std::os::raw::c_int,
                                  end: xmlChar, end2: xmlChar, end3: xmlChar)
     -> *mut xmlChar;
    /*
 * Generated by MACROS on top of parser.c c.f. PUSH_AND_POP.
 */
    #[no_mangle]
    fn nodePush(ctxt: xmlParserCtxtPtr, value: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn nodePop(ctxt: xmlParserCtxtPtr) -> xmlNodePtr;
    #[no_mangle]
    fn inputPush(ctxt: xmlParserCtxtPtr, value: xmlParserInputPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn inputPop(ctxt: xmlParserCtxtPtr) -> xmlParserInputPtr;
    #[no_mangle]
    fn namePop(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    #[no_mangle]
    fn namePush(ctxt: xmlParserCtxtPtr, value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStringCurrentChar(ctxt: xmlParserCtxtPtr, cur: *const xmlChar,
                            len: *mut std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCheckLanguageID(lang: *const xmlChar) -> std::os::raw::c_int;
    /*
 * Really core function shared with HTML parser.
 */
    #[no_mangle]
    fn xmlCurrentChar(ctxt: xmlParserCtxtPtr, len: *mut std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCopyCharMultiByte(out: *mut xmlChar, val: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCopyChar(len: std::os::raw::c_int, out: *mut xmlChar, val: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNextChar(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParserInputShrink(in_0: xmlParserInputPtr);
    /*
 * Actually comes from the HTML parser but launched from the init stuff.
 */
    #[no_mangle]
    fn htmlInitAutoClose();
    #[no_mangle]
    fn htmlCreateFileParserCtxt(filename: *const std::os::raw::c_char,
                                encoding: *const std::os::raw::c_char)
     -> htmlParserCtxtPtr;
    #[no_mangle]
    fn xmlSchematronValidateDoc(ctxt: xmlSchematronValidCtxtPtr,
                                instance: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBuildURI(URI: *const xmlChar, base: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlBuildRelativeURI(URI: *const xmlChar, base: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseURIReference(uri: xmlURIPtr, str: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSaveUri(uri: xmlURIPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlPrintURI(stream: *mut FILE, uri: xmlURIPtr);
    #[no_mangle]
    fn xmlURIEscapeStr(str: *const xmlChar, list: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlNormalizeURIPath(path: *mut std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlURIEscape(str: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCanonicPath(path: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlPathToURI(path: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlSaveDoc(ctxt: xmlSaveCtxtPtr, doc: xmlDocPtr) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlSaveTree(ctxt: xmlSaveCtxtPtr, node: xmlNodePtr) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlSaveFlush(ctxt: xmlSaveCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSaveClose(ctxt: xmlSaveCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaInitTypes();
    #[no_mangle]
    fn xmlSchemaCleanupTypes();
    #[no_mangle]
    fn xmlSchemaGetPredefinedType(name: *const xmlChar, ns: *const xmlChar)
     -> xmlSchemaTypePtr;
    #[no_mangle]
    fn xmlSchemaValidatePredefinedType(type_0: xmlSchemaTypePtr,
                                       value: *const xmlChar,
                                       val: *mut xmlSchemaValPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValPredefTypeNode(type_0: xmlSchemaTypePtr,
                                  value: *const xmlChar,
                                  val: *mut xmlSchemaValPtr, node: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateFacet(base: xmlSchemaTypePtr,
                              facet: xmlSchemaFacetPtr, value: *const xmlChar,
                              val: xmlSchemaValPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateFacetWhtsp(facet: xmlSchemaFacetPtr,
                                   fws: xmlSchemaWhitespaceValueType,
                                   valType: xmlSchemaValType,
                                   value: *const xmlChar,
                                   val: xmlSchemaValPtr,
                                   ws: xmlSchemaWhitespaceValueType)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaCheckFacet(facet: xmlSchemaFacetPtr,
                           typeDecl: xmlSchemaTypePtr,
                           ctxt: xmlSchemaParserCtxtPtr, name: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaCompareValues(x: xmlSchemaValPtr, y: xmlSchemaValPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaGetBuiltInListSimpleTypeItemType(type_0: xmlSchemaTypePtr)
     -> xmlSchemaTypePtr;
    #[no_mangle]
    fn xmlSchemaValidateListSimpleTypeFacet(facet: xmlSchemaFacetPtr,
                                            value: *const xmlChar,
                                            actualLen: std::os::raw::c_ulong,
                                            expectedLen: *mut std::os::raw::c_ulong)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaGetBuiltInType(type_0: xmlSchemaValType) -> xmlSchemaTypePtr;
    #[no_mangle]
    fn xmlSchemaIsBuiltInTypeFacet(type_0: xmlSchemaTypePtr,
                                   facetType: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaCollapseString(value: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlSchemaWhiteSpaceReplace(value: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlSchemaGetFacetValueAsULong(facet: xmlSchemaFacetPtr)
     -> std::os::raw::c_ulong;
    #[no_mangle]
    fn xmlSchemaValidateLengthFacet(type_0: xmlSchemaTypePtr,
                                    facet: xmlSchemaFacetPtr,
                                    value: *const xmlChar,
                                    val: xmlSchemaValPtr,
                                    length: *mut std::os::raw::c_ulong)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateLengthFacetWhtsp(facet: xmlSchemaFacetPtr,
                                         valType: xmlSchemaValType,
                                         value: *const xmlChar,
                                         val: xmlSchemaValPtr,
                                         length: *mut std::os::raw::c_ulong,
                                         ws: xmlSchemaWhitespaceValueType)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValPredefTypeNodeNoNorm(type_0: xmlSchemaTypePtr,
                                        value: *const xmlChar,
                                        val: *mut xmlSchemaValPtr,
                                        node: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaGetCanonValue(val: xmlSchemaValPtr,
                              retValue: *mut *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaGetCanonValueWhtsp(val: xmlSchemaValPtr,
                                   retValue: *mut *const xmlChar,
                                   ws: xmlSchemaWhitespaceValueType)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValueAppend(prev: xmlSchemaValPtr, cur: xmlSchemaValPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValueGetAsString(val: xmlSchemaValPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlSchemaValueGetAsBoolean(val: xmlSchemaValPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaCompareValuesWhtsp(x: xmlSchemaValPtr,
                                   xws: xmlSchemaWhitespaceValueType,
                                   y: xmlSchemaValPtr,
                                   yws: xmlSchemaWhitespaceValueType)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaGetValType(val: xmlSchemaValPtr) -> xmlSchemaValType;
    /*
 * Constructors & Destructor
 */
    #[no_mangle]
    fn xmlNewTextWriter(out: xmlOutputBufferPtr) -> xmlTextWriterPtr;
    #[no_mangle]
    fn xmlNewTextWriterFilename(uri: *const std::os::raw::c_char,
                                compression: std::os::raw::c_int) -> xmlTextWriterPtr;
    #[no_mangle]
    fn xmlNewTextWriterMemory(buf: xmlBufferPtr, compression: std::os::raw::c_int)
     -> xmlTextWriterPtr;
    #[no_mangle]
    fn xmlNewTextWriterPushParser(ctxt: xmlParserCtxtPtr,
                                  compression: std::os::raw::c_int)
     -> xmlTextWriterPtr;
    #[no_mangle]
    fn xmlNewTextWriterTree(doc: xmlDocPtr, node: xmlNodePtr,
                            compression: std::os::raw::c_int) -> xmlTextWriterPtr;
    #[no_mangle]
    fn xmlFreeTextWriter(writer: xmlTextWriterPtr);
    /*
 * Functions
 */
    /*
 * Document
 */
    #[no_mangle]
    fn xmlTextWriterStartDocument(writer: xmlTextWriterPtr,
                                  version: *const std::os::raw::c_char,
                                  encoding: *const std::os::raw::c_char,
                                  standalone: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndDocument(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    /*
 * Comments
 */
    #[no_mangle]
    fn xmlTextWriterStartComment(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndComment(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteComment(writer: xmlTextWriterPtr,
                                 content: *const xmlChar) -> std::os::raw::c_int;
    /*
 * Elements
 */
    #[no_mangle]
    fn xmlTextWriterStartElement(writer: xmlTextWriterPtr,
                                 name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterStartElementNS(writer: xmlTextWriterPtr,
                                   prefix: *const xmlChar,
                                   name: *const xmlChar,
                                   namespaceURI: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndElement(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterFullEndElement(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteElement(writer: xmlTextWriterPtr,
                                 name: *const xmlChar,
                                 content: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteElementNS(writer: xmlTextWriterPtr,
                                   prefix: *const xmlChar,
                                   name: *const xmlChar,
                                   namespaceURI: *const xmlChar,
                                   content: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteRawLen(writer: xmlTextWriterPtr,
                                content: *const xmlChar, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteRaw(writer: xmlTextWriterPtr,
                             content: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteString(writer: xmlTextWriterPtr,
                                content: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteBase64(writer: xmlTextWriterPtr,
                                data: *const std::os::raw::c_char, start: std::os::raw::c_int,
                                len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteBinHex(writer: xmlTextWriterPtr,
                                data: *const std::os::raw::c_char, start: std::os::raw::c_int,
                                len: std::os::raw::c_int) -> std::os::raw::c_int;
    /*
 * Attributes
 */
    #[no_mangle]
    fn xmlTextWriterStartAttribute(writer: xmlTextWriterPtr,
                                   name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterStartAttributeNS(writer: xmlTextWriterPtr,
                                     prefix: *const xmlChar,
                                     name: *const xmlChar,
                                     namespaceURI: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndAttribute(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteAttribute(writer: xmlTextWriterPtr,
                                   name: *const xmlChar,
                                   content: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteAttributeNS(writer: xmlTextWriterPtr,
                                     prefix: *const xmlChar,
                                     name: *const xmlChar,
                                     namespaceURI: *const xmlChar,
                                     content: *const xmlChar) -> std::os::raw::c_int;
    /*
 * PI's
 */
    #[no_mangle]
    fn xmlTextWriterStartPI(writer: xmlTextWriterPtr, target: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndPI(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWritePI(writer: xmlTextWriterPtr, target: *const xmlChar,
                            content: *const xmlChar) -> std::os::raw::c_int;
    /* *
 * xmlTextWriterWriteProcessingInstruction:
 *
 * This macro maps to xmlTextWriterWritePI
 */
    /*
 * CDATA
 */
    #[no_mangle]
    fn xmlTextWriterStartCDATA(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndCDATA(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteCDATA(writer: xmlTextWriterPtr,
                               content: *const xmlChar) -> std::os::raw::c_int;
    /*
 * DTD
 */
    #[no_mangle]
    fn xmlTextWriterStartDTD(writer: xmlTextWriterPtr, name: *const xmlChar,
                             pubid: *const xmlChar, sysid: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndDTD(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteDTD(writer: xmlTextWriterPtr, name: *const xmlChar,
                             pubid: *const xmlChar, sysid: *const xmlChar,
                             subset: *const xmlChar) -> std::os::raw::c_int;
    /* *
 * xmlTextWriterWriteDocType:
 *
 * this macro maps to xmlTextWriterWriteDTD
 */
    /*
 * DTD element definition
 */
    #[no_mangle]
    fn xmlTextWriterStartDTDElement(writer: xmlTextWriterPtr,
                                    name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndDTDElement(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteDTDElement(writer: xmlTextWriterPtr,
                                    name: *const xmlChar,
                                    content: *const xmlChar) -> std::os::raw::c_int;
    /*
 * DTD attribute list definition
 */
    #[no_mangle]
    fn xmlTextWriterStartDTDAttlist(writer: xmlTextWriterPtr,
                                    name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndDTDAttlist(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteDTDAttlist(writer: xmlTextWriterPtr,
                                    name: *const xmlChar,
                                    content: *const xmlChar) -> std::os::raw::c_int;
    /*
 * DTD entity definition
 */
    #[no_mangle]
    fn xmlTextWriterStartDTDEntity(writer: xmlTextWriterPtr, pe: std::os::raw::c_int,
                                   name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterEndDTDEntity(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteDTDInternalEntity(writer: xmlTextWriterPtr,
                                           pe: std::os::raw::c_int,
                                           name: *const xmlChar,
                                           content: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteDTDExternalEntity(writer: xmlTextWriterPtr,
                                           pe: std::os::raw::c_int,
                                           name: *const xmlChar,
                                           pubid: *const xmlChar,
                                           sysid: *const xmlChar,
                                           ndataid: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteDTDExternalEntityContents(writer: xmlTextWriterPtr,
                                                   pubid: *const xmlChar,
                                                   sysid: *const xmlChar,
                                                   ndataid: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterWriteDTDEntity(writer: xmlTextWriterPtr, pe: std::os::raw::c_int,
                                   name: *const xmlChar,
                                   pubid: *const xmlChar,
                                   sysid: *const xmlChar,
                                   ndataid: *const xmlChar,
                                   content: *const xmlChar) -> std::os::raw::c_int;
    /*
 * DTD notation definition
 */
    #[no_mangle]
    fn xmlTextWriterWriteDTDNotation(writer: xmlTextWriterPtr,
                                     name: *const xmlChar,
                                     pubid: *const xmlChar,
                                     sysid: *const xmlChar) -> std::os::raw::c_int;
    /*
 * Indentation
 */
    #[no_mangle]
    fn xmlTextWriterSetIndent(writer: xmlTextWriterPtr, indent: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterSetIndentString(writer: xmlTextWriterPtr,
                                    str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextWriterSetQuoteChar(writer: xmlTextWriterPtr, quotechar: xmlChar)
     -> std::os::raw::c_int;
    /*
 * misc
 */
    #[no_mangle]
    fn xmlTextWriterFlush(writer: xmlTextWriterPtr) -> std::os::raw::c_int;
    /* used to limit Pop on the stack */
    /* ***********************************************************************
 *									*
 *			Public API					*
 *									*
 ************************************************************************/
    /* *
 * Objects and Nodesets handling
 */
    #[no_mangle]
    static mut xmlXPathNAN: std::os::raw::c_double;
    /* These macros may later turn into functions */
/* *
 * xmlXPathNodeSetGetLength:
 * @ns:  a node-set
 *
 * Implement a functionality similar to the DOM NodeList.length.
 *
 * Returns the number of nodes in the node-set.
 */
    /* *
 * xmlXPathNodeSetItem:
 * @ns:  a node-set
 * @index:  index of a node in the set
 *
 * Implements a functionality similar to the DOM NodeList.item().
 *
 * Returns the xmlNodePtr at the given @index in @ns or NULL if
 *         @index is out of range (0 to length-1)
 */
    /* *
 * xmlXPathNodeSetIsEmpty:
 * @ns: a node-set
 *
 * Checks whether @ns is empty or not.
 *
 * Returns %TRUE if @ns is an empty node-set.
 */
    #[no_mangle]
    fn xmlXPathFreeObject(obj: xmlXPathObjectPtr);
    #[no_mangle]
    fn xmlXPathNodeSetCreate(val: xmlNodePtr) -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathFreeNodeSet(obj: xmlNodeSetPtr);
    #[no_mangle]
    fn xmlXPathObjectCopy(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathCmpNodes(node1: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    /* *
 * Conversion functions to basic types.
 */
    #[no_mangle]
    fn xmlXPathCastNumberToBoolean(val: std::os::raw::c_double) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathCastStringToBoolean(val: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathCastNodeSetToBoolean(ns: xmlNodeSetPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathCastToBoolean(val: xmlXPathObjectPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathCastBooleanToNumber(val: std::os::raw::c_int) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathCastStringToNumber(val: *const xmlChar) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathCastNodeToNumber(node: xmlNodePtr) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathCastNodeSetToNumber(ns: xmlNodeSetPtr) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathCastToNumber(val: xmlXPathObjectPtr) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathCastBooleanToString(val: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathCastNumberToString(val: std::os::raw::c_double) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathCastNodeToString(node: xmlNodePtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathCastNodeSetToString(ns: xmlNodeSetPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathCastToString(val: xmlXPathObjectPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathConvertBoolean(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathConvertNumber(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathConvertString(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathContextSetCache(ctxt: xmlXPathContextPtr, active: std::os::raw::c_int,
                               value: std::os::raw::c_int, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    /* *
 * Evaluation functions.
 */
    #[no_mangle]
    fn xmlXPathOrderDocElems(doc: xmlDocPtr) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlXPathSetContextNode(node: xmlNodePtr, ctx: xmlXPathContextPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNodeEval(node: xmlNodePtr, str: *const xmlChar,
                        ctx: xmlXPathContextPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathEval(str: *const xmlChar, ctx: xmlXPathContextPtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathEvalExpression(str: *const xmlChar, ctxt: xmlXPathContextPtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathEvalPredicate(ctxt: xmlXPathContextPtr, res: xmlXPathObjectPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathCompiledEval(comp: xmlXPathCompExprPtr,
                            ctx: xmlXPathContextPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathCompiledEvalToBoolean(comp: xmlXPathCompExprPtr,
                                     ctxt: xmlXPathContextPtr) -> std::os::raw::c_int;
    /* LIBXML_XPATH_ENABLED */
    #[no_mangle]
    fn xmlXPathInit();
    #[no_mangle]
    fn xmlXPathIsNaN(val: std::os::raw::c_double) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathIsInf(val: std::os::raw::c_double) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPtrNewRange(start: xmlNodePtr, startindex: std::os::raw::c_int,
                       end: xmlNodePtr, endindex: std::os::raw::c_int)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewRangePoints(start: xmlXPathObjectPtr, end: xmlXPathObjectPtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewRangeNodePoint(start: xmlNodePtr, end: xmlXPathObjectPtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewRangePointNode(start: xmlXPathObjectPtr, end: xmlNodePtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewRangeNodes(start: xmlNodePtr, end: xmlNodePtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewLocationSetNodes(start: xmlNodePtr, end: xmlNodePtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewLocationSetNodeSet(set: xmlNodeSetPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewRangeNodeObject(start: xmlNodePtr, end: xmlXPathObjectPtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewCollapsedRange(start: xmlNodePtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrLocationSetAdd(cur: xmlLocationSetPtr, val: xmlXPathObjectPtr);
    #[no_mangle]
    fn xmlXPtrWrapLocationSet(val: xmlLocationSetPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrLocationSetDel(cur: xmlLocationSetPtr, val: xmlXPathObjectPtr);
    #[no_mangle]
    fn xmlXPtrLocationSetRemove(cur: xmlLocationSetPtr, val: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPtrEval(str: *const xmlChar, ctx: xmlXPathContextPtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrRangeToFunction(ctxt: xmlXPathParserContextPtr,
                              nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPtrBuildNodeList(obj: xmlXPathObjectPtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPtrEvalRangePredicate(ctxt: xmlXPathParserContextPtr);
    /*
 * Summary: Tree debugging APIs
 * Description: Interfaces to a set of routines used for debugging the tree
 *              produced by the XML parser.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * The standard Dump routines.
 */
    #[no_mangle]
    fn xmlDebugDumpString(output: *mut FILE, str: *const xmlChar);
    #[no_mangle]
    fn xmlDebugDumpAttr(output: *mut FILE, attr: xmlAttrPtr,
                        depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpAttrList(output: *mut FILE, attr: xmlAttrPtr,
                            depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpOneNode(output: *mut FILE, node: xmlNodePtr,
                           depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpNode(output: *mut FILE, node: xmlNodePtr,
                        depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpNodeList(output: *mut FILE, node: xmlNodePtr,
                            depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpDocumentHead(output: *mut FILE, doc: xmlDocPtr);
    #[no_mangle]
    fn xmlDebugDumpDocument(output: *mut FILE, doc: xmlDocPtr);
    #[no_mangle]
    fn xmlDebugDumpDTD(output: *mut FILE, dtd: xmlDtdPtr);
    #[no_mangle]
    fn xmlDebugDumpEntities(output: *mut FILE, doc: xmlDocPtr);
    /* ***************************************************************
 *								*
 *			Checking routines			*
 *								*
 ****************************************************************/
    #[no_mangle]
    fn xmlDebugCheckDocument(output: *mut FILE, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    /* ***************************************************************
 *								*
 *			XML shell helpers			*
 *								*
 ****************************************************************/
    #[no_mangle]
    fn xmlLsOneNode(output: *mut FILE, node: xmlNodePtr);
    #[no_mangle]
    fn xmlLsCountNode(node: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBoolToText(boolval: std::os::raw::c_int) -> *const std::os::raw::c_char;
    #[no_mangle]
    fn xmlShellPrintXPathResult(list: xmlXPathObjectPtr);
    #[no_mangle]
    fn xmlShellList(ctxt: xmlShellCtxtPtr, arg: *mut std::os::raw::c_char,
                    node: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlShellBase(ctxt: xmlShellCtxtPtr, arg: *mut std::os::raw::c_char,
                    node: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlShellDir(ctxt: xmlShellCtxtPtr, arg: *mut std::os::raw::c_char,
                   node: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlShellLoad(ctxt: xmlShellCtxtPtr, filename: *mut std::os::raw::c_char,
                    node: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlShellCat(ctxt: xmlShellCtxtPtr, arg: *mut std::os::raw::c_char,
                   node: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlShellWrite(ctxt: xmlShellCtxtPtr, filename: *mut std::os::raw::c_char,
                     node: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlShellSave(ctxt: xmlShellCtxtPtr, filename: *mut std::os::raw::c_char,
                    node: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn xmlShellValidate(ctxt: xmlShellCtxtPtr, dtd: *mut std::os::raw::c_char,
                        node: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    /* LIBXML_VALID_ENABLED */
    #[no_mangle]
    fn xmlShellDu(ctxt: xmlShellCtxtPtr, arg: *mut std::os::raw::c_char,
                  tree: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlShellPwd(ctxt: xmlShellCtxtPtr, buffer: *mut std::os::raw::c_char,
                   node: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    /*
  We manually define xmlErrMemory because it's normal declaration
  is "hidden" by #ifdef IN_LIBXML
*/
    #[no_mangle]
    fn xmlErrMemory(ctxt: xmlParserCtxtPtr, extra: *const std::os::raw::c_char);
    /*
 * Summary: internal interfaces for XML Path Language implementation
 * Description: internal interfaces for XML Path Language implementation
 *              used to build new modules on top of XPath like XPointer and
 *              XSLT
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* ***********************************************************************
 *									*
 *			Helpers						*
 *									*
 ************************************************************************/
    /*
 * Many of these macros may later turn into functions. They
 * shouldn't be used in #ifdef's preprocessor instructions.
 */
/* *
 * xmlXPathSetError:
 * @ctxt:  an XPath parser context
 * @err:  an xmlXPathError code
 *
 * Raises an error.
 */
    /* *
 * xmlXPathSetArityError:
 * @ctxt:  an XPath parser context
 *
 * Raises an XPATH_INVALID_ARITY error.
 */
    /* *
 * xmlXPathSetTypeError:
 * @ctxt:  an XPath parser context
 *
 * Raises an XPATH_INVALID_TYPE error.
 */
    /* *
 * xmlXPathGetError:
 * @ctxt:  an XPath parser context
 *
 * Get the error code of an XPath context.
 *
 * Returns the context error.
 */
    /* *
 * xmlXPathCheckError:
 * @ctxt:  an XPath parser context
 *
 * Check if an XPath error was raised.
 *
 * Returns true if an error has been raised, false otherwise.
 */
    /* *
 * xmlXPathGetDocument:
 * @ctxt:  an XPath parser context
 *
 * Get the document of an XPath context.
 *
 * Returns the context document.
 */
    /* *
 * xmlXPathGetContextNode:
 * @ctxt: an XPath parser context
 *
 * Get the context node of an XPath context.
 *
 * Returns the context node.
 */
    #[no_mangle]
    fn xmlXPathPopBoolean(ctxt: xmlXPathParserContextPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathPopNumber(ctxt: xmlXPathParserContextPtr) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathPopString(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathPopNodeSet(ctxt: xmlXPathParserContextPtr) -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathPopExternal(ctxt: xmlXPathParserContextPtr)
     -> *mut std::os::raw::c_void;
    /*
 * Error reporting.
 */
    #[no_mangle]
    fn xmlXPatherror(ctxt: xmlXPathParserContextPtr,
                     file: *const std::os::raw::c_char, line: std::os::raw::c_int,
                     no: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathErr(ctxt: xmlXPathParserContextPtr, error: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathDebugDumpObject(output: *mut FILE, cur: xmlXPathObjectPtr,
                               depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathDebugDumpCompExpr(output: *mut FILE, comp: xmlXPathCompExprPtr,
                                 depth: std::os::raw::c_int);
    /* *
 * NodeSet handling.
 */
    #[no_mangle]
    fn xmlXPathNodeSetContains(cur: xmlNodeSetPtr, val: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathDifference(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathIntersection(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathDistinctSorted(nodes: xmlNodeSetPtr) -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathDistinct(nodes: xmlNodeSetPtr) -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathHasSameNodes(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNodeLeadingSorted(nodes: xmlNodeSetPtr, node: xmlNodePtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathLeadingSorted(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathNodeLeading(nodes: xmlNodeSetPtr, node: xmlNodePtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathLeading(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathNodeTrailingSorted(nodes: xmlNodeSetPtr, node: xmlNodePtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathTrailingSorted(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathNodeTrailing(nodes: xmlNodeSetPtr, node: xmlNodePtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathTrailing(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr)
     -> xmlNodeSetPtr;
    /* *
 * Extending a context.
 */
    #[no_mangle]
    fn xmlXPathRegisterNs(ctxt: xmlXPathContextPtr, prefix: *const xmlChar,
                          ns_uri: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNsLookup(ctxt: xmlXPathContextPtr, prefix: *const xmlChar)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlXPathRegisteredNsCleanup(ctxt: xmlXPathContextPtr);
    #[no_mangle]
    fn xmlXPathRegisterVariable(ctxt: xmlXPathContextPtr,
                                name: *const xmlChar,
                                value: xmlXPathObjectPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathRegisterVariableNS(ctxt: xmlXPathContextPtr,
                                  name: *const xmlChar,
                                  ns_uri: *const xmlChar,
                                  value: xmlXPathObjectPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathRegisteredFuncsCleanup(ctxt: xmlXPathContextPtr);
    #[no_mangle]
    fn xmlXPathVariableLookup(ctxt: xmlXPathContextPtr, name: *const xmlChar)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathVariableLookupNS(ctxt: xmlXPathContextPtr,
                                name: *const xmlChar, ns_uri: *const xmlChar)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathRegisteredVariablesCleanup(ctxt: xmlXPathContextPtr);
    /* TODO: remap to xmlXPathValuePop and Push. */
    #[no_mangle]
    fn valuePop(ctxt: xmlXPathParserContextPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn valuePush(ctxt: xmlXPathParserContextPtr, value: xmlXPathObjectPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNewString(val: *const xmlChar) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewCString(val: *const std::os::raw::c_char) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathWrapCString(val: *mut std::os::raw::c_char) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewFloat(val: std::os::raw::c_double) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewBoolean(val: std::os::raw::c_int) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewNodeSet(val: xmlNodePtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNodeSetAdd(cur: xmlNodeSetPtr, val: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNodeSetAddUnique(cur: xmlNodeSetPtr, val: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNodeSetAddNs(cur: xmlNodeSetPtr, node: xmlNodePtr,
                            ns: xmlNsPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNodeSetSort(set: xmlNodeSetPtr);
    #[no_mangle]
    fn xmlXPathRoot(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathEvalExpr(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathParseName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathParseNCName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
    /*
 * Existing functions.
 */
    #[no_mangle]
    fn xmlXPathStringEvalNumber(str: *const xmlChar) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathEvaluatePredicateResult(ctxt: xmlXPathParserContextPtr,
                                       res: xmlXPathObjectPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathRegisterAllFunctions(ctxt: xmlXPathContextPtr);
    #[no_mangle]
    fn xmlXPathNodeSetMerge(val1: xmlNodeSetPtr, val2: xmlNodeSetPtr)
     -> xmlNodeSetPtr;
    #[no_mangle]
    fn xmlXPathNodeSetDel(cur: xmlNodeSetPtr, val: xmlNodePtr);
    #[no_mangle]
    fn xmlXPathNodeSetRemove(cur: xmlNodeSetPtr, val: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathNewNodeSetList(val: xmlNodeSetPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathWrapNodeSet(val: xmlNodeSetPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathWrapExternal(val: *mut std::os::raw::c_void) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathEqualValues(ctxt: xmlXPathParserContextPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNotEqualValues(ctxt: xmlXPathParserContextPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathCompareValues(ctxt: xmlXPathParserContextPtr, inf: std::os::raw::c_int,
                             strict: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathValueFlipSign(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathAddValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathSubValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathMultValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathDivValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathModValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathIsNodeType(name: *const xmlChar) -> std::os::raw::c_int;
    /*
 * Some of the axis navigation routines.
 */
    #[no_mangle]
    fn xmlXPathNextSelf(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextChild(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextDescendant(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextDescendantOrSelf(ctxt: xmlXPathParserContextPtr,
                                    cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextParent(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextAncestorOrSelf(ctxt: xmlXPathParserContextPtr,
                                  cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextFollowingSibling(ctxt: xmlXPathParserContextPtr,
                                    cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextFollowing(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextNamespace(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextAttribute(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextPreceding(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextAncestor(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextPrecedingSibling(ctxt: xmlXPathParserContextPtr,
                                    cur: xmlNodePtr) -> xmlNodePtr;
    /*
 * The official core of XPath functions.
 */
    #[no_mangle]
    fn xmlXPathLastFunction(ctxt: xmlXPathParserContextPtr,
                            nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathPositionFunction(ctxt: xmlXPathParserContextPtr,
                                nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathCountFunction(ctxt: xmlXPathParserContextPtr,
                             nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathIdFunction(ctxt: xmlXPathParserContextPtr, nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathLocalNameFunction(ctxt: xmlXPathParserContextPtr,
                                 nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathNamespaceURIFunction(ctxt: xmlXPathParserContextPtr,
                                    nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathStringFunction(ctxt: xmlXPathParserContextPtr,
                              nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathStringLengthFunction(ctxt: xmlXPathParserContextPtr,
                                    nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathConcatFunction(ctxt: xmlXPathParserContextPtr,
                              nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathContainsFunction(ctxt: xmlXPathParserContextPtr,
                                nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathStartsWithFunction(ctxt: xmlXPathParserContextPtr,
                                  nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathSubstringFunction(ctxt: xmlXPathParserContextPtr,
                                 nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathSubstringBeforeFunction(ctxt: xmlXPathParserContextPtr,
                                       nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathSubstringAfterFunction(ctxt: xmlXPathParserContextPtr,
                                      nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathNormalizeFunction(ctxt: xmlXPathParserContextPtr,
                                 nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathTranslateFunction(ctxt: xmlXPathParserContextPtr,
                                 nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathNotFunction(ctxt: xmlXPathParserContextPtr,
                           nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathTrueFunction(ctxt: xmlXPathParserContextPtr,
                            nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathFalseFunction(ctxt: xmlXPathParserContextPtr,
                             nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathLangFunction(ctxt: xmlXPathParserContextPtr,
                            nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathNumberFunction(ctxt: xmlXPathParserContextPtr,
                              nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathSumFunction(ctxt: xmlXPathParserContextPtr,
                           nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathFloorFunction(ctxt: xmlXPathParserContextPtr,
                             nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathCeilingFunction(ctxt: xmlXPathParserContextPtr,
                               nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathRoundFunction(ctxt: xmlXPathParserContextPtr,
                             nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathBooleanFunction(ctxt: xmlXPathParserContextPtr,
                               nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlC14NDocSaveTo(doc: xmlDocPtr, nodes: xmlNodeSetPtr,
                        mode: std::os::raw::c_int,
                        inclusive_ns_prefixes: *mut *mut xmlChar,
                        with_comments: std::os::raw::c_int, buf: xmlOutputBufferPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlC14NDocDumpMemory(doc: xmlDocPtr, nodes: xmlNodeSetPtr,
                            mode: std::os::raw::c_int,
                            inclusive_ns_prefixes: *mut *mut xmlChar,
                            with_comments: std::os::raw::c_int,
                            doc_txt_ptr: *mut *mut xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlC14NDocSave(doc: xmlDocPtr, nodes: xmlNodeSetPtr, mode: std::os::raw::c_int,
                      inclusive_ns_prefixes: *mut *mut xmlChar,
                      with_comments: std::os::raw::c_int,
                      filename: *const std::os::raw::c_char, compression: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlModuleSymbol(module: xmlModulePtr, name: *const std::os::raw::c_char,
                       result: *mut *mut std::os::raw::c_void) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlModuleClose(module: xmlModulePtr) -> std::os::raw::c_int;
    /*
 * Summary: Unicode character APIs
 * Description: API for the Unicode character APIs
 *
 * This file is automatically generated from the
 * UCS description files of the Unicode Character Database
 * http://www.unicode.org/Public/4.0-Update1/UCD-4.0.1.html
 * using the genUnicode.py Python script.
 *
 * Generation date: Mon Mar 27 11:09:52 2006
 * Sources: Blocks-4.0.1.txt UnicodeData-4.0.1.txt
 * Author: Daniel Veillard
 */
    #[no_mangle]
    fn xmlUCSIsAegeanNumbers(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsAlphabeticPresentationForms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArabic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArabicPresentationFormsA(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArabicPresentationFormsB(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArmenian(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArrows(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBasicLatin(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBengali(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBlockElements(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBopomofo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBopomofoExtended(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBoxDrawing(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBraillePatterns(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBuhid(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsByzantineMusicalSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKCompatibility(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKCompatibilityForms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKCompatibilityIdeographs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKCompatibilityIdeographsSupplement(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKRadicalsSupplement(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKSymbolsandPunctuation(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKUnifiedIdeographs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKUnifiedIdeographsExtensionA(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKUnifiedIdeographsExtensionB(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCherokee(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCombiningDiacriticalMarks(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCombiningDiacriticalMarksforSymbols(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCombiningHalfMarks(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCombiningMarksforSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsControlPictures(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCurrencySymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCypriotSyllabary(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCyrillic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCyrillicSupplement(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsDeseret(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsDevanagari(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsDingbats(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsEnclosedAlphanumerics(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsEnclosedCJKLettersandMonths(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsEthiopic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGeneralPunctuation(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGeometricShapes(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGeorgian(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGothic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGreek(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGreekExtended(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGreekandCoptic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGujarati(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGurmukhi(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHalfwidthandFullwidthForms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHangulCompatibilityJamo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHangulJamo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHangulSyllables(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHanunoo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHebrew(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHighPrivateUseSurrogates(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHighSurrogates(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHiragana(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsIPAExtensions(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsIdeographicDescriptionCharacters(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKanbun(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKangxiRadicals(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKannada(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKatakana(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKatakanaPhoneticExtensions(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKhmer(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKhmerSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLao(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLatin1Supplement(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLatinExtendedA(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLatinExtendedB(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLatinExtendedAdditional(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLetterlikeSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLimbu(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLinearBIdeograms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLinearBSyllabary(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLowSurrogates(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMalayalam(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMathematicalAlphanumericSymbols(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMathematicalOperators(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousMathematicalSymbolsA(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousMathematicalSymbolsB(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousSymbolsandArrows(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousTechnical(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMongolian(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMusicalSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMyanmar(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsNumberForms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOgham(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOldItalic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOpticalCharacterRecognition(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOriya(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOsmanya(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsPhoneticExtensions(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsPrivateUse(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsPrivateUseArea(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsRunic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsShavian(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSinhala(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSmallFormVariants(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSpacingModifierLetters(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSpecials(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSuperscriptsandSubscripts(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementalArrowsA(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementalArrowsB(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementalMathematicalOperators(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementaryPrivateUseAreaA(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementaryPrivateUseAreaB(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSyriac(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTagalog(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTagbanwa(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTags(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTaiLe(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTaiXuanJingSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTamil(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTelugu(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsThaana(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsThai(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTibetan(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsUgaritic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsUnifiedCanadianAboriginalSyllabics(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsVariationSelectors(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsVariationSelectorsSupplement(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsYiRadicals(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsYiSyllables(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsYijingHexagramSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBlock(code: std::os::raw::c_int, block: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatC(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatCc(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatCf(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatCo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatCs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatL(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLl(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLm(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLt(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLu(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatM(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatMc(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatMe(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatMn(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatN(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatNd(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatNl(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatNo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatP(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPc(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPd(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPe(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPf(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPi(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatS(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatSc(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatSk(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatSm(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatSo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatZ(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatZl(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatZp(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatZs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCat(code: std::os::raw::c_int, cat: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
}
pub type xmlChar = std::os::raw::c_uchar;
pub type size_t = std::os::raw::c_ulong;
pub type __off_t = std::os::raw::c_long;
pub type __off64_t = std::os::raw::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: std::os::raw::c_int,
    pub _IO_read_ptr: *mut std::os::raw::c_char,
    pub _IO_read_end: *mut std::os::raw::c_char,
    pub _IO_read_base: *mut std::os::raw::c_char,
    pub _IO_write_base: *mut std::os::raw::c_char,
    pub _IO_write_ptr: *mut std::os::raw::c_char,
    pub _IO_write_end: *mut std::os::raw::c_char,
    pub _IO_buf_base: *mut std::os::raw::c_char,
    pub _IO_buf_end: *mut std::os::raw::c_char,
    pub _IO_save_base: *mut std::os::raw::c_char,
    pub _IO_backup_base: *mut std::os::raw::c_char,
    pub _IO_save_end: *mut std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: std::os::raw::c_int,
    pub _flags2: std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: std::os::raw::c_ushort,
    pub _vtable_offset: std::os::raw::c_schar,
    pub _shortbuf: [std::os::raw::c_char; 1],
    pub _lock: *mut std::os::raw::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: std::os::raw::c_int,
    pub _unused2: [std::os::raw::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInputBuffer {
    pub context: *mut std::os::raw::c_void,
    pub readcallback: xmlInputReadCallback,
    pub closecallback: xmlInputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub raw: xmlBufPtr,
    pub compressed: std::os::raw::c_int,
    pub error: std::os::raw::c_int,
    pub rawconsumed: std::os::raw::c_ulong,
}
pub type xmlBufPtr = *mut xmlBuf;
pub type xmlBuf = _xmlBuf;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
/*
 * Summary: interface for the encoding conversion functions
 * Description: interface for the encoding conversion functions needed for
 *              XML basic encoding and iconv() support.
 *
 * Related specs are
 * rfc2044        (UTF-8 and UTF-16) F. Yergeau Alis Technologies
 * [ISO-10646]    UTF-8 and UTF-16 in Annexes
 * [ISO-8859-1]   ISO Latin-1 characters codes.
 * [UNICODE]      The Unicode Consortium, "The Unicode Standard --
 *                Worldwide Character Encoding -- Version 1.0", Addison-
 *                Wesley, Volume 1, 1991, Volume 2, 1992.  UTF-8 is
 *                described in Unicode Technical Report #4.
 * [US-ASCII]     Coded Character Set--7-bit American Standard Code for
 *                Information Interchange, ANSI X3.4-1986.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * xmlCharEncoding:
 *
 * Predefined values for some standard encodings.
 * Libxml does not do beforehand translation on UTF8 and ISOLatinX.
 * It also supports ASCII, ISO-8859-1, and UTF16 (LE and BE) by default.
 *
 * Anything else would have to be translated to UTF8 before being
 * given to the parser itself. The BOM for UTF16 and the encoding
 * declaration are looked at and a converter is looked for at that
 * point. If not found the parser stops here as asked by the XML REC. A
 * converter can be registered by the user using xmlRegisterCharEncodingHandler
 * but the current form doesn't allow stateful transcoding (a serious
 * problem agreed !). If iconv has been found it will be used
 * automatically and allow stateful transcoding, the simplest is then
 * to be sure to enable iconv and to provide iconv libs for the encoding
 * support needed.
 *
 * Note that the generic "UTF-16" is not a predefined value.  Instead, only
 * the specific UTF-16LE and UTF-16BE are present.
 */
/* No char encoding detected */
/* No char encoding detected */
/* UTF-8 */
/* UTF-16 little endian */
/* UTF-16 big endian */
/* UCS-4 little endian */
/* UCS-4 big endian */
/* EBCDIC uh! */
/* UCS-4 unusual ordering */
/* UCS-4 unusual ordering */
/* UCS-2 */
/* ISO-8859-1 ISO Latin 1 */
/* ISO-8859-2 ISO Latin 2 */
/* ISO-8859-3 */
/* ISO-8859-4 */
/* ISO-8859-5 */
/* ISO-8859-6 */
/* ISO-8859-7 */
/* ISO-8859-8 */
/* ISO-8859-9 */
/* ISO-2022-JP */
/* Shift_JIS */
/* EUC-JP */
/* pure ASCII */
/* *
 * xmlCharEncodingInputFunc:
 * @out:  a pointer to an array of bytes to store the UTF-8 result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of chars in the original encoding
 * @inlen:  the length of @in
 *
 * Take a block of chars in the original encoding and try to convert
 * it to an UTF-8 block of chars out.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets consumed.
 */
/* *
 * xmlCharEncodingOutputFunc:
 * @out:  a pointer to an array of bytes to store the result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of UTF-8 chars
 * @inlen:  the length of @in
 *
 * Take a block of UTF-8 chars in and try to convert it to another
 * encoding.
 * Note: a first call designed to produce heading info is called with
 * in = NULL. If stateful this should also initialize the encoder state.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets produced.
 */
/*
 * Block defining the handlers for non UTF-8 encodings.
 * If iconv is supported, there are two extra fields.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlCharEncodingHandler {
    pub name: *mut std::os::raw::c_char,
    pub input: xmlCharEncodingInputFunc,
    pub output: xmlCharEncodingOutputFunc,
    pub iconv_in: iconv_t,
    pub iconv_out: iconv_t,
}
pub type iconv_t = *mut std::os::raw::c_void;
pub type xmlCharEncodingOutputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
pub type xmlCharEncodingInputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
/* *
 * xmlInputOpenCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Input API to open the resource
 *
 * Returns an Input context or NULL in case or error
 */
/* *
 * xmlInputReadCallback:
 * @context:  an Input context
 * @buffer:  the buffer to store data read
 * @len:  the length of the buffer in bytes
 *
 * Callback used in the I/O Input API to read the resource
 *
 * Returns the number of bytes read or -1 in case of error
 */
/* *
 * xmlInputCloseCallback:
 * @context:  an Input context
 *
 * Callback used in the I/O Input API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
pub type xmlInputCloseCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type xmlInputReadCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_char,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
/*
 * Summary: interfaces for tree manipulation
 * Description: this module describes the structures found in an tree resulting
 *              from an XML or HTML parsing, as well as the API provided for
 *              various processing on that tree
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Some of the basic types pointer to structures:
 */
/* xmlIO.h */
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
/*
 * Those are the functions and datatypes for the library output
 * I/O structures.
 */
/* *
 * xmlOutputMatchCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Output API to detect if the current handler
 * can provide output fonctionnalities for this resource.
 *
 * Returns 1 if yes and 0 if another Output module should be used
 */
/* *
 * xmlOutputOpenCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Output API to open the resource
 *
 * Returns an Output context or NULL in case or error
 */
/* *
 * xmlOutputWriteCallback:
 * @context:  an Output context
 * @buffer:  the buffer of data to write
 * @len:  the length of the buffer in bytes
 *
 * Callback used in the I/O Output API to write to the resource
 *
 * Returns the number of bytes written or -1 in case of error
 */
/* *
 * xmlOutputCloseCallback:
 * @context:  an Output context
 *
 * Callback used in the I/O Output API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
/* LIBXML_OUTPUT_ENABLED */
/* I18N conversions to UTF-8 */
/* Local buffer encoded in UTF-8 */
/* if encoder != NULL buffer for raw input */
/* -1=unknown, 0=not compressed, 1=compressed */
/* amount consumed from raw */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlOutputBuffer {
    pub context: *mut std::os::raw::c_void,
    pub writecallback: xmlOutputWriteCallback,
    pub closecallback: xmlOutputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub conv: xmlBufPtr,
    pub written: std::os::raw::c_int,
    pub error: std::os::raw::c_int,
}
pub type xmlOutputCloseCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type xmlOutputWriteCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
pub type xmlOutputBuffer = _xmlOutputBuffer;
pub type xmlOutputBufferPtr = *mut xmlOutputBuffer;
/*
 * Summary: the core parser module
 * Description: Interfaces, constants and types related to the XML parser
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * XML_DEFAULT_VERSION:
 *
 * The default version of XML used: 1.0
 */
/* *
 * xmlParserInput:
 *
 * An xmlParserInput is an input flow for the XML processor.
 * Each entity parsed is associated an xmlParserInput (except the
 * few predefined ones). This is the case both for internal entities
 * - in which case the flow is already completely in memory - or
 * external entities - in which case we use the buf structure for
 * progressive reading and I18N conversions to the internal UTF-8 format.
 */
/* *
 * xmlParserInputDeallocate:
 * @str:  the string to deallocate
 *
 * Callback for freeing some parser input allocations.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInput {
    pub buf: xmlParserInputBufferPtr,
    pub filename: *const std::os::raw::c_char,
    pub directory: *const std::os::raw::c_char,
    pub base: *const xmlChar,
    pub cur: *const xmlChar,
    pub end: *const xmlChar,
    pub length: std::os::raw::c_int,
    pub line: std::os::raw::c_int,
    pub col: std::os::raw::c_int,
    pub consumed: std::os::raw::c_ulong,
    pub free: xmlParserInputDeallocate,
    pub encoding: *const xmlChar,
    pub version: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub id: std::os::raw::c_int,
}
pub type xmlParserInputDeallocate
    =
    Option<unsafe extern "C" fn(_: *mut xmlChar) -> ()>;
/* parser.h */
pub type xmlParserInput = _xmlParserInput;
pub type xmlParserInputPtr = *mut xmlParserInput;
/* an unique identifier for the entity */
/* *
 * xmlParserNodeInfo:
 *
 * The parser can be asked to collect Node informations, i.e. at what
 * place in the file they were detected.
 * NOTE: This is off by default and not very well tested.
 */
/* Position & line # that text that created the node begins & ends on */
/* *
 * xmlParserInputState:
 *
 * The parser is now working also as a state based parser.
 * The recursive one use the state info for entities processing.
 */
/* nothing is to be parsed */
/* nothing has been parsed */
/* Misc* before int subset */
/* Within a processing instruction */
/* within some DTD content */
/* Misc* after internal subset */
/* within a comment */
/* within a start tag */
/* within the content */
/* within a CDATA section */
/* within a closing tag */
/* within an entity declaration */
/* within an entity value in a decl */
/* within an attribute value */
/* within a SYSTEM value */
/* the Misc* after the last end tag */
/* within an IGNORED section */
/* within a PUBLIC value */
/* *
 * XML_DETECT_IDS:
 *
 * Bit in the loadsubset context field to tell to do ID/REFs lookups.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
/* *
 * XML_COMPLETE_ATTRS:
 *
 * Bit in the loadsubset context field to tell to do complete the
 * elements attributes lists with the ones defaulted from the DTDs.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
/* *
 * XML_SKIP_IDS:
 *
 * Bit in the loadsubset context field to tell to not do ID/REFs registration.
 * Used to initialize xmlLoadExtDtdDefaultValue in some special cases.
 */
/* *
 * xmlParserMode:
 *
 * A parser can operate in various modes
 */
/* *
 * xmlParserCtxt:
 *
 * The parser context.
 * NOTE This doesn't completely define the parser state, the (current ?)
 *      design of the parser uses recursive function calls since this allow
 *      and easy mapping from the production rules of the specification
 *      to the actual code. The drawback is that the actual function call
 *      also reflect the parser state. However most of the parsing routines
 *      takes as the only argument the parser context pointer, so migrating
 *      to a state based parser for progressive parsing shouldn't be too hard.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserCtxt {
    pub sax: *mut _xmlSAXHandler,
    pub userData: *mut std::os::raw::c_void,
    pub myDoc: xmlDocPtr,
    pub wellFormed: std::os::raw::c_int,
    pub replaceEntities: std::os::raw::c_int,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub html: std::os::raw::c_int,
    pub input: xmlParserInputPtr,
    pub inputNr: std::os::raw::c_int,
    pub inputMax: std::os::raw::c_int,
    pub inputTab: *mut xmlParserInputPtr,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub record_info: std::os::raw::c_int,
    pub node_seq: xmlParserNodeInfoSeq,
    pub errNo: std::os::raw::c_int,
    pub hasExternalSubset: std::os::raw::c_int,
    pub hasPErefs: std::os::raw::c_int,
    pub external: std::os::raw::c_int,
    pub valid: std::os::raw::c_int,
    pub validate: std::os::raw::c_int,
    pub vctxt: xmlValidCtxt,
    pub instate: xmlParserInputState,
    pub token: std::os::raw::c_int,
    pub directory: *mut std::os::raw::c_char,
    pub name: *const xmlChar,
    pub nameNr: std::os::raw::c_int,
    pub nameMax: std::os::raw::c_int,
    pub nameTab: *mut *const xmlChar,
    pub nbChars: std::os::raw::c_long,
    pub checkIndex: std::os::raw::c_long,
    pub keepBlanks: std::os::raw::c_int,
    pub disableSAX: std::os::raw::c_int,
    pub inSubset: std::os::raw::c_int,
    pub intSubName: *const xmlChar,
    pub extSubURI: *mut xmlChar,
    pub extSubSystem: *mut xmlChar,
    pub space: *mut std::os::raw::c_int,
    pub spaceNr: std::os::raw::c_int,
    pub spaceMax: std::os::raw::c_int,
    pub spaceTab: *mut std::os::raw::c_int,
    pub depth: std::os::raw::c_int,
    pub entity: xmlParserInputPtr,
    pub charset: std::os::raw::c_int,
    pub nodelen: std::os::raw::c_int,
    pub nodemem: std::os::raw::c_int,
    pub pedantic: std::os::raw::c_int,
    pub _private: *mut std::os::raw::c_void,
    pub loadsubset: std::os::raw::c_int,
    pub linenumbers: std::os::raw::c_int,
    pub catalogs: *mut std::os::raw::c_void,
    pub recovery: std::os::raw::c_int,
    pub progressive: std::os::raw::c_int,
    pub dict: xmlDictPtr,
    pub atts: *mut *const xmlChar,
    pub maxatts: std::os::raw::c_int,
    pub docdict: std::os::raw::c_int,
    pub str_xml: *const xmlChar,
    pub str_xmlns: *const xmlChar,
    pub str_xml_ns: *const xmlChar,
    pub sax2: std::os::raw::c_int,
    pub nsNr: std::os::raw::c_int,
    pub nsMax: std::os::raw::c_int,
    pub nsTab: *mut *const xmlChar,
    pub attallocs: *mut std::os::raw::c_int,
    pub pushTab: *mut *mut std::os::raw::c_void,
    pub attsDefault: xmlHashTablePtr,
    pub attsSpecial: xmlHashTablePtr,
    pub nsWellFormed: std::os::raw::c_int,
    pub options: std::os::raw::c_int,
    pub dictNames: std::os::raw::c_int,
    pub freeElemsNr: std::os::raw::c_int,
    pub freeElems: xmlNodePtr,
    pub freeAttrsNr: std::os::raw::c_int,
    pub freeAttrs: xmlAttrPtr,
    pub lastError: xmlError,
    pub parseMode: xmlParserMode,
    pub nbentities: std::os::raw::c_ulong,
    pub sizeentities: std::os::raw::c_ulong,
    pub nodeInfo: *mut xmlParserNodeInfo,
    pub nodeInfoNr: std::os::raw::c_int,
    pub nodeInfoMax: std::os::raw::c_int,
    pub nodeInfoTab: *mut xmlParserNodeInfo,
    pub input_id: std::os::raw::c_int,
    pub sizeentcopy: std::os::raw::c_ulong,
}
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfo {
    pub node: *const _xmlNode,
    pub begin_pos: std::os::raw::c_ulong,
    pub begin_line: std::os::raw::c_ulong,
    pub end_pos: std::os::raw::c_ulong,
    pub end_line: std::os::raw::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNode {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub content: *mut xmlChar,
    pub properties: *mut _xmlAttr,
    pub nsDef: *mut xmlNs,
    pub psvi: *mut std::os::raw::c_void,
    pub line: std::os::raw::c_ushort,
    pub extra: std::os::raw::c_ushort,
}
/* entities.h */
/* *
 * BASE_BUFFER_SIZE:
 *
 * default buffer size 4000.
 */
/* *
 * LIBXML_NAMESPACE_DICT:
 *
 * Defines experimental behaviour:
 * 1) xmlNs gets an additional field @context (a xmlDoc)
 * 2) when creating a tree, xmlNs->href is stored in the dict of xmlDoc.
 */
/* #define LIBXML_NAMESPACE_DICT */
/* *
 * xmlBufferAllocationScheme:
 *
 * A buffer allocation scheme can be defined to either match exactly the
 * need or double it's allocated size each time it is found too small.
 */
/* double each time one need to grow */
/* grow only to the minimal size */
/* immutable buffer */
/* special allocation scheme used for I/O */
/* exact up to a threshold, and doubleit thereafter */
/* limit the upper size of the buffer */
/* *
 * xmlBuffer:
 *
 * A buffer structure, this old construct is limited to 2GB and
 * is being deprecated, use API with xmlBuf instead
 */
/* The buffer content UTF8 */
/* The buffer size used */
/* The buffer size */
/* The realloc method */
/* in IO mode we may have a different base */
/* *
 * xmlBuf:
 *
 * A buffer structure, new one, the actual structure internals are not public
 */
/* *
 * xmlBufPtr:
 *
 * A pointer to a buffer structure, the actual structure internals are not
 * public
 */
/*
 * A few public routines for xmlBuf. As those are expected to be used
 * mostly internally the bulk of the routines are internal in buf.h
 */
/*
 * LIBXML2_NEW_BUFFER:
 *
 * Macro used to express that the API use the new buffers for
 * xmlParserInputBuffer and xmlOutputBuffer. The change was
 * introduced in 2.9.0.
 */
/* *
 * XML_XML_NAMESPACE:
 *
 * This is the namespace for the special xml: prefix predefined in the
 * XML Namespace specification.
 */
/* *
 * XML_XML_ID:
 *
 * This is the name for the special xml:id attribute
 */
/*
 * The different element types carried by an XML tree.
 *
 * NOTE: This is synchronized with DOM Level1 values
 *       See http://www.w3.org/TR/REC-DOM-Level-1/
 *
 * Actually this had diverged a bit, and now XML_DOCUMENT_TYPE_NODE should
 * be deprecated to use an XML_DTD_NODE.
 */
/* *
 * xmlNotation:
 *
 * A DTD Notation definition.
 */
/* Notation name */
/* Public identifier, if any */
/* System identifier, if any */
/* *
 * xmlAttributeType:
 *
 * A DTD Attribute type definition.
 */
/* *
 * xmlAttributeDefault:
 *
 * A DTD Attribute default definition.
 */
/* *
 * xmlEnumeration:
 *
 * List structure used when there is an enumeration in DTDs.
 */
/* next one */
/* Enumeration name */
/* *
 * xmlAttribute:
 *
 * An Attribute declaration in a DTD.
 */
/* application data */
/* XML_ATTRIBUTE_DECL, must be second ! */
/* Attribute name */
/* NULL */
/* NULL */
/* -> DTD */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* next in hash table */
/* The attribute type */
/* the default */
/* or the default value */
/* or the enumeration tree if any */
/* the namespace prefix if any */
/* Element holding the attribute */
/* *
 * xmlElementContentType:
 *
 * Possible definitions of element content types.
 */
/* *
 * xmlElementContentOccur:
 *
 * Possible definitions of element content occurrences.
 */
/* *
 * xmlElementContent:
 *
 * An XML Element content as stored after parsing an element definition
 * in a DTD.
 */
/* PCDATA, ELEMENT, SEQ or OR */
/* ONCE, OPT, MULT or PLUS */
/* Element name */
/* first child */
/* second child */
/* parent */
/* Namespace prefix */
/* *
 * xmlElementTypeVal:
 *
 * The different possibilities for an element content type.
 */
/* *
 * xmlElement:
 *
 * An XML Element declaration from a DTD.
 */
/* application data */
/* XML_ELEMENT_DECL, must be second ! */
/* Element name */
/* NULL */
/* NULL */
/* -> DTD */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* The type */
/* the allowed element content */
/* List of the declared attributes */
/* the namespace prefix if any */
/* the validating regexp */
/* *
 * XML_LOCAL_NAMESPACE:
 *
 * A namespace declaration node.
 */
/* *
 * xmlNs:
 *
 * An XML namespace.
 * Note that prefix == NULL is valid, it defines the default namespace
 * within the subtree (until overridden).
 *
 * xmlNsType is unified with xmlElementType.
 */
pub type xmlNs = _xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNs {
    pub next: *mut _xmlNs,
    pub type_0: xmlNsType,
    pub href: *const xmlChar,
    pub prefix: *const xmlChar,
    pub _private: *mut std::os::raw::c_void,
    pub context: *mut _xmlDoc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDoc {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *mut std::os::raw::c_char,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub compression: std::os::raw::c_int,
    pub standalone: std::os::raw::c_int,
    pub intSubset: *mut _xmlDtd,
    pub extSubset: *mut _xmlDtd,
    pub oldNs: *mut _xmlNs,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub ids: *mut std::os::raw::c_void,
    pub refs: *mut std::os::raw::c_void,
    pub URL: *const xmlChar,
    pub charset: std::os::raw::c_int,
    pub dict: *mut _xmlDict,
    pub psvi: *mut std::os::raw::c_void,
    pub parseFlags: std::os::raw::c_int,
    pub properties: std::os::raw::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDtd {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDoc,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub notations: *mut std::os::raw::c_void,
    pub elements: *mut std::os::raw::c_void,
    pub attributes: *mut std::os::raw::c_void,
    pub entities: *mut std::os::raw::c_void,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub pentities: *mut std::os::raw::c_void,
}
pub type xmlElementType = std::os::raw::c_uint;
pub const XML_DOCB_DOCUMENT_NODE: xmlElementType = 21;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
pub type xmlNsType = xmlElementType;
/* normally an xmlDoc */
/* *
 * xmlDtd:
 *
 * An XML DTD, as defined by <!DOCTYPE ... There is actually one for
 * the internal subset and for the external subset.
 */
/* application data */
/* XML_DTD_NODE, must be second ! */
/* Name of the DTD */
/* the value of the property link */
/* last child link */
/* child->parent link */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* End of common part */
/* Hash table for notations if any */
/* Hash table for elements if any */
/* Hash table for attributes if any */
/* Hash table for entities if any */
/* External identifier for PUBLIC DTD */
/* URI for a SYSTEM or PUBLIC DTD */
/* Hash table for param entities if any */
/* *
 * xmlAttr:
 *
 * An attribute on an XML node.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttr {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlAttr,
    pub prev: *mut _xmlAttr,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub atype: xmlAttributeType,
    pub psvi: *mut std::os::raw::c_void,
}
pub type xmlAttributeType = std::os::raw::c_uint;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = std::os::raw::c_uint;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
/*
 * Summary: error handling
 * Description: the API used to report errors
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlErrorLevel:
 *
 * Indicates the level of an error
 */
/* A simple warning */
/* A recoverable error */
/* A fatal error */
/* *
 * xmlErrorDomain:
 *
 * Indicates where an error may have come from
 */
/* The XML parser */
/* The tree module */
/* The XML Namespace module */
/* The XML DTD validation with parser context*/
/* The HTML parser */
/* The memory allocator */
/* The serialization code */
/* The Input/Output stack */
/* The FTP module */
/* The HTTP module */
/* The XInclude processing */
/* The XPath module */
/* The XPointer module */
/* The regular expressions module */
/* The W3C XML Schemas Datatype module */
/* The W3C XML Schemas parser module */
/* The W3C XML Schemas validation module */
/* The Relax-NG parser module */
/* The Relax-NG validator module */
/* The Catalog module */
/* The Canonicalization module */
/* The XSLT engine from libxslt */
/* The XML DTD validation with valid context */
/* The error checking module */
/* The xmlwriter module */
/* The dynamically loaded module module*/
/* The module handling character conversion */
/* The Schematron validator module */
/* The buffers module */
/* The URI module */
/* *
 * xmlError:
 *
 * An XML Error instance.
 */
pub type xmlError = _xmlError;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlError {
    pub domain: std::os::raw::c_int,
    pub code: std::os::raw::c_int,
    pub message: *mut std::os::raw::c_char,
    pub level: xmlErrorLevel,
    pub file: *mut std::os::raw::c_char,
    pub line: std::os::raw::c_int,
    pub str1: *mut std::os::raw::c_char,
    pub str2: *mut std::os::raw::c_char,
    pub str3: *mut std::os::raw::c_char,
    pub int1: std::os::raw::c_int,
    pub int2: std::os::raw::c_int,
    pub ctxt: *mut std::os::raw::c_void,
    pub node: *mut std::os::raw::c_void,
}
pub type xmlErrorLevel = std::os::raw::c_uint;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
pub type xmlAttrPtr = *mut xmlAttr;
pub type xmlAttr = _xmlAttr;
/* for type/PSVI informations */
/* *
 * xmlID:
 *
 * An XML ID instance.
 */
/* next ID */
/* The ID name */
/* The attribute holding it */
/* The attribute if attr is not available */
/* The line number if attr is not available */
/* The document holding the ID */
/* *
 * xmlRef:
 *
 * An XML IDREF instance.
 */
/* next Ref */
/* The Ref name */
/* The attribute holding it */
/* The attribute if attr is not available */
/* The line number if attr is not available */
/* *
 * xmlNode:
 *
 * A node in an XML tree.
 */
pub type xmlNodePtr = *mut xmlNode;
pub type xmlNode = _xmlNode;
/*
 * Summary: Chained hash tables
 * Description: This module implements the hash table support used in
 *		various places in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Bjorn Reese <bjorn.reese@systematic.dk>
 */
/*
 * The hash table.
 */
pub type xmlHashTablePtr = *mut xmlHashTable;
pub type xmlHashTable = _xmlHashTable;
pub type xmlDictPtr = *mut xmlDict;
pub type xmlDict = _xmlDict;
pub type xmlParserInputState = std::os::raw::c_int;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
/*
 * Summary: The DTD validation
 * Description: API for the DTD handling and the validity checking
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Validation state added for non-determinist content model.
 */
/* *
 * xmlValidityErrorFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity error is found. This is a message
 * oriented function similar to an *printf function.
 */
/* *
 * xmlValidityWarningFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity warning is found. This is a message
 * oriented function similar to an *printf function.
 */
/*
 * xmlValidCtxt:
 * An xmlValidCtxt is used for error reporting when validating.
 */
pub type xmlValidCtxt = _xmlValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlValidCtxt {
    pub userData: *mut std::os::raw::c_void,
    pub error: xmlValidityErrorFunc,
    pub warning: xmlValidityWarningFunc,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub finishDtd: std::os::raw::c_uint,
    pub doc: xmlDocPtr,
    pub valid: std::os::raw::c_int,
    pub vstate: *mut xmlValidState,
    pub vstateNr: std::os::raw::c_int,
    pub vstateMax: std::os::raw::c_int,
    pub vstateTab: *mut xmlValidState,
    pub am: xmlAutomataPtr,
    pub state: xmlAutomataStatePtr,
}
/*
 * Summary: API to build regexp automata
 * Description: the API to build regexp automata
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlAutomataPtr:
 *
 * A libxml automata description, It can be compiled into a regexp
 */
/* *
 * xmlAutomataStatePtr:
 *
 * A state int the automata description,
 */
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataPtr = *mut xmlAutomata;
pub type xmlAutomata = _xmlAutomata;
pub type xmlValidState = _xmlValidState;
/* application data */
/* type number, must be second ! */
/* the name of the node, or the entity */
/* parent->childs link */
/* last child link */
/* child->parent link */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* End of common part */
/* pointer to the associated namespace */
/* the content */
/* properties list */
/* namespace definitions on this node */
/* for type/PSVI informations */
/* line number */
/* extra data for XPath/XSLT */
/* *
 * XML_GET_CONTENT:
 *
 * Macro to extract the content pointer of a node.
 */
/* *
 * XML_GET_LINE:
 *
 * Macro to extract the line number of an element node.
 */
/* *
 * xmlDocProperty
 *
 * Set of properties of the document as found by the parser
 * Some of them are linked to similary named xmlParserOption
 */
/* document is XML well formed */
/* document is Namespace valid */
/* parsed with old XML-1.0 parser */
/* DTD validation was successful */
/* XInclude substitution was done */
/* Document was built using the API
                                           and not by parsing an instance */
/* built for internal processing */
/* parsed or built HTML document */
/* *
 * xmlDoc:
 *
 * An XML document.
 */
pub type xmlDocPtr = *mut xmlDoc;
pub type xmlDoc = _xmlDoc;
pub type xmlValidityWarningFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlValidityErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfoSeq {
    pub maximum: std::os::raw::c_ulong,
    pub length: std::os::raw::c_ulong,
    pub buffer: *mut xmlParserNodeInfo,
}
/* volume of entity copy */
/* *
 * xmlSAXLocator:
 *
 * A SAX Locator.
 */
/* *
 * xmlSAXHandler:
 *
 * A SAX handler is bunch of callbacks called by the parser when processing
 * of the input generate data or structure informations.
 */
/* *
 * resolveEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * Callback:
 * The entity loader, to control the loading of external entities,
 * the application can either:
 *    - override this resolveEntity() callback in the SAX block
 *    - or better use the xmlSetExternalEntityLoader() function to
 *      set up it's own entity resolution routine
 *
 * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
 */
/* *
 * internalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on internal subset declaration.
 */
/* *
 * externalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on external subset declaration.
 */
/* *
 * getEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get an entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
/* *
 * getParameterEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get a parameter entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
/* *
 * entityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the entity name
 * @type:  the entity type
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @content: the entity value (without processing).
 *
 * An entity definition has been parsed.
 */
/* *
 * notationDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the notation
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * What to do when a notation declaration has been parsed.
 */
/* *
 * attributeDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @elem:  the name of the element
 * @fullname:  the attribute name
 * @type:  the attribute type
 * @def:  the type of default value
 * @defaultValue: the attribute default value
 * @tree:  the tree of enumerated value set
 *
 * An attribute definition has been parsed.
 */
/* *
 * elementDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the element name
 * @type:  the element type
 * @content: the element value tree
 *
 * An element definition has been parsed.
 */
/* *
 * unparsedEntityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the entity
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @notationName: the name of the notation
 *
 * What to do when an unparsed entity declaration is parsed.
 */
/* *
 * setDocumentLocatorSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @loc: A SAX Locator
 *
 * Receive the document locator at startup, actually xmlDefaultSAXLocator.
 * Everything is available on the context, so this is useless in our case.
 */
/* *
 * startDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document start being processed.
 */
/* *
 * endDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document end has been detected.
 */
/* *
 * startElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name, including namespace prefix
 * @atts:  An array of name/value attributes pairs, NULL terminated
 *
 * Called when an opening tag has been processed.
 */
/* *
 * endElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name
 *
 * Called when the end of an element has been detected.
 */
/* *
 * attributeSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The attribute name, including namespace prefix
 * @value:  The attribute value
 *
 * Handle an attribute that has been read by the parser.
 * The default handling is to convert the attribute into an
 * DOM subtree and past it in a new xmlAttr element added to
 * the element.
 */
/* *
 * referenceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The entity name
 *
 * Called when an entity reference is detected.
 */
/* *
 * charactersSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some chars from the parser.
 */
/* *
 * ignorableWhitespaceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some ignorable whitespaces from the parser.
 * UNUSED: by default the DOM building will use characters.
 */
/* *
 * processingInstructionSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @target:  the target name
 * @data: the PI data's
 *
 * A processing instruction has been parsed.
 */
/* *
 * commentSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  the comment content
 *
 * A comment has been parsed.
 */
/* *
 * cdataBlockSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  The pcdata content
 * @len:  the block length
 *
 * Called when a pcdata block has been parsed.
 */
/* *
 * warningSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format a warning messages, callback.
 */
/* *
 * errorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format an error messages, callback.
 */
/* *
 * fatalErrorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format fatal error messages, callback.
 * Note: so far fatalError() SAX callbacks are not used, error()
 *       get all the callbacks for errors.
 */
/* *
 * isStandaloneSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Is this document tagged standalone?
 *
 * Returns 1 if true
 */
/* *
 * hasInternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an internal subset.
 *
 * Returns 1 if true
 */
/* *
 * hasExternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an external subset?
 *
 * Returns 1 if true
 */
/* ***********************************************************************
 *									*
 *			The SAX version 2 API extensions		*
 *									*
 ************************************************************************/
/* *
 * XML_SAX2_MAGIC:
 *
 * Special constant found in SAX2 blocks initialized fields
 */
/* *
 * startElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 * @nb_namespaces:  number of namespace definitions on that node
 * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
 * @nb_attributes:  the number of attributes on that node
 * @nb_defaulted:  the number of defaulted attributes. The defaulted
 *                  ones are at the end of the array
 * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
 *               attribute values.
 *
 * SAX2 callback when an element start has been detected by the parser.
 * It provides the namespace informations for the element, as well as
 * the new namespace declarations on the element.
 */
/* *
 * endElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 *
 * SAX2 callback when an element end has been detected by the parser.
 * It provides the namespace informations for the element.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandler {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: std::os::raw::c_uint,
    pub _private: *mut std::os::raw::c_void,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub serror: xmlStructuredErrorFunc,
}
/* the node in the tree */
/* *
 * xmlParserError:
 *
 * This is an error that the XML (or HTML) parser can generate
 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* 11 */
/* 12 */
/* 13 */
/* 14 */
/* 15 */
/* 16 */
/* 17 */
/* 18 */
/* 19 */
/* 20 */
/* 21 */
/* 22 */
/* 23 */
/* 24 */
/* 25 */
/* 26 */
/* 27 */
/* 28 */
/* 29 */
/* 30 */
/* 31 */
/* 32 */
/* 33 */
/* 34 */
/* 35 */
/* 36 */
/* 37 */
/* 38 */
/* 39 */
/* 40 */
/* 41 */
/* 42 */
/* 43 */
/* 44 */
/* 45 */
/* 46 */
/* 47 */
/* 48 */
/* 49 */
/* 50 */
/* 51 */
/* 52 */
/* 53 */
/* 54 */
/* 55 */
/* 56 */
/* 57 */
/* 58 */
/* 59 */
/* 60 */
/* 61 */
/* 62 */
/* 63 */
/* 64 */
/* 65 */
/* 66 */
/* 67 */
/* 68 */
/* 69 */
/* 70 */
/* 71 */
/* 72 */
/* 73 */
/* 74 */
/* 75 */
/* 76 */
/* 77 */
/* 78 */
/* 79 */
/* 80 */
/* 81 */
/* 82 */
/* 83 */
/* 84 */
/* 85 */
/* 86 */
/* 87 */
/* 88 */
/* 89 */
/* 90 */
/* 91 */
/* 92 */
/* 93 */
/* 94 */
/* 95 */
/* 96 */
/* 97 */
/* 98 */
/* 99 */
/* 100 */
/* 101 */
/* 102 */
/* 103 */
/* 104 */
/* 105 */
/* 106 */
/* 107 */
/* 108 */
/* 109 */
/* 110 */
/* 111 */
/* 201 */
/* 202 */
/* 203 */
/* 204 */
/* 205 */
/* 501 */
/* 502 */
/* 503 */
/* 504 */
/* 505 */
/* 506 */
/* 507 */
/* 508 */
/* 509 */
/* 510 */
/* 511 */
/* 512 */
/* 513 */
/* 514 */
/* 515 */
/* 516 */
/* 517 */
/* 518 */
/* 519 */
/* 520 */
/* 521 */
/* 522 */
/* 523 */
/* 524 */
/* 525 */
/* 526 */
/* 527 */
/* 528 */
/* 529 */
/* 530 */
/* 531 */
/* 532 */
/* 533 */
/* 534 */
/* 535 */
/* 536 */
/* 537 */
/* 538 */
/* 539 */
/* 540 */
/* 541 */
/* 801 */
/* 1001 */
/* 1002 */
/* 1003 */
/* 1004 */
/* 1005 */
/* 1006 */
/* 1007 */
/* 1008 */
/* 1009 */
/* 1010 */
/* 1011 */
/* 1012 */
/* 1013 */
/* 1014 */
/* 1015 */
/* 1016 */
/* 1017 */
/* 1018 */
/* 1019 */
/* 1020 */
/* 1021 */
/* 1022 */
/* 1023 */
/* 1024 */
/* 1025 */
/* 1026 */
/* 1027 */
/* 1028 */
/* 1029 */
/* 1030 */
/* 1031 */
/* 1032 */
/* 1033 */
/* 1034 */
/* 1035 */
/* 1036 */
/* 1037 */
/* 1038 */
/* 1039 */
/* 1040 */
/* 1041 */
/* 1042 */
/* 1043 */
/* 1044 */
/* 1045 */
/* 1046 */
/* 1047 */
/* 1048 */
/* 1049 */
/* 1050 */
/* 1051 */
/* 1052 */
/* 1053 */
/* 1054 */
/* 1055 */
/* 1056 */
/* 1057 */
/* 1058 */
/* 1059 */
/* 1060 */
/* 1061 */
/* 1062 */
/* 1063 */
/* 1064 */
/* 1065 */
/* 1066 */
/* 1067 */
/* 1068 */
/* 1069 */
/* 1070 */
/* 1071 */
/* 1072 */
/* 1073 */
/* 1074 */
/* 1075 */
/* 1076 */
/* 1077 */
/* 1078 */
/* 1079 */
/* 1080 */
/* 1081 */
/* 1082 */
/* 1083 */
/* 1084 */
/* 1085 */
/* 1086 */
/* 1087 */
/* 1088 */
/* 1089 */
/* 1090 */
/* 1091 */
/* 1092 */
/* 1093 */
/* 1094 */
/* 1095 */
/* 1096 */
/* 1097 */
/* 1098 */
/* 1099 */
/* 1100 */
/* 1101 */
/* 1102 */
/* 1103 */
/* 1104 */
/* 1105 */
/* 1106 */
/* 1107 */
/* 1108 */
/* 1109 */
/* 1110 */
/* 1111 */
/* 1112 */
/* 1113 */
/* 1114 */
/* 1115 */
/* 1116 */
/* 1117 */
/* 1118 */
/* 1119 */
/* 1120 */
/* 1121 */
/* 1122 */
/* 1201 */
/* 1202 */
/* 1203 */
/* 1204 */
/* 1205 */
/* 1206 */
/* 1207 */
/* 1208 */
/* 1209 */
/* 1210 */
/* 1211 */
/* 1212 */
/* 1213 */
/* 1214 */
/* 1215 */
/* 1216 */
/* 1217 */
/* 1218 */
/* 1219 */
/* 1220 */
/* 1221 */
/* 1301 */
/* 1302 */
/* 1303 */
/* 1401 */
/* 1402 */
/* 1403 */
/* 1501 */
/* 1502 */
/* 1503 */
/* 1504 */
/* 1505 */
/* 1506 */
/* 1507 */
/* 1508 */
/* 1509 */
/* 1510 */
/* 1511 */
/* 1512 */
/* 1513 */
/* 1514 */
/* 1515 */
/* 1516 */
/* 1517 */
/* 1518 */
/* 1519 */
/* 1520 */
/* 1521 */
/* 1522 */
/* 1523 */
/* 1524 */
/* 1525 */
/* 1526 */
/* 1527 */
/* 1528 */
/* 1529 */
/* 1530 */
/* 1531 */
/* 1532 */
/* 1533 */
/* 1534 */
/* 1535 */
/* 1536 */
/* 1537 */
/* 1538 */
/* 1539 */
/* 1540 */
/* 1541 */
/* 1542 */
/* 1543 */
/* 1544 */
/* 1545 */
/* 1546 */
/* 1547 */
/* 1548 */
/* 1549 */
/* 1550 */
/* 1551 */
/* 1552 */
/* 1553 */
/* 1554 */
/* 1555 */
/* 1556 */
/* 1601 */
/* 1602 */
/* 1603 */
/* 1604 */
/* 1605 */
/* 1606 */
/* 1607 */
/* 1608 */
/* 1609 */
/* 1610 */
/* 1611 */
/* 1612 */
/* 1613 */
/* 1614 */
/* 1615 */
/* 1616 */
/* 1617 */
/* 1618 */
/* 1651 */
/* 1652 */
/* 1653 */
/* 1654 */
/* 1701 */
/* 1702 */
/* 1703 */
/* 1704 */
/* 1705 */
/* 1706 */
/* 1707 */
/* 1708 */
/* 1709 */
/* 1710 */
/* 1711 */
/* 1712 */
/* 1713 */
/* 1714 */
/* 1715 */
/* 1716 */
/* 1717 */
/* 1718 */
/* 1719 */
/* 1720 */
/* 1721 */
/* 1722 */
/* 1723 */
/* 1724 */
/* 1725 */
/* 1726 */
/* 1727 */
/* 1728 */
/* 1729 */
/* 1730 */
/* 1731 */
/* 1732 */
/* 1733 */
/* 1734 */
/* 1735 */
/* 1736 */
/* 1737 */
/* 1738 */
/* 1739 */
/* 1740 */
/* 1741 */
/* 1742 */
/* 1743 */
/* 1744 */
/* 1745 */
/* 1746 */
/* 1747 */
/* 1748 */
/* 1749 */
/* 1750 */
/* 1751 */
/* 1752 */
/* 1753 */
/* 1754 */
/* 1755 */
/* 1756 */
/* 1757 */
/* 1758 */
/* 1759 */
/* 1760 */
/* 1761 */
/* 1762 */
/* 1763 */
/* 1764 */
/* 1765 */
/* 1766 */
/* 1767 */
/* 1768 */
/* 1769 */
/* 1770 */
/* 1771 */
/* 1772 */
/* 1773 */
/* 1774 */
/* 1775 */
/* 1776 */
/* 1777 */
/* 1778 */
/* 1779 */
/* 1780 */
/* 1781 */
/* 1782 */
/* 1783 */
/* 1784 */
/* 1785 */
/* 1786 */
/* 1787 */
/* 1788 */
/* 1789 */
/* 1790 */
/* 1791 */
/* 1792 */
/* 1793 */
/* 1794 */
/* 1795 */
/* 1796 */
/* 1797 */
/* 1798 */
/* 1799 */
/* 1800 */
/* 1802 */
/* 1803 */
/* 1804 */
/* 1805 */
/* 1806 */
/* 1807 */
/* 1808 */
/* 1809 */
/* 1810 */
/* 1811 */
/* 1812 */
/* 1813 */
/* 1814 */
/* 1815 */
/* 1816 */
/* 1817 */
/* 1818 */
/* 1819 */
/* 1820 */
/* 1821 */
/* 1822 */
/* 1823 */
/* 1824 */
/* 1825 */
/* 1826 */
/* 1827 */
/* 1828 */
/* 1829 */
/* 1830 */
/* 1831 */
/* 1832 */
/* 1833 */
/* 1834 */
/* 1835 */
/* 1836 */
/* 1837 */
/* 1838 */
/* 1839 */
/* 1840 */
/* 1841 */
/* 1842 */
/* 1843 */
/* 1844 */
/* 1845 */
/* 1846 */
/* 1847 */
/* 1848 */
/* 1849 */
/* 1850 */
/* 1851 */
/* 1852 */
/* 1853 */
/* 1854 */
/* 1855 */
/* 1856 */
/* 1857 */
/* 1858 */
/* 1859 */
/* 1860 */
/* 1861 */
/* 1862 */
/* 1863 */
/* 1864 */
/* 1865 */
/* 1866 */
/* 1867 */
/* 1868 */
/* 1869 */
/* 1870 */
/* 1871 */
/* 1872 */
/* 1873 */
/* 1874 */
/* 1875 */
/* 1876 */
/* 1877 */
/* 1878 */
/* 1879 */
/* 1901 */
/* 1902 */
/* 1903 */
/* 1951 */
/* 1952 */
/* 1953 */
/* 1954 */
/* 1955 */
/* 2001 */
/* 2002 */
/* 2003 */
/* 2021 */
/* 2022 */
/* 3001 */
/* 3002 */
/* 3003 */
/* 3004 */
/* 3005 */
/* 3006 */
/* 3007 */
/* 3008 */
/* 3009 */
/* 3010 */
/* 3011 */
/* 3012 */
/* 3013 */
/* 3014 */
/* 3015 */
/* 3016 */
/* 3017 */
/* 3018 */
/* 3019 */
/* 3020 */
/* 3021 */
/* 3022 */
/* 3023 */
/* 3024 */
/* 3025 */
/* 3026 */
/* 3027 */
/* 3028 */
/* 3029 */
/* 3030 */
/* 3031 */
/* 3032 */
/* 3033 */
/* 3034 */
/* 3035 */
/* 3036 */
/* 3037 */
/* 3038 */
/* 3039 */
/* 3040 */
/* 3041 */
/* 3042 */
/* 3043 */
/* 3044 */
/* 3045 */
/* 3046 */
/* 3047 */
/* 3048 */
/* 3049 */
/* 3050 */
/* 3051 */
/* 3052 */
/* 3053 */
/* 3054 */
/* 3055 */
/* 3056 */
/* 3057 */
/* 3058 */
/* 3059 */
/* 3060 */
/* 3061 */
/* 3062 */
/* 3063 */
/* 3064 */
/* 3065 */
/* 3066 */
/* 3067 */
/* 3068 */
/* 3069 non-W3C */
/* 3070 non-W3C */
/* 3071 */
/* 3072 */
/* 3073 */
/* 3074 */
/* 3075 */
/* 3076 */
/* 3077 */
/* 3078 */
/* 3079 */
/* 3080 */
/* 3081 */
/* 3082 */
/* 3083 */
/* 3084 */
/* 3085 */
/* 3085 */
/* 3086 */
/* 3087 */
/* 3088 */
/* 3089 */
/* 3090 */
/* 4000 */
/* 4900 */
/* 4901 */
/* 5001 */
/* 5002 */
/* 5003 */
/* 5004 */
/* 5005 */
/* 5006 */
/* 5007 */
/* 5008 */
/* 5009 */
/* 5010 */
/* 5011 */
/* 5012 */
/* 5013 */
/* 5014 */
/* 5015 */
/* 5016 */
/* 5017 */
/* 5018 */
/* 5019 */
/* 5020 */
/* 5021 */
/* 5022 */
/* 5023 */
/* 5024 */
/* 5025 */
/* 5026 */
/* 5027 */
/* 5028 */
/* 5029 */
/* 5030 */
/* 5031 */
/* 5032 */
/* 5033 */
/* 5034 */
/* 5035 */
/* 5036 */
/* 5037 */
/* 6001 */
/* 6002 */
/* 6003 */
/* 6004 */
/* *
 * xmlGenericErrorFunc:
 * @ctx:  a parsing context
 * @msg:  the message
 * @...:  the extra arguments of the varags to format the message
 *
 * Signature of the function to use when there is an error and
 * no parsing or validity context available .
 */
/* *
 * xmlStructuredErrorFunc:
 * @userData:  user provided data for the error callback
 * @error:  the error being raised.
 *
 * Signature of the function to use when there is an error and
 * the module handles the new error reporting mechanism.
 */
pub type xmlStructuredErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlErrorPtr) -> ()>;
pub type xmlErrorPtr = *mut xmlError;
pub type endElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type startElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *mut *const xmlChar,
                                _: std::os::raw::c_int, _: std::os::raw::c_int,
                                _: *mut *const xmlChar) -> ()>;
pub type externalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type cdataBlockSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type getParameterEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type xmlEntityPtr = *mut xmlEntity;
pub type xmlEntity = _xmlEntity;
/*
 * Summary: interface for the XML entities handling
 * Description: this module provides some of the entity API needed
 *              for the parser and applications.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * The different valid entity types.
 */
/*
 * An unit of storage for an entity, contains the string, the value
 * and the linkind data needed for the linking in the hash table.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEntity {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub orig: *mut xmlChar,
    pub content: *mut xmlChar,
    pub length: std::os::raw::c_int,
    pub etype: xmlEntityType,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub nexte: *mut _xmlEntity,
    pub URI: *const xmlChar,
    pub owner: std::os::raw::c_int,
    pub checked: std::os::raw::c_int,
}
pub type xmlEntityType = std::os::raw::c_uint;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub type fatalErrorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type errorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type warningSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type commentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type processingInstructionSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type ignorableWhitespaceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type charactersSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type referenceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type endElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type startElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *mut *const xmlChar) -> ()>;
pub type endDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type startDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type setDocumentLocatorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlSAXLocatorPtr)
               -> ()>;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXLocator = _xmlSAXLocator;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXLocator {
    pub getPublicId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getSystemId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getLineNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                  -> std::os::raw::c_int>,
    pub getColumnNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                    -> std::os::raw::c_int>,
}
pub type unparsedEntityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type elementDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: xmlElementContentPtr)
               -> ()>;
pub type xmlElementContentPtr = *mut xmlElementContent;
pub type xmlElementContent = _xmlElementContent;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElementContent {
    pub type_0: xmlElementContentType,
    pub ocur: xmlElementContentOccur,
    pub name: *const xmlChar,
    pub c1: *mut _xmlElementContent,
    pub c2: *mut _xmlElementContent,
    pub parent: *mut _xmlElementContent,
    pub prefix: *const xmlChar,
}
pub type xmlElementContentOccur = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub type attributeDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: std::os::raw::c_int,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: xmlEnumerationPtr) -> ()>;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
pub type xmlEnumeration = _xmlEnumeration;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEnumeration {
    pub next: *mut _xmlEnumeration,
    pub name: *const xmlChar,
}
pub type notationDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type entityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: *const xmlChar, _: *mut xmlChar) -> ()>;
pub type getEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type resolveEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlParserInputPtr>;
pub type hasExternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type hasInternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type isStandaloneSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type internalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type xmlParserCtxt = _xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
pub type xmlSAXHandler = _xmlSAXHandler;
pub type xmlSAXHandlerPtr = *mut xmlSAXHandler;
pub type xmlBufferAllocationScheme = std::os::raw::c_uint;
pub const XML_BUFFER_ALLOC_BOUNDED: xmlBufferAllocationScheme = 5;
pub const XML_BUFFER_ALLOC_HYBRID: xmlBufferAllocationScheme = 4;
pub const XML_BUFFER_ALLOC_IO: xmlBufferAllocationScheme = 3;
pub const XML_BUFFER_ALLOC_IMMUTABLE: xmlBufferAllocationScheme = 2;
pub const XML_BUFFER_ALLOC_EXACT: xmlBufferAllocationScheme = 1;
pub const XML_BUFFER_ALLOC_DOUBLEIT: xmlBufferAllocationScheme = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlBuffer {
    pub content: *mut xmlChar,
    pub use_0: std::os::raw::c_uint,
    pub size: std::os::raw::c_uint,
    pub alloc: xmlBufferAllocationScheme,
    pub contentIO: *mut xmlChar,
}
pub type xmlBuffer = _xmlBuffer;
pub type xmlBufferPtr = *mut xmlBuffer;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNotation {
    pub name: *const xmlChar,
    pub PublicID: *const xmlChar,
    pub SystemID: *const xmlChar,
}
pub type xmlNotation = _xmlNotation;
pub type xmlNotationPtr = *mut xmlNotation;
pub type xmlAttributeDefault = std::os::raw::c_uint;
pub const XML_ATTRIBUTE_FIXED: xmlAttributeDefault = 4;
pub const XML_ATTRIBUTE_IMPLIED: xmlAttributeDefault = 3;
pub const XML_ATTRIBUTE_REQUIRED: xmlAttributeDefault = 2;
pub const XML_ATTRIBUTE_NONE: xmlAttributeDefault = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttribute {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub nexth: *mut _xmlAttribute,
    pub atype: xmlAttributeType,
    pub def: xmlAttributeDefault,
    pub defaultValue: *const xmlChar,
    pub tree: xmlEnumerationPtr,
    pub prefix: *const xmlChar,
    pub elem: *const xmlChar,
}
pub type xmlAttribute = _xmlAttribute;
pub type xmlAttributePtr = *mut xmlAttribute;
pub type xmlElementTypeVal = std::os::raw::c_uint;
pub const XML_ELEMENT_TYPE_ELEMENT: xmlElementTypeVal = 4;
pub const XML_ELEMENT_TYPE_MIXED: xmlElementTypeVal = 3;
pub const XML_ELEMENT_TYPE_ANY: xmlElementTypeVal = 2;
pub const XML_ELEMENT_TYPE_EMPTY: xmlElementTypeVal = 1;
pub const XML_ELEMENT_TYPE_UNDEFINED: xmlElementTypeVal = 0;
pub type xmlRegexp = _xmlRegexp;
pub type xmlRegexpPtr = *mut xmlRegexp;
pub type xmlRegExecCtxt = _xmlRegExecCtxt;
pub type xmlRegExecCtxtPtr = *mut xmlRegExecCtxt;
pub type xmlExpCtxt = _xmlExpCtxt;
pub type xmlExpCtxtPtr = *mut xmlExpCtxt;
pub type xmlExpNode = _xmlExpNode;
pub type xmlExpNodePtr = *mut xmlExpNode;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElement {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub etype: xmlElementTypeVal,
    pub content: xmlElementContentPtr,
    pub attributes: xmlAttributePtr,
    pub prefix: *const xmlChar,
    pub contModel: xmlRegexpPtr,
}
pub type xmlElement = _xmlElement;
pub type xmlElementPtr = *mut xmlElement;
pub type xmlNsPtr = *mut xmlNs;
pub type xmlDtd = _xmlDtd;
pub type xmlDtdPtr = *mut xmlDtd;
/* set of xmlDocProperties for this document
				   set at the end of parsing */
/* *
 * xmlDOMWrapAcquireNsFunction:
 * @ctxt:  a DOM wrapper context
 * @node:  the context node (element or attribute)
 * @nsName:  the requested namespace name
 * @nsPrefix:  the requested namespace prefix
 *
 * A function called to acquire namespaces (xmlNs) from the wrapper.
 *
 * Returns an xmlNsPtr or NULL in case of an error.
 */
/* *
 * xmlDOMWrapCtxt:
 *
 * Context for DOM wrapper-operations.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDOMWrapCtxt {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: std::os::raw::c_int,
    pub namespaceMap: *mut std::os::raw::c_void,
    pub getNsForNodeFunc: xmlDOMWrapAcquireNsFunction,
}
pub type xmlDOMWrapAcquireNsFunction
    =
    Option<unsafe extern "C" fn(_: xmlDOMWrapCtxtPtr, _: xmlNodePtr,
                                _: *const xmlChar, _: *const xmlChar)
               -> xmlNsPtr>;
pub type xmlDOMWrapCtxtPtr = *mut xmlDOMWrapCtxt;
pub type xmlDOMWrapCtxt = _xmlDOMWrapCtxt;
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */
/* *
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/* *
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
/*
 * Recent version of gcc produce a warning when a function pointer is assigned
 * to an object pointer, or vice versa.  The following macro is a dirty hack
 * to allow suppression of the warning.  If your architecture has function
 * pointers which are a different size than a void pointer, there may be some
 * serious trouble within the library.
 */
/* *
 * XML_CAST_FPTR:
 * @fptr:  pointer to a function
 *
 * Macro to do a casting from an object pointer to a
 * function pointer without encountering a warning from
 * gcc
 *
 * #define XML_CAST_FPTR(fptr) (*(void **)(&fptr))
 * This macro violated ISO C aliasing rules (gcc4 on s390 broke)
 * so it is disabled now
 */
/*
 * function types:
 */
/* *
 * xmlHashDeallocator:
 * @payload:  the data in the hash
 * @name:  the name associated
 *
 * Callback to free data from a hash.
 */
pub type xmlHashDeallocator
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type xmlParserErrors = std::os::raw::c_uint;
pub const XML_BUF_OVERFLOW: xmlParserErrors = 7000;
pub const XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors =
    3007;
pub const XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors =
    3005;
pub const XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const XML_IO_EALREADY: xmlParserErrors = 1555;
pub const XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const XML_IO_EISCONN: xmlParserErrors = 1551;
pub const XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const XML_IO_WRITE: xmlParserErrors = 1546;
pub const XML_IO_FLUSH: xmlParserErrors = 1545;
pub const XML_IO_ENCODER: xmlParserErrors = 1544;
pub const XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const XML_IO_EXDEV: xmlParserErrors = 1542;
pub const XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const XML_IO_ESRCH: xmlParserErrors = 1540;
pub const XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const XML_IO_EROFS: xmlParserErrors = 1538;
pub const XML_IO_ERANGE: xmlParserErrors = 1537;
pub const XML_IO_EPIPE: xmlParserErrors = 1536;
pub const XML_IO_EPERM: xmlParserErrors = 1535;
pub const XML_IO_ENXIO: xmlParserErrors = 1534;
pub const XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const XML_IO_ENOENT: xmlParserErrors = 1524;
pub const XML_IO_ENODEV: xmlParserErrors = 1523;
pub const XML_IO_ENFILE: xmlParserErrors = 1522;
pub const XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const XML_IO_EMLINK: xmlParserErrors = 1519;
pub const XML_IO_EMFILE: xmlParserErrors = 1518;
pub const XML_IO_EISDIR: xmlParserErrors = 1517;
pub const XML_IO_EIO: xmlParserErrors = 1516;
pub const XML_IO_EINVAL: xmlParserErrors = 1515;
pub const XML_IO_EINTR: xmlParserErrors = 1514;
pub const XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const XML_IO_EFBIG: xmlParserErrors = 1512;
pub const XML_IO_EFAULT: xmlParserErrors = 1511;
pub const XML_IO_EEXIST: xmlParserErrors = 1510;
pub const XML_IO_EDOM: xmlParserErrors = 1509;
pub const XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const XML_IO_ECHILD: xmlParserErrors = 1507;
pub const XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const XML_IO_EBUSY: xmlParserErrors = 1505;
pub const XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const XML_IO_EBADF: xmlParserErrors = 1503;
pub const XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const XML_IO_EACCES: xmlParserErrors = 1501;
pub const XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const XML_WAR_NS_URI: xmlParserErrors = 99;
pub const XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const XML_ERR_OK: xmlParserErrors = 0;
pub type xmlGenericErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlLink = _xmlLink;
pub type xmlLinkPtr = *mut xmlLink;
pub type xmlList = _xmlList;
pub type xmlListPtr = *mut xmlList;
/* *
 * xmlListDeallocator:
 * @lk:  the data to deallocate
 *
 * Callback function used to free data from a list.
 */
pub type xmlListDeallocator
    =
    Option<unsafe extern "C" fn(_: xmlLinkPtr) -> ()>;
/* *
 * xmlListDataCompare:
 * @data0: the first data
 * @data1: the second data
 *
 * Callback function used to compare 2 data.
 *
 * Returns 0 is equality, -1 or 1 otherwise depending on the ordering.
 */
pub type xmlListDataCompare
    =
    Option<unsafe extern "C" fn(_: *const std::os::raw::c_void,
                                _: *const std::os::raw::c_void) -> std::os::raw::c_int>;
pub type xmlValidCtxtPtr = *mut xmlValidCtxt;
/* used to build the automata */
/*
 * ALL notation declarations are stored in a table.
 * There is one table per DTD.
 */
pub type xmlNotationTable = _xmlHashTable;
pub type xmlNotationTablePtr = *mut xmlNotationTable;
/*
 * ALL element declarations are stored in a table.
 * There is one table per DTD.
 */
pub type xmlElementTable = _xmlHashTable;
pub type xmlElementTablePtr = *mut xmlElementTable;
/*
 * ALL attribute declarations are stored in a table.
 * There is one table per DTD.
 */
pub type xmlAttributeTable = _xmlHashTable;
pub type xmlAttributeTablePtr = *mut xmlAttributeTable;
/* was the entity content checked */
/* this is also used to count entities
					 * references done from that entity
					 * and if it contains '<' */
/*
 * All entities are stored in an hash table.
 * There is 2 separate hash tables for global and parameter entities.
 */
pub type xmlEntitiesTable = _xmlHashTable;
pub type xmlEntitiesTablePtr = *mut xmlEntitiesTable;
pub type xmlParserNodeInfoPtr = *mut xmlParserNodeInfo;
pub type xmlParserNodeInfoSeqPtr = *mut xmlParserNodeInfoSeq;
/*
 * SAX Version 1
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandlerV1 {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: std::os::raw::c_uint,
}
pub type xmlSAXHandlerV1 = _xmlSAXHandlerV1;
pub type xmlCharEncoding = std::os::raw::c_int;
pub const XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
pub const XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
pub const XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
pub const XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
pub const XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
pub const XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
pub const XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
pub const XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
pub const XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
pub const XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
pub const XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
pub const XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
pub const XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
pub const XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
pub const XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
pub const XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
pub const XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
pub const XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
pub const XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
pub const XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
pub const XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
pub const XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
pub const XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
/*
 * New set of simpler/more flexible APIs
 */
/* *
 * xmlParserOption:
 *
 * This is the set of XML parser options that can be passed down
 * to the xmlReadDoc() and similar calls.
 */
pub type C2RustUnnamed = std::os::raw::c_uint;
/* Store big lines numbers in text PSVI field */
/* ignore internal document encoding hint */
pub const XML_PARSE_BIG_LINES: C2RustUnnamed = 4194304;
/* parse using SAX2 interface before 2.7.0 */
pub const XML_PARSE_IGNORE_ENC: C2RustUnnamed = 2097152;
/* relax any hardcoded limit from the parser */
pub const XML_PARSE_OLDSAX: C2RustUnnamed = 1048576;
/* do not fixup XINCLUDE xml:base uris */
pub const XML_PARSE_HUGE: C2RustUnnamed = 524288;
/* parse using XML-1.0 before update 5 */
pub const XML_PARSE_NOBASEFIX: C2RustUnnamed = 262144;
/* compact small text nodes; no modification of
                                   the tree allowed afterwards (will possibly
				   crash if you try to modify the tree) */
pub const XML_PARSE_OLD10: C2RustUnnamed = 131072;
/* do not generate XINCLUDE START/END nodes */
pub const XML_PARSE_COMPACT: C2RustUnnamed = 65536;
/* merge CDATA as text nodes */
pub const XML_PARSE_NOXINCNODE: C2RustUnnamed = 32768;
/* remove redundant namespaces declarations */
pub const XML_PARSE_NOCDATA: C2RustUnnamed = 16384;
/* Do not reuse the context dictionary */
pub const XML_PARSE_NSCLEAN: C2RustUnnamed = 8192;
/* Forbid network access */
pub const XML_PARSE_NODICT: C2RustUnnamed = 4096;
/* Implement XInclude substitition  */
pub const XML_PARSE_NONET: C2RustUnnamed = 2048;
/* use the SAX1 interface internally */
pub const XML_PARSE_XINCLUDE: C2RustUnnamed = 1024;
/* remove blank nodes */
pub const XML_PARSE_SAX1: C2RustUnnamed = 512;
/* pedantic error reporting */
pub const XML_PARSE_NOBLANKS: C2RustUnnamed = 256;
/* suppress warning reports */
pub const XML_PARSE_PEDANTIC: C2RustUnnamed = 128;
/* suppress error reports */
pub const XML_PARSE_NOWARNING: C2RustUnnamed = 64;
/* validate with the DTD */
pub const XML_PARSE_NOERROR: C2RustUnnamed = 32;
/* default DTD attributes */
pub const XML_PARSE_DTDVALID: C2RustUnnamed = 16;
/* load the external subset */
pub const XML_PARSE_DTDATTR: C2RustUnnamed = 8;
/* substitute entities */
pub const XML_PARSE_DTDLOAD: C2RustUnnamed = 4;
/* recover on errors */
pub const XML_PARSE_NOENT: C2RustUnnamed = 2;
pub const XML_PARSE_RECOVER: C2RustUnnamed = 1;
/*
 * Library wide options
 */
/* *
 * xmlFeature:
 *
 * Used to examine the existance of features that can be enabled
 * or disabled at compile-time.
 * They used to be called XML_FEATURE_xxx but this clashed with Expat
 */
pub type xmlFeature = std::os::raw::c_uint;
pub const XML_WITH_NONE: xmlFeature = 99999;
pub const XML_WITH_LZMA: xmlFeature = 33;
pub const XML_WITH_ICU: xmlFeature = 32;
pub const XML_WITH_ZLIB: xmlFeature = 31;
pub const XML_WITH_DEBUG_RUN: xmlFeature = 30;
pub const XML_WITH_DEBUG_MEM: xmlFeature = 29;
pub const XML_WITH_DEBUG: xmlFeature = 28;
pub const XML_WITH_MODULES: xmlFeature = 27;
pub const XML_WITH_SCHEMATRON: xmlFeature = 26;
pub const XML_WITH_SCHEMAS: xmlFeature = 25;
pub const XML_WITH_EXPR: xmlFeature = 24;
pub const XML_WITH_AUTOMATA: xmlFeature = 23;
pub const XML_WITH_REGEXP: xmlFeature = 22;
pub const XML_WITH_UNICODE: xmlFeature = 21;
pub const XML_WITH_ISO8859X: xmlFeature = 20;
pub const XML_WITH_ICONV: xmlFeature = 19;
pub const XML_WITH_XINCLUDE: xmlFeature = 18;
pub const XML_WITH_XPTR: xmlFeature = 17;
pub const XML_WITH_XPATH: xmlFeature = 16;
pub const XML_WITH_CATALOG: xmlFeature = 15;
pub const XML_WITH_C14N: xmlFeature = 14;
pub const XML_WITH_LEGACY: xmlFeature = 13;
pub const XML_WITH_HTML: xmlFeature = 12;
pub const XML_WITH_VALID: xmlFeature = 11;
pub const XML_WITH_HTTP: xmlFeature = 10;
pub const XML_WITH_FTP: xmlFeature = 9;
pub const XML_WITH_SAX1: xmlFeature = 8;
pub const XML_WITH_WRITER: xmlFeature = 7;
pub const XML_WITH_PATTERN: xmlFeature = 6;
pub const XML_WITH_READER: xmlFeature = 5;
pub const XML_WITH_PUSH: xmlFeature = 4;
pub const XML_WITH_OUTPUT: xmlFeature = 3;
pub const XML_WITH_TREE: xmlFeature = 2;
pub const XML_WITH_THREAD: xmlFeature = 1;
pub type xmlRelaxNG = _xmlRelaxNG;
pub type xmlRelaxNGPtr = *mut xmlRelaxNG;
/* just to be sure of allocation size */
/* *
 * xmlRelaxNGValidityErrorFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of an error callback from a Relax-NG validation
 */
pub type xmlRelaxNGValidityErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
/* *
 * xmlRelaxNGValidityWarningFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of a warning callback from a Relax-NG validation
 */
pub type xmlRelaxNGValidityWarningFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlRelaxNGParserCtxt = _xmlRelaxNGParserCtxt;
pub type xmlRelaxNGParserCtxtPtr = *mut xmlRelaxNGParserCtxt;
pub type xmlRelaxNGValidCtxt = _xmlRelaxNGValidCtxt;
pub type xmlRelaxNGValidCtxtPtr = *mut xmlRelaxNGValidCtxt;
/*
* TODO: Actually all those flags used for the schema should sit
* on the schema parser context, since they are used only
* during parsing an XML schema document, and not available
* on the component level as per spec.
*/
/* *
 * XML_SCHEMAS_QUALIF_ELEM:
 *
 * Reflects elementFormDefault == qualified in
 * an XML schema document.
 */
/* *
 * XML_SCHEMAS_QUALIF_ATTR:
 *
 * Reflects attributeFormDefault == qualified in
 * an XML schema document.
 */
/* *
 * XML_SCHEMAS_FINAL_DEFAULT_EXTENSION:
 *
 * the schema has "extension" in the set of finalDefault.
 */
/* *
 * XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION:
 *
 * the schema has "restriction" in the set of finalDefault.
 */
/* *
 * XML_SCHEMAS_FINAL_DEFAULT_LIST:
 *
 * the cshema has "list" in the set of finalDefault.
 */
/* *
 * XML_SCHEMAS_FINAL_DEFAULT_UNION:
 *
 * the schema has "union" in the set of finalDefault.
 */
/* *
 * XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION:
 *
 * the schema has "extension" in the set of blockDefault.
 */
/* *
 * XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION:
 *
 * the schema has "restriction" in the set of blockDefault.
 */
/* *
 * XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION:
 *
 * the schema has "substitution" in the set of blockDefault.
 */
/* *
 * XML_SCHEMAS_INCLUDING_CONVERT_NS:
 *
 * the schema is currently including an other schema with
 * no target namespace.
 */
/* *
 * _xmlSchema:
 *
 * A Schemas definition
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchema {
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub version: *const xmlChar,
    pub id: *const xmlChar,
    pub doc: xmlDocPtr,
    pub annot: xmlSchemaAnnotPtr,
    pub flags: std::os::raw::c_int,
    pub typeDecl: xmlHashTablePtr,
    pub attrDecl: xmlHashTablePtr,
    pub attrgrpDecl: xmlHashTablePtr,
    pub elemDecl: xmlHashTablePtr,
    pub notaDecl: xmlHashTablePtr,
    pub schemasImports: xmlHashTablePtr,
    pub _private: *mut std::os::raw::c_void,
    pub groupDecl: xmlHashTablePtr,
    pub dict: xmlDictPtr,
    pub includes: *mut std::os::raw::c_void,
    pub preserve: std::os::raw::c_int,
    pub counter: std::os::raw::c_int,
    pub idcDef: xmlHashTablePtr,
    pub volatiles: *mut std::os::raw::c_void,
}
pub type xmlSchemaAnnotPtr = *mut xmlSchemaAnnot;
/* *
 * Annotation
 */
pub type xmlSchemaAnnot = _xmlSchemaAnnot;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnot {
    pub next: *mut _xmlSchemaAnnot,
    pub content: xmlNodePtr,
}
/*
    XML_SCHEMA_VAL_XSI_ASSEMBLE			= 1<<1,
	* assemble schemata using
	* xsi:schemaLocation and
	* xsi:noNamespaceSchemaLocation
*/
/* *
 * The schemas related types are kept internal
 */
pub type xmlSchema = _xmlSchema;
pub type xmlSchemaPtr = *mut xmlSchema;
/* *
 * xmlSchemaValidityErrorFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of an error callback from an XSD validation
 */
pub type xmlSchemaValidityErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
/* *
 * xmlSchemaValidityWarningFunc:
 * @ctx: the validation context
 * @msg: the message
 * @...: extra arguments
 *
 * Signature of a warning callback from an XSD validation
 */
pub type xmlSchemaValidityWarningFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlSchemaParserCtxt = _xmlSchemaParserCtxt;
pub type xmlSchemaParserCtxtPtr = *mut xmlSchemaParserCtxt;
pub type xmlSchemaValidCtxt = _xmlSchemaValidCtxt;
pub type xmlSchemaValidCtxtPtr = *mut xmlSchemaValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSAXPlug {
    pub magic: std::os::raw::c_uint,
    pub user_sax_ptr: *mut xmlSAXHandlerPtr,
    pub user_sax: xmlSAXHandlerPtr,
    pub user_data_ptr: *mut *mut std::os::raw::c_void,
    pub user_data: *mut std::os::raw::c_void,
    pub schemas_sax: xmlSAXHandler,
    pub ctxt: xmlSchemaValidCtxtPtr,
}
/*
 * Interface to insert Schemas SAX validation in a SAX stream
 */
pub type xmlSchemaSAXPlugStruct = _xmlSchemaSAXPlug;
pub type xmlSchemaSAXPlugPtr = *mut xmlSchemaSAXPlugStruct;
/*
 * Summary: the XMLReader implementation
 * Description: API of the XML streaming API based on C# interfaces.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlParserSeverities:
 *
 * How severe an error callback is when the per-reader error callback API
 * is used.
 */
pub type xmlParserSeverities = std::os::raw::c_uint;
pub const XML_PARSER_SEVERITY_ERROR: xmlParserSeverities = 4;
pub const XML_PARSER_SEVERITY_WARNING: xmlParserSeverities = 3;
pub const XML_PARSER_SEVERITY_VALIDITY_ERROR: xmlParserSeverities = 2;
pub const XML_PARSER_SEVERITY_VALIDITY_WARNING: xmlParserSeverities = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlTextReader {
    pub mode: std::os::raw::c_int,
    pub doc: xmlDocPtr,
    pub validate: xmlTextReaderValidate,
    pub allocs: std::os::raw::c_int,
    pub state: xmlTextReaderState,
    pub ctxt: xmlParserCtxtPtr,
    pub sax: xmlSAXHandlerPtr,
    pub input: xmlParserInputBufferPtr,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub characters: charactersSAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub base: std::os::raw::c_uint,
    pub cur: std::os::raw::c_uint,
    pub node: xmlNodePtr,
    pub curnode: xmlNodePtr,
    pub depth: std::os::raw::c_int,
    pub faketext: xmlNodePtr,
    pub preserve: std::os::raw::c_int,
    pub buffer: xmlBufPtr,
    pub dict: xmlDictPtr,
    pub ent: xmlNodePtr,
    pub entNr: std::os::raw::c_int,
    pub entMax: std::os::raw::c_int,
    pub entTab: *mut xmlNodePtr,
    pub errorFunc: xmlTextReaderErrorFunc,
    pub errorFuncArg: *mut std::os::raw::c_void,
    pub rngSchemas: xmlRelaxNGPtr,
    pub rngValidCtxt: xmlRelaxNGValidCtxtPtr,
    pub rngPreserveCtxt: std::os::raw::c_int,
    pub rngValidErrors: std::os::raw::c_int,
    pub rngFullNode: xmlNodePtr,
    pub xsdSchemas: xmlSchemaPtr,
    pub xsdValidCtxt: xmlSchemaValidCtxtPtr,
    pub xsdPreserveCtxt: std::os::raw::c_int,
    pub xsdValidErrors: std::os::raw::c_int,
    pub xsdPlug: xmlSchemaSAXPlugPtr,
    pub xinclude: std::os::raw::c_int,
    pub xinclude_name: *const xmlChar,
    pub xincctxt: xmlXIncludeCtxtPtr,
    pub in_xinclude: std::os::raw::c_int,
    pub patternNr: std::os::raw::c_int,
    pub patternMax: std::os::raw::c_int,
    pub patternTab: *mut xmlPatternPtr,
    pub preserves: std::os::raw::c_int,
    pub parserFlags: std::os::raw::c_int,
    pub sErrorFunc: xmlStructuredErrorFunc,
}
/*
 * Summary: pattern expression handling
 * Description: allows to compile and test pattern expressions for nodes
 *              either in a tree or based on a parser state.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlPattern:
 *
 * A compiled (XPath based) pattern to select nodes
 */
pub type xmlPatternPtr = *mut xmlPattern;
pub type xmlPattern = _xmlPattern;
/*
 * Summary: implementation of XInclude
 * Description: API to handle XInclude processing,
 * implements the
 * World Wide Web Consortium Last Call Working Draft 10 November 2003
 * http://www.w3.org/TR/2003/WD-xinclude-20031110
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * XINCLUDE_NS:
 *
 * Macro defining the Xinclude namespace: http://www.w3.org/2003/XInclude
 */
/* *
 * XINCLUDE_OLD_NS:
 *
 * Macro defining the draft Xinclude namespace: http://www.w3.org/2001/XInclude
 */
/* *
 * XINCLUDE_NODE:
 *
 * Macro defining "include"
 */
/* *
 * XINCLUDE_FALLBACK:
 *
 * Macro defining "fallback"
 */
/* *
 * XINCLUDE_HREF:
 *
 * Macro defining "href"
 */
/* *
 * XINCLUDE_PARSE:
 *
 * Macro defining "parse"
 */
/* *
 * XINCLUDE_PARSE_XML:
 *
 * Macro defining "xml"
 */
/* *
 * XINCLUDE_PARSE_TEXT:
 *
 * Macro defining "text"
 */
/* *
 * XINCLUDE_PARSE_ENCODING:
 *
 * Macro defining "encoding"
 */
/* *
 * XINCLUDE_PARSE_XPOINTER:
 *
 * Macro defining "xpointer"
 */
pub type xmlXIncludeCtxtPtr = *mut xmlXIncludeCtxt;
pub type xmlXIncludeCtxt = _xmlXIncludeCtxt;
/* *
 * xmlTextReader:
 *
 * Structure for an xmlReader context.
 */
/* *
 * xmlTextReaderPtr:
 *
 * Pointer to an xmlReader context.
 */
/*
 * Constructors & Destructor
 */
/*
 * Iterators
 */
/*
 * Attributes of the node
 */
/*
 * use the Const version of the routine for
 * better performance and simpler code
 */
/*
 * Methods of the XmlTextReader
 */
/*
 * Extensions
 */
/* LIBXML_PATTERN_ENABLED */
/*
 * Index lookup
 */
/*
 * New more complete APIs for simpler creation and reuse of readers
 */
/*
 * Error handling extensions
 */
/* *
 * xmlTextReaderErrorFunc:
 * @arg: the user argument
 * @msg: the message
 * @severity: the severity of the error
 * @locator: a locator indicating where the error occurred
 *
 * Signature of an error callback from a reader parser
 */
pub type xmlTextReaderErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: xmlParserSeverities,
                                _: xmlTextReaderLocatorPtr) -> ()>;
pub type xmlTextReaderLocatorPtr = *mut std::os::raw::c_void;
pub type xmlTextReaderState = std::os::raw::c_int;
pub const XML_TEXTREADER_ERROR: xmlTextReaderState = 6;
pub const XML_TEXTREADER_DONE: xmlTextReaderState = 5;
pub const XML_TEXTREADER_BACKTRACK: xmlTextReaderState = 4;
pub const XML_TEXTREADER_EMPTY: xmlTextReaderState = 3;
pub const XML_TEXTREADER_END: xmlTextReaderState = 2;
pub const XML_TEXTREADER_ELEMENT: xmlTextReaderState = 1;
pub const XML_TEXTREADER_START: xmlTextReaderState = 0;
pub const XML_TEXTREADER_NONE: xmlTextReaderState = -1;
pub type xmlTextReaderValidate = std::os::raw::c_uint;
pub const XML_TEXTREADER_VALIDATE_XSD: xmlTextReaderValidate = 4;
pub const XML_TEXTREADER_VALIDATE_RNG: xmlTextReaderValidate = 2;
pub const XML_TEXTREADER_VALIDATE_DTD: xmlTextReaderValidate = 1;
pub const XML_TEXTREADER_NOT_VALIDATE: xmlTextReaderValidate = 0;
pub type xmlTextReader = _xmlTextReader;
pub type xmlTextReaderPtr = *mut xmlTextReader;
pub type xmlStreamCtxt = _xmlStreamCtxt;
pub type xmlStreamCtxtPtr = *mut xmlStreamCtxt;
pub type xmlLocationSetPtr = *mut xmlLocationSet;
/*
 * Summary: API to handle XML Pointers
 * Description: API to handle XML Pointers
 * Base implementation was made accordingly to
 * W3C Candidate Recommendation 7 June 2000
 * http://www.w3.org/TR/2000/CR-xptr-20000607
 *
 * Added support for the element() scheme described in:
 * W3C Proposed Recommendation 13 November 2002
 * http://www.w3.org/TR/2002/PR-xptr-element-20021113/
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * A Location Set
 */
pub type xmlLocationSet = _xmlLocationSet;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlLocationSet {
    pub locNr: std::os::raw::c_int,
    pub locMax: std::os::raw::c_int,
    pub locTab: *mut xmlXPathObjectPtr,
}
pub type xmlXPathObjectPtr = *mut xmlXPathObject;
pub type xmlXPathObject = _xmlXPathObject;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathObject {
    pub type_0: xmlXPathObjectType,
    pub nodesetval: xmlNodeSetPtr,
    pub boolval: std::os::raw::c_int,
    pub floatval: std::os::raw::c_double,
    pub stringval: *mut xmlChar,
    pub user: *mut std::os::raw::c_void,
    pub index: std::os::raw::c_int,
    pub user2: *mut std::os::raw::c_void,
    pub index2: std::os::raw::c_int,
}
pub type xmlNodeSetPtr = *mut xmlNodeSet;
/*
 * A node-set (an unordered collection of nodes without duplicates).
 */
pub type xmlNodeSet = _xmlNodeSet;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNodeSet {
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
}
pub type xmlXPathObjectType = std::os::raw::c_uint;
pub const XPATH_XSLT_TREE: xmlXPathObjectType = 9;
pub const XPATH_USERS: xmlXPathObjectType = 8;
pub const XPATH_LOCATIONSET: xmlXPathObjectType = 7;
pub const XPATH_RANGE: xmlXPathObjectType = 6;
pub const XPATH_POINT: xmlXPathObjectType = 5;
pub const XPATH_STRING: xmlXPathObjectType = 4;
pub const XPATH_NUMBER: xmlXPathObjectType = 3;
pub const XPATH_BOOLEAN: xmlXPathObjectType = 2;
pub const XPATH_NODESET: xmlXPathObjectType = 1;
pub const XPATH_UNDEFINED: xmlXPathObjectType = 0;
pub type xmlXPathParserContextPtr = *mut xmlXPathParserContext;
pub type xmlXPathParserContext = _xmlXPathParserContext;
/* *
 * xmlXPathParserContext:
 *
 * An XPath parser context. It contains pure parsing informations,
 * an xmlXPathContext, and the stack of objects.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathParserContext {
    pub cur: *const xmlChar,
    pub base: *const xmlChar,
    pub error: std::os::raw::c_int,
    pub context: xmlXPathContextPtr,
    pub value: xmlXPathObjectPtr,
    pub valueNr: std::os::raw::c_int,
    pub valueMax: std::os::raw::c_int,
    pub valueTab: *mut xmlXPathObjectPtr,
    pub comp: xmlXPathCompExprPtr,
    pub xptr: std::os::raw::c_int,
    pub ancestor: xmlNodePtr,
    pub valueFrame: std::os::raw::c_int,
}
pub type xmlXPathCompExprPtr = *mut xmlXPathCompExpr;
/*
 * The structure of a compiled expression form is not public.
 */
pub type xmlXPathCompExpr = _xmlXPathCompExpr;
pub type xmlXPathContextPtr = *mut xmlXPathContext;
/*
 * Summary: XML Path Language implementation
 * Description: API for the XML Path Language implementation
 *
 * XML Path Language implementation
 * XPath is a language for addressing parts of an XML document,
 * designed to be used by both XSLT and XPointer
 *     http://www.w3.org/TR/xpath
 *
 * Implements
 * W3C Recommendation 16 November 1999
 *     http://www.w3.org/TR/1999/REC-xpath-19991116
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* LIBXML_XPATH_ENABLED */
/* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED */
pub type xmlXPathContext = _xmlXPathContext;
/* *
 * xmlXPathFlags:
 * Flags for XPath engine compilation and runtime
 */
/* *
 * XML_XPATH_CHECKNS:
 *
 * check namespaces at compilation
 */
/* *
 * XML_XPATH_NOVAR:
 *
 * forbid variables in expression
 */
/* *
 * xmlXPathContext:
 *
 * Expression evaluation occurs with respect to a context.
 * he context consists of:
 *    - a node (the context node)
 *    - a node list (the context node list)
 *    - a set of variable bindings
 *    - a function library
 *    - the set of namespace declarations in scope for the expression
 * Following the switch to hash tables, this need to be trimmed up at
 * the next binary incompatible release.
 * The node may be modified when the context is passed to libxml2
 * for an XPath evaluation so you may need to initialize it again
 * before the next call.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathContext {
    pub doc: xmlDocPtr,
    pub node: xmlNodePtr,
    pub nb_variables_unused: std::os::raw::c_int,
    pub max_variables_unused: std::os::raw::c_int,
    pub varHash: xmlHashTablePtr,
    pub nb_types: std::os::raw::c_int,
    pub max_types: std::os::raw::c_int,
    pub types: xmlXPathTypePtr,
    pub nb_funcs_unused: std::os::raw::c_int,
    pub max_funcs_unused: std::os::raw::c_int,
    pub funcHash: xmlHashTablePtr,
    pub nb_axis: std::os::raw::c_int,
    pub max_axis: std::os::raw::c_int,
    pub axis: xmlXPathAxisPtr,
    pub namespaces: *mut xmlNsPtr,
    pub nsNr: std::os::raw::c_int,
    pub user: *mut std::os::raw::c_void,
    pub contextSize: std::os::raw::c_int,
    pub proximityPosition: std::os::raw::c_int,
    pub xptr: std::os::raw::c_int,
    pub here: xmlNodePtr,
    pub origin: xmlNodePtr,
    pub nsHash: xmlHashTablePtr,
    pub varLookupFunc: xmlXPathVariableLookupFunc,
    pub varLookupData: *mut std::os::raw::c_void,
    pub extra: *mut std::os::raw::c_void,
    pub function: *const xmlChar,
    pub functionURI: *const xmlChar,
    pub funcLookupFunc: xmlXPathFuncLookupFunc,
    pub funcLookupData: *mut std::os::raw::c_void,
    pub tmpNsList: *mut xmlNsPtr,
    pub tmpNsNr: std::os::raw::c_int,
    pub userData: *mut std::os::raw::c_void,
    pub error: xmlStructuredErrorFunc,
    pub lastError: xmlError,
    pub debugNode: xmlNodePtr,
    pub dict: xmlDictPtr,
    pub flags: std::os::raw::c_int,
    pub cache: *mut std::os::raw::c_void,
}
/* *
 * xmlXPathFuncLookupFunc:
 * @ctxt:  an XPath context
 * @name:  name of the function
 * @ns_uri:  the namespace name hosting this function
 *
 * Prototype for callbacks used to plug function lookup in the XPath
 * engine.
 *
 * Returns the XPath function or NULL if not found.
 */
pub type xmlXPathFuncLookupFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlXPathFunction>;
/* the search function */
/* *
 * xmlXPathFunction:
 * @ctxt:  the XPath interprestation context
 * @nargs:  the number of arguments
 *
 * An XPath function.
 * The arguments (if any) are popped out from the context stack
 * and the result is pushed on the stack.
 */
pub type xmlXPathFunction
    =
    Option<unsafe extern "C" fn(_: xmlXPathParserContextPtr, _: std::os::raw::c_int)
               -> ()>;
/*
 * Function and Variable Lookup.
 */
/* *
 * xmlXPathVariableLookupFunc:
 * @ctxt:  an XPath context
 * @name:  name of the variable
 * @ns_uri:  the namespace name hosting this variable
 *
 * Prototype for callbacks used to plug variable lookup in the XPath
 * engine.
 *
 * Returns the XPath object value or NULL if not found.
 */
pub type xmlXPathVariableLookupFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlXPathObjectPtr>;
pub type xmlXPathAxisPtr = *mut xmlXPathAxis;
/*
 * Extra axis: a name and an axis function.
 */
pub type xmlXPathAxis = _xmlXPathAxis;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathAxis {
    pub name: *const xmlChar,
    pub func: xmlXPathAxisFunc,
}
/* the evaluation function */
/* *
 * xmlXPathAxisFunc:
 * @ctxt:  the XPath interpreter context
 * @cur:  the previous node being explored on that axis
 *
 * An axis traversal function. To traverse an axis, the engine calls
 * the first time with cur == NULL and repeat until the function returns
 * NULL indicating the end of the axis traversal.
 *
 * Returns the next node in that axis or NULL if at the end of the axis.
 */
pub type xmlXPathAxisFunc
    =
    Option<unsafe extern "C" fn(_: xmlXPathParserContextPtr,
                                _: xmlXPathObjectPtr) -> xmlXPathObjectPtr>;
pub type xmlXPathTypePtr = *mut xmlXPathType;
/*
 * Extra type: a name and a conversion function.
 */
pub type xmlXPathType = _xmlXPathType;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathType {
    pub name: *const xmlChar,
    pub func: xmlXPathConvertFunc,
}
/* *
 * xmlXPathConvertFunc:
 * @obj:  an XPath object
 * @type:  the number of the target type
 *
 * A conversion function is associated to a type and used to cast
 * the new type to primitive values.
 *
 * Returns -1 in case of error, 0 otherwise
 */
pub type xmlXPathConvertFunc
    =
    Option<unsafe extern "C" fn(_: xmlXPathObjectPtr, _: std::os::raw::c_int)
               -> std::os::raw::c_int>;
pub type xmlTextWriterPtr = *mut xmlTextWriter;
/*
 * Summary: text writing API for XML
 * Description: text writing API for XML
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Alfred Mickautsch <alfred@mickautsch.de>
 */
pub type xmlTextWriter = _xmlTextWriter;
pub type xmlSchemaValPtr = *mut xmlSchemaVal;
pub type xmlSchemaVal = _xmlSchemaVal;
pub type xmlSchemaTypePtr = *mut xmlSchemaType;
pub type xmlSchemaType = _xmlSchemaType;
/* the linked facet */
/* *
 * XML_SCHEMAS_TYPE_MIXED:
 *
 * the element content type is mixed
 */
/* *
 * XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION:
 *
 * the simple or complex type has a derivation method of "extension".
 */
/* *
 * XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION:
 *
 * the simple or complex type has a derivation method of "restriction".
 */
/* *
 * XML_SCHEMAS_TYPE_GLOBAL:
 *
 * the type is global
 */
/* *
 * XML_SCHEMAS_TYPE_OWNED_ATTR_WILDCARD:
 *
 * the complexType owns an attribute wildcard, i.e.
 * it can be freed by the complexType
 */
/* Obsolete. */
/* *
 * XML_SCHEMAS_TYPE_VARIETY_ABSENT:
 *
 * the simpleType has a variety of "absent".
 * TODO: Actually not necessary :-/, since if
 * none of the variety flags occur then it's
 * automatically absent.
 */
/* *
 * XML_SCHEMAS_TYPE_VARIETY_LIST:
 *
 * the simpleType has a variety of "list".
 */
/* *
 * XML_SCHEMAS_TYPE_VARIETY_UNION:
 *
 * the simpleType has a variety of "union".
 */
/* *
 * XML_SCHEMAS_TYPE_VARIETY_ATOMIC:
 *
 * the simpleType has a variety of "union".
 */
/* *
 * XML_SCHEMAS_TYPE_FINAL_EXTENSION:
 *
 * the complexType has a final of "extension".
 */
/* *
 * XML_SCHEMAS_TYPE_FINAL_RESTRICTION:
 *
 * the simpleType/complexType has a final of "restriction".
 */
/* *
 * XML_SCHEMAS_TYPE_FINAL_LIST:
 *
 * the simpleType has a final of "list".
 */
/* *
 * XML_SCHEMAS_TYPE_FINAL_UNION:
 *
 * the simpleType has a final of "union".
 */
/* *
 * XML_SCHEMAS_TYPE_FINAL_DEFAULT:
 *
 * the simpleType has a final of "default".
 */
/* *
 * XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE:
 *
 * Marks the item as a builtin primitive.
 */
/* *
 * XML_SCHEMAS_TYPE_MARKED:
 *
 * Marks the item as marked; used for circular checks.
 */
/* *
 * XML_SCHEMAS_TYPE_BLOCK_DEFAULT:
 *
 * the complexType did not specify 'block' so use the default of the
 * <schema> item.
 */
/* *
 * XML_SCHEMAS_TYPE_BLOCK_EXTENSION:
 *
 * the complexType has a 'block' of "extension".
 */
/* *
 * XML_SCHEMAS_TYPE_BLOCK_RESTRICTION:
 *
 * the complexType has a 'block' of "restriction".
 */
/* *
 * XML_SCHEMAS_TYPE_ABSTRACT:
 *
 * the simple/complexType is abstract.
 */
/* *
 * XML_SCHEMAS_TYPE_FACETSNEEDVALUE:
 *
 * indicates if the facets need a computed value
 */
/* *
 * XML_SCHEMAS_TYPE_INTERNAL_RESOLVED:
 *
 * indicates that the type was typefixed
 */
/* *
 * XML_SCHEMAS_TYPE_INTERNAL_INVALID:
 *
 * indicates that the type is invalid
 */
/* *
 * XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE:
 *
 * a whitespace-facet value of "preserve"
 */
/* *
 * XML_SCHEMAS_TYPE_WHITESPACE_REPLACE:
 *
 * a whitespace-facet value of "replace"
 */
/* *
 * XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE:
 *
 * a whitespace-facet value of "collapse"
 */
/* *
 * XML_SCHEMAS_TYPE_HAS_FACETS:
 *
 * has facets
 */
/* *
 * XML_SCHEMAS_TYPE_NORMVALUENEEDED:
 *
 * indicates if the facets (pattern) need a normalized value
 */
/* *
 * XML_SCHEMAS_TYPE_FIXUP_1:
 *
 * First stage of fixup was done.
 */
/* *
 * XML_SCHEMAS_TYPE_REDEFINED:
 *
 * The type was redefined.
 */
/* *
 * XML_SCHEMAS_TYPE_REDEFINING:
 *
 * The type redefines an other type.
 */
/* #define XML_SCHEMAS_TYPE_REDEFINING    1 << 31 */
/* *
 * _xmlSchemaType:
 *
 * Schemas type definition.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaType {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaType,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub subtypes: xmlSchemaTypePtr,
    pub attributes: xmlSchemaAttributePtr,
    pub node: xmlNodePtr,
    pub minOccurs: std::os::raw::c_int,
    pub maxOccurs: std::os::raw::c_int,
    pub flags: std::os::raw::c_int,
    pub contentType: xmlSchemaContentType,
    pub base: *const xmlChar,
    pub baseNs: *const xmlChar,
    pub baseType: xmlSchemaTypePtr,
    pub facets: xmlSchemaFacetPtr,
    pub redef: *mut _xmlSchemaType,
    pub recurse: std::os::raw::c_int,
    pub attributeUses: *mut xmlSchemaAttributeLinkPtr,
    pub attributeWildcard: xmlSchemaWildcardPtr,
    pub builtInType: std::os::raw::c_int,
    pub memberTypes: xmlSchemaTypeLinkPtr,
    pub facetSet: xmlSchemaFacetLinkPtr,
    pub refPrefix: *const xmlChar,
    pub contentTypeDef: xmlSchemaTypePtr,
    pub contModel: xmlRegexpPtr,
    pub targetNamespace: *const xmlChar,
    pub attrUses: *mut std::os::raw::c_void,
}
pub type xmlSchemaFacetLinkPtr = *mut xmlSchemaFacetLink;
/* the linked type */
/* *
 * xmlSchemaFacetLink:
 * Used to build a list of facets.
 */
pub type xmlSchemaFacetLink = _xmlSchemaFacetLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaFacetLink {
    pub next: *mut _xmlSchemaFacetLink,
    pub facet: xmlSchemaFacetPtr,
}
pub type xmlSchemaFacetPtr = *mut xmlSchemaFacet;
pub type xmlSchemaFacet = _xmlSchemaFacet;
/* The identity-constraint defs */
/*
 * XML_SCHEMAS_FACET_UNKNOWN:
 *
 * unknown facet handling
 */
/*
 * XML_SCHEMAS_FACET_PRESERVE:
 *
 * preserve the type of the facet
 */
/*
 * XML_SCHEMAS_FACET_REPLACE:
 *
 * replace the type of the facet
 */
/*
 * XML_SCHEMAS_FACET_COLLAPSE:
 *
 * collapse the types of the facet
 */
/* *
 * A facet definition.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaFacet {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaFacet,
    pub value: *const xmlChar,
    pub id: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub node: xmlNodePtr,
    pub fixed: std::os::raw::c_int,
    pub whitespace: std::os::raw::c_int,
    pub val: xmlSchemaValPtr,
    pub regexp: xmlRegexpPtr,
}
pub type xmlSchemaTypeType = std::os::raw::c_uint;
pub const XML_SCHEMA_EXTRA_ATTR_USE_PROHIB: xmlSchemaTypeType = 2001;
pub const XML_SCHEMA_EXTRA_QNAMEREF: xmlSchemaTypeType = 2000;
pub const XML_SCHEMA_FACET_MINLENGTH: xmlSchemaTypeType = 1011;
pub const XML_SCHEMA_FACET_MAXLENGTH: xmlSchemaTypeType = 1010;
pub const XML_SCHEMA_FACET_LENGTH: xmlSchemaTypeType = 1009;
pub const XML_SCHEMA_FACET_WHITESPACE: xmlSchemaTypeType = 1008;
pub const XML_SCHEMA_FACET_ENUMERATION: xmlSchemaTypeType = 1007;
pub const XML_SCHEMA_FACET_PATTERN: xmlSchemaTypeType = 1006;
pub const XML_SCHEMA_FACET_FRACTIONDIGITS: xmlSchemaTypeType = 1005;
pub const XML_SCHEMA_FACET_TOTALDIGITS: xmlSchemaTypeType = 1004;
pub const XML_SCHEMA_FACET_MAXEXCLUSIVE: xmlSchemaTypeType = 1003;
pub const XML_SCHEMA_FACET_MAXINCLUSIVE: xmlSchemaTypeType = 1002;
pub const XML_SCHEMA_FACET_MINEXCLUSIVE: xmlSchemaTypeType = 1001;
pub const XML_SCHEMA_FACET_MININCLUSIVE: xmlSchemaTypeType = 1000;
pub const XML_SCHEMA_TYPE_ATTRIBUTE_USE: xmlSchemaTypeType = 26;
pub const XML_SCHEMA_TYPE_PARTICLE: xmlSchemaTypeType = 25;
pub const XML_SCHEMA_TYPE_IDC_KEYREF: xmlSchemaTypeType = 24;
pub const XML_SCHEMA_TYPE_IDC_KEY: xmlSchemaTypeType = 23;
pub const XML_SCHEMA_TYPE_IDC_UNIQUE: xmlSchemaTypeType = 22;
pub const XML_SCHEMA_TYPE_ANY_ATTRIBUTE: xmlSchemaTypeType = 21;
pub const XML_SCHEMA_TYPE_UNION: xmlSchemaTypeType = 20;
pub const XML_SCHEMA_TYPE_LIST: xmlSchemaTypeType = 19;
pub const XML_SCHEMA_TYPE_NOTATION: xmlSchemaTypeType = 18;
pub const XML_SCHEMA_TYPE_GROUP: xmlSchemaTypeType = 17;
pub const XML_SCHEMA_TYPE_ATTRIBUTEGROUP: xmlSchemaTypeType = 16;
pub const XML_SCHEMA_TYPE_ATTRIBUTE: xmlSchemaTypeType = 15;
pub const XML_SCHEMA_TYPE_ELEMENT: xmlSchemaTypeType = 14;
pub const XML_SCHEMA_TYPE_EXTENSION: xmlSchemaTypeType = 13;
pub const XML_SCHEMA_TYPE_RESTRICTION: xmlSchemaTypeType = 12;
pub const XML_SCHEMA_TYPE_UR: xmlSchemaTypeType = 11;
pub const XML_SCHEMA_TYPE_COMPLEX_CONTENT: xmlSchemaTypeType = 10;
pub const XML_SCHEMA_TYPE_SIMPLE_CONTENT: xmlSchemaTypeType = 9;
pub const XML_SCHEMA_TYPE_ALL: xmlSchemaTypeType = 8;
pub const XML_SCHEMA_TYPE_CHOICE: xmlSchemaTypeType = 7;
pub const XML_SCHEMA_TYPE_SEQUENCE: xmlSchemaTypeType = 6;
pub const XML_SCHEMA_TYPE_COMPLEX: xmlSchemaTypeType = 5;
pub const XML_SCHEMA_TYPE_SIMPLE: xmlSchemaTypeType = 4;
pub const XML_SCHEMA_TYPE_FACET: xmlSchemaTypeType = 3;
pub const XML_SCHEMA_TYPE_ANY: xmlSchemaTypeType = 2;
pub const XML_SCHEMA_TYPE_BASIC: xmlSchemaTypeType = 1;
pub type xmlSchemaTypeLinkPtr = *mut xmlSchemaTypeLink;
/* *
 * xmlSchemaTypeLink:
 * Used to build a list of types (e.g. member types of
 * simpleType with variety "union").
 */
pub type xmlSchemaTypeLink = _xmlSchemaTypeLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaTypeLink {
    pub next: *mut _xmlSchemaTypeLink,
    pub type_0: xmlSchemaTypePtr,
}
pub type xmlSchemaWildcardPtr = *mut xmlSchemaWildcard;
/* the value */
/* *
 * xmlSchemaWildcard.
 * A wildcard.
 */
pub type xmlSchemaWildcard = _xmlSchemaWildcard;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaWildcard {
    pub type_0: xmlSchemaTypeType,
    pub id: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub node: xmlNodePtr,
    pub minOccurs: std::os::raw::c_int,
    pub maxOccurs: std::os::raw::c_int,
    pub processContents: std::os::raw::c_int,
    pub any: std::os::raw::c_int,
    pub nsSet: xmlSchemaWildcardNsPtr,
    pub negNsSet: xmlSchemaWildcardNsPtr,
    pub flags: std::os::raw::c_int,
}
pub type xmlSchemaWildcardNsPtr = *mut xmlSchemaWildcardNs;
/* the linked attribute */
/* *
 * XML_SCHEMAS_WILDCARD_COMPLETE:
 *
 * If the wildcard is complete.
 */
/* *
 * xmlSchemaCharValueLink:
 * Used to build a list of namespaces on wildcards.
 */
pub type xmlSchemaWildcardNs = _xmlSchemaWildcardNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaWildcardNs {
    pub next: *mut _xmlSchemaWildcardNs,
    pub value: *const xmlChar,
}
pub type xmlSchemaAttributeLinkPtr = *mut xmlSchemaAttributeLink;
/* Deprecated; not used */
/* *
 * xmlSchemaAttributeLink:
 * Used to build a list of attribute uses on complexType definitions.
 * WARNING: Deprecated; not used.
 */
pub type xmlSchemaAttributeLink = _xmlSchemaAttributeLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeLink {
    pub next: *mut _xmlSchemaAttributeLink,
    pub attr: *mut _xmlSchemaAttribute,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttribute {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaAttribute,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub typeName: *const xmlChar,
    pub typeNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub base: xmlSchemaTypePtr,
    pub occurs: std::os::raw::c_int,
    pub defValue: *const xmlChar,
    pub subtypes: xmlSchemaTypePtr,
    pub node: xmlNodePtr,
    pub targetNamespace: *const xmlChar,
    pub flags: std::os::raw::c_int,
    pub refPrefix: *const xmlChar,
    pub defVal: xmlSchemaValPtr,
    pub refDecl: xmlSchemaAttributePtr,
}
pub type xmlSchemaAttributePtr = *mut xmlSchemaAttribute;
/* the annotation */
/* *
 * XML_SCHEMAS_ANYATTR_SKIP:
 *
 * Skip unknown attribute from validation
 * Obsolete, not used anymore.
 */
/* *
 * XML_SCHEMAS_ANYATTR_LAX:
 *
 * Ignore validation non definition on attributes
 * Obsolete, not used anymore.
 */
/* *
 * XML_SCHEMAS_ANYATTR_STRICT:
 *
 * Apply strict validation rules on attributes
 * Obsolete, not used anymore.
 */
/* *
 * XML_SCHEMAS_ANY_SKIP:
 *
 * Skip unknown attribute from validation
 */
/* *
 * XML_SCHEMAS_ANY_LAX:
 *
 * Used by wildcards.
 * Validate if type found, don't worry if not found
 */
/* *
 * XML_SCHEMAS_ANY_STRICT:
 *
 * Used by wildcards.
 * Apply strict validation rules
 */
/* *
 * XML_SCHEMAS_ATTR_USE_PROHIBITED:
 *
 * Used by wildcards.
 * The attribute is prohibited.
 */
/* *
 * XML_SCHEMAS_ATTR_USE_REQUIRED:
 *
 * The attribute is required.
 */
/* *
 * XML_SCHEMAS_ATTR_USE_OPTIONAL:
 *
 * The attribute is optional.
 */
/* *
 * XML_SCHEMAS_ATTR_GLOBAL:
 *
 * allow elements in no namespace
 */
/* *
 * XML_SCHEMAS_ATTR_NSDEFAULT:
 *
 * allow elements in no namespace
 */
/* *
 * XML_SCHEMAS_ATTR_INTERNAL_RESOLVED:
 *
 * this is set when the "type" and "ref" references
 * have been resolved.
 */
/* *
 * XML_SCHEMAS_ATTR_FIXED:
 *
 * the attribute has a fixed value
 */
/* *
 * xmlSchemaAttribute:
 * An attribute definition.
 */
pub type xmlSchemaAttribute = _xmlSchemaAttribute;
pub type xmlSchemaContentType = std::os::raw::c_uint;
pub const XML_SCHEMA_CONTENT_ANY: xmlSchemaContentType = 7;
pub const XML_SCHEMA_CONTENT_BASIC: xmlSchemaContentType = 6;
pub const XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS: xmlSchemaContentType = 5;
pub const XML_SCHEMA_CONTENT_SIMPLE: xmlSchemaContentType = 4;
pub const XML_SCHEMA_CONTENT_MIXED: xmlSchemaContentType = 3;
pub const XML_SCHEMA_CONTENT_ELEMENTS: xmlSchemaContentType = 2;
pub const XML_SCHEMA_CONTENT_EMPTY: xmlSchemaContentType = 1;
pub const XML_SCHEMA_CONTENT_UNKNOWN: xmlSchemaContentType = 0;
pub type xmlSchemaWhitespaceValueType = std::os::raw::c_uint;
pub const XML_SCHEMA_WHITESPACE_COLLAPSE: xmlSchemaWhitespaceValueType = 3;
pub const XML_SCHEMA_WHITESPACE_REPLACE: xmlSchemaWhitespaceValueType = 2;
pub const XML_SCHEMA_WHITESPACE_PRESERVE: xmlSchemaWhitespaceValueType = 1;
pub const XML_SCHEMA_WHITESPACE_UNKNOWN: xmlSchemaWhitespaceValueType = 0;
pub type xmlSchemaValType = std::os::raw::c_uint;
pub const XML_SCHEMAS_ANYSIMPLETYPE: xmlSchemaValType = 46;
pub const XML_SCHEMAS_ANYTYPE: xmlSchemaValType = 45;
pub const XML_SCHEMAS_BASE64BINARY: xmlSchemaValType = 44;
pub const XML_SCHEMAS_HEXBINARY: xmlSchemaValType = 43;
pub const XML_SCHEMAS_UBYTE: xmlSchemaValType = 42;
pub const XML_SCHEMAS_BYTE: xmlSchemaValType = 41;
pub const XML_SCHEMAS_USHORT: xmlSchemaValType = 40;
pub const XML_SCHEMAS_SHORT: xmlSchemaValType = 39;
pub const XML_SCHEMAS_ULONG: xmlSchemaValType = 38;
pub const XML_SCHEMAS_LONG: xmlSchemaValType = 37;
pub const XML_SCHEMAS_UINT: xmlSchemaValType = 36;
pub const XML_SCHEMAS_INT: xmlSchemaValType = 35;
pub const XML_SCHEMAS_PINTEGER: xmlSchemaValType = 34;
pub const XML_SCHEMAS_NNINTEGER: xmlSchemaValType = 33;
pub const XML_SCHEMAS_NINTEGER: xmlSchemaValType = 32;
pub const XML_SCHEMAS_NPINTEGER: xmlSchemaValType = 31;
pub const XML_SCHEMAS_INTEGER: xmlSchemaValType = 30;
pub const XML_SCHEMAS_ANYURI: xmlSchemaValType = 29;
pub const XML_SCHEMAS_NOTATION: xmlSchemaValType = 28;
pub const XML_SCHEMAS_ENTITIES: xmlSchemaValType = 27;
pub const XML_SCHEMAS_ENTITY: xmlSchemaValType = 26;
pub const XML_SCHEMAS_IDREFS: xmlSchemaValType = 25;
pub const XML_SCHEMAS_IDREF: xmlSchemaValType = 24;
pub const XML_SCHEMAS_ID: xmlSchemaValType = 23;
pub const XML_SCHEMAS_NCNAME: xmlSchemaValType = 22;
pub const XML_SCHEMAS_QNAME: xmlSchemaValType = 21;
pub const XML_SCHEMAS_NAME: xmlSchemaValType = 20;
pub const XML_SCHEMAS_NMTOKENS: xmlSchemaValType = 19;
pub const XML_SCHEMAS_NMTOKEN: xmlSchemaValType = 18;
pub const XML_SCHEMAS_LANGUAGE: xmlSchemaValType = 17;
pub const XML_SCHEMAS_TOKEN: xmlSchemaValType = 16;
pub const XML_SCHEMAS_BOOLEAN: xmlSchemaValType = 15;
pub const XML_SCHEMAS_DOUBLE: xmlSchemaValType = 14;
pub const XML_SCHEMAS_FLOAT: xmlSchemaValType = 13;
pub const XML_SCHEMAS_DURATION: xmlSchemaValType = 12;
pub const XML_SCHEMAS_DATETIME: xmlSchemaValType = 11;
pub const XML_SCHEMAS_DATE: xmlSchemaValType = 10;
pub const XML_SCHEMAS_GYEARMONTH: xmlSchemaValType = 9;
pub const XML_SCHEMAS_GYEAR: xmlSchemaValType = 8;
pub const XML_SCHEMAS_GMONTHDAY: xmlSchemaValType = 7;
pub const XML_SCHEMAS_GMONTH: xmlSchemaValType = 6;
pub const XML_SCHEMAS_GDAY: xmlSchemaValType = 5;
pub const XML_SCHEMAS_TIME: xmlSchemaValType = 4;
pub const XML_SCHEMAS_DECIMAL: xmlSchemaValType = 3;
pub const XML_SCHEMAS_NORMSTRING: xmlSchemaValType = 2;
pub const XML_SCHEMAS_STRING: xmlSchemaValType = 1;
pub const XML_SCHEMAS_UNKNOWN: xmlSchemaValType = 0;
pub type xmlSaveCtxtPtr = *mut xmlSaveCtxt;
pub type xmlSaveCtxt = _xmlSaveCtxt;
pub type xmlModulePtr = *mut xmlModule;
/*
 * Summary: dynamic module loading
 * Description: basic API for dynamic module loading, used by
 *              libexslt added in 2.6.17
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Joel W. Reed
 */
/* *
 * xmlModulePtr:
 *
 * A handle to a dynamically loaded module
 */
pub type xmlModule = _xmlModule;
pub type xmlURIPtr = *mut xmlURI;
/* *
 * Summary: library of generic URI related routines
 * Description: library of generic URI related routines
 *              Implements RFC 2396
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlURI:
 *
 * A parsed URI reference. This is a struct containing the various fields
 * as described in RFC 2396 but separated for further processing.
 *
 * Note: query is a deprecated field which is incorrectly unescaped.
 * query_raw takes precedence over query if the former is set.
 * See: http://mail.gnome.org/archives/xml/2007-April/thread.html#00127
 */
pub type xmlURI = _xmlURI;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlURI {
    pub scheme: *mut std::os::raw::c_char,
    pub opaque: *mut std::os::raw::c_char,
    pub authority: *mut std::os::raw::c_char,
    pub server: *mut std::os::raw::c_char,
    pub user: *mut std::os::raw::c_char,
    pub port: std::os::raw::c_int,
    pub path: *mut std::os::raw::c_char,
    pub query: *mut std::os::raw::c_char,
    pub fragment: *mut std::os::raw::c_char,
    pub cleanup: std::os::raw::c_int,
    pub query_raw: *mut std::os::raw::c_char,
}
pub type xmlSchematronValidCtxtPtr = *mut xmlSchematronValidCtxt;
pub type xmlSchematronValidCtxt = _xmlSchematronValidCtxt;
pub type htmlParserCtxtPtr = xmlParserCtxtPtr;
pub type xmlShellCtxtPtr = *mut xmlShellCtxt;
/* *
 * xmlShellCtxt:
 *
 * A debugging shell context.
 * TODO: add the defined function tables.
 */
pub type xmlShellCtxt = _xmlShellCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlShellCtxt {
    pub filename: *mut std::os::raw::c_char,
    pub doc: xmlDocPtr,
    pub node: xmlNodePtr,
    pub pctxt: xmlXPathContextPtr,
    pub loaded: std::os::raw::c_int,
    pub output: *mut FILE,
    pub input: xmlShellReadlineFunc,
}
/* ***************************************************************
 *								*
 *	 The XML shell related structures and functions		*
 *								*
 ****************************************************************/
/* *
 * xmlShellReadlineFunc:
 * @prompt:  a string prompt
 *
 * This is a generic signature for the XML shell input function.
 *
 * Returns a string which will be freed by the Shell.
 */
pub type xmlShellReadlineFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char>;
pub type xmlChRangeGroup = _xmlChRangeGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlChRangeGroup {
    pub nbShortRange: std::os::raw::c_int,
    pub nbLongRange: std::os::raw::c_int,
    pub shortRange: *const xmlChSRange,
    pub longRange: *const xmlChLRange,
}
pub type xmlChLRange = _xmlChLRange;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlChLRange {
    pub low: std::os::raw::c_uint,
    pub high: std::os::raw::c_uint,
}
/*
 * Summary: Unicode character range checking
 * Description: this module exports interfaces for the character
 *               range validation APIs
 *
 * This file is automatically generated from the cvs source
 * definition files using the genChRanges.py Python script
 *
 * Generation date: Mon Mar 27 11:09:48 2006
 * Sources: chvalid.def
 * Author: William Brack <wbrack@mmm.com.hk>
 */
/*
 * Define our typedefs and structures
 *
 */
pub type xmlChSRange = _xmlChSRange;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlChSRange {
    pub low: std::os::raw::c_ushort,
    pub high: std::os::raw::c_ushort,
}
pub type xmlCatalogPtr = *mut xmlCatalog;
pub type xmlCatalog = _xmlCatalog;
pub type xmlCatalogAllow = std::os::raw::c_uint;
pub const XML_CATA_ALLOW_ALL: xmlCatalogAllow = 3;
pub const XML_CATA_ALLOW_DOCUMENT: xmlCatalogAllow = 2;
pub const XML_CATA_ALLOW_GLOBAL: xmlCatalogAllow = 1;
pub const XML_CATA_ALLOW_NONE: xmlCatalogAllow = 0;
pub type xmlCatalogPrefer = std::os::raw::c_uint;
pub const XML_CATA_PREFER_SYSTEM: xmlCatalogPrefer = 2;
pub const XML_CATA_PREFER_PUBLIC: xmlCatalogPrefer = 1;
pub const XML_CATA_PREFER_NONE: xmlCatalogPrefer = 0;
pub type htmlDocPtr = xmlDocPtr;
pub type htmlSAXHandlerPtr = xmlSAXHandlerPtr;
/* Required attributes */
/*
 * Internal description of an HTML entity.
 */
pub type htmlEntityDesc = _htmlEntityDesc;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _htmlEntityDesc {
    pub value: std::os::raw::c_uint,
    pub name: *const std::os::raw::c_char,
    pub desc: *const std::os::raw::c_char,
}
pub type htmlNodePtr = xmlNodePtr;
pub type htmlStatus = std::os::raw::c_uint;
pub const HTML_REQUIRED: htmlStatus = 12;
pub const HTML_VALID: htmlStatus = 4;
pub const HTML_DEPRECATED: htmlStatus = 2;
pub const HTML_INVALID: htmlStatus = 1;
pub const HTML_NA: htmlStatus = 0;
/*
 * Internal description of an HTML element, representing HTML 4.01
 * and XHTML 1.0 (which share the same structure).
 */
pub type htmlElemDesc = _htmlElemDesc;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _htmlElemDesc {
    pub name: *const std::os::raw::c_char,
    pub startTag: std::os::raw::c_char,
    pub endTag: std::os::raw::c_char,
    pub saveEndTag: std::os::raw::c_char,
    pub empty: std::os::raw::c_char,
    pub depr: std::os::raw::c_char,
    pub dtd: std::os::raw::c_char,
    pub isinline: std::os::raw::c_char,
    pub desc: *const std::os::raw::c_char,
    pub subelts: *mut *const std::os::raw::c_char,
    pub defaultsubelt: *const std::os::raw::c_char,
    pub attrs_opt: *mut *const std::os::raw::c_char,
    pub attrs_depr: *mut *const std::os::raw::c_char,
    pub attrs_req: *mut *const std::os::raw::c_char,
}
static mut generic_errors: std::os::raw::c_int = 0 as std::os::raw::c_int;
static mut call_tests: std::os::raw::c_int = 0 as std::os::raw::c_int;
static mut function_tests: std::os::raw::c_int = 0 as std::os::raw::c_int;
static mut chartab: [xmlChar; 1024] = [0; 1024];
static mut inttab: [std::os::raw::c_int; 1024] = [0; 1024];
static mut longtab: [std::os::raw::c_ulong; 1024] = [0; 1024];
static mut api_doc: xmlDocPtr = 0 as *const xmlDoc as xmlDocPtr;
static mut api_dtd: xmlDtdPtr = 0 as *const xmlDtd as xmlDtdPtr;
static mut api_root: xmlNodePtr = 0 as *const xmlNode as xmlNodePtr;
static mut api_attr: xmlAttrPtr = 0 as *const xmlAttr as xmlAttrPtr;
static mut api_ns: xmlNsPtr = 0 as *const xmlNs as xmlNsPtr;
unsafe extern "C" fn structured_errors(mut userData: *mut std::os::raw::c_void,
                                       mut error: xmlErrorPtr) {
    generic_errors += 1;
}
unsafe extern "C" fn free_api_doc() {
    xmlFreeDoc(api_doc);
    api_doc = 0 as xmlDocPtr;
    api_dtd = 0 as xmlDtdPtr;
    api_root = 0 as xmlNodePtr;
    api_attr = 0 as xmlAttrPtr;
    api_ns = 0 as xmlNsPtr;
}
unsafe extern "C" fn get_api_doc() -> xmlDocPtr {
    if api_doc.is_null() {
        api_doc =
            xmlReadMemory(b"<!DOCTYPE root [<!ELEMENT root EMPTY>]><root xmlns:h=\'http://example.com/\' h:foo=\'bar\'/>\x00"
                              as *const u8 as *const std::os::raw::c_char,
                          88 as std::os::raw::c_int,
                          b"root_test\x00" as *const u8 as
                              *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                          0 as std::os::raw::c_int);
        api_root = 0 as xmlNodePtr;
        api_attr = 0 as xmlAttrPtr
    }
    return api_doc;
}
unsafe extern "C" fn get_api_dtd() -> xmlDtdPtr {
    if api_dtd.is_null() ||
           (*api_dtd).type_0 as std::os::raw::c_uint !=
               XML_DTD_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        get_api_doc();
        if !api_doc.is_null() && !(*api_doc).children.is_null() &&
               (*(*api_doc).children).type_0 as std::os::raw::c_uint ==
                   XML_DTD_NODE as std::os::raw::c_int as std::os::raw::c_uint {
            api_dtd = (*api_doc).children as xmlDtdPtr
        }
    }
    return api_dtd;
}
unsafe extern "C" fn get_api_root() -> xmlNodePtr {
    if api_root.is_null() ||
           (*api_root).type_0 as std::os::raw::c_uint !=
               XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        get_api_doc();
        if !api_doc.is_null() && !(*api_doc).children.is_null() &&
               !(*(*api_doc).children).next.is_null() &&
               (*(*(*api_doc).children).next).type_0 as std::os::raw::c_uint ==
                   XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
            api_root = (*(*api_doc).children).next
        }
    }
    return api_root;
}
unsafe extern "C" fn get_api_ns() -> xmlNsPtr {
    get_api_root();
    if !api_root.is_null() { api_ns = (*api_root).nsDef }
    return api_ns;
}
unsafe extern "C" fn get_api_attr() -> xmlAttrPtr {
    static mut nr: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut name: [xmlChar; 20] = [0; 20];
    if api_root.is_null() ||
           (*api_root).type_0 as std::os::raw::c_uint !=
               XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        get_api_root();
    }
    if api_root.is_null() { return 0 as xmlAttrPtr }
    if !(*api_root).properties.is_null() {
        api_attr = (*api_root).properties;
        return (*api_root).properties
    }
    api_attr = 0 as xmlAttrPtr;
    let fresh0 = nr;
    nr = nr + 1;
    snprintf(name.as_mut_ptr() as *mut std::os::raw::c_char,
             20 as std::os::raw::c_int as std::os::raw::c_ulong,
             b"foo%d\x00" as *const u8 as *const std::os::raw::c_char, fresh0);
    api_attr =
        xmlSetProp(api_root, name.as_mut_ptr(),
                   b"bar\x00" as *const u8 as *const std::os::raw::c_char as
                       *const xmlChar);
    return api_attr;
}
static mut quiet: std::os::raw::c_int = 0 as std::os::raw::c_int;
unsafe fn main_0(mut argc: std::os::raw::c_int, mut argv: *mut *mut std::os::raw::c_char)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    let mut blocks: std::os::raw::c_int = 0;
    let mut mem: std::os::raw::c_int = 0;
    /* access to the proxy can slow up regression tests a lot */
    putenv(b"http_proxy=\x00" as *const u8 as *const std::os::raw::c_char as
               *mut std::os::raw::c_char);
    memset(chartab.as_mut_ptr() as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<[xmlChar; 1024]>() as std::os::raw::c_ulong);
    strncpy(chartab.as_mut_ptr() as *mut std::os::raw::c_char,
            b"  chartab\n\x00" as *const u8 as *const std::os::raw::c_char,
            20 as std::os::raw::c_int as std::os::raw::c_ulong);
    memset(inttab.as_mut_ptr() as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<[std::os::raw::c_int; 1024]>() as std::os::raw::c_ulong);
    memset(longtab.as_mut_ptr() as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<[std::os::raw::c_ulong; 1024]>() as std::os::raw::c_ulong);
    xmlInitParser();
    xmlRelaxNGInitTypes();
    xmlCheckVersion(20908 as std::os::raw::c_int);
    xmlSetStructuredErrorFunc(0 as *mut std::os::raw::c_void,
                              Some(structured_errors as
                                       unsafe extern "C" fn(_:
                                                                *mut std::os::raw::c_void,
                                                            _: xmlErrorPtr)
                                           -> ()));
    if argc >= 2 as std::os::raw::c_int {
        if strcmp(*argv.offset(1 as std::os::raw::c_int as isize),
                  b"-q\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
            quiet = 1 as std::os::raw::c_int;
            if argc >= 3 as std::os::raw::c_int {
                ret = test_module(*argv.offset(2 as std::os::raw::c_int as isize))
            } else { ret = testlibxml2() }
        } else { ret = test_module(*argv.offset(1 as std::os::raw::c_int as isize)) }
    } else { ret = testlibxml2() }
    xmlCleanupParser();
    blocks = xmlMemBlocks();
    mem = xmlMemUsed();
    if blocks != 0 as std::os::raw::c_int || mem != 0 as std::os::raw::c_int {
        printf(b"testapi leaked %d bytes in %d blocks\n\x00" as *const u8 as
                   *const std::os::raw::c_char, mem, blocks);
    }
    xmlMemoryDump();
    return (ret != 0 as std::os::raw::c_int) as std::os::raw::c_int;
}
unsafe extern "C" fn gen_void_ptr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_void {
    return 0 as *mut std::os::raw::c_void;
}
unsafe extern "C" fn des_void_ptr(mut no: std::os::raw::c_int,
                                  mut val: *mut std::os::raw::c_void,
                                  mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_userdata(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_void {
    if no == 0 as std::os::raw::c_int {
        return &mut call_tests as *mut std::os::raw::c_int as *mut std::os::raw::c_void
    }
    if no == 1 as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int) as *mut std::os::raw::c_void
    }
    return 0 as *mut std::os::raw::c_void;
}
unsafe extern "C" fn des_userdata(mut no: std::os::raw::c_int,
                                  mut val: *mut std::os::raw::c_void,
                                  mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_int(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> std::os::raw::c_int {
    if no == 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    if no == 1 as std::os::raw::c_int { return 1 as std::os::raw::c_int }
    if no == 2 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
    if no == 3 as std::os::raw::c_int { return 122 as std::os::raw::c_int }
    return -(1 as std::os::raw::c_int);
}
unsafe extern "C" fn des_int(mut no: std::os::raw::c_int, mut val: std::os::raw::c_int,
                             mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_parseroptions(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> std::os::raw::c_int {
    if no == 0 as std::os::raw::c_int {
        return XML_PARSE_NOBLANKS as std::os::raw::c_int |
                   XML_PARSE_RECOVER as std::os::raw::c_int
    }
    if no == 1 as std::os::raw::c_int {
        return XML_PARSE_NOENT as std::os::raw::c_int |
                   XML_PARSE_DTDLOAD as std::os::raw::c_int |
                   XML_PARSE_DTDATTR as std::os::raw::c_int |
                   XML_PARSE_DTDVALID as std::os::raw::c_int |
                   XML_PARSE_NOCDATA as std::os::raw::c_int
    }
    if no == 2 as std::os::raw::c_int {
        return XML_PARSE_XINCLUDE as std::os::raw::c_int |
                   XML_PARSE_NOXINCNODE as std::os::raw::c_int |
                   XML_PARSE_NSCLEAN as std::os::raw::c_int
    }
    if no == 3 as std::os::raw::c_int {
        return XML_PARSE_XINCLUDE as std::os::raw::c_int |
                   XML_PARSE_NODICT as std::os::raw::c_int
    }
    return XML_PARSE_SAX1 as std::os::raw::c_int;
}
unsafe extern "C" fn des_parseroptions(mut no: std::os::raw::c_int,
                                       mut val: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlChar(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlChar {
    if no == 0 as std::os::raw::c_int { return 'a' as i32 as xmlChar }
    if no == 1 as std::os::raw::c_int { return ' ' as i32 as xmlChar }
    if no == 2 as std::os::raw::c_int { return -8i32 as xmlChar }
    return 0 as std::os::raw::c_int as xmlChar;
}
unsafe extern "C" fn des_xmlChar(mut no: std::os::raw::c_int, mut val: xmlChar,
                                 mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_unsigned_int(mut no: std::os::raw::c_int,
                                      mut nr: std::os::raw::c_int) -> std::os::raw::c_uint {
    if no == 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int as std::os::raw::c_uint }
    if no == 1 as std::os::raw::c_int { return 1 as std::os::raw::c_int as std::os::raw::c_uint }
    if no == 2 as std::os::raw::c_int { return 122 as std::os::raw::c_int as std::os::raw::c_uint }
    return -(1 as std::os::raw::c_int) as std::os::raw::c_uint;
}
unsafe extern "C" fn des_unsigned_int(mut no: std::os::raw::c_int,
                                      mut val: std::os::raw::c_uint,
                                      mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_unsigned_long(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> std::os::raw::c_ulong {
    if no == 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int as std::os::raw::c_ulong }
    if no == 1 as std::os::raw::c_int { return 1 as std::os::raw::c_int as std::os::raw::c_ulong }
    if no == 2 as std::os::raw::c_int { return 122 as std::os::raw::c_int as std::os::raw::c_ulong }
    return -(1 as std::os::raw::c_int) as std::os::raw::c_ulong;
}
unsafe extern "C" fn des_unsigned_long(mut no: std::os::raw::c_int,
                                       mut val: std::os::raw::c_ulong,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_double(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> std::os::raw::c_double {
    if no == 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int as std::os::raw::c_double }
    if no == 1 as std::os::raw::c_int { return -1.1f64 }
    if no == 2 as std::os::raw::c_int { return xmlXPathNAN }
    return -(1 as std::os::raw::c_int) as std::os::raw::c_double;
}
unsafe extern "C" fn des_double(mut no: std::os::raw::c_int, mut val: std::os::raw::c_double,
                                mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_unsigned_long_ptr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_ulong {
    if no == 0 as std::os::raw::c_int {
        return &mut *longtab.as_mut_ptr().offset(nr as isize) as
                   *mut std::os::raw::c_ulong
    }
    return 0 as *mut std::os::raw::c_ulong;
}
unsafe extern "C" fn des_unsigned_long_ptr(mut no: std::os::raw::c_int,
                                           mut val: *mut std::os::raw::c_ulong,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_int_ptr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_int {
    if no == 0 as std::os::raw::c_int {
        return &mut *inttab.as_mut_ptr().offset(nr as isize) as
                   *mut std::os::raw::c_int
    }
    return 0 as *mut std::os::raw::c_int;
}
unsafe extern "C" fn des_int_ptr(mut no: std::os::raw::c_int,
                                 mut val: *mut std::os::raw::c_int,
                                 mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_const_char_ptr(mut no: std::os::raw::c_int,
                                        mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_char {
    if no == 0 as std::os::raw::c_int {
        return b"foo\x00" as *const u8 as *const std::os::raw::c_char as
                   *mut std::os::raw::c_char
    }
    if no == 1 as std::os::raw::c_int {
        return b"<foo/>\x00" as *const u8 as *const std::os::raw::c_char as
                   *mut std::os::raw::c_char
    }
    if no == 2 as std::os::raw::c_int {
        return b"test/ent2\x00" as *const u8 as *const std::os::raw::c_char as
                   *mut std::os::raw::c_char
    }
    return 0 as *mut std::os::raw::c_char;
}
unsafe extern "C" fn des_const_char_ptr(mut no: std::os::raw::c_int,
                                        mut val: *const std::os::raw::c_char,
                                        mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlChar_ptr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> *mut xmlChar {
    if no == 0 as std::os::raw::c_int {
        return &mut *chartab.as_mut_ptr().offset(0 as std::os::raw::c_int as isize) as
                   *mut xmlChar
    }
    return 0 as *mut xmlChar;
}
unsafe extern "C" fn des_xmlChar_ptr(mut no: std::os::raw::c_int,
                                     mut val: *mut xmlChar,
                                     mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_FILE_ptr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> *mut FILE {
    if no == 0 as std::os::raw::c_int {
        return fopen(b"test.out\x00" as *const u8 as *const std::os::raw::c_char,
                     b"a+\x00" as *const u8 as *const std::os::raw::c_char)
    }
    return 0 as *mut FILE;
}
unsafe extern "C" fn des_FILE_ptr(mut no: std::os::raw::c_int, mut val: *mut FILE,
                                  mut nr: std::os::raw::c_int) {
    if !val.is_null() { fclose(val); };
}
unsafe extern "C" fn gen_debug_FILE_ptr(mut no: std::os::raw::c_int,
                                        mut nr: std::os::raw::c_int) -> *mut FILE {
    return fopen(b"test.out\x00" as *const u8 as *const std::os::raw::c_char,
                 b"a+\x00" as *const u8 as *const std::os::raw::c_char);
}
unsafe extern "C" fn des_debug_FILE_ptr(mut no: std::os::raw::c_int,
                                        mut val: *mut FILE,
                                        mut nr: std::os::raw::c_int) {
    if !val.is_null() { fclose(val); };
}
unsafe extern "C" fn gen_const_xmlChar_ptr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> *mut xmlChar {
    if no == 0 as std::os::raw::c_int {
        return b"foo\x00" as *const u8 as *const std::os::raw::c_char as *mut xmlChar
    }
    if no == 1 as std::os::raw::c_int {
        return b"<foo/>\x00" as *const u8 as *const std::os::raw::c_char as
                   *mut xmlChar
    }
    if no == 2 as std::os::raw::c_int {
        return b"n\xf8ne\x00" as *const u8 as *const std::os::raw::c_char as
                   *mut xmlChar
    }
    if no == 3 as std::os::raw::c_int {
        return b" 2ab \x00" as *const u8 as *const std::os::raw::c_char as
                   *mut xmlChar
    }
    return 0 as *mut xmlChar;
}
unsafe extern "C" fn des_const_xmlChar_ptr(mut no: std::os::raw::c_int,
                                           mut val: *const xmlChar,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_filepath(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> *const std::os::raw::c_char {
    if no == 0 as std::os::raw::c_int {
        return b"missing.xml\x00" as *const u8 as *const std::os::raw::c_char
    }
    if no == 1 as std::os::raw::c_int {
        return b"<foo/>\x00" as *const u8 as *const std::os::raw::c_char
    }
    if no == 2 as std::os::raw::c_int {
        return b"test/ent2\x00" as *const u8 as *const std::os::raw::c_char
    }
    if no == 3 as std::os::raw::c_int {
        return b"test/valid/REC-xml-19980210.xml\x00" as *const u8 as
                   *const std::os::raw::c_char
    }
    if no == 4 as std::os::raw::c_int {
        return b"test/valid/dtds/xhtml1-strict.dtd\x00" as *const u8 as
                   *const std::os::raw::c_char
    }
    if no == 5 as std::os::raw::c_int {
        return b"http://localhost/\x00" as *const u8 as *const std::os::raw::c_char
    }
    if no == 6 as std::os::raw::c_int {
        return b"http:http://http\x00" as *const u8 as *const std::os::raw::c_char
    }
    return 0 as *const std::os::raw::c_char;
}
unsafe extern "C" fn des_filepath(mut no: std::os::raw::c_int,
                                  mut val: *const std::os::raw::c_char,
                                  mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_eaten_name(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> *mut xmlChar {
    if no == 0 as std::os::raw::c_int {
        return xmlStrdup(b"eaten\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut xmlChar)
    }
    return 0 as *mut xmlChar;
}
unsafe extern "C" fn des_eaten_name(mut no: std::os::raw::c_int,
                                    mut val: *mut xmlChar,
                                    mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_fileoutput(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> *const std::os::raw::c_char {
    if no == 0 as std::os::raw::c_int {
        return b"/missing.xml\x00" as *const u8 as *const std::os::raw::c_char
    }
    if no == 1 as std::os::raw::c_int {
        return b"<foo/>\x00" as *const u8 as *const std::os::raw::c_char
    }
    if no == 2 as std::os::raw::c_int {
        return b"ftp://localhost/foo\x00" as *const u8 as *const std::os::raw::c_char
    }
    if no == 3 as std::os::raw::c_int {
        return b"http://localhost/\x00" as *const u8 as *const std::os::raw::c_char
    }
    if no == 4 as std::os::raw::c_int {
        return b"http:http://http\x00" as *const u8 as *const std::os::raw::c_char
    }
    return 0 as *const std::os::raw::c_char;
}
unsafe extern "C" fn des_fileoutput(mut no: std::os::raw::c_int,
                                    mut val: *const std::os::raw::c_char,
                                    mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlParserCtxtPtr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlParserCtxtPtr {
    if no == 0 as std::os::raw::c_int { return xmlNewParserCtxt() }
    if no == 1 as std::os::raw::c_int {
        return xmlCreateMemoryParserCtxt(b"<doc/>\x00" as *const u8 as
                                             *const std::os::raw::c_char,
                                         6 as std::os::raw::c_int)
    }
    return 0 as xmlParserCtxtPtr;
}
unsafe extern "C" fn des_xmlParserCtxtPtr(mut no: std::os::raw::c_int,
                                          mut val: xmlParserCtxtPtr,
                                          mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlFreeParserCtxt(val); };
}
unsafe extern "C" fn gen_xmlSAXHandlerPtr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlSAXHandlerPtr {
    if no == 0 as std::os::raw::c_int {
        return __xmlDefaultSAXHandler() as xmlSAXHandlerPtr
    }
    return 0 as xmlSAXHandlerPtr;
}
unsafe extern "C" fn des_xmlSAXHandlerPtr(mut no: std::os::raw::c_int,
                                          mut val: xmlSAXHandlerPtr,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlValidCtxtPtr(mut no: std::os::raw::c_int,
                                         mut nr: std::os::raw::c_int)
 -> xmlValidCtxtPtr {
    if no == 0 as std::os::raw::c_int { return xmlNewValidCtxt() }
    return 0 as xmlValidCtxtPtr;
}
unsafe extern "C" fn des_xmlValidCtxtPtr(mut no: std::os::raw::c_int,
                                         mut val: xmlValidCtxtPtr,
                                         mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlFreeValidCtxt(val); };
}
unsafe extern "C" fn gen_xmlParserInputBufferPtr(mut no: std::os::raw::c_int,
                                                 mut nr: std::os::raw::c_int)
 -> xmlParserInputBufferPtr {
    if no == 0 as std::os::raw::c_int {
        return xmlParserInputBufferCreateFilename(b"missing.xml\x00" as
                                                      *const u8 as
                                                      *const std::os::raw::c_char,
                                                  XML_CHAR_ENCODING_NONE)
    }
    if no == 1 as std::os::raw::c_int {
        return xmlParserInputBufferCreateFilename(b"<foo/>\x00" as *const u8
                                                      as *const std::os::raw::c_char,
                                                  XML_CHAR_ENCODING_NONE)
    }
    if no == 2 as std::os::raw::c_int {
        return xmlParserInputBufferCreateFilename(b"test/ent2\x00" as
                                                      *const u8 as
                                                      *const std::os::raw::c_char,
                                                  XML_CHAR_ENCODING_NONE)
    }
    if no == 3 as std::os::raw::c_int {
        return xmlParserInputBufferCreateFilename(b"test/valid/REC-xml-19980210.xml\x00"
                                                      as *const u8 as
                                                      *const std::os::raw::c_char,
                                                  XML_CHAR_ENCODING_NONE)
    }
    if no == 4 as std::os::raw::c_int {
        return xmlParserInputBufferCreateFilename(b"test/valid/dtds/xhtml1-strict.dtd\x00"
                                                      as *const u8 as
                                                      *const std::os::raw::c_char,
                                                  XML_CHAR_ENCODING_NONE)
    }
    if no == 5 as std::os::raw::c_int {
        return xmlParserInputBufferCreateFilename(b"http://localhost/\x00" as
                                                      *const u8 as
                                                      *const std::os::raw::c_char,
                                                  XML_CHAR_ENCODING_NONE)
    }
    if no == 6 as std::os::raw::c_int {
        return xmlParserInputBufferCreateFilename(b"http:http://http\x00" as
                                                      *const u8 as
                                                      *const std::os::raw::c_char,
                                                  XML_CHAR_ENCODING_NONE)
    }
    return 0 as xmlParserInputBufferPtr;
}
unsafe extern "C" fn des_xmlParserInputBufferPtr(mut no: std::os::raw::c_int,
                                                 mut val:
                                                     xmlParserInputBufferPtr,
                                                 mut nr: std::os::raw::c_int) {
    xmlFreeParserInputBuffer(val);
}
unsafe extern "C" fn gen_xmlDocPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlDocPtr {
    if no == 0 as std::os::raw::c_int {
        return xmlNewDoc(b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut xmlChar)
    }
    if no == 1 as std::os::raw::c_int {
        return xmlReadMemory(b"<foo/>\x00" as *const u8 as
                                 *const std::os::raw::c_char, 6 as std::os::raw::c_int,
                             b"test\x00" as *const u8 as *const std::os::raw::c_char,
                             0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int)
    }
    if no == 2 as std::os::raw::c_int {
        return xmlReadMemory(b"<!DOCTYPE foo []> <foo/>\x00" as *const u8 as
                                 *const std::os::raw::c_char, 24 as std::os::raw::c_int,
                             b"test\x00" as *const u8 as *const std::os::raw::c_char,
                             0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int)
    }
    return 0 as xmlDocPtr;
}
unsafe extern "C" fn des_xmlDocPtr(mut no: std::os::raw::c_int, mut val: xmlDocPtr,
                                   mut nr: std::os::raw::c_int) {
    if !val.is_null() && val != api_doc && (*val).doc != api_doc {
        xmlFreeDoc(val);
    };
}
unsafe extern "C" fn gen_xmlAttrPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlAttrPtr {
    if no == 0 as std::os::raw::c_int { return get_api_attr() }
    return 0 as xmlAttrPtr;
}
unsafe extern "C" fn des_xmlAttrPtr(mut no: std::os::raw::c_int, mut val: xmlAttrPtr,
                                    mut nr: std::os::raw::c_int) {
    if no == 0 as std::os::raw::c_int { free_api_doc(); };
}
unsafe extern "C" fn gen_xmlDictPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlDictPtr {
    if no == 0 as std::os::raw::c_int { return xmlDictCreate() }
    return 0 as xmlDictPtr;
}
unsafe extern "C" fn des_xmlDictPtr(mut no: std::os::raw::c_int, mut val: xmlDictPtr,
                                    mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlDictFree(val); };
}
unsafe extern "C" fn gen_xmlNodePtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlNodePtr {
    if no == 0 as std::os::raw::c_int {
        return xmlNewPI(b"test\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar, 0 as *const xmlChar)
    }
    if no == 1 as std::os::raw::c_int { return get_api_root() }
    return 0 as xmlNodePtr;
    /*     if (no == 2) return((xmlNodePtr) get_api_doc()); */
}
unsafe extern "C" fn des_xmlNodePtr(mut no: std::os::raw::c_int, mut val: xmlNodePtr,
                                    mut nr: std::os::raw::c_int) {
    if no == 1 as std::os::raw::c_int {
        free_api_doc();
    } else if !val.is_null() { xmlUnlinkNode(val); xmlFreeNode(val); };
}
unsafe extern "C" fn gen_xmlDtdPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlDtdPtr {
    if no == 0 as std::os::raw::c_int {
        return xmlNewDtd(0 as xmlDocPtr,
                         b"dtd\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut xmlChar,
                         b"foo\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut xmlChar,
                         b"bar\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut xmlChar)
    }
    if no == 1 as std::os::raw::c_int { return get_api_dtd() }
    return 0 as xmlDtdPtr;
}
unsafe extern "C" fn des_xmlDtdPtr(mut no: std::os::raw::c_int, mut val: xmlDtdPtr,
                                   mut nr: std::os::raw::c_int) {
    if no == 1 as std::os::raw::c_int {
        free_api_doc();
    } else if !val.is_null() {
        xmlUnlinkNode(val as xmlNodePtr);
        xmlFreeNode(val as xmlNodePtr);
    };
}
unsafe extern "C" fn gen_xmlNsPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlNsPtr {
    if no == 0 as std::os::raw::c_int { return get_api_ns() }
    return 0 as xmlNsPtr;
}
unsafe extern "C" fn des_xmlNsPtr(mut no: std::os::raw::c_int, mut val: xmlNsPtr,
                                  mut nr: std::os::raw::c_int) {
    if no == 0 as std::os::raw::c_int { free_api_doc(); };
}
unsafe extern "C" fn gen_xmlNodePtr_in(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> xmlNodePtr {
    if no == 0 as std::os::raw::c_int {
        return xmlNewPI(b"test\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar, 0 as *const xmlChar)
    }
    if no == 0 as std::os::raw::c_int {
        return xmlNewText(b"text\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar)
    }
    return 0 as xmlNodePtr;
}
unsafe extern "C" fn des_xmlNodePtr_in(mut no: std::os::raw::c_int,
                                       mut val: xmlNodePtr,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlTextWriterPtr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlTextWriterPtr {
    if no == 0 as std::os::raw::c_int {
        return xmlNewTextWriterFilename(b"test.out\x00" as *const u8 as
                                            *const std::os::raw::c_char,
                                        0 as std::os::raw::c_int)
    }
    return 0 as xmlTextWriterPtr;
}
unsafe extern "C" fn des_xmlTextWriterPtr(mut no: std::os::raw::c_int,
                                          mut val: xmlTextWriterPtr,
                                          mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlFreeTextWriter(val); };
}
unsafe extern "C" fn gen_xmlTextReaderPtr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlTextReaderPtr {
    if no == 0 as std::os::raw::c_int {
        return xmlNewTextReaderFilename(b"test/ent2\x00" as *const u8 as
                                            *const std::os::raw::c_char)
    }
    if no == 1 as std::os::raw::c_int {
        return xmlNewTextReaderFilename(b"test/valid/REC-xml-19980210.xml\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char)
    }
    if no == 2 as std::os::raw::c_int {
        return xmlNewTextReaderFilename(b"test/valid/dtds/xhtml1-strict.dtd\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char)
    }
    return 0 as xmlTextReaderPtr;
}
unsafe extern "C" fn des_xmlTextReaderPtr(mut no: std::os::raw::c_int,
                                          mut val: xmlTextReaderPtr,
                                          mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlFreeTextReader(val); };
}
static mut static_buf_content: *const xmlChar =
    b"a static buffer\x00" as *const u8 as *const std::os::raw::c_char as
        *mut xmlChar;
unsafe extern "C" fn gen_xmlBufferPtr(mut no: std::os::raw::c_int,
                                      mut nr: std::os::raw::c_int) -> xmlBufferPtr {
    if no == 0 as std::os::raw::c_int { return xmlBufferCreate() }
    if no == 1 as std::os::raw::c_int {
        return xmlBufferCreateStatic(static_buf_content as *mut std::os::raw::c_void,
                                     13 as std::os::raw::c_int as size_t)
    }
    return 0 as xmlBufferPtr;
}
unsafe extern "C" fn des_xmlBufferPtr(mut no: std::os::raw::c_int,
                                      mut val: xmlBufferPtr,
                                      mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlBufferFree(val); };
}
unsafe extern "C" fn gen_xmlListPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlListPtr {
    if no == 0 as std::os::raw::c_int { return xmlListCreate(None, None) }
    return 0 as xmlListPtr;
}
unsafe extern "C" fn des_xmlListPtr(mut no: std::os::raw::c_int, mut val: xmlListPtr,
                                    mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlListDelete(val); };
}
unsafe extern "C" fn gen_xmlHashTablePtr(mut no: std::os::raw::c_int,
                                         mut nr: std::os::raw::c_int)
 -> xmlHashTablePtr {
    if no == 0 as std::os::raw::c_int { return xmlHashCreate(10 as std::os::raw::c_int) }
    return 0 as xmlHashTablePtr;
}
unsafe extern "C" fn des_xmlHashTablePtr(mut no: std::os::raw::c_int,
                                         mut val: xmlHashTablePtr,
                                         mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlHashFree(val, None); };
}
unsafe extern "C" fn gen_xmlXPathObjectPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> xmlXPathObjectPtr {
    if no == 0 as std::os::raw::c_int {
        return xmlXPathNewString(b"string object\x00" as *const u8 as
                                     *const std::os::raw::c_char as *mut xmlChar)
    }
    if no == 1 as std::os::raw::c_int { return xmlXPathNewFloat(1.1f64) }
    if no == 2 as std::os::raw::c_int { return xmlXPathNewBoolean(1 as std::os::raw::c_int) }
    if no == 3 as std::os::raw::c_int { return xmlXPathNewNodeSet(0 as xmlNodePtr) }
    return 0 as xmlXPathObjectPtr;
}
unsafe extern "C" fn des_xmlXPathObjectPtr(mut no: std::os::raw::c_int,
                                           mut val: xmlXPathObjectPtr,
                                           mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlXPathFreeObject(val); };
}
unsafe extern "C" fn gen_xmlOutputBufferPtr(mut no: std::os::raw::c_int,
                                            mut nr: std::os::raw::c_int)
 -> xmlOutputBufferPtr {
    if no == 0 as std::os::raw::c_int {
        return xmlOutputBufferCreateFilename(b"test.out\x00" as *const u8 as
                                                 *const std::os::raw::c_char,
                                             0 as xmlCharEncodingHandlerPtr,
                                             0 as std::os::raw::c_int)
    }
    return 0 as xmlOutputBufferPtr;
}
unsafe extern "C" fn des_xmlOutputBufferPtr(mut no: std::os::raw::c_int,
                                            mut val: xmlOutputBufferPtr,
                                            mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlOutputBufferClose(val); };
}
unsafe extern "C" fn gen_xmlNanoFTPCtxtPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_void {
    if no == 0 as std::os::raw::c_int {
        return xmlNanoFTPNewCtxt(b"ftp://localhost/foo\x00" as *const u8 as
                                     *const std::os::raw::c_char)
    }
    if no == 1 as std::os::raw::c_int {
        return xmlNanoFTPNewCtxt(b"http://localhost/\x00" as *const u8 as
                                     *const std::os::raw::c_char)
    }
    if no == 2 as std::os::raw::c_int {
        return xmlNanoFTPNewCtxt(b"foo\x00" as *const u8 as
                                     *const std::os::raw::c_char)
    }
    return 0 as *mut std::os::raw::c_void;
}
unsafe extern "C" fn des_xmlNanoFTPCtxtPtr(mut no: std::os::raw::c_int,
                                           mut val: *mut std::os::raw::c_void,
                                           mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlNanoFTPFreeCtxt(val); };
}
unsafe extern "C" fn gen_xmlNanoHTTPCtxtPtr(mut no: std::os::raw::c_int,
                                            mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_void {
    if no == 0 as std::os::raw::c_int {
        return xmlNanoHTTPOpen(b"http://localhost/\x00" as *const u8 as
                                   *const std::os::raw::c_char,
                               0 as *mut *mut std::os::raw::c_char)
    }
    if no == 1 as std::os::raw::c_int {
        return xmlNanoHTTPOpen(b"ftp://localhost/foo\x00" as *const u8 as
                                   *const std::os::raw::c_char,
                               0 as *mut *mut std::os::raw::c_char)
    }
    if no == 2 as std::os::raw::c_int {
        return xmlNanoHTTPOpen(b"http:http://http\x00" as *const u8 as
                                   *const std::os::raw::c_char,
                               0 as *mut *mut std::os::raw::c_char)
    }
    return 0 as *mut std::os::raw::c_void;
}
unsafe extern "C" fn des_xmlNanoHTTPCtxtPtr(mut no: std::os::raw::c_int,
                                            mut val: *mut std::os::raw::c_void,
                                            mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlNanoHTTPClose(val); };
}
unsafe extern "C" fn gen_xmlCharEncoding(mut no: std::os::raw::c_int,
                                         mut nr: std::os::raw::c_int)
 -> xmlCharEncoding {
    if no == 0 as std::os::raw::c_int { return XML_CHAR_ENCODING_UTF8 }
    if no == 1 as std::os::raw::c_int { return XML_CHAR_ENCODING_NONE }
    if no == 2 as std::os::raw::c_int { return XML_CHAR_ENCODING_8859_1 }
    return XML_CHAR_ENCODING_ERROR;
}
unsafe extern "C" fn des_xmlCharEncoding(mut no: std::os::raw::c_int,
                                         mut val: xmlCharEncoding,
                                         mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlExpCtxtPtr(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> xmlExpCtxtPtr {
    return 0 as xmlExpCtxtPtr;
}
unsafe extern "C" fn des_xmlExpCtxtPtr(mut no: std::os::raw::c_int,
                                       mut val: xmlExpCtxtPtr,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlExpNodePtr(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> xmlExpNodePtr {
    return 0 as xmlExpNodePtr;
}
unsafe extern "C" fn des_xmlExpNodePtr(mut no: std::os::raw::c_int,
                                       mut val: xmlExpNodePtr,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlSchemaPtr(mut no: std::os::raw::c_int,
                                      mut nr: std::os::raw::c_int) -> xmlSchemaPtr {
    return 0 as xmlSchemaPtr;
}
unsafe extern "C" fn des_xmlSchemaPtr(mut no: std::os::raw::c_int,
                                      mut val: xmlSchemaPtr,
                                      mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlSchemaValidCtxtPtr(mut no: std::os::raw::c_int,
                                               mut nr: std::os::raw::c_int)
 -> xmlSchemaValidCtxtPtr {
    return 0 as xmlSchemaValidCtxtPtr;
}
unsafe extern "C" fn des_xmlSchemaValidCtxtPtr(mut no: std::os::raw::c_int,
                                               mut val: xmlSchemaValidCtxtPtr,
                                               mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlHashDeallocator(mut payload: *mut std::os::raw::c_void,
                                             mut name: *const xmlChar) {
}
unsafe extern "C" fn gen_xmlHashDeallocator(mut no: std::os::raw::c_int,
                                            mut nr: std::os::raw::c_int)
 -> xmlHashDeallocator {
    if no == 0 as std::os::raw::c_int {
        return Some(test_xmlHashDeallocator as
                        unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                             _: *const xmlChar) -> ())
    }
    return None;
}
unsafe extern "C" fn des_xmlHashDeallocator(mut no: std::os::raw::c_int,
                                            mut val: xmlHashDeallocator,
                                            mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn desret_int(mut val: std::os::raw::c_int) { }
unsafe extern "C" fn desret_xmlChar(mut val: xmlChar) { }
unsafe extern "C" fn desret_long(mut val: std::os::raw::c_long) { }
unsafe extern "C" fn desret_unsigned_long(mut val: std::os::raw::c_ulong) { }
unsafe extern "C" fn desret_double(mut val: std::os::raw::c_double) { }
unsafe extern "C" fn desret_xmlCharEncoding(mut val: xmlCharEncoding) { }
unsafe extern "C" fn desret_void_ptr(mut val: *mut std::os::raw::c_void) { }
unsafe extern "C" fn desret_const_char_ptr(mut val: *const std::os::raw::c_char) { }
unsafe extern "C" fn desret_const_xmlChar_ptr(mut val: *const xmlChar) { }
unsafe extern "C" fn desret_xmlChar_ptr(mut val: *mut xmlChar) {
    if !val.is_null() {
        xmlFree.expect("non-null function pointer")(val as *mut std::os::raw::c_void);
    };
}
unsafe extern "C" fn desret_xmlDocPtr(mut val: xmlDocPtr) {
    if val != api_doc { xmlFreeDoc(val); };
}
unsafe extern "C" fn desret_xmlDictPtr(mut val: xmlDictPtr) {
    xmlDictFree(val);
}
unsafe extern "C" fn desret_xmlOutputBufferPtr(mut val: xmlOutputBufferPtr) {
    xmlOutputBufferClose(val);
}
unsafe extern "C" fn desret_xmlTextReaderPtr(mut val: xmlTextReaderPtr) {
    xmlFreeTextReader(val);
}
unsafe extern "C" fn desret_xmlNodePtr(mut val: xmlNodePtr) {
    if !val.is_null() && val != api_root && val != api_doc as xmlNodePtr {
        xmlUnlinkNode(val);
        xmlFreeNode(val);
    };
}
unsafe extern "C" fn desret_xmlAttrPtr(mut val: xmlAttrPtr) {
    if !val.is_null() {
        xmlUnlinkNode(val as xmlNodePtr);
        xmlFreeNode(val as xmlNodePtr);
    };
}
unsafe extern "C" fn desret_xmlEntityPtr(mut val: xmlEntityPtr) {
    if !val.is_null() {
        xmlUnlinkNode(val as xmlNodePtr);
        xmlFreeNode(val as xmlNodePtr);
    };
}
unsafe extern "C" fn desret_xmlElementPtr(mut val: xmlElementPtr) {
    if !val.is_null() { xmlUnlinkNode(val as xmlNodePtr); };
}
unsafe extern "C" fn desret_xmlAttributePtr(mut val: xmlAttributePtr) {
    if !val.is_null() { xmlUnlinkNode(val as xmlNodePtr); };
}
unsafe extern "C" fn desret_xmlNsPtr(mut val: xmlNsPtr) { }
unsafe extern "C" fn desret_xmlDtdPtr(mut val: xmlDtdPtr) {
    desret_xmlNodePtr(val as xmlNodePtr);
}
unsafe extern "C" fn desret_xmlXPathObjectPtr(mut val: xmlXPathObjectPtr) {
    xmlXPathFreeObject(val);
}
unsafe extern "C" fn desret_xmlNodeSetPtr(mut val: xmlNodeSetPtr) {
    xmlXPathFreeNodeSet(val);
}
unsafe extern "C" fn desret_xmlParserCtxtPtr(mut val: xmlParserCtxtPtr) {
    xmlFreeParserCtxt(val);
}
unsafe extern "C" fn desret_xmlParserInputBufferPtr(mut val:
                                                        xmlParserInputBufferPtr) {
    xmlFreeParserInputBuffer(val);
}
unsafe extern "C" fn desret_xmlParserInputPtr(mut val: xmlParserInputPtr) {
    xmlFreeInputStream(val);
}
unsafe extern "C" fn desret_xmlTextWriterPtr(mut val: xmlTextWriterPtr) {
    xmlFreeTextWriter(val);
}
unsafe extern "C" fn desret_xmlBufferPtr(mut val: xmlBufferPtr) {
    xmlBufferFree(val);
}
unsafe extern "C" fn desret_xmlSchemaParserCtxtPtr(mut val:
                                                       xmlSchemaParserCtxtPtr) {
    xmlSchemaFreeParserCtxt(val);
}
unsafe extern "C" fn desret_xmlSchemaTypePtr(mut val: xmlSchemaTypePtr) { }
unsafe extern "C" fn desret_xmlRelaxNGParserCtxtPtr(mut val:
                                                        xmlRelaxNGParserCtxtPtr) {
    xmlRelaxNGFreeParserCtxt(val);
}
unsafe extern "C" fn desret_const_htmlEntityDesc_ptr(mut val:
                                                         *const htmlEntityDesc) {
}
unsafe extern "C" fn desret_xmlNanoHTTPCtxtPtr(mut val: *mut std::os::raw::c_void) {
    xmlNanoHTTPClose(val);
}
unsafe extern "C" fn desret_xmlNanoFTPCtxtPtr(mut val: *mut std::os::raw::c_void) {
    xmlNanoFTPClose(val);
}
unsafe extern "C" fn gen_const_xmlChar_ptr_ptr(mut no: std::os::raw::c_int,
                                               mut nr: std::os::raw::c_int)
 -> *mut *mut xmlChar {
    return 0 as *mut *mut xmlChar;
}
unsafe extern "C" fn des_const_xmlChar_ptr_ptr(mut no: std::os::raw::c_int,
                                               mut val: *mut *const xmlChar,
                                               mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_unsigned_char_ptr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_uchar {
    return 0 as *mut std::os::raw::c_uchar;
}
unsafe extern "C" fn des_unsigned_char_ptr(mut no: std::os::raw::c_int,
                                           mut val: *mut std::os::raw::c_uchar,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_const_unsigned_char_ptr(mut no: std::os::raw::c_int,
                                                 mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_uchar {
    return 0 as *mut std::os::raw::c_uchar;
}
unsafe extern "C" fn des_const_unsigned_char_ptr(mut no: std::os::raw::c_int,
                                                 mut val:
                                                     *const std::os::raw::c_uchar,
                                                 mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_const_htmlNodePtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> htmlNodePtr {
    return 0 as htmlNodePtr;
}
unsafe extern "C" fn des_const_htmlNodePtr(mut no: std::os::raw::c_int,
                                           val: htmlNodePtr,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_htmlDocPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> htmlDocPtr {
    if no == 0 as std::os::raw::c_int {
        return htmlNewDoc(0 as *const xmlChar, 0 as *const xmlChar)
    }
    if no == 1 as std::os::raw::c_int {
        return htmlReadMemory(b"<html/>\x00" as *const u8 as
                                  *const std::os::raw::c_char, 7 as std::os::raw::c_int,
                              b"test\x00" as *const u8 as *const std::os::raw::c_char,
                              0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int)
    }
    return 0 as htmlDocPtr;
}
unsafe extern "C" fn des_htmlDocPtr(mut no: std::os::raw::c_int, mut val: htmlDocPtr,
                                    mut nr: std::os::raw::c_int) {
    if !val.is_null() && val != api_doc && (*val).doc != api_doc {
        xmlFreeDoc(val);
    };
}
unsafe extern "C" fn desret_htmlDocPtr(mut val: htmlDocPtr) {
    if !val.is_null() && val != api_doc && (*val).doc != api_doc {
        xmlFreeDoc(val);
    };
}
unsafe extern "C" fn gen_htmlParserCtxtPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> htmlParserCtxtPtr {
    if no == 0 as std::os::raw::c_int { return xmlNewParserCtxt() }
    if no == 1 as std::os::raw::c_int {
        return htmlCreateMemoryParserCtxt(b"<html/>\x00" as *const u8 as
                                              *const std::os::raw::c_char,
                                          7 as std::os::raw::c_int)
    }
    return 0 as htmlParserCtxtPtr;
}
unsafe extern "C" fn des_htmlParserCtxtPtr(mut no: std::os::raw::c_int,
                                           mut val: htmlParserCtxtPtr,
                                           mut nr: std::os::raw::c_int) {
    if !val.is_null() { htmlFreeParserCtxt(val); };
}
unsafe extern "C" fn desret_htmlParserCtxtPtr(mut val: htmlParserCtxtPtr) {
    if !val.is_null() { htmlFreeParserCtxt(val); };
}
unsafe extern "C" fn gen_xmlNodeSetPtr(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> xmlNodeSetPtr {
    return 0 as xmlNodeSetPtr;
}
unsafe extern "C" fn des_xmlNodeSetPtr(mut no: std::os::raw::c_int,
                                       mut val: xmlNodeSetPtr,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlShellCtxtPtr(mut no: std::os::raw::c_int,
                                         mut nr: std::os::raw::c_int)
 -> xmlShellCtxtPtr {
    return 0 as xmlShellCtxtPtr;
}
unsafe extern "C" fn des_xmlShellCtxtPtr(mut no: std::os::raw::c_int,
                                         mut val: xmlShellCtxtPtr,
                                         mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlPatternPtr(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> xmlPatternPtr {
    return 0 as xmlPatternPtr;
}
unsafe extern "C" fn des_xmlPatternPtr(mut no: std::os::raw::c_int,
                                       mut val: xmlPatternPtr,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlElementContentPtr(mut no: std::os::raw::c_int,
                                              mut nr: std::os::raw::c_int)
 -> xmlElementContentPtr {
    return 0 as xmlElementContentPtr;
}
unsafe extern "C" fn des_xmlElementContentPtr(mut no: std::os::raw::c_int,
                                              mut val: xmlElementContentPtr,
                                              mut nr: std::os::raw::c_int) {
    if !val.is_null() { xmlFreeElementContent(val); };
}
unsafe extern "C" fn desret_xmlElementContentPtr(mut val:
                                                     xmlElementContentPtr) {
    if !val.is_null() { xmlFreeElementContent(val); };
}
unsafe extern "C" fn gen_xmlParserNodeInfoSeqPtr(mut no: std::os::raw::c_int,
                                                 mut nr: std::os::raw::c_int)
 -> xmlParserNodeInfoSeqPtr {
    return 0 as xmlParserNodeInfoSeqPtr;
}
unsafe extern "C" fn des_xmlParserNodeInfoSeqPtr(mut no: std::os::raw::c_int,
                                                 mut val:
                                                     xmlParserNodeInfoSeqPtr,
                                                 mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn desret_const_xmlParserNodeInfo_ptr(mut val:
                                                            *const xmlParserNodeInfo) {
}
unsafe extern "C" fn gen_void_ptr_ptr(mut no: std::os::raw::c_int,
                                      mut nr: std::os::raw::c_int)
 -> *mut *mut std::os::raw::c_void {
    return 0 as *mut *mut std::os::raw::c_void;
}
unsafe extern "C" fn des_void_ptr_ptr(mut no: std::os::raw::c_int,
                                      mut val: *mut *mut std::os::raw::c_void,
                                      mut nr: std::os::raw::c_int) {
}
/* ***********************************************************************
 *									*
 *   WARNING: end of the manually maintained part of the test code	*
 *            do not remove or alter the CUT HERE line			*
 *									*
 ************************************************************************/
/* CUT HERE: everything below that line is generated */
unsafe extern "C" fn desret_htmlStatus(mut val: htmlStatus) { }
unsafe extern "C" fn gen_xmlAttributeDefault(mut no: std::os::raw::c_int,
                                             mut nr: std::os::raw::c_int)
 -> xmlAttributeDefault {
    if no == 1 as std::os::raw::c_int { return XML_ATTRIBUTE_FIXED }
    if no == 2 as std::os::raw::c_int { return XML_ATTRIBUTE_IMPLIED }
    if no == 3 as std::os::raw::c_int { return XML_ATTRIBUTE_NONE }
    if no == 4 as std::os::raw::c_int { return XML_ATTRIBUTE_REQUIRED }
    return 0 as xmlAttributeDefault;
}
unsafe extern "C" fn des_xmlAttributeDefault(mut no: std::os::raw::c_int,
                                             mut val: xmlAttributeDefault,
                                             mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlAttributeType(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlAttributeType {
    if no == 1 as std::os::raw::c_int { return XML_ATTRIBUTE_CDATA }
    if no == 2 as std::os::raw::c_int { return XML_ATTRIBUTE_ENTITIES }
    if no == 3 as std::os::raw::c_int { return XML_ATTRIBUTE_ENTITY }
    if no == 4 as std::os::raw::c_int { return XML_ATTRIBUTE_ENUMERATION }
    return 0 as xmlAttributeType;
}
unsafe extern "C" fn des_xmlAttributeType(mut no: std::os::raw::c_int,
                                          mut val: xmlAttributeType,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlBufferAllocationScheme(mut no: std::os::raw::c_int,
                                                   mut nr: std::os::raw::c_int)
 -> xmlBufferAllocationScheme {
    if no == 1 as std::os::raw::c_int { return XML_BUFFER_ALLOC_BOUNDED }
    if no == 2 as std::os::raw::c_int { return XML_BUFFER_ALLOC_DOUBLEIT }
    if no == 3 as std::os::raw::c_int { return XML_BUFFER_ALLOC_EXACT }
    if no == 4 as std::os::raw::c_int { return XML_BUFFER_ALLOC_HYBRID }
    return XML_BUFFER_ALLOC_DOUBLEIT;
}
unsafe extern "C" fn des_xmlBufferAllocationScheme(mut no: std::os::raw::c_int,
                                                   mut val:
                                                       xmlBufferAllocationScheme,
                                                   mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn desret_xmlBufferAllocationScheme(mut val:
                                                          xmlBufferAllocationScheme) {
}
unsafe extern "C" fn gen_xmlCatalogAllow(mut no: std::os::raw::c_int,
                                         mut nr: std::os::raw::c_int)
 -> xmlCatalogAllow {
    if no == 1 as std::os::raw::c_int { return XML_CATA_ALLOW_ALL }
    if no == 2 as std::os::raw::c_int { return XML_CATA_ALLOW_DOCUMENT }
    if no == 3 as std::os::raw::c_int { return XML_CATA_ALLOW_GLOBAL }
    if no == 4 as std::os::raw::c_int { return XML_CATA_ALLOW_NONE }
    return XML_CATA_ALLOW_NONE;
}
unsafe extern "C" fn des_xmlCatalogAllow(mut no: std::os::raw::c_int,
                                         mut val: xmlCatalogAllow,
                                         mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn desret_xmlCatalogAllow(mut val: xmlCatalogAllow) { }
unsafe extern "C" fn gen_xmlCatalogPrefer(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlCatalogPrefer {
    if no == 1 as std::os::raw::c_int { return XML_CATA_PREFER_NONE }
    if no == 2 as std::os::raw::c_int { return XML_CATA_PREFER_PUBLIC }
    if no == 3 as std::os::raw::c_int { return XML_CATA_PREFER_SYSTEM }
    return XML_CATA_PREFER_NONE;
}
unsafe extern "C" fn des_xmlCatalogPrefer(mut no: std::os::raw::c_int,
                                          mut val: xmlCatalogPrefer,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn desret_xmlCatalogPrefer(mut val: xmlCatalogPrefer) { }
unsafe extern "C" fn gen_xmlElementContentType(mut no: std::os::raw::c_int,
                                               mut nr: std::os::raw::c_int)
 -> xmlElementContentType {
    if no == 1 as std::os::raw::c_int { return XML_ELEMENT_CONTENT_ELEMENT }
    if no == 2 as std::os::raw::c_int { return XML_ELEMENT_CONTENT_OR }
    if no == 3 as std::os::raw::c_int { return XML_ELEMENT_CONTENT_PCDATA }
    if no == 4 as std::os::raw::c_int { return XML_ELEMENT_CONTENT_SEQ }
    return 0 as xmlElementContentType;
}
unsafe extern "C" fn des_xmlElementContentType(mut no: std::os::raw::c_int,
                                               mut val: xmlElementContentType,
                                               mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlElementTypeVal(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> xmlElementTypeVal {
    if no == 1 as std::os::raw::c_int { return XML_ELEMENT_TYPE_ANY }
    if no == 2 as std::os::raw::c_int { return XML_ELEMENT_TYPE_ELEMENT }
    if no == 3 as std::os::raw::c_int { return XML_ELEMENT_TYPE_EMPTY }
    if no == 4 as std::os::raw::c_int { return XML_ELEMENT_TYPE_MIXED }
    return XML_ELEMENT_TYPE_UNDEFINED;
}
unsafe extern "C" fn des_xmlElementTypeVal(mut no: std::os::raw::c_int,
                                           mut val: xmlElementTypeVal,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlFeature(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlFeature {
    if no == 1 as std::os::raw::c_int { return XML_WITH_AUTOMATA }
    if no == 2 as std::os::raw::c_int { return XML_WITH_C14N }
    if no == 3 as std::os::raw::c_int { return XML_WITH_CATALOG }
    if no == 4 as std::os::raw::c_int { return XML_WITH_DEBUG }
    return 0 as xmlFeature;
}
unsafe extern "C" fn des_xmlFeature(mut no: std::os::raw::c_int, mut val: xmlFeature,
                                    mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn desret_xmlParserErrors(mut val: xmlParserErrors) { }
unsafe extern "C" fn gen_xmlSchemaValType(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlSchemaValType {
    if no == 1 as std::os::raw::c_int { return XML_SCHEMAS_ANYSIMPLETYPE }
    if no == 2 as std::os::raw::c_int { return XML_SCHEMAS_ANYTYPE }
    if no == 3 as std::os::raw::c_int { return XML_SCHEMAS_ANYURI }
    if no == 4 as std::os::raw::c_int { return XML_SCHEMAS_BASE64BINARY }
    return XML_SCHEMAS_UNKNOWN;
}
unsafe extern "C" fn des_xmlSchemaValType(mut no: std::os::raw::c_int,
                                          mut val: xmlSchemaValType,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn desret_xmlSchemaValType(mut val: xmlSchemaValType) { }
unsafe extern "C" fn gen_xmlSchemaWhitespaceValueType(mut no: std::os::raw::c_int,
                                                      mut nr: std::os::raw::c_int)
 -> xmlSchemaWhitespaceValueType {
    if no == 1 as std::os::raw::c_int { return XML_SCHEMA_WHITESPACE_COLLAPSE }
    if no == 2 as std::os::raw::c_int { return XML_SCHEMA_WHITESPACE_PRESERVE }
    if no == 3 as std::os::raw::c_int { return XML_SCHEMA_WHITESPACE_REPLACE }
    if no == 4 as std::os::raw::c_int { return XML_SCHEMA_WHITESPACE_UNKNOWN }
    return XML_SCHEMA_WHITESPACE_UNKNOWN;
}
unsafe extern "C" fn des_xmlSchemaWhitespaceValueType(mut no: std::os::raw::c_int,
                                                      mut val:
                                                          xmlSchemaWhitespaceValueType,
                                                      mut nr: std::os::raw::c_int) {
}
/*
 * testapi.c: libxml2 API tester program.
 *
 * Automatically generated by gentest.py from libxml2-api.xml
 *
 * See Copyright for the status of this software.
 *
 * daniel@veillard.com
 */
/* for putenv() */
/* *
 * testlibxml2:
 *
 * Main entry point of the tester for the full libxml2 module,
 * it calls all the tester entry point for each module.
 *
 * Returns the number of error found
 */
unsafe extern "C" fn testlibxml2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* a pointer to an array of bytes to store the result */
    test_ret += test_HTMLparser(); /* the length of @out */
    test_ret += test_HTMLtree(); /* a pointer to an array of UTF-8 chars */
    test_ret += test_SAX2(); /* the length of @in */
    test_ret += test_c14n(); /* HTML element */
    test_ret += test_catalog(); /* HTML attribute */
    test_ret += test_chvalid(); /* whether to allow deprecated attributes */
    test_ret += test_debugXML(); /* the HTML document */
    test_ret += test_dict(); /* The tag name */
    test_ret += test_encoding(); /* the HTML element */
    test_ret += test_entities(); /* a pointer to a char array */
    test_ret += test_hash(); /* the size of the array */
    test_ret += test_list(); /* a SAX handler */
    test_ret += test_nanoftp(); /* The user data returned on SAX callbacks */
    test_ret += test_nanohttp(); /* a pointer to an array of chars */
    test_ret += test_parser(); /* number of chars in the array */
    test_ret += test_parserInternals(); /* an optional file name or URI */
    test_ret += test_pattern(); /* an optional encoding */
    test_ret += test_relaxng(); /* an HTML parser context */
    test_ret +=
        test_schemasInternals(); /* a pointer to a zero terminated string */
    test_ret += test_schematron(); /* the base URL to use for the document */
    test_ret += test_tree(); /* the document encoding, or NULL */
    test_ret += test_uri(); /* a combination of htmlParserOption(s) */
    test_ret += test_valid(); /* an HTML parser context */
    test_ret += test_xinclude(); /* a file or URL */
    test_ret += test_xmlIO(); /* the document encoding, or NULL */
    test_ret += test_xmlautomata(); /* a combination of htmlParserOption(s) */
    test_ret += test_xmlerror(); /* an HTML parser context */
    test_ret += test_xmlmodule(); /* a pointer to a char array */
    test_ret += test_xmlreader(); /* the size of the array */
    test_ret += test_xmlregexp(); /* the base URL to use for the document */
    test_ret += test_xmlsave(); /* the document encoding, or NULL */
    test_ret += test_xmlschemas(); /* a combination of htmlParserOption(s) */
    test_ret += test_xmlschemastypes(); /* an HTML parser context */
    test_ret += test_xmlstring(); /* an HTML parser context */
    test_ret += test_xmlunicode(); /* a combination of htmlParserOption(s) */
    test_ret += test_xmlwriter(); /* HTML parent element */
    test_ret += test_xpath(); /* HTML element */
    test_ret += test_xpathInternals(); /* HTML parent element */
    test_ret += test_xpointer(); /* HTML element */
    printf(b"Total: %d functions, %d tests, %d errors\n\x00" as *const u8 as
               *const std::os::raw::c_char, function_tests, call_tests,
           test_ret); /* a pointer to an array of bytes to store the result */
    return test_ret; /* the length of @out */
}
unsafe extern "C" fn test_UTF8ToHtml() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* a pointer to an array of UTF-8 chars */
    let mut mem_base: std::os::raw::c_int = 0; /* the length of @in */
    let mut ret_val: std::os::raw::c_int =
        0; /* the quote character to escape (' or ") or zero. */
    let mut out: *mut std::os::raw::c_uchar =
        0 as *mut std::os::raw::c_uchar; /* the entity name */
    let mut n_out: std::os::raw::c_int = 0; /* the entity's unicode value */
    let mut outlen: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int; /* int 0 or 1 */
    let mut n_outlen: std::os::raw::c_int = 0; /* the HTML document */
    let mut in_0: *mut std::os::raw::c_uchar =
        0 as *mut std::os::raw::c_uchar; /* the HTML element */
    let mut n_in: std::os::raw::c_int = 0; /* an attribute name */
    let mut inlen: *mut std::os::raw::c_int =
        0 as *mut std::os::raw::c_int; /* an htmlNodePtr in a tree */
    let mut n_inlen: std::os::raw::c_int =
        0; /* whether to allow deprecated elements (YES is faster here for Element nodes) */
    n_out = 0 as std::os::raw::c_int; /* an HTML parser context */
    while n_out < 1 as std::os::raw::c_int {
        n_outlen = 0 as std::os::raw::c_int; /* an HTML parser context */
        while n_outlen < 2 as std::os::raw::c_int {
            n_in = 0 as std::os::raw::c_int; /* an char array */
            while n_in < 1 as std::os::raw::c_int {
                n_inlen =
                    0 as std::os::raw::c_int; /* the size in byte of the chunk */
                while n_inlen < 2 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks(); /* last chunk indicator */
                    out =
                        gen_unsigned_char_ptr(n_out,
                                              0 as
                                                  std::os::raw::c_int); /* a pointer to an array of xmlChar */
                    outlen =
                        gen_int_ptr(n_outlen,
                                    1 as
                                        std::os::raw::c_int); /* a free form C string describing the HTML document encoding, or NULL */
                    in_0 =
                        gen_const_unsigned_char_ptr(n_in,
                                                    2 as
                                                        std::os::raw::c_int); /* an HTML parser context */
                    inlen =
                        gen_int_ptr(n_inlen,
                                    3 as
                                        std::os::raw::c_int); /* an HTML parser context */
                    ret_val =
                        UTF8ToHtml(out, outlen, in_0 as *const std::os::raw::c_uchar,
                                   inlen); /* an HTML parser context */
                    desret_int(ret_val); /* location to store the entity name */
                    call_tests += 1; /* the filename */
                    des_unsigned_char_ptr(n_out, out,
                                          0 as
                                              std::os::raw::c_int); /* a free form C string describing the HTML document encoding, or NULL */
                    des_int_ptr(n_outlen, outlen,
                                1 as
                                    std::os::raw::c_int); /* a pointer to a zero terminated string */
                    des_const_unsigned_char_ptr(n_in,
                                                in_0 as *const std::os::raw::c_uchar,
                                                2 as
                                                    std::os::raw::c_int); /* the base URL to use for the document */
                    des_int_ptr(n_inlen, inlen,
                                3 as
                                    std::os::raw::c_int); /* the document encoding, or NULL */
                    xmlResetLastError(); /* a combination of htmlParserOption(s) */
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in UTF8ToHtml\x00" as
                                   *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base); /* a file or URL */
                        test_ret += 1; /* the document encoding, or NULL */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_out); /* a combination of htmlParserOption(s) */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_outlen); /* a pointer to a char array */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_in); /* the size of the array */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_inlen); /* the base URL to use for the document */
                        printf(b"\n\x00" as *const u8 as
                                   *const std::os::raw::c_char); /* the document encoding, or NULL */
                    } /* a combination of htmlParserOption(s) */
                    n_inlen += 1
                } /* a pointer to an array of xmlChar */
                n_in += 1
            } /* a free form C string describing the HTML document encoding, or NULL */
            n_outlen += 1
        } /* the SAX handler block */
        n_out += 1
    } /* if using SAX, this pointer will be provided on callbacks. */
    function_tests += 1; /* the filename */
    return test_ret; /* a free form C string describing the HTML document encoding, or NULL */
}
unsafe extern "C" fn gen_const_htmlElemDesc_ptr(mut no: std::os::raw::c_int,
                                                mut nr: std::os::raw::c_int)
 -> *mut htmlElemDesc {
    return 0 as *mut htmlElemDesc; /* the SAX handler block */
}
unsafe extern "C" fn des_const_htmlElemDesc_ptr(mut no: std::os::raw::c_int,
                                                mut val: *const htmlElemDesc,
                                                mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_htmlAttrAllowed() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* if using SAX, this pointer will be provided on callbacks. */
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlStatus = HTML_NA;
    let mut elt: *mut htmlElemDesc = 0 as *mut htmlElemDesc;
    let mut n_elt: std::os::raw::c_int = 0;
    let mut attr: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_attr: std::os::raw::c_int = 0;
    let mut legacy: std::os::raw::c_int = 0;
    let mut n_legacy: std::os::raw::c_int = 0;
    n_elt = 0 as std::os::raw::c_int;
    while n_elt < 1 as std::os::raw::c_int {
        n_attr = 0 as std::os::raw::c_int;
        while n_attr < 5 as std::os::raw::c_int {
            n_legacy = 0 as std::os::raw::c_int;
            while n_legacy < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                elt = gen_const_htmlElemDesc_ptr(n_elt, 0 as std::os::raw::c_int);
                attr = gen_const_xmlChar_ptr(n_attr, 1 as std::os::raw::c_int);
                legacy = gen_int(n_legacy, 2 as std::os::raw::c_int);
                ret_val =
                    htmlAttrAllowed(elt as *const htmlElemDesc,
                                    attr as *const xmlChar, legacy);
                desret_htmlStatus(ret_val);
                call_tests += 1;
                des_const_htmlElemDesc_ptr(n_elt, elt as *const htmlElemDesc,
                                           0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_attr, attr as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_int(n_legacy, legacy, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in htmlAttrAllowed\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_attr);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_legacy);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_legacy += 1
            }
            n_attr += 1
        }
        n_elt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_htmlNodePtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> htmlNodePtr {
    return 0 as htmlNodePtr;
}
unsafe extern "C" fn des_htmlNodePtr(mut no: std::os::raw::c_int,
                                     mut val: htmlNodePtr,
                                     mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_htmlAutoCloseTag() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut elem: htmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_htmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                elem = gen_htmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                ret_val = htmlAutoCloseTag(doc, name as *const xmlChar, elem);
                desret_int(ret_val);
                call_tests += 1;
                des_htmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_htmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in htmlAutoCloseTag\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_elem += 1
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlCreateMemoryParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buffer = gen_const_char_ptr(n_buffer, 0 as std::os::raw::c_int);
            size = gen_int(n_size, 1 as std::os::raw::c_int);
            if !(!buffer.is_null() &&
                     size >
                         strlen(buffer as *const std::os::raw::c_char) as std::os::raw::c_int
                             + 1 as std::os::raw::c_int) {
                ret_val =
                    htmlCreateMemoryParserCtxt(buffer as *const std::os::raw::c_char,
                                               size);
                desret_htmlParserCtxtPtr(ret_val);
                call_tests += 1;
                des_const_char_ptr(n_buffer, buffer as *const std::os::raw::c_char,
                                   0 as std::os::raw::c_int);
                des_int(n_size, size, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in htmlCreateMemoryParserCtxt\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_size);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_size += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_htmlSAXHandlerPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> htmlSAXHandlerPtr {
    return 0 as htmlSAXHandlerPtr;
}
unsafe extern "C" fn des_htmlSAXHandlerPtr(mut no: std::os::raw::c_int,
                                           mut val: htmlSAXHandlerPtr,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_htmlCreatePushParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut sax: htmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut user_data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_user_data: std::os::raw::c_int = 0;
    let mut chunk: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_chunk: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut n_enc: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 1 as std::os::raw::c_int {
        n_user_data = 0 as std::os::raw::c_int;
        while n_user_data < 3 as std::os::raw::c_int {
            n_chunk = 0 as std::os::raw::c_int;
            while n_chunk < 4 as std::os::raw::c_int {
                n_size = 0 as std::os::raw::c_int;
                while n_size < 4 as std::os::raw::c_int {
                    n_filename = 0 as std::os::raw::c_int;
                    while n_filename < 6 as std::os::raw::c_int {
                        n_enc = 0 as std::os::raw::c_int;
                        while n_enc < 4 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            sax =
                                gen_htmlSAXHandlerPtr(n_sax,
                                                      0 as std::os::raw::c_int);
                            user_data =
                                gen_userdata(n_user_data, 1 as std::os::raw::c_int);
                            chunk =
                                gen_const_char_ptr(n_chunk, 2 as std::os::raw::c_int);
                            size = gen_int(n_size, 3 as std::os::raw::c_int);
                            filename =
                                gen_fileoutput(n_filename, 4 as std::os::raw::c_int);
                            enc =
                                gen_xmlCharEncoding(n_enc, 5 as std::os::raw::c_int);
                            if !(!chunk.is_null() &&
                                     size >
                                         strlen(chunk as *const std::os::raw::c_char)
                                             as std::os::raw::c_int +
                                             1 as std::os::raw::c_int) {
                                ret_val =
                                    htmlCreatePushParserCtxt(sax, user_data,
                                                             chunk as
                                                                 *const std::os::raw::c_char,
                                                             size, filename,
                                                             enc);
                                desret_htmlParserCtxtPtr(ret_val);
                                call_tests += 1;
                                des_htmlSAXHandlerPtr(n_sax, sax,
                                                      0 as std::os::raw::c_int);
                                des_userdata(n_user_data, user_data,
                                             1 as std::os::raw::c_int);
                                des_const_char_ptr(n_chunk,
                                                   chunk as
                                                       *const std::os::raw::c_char,
                                                   2 as std::os::raw::c_int);
                                des_int(n_size, size, 3 as std::os::raw::c_int);
                                des_fileoutput(n_filename, filename,
                                               4 as std::os::raw::c_int);
                                des_xmlCharEncoding(n_enc, enc,
                                                    5 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in htmlCreatePushParserCtxt\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_sax);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_user_data);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_chunk);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_size);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_filename);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_enc);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                            }
                            n_enc += 1
                        }
                        n_filename += 1
                    }
                    n_size += 1
                }
                n_chunk += 1
            }
            n_user_data += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlCtxtReadDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 5 as std::os::raw::c_int {
            n_URL = 0 as std::os::raw::c_int;
            while n_URL < 8 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    n_options = 0 as std::os::raw::c_int;
                    while n_options < 4 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        ctxt =
                            gen_htmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                        cur = gen_const_xmlChar_ptr(n_cur, 1 as std::os::raw::c_int);
                        URL = gen_filepath(n_URL, 2 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                        options = gen_int(n_options, 4 as std::os::raw::c_int);
                        ret_val =
                            htmlCtxtReadDoc(ctxt, cur as *const xmlChar, URL,
                                            encoding as *const std::os::raw::c_char,
                                            options);
                        desret_htmlDocPtr(ret_val);
                        call_tests += 1;
                        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_filepath(n_URL, URL, 2 as std::os::raw::c_int);
                        des_const_char_ptr(n_encoding,
                                           encoding as *const std::os::raw::c_char,
                                           3 as std::os::raw::c_int);
                        des_int(n_options, options, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in htmlCtxtReadDoc\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ctxt);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_cur);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_URL);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_encoding);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_options);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_options += 1
                    }
                    n_encoding += 1
                }
                n_URL += 1
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlCtxtReadFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 8 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                n_options = 0 as std::os::raw::c_int;
                while n_options < 4 as std::os::raw::c_int {
                    ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    filename = gen_filepath(n_filename, 1 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                    options = gen_int(n_options, 3 as std::os::raw::c_int);
                    ret_val =
                        htmlCtxtReadFile(ctxt, filename,
                                         encoding as *const std::os::raw::c_char,
                                         options);
                    desret_htmlDocPtr(ret_val);
                    call_tests += 1;
                    des_htmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_filepath(n_filename, filename, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_int(n_options, options, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    n_options += 1
                }
                n_encoding += 1
            }
            n_filename += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlCtxtReadMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 4 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 4 as std::os::raw::c_int {
                n_URL = 0 as std::os::raw::c_int;
                while n_URL < 8 as std::os::raw::c_int {
                    n_encoding = 0 as std::os::raw::c_int;
                    while n_encoding < 4 as std::os::raw::c_int {
                        n_options = 0 as std::os::raw::c_int;
                        while n_options < 4 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            ctxt =
                                gen_htmlParserCtxtPtr(n_ctxt,
                                                      0 as std::os::raw::c_int);
                            buffer =
                                gen_const_char_ptr(n_buffer,
                                                   1 as std::os::raw::c_int);
                            size = gen_int(n_size, 2 as std::os::raw::c_int);
                            URL = gen_filepath(n_URL, 3 as std::os::raw::c_int);
                            encoding =
                                gen_const_char_ptr(n_encoding,
                                                   4 as std::os::raw::c_int);
                            options = gen_int(n_options, 5 as std::os::raw::c_int);
                            if !(!buffer.is_null() &&
                                     size >
                                         strlen(buffer as *const std::os::raw::c_char)
                                             as std::os::raw::c_int +
                                             1 as std::os::raw::c_int) {
                                ret_val =
                                    htmlCtxtReadMemory(ctxt,
                                                       buffer as
                                                           *const std::os::raw::c_char,
                                                       size, URL,
                                                       encoding as
                                                           *const std::os::raw::c_char,
                                                       options);
                                desret_htmlDocPtr(ret_val);
                                call_tests += 1;
                                des_htmlParserCtxtPtr(n_ctxt, ctxt,
                                                      0 as std::os::raw::c_int);
                                des_const_char_ptr(n_buffer,
                                                   buffer as
                                                       *const std::os::raw::c_char,
                                                   1 as std::os::raw::c_int);
                                des_int(n_size, size, 2 as std::os::raw::c_int);
                                des_filepath(n_URL, URL, 3 as std::os::raw::c_int);
                                des_const_char_ptr(n_encoding,
                                                   encoding as
                                                       *const std::os::raw::c_char,
                                                   4 as std::os::raw::c_int);
                                des_int(n_options, options, 5 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in htmlCtxtReadMemory\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_ctxt);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_buffer);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_size);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_URL);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_encoding);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_options);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                            }
                            n_options += 1
                        }
                        n_encoding += 1
                    }
                    n_URL += 1
                }
                n_size += 1
            }
            n_buffer += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlCtxtReset() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        htmlCtxtReset(ctxt);
        call_tests += 1;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlCtxtReset\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlCtxtUseOptions() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_options = 0 as std::os::raw::c_int;
        while n_options < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            options = gen_int(n_options, 1 as std::os::raw::c_int);
            ret_val = htmlCtxtUseOptions(ctxt, options);
            desret_int(ret_val);
            call_tests += 1;
            des_htmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_options, options, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlCtxtUseOptions\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_options);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_options += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlElementAllowedHere() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut parent: *mut htmlElemDesc = 0 as *mut htmlElemDesc;
    let mut n_parent: std::os::raw::c_int = 0;
    let mut elt: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_elt: std::os::raw::c_int = 0;
    n_parent = 0 as std::os::raw::c_int;
    while n_parent < 1 as std::os::raw::c_int {
        n_elt = 0 as std::os::raw::c_int;
        while n_elt < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            parent = gen_const_htmlElemDesc_ptr(n_parent, 0 as std::os::raw::c_int);
            elt = gen_const_xmlChar_ptr(n_elt, 1 as std::os::raw::c_int);
            ret_val =
                htmlElementAllowedHere(parent as *const htmlElemDesc,
                                       elt as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_const_htmlElemDesc_ptr(n_parent,
                                       parent as *const htmlElemDesc,
                                       0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_elt, elt as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlElementAllowedHere\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_parent);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_elt);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_elt += 1
        }
        n_parent += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlElementStatusHere() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlStatus = HTML_NA;
    let mut parent: *mut htmlElemDesc = 0 as *mut htmlElemDesc;
    let mut n_parent: std::os::raw::c_int = 0;
    let mut elt: *mut htmlElemDesc = 0 as *mut htmlElemDesc;
    let mut n_elt: std::os::raw::c_int = 0;
    n_parent = 0 as std::os::raw::c_int;
    while n_parent < 1 as std::os::raw::c_int {
        n_elt = 0 as std::os::raw::c_int;
        while n_elt < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            parent = gen_const_htmlElemDesc_ptr(n_parent, 0 as std::os::raw::c_int);
            elt = gen_const_htmlElemDesc_ptr(n_elt, 1 as std::os::raw::c_int);
            ret_val =
                htmlElementStatusHere(parent as *const htmlElemDesc,
                                      elt as *const htmlElemDesc);
            desret_htmlStatus(ret_val);
            call_tests += 1;
            des_const_htmlElemDesc_ptr(n_parent,
                                       parent as *const htmlElemDesc,
                                       0 as std::os::raw::c_int);
            des_const_htmlElemDesc_ptr(n_elt, elt as *const htmlElemDesc,
                                       1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlElementStatusHere\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_parent);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_elt);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_elt += 1
        }
        n_parent += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlEncodeEntities() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut out: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    let mut n_out: std::os::raw::c_int = 0;
    let mut outlen: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_outlen: std::os::raw::c_int = 0;
    let mut in_0: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    let mut n_in: std::os::raw::c_int = 0;
    let mut inlen: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_inlen: std::os::raw::c_int = 0;
    let mut quoteChar: std::os::raw::c_int = 0;
    let mut n_quoteChar: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 1 as std::os::raw::c_int {
        n_outlen = 0 as std::os::raw::c_int;
        while n_outlen < 2 as std::os::raw::c_int {
            n_in = 0 as std::os::raw::c_int;
            while n_in < 1 as std::os::raw::c_int {
                n_inlen = 0 as std::os::raw::c_int;
                while n_inlen < 2 as std::os::raw::c_int {
                    n_quoteChar = 0 as std::os::raw::c_int;
                    while n_quoteChar < 4 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        out = gen_unsigned_char_ptr(n_out, 0 as std::os::raw::c_int);
                        outlen = gen_int_ptr(n_outlen, 1 as std::os::raw::c_int);
                        in_0 =
                            gen_const_unsigned_char_ptr(n_in,
                                                        2 as std::os::raw::c_int);
                        inlen = gen_int_ptr(n_inlen, 3 as std::os::raw::c_int);
                        quoteChar = gen_int(n_quoteChar, 4 as std::os::raw::c_int);
                        ret_val =
                            htmlEncodeEntities(out, outlen,
                                               in_0 as *const std::os::raw::c_uchar,
                                               inlen, quoteChar);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_unsigned_char_ptr(n_out, out, 0 as std::os::raw::c_int);
                        des_int_ptr(n_outlen, outlen, 1 as std::os::raw::c_int);
                        des_const_unsigned_char_ptr(n_in,
                                                    in_0 as
                                                        *const std::os::raw::c_uchar,
                                                    2 as std::os::raw::c_int);
                        des_int_ptr(n_inlen, inlen, 3 as std::os::raw::c_int);
                        des_int(n_quoteChar, quoteChar, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in htmlEncodeEntities\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_out);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_outlen);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_in);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_inlen);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_quoteChar);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_quoteChar += 1
                    }
                    n_inlen += 1
                }
                n_in += 1
            }
            n_outlen += 1
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlEntityLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const htmlEntityDesc = 0 as *const htmlEntityDesc;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
        ret_val = htmlEntityLookup(name as *const xmlChar);
        desret_const_htmlEntityDesc_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlEntityLookup\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_name);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlEntityValueLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const htmlEntityDesc = 0 as *const htmlEntityDesc;
    let mut value: std::os::raw::c_uint = 0;
    let mut n_value: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        value = gen_unsigned_int(n_value, 0 as std::os::raw::c_int);
        ret_val = htmlEntityValueLookup(value);
        desret_const_htmlEntityDesc_ptr(ret_val);
        call_tests += 1;
        des_unsigned_int(n_value, value, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlEntityValueLookup\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_value);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlHandleOmittedElem() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0 as std::os::raw::c_int);
        ret_val = htmlHandleOmittedElem(val);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlHandleOmittedElem\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlIsAutoClosed() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: htmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 3 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_htmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            elem = gen_htmlNodePtr(n_elem, 1 as std::os::raw::c_int);
            ret_val = htmlIsAutoClosed(doc, elem);
            desret_int(ret_val);
            call_tests += 1;
            des_htmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_htmlNodePtr(n_elem, elem, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlIsAutoClosed\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_elem);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_elem += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlIsScriptAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
        ret_val = htmlIsScriptAttribute(name as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlIsScriptAttribute\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_name);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlNewParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    mem_base = xmlMemBlocks();
    ret_val = htmlNewParserCtxt();
    desret_htmlParserCtxtPtr(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in htmlNewParserCtxt\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlNodeStatus() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlStatus = HTML_NA;
    let mut node: htmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut legacy: std::os::raw::c_int = 0;
    let mut n_legacy: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 1 as std::os::raw::c_int {
        n_legacy = 0 as std::os::raw::c_int;
        while n_legacy < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            node = gen_const_htmlNodePtr(n_node, 0 as std::os::raw::c_int);
            legacy = gen_int(n_legacy, 1 as std::os::raw::c_int);
            ret_val = htmlNodeStatus(node, legacy);
            desret_htmlStatus(ret_val);
            call_tests += 1;
            des_const_htmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
            des_int(n_legacy, legacy, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlNodeStatus\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_legacy);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_legacy += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlParseCharRef() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = htmlParseCharRef(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlParseCharRef\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlParseChunk() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut chunk: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_chunk: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut terminate: std::os::raw::c_int = 0;
    let mut n_terminate: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_chunk = 0 as std::os::raw::c_int;
        while n_chunk < 4 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 4 as std::os::raw::c_int {
                n_terminate = 0 as std::os::raw::c_int;
                while n_terminate < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    chunk = gen_const_char_ptr(n_chunk, 1 as std::os::raw::c_int);
                    size = gen_int(n_size, 2 as std::os::raw::c_int);
                    terminate = gen_int(n_terminate, 3 as std::os::raw::c_int);
                    if !(!chunk.is_null() &&
                             size >
                                 strlen(chunk as *const std::os::raw::c_char) as
                                     std::os::raw::c_int + 1 as std::os::raw::c_int) {
                        ret_val =
                            htmlParseChunk(ctxt, chunk as *const std::os::raw::c_char,
                                           size, terminate);
                        if !ctxt.is_null() {
                            xmlFreeDoc((*ctxt).myDoc);
                            (*ctxt).myDoc = 0 as xmlDocPtr
                        }
                        desret_int(ret_val);
                        call_tests += 1;
                        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                        des_const_char_ptr(n_chunk,
                                           chunk as *const std::os::raw::c_char,
                                           1 as std::os::raw::c_int);
                        des_int(n_size, size, 2 as std::os::raw::c_int);
                        des_int(n_terminate, terminate, 3 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in htmlParseChunk\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ctxt);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_chunk);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_size);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_terminate);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                    }
                    n_terminate += 1
                }
                n_size += 1
            }
            n_chunk += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlParseDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 5 as std::os::raw::c_int {
        n_encoding = 0 as std::os::raw::c_int;
        while n_encoding < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_const_xmlChar_ptr(n_cur, 0 as std::os::raw::c_int);
            encoding = gen_const_char_ptr(n_encoding, 1 as std::os::raw::c_int);
            ret_val =
                htmlParseDoc(cur as *const xmlChar,
                             encoding as *const std::os::raw::c_char);
            desret_htmlDocPtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_char_ptr(n_encoding, encoding as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlParseDoc\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_encoding);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_encoding += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlParseDocument() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = htmlParseDocument(ctxt);
        if !ctxt.is_null() {
            xmlFreeDoc((*ctxt).myDoc);
            (*ctxt).myDoc = 0 as xmlDocPtr
        }
        desret_int(ret_val);
        call_tests += 1;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlParseDocument\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlParseElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        htmlParseElement(ctxt);
        call_tests += 1;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlParseElement\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlParseEntityRef() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const htmlEntityDesc = 0 as *const htmlEntityDesc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut str: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            str = gen_const_xmlChar_ptr_ptr(n_str, 1 as std::os::raw::c_int);
            ret_val = htmlParseEntityRef(ctxt, str as *mut *const xmlChar);
            desret_const_htmlEntityDesc_ptr(ret_val);
            call_tests += 1;
            des_htmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr_ptr(n_str, str as *mut *const xmlChar,
                                      1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlParseEntityRef\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlParseFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        n_encoding = 0 as std::os::raw::c_int;
        while n_encoding < 4 as std::os::raw::c_int {
            filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
            encoding = gen_const_char_ptr(n_encoding, 1 as std::os::raw::c_int);
            ret_val =
                htmlParseFile(filename, encoding as *const std::os::raw::c_char);
            desret_htmlDocPtr(ret_val);
            call_tests += 1;
            des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_encoding, encoding as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            n_encoding += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlReadDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 5 as std::os::raw::c_int {
        n_URL = 0 as std::os::raw::c_int;
        while n_URL < 8 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                n_options = 0 as std::os::raw::c_int;
                while n_options < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    cur = gen_const_xmlChar_ptr(n_cur, 0 as std::os::raw::c_int);
                    URL = gen_filepath(n_URL, 1 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                    options = gen_int(n_options, 3 as std::os::raw::c_int);
                    ret_val =
                        htmlReadDoc(cur as *const xmlChar, URL,
                                    encoding as *const std::os::raw::c_char, options);
                    desret_htmlDocPtr(ret_val);
                    call_tests += 1;
                    des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                          0 as std::os::raw::c_int);
                    des_filepath(n_URL, URL, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_int(n_options, options, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in htmlReadDoc\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_URL);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_options);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_options += 1
                }
                n_encoding += 1
            }
            n_URL += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlReadFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        n_encoding = 0 as std::os::raw::c_int;
        while n_encoding < 4 as std::os::raw::c_int {
            n_options = 0 as std::os::raw::c_int;
            while n_options < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
                encoding = gen_const_char_ptr(n_encoding, 1 as std::os::raw::c_int);
                options = gen_int(n_options, 2 as std::os::raw::c_int);
                ret_val =
                    htmlReadFile(filename, encoding as *const std::os::raw::c_char,
                                 options);
                desret_htmlDocPtr(ret_val);
                call_tests += 1;
                des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
                des_const_char_ptr(n_encoding,
                                   encoding as *const std::os::raw::c_char,
                                   1 as std::os::raw::c_int);
                des_int(n_options, options, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in htmlReadFile\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_encoding);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_options);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_options += 1
            }
            n_encoding += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlReadMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            n_URL = 0 as std::os::raw::c_int;
            while n_URL < 8 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    n_options = 0 as std::os::raw::c_int;
                    while n_options < 4 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        buffer =
                            gen_const_char_ptr(n_buffer, 0 as std::os::raw::c_int);
                        size = gen_int(n_size, 1 as std::os::raw::c_int);
                        URL = gen_filepath(n_URL, 2 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                        options = gen_int(n_options, 4 as std::os::raw::c_int);
                        if !(!buffer.is_null() &&
                                 size >
                                     strlen(buffer as *const std::os::raw::c_char) as
                                         std::os::raw::c_int + 1 as std::os::raw::c_int) {
                            ret_val =
                                htmlReadMemory(buffer as *const std::os::raw::c_char,
                                               size, URL,
                                               encoding as
                                                   *const std::os::raw::c_char,
                                               options);
                            desret_htmlDocPtr(ret_val);
                            call_tests += 1;
                            des_const_char_ptr(n_buffer,
                                               buffer as *const std::os::raw::c_char,
                                               0 as std::os::raw::c_int);
                            des_int(n_size, size, 1 as std::os::raw::c_int);
                            des_filepath(n_URL, URL, 2 as std::os::raw::c_int);
                            des_const_char_ptr(n_encoding,
                                               encoding as
                                                   *const std::os::raw::c_char,
                                               3 as std::os::raw::c_int);
                            des_int(n_options, options, 4 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in htmlReadMemory\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_buffer);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_size);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_URL);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_encoding);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_options);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                        }
                        n_options += 1
                    }
                    n_encoding += 1
                }
                n_URL += 1
            }
            n_size += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlSAXParseDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut sax: htmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut userData: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_userData: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 5 as std::os::raw::c_int {
        n_encoding = 0 as std::os::raw::c_int;
        while n_encoding < 4 as std::os::raw::c_int {
            n_sax = 0 as std::os::raw::c_int;
            while n_sax < 1 as std::os::raw::c_int {
                n_userData = 0 as std::os::raw::c_int;
                while n_userData < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    cur = gen_const_xmlChar_ptr(n_cur, 0 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 1 as std::os::raw::c_int);
                    sax = gen_htmlSAXHandlerPtr(n_sax, 2 as std::os::raw::c_int);
                    userData = gen_userdata(n_userData, 3 as std::os::raw::c_int);
                    ret_val =
                        htmlSAXParseDoc(cur as *const xmlChar,
                                        encoding as *const std::os::raw::c_char, sax,
                                        userData);
                    desret_htmlDocPtr(ret_val);
                    call_tests += 1;
                    des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                          0 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       1 as std::os::raw::c_int);
                    des_htmlSAXHandlerPtr(n_sax, sax, 2 as std::os::raw::c_int);
                    des_userdata(n_userData, userData, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in htmlSAXParseDoc\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_sax);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_userData);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_userData += 1
                }
                n_sax += 1
            }
            n_encoding += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlSAXParseFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut sax: htmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut userData: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_userData: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        n_encoding = 0 as std::os::raw::c_int;
        while n_encoding < 4 as std::os::raw::c_int {
            n_sax = 0 as std::os::raw::c_int;
            while n_sax < 1 as std::os::raw::c_int {
                n_userData = 0 as std::os::raw::c_int;
                while n_userData < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 1 as std::os::raw::c_int);
                    sax = gen_htmlSAXHandlerPtr(n_sax, 2 as std::os::raw::c_int);
                    userData = gen_userdata(n_userData, 3 as std::os::raw::c_int);
                    ret_val =
                        htmlSAXParseFile(filename,
                                         encoding as *const std::os::raw::c_char, sax,
                                         userData);
                    desret_htmlDocPtr(ret_val);
                    call_tests += 1;
                    des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       1 as std::os::raw::c_int);
                    des_htmlSAXHandlerPtr(n_sax, sax, 2 as std::os::raw::c_int);
                    des_userdata(n_userData, userData, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in htmlSAXParseFile\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_filename);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_sax);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_userData);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_userData += 1
                }
                n_sax += 1
            }
            n_encoding += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlTagLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the HTML buffer output */
}
unsafe extern "C" fn test_HTMLparser() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the document */
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing HTMLparser : 32 of 38 functions ...\n\x00" as
                   *const u8 as
                   *const std::os::raw::c_char); /* the encoding string */
    } /* should formatting spaces been added */
    test_ret += test_UTF8ToHtml(); /* the HTML buffer output */
    test_ret += test_htmlAttrAllowed(); /* the document */
    test_ret += test_htmlAutoCloseTag(); /* the encoding string */
    test_ret += test_htmlCreateMemoryParserCtxt(); /* the FILE* */
    test_ret += test_htmlCreatePushParserCtxt(); /* the document */
    test_ret += test_htmlCtxtReadDoc(); /* the document */
    test_ret += test_htmlCtxtReadFile(); /* OUT: the memory pointer */
    test_ret += test_htmlCtxtReadMemory(); /* OUT: the memory length */
    test_ret += test_htmlCtxtReset(); /* the document */
    test_ret += test_htmlCtxtUseOptions(); /* OUT: the memory pointer */
    test_ret += test_htmlElementAllowedHere(); /* OUT: the memory length */
    test_ret +=
        test_htmlElementStatusHere(); /* should formatting spaces been added */
    test_ret += test_htmlEncodeEntities(); /* the document */
    test_ret +=
        test_htmlEntityLookup(); /* the name of the attribute to check */
    test_ret += test_htmlEntityValueLookup(); /* URI for the dtd, or NULL */
    test_ret +=
        test_htmlHandleOmittedElem(); /* the external ID of the DTD, or NULL */
    test_ret += test_htmlIsAutoClosed(); /* URI for the dtd, or NULL */
    test_ret +=
        test_htmlIsScriptAttribute(); /* the external ID of the DTD, or NULL */
    test_ret += test_htmlNewParserCtxt(); /* the HTML buffer output */
    test_ret += test_htmlNodeStatus(); /* the document */
    test_ret += test_htmlParseCharRef(); /* the current node */
    test_ret += test_htmlParseChunk(); /* the FILE pointer */
    test_ret += test_htmlParseDoc(); /* the document */
    test_ret += test_htmlParseDocument(); /* the current node */
    test_ret += test_htmlParseElement(); /* the FILE pointer */
    test_ret += test_htmlParseEntityRef(); /* the document */
    test_ret += test_htmlParseFile(); /* the current node */
    test_ret += test_htmlReadDoc(); /* the document encoding */
    test_ret += test_htmlReadFile(); /* should formatting spaces been added */
    test_ret += test_htmlReadMemory(); /* the HTML buffer output */
    test_ret += test_htmlSAXParseDoc(); /* the document */
    test_ret += test_htmlSAXParseFile(); /* the current node */
    test_ret += test_htmlTagLookup(); /* the encoding string */
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module HTMLparser: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char,
               test_ret); /* should formatting spaces been added */
    } /* the HTML buffer output */
    return test_ret; /* the document */
}
unsafe extern "C" fn test_htmlDocContentDumpFormatOutput() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the current node */
    let mut mem_base: std::os::raw::c_int = 0; /* the encoding string */
    let mut buf: xmlOutputBufferPtr =
        0 as *mut xmlOutputBuffer; /* the filename (or URL) */
    let mut n_buf: std::os::raw::c_int = 0; /* the document */
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc; /* the filename */
    let mut n_cur: std::os::raw::c_int = 0; /* the document */
    let mut encoding: *mut std::os::raw::c_char =
        0 as *mut std::os::raw::c_char; /* the document encoding */
    let mut n_encoding: std::os::raw::c_int = 0; /* the filename */
    let mut format: std::os::raw::c_int = 0; /* the document */
    let mut n_format: std::os::raw::c_int = 0; /* the document encoding */
    n_buf = 0 as std::os::raw::c_int; /* should formatting spaces been added */
    while n_buf < 2 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int; /* the document */
        while n_cur < 4 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int; /* the encoding string */
            while n_encoding < 4 as std::os::raw::c_int {
                n_format =
                    0 as std::os::raw::c_int; /* the user data (XML parser context) */
                while n_format < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks(); /* the name of the element */
                    buf =
                        gen_xmlOutputBufferPtr(n_buf,
                                               0 as
                                                   std::os::raw::c_int); /* the attribute name */
                    cur =
                        gen_xmlDocPtr(n_cur,
                                      1 as
                                          std::os::raw::c_int); /* the attribute type */
                    encoding =
                        gen_const_char_ptr(n_encoding,
                                           2 as
                                               std::os::raw::c_int); /* the type of default value */
                    format =
                        gen_int(n_format,
                                3 as
                                    std::os::raw::c_int); /* the attribute default value */
                    htmlDocContentDumpFormatOutput(buf, cur,
                                                   encoding as
                                                       *const std::os::raw::c_char,
                                                   format); /* the tree of enumerated value set */
                    call_tests += 1; /* the user data (XML parser context) */
                    des_xmlOutputBufferPtr(n_buf, buf,
                                           0 as
                                               std::os::raw::c_int); /* The pcdata content */
                    des_xmlDocPtr(n_cur, cur,
                                  1 as std::os::raw::c_int); /* the block length */
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as
                                           std::os::raw::c_int); /* the user data (XML parser context) */
                    des_int(n_format, format,
                            3 as std::os::raw::c_int); /* a xmlChar string */
                    xmlResetLastError(); /* the number of xmlChar */
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in htmlDocContentDumpFormatOutput\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() -
                                   mem_base); /* the user data (XML parser context) */
                        test_ret += 1; /* the xmlSAX2Comment content */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buf); /* the user data (XML parser context) */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur); /* the element name */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding); /* the element type */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_format); /* the element value tree */
                        printf(b"\n\x00" as *const u8 as
                                   *const std::os::raw::c_char); /* the user data (XML parser context) */
                    } /* the user data (XML parser context) */
                    n_format += 1
                } /* The element name */
                n_encoding += 1
            } /* the user data (XML parser context) */
            n_cur += 1
        } /* the local name of the element */
        n_buf += 1
    } /* the element namespace prefix if available */
    function_tests += 1; /* the element namespace name if available */
    return test_ret; /* the user data (XML parser context) */
}
unsafe extern "C" fn test_htmlDocContentDumpOutput() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the entity name */
    let mut mem_base: std::os::raw::c_int = 0; /* the entity type */
    let mut buf: xmlOutputBufferPtr =
        0 as *mut xmlOutputBuffer; /* The public ID of the entity */
    let mut n_buf: std::os::raw::c_int = 0; /* The system ID of the entity */
    let mut cur: xmlDocPtr =
        0 as *mut xmlDoc; /* the entity value (without processing). */
    let mut n_cur: std::os::raw::c_int = 0; /* the user data (XML parser context) */
    let mut encoding: *mut std::os::raw::c_char =
        0 as *mut std::os::raw::c_char; /* the root element name */
    let mut n_encoding: std::os::raw::c_int = 0; /* the external ID */
    n_buf = 0 as std::os::raw::c_int; /* the SYSTEM ID (e.g. filename or URL) */
    while n_buf < 2 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int; /* the user data (XML parser context) */
        while n_cur < 4 as std::os::raw::c_int {
            n_encoding =
                0 as std::os::raw::c_int; /* the user data (XML parser context) */
            while n_encoding < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* The entity name */
                buf =
                    gen_xmlOutputBufferPtr(n_buf,
                                           0 as
                                               std::os::raw::c_int); /* the user data (XML parser context) */
                cur =
                    gen_xmlDocPtr(n_cur,
                                  1 as
                                      std::os::raw::c_int); /* the user data (XML parser context) */
                encoding =
                    gen_const_char_ptr(n_encoding,
                                       2 as
                                           std::os::raw::c_int); /* The entity name */
                htmlDocContentDumpOutput(buf, cur,
                                         encoding as
                                             *const std::os::raw::c_char); /* the user data (XML parser context) */
                call_tests += 1; /* the user data (XML parser context) */
                des_xmlOutputBufferPtr(n_buf, buf,
                                       0 as
                                           std::os::raw::c_int); /* the user data (XML parser context) */
                des_xmlDocPtr(n_cur, cur,
                              1 as
                                  std::os::raw::c_int); /* the user data (XML parser context) */
                des_const_char_ptr(n_encoding,
                                   encoding as *const std::os::raw::c_char,
                                   2 as
                                       std::os::raw::c_int); /* the user data (XML parser context) */
                xmlResetLastError(); /* a xmlChar string */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in htmlDocContentDumpOutput\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() -
                               mem_base); /* the number of xmlChar */
                    test_ret += 1; /* the SAX handler */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buf); /* flag if non-zero sets the handler warning procedure */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur); /* the SAX handler */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_encoding); /* the SAX handler */
                    printf(b"\n\x00" as *const u8 as
                               *const std::os::raw::c_char); /* the user data (XML parser context) */
                } /* the root element name */
                n_encoding += 1
            } /* the external ID */
            n_cur += 1
        } /* the SYSTEM ID (e.g. filename or URL) */
        n_buf += 1
    } /* the user data (XML parser context) */
    function_tests += 1; /* the user data (XML parser context) */
    return test_ret; /* The name of the notation */
}
unsafe extern "C" fn test_htmlDocDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* The public ID of the entity */
    let mut mem_base: std::os::raw::c_int = 0; /* The system ID of the entity */
    let mut ret_val: std::os::raw::c_int = 0; /* the user data (XML parser context) */
    let mut f: *mut FILE = 0 as *mut FILE; /* the target name */
    let mut n_f: std::os::raw::c_int = 0; /* the PI data's */
    let mut cur: xmlDocPtr =
        0 as *mut xmlDoc; /* the user data (XML parser context) */
    let mut n_cur: std::os::raw::c_int = 0; /* The entity name */
    n_f = 0 as std::os::raw::c_int; /* the user data (XML parser context) */
    while n_f < 2 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int; /* The public ID of the entity */
        while n_cur < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* The system ID of the entity */
            f =
                gen_FILE_ptr(n_f,
                             0 as
                                 std::os::raw::c_int); /* the user data (XML parser context) */
            cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int); /* A SAX Locator */
            ret_val =
                htmlDocDump(f, cur); /* the user data (XML parser context) */
            desret_int(ret_val); /* the user data (XML parser context) */
            call_tests +=
                1; /* The element name, including namespace prefix */
            des_FILE_ptr(n_f, f,
                         0 as
                             std::os::raw::c_int); /* An array of name/value attributes pairs, NULL terminated */
            des_xmlDocPtr(n_cur, cur,
                          1 as
                              std::os::raw::c_int); /* the user data (XML parser context) */
            xmlResetLastError(); /* the local name of the element */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlDocDump\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the element namespace prefix if available */
                test_ret += 1; /* the element namespace name if available */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_f); /* number of namespace definitions on that node */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_cur); /* pointer to the array of prefix/URI pairs namespace definitions */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the number of attributes on that node */
            } /* the number of defaulted attributes. */
            n_cur += 1
        } /* pointer to the array of (localname/prefix/URI/value/end) attribute values. */
        n_f += 1
    } /* the user data (XML parser context) */
    function_tests += 1; /* The name of the entity */
    return test_ret; /* The public ID of the entity */
}
unsafe extern "C" fn gen_xmlChar_ptr_ptr(mut no: std::os::raw::c_int,
                                         mut nr: std::os::raw::c_int)
 -> *mut *mut xmlChar {
    return 0 as *mut *mut xmlChar; /* The system ID of the entity */
}
unsafe extern "C" fn des_xmlChar_ptr_ptr(mut no: std::os::raw::c_int,
                                         mut val: *mut *mut xmlChar,
                                         mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_htmlDocDumpMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the name of the notation */
    let mut mem_base: std::os::raw::c_int = 0; /* the version, 1 or 2 */
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc; /* the SAX handler */
    let mut n_cur: std::os::raw::c_int = 0; /* the version, 1 or 2 */
    let mut mem: *mut *mut xmlChar =
        0 as *mut *mut xmlChar; /* the XML document for canonization */
    let mut n_mem: std::os::raw::c_int =
        0; /* the nodes set to be included in the canonized image or NULL if all document nodes should be included */
    let mut size: *mut std::os::raw::c_int =
        0 as *mut std::os::raw::c_int; /* the c14n mode (see @xmlC14NMode) */
    let mut n_size: std::os::raw::c_int =
        0; /* the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) */
    n_cur =
        0 as
            std::os::raw::c_int; /* include comments in the result (!=0) or not (==0) */
    while n_cur < 4 as std::os::raw::c_int {
        n_mem =
            0 as
                std::os::raw::c_int; /* the memory pointer for allocated canonical XML text; the caller of this functions is responsible for calling xmlFree() to free allocated memory */
        while n_mem < 1 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int; /* the XML document for canonization */
            while n_size < 2 as std::os::raw::c_int {
                mem_base =
                    xmlMemBlocks(); /* the nodes set to be included in the canonized image or NULL if all document nodes should be included */
                cur =
                    gen_xmlDocPtr(n_cur,
                                  0 as
                                      std::os::raw::c_int); /* the c14n mode (see @xmlC14NMode) */
                mem =
                    gen_xmlChar_ptr_ptr(n_mem,
                                        1 as
                                            std::os::raw::c_int); /* the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) */
                size =
                    gen_int_ptr(n_size,
                                2 as
                                    std::os::raw::c_int); /* include comments in the result (!=0) or not (==0) */
                htmlDocDumpMemory(cur, mem,
                                  size); /* the filename to store canonical XML image */
                call_tests +=
                    1; /* the compression level (zlib requred): -1 - libxml default, 0 - uncompressed, >0 - compression level */
                des_xmlDocPtr(n_cur, cur,
                              0 as
                                  std::os::raw::c_int); /* the XML document for canonization */
                des_xmlChar_ptr_ptr(n_mem, mem,
                                    1 as
                                        std::os::raw::c_int); /* the nodes set to be included in the canonized image or NULL if all document nodes should be included */
                des_int_ptr(n_size, size,
                            2 as
                                std::os::raw::c_int); /* the c14n mode (see @xmlC14NMode) */
                xmlResetLastError(); /* the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in htmlDocDumpMemory\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() -
                               mem_base); /* include comments in the result (!=0) or not (==0) */
                    test_ret +=
                        1; /* the output buffer to store canonical XML; this buffer MUST have encoder==NULL because C14N requires UTF-8 output */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_mem);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_size);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_size += 1
            }
            n_mem += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlDocDumpMemoryFormat() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut mem: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_mem: std::os::raw::c_int = 0;
    let mut size: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_size: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 4 as std::os::raw::c_int {
        n_mem = 0 as std::os::raw::c_int;
        while n_mem < 1 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 2 as std::os::raw::c_int {
                n_format = 0 as std::os::raw::c_int;
                while n_format < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    cur = gen_xmlDocPtr(n_cur, 0 as std::os::raw::c_int);
                    mem = gen_xmlChar_ptr_ptr(n_mem, 1 as std::os::raw::c_int);
                    size = gen_int_ptr(n_size, 2 as std::os::raw::c_int);
                    format = gen_int(n_format, 3 as std::os::raw::c_int);
                    htmlDocDumpMemoryFormat(cur, mem, size, format);
                    call_tests += 1;
                    des_xmlDocPtr(n_cur, cur, 0 as std::os::raw::c_int);
                    des_xmlChar_ptr_ptr(n_mem, mem, 1 as std::os::raw::c_int);
                    des_int_ptr(n_size, size, 2 as std::os::raw::c_int);
                    des_int(n_format, format, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in htmlDocDumpMemoryFormat\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_mem);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_size);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_format);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_format += 1
                }
                n_size += 1
            }
            n_mem += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlGetMetaEncoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        doc = gen_htmlDocPtr(n_doc, 0 as std::os::raw::c_int);
        ret_val = htmlGetMetaEncoding(doc);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_htmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlGetMetaEncoding\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlIsBooleanAttr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
        ret_val = htmlIsBooleanAttr(name as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in htmlIsBooleanAttr\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_name);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlNewDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URI: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    n_URI = 0 as std::os::raw::c_int;
    while n_URI < 5 as std::os::raw::c_int {
        n_ExternalID = 0 as std::os::raw::c_int;
        while n_ExternalID < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            URI = gen_const_xmlChar_ptr(n_URI, 0 as std::os::raw::c_int);
            ExternalID =
                gen_const_xmlChar_ptr(n_ExternalID, 1 as std::os::raw::c_int);
            ret_val =
                htmlNewDoc(URI as *const xmlChar,
                           ExternalID as *const xmlChar);
            desret_htmlDocPtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_URI, URI as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_ExternalID, ExternalID as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlNewDoc\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URI);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ExternalID);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ExternalID += 1
        }
        n_URI += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlNewDocNoDtD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlDocPtr = 0 as *mut xmlDoc;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URI: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    n_URI = 0 as std::os::raw::c_int;
    while n_URI < 5 as std::os::raw::c_int {
        n_ExternalID = 0 as std::os::raw::c_int;
        while n_ExternalID < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            URI = gen_const_xmlChar_ptr(n_URI, 0 as std::os::raw::c_int);
            ExternalID =
                gen_const_xmlChar_ptr(n_ExternalID, 1 as std::os::raw::c_int);
            ret_val =
                htmlNewDocNoDtD(URI as *const xmlChar,
                                ExternalID as *const xmlChar);
            desret_htmlDocPtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_URI, URI as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_ExternalID, ExternalID as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlNewDocNoDtD\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URI);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ExternalID);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ExternalID += 1
        }
        n_URI += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlNodeDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_cur = 0 as std::os::raw::c_int;
            while n_cur < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                cur = gen_xmlNodePtr(n_cur, 2 as std::os::raw::c_int);
                ret_val = htmlNodeDump(buf, doc, cur);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlNodePtr(n_cur, cur, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in htmlNodeDump\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buf);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_cur += 1
            }
            n_doc += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlNodeDumpFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut n_out: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_cur = 0 as std::os::raw::c_int;
            while n_cur < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                out = gen_FILE_ptr(n_out, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                cur = gen_xmlNodePtr(n_cur, 2 as std::os::raw::c_int);
                htmlNodeDumpFile(out, doc, cur);
                call_tests += 1;
                des_FILE_ptr(n_out, out, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlNodePtr(n_cur, cur, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in htmlNodeDumpFile\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_out);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_cur += 1
            }
            n_doc += 1
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlNodeDumpFileFormat() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut n_out: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_cur = 0 as std::os::raw::c_int;
            while n_cur < 3 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    n_format = 0 as std::os::raw::c_int;
                    while n_format < 4 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        out = gen_FILE_ptr(n_out, 0 as std::os::raw::c_int);
                        doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                        cur = gen_xmlNodePtr(n_cur, 2 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                        format = gen_int(n_format, 4 as std::os::raw::c_int);
                        ret_val =
                            htmlNodeDumpFileFormat(out, doc, cur,
                                                   encoding as
                                                       *const std::os::raw::c_char,
                                                   format);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_FILE_ptr(n_out, out, 0 as std::os::raw::c_int);
                        des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                        des_xmlNodePtr(n_cur, cur, 2 as std::os::raw::c_int);
                        des_const_char_ptr(n_encoding,
                                           encoding as *const std::os::raw::c_char,
                                           3 as std::os::raw::c_int);
                        des_int(n_format, format, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in htmlNodeDumpFileFormat\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_out);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_doc);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_cur);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_encoding);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_format);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_format += 1
                    }
                    n_encoding += 1
                }
                n_cur += 1
            }
            n_doc += 1
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlNodeDumpFormatOutput() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_cur = 0 as std::os::raw::c_int;
            while n_cur < 3 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    n_format = 0 as std::os::raw::c_int;
                    while n_format < 4 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        buf = gen_xmlOutputBufferPtr(n_buf, 0 as std::os::raw::c_int);
                        doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                        cur = gen_xmlNodePtr(n_cur, 2 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                        format = gen_int(n_format, 4 as std::os::raw::c_int);
                        htmlNodeDumpFormatOutput(buf, doc, cur,
                                                 encoding as
                                                     *const std::os::raw::c_char,
                                                 format);
                        call_tests += 1;
                        des_xmlOutputBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
                        des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                        des_xmlNodePtr(n_cur, cur, 2 as std::os::raw::c_int);
                        des_const_char_ptr(n_encoding,
                                           encoding as *const std::os::raw::c_char,
                                           3 as std::os::raw::c_int);
                        des_int(n_format, format, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in htmlNodeDumpFormatOutput\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_buf);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_doc);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_cur);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_encoding);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_format);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_format += 1
                    }
                    n_encoding += 1
                }
                n_cur += 1
            }
            n_doc += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlNodeDumpOutput() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_cur = 0 as std::os::raw::c_int;
            while n_cur < 3 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    buf = gen_xmlOutputBufferPtr(n_buf, 0 as std::os::raw::c_int);
                    doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                    cur = gen_xmlNodePtr(n_cur, 2 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                    htmlNodeDumpOutput(buf, doc, cur,
                                       encoding as *const std::os::raw::c_char);
                    call_tests += 1;
                    des_xmlOutputBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
                    des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_cur, cur, 2 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in htmlNodeDumpOutput\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buf);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_encoding += 1
                }
                n_cur += 1
            }
            n_doc += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlSaveFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
            cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = htmlSaveFile(filename, cur);
            desret_int(ret_val);
            call_tests += 1;
            des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlSaveFile\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_filename);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlSaveFileEnc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
                cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
                encoding = gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                ret_val =
                    htmlSaveFileEnc(filename, cur,
                                    encoding as *const std::os::raw::c_char);
                desret_int(ret_val);
                call_tests += 1;
                des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
                des_const_char_ptr(n_encoding,
                                   encoding as *const std::os::raw::c_char,
                                   2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in htmlSaveFileEnc\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_encoding);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_encoding += 1
            }
            n_cur += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlSaveFileFormat() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                n_format = 0 as std::os::raw::c_int;
                while n_format < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
                    cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                    format = gen_int(n_format, 3 as std::os::raw::c_int);
                    ret_val =
                        htmlSaveFileFormat(filename, cur,
                                           encoding as *const std::os::raw::c_char,
                                           format);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
                    des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_int(n_format, format, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in htmlSaveFileFormat\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_filename);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_format);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_format += 1
                }
                n_encoding += 1
            }
            n_cur += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlSetMetaEncoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut encoding: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 3 as std::os::raw::c_int {
        n_encoding = 0 as std::os::raw::c_int;
        while n_encoding < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_htmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            encoding = gen_const_xmlChar_ptr(n_encoding, 1 as std::os::raw::c_int);
            ret_val = htmlSetMetaEncoding(doc, encoding as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_htmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_encoding, encoding as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlSetMetaEncoding\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_encoding);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_encoding += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_HTMLtree() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing HTMLtree : 18 of 18 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_htmlDocContentDumpFormatOutput();
    test_ret += test_htmlDocContentDumpOutput();
    test_ret += test_htmlDocDump();
    test_ret += test_htmlDocDumpMemory();
    test_ret += test_htmlDocDumpMemoryFormat();
    test_ret += test_htmlGetMetaEncoding();
    test_ret += test_htmlIsBooleanAttr();
    test_ret += test_htmlNewDoc();
    test_ret += test_htmlNewDocNoDtD();
    test_ret += test_htmlNodeDump();
    test_ret += test_htmlNodeDumpFile();
    test_ret += test_htmlNodeDumpFileFormat();
    test_ret += test_htmlNodeDumpFormatOutput();
    test_ret += test_htmlNodeDumpOutput();
    test_ret += test_htmlSaveFile();
    test_ret += test_htmlSaveFileEnc();
    test_ret += test_htmlSaveFileFormat();
    test_ret += test_htmlSetMetaEncoding();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module HTMLtree: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_docbDefaultSAXHandlerInit() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    docbDefaultSAXHandlerInit();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in docbDefaultSAXHandlerInit\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlDefaultSAXHandlerInit() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    htmlDefaultSAXHandlerInit();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in htmlDefaultSAXHandlerInit\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDefaultSAXHandlerInit() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlDefaultSAXHandlerInit();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlDefaultSAXHandlerInit\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlEnumerationPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> xmlEnumerationPtr {
    return 0 as xmlEnumerationPtr;
}
unsafe extern "C" fn des_xmlEnumerationPtr(mut no: std::os::raw::c_int,
                                           mut val: xmlEnumerationPtr,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSAX2AttributeDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut elem: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut fullname: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_fullname: std::os::raw::c_int = 0;
    let mut type_0: std::os::raw::c_int = 0;
    let mut n_type: std::os::raw::c_int = 0;
    let mut def: std::os::raw::c_int = 0;
    let mut n_def: std::os::raw::c_int = 0;
    let mut defaultValue: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_defaultValue: std::os::raw::c_int = 0;
    let mut tree: xmlEnumerationPtr = 0 as *mut xmlEnumeration;
    let mut n_tree: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 5 as std::os::raw::c_int {
            n_fullname = 0 as std::os::raw::c_int;
            while n_fullname < 5 as std::os::raw::c_int {
                n_type = 0 as std::os::raw::c_int;
                while n_type < 4 as std::os::raw::c_int {
                    n_def = 0 as std::os::raw::c_int;
                    while n_def < 4 as std::os::raw::c_int {
                        n_defaultValue = 0 as std::os::raw::c_int;
                        while n_defaultValue < 5 as std::os::raw::c_int {
                            n_tree = 0 as std::os::raw::c_int;
                            while n_tree < 1 as std::os::raw::c_int {
                                mem_base = xmlMemBlocks();
                                ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                                elem =
                                    gen_const_xmlChar_ptr(n_elem,
                                                          1 as std::os::raw::c_int);
                                fullname =
                                    gen_const_xmlChar_ptr(n_fullname,
                                                          2 as std::os::raw::c_int);
                                type_0 = gen_int(n_type, 3 as std::os::raw::c_int);
                                def = gen_int(n_def, 4 as std::os::raw::c_int);
                                defaultValue =
                                    gen_const_xmlChar_ptr(n_defaultValue,
                                                          5 as std::os::raw::c_int);
                                tree =
                                    gen_xmlEnumerationPtr(n_tree,
                                                          6 as std::os::raw::c_int);
                                xmlSAX2AttributeDecl(ctx,
                                                     elem as *const xmlChar,
                                                     fullname as
                                                         *const xmlChar,
                                                     type_0, def,
                                                     defaultValue as
                                                         *const xmlChar,
                                                     tree);
                                call_tests += 1;
                                des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_elem,
                                                      elem as *const xmlChar,
                                                      1 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_fullname,
                                                      fullname as
                                                          *const xmlChar,
                                                      2 as std::os::raw::c_int);
                                des_int(n_type, type_0, 3 as std::os::raw::c_int);
                                des_int(n_def, def, 4 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_defaultValue,
                                                      defaultValue as
                                                          *const xmlChar,
                                                      5 as std::os::raw::c_int);
                                des_xmlEnumerationPtr(n_tree, tree,
                                                      6 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in xmlSAX2AttributeDecl\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_ctx);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_elem);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_fullname);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_type);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_def);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_defaultValue);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_tree);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                                n_tree += 1
                            }
                            n_defaultValue += 1
                        }
                        n_def += 1
                    }
                    n_type += 1
                }
                n_fullname += 1
            }
            n_elem += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2CDataBlock() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!value.is_null() &&
                         len >
                             strlen(value as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    xmlSAX2CDataBlock(ctx, value as *const xmlChar, len);
                    call_tests += 1;
                    des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSAX2CDataBlock\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_value += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2Characters() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut ch: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ch: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_ch = 0 as std::os::raw::c_int;
        while n_ch < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                ch = gen_const_xmlChar_ptr(n_ch, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!ch.is_null() &&
                         len >
                             strlen(ch as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    xmlSAX2Characters(ctx, ch as *const xmlChar, len);
                    call_tests += 1;
                    des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_ch, ch as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSAX2Characters\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ch);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_ch += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2Comment() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
            value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
            xmlSAX2Comment(ctx, value as *const xmlChar);
            call_tests += 1;
            des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSAX2Comment\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_value += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2ElementDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut type_0: std::os::raw::c_int = 0;
    let mut n_type: std::os::raw::c_int = 0;
    let mut content: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut n_content: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_type = 0 as std::os::raw::c_int;
            while n_type < 4 as std::os::raw::c_int {
                n_content = 0 as std::os::raw::c_int;
                while n_content < 1 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    type_0 = gen_int(n_type, 2 as std::os::raw::c_int);
                    content =
                        gen_xmlElementContentPtr(n_content, 3 as std::os::raw::c_int);
                    xmlSAX2ElementDecl(ctx, name as *const xmlChar, type_0,
                                       content);
                    call_tests += 1;
                    des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_type, type_0, 2 as std::os::raw::c_int);
                    des_xmlElementContentPtr(n_content, content,
                                             3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSAX2ElementDecl\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_type);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_content += 1
                }
                n_type += 1
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2EndDocument() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        xmlSAX2EndDocument(ctx);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2EndDocument\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2EndElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            xmlSAX2EndElement(ctx, name as *const xmlChar);
            call_tests += 1;
            des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSAX2EndElement\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2EndElementNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut localname: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_localname: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URI: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_localname = 0 as std::os::raw::c_int;
        while n_localname < 5 as std::os::raw::c_int {
            n_prefix = 0 as std::os::raw::c_int;
            while n_prefix < 5 as std::os::raw::c_int {
                n_URI = 0 as std::os::raw::c_int;
                while n_URI < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                    localname =
                        gen_const_xmlChar_ptr(n_localname, 1 as std::os::raw::c_int);
                    prefix =
                        gen_const_xmlChar_ptr(n_prefix, 2 as std::os::raw::c_int);
                    URI = gen_const_xmlChar_ptr(n_URI, 3 as std::os::raw::c_int);
                    xmlSAX2EndElementNs(ctx, localname as *const xmlChar,
                                        prefix as *const xmlChar,
                                        URI as *const xmlChar);
                    call_tests += 1;
                    des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_localname,
                                          localname as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_URI, URI as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSAX2EndElementNs\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_localname);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_prefix);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_URI);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_URI += 1
                }
                n_prefix += 1
            }
            n_localname += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2EntityDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut type_0: std::os::raw::c_int = 0;
    let mut n_type: std::os::raw::c_int = 0;
    let mut publicId: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_publicId: std::os::raw::c_int = 0;
    let mut systemId: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_systemId: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_type = 0 as std::os::raw::c_int;
            while n_type < 4 as std::os::raw::c_int {
                n_publicId = 0 as std::os::raw::c_int;
                while n_publicId < 5 as std::os::raw::c_int {
                    n_systemId = 0 as std::os::raw::c_int;
                    while n_systemId < 5 as std::os::raw::c_int {
                        n_content = 0 as std::os::raw::c_int;
                        while n_content < 2 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                            name =
                                gen_const_xmlChar_ptr(n_name,
                                                      1 as std::os::raw::c_int);
                            type_0 = gen_int(n_type, 2 as std::os::raw::c_int);
                            publicId =
                                gen_const_xmlChar_ptr(n_publicId,
                                                      3 as std::os::raw::c_int);
                            systemId =
                                gen_const_xmlChar_ptr(n_systemId,
                                                      4 as std::os::raw::c_int);
                            content =
                                gen_xmlChar_ptr(n_content, 5 as std::os::raw::c_int);
                            xmlSAX2EntityDecl(ctx, name as *const xmlChar,
                                              type_0,
                                              publicId as *const xmlChar,
                                              systemId as *const xmlChar,
                                              content);
                            call_tests += 1;
                            des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_name,
                                                  name as *const xmlChar,
                                                  1 as std::os::raw::c_int);
                            des_int(n_type, type_0, 2 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_publicId,
                                                  publicId as *const xmlChar,
                                                  3 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_systemId,
                                                  systemId as *const xmlChar,
                                                  4 as std::os::raw::c_int);
                            des_xmlChar_ptr(n_content, content,
                                            5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlSAX2EntityDecl\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ctx);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_name);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_type);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_publicId);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_systemId);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_content);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_content += 1
                        }
                        n_systemId += 1
                    }
                    n_publicId += 1
                }
                n_type += 1
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2ExternalSubset() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_SystemID: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_ExternalID = 0 as std::os::raw::c_int;
            while n_ExternalID < 5 as std::os::raw::c_int {
                n_SystemID = 0 as std::os::raw::c_int;
                while n_SystemID < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    ExternalID =
                        gen_const_xmlChar_ptr(n_ExternalID, 2 as std::os::raw::c_int);
                    SystemID =
                        gen_const_xmlChar_ptr(n_SystemID, 3 as std::os::raw::c_int);
                    xmlSAX2ExternalSubset(ctx, name as *const xmlChar,
                                          ExternalID as *const xmlChar,
                                          SystemID as *const xmlChar);
                    call_tests += 1;
                    des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_ExternalID,
                                          ExternalID as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_SystemID,
                                          SystemID as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSAX2ExternalSubset\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ExternalID);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_SystemID);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_SystemID += 1
                }
                n_ExternalID += 1
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2GetColumnNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlSAX2GetColumnNumber(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2GetColumnNumber\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2GetEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlSAX2GetEntity(ctx, name as *const xmlChar);
            desret_xmlEntityPtr(ret_val);
            call_tests += 1;
            des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSAX2GetEntity\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2GetLineNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlSAX2GetLineNumber(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2GetLineNumber\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2GetParameterEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlSAX2GetParameterEntity(ctx, name as *const xmlChar);
            desret_xmlEntityPtr(ret_val);
            call_tests += 1;
            des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSAX2GetParameterEntity\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2GetPublicId() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlSAX2GetPublicId(ctx);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2GetPublicId\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2GetSystemId() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlSAX2GetSystemId(ctx);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2GetSystemId\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2HasExternalSubset() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlSAX2HasExternalSubset(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2HasExternalSubset\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2HasInternalSubset() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlSAX2HasInternalSubset(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2HasInternalSubset\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2IgnorableWhitespace() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut ch: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ch: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_ch = 0 as std::os::raw::c_int;
        while n_ch < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                ch = gen_const_xmlChar_ptr(n_ch, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!ch.is_null() &&
                         len >
                             strlen(ch as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    xmlSAX2IgnorableWhitespace(ctx, ch as *const xmlChar,
                                               len);
                    call_tests += 1;
                    des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_ch, ch as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSAX2IgnorableWhitespace\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ch);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_ch += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlSAXHandler_ptr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> *mut xmlSAXHandler {
    return 0 as *mut xmlSAXHandler;
}
unsafe extern "C" fn des_xmlSAXHandler_ptr(mut no: std::os::raw::c_int,
                                           mut val: *mut xmlSAXHandler,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSAX2InitDefaultSAXHandler() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut hdlr: *mut xmlSAXHandler = 0 as *mut xmlSAXHandler;
    let mut n_hdlr: std::os::raw::c_int = 0;
    let mut warning: std::os::raw::c_int = 0;
    let mut n_warning: std::os::raw::c_int = 0;
    n_hdlr = 0 as std::os::raw::c_int;
    while n_hdlr < 1 as std::os::raw::c_int {
        n_warning = 0 as std::os::raw::c_int;
        while n_warning < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0 as std::os::raw::c_int);
            warning = gen_int(n_warning, 1 as std::os::raw::c_int);
            xmlSAX2InitDefaultSAXHandler(hdlr, warning);
            call_tests += 1;
            des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0 as std::os::raw::c_int);
            des_int(n_warning, warning, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSAX2InitDefaultSAXHandler\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_hdlr);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_warning);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_warning += 1
        }
        n_hdlr += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2InitDocbDefaultSAXHandler() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut hdlr: *mut xmlSAXHandler = 0 as *mut xmlSAXHandler;
    let mut n_hdlr: std::os::raw::c_int = 0;
    n_hdlr = 0 as std::os::raw::c_int;
    while n_hdlr < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0 as std::os::raw::c_int);
        xmlSAX2InitDocbDefaultSAXHandler(hdlr);
        call_tests += 1;
        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2InitDocbDefaultSAXHandler\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_hdlr);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_hdlr += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2InitHtmlDefaultSAXHandler() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut hdlr: *mut xmlSAXHandler = 0 as *mut xmlSAXHandler;
    let mut n_hdlr: std::os::raw::c_int = 0;
    n_hdlr = 0 as std::os::raw::c_int;
    while n_hdlr < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0 as std::os::raw::c_int);
        xmlSAX2InitHtmlDefaultSAXHandler(hdlr);
        call_tests += 1;
        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2InitHtmlDefaultSAXHandler\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_hdlr);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_hdlr += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2InternalSubset() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_SystemID: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_ExternalID = 0 as std::os::raw::c_int;
            while n_ExternalID < 5 as std::os::raw::c_int {
                n_SystemID = 0 as std::os::raw::c_int;
                while n_SystemID < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    ExternalID =
                        gen_const_xmlChar_ptr(n_ExternalID, 2 as std::os::raw::c_int);
                    SystemID =
                        gen_const_xmlChar_ptr(n_SystemID, 3 as std::os::raw::c_int);
                    xmlSAX2InternalSubset(ctx, name as *const xmlChar,
                                          ExternalID as *const xmlChar,
                                          SystemID as *const xmlChar);
                    call_tests += 1;
                    des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_ExternalID,
                                          ExternalID as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_SystemID,
                                          SystemID as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSAX2InternalSubset\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ExternalID);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_SystemID);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_SystemID += 1
                }
                n_ExternalID += 1
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2IsStandalone() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlSAX2IsStandalone(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2IsStandalone\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2NotationDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut publicId: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_publicId: std::os::raw::c_int = 0;
    let mut systemId: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_systemId: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_publicId = 0 as std::os::raw::c_int;
            while n_publicId < 5 as std::os::raw::c_int {
                n_systemId = 0 as std::os::raw::c_int;
                while n_systemId < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    publicId =
                        gen_const_xmlChar_ptr(n_publicId, 2 as std::os::raw::c_int);
                    systemId =
                        gen_const_xmlChar_ptr(n_systemId, 3 as std::os::raw::c_int);
                    xmlSAX2NotationDecl(ctx, name as *const xmlChar,
                                        publicId as *const xmlChar,
                                        systemId as *const xmlChar);
                    call_tests += 1;
                    des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_publicId,
                                          publicId as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_systemId,
                                          systemId as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSAX2NotationDecl\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_publicId);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_systemId);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_systemId += 1
                }
                n_publicId += 1
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2ProcessingInstruction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut target: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_target: std::os::raw::c_int = 0;
    let mut data: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_data: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_target = 0 as std::os::raw::c_int;
        while n_target < 5 as std::os::raw::c_int {
            n_data = 0 as std::os::raw::c_int;
            while n_data < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                target = gen_const_xmlChar_ptr(n_target, 1 as std::os::raw::c_int);
                data = gen_const_xmlChar_ptr(n_data, 2 as std::os::raw::c_int);
                xmlSAX2ProcessingInstruction(ctx, target as *const xmlChar,
                                             data as *const xmlChar);
                call_tests += 1;
                des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_target, target as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_data, data as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSAX2ProcessingInstruction\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctx);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_target);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_data);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_data += 1
            }
            n_target += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2Reference() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            xmlSAX2Reference(ctx, name as *const xmlChar);
            call_tests += 1;
            des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSAX2Reference\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2ResolveEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut publicId: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_publicId: std::os::raw::c_int = 0;
    let mut systemId: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_systemId: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_publicId = 0 as std::os::raw::c_int;
        while n_publicId < 5 as std::os::raw::c_int {
            n_systemId = 0 as std::os::raw::c_int;
            while n_systemId < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                publicId =
                    gen_const_xmlChar_ptr(n_publicId, 1 as std::os::raw::c_int);
                systemId =
                    gen_const_xmlChar_ptr(n_systemId, 2 as std::os::raw::c_int);
                ret_val =
                    xmlSAX2ResolveEntity(ctx, publicId as *const xmlChar,
                                         systemId as *const xmlChar);
                desret_xmlParserInputPtr(ret_val);
                call_tests += 1;
                des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_publicId, publicId as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_systemId, systemId as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSAX2ResolveEntity\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctx);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_publicId);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_systemId);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_systemId += 1
            }
            n_publicId += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlSAXLocatorPtr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlSAXLocatorPtr {
    return 0 as xmlSAXLocatorPtr;
}
unsafe extern "C" fn des_xmlSAXLocatorPtr(mut no: std::os::raw::c_int,
                                          mut val: xmlSAXLocatorPtr,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSAX2SetDocumentLocator() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut loc: xmlSAXLocatorPtr = 0 as *mut xmlSAXLocator;
    let mut n_loc: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_loc = 0 as std::os::raw::c_int;
        while n_loc < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
            loc = gen_xmlSAXLocatorPtr(n_loc, 1 as std::os::raw::c_int);
            xmlSAX2SetDocumentLocator(ctx, loc);
            call_tests += 1;
            des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_xmlSAXLocatorPtr(n_loc, loc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSAX2SetDocumentLocator\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_loc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_loc += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2StartDocument() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        xmlSAX2StartDocument(ctx);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAX2StartDocument\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2StartElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut fullname: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_fullname: std::os::raw::c_int = 0;
    let mut atts: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_atts: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_fullname = 0 as std::os::raw::c_int;
        while n_fullname < 5 as std::os::raw::c_int {
            n_atts = 0 as std::os::raw::c_int;
            while n_atts < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                fullname =
                    gen_const_xmlChar_ptr(n_fullname, 1 as std::os::raw::c_int);
                atts = gen_const_xmlChar_ptr_ptr(n_atts, 2 as std::os::raw::c_int);
                xmlSAX2StartElement(ctx, fullname as *const xmlChar,
                                    atts as *mut *const xmlChar);
                call_tests += 1;
                des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_fullname, fullname as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr_ptr(n_atts, atts as *mut *const xmlChar,
                                          2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSAX2StartElement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctx);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_fullname);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_atts);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_atts += 1
            }
            n_fullname += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2StartElementNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut localname: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_localname: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URI: std::os::raw::c_int = 0;
    let mut nb_namespaces: std::os::raw::c_int = 0;
    let mut n_nb_namespaces: std::os::raw::c_int = 0;
    let mut namespaces: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_namespaces: std::os::raw::c_int = 0;
    let mut nb_attributes: std::os::raw::c_int = 0;
    let mut n_nb_attributes: std::os::raw::c_int = 0;
    let mut nb_defaulted: std::os::raw::c_int = 0;
    let mut n_nb_defaulted: std::os::raw::c_int = 0;
    let mut attributes: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_attributes: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_localname = 0 as std::os::raw::c_int;
        while n_localname < 5 as std::os::raw::c_int {
            n_prefix = 0 as std::os::raw::c_int;
            while n_prefix < 5 as std::os::raw::c_int {
                n_URI = 0 as std::os::raw::c_int;
                while n_URI < 5 as std::os::raw::c_int {
                    n_nb_namespaces = 0 as std::os::raw::c_int;
                    while n_nb_namespaces < 4 as std::os::raw::c_int {
                        n_namespaces = 0 as std::os::raw::c_int;
                        while n_namespaces < 1 as std::os::raw::c_int {
                            n_nb_attributes = 0 as std::os::raw::c_int;
                            while n_nb_attributes < 4 as std::os::raw::c_int {
                                n_nb_defaulted = 0 as std::os::raw::c_int;
                                while n_nb_defaulted < 4 as std::os::raw::c_int {
                                    n_attributes = 0 as std::os::raw::c_int;
                                    while n_attributes < 1 as std::os::raw::c_int {
                                        mem_base = xmlMemBlocks();
                                        ctx =
                                            gen_void_ptr(n_ctx,
                                                         0 as std::os::raw::c_int);
                                        localname =
                                            gen_const_xmlChar_ptr(n_localname,
                                                                  1 as
                                                                      std::os::raw::c_int);
                                        prefix =
                                            gen_const_xmlChar_ptr(n_prefix,
                                                                  2 as
                                                                      std::os::raw::c_int);
                                        URI =
                                            gen_const_xmlChar_ptr(n_URI,
                                                                  3 as
                                                                      std::os::raw::c_int);
                                        nb_namespaces =
                                            gen_int(n_nb_namespaces,
                                                    4 as std::os::raw::c_int);
                                        namespaces =
                                            gen_const_xmlChar_ptr_ptr(n_namespaces,
                                                                      5 as
                                                                          std::os::raw::c_int);
                                        nb_attributes =
                                            gen_int(n_nb_attributes,
                                                    6 as std::os::raw::c_int);
                                        nb_defaulted =
                                            gen_int(n_nb_defaulted,
                                                    7 as std::os::raw::c_int);
                                        attributes =
                                            gen_const_xmlChar_ptr_ptr(n_attributes,
                                                                      8 as
                                                                          std::os::raw::c_int);
                                        xmlSAX2StartElementNs(ctx,
                                                              localname as
                                                                  *const xmlChar,
                                                              prefix as
                                                                  *const xmlChar,
                                                              URI as
                                                                  *const xmlChar,
                                                              nb_namespaces,
                                                              namespaces as
                                                                  *mut *const xmlChar,
                                                              nb_attributes,
                                                              nb_defaulted,
                                                              attributes as
                                                                  *mut *const xmlChar);
                                        call_tests += 1;
                                        des_void_ptr(n_ctx, ctx,
                                                     0 as std::os::raw::c_int);
                                        des_const_xmlChar_ptr(n_localname,
                                                              localname as
                                                                  *const xmlChar,
                                                              1 as
                                                                  std::os::raw::c_int);
                                        des_const_xmlChar_ptr(n_prefix,
                                                              prefix as
                                                                  *const xmlChar,
                                                              2 as
                                                                  std::os::raw::c_int);
                                        des_const_xmlChar_ptr(n_URI,
                                                              URI as
                                                                  *const xmlChar,
                                                              3 as
                                                                  std::os::raw::c_int);
                                        des_int(n_nb_namespaces,
                                                nb_namespaces,
                                                4 as std::os::raw::c_int);
                                        des_const_xmlChar_ptr_ptr(n_namespaces,
                                                                  namespaces
                                                                      as
                                                                      *mut *const xmlChar,
                                                                  5 as
                                                                      std::os::raw::c_int);
                                        des_int(n_nb_attributes,
                                                nb_attributes,
                                                6 as std::os::raw::c_int);
                                        des_int(n_nb_defaulted, nb_defaulted,
                                                7 as std::os::raw::c_int);
                                        des_const_xmlChar_ptr_ptr(n_attributes,
                                                                  attributes
                                                                      as
                                                                      *mut *const xmlChar,
                                                                  8 as
                                                                      std::os::raw::c_int);
                                        xmlResetLastError();
                                        if mem_base != xmlMemBlocks() {
                                            printf(b"Leak of %d blocks found in xmlSAX2StartElementNs\x00"
                                                       as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   xmlMemBlocks() - mem_base);
                                            test_ret += 1;
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_ctx);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_localname);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_prefix);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_URI);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_nb_namespaces);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_namespaces);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_nb_attributes);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_nb_defaulted);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_attributes);
                                            printf(b"\n\x00" as *const u8 as
                                                       *const std::os::raw::c_char);
                                        }
                                        n_attributes += 1
                                    }
                                    n_nb_defaulted += 1
                                }
                                n_nb_attributes += 1
                            }
                            n_namespaces += 1
                        }
                        n_nb_namespaces += 1
                    }
                    n_URI += 1
                }
                n_prefix += 1
            }
            n_localname += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAX2UnparsedEntityDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut publicId: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_publicId: std::os::raw::c_int = 0;
    let mut systemId: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_systemId: std::os::raw::c_int = 0;
    let mut notationName: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_notationName: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_publicId = 0 as std::os::raw::c_int;
            while n_publicId < 5 as std::os::raw::c_int {
                n_systemId = 0 as std::os::raw::c_int;
                while n_systemId < 5 as std::os::raw::c_int {
                    n_notationName = 0 as std::os::raw::c_int;
                    while n_notationName < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                        publicId =
                            gen_const_xmlChar_ptr(n_publicId,
                                                  2 as std::os::raw::c_int);
                        systemId =
                            gen_const_xmlChar_ptr(n_systemId,
                                                  3 as std::os::raw::c_int);
                        notationName =
                            gen_const_xmlChar_ptr(n_notationName,
                                                  4 as std::os::raw::c_int);
                        xmlSAX2UnparsedEntityDecl(ctx, name as *const xmlChar,
                                                  publicId as *const xmlChar,
                                                  systemId as *const xmlChar,
                                                  notationName as
                                                      *const xmlChar);
                        call_tests += 1;
                        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_publicId,
                                              publicId as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_systemId,
                                              systemId as *const xmlChar,
                                              3 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_notationName,
                                              notationName as *const xmlChar,
                                              4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlSAX2UnparsedEntityDecl\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ctx);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_publicId);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_systemId);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_notationName);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_notationName += 1
                    }
                    n_systemId += 1
                }
                n_publicId += 1
            }
            n_name += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXDefaultVersion() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut version: std::os::raw::c_int = 0;
    let mut n_version: std::os::raw::c_int = 0;
    n_version = 0 as std::os::raw::c_int;
    while n_version < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        version = gen_int(n_version, 0 as std::os::raw::c_int);
        ret_val = xmlSAXDefaultVersion(version);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_version, version, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSAXDefaultVersion\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_version);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_version += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXVersion() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut hdlr: *mut xmlSAXHandler = 0 as *mut xmlSAXHandler;
    let mut n_hdlr: std::os::raw::c_int = 0;
    let mut version: std::os::raw::c_int = 0;
    let mut n_version: std::os::raw::c_int = 0;
    n_hdlr = 0 as std::os::raw::c_int;
    while n_hdlr < 1 as std::os::raw::c_int {
        n_version = 0 as std::os::raw::c_int;
        while n_version < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0 as std::os::raw::c_int);
            version = gen_int(n_version, 1 as std::os::raw::c_int);
            ret_val = xmlSAXVersion(hdlr, version);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0 as std::os::raw::c_int);
            des_int(n_version, version, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSAXVersion\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_hdlr);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_version);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_version += 1
        }
        n_hdlr += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_SAX2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing SAX2 : 38 of 38 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char);
    }
    test_ret += test_docbDefaultSAXHandlerInit();
    test_ret += test_htmlDefaultSAXHandlerInit();
    test_ret += test_xmlDefaultSAXHandlerInit();
    test_ret += test_xmlSAX2AttributeDecl();
    test_ret += test_xmlSAX2CDataBlock();
    test_ret += test_xmlSAX2Characters();
    test_ret += test_xmlSAX2Comment();
    test_ret += test_xmlSAX2ElementDecl();
    test_ret += test_xmlSAX2EndDocument();
    test_ret += test_xmlSAX2EndElement();
    test_ret += test_xmlSAX2EndElementNs();
    test_ret += test_xmlSAX2EntityDecl();
    test_ret += test_xmlSAX2ExternalSubset();
    test_ret += test_xmlSAX2GetColumnNumber();
    test_ret += test_xmlSAX2GetEntity();
    test_ret += test_xmlSAX2GetLineNumber();
    test_ret += test_xmlSAX2GetParameterEntity();
    test_ret += test_xmlSAX2GetPublicId();
    test_ret += test_xmlSAX2GetSystemId();
    test_ret += test_xmlSAX2HasExternalSubset();
    test_ret += test_xmlSAX2HasInternalSubset();
    test_ret += test_xmlSAX2IgnorableWhitespace();
    test_ret += test_xmlSAX2InitDefaultSAXHandler();
    test_ret += test_xmlSAX2InitDocbDefaultSAXHandler();
    test_ret += test_xmlSAX2InitHtmlDefaultSAXHandler();
    test_ret += test_xmlSAX2InternalSubset();
    test_ret += test_xmlSAX2IsStandalone();
    test_ret += test_xmlSAX2NotationDecl();
    test_ret += test_xmlSAX2ProcessingInstruction();
    test_ret += test_xmlSAX2Reference();
    test_ret += test_xmlSAX2ResolveEntity();
    test_ret += test_xmlSAX2SetDocumentLocator();
    test_ret += test_xmlSAX2StartDocument();
    test_ret += test_xmlSAX2StartElement();
    test_ret += test_xmlSAX2StartElementNs();
    test_ret += test_xmlSAX2UnparsedEntityDecl();
    test_ret += test_xmlSAXDefaultVersion();
    test_ret += test_xmlSAXVersion();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module SAX2: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlC14NDocDumpMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut nodes: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes: std::os::raw::c_int = 0;
    let mut mode: std::os::raw::c_int = 0;
    let mut n_mode: std::os::raw::c_int = 0;
    let mut inclusive_ns_prefixes: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_inclusive_ns_prefixes: std::os::raw::c_int = 0;
    let mut with_comments: std::os::raw::c_int = 0;
    let mut n_with_comments: std::os::raw::c_int = 0;
    let mut doc_txt_ptr: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_doc_txt_ptr: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_nodes = 0 as std::os::raw::c_int;
        while n_nodes < 1 as std::os::raw::c_int {
            n_mode = 0 as std::os::raw::c_int;
            while n_mode < 4 as std::os::raw::c_int {
                n_inclusive_ns_prefixes = 0 as std::os::raw::c_int;
                while n_inclusive_ns_prefixes < 1 as std::os::raw::c_int {
                    n_with_comments = 0 as std::os::raw::c_int;
                    while n_with_comments < 4 as std::os::raw::c_int {
                        n_doc_txt_ptr = 0 as std::os::raw::c_int;
                        while n_doc_txt_ptr < 1 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                            nodes =
                                gen_xmlNodeSetPtr(n_nodes, 1 as std::os::raw::c_int);
                            mode = gen_int(n_mode, 2 as std::os::raw::c_int);
                            inclusive_ns_prefixes =
                                gen_xmlChar_ptr_ptr(n_inclusive_ns_prefixes,
                                                    3 as std::os::raw::c_int);
                            with_comments =
                                gen_int(n_with_comments, 4 as std::os::raw::c_int);
                            doc_txt_ptr =
                                gen_xmlChar_ptr_ptr(n_doc_txt_ptr,
                                                    5 as std::os::raw::c_int);
                            ret_val =
                                xmlC14NDocDumpMemory(doc, nodes, mode,
                                                     inclusive_ns_prefixes,
                                                     with_comments,
                                                     doc_txt_ptr);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                            des_xmlNodeSetPtr(n_nodes, nodes,
                                              1 as std::os::raw::c_int);
                            des_int(n_mode, mode, 2 as std::os::raw::c_int);
                            des_xmlChar_ptr_ptr(n_inclusive_ns_prefixes,
                                                inclusive_ns_prefixes,
                                                3 as std::os::raw::c_int);
                            des_int(n_with_comments, with_comments,
                                    4 as std::os::raw::c_int);
                            des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr,
                                                5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlC14NDocDumpMemory\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_doc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_nodes);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_mode);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char,
                                       n_inclusive_ns_prefixes);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char,
                                       n_with_comments);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char,
                                       n_doc_txt_ptr);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_doc_txt_ptr += 1
                        }
                        n_with_comments += 1
                    }
                    n_inclusive_ns_prefixes += 1
                }
                n_mode += 1
            }
            n_nodes += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlC14NDocSave() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut nodes: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes: std::os::raw::c_int = 0;
    let mut mode: std::os::raw::c_int = 0;
    let mut n_mode: std::os::raw::c_int = 0;
    let mut inclusive_ns_prefixes: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_inclusive_ns_prefixes: std::os::raw::c_int = 0;
    let mut with_comments: std::os::raw::c_int = 0;
    let mut n_with_comments: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut compression: std::os::raw::c_int = 0;
    let mut n_compression: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_nodes = 0 as std::os::raw::c_int;
        while n_nodes < 1 as std::os::raw::c_int {
            n_mode = 0 as std::os::raw::c_int;
            while n_mode < 4 as std::os::raw::c_int {
                n_inclusive_ns_prefixes = 0 as std::os::raw::c_int;
                while n_inclusive_ns_prefixes < 1 as std::os::raw::c_int {
                    n_with_comments = 0 as std::os::raw::c_int;
                    while n_with_comments < 4 as std::os::raw::c_int {
                        n_filename = 0 as std::os::raw::c_int;
                        while n_filename < 6 as std::os::raw::c_int {
                            n_compression = 0 as std::os::raw::c_int;
                            while n_compression < 4 as std::os::raw::c_int {
                                mem_base = xmlMemBlocks();
                                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                                nodes =
                                    gen_xmlNodeSetPtr(n_nodes,
                                                      1 as std::os::raw::c_int);
                                mode = gen_int(n_mode, 2 as std::os::raw::c_int);
                                inclusive_ns_prefixes =
                                    gen_xmlChar_ptr_ptr(n_inclusive_ns_prefixes,
                                                        3 as std::os::raw::c_int);
                                with_comments =
                                    gen_int(n_with_comments,
                                            4 as std::os::raw::c_int);
                                filename =
                                    gen_fileoutput(n_filename,
                                                   5 as std::os::raw::c_int);
                                compression =
                                    gen_int(n_compression, 6 as std::os::raw::c_int);
                                ret_val =
                                    xmlC14NDocSave(doc, nodes, mode,
                                                   inclusive_ns_prefixes,
                                                   with_comments, filename,
                                                   compression);
                                desret_int(ret_val);
                                call_tests += 1;
                                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                                des_xmlNodeSetPtr(n_nodes, nodes,
                                                  1 as std::os::raw::c_int);
                                des_int(n_mode, mode, 2 as std::os::raw::c_int);
                                des_xmlChar_ptr_ptr(n_inclusive_ns_prefixes,
                                                    inclusive_ns_prefixes,
                                                    3 as std::os::raw::c_int);
                                des_int(n_with_comments, with_comments,
                                        4 as std::os::raw::c_int);
                                des_fileoutput(n_filename, filename,
                                               5 as std::os::raw::c_int);
                                des_int(n_compression, compression,
                                        6 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in xmlC14NDocSave\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_doc);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_nodes);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_mode);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_inclusive_ns_prefixes);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_with_comments);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_filename);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_compression);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                                n_compression += 1
                            }
                            n_filename += 1
                        }
                        n_with_comments += 1
                    }
                    n_inclusive_ns_prefixes += 1
                }
                n_mode += 1
            }
            n_nodes += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlC14NDocSaveTo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut nodes: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes: std::os::raw::c_int = 0;
    let mut mode: std::os::raw::c_int = 0;
    let mut n_mode: std::os::raw::c_int = 0;
    let mut inclusive_ns_prefixes: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_inclusive_ns_prefixes: std::os::raw::c_int = 0;
    let mut with_comments: std::os::raw::c_int = 0;
    let mut n_with_comments: std::os::raw::c_int = 0;
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_nodes = 0 as std::os::raw::c_int;
        while n_nodes < 1 as std::os::raw::c_int {
            n_mode = 0 as std::os::raw::c_int;
            while n_mode < 4 as std::os::raw::c_int {
                n_inclusive_ns_prefixes = 0 as std::os::raw::c_int;
                while n_inclusive_ns_prefixes < 1 as std::os::raw::c_int {
                    n_with_comments = 0 as std::os::raw::c_int;
                    while n_with_comments < 4 as std::os::raw::c_int {
                        n_buf = 0 as std::os::raw::c_int;
                        while n_buf < 2 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                            nodes =
                                gen_xmlNodeSetPtr(n_nodes, 1 as std::os::raw::c_int);
                            mode = gen_int(n_mode, 2 as std::os::raw::c_int);
                            inclusive_ns_prefixes =
                                gen_xmlChar_ptr_ptr(n_inclusive_ns_prefixes,
                                                    3 as std::os::raw::c_int);
                            with_comments =
                                gen_int(n_with_comments, 4 as std::os::raw::c_int);
                            buf =
                                gen_xmlOutputBufferPtr(n_buf,
                                                       5 as std::os::raw::c_int);
                            ret_val =
                                xmlC14NDocSaveTo(doc, nodes, mode,
                                                 inclusive_ns_prefixes,
                                                 with_comments, buf);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                            des_xmlNodeSetPtr(n_nodes, nodes,
                                              1 as std::os::raw::c_int);
                            des_int(n_mode, mode, 2 as std::os::raw::c_int);
                            des_xmlChar_ptr_ptr(n_inclusive_ns_prefixes,
                                                inclusive_ns_prefixes,
                                                3 as std::os::raw::c_int);
                            des_int(n_with_comments, with_comments,
                                    4 as std::os::raw::c_int);
                            des_xmlOutputBufferPtr(n_buf, buf,
                                                   5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlC14NDocSaveTo\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_doc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_nodes);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_mode);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char,
                                       n_inclusive_ns_prefixes);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char,
                                       n_with_comments);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_buf);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_buf += 1
                        }
                        n_with_comments += 1
                    }
                    n_inclusive_ns_prefixes += 1
                }
                n_mode += 1
            }
            n_nodes += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlC14NExecute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a Catalog */
}
unsafe extern "C" fn test_c14n() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the type of record to add to the catalog */
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing c14n : 3 of 4 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char); /* the system, public or prefix to match */
    } /* the replacement value for the match */
    test_ret += test_xmlC14NDocDumpMemory(); /* a Catalog */
    test_ret += test_xmlC14NDocSave(); /* the file. */
    test_ret += test_xmlC14NDocSaveTo(); /* a Catalog */
    test_ret += test_xmlC14NExecute(); /* the value to remove */
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module c14n: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret); /* a Catalog */
    } /* the public ID string */
    return test_ret; /* the system ID string */
}
unsafe extern "C" fn gen_xmlCatalogPtr(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> xmlCatalogPtr {
    return 0 as xmlCatalogPtr; /* a Catalog */
}
unsafe extern "C" fn des_xmlCatalogPtr(mut no: std::os::raw::c_int,
                                       mut val: xmlCatalogPtr,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlACatalogAdd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the public ID string */
    let mut mem_base: std::os::raw::c_int = 0; /* a Catalog */
    let mut ret_val: std::os::raw::c_int = 0; /* the system ID string */
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog; /* a Catalog */
    let mut n_catal: std::os::raw::c_int = 0; /* the URI */
    let mut type_0: *mut xmlChar =
        0 as *mut xmlChar; /* the type of record to add to the catalog */
    let mut n_type: std::os::raw::c_int =
        0; /* the system, public or prefix to match */
    let mut orig: *mut xmlChar =
        0 as *mut xmlChar; /* the replacement value for the match */
    let mut n_orig: std::os::raw::c_int = 0; /* the file. */
    let mut replace: *mut xmlChar =
        0 as *mut xmlChar; /* should this create an SGML catalog */
    let mut n_replace: std::os::raw::c_int = 0; /* a document's list of catalogs */
    n_catal = 0 as std::os::raw::c_int; /* the public ID string */
    while n_catal < 1 as std::os::raw::c_int {
        n_type = 0 as std::os::raw::c_int; /* the system ID string */
        while n_type < 5 as std::os::raw::c_int {
            n_orig = 0 as std::os::raw::c_int; /* a document's list of catalogs */
            while n_orig < 5 as std::os::raw::c_int {
                n_replace = 0 as std::os::raw::c_int; /* the URI */
                while n_replace < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks(); /* the value to remove */
                    catal =
                        gen_xmlCatalogPtr(n_catal,
                                          0 as
                                              std::os::raw::c_int); /* the public ID string */
                    type_0 =
                        gen_const_xmlChar_ptr(n_type,
                                              1 as
                                                  std::os::raw::c_int); /* the system ID string */
                    orig =
                        gen_const_xmlChar_ptr(n_orig,
                                              2 as
                                                  std::os::raw::c_int); /* the public ID string */
                    replace =
                        gen_const_xmlChar_ptr(n_replace,
                                              3 as
                                                  std::os::raw::c_int); /* the system ID string */
                    ret_val =
                        xmlACatalogAdd(catal, type_0 as *const xmlChar,
                                       orig as *const xmlChar,
                                       replace as
                                           *const xmlChar); /* the URI */
                    desret_int(ret_val); /* the default preference for delegation */
                    call_tests += 1; /* what catalogs should be accepted */
                    des_xmlCatalogPtr(n_catal, catal,
                                      0 as std::os::raw::c_int); /* the catalog */
                    des_const_xmlChar_ptr(n_type, type_0 as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_orig, orig as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_replace,
                                          replace as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlACatalogAdd\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_catal);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_type);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_orig);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_replace);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_replace += 1
                }
                n_orig += 1
            }
            n_type += 1
        }
        n_catal += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlACatalogDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut n_catal: std::os::raw::c_int = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut n_out: std::os::raw::c_int = 0;
    n_catal = 0 as std::os::raw::c_int;
    while n_catal < 1 as std::os::raw::c_int {
        n_out = 0 as std::os::raw::c_int;
        while n_out < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            catal = gen_xmlCatalogPtr(n_catal, 0 as std::os::raw::c_int);
            out = gen_FILE_ptr(n_out, 1 as std::os::raw::c_int);
            xmlACatalogDump(catal, out);
            call_tests += 1;
            des_xmlCatalogPtr(n_catal, catal, 0 as std::os::raw::c_int);
            des_FILE_ptr(n_out, out, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlACatalogDump\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_catal);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_out);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_out += 1
        }
        n_catal += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlACatalogRemove() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut n_catal: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_catal = 0 as std::os::raw::c_int;
    while n_catal < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            catal = gen_xmlCatalogPtr(n_catal, 0 as std::os::raw::c_int);
            value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
            ret_val = xmlACatalogRemove(catal, value as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlCatalogPtr(n_catal, catal, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlACatalogRemove\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_catal);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_value += 1
        }
        n_catal += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlACatalogResolve() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut n_catal: std::os::raw::c_int = 0;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubID: std::os::raw::c_int = 0;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysID: std::os::raw::c_int = 0;
    n_catal = 0 as std::os::raw::c_int;
    while n_catal < 1 as std::os::raw::c_int {
        n_pubID = 0 as std::os::raw::c_int;
        while n_pubID < 5 as std::os::raw::c_int {
            n_sysID = 0 as std::os::raw::c_int;
            while n_sysID < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                catal = gen_xmlCatalogPtr(n_catal, 0 as std::os::raw::c_int);
                pubID = gen_const_xmlChar_ptr(n_pubID, 1 as std::os::raw::c_int);
                sysID = gen_const_xmlChar_ptr(n_sysID, 2 as std::os::raw::c_int);
                ret_val =
                    xmlACatalogResolve(catal, pubID as *const xmlChar,
                                       sysID as *const xmlChar);
                desret_xmlChar_ptr(ret_val);
                call_tests += 1;
                des_xmlCatalogPtr(n_catal, catal, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_pubID, pubID as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_sysID, sysID as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlACatalogResolve\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_catal);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_pubID);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_sysID);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_sysID += 1
            }
            n_pubID += 1
        }
        n_catal += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlACatalogResolvePublic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut n_catal: std::os::raw::c_int = 0;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubID: std::os::raw::c_int = 0;
    n_catal = 0 as std::os::raw::c_int;
    while n_catal < 1 as std::os::raw::c_int {
        n_pubID = 0 as std::os::raw::c_int;
        while n_pubID < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            catal = gen_xmlCatalogPtr(n_catal, 0 as std::os::raw::c_int);
            pubID = gen_const_xmlChar_ptr(n_pubID, 1 as std::os::raw::c_int);
            ret_val =
                xmlACatalogResolvePublic(catal, pubID as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_xmlCatalogPtr(n_catal, catal, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_pubID, pubID as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlACatalogResolvePublic\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_catal);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_pubID);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_pubID += 1
        }
        n_catal += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlACatalogResolveSystem() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut n_catal: std::os::raw::c_int = 0;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysID: std::os::raw::c_int = 0;
    n_catal = 0 as std::os::raw::c_int;
    while n_catal < 1 as std::os::raw::c_int {
        n_sysID = 0 as std::os::raw::c_int;
        while n_sysID < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            catal = gen_xmlCatalogPtr(n_catal, 0 as std::os::raw::c_int);
            sysID = gen_const_xmlChar_ptr(n_sysID, 1 as std::os::raw::c_int);
            ret_val =
                xmlACatalogResolveSystem(catal, sysID as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_xmlCatalogPtr(n_catal, catal, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_sysID, sysID as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlACatalogResolveSystem\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_catal);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_sysID);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_sysID += 1
        }
        n_catal += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlACatalogResolveURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut n_catal: std::os::raw::c_int = 0;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URI: std::os::raw::c_int = 0;
    n_catal = 0 as std::os::raw::c_int;
    while n_catal < 1 as std::os::raw::c_int {
        n_URI = 0 as std::os::raw::c_int;
        while n_URI < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            catal = gen_xmlCatalogPtr(n_catal, 0 as std::os::raw::c_int);
            URI = gen_const_xmlChar_ptr(n_URI, 1 as std::os::raw::c_int);
            ret_val = xmlACatalogResolveURI(catal, URI as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_xmlCatalogPtr(n_catal, catal, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_URI, URI as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlACatalogResolveURI\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_catal);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URI);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_URI += 1
        }
        n_catal += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogAdd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut type_0: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_type: std::os::raw::c_int = 0;
    let mut orig: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_orig: std::os::raw::c_int = 0;
    let mut replace: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_replace: std::os::raw::c_int = 0;
    n_type = 0 as std::os::raw::c_int;
    while n_type < 5 as std::os::raw::c_int {
        n_orig = 0 as std::os::raw::c_int;
        while n_orig < 5 as std::os::raw::c_int {
            n_replace = 0 as std::os::raw::c_int;
            while n_replace < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                type_0 = gen_const_xmlChar_ptr(n_type, 0 as std::os::raw::c_int);
                orig = gen_const_xmlChar_ptr(n_orig, 1 as std::os::raw::c_int);
                replace = gen_const_xmlChar_ptr(n_replace, 2 as std::os::raw::c_int);
                ret_val =
                    xmlCatalogAdd(type_0 as *const xmlChar,
                                  orig as *const xmlChar,
                                  replace as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_const_xmlChar_ptr(n_type, type_0 as *const xmlChar,
                                      0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_orig, orig as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_replace, replace as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlCatalogAdd\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_type);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_orig);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_replace);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_replace += 1
            }
            n_orig += 1
        }
        n_type += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogCleanup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    xmlCatalogCleanup();
    call_tests += 1;
    xmlResetLastError();
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogConvert() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret_val: std::os::raw::c_int = 0;
    ret_val = xmlCatalogConvert();
    desret_int(ret_val);
    call_tests += 1;
    xmlResetLastError();
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut n_out: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0 as std::os::raw::c_int);
        xmlCatalogDump(out);
        call_tests += 1;
        des_FILE_ptr(n_out, out, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCatalogDump\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_out);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogGetDefaults() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlCatalogAllow = XML_CATA_ALLOW_NONE;
    mem_base = xmlMemBlocks();
    ret_val = xmlCatalogGetDefaults();
    desret_xmlCatalogAllow(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlCatalogGetDefaults\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogIsEmpty() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut n_catal: std::os::raw::c_int = 0;
    n_catal = 0 as std::os::raw::c_int;
    while n_catal < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0 as std::os::raw::c_int);
        ret_val = xmlCatalogIsEmpty(catal);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlCatalogPtr(n_catal, catal, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCatalogIsEmpty\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_catal);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_catal += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogLocalResolve() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut catalogs: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_catalogs: std::os::raw::c_int = 0;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubID: std::os::raw::c_int = 0;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysID: std::os::raw::c_int = 0;
    n_catalogs = 0 as std::os::raw::c_int;
    while n_catalogs < 2 as std::os::raw::c_int {
        n_pubID = 0 as std::os::raw::c_int;
        while n_pubID < 5 as std::os::raw::c_int {
            n_sysID = 0 as std::os::raw::c_int;
            while n_sysID < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                catalogs = gen_void_ptr(n_catalogs, 0 as std::os::raw::c_int);
                pubID = gen_const_xmlChar_ptr(n_pubID, 1 as std::os::raw::c_int);
                sysID = gen_const_xmlChar_ptr(n_sysID, 2 as std::os::raw::c_int);
                ret_val =
                    xmlCatalogLocalResolve(catalogs, pubID as *const xmlChar,
                                           sysID as *const xmlChar);
                desret_xmlChar_ptr(ret_val);
                call_tests += 1;
                des_void_ptr(n_catalogs, catalogs, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_pubID, pubID as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_sysID, sysID as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlCatalogLocalResolve\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_catalogs);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_pubID);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_sysID);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_sysID += 1
            }
            n_pubID += 1
        }
        n_catalogs += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogLocalResolveURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut catalogs: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_catalogs: std::os::raw::c_int = 0;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URI: std::os::raw::c_int = 0;
    n_catalogs = 0 as std::os::raw::c_int;
    while n_catalogs < 2 as std::os::raw::c_int {
        n_URI = 0 as std::os::raw::c_int;
        while n_URI < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            catalogs = gen_void_ptr(n_catalogs, 0 as std::os::raw::c_int);
            URI = gen_const_xmlChar_ptr(n_URI, 1 as std::os::raw::c_int);
            ret_val =
                xmlCatalogLocalResolveURI(catalogs, URI as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_void_ptr(n_catalogs, catalogs, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_URI, URI as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCatalogLocalResolveURI\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_catalogs);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URI);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_URI += 1
        }
        n_catalogs += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogRemove() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
        ret_val = xmlCatalogRemove(value as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogResolve() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubID: std::os::raw::c_int = 0;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysID: std::os::raw::c_int = 0;
    n_pubID = 0 as std::os::raw::c_int;
    while n_pubID < 5 as std::os::raw::c_int {
        n_sysID = 0 as std::os::raw::c_int;
        while n_sysID < 5 as std::os::raw::c_int {
            pubID = gen_const_xmlChar_ptr(n_pubID, 0 as std::os::raw::c_int);
            sysID = gen_const_xmlChar_ptr(n_sysID, 1 as std::os::raw::c_int);
            ret_val =
                xmlCatalogResolve(pubID as *const xmlChar,
                                  sysID as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_pubID, pubID as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_sysID, sysID as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            n_sysID += 1
        }
        n_pubID += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogResolvePublic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubID: std::os::raw::c_int = 0;
    n_pubID = 0 as std::os::raw::c_int;
    while n_pubID < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        pubID = gen_const_xmlChar_ptr(n_pubID, 0 as std::os::raw::c_int);
        ret_val = xmlCatalogResolvePublic(pubID as *const xmlChar);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_pubID, pubID as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCatalogResolvePublic\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_pubID);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_pubID += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogResolveSystem() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysID: std::os::raw::c_int = 0;
    n_sysID = 0 as std::os::raw::c_int;
    while n_sysID < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        sysID = gen_const_xmlChar_ptr(n_sysID, 0 as std::os::raw::c_int);
        ret_val = xmlCatalogResolveSystem(sysID as *const xmlChar);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_sysID, sysID as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCatalogResolveSystem\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_sysID);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_sysID += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogResolveURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URI: std::os::raw::c_int = 0;
    n_URI = 0 as std::os::raw::c_int;
    while n_URI < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0 as std::os::raw::c_int);
        ret_val = xmlCatalogResolveURI(URI as *const xmlChar);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_URI, URI as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCatalogResolveURI\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URI);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_URI += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogSetDefaultPrefer() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlCatalogPrefer = XML_CATA_PREFER_NONE;
    let mut prefer: xmlCatalogPrefer = XML_CATA_PREFER_NONE;
    let mut n_prefer: std::os::raw::c_int = 0;
    n_prefer = 0 as std::os::raw::c_int;
    while n_prefer < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        prefer = gen_xmlCatalogPrefer(n_prefer, 0 as std::os::raw::c_int);
        ret_val = xmlCatalogSetDefaultPrefer(prefer);
        desret_xmlCatalogPrefer(ret_val);
        call_tests += 1;
        des_xmlCatalogPrefer(n_prefer, prefer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCatalogSetDefaultPrefer\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_prefer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_prefer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCatalogSetDefaults() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut allow: xmlCatalogAllow = XML_CATA_ALLOW_NONE;
    let mut n_allow: std::os::raw::c_int = 0;
    n_allow = 0 as std::os::raw::c_int;
    while n_allow < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        allow = gen_xmlCatalogAllow(n_allow, 0 as std::os::raw::c_int);
        xmlCatalogSetDefaults(allow);
        call_tests += 1;
        des_xmlCatalogAllow(n_allow, allow, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCatalogSetDefaults\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_allow);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_allow += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlConvertSGMLCatalog() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut n_catal: std::os::raw::c_int = 0;
    n_catal = 0 as std::os::raw::c_int;
    while n_catal < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0 as std::os::raw::c_int);
        ret_val = xmlConvertSGMLCatalog(catal);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlCatalogPtr(n_catal, catal, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlConvertSGMLCatalog\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_catal);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_catal += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlInitializeCatalog() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlInitializeCatalog();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlInitializeCatalog\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlLoadACatalog() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a file path */
}
unsafe extern "C" fn test_xmlLoadCatalog() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* a list of directories separated by a colon or a space. */
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlLoadCatalog(filename);
        desret_int(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlLoadCatalogs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut pathss: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_pathss: std::os::raw::c_int = 0;
    n_pathss = 0 as std::os::raw::c_int;
    while n_pathss < 4 as std::os::raw::c_int {
        pathss = gen_const_char_ptr(n_pathss, 0 as std::os::raw::c_int);
        xmlLoadCatalogs(pathss as *const std::os::raw::c_char);
        call_tests += 1;
        des_const_char_ptr(n_pathss, pathss as *const std::os::raw::c_char,
                           0 as std::os::raw::c_int);
        xmlResetLastError();
        n_pathss += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlLoadSGMLSuperCatalog() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlNewCatalog() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the filename */
}
unsafe extern "C" fn test_xmlParseCatalogFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* character to be validated */
    let mut mem_base: std::os::raw::c_int =
        0; /* pointer to range to be used to validate */
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc; /* character to validate */
    let mut filename: *const std::os::raw::c_char =
        0 as *const std::os::raw::c_char; /* character to validate */
    let mut n_filename: std::os::raw::c_int = 0; /* character to validate */
    n_filename = 0 as std::os::raw::c_int; /* character to validate */
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* character to validate */
        filename =
            gen_filepath(n_filename,
                         0 as std::os::raw::c_int); /* character to validate */
        ret_val = xmlParseCatalogFile(filename); /* character to validate */
        desret_xmlDocPtr(ret_val); /* character to validate */
        call_tests += 1; /* a bool to turn into text */
        des_filepath(n_filename, filename,
                     0 as std::os::raw::c_int); /* the FILE * for the output */
        xmlResetLastError(); /* the document */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParseCatalogFile\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* the FILE * for the output */
            test_ret += 1; /* the attribute */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename); /* the indentation level. */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the FILE * for the output */
        } /* the attribute list */
        n_filename += 1
    } /* the indentation level. */
    function_tests += 1; /* the FILE * for the output */
    return test_ret; /* the DTD */
}
unsafe extern "C" fn test_catalog() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the FILE * for the output */
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing catalog : 27 of 36 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char); /* the document */
    } /* the FILE * for the output */
    test_ret += test_xmlACatalogAdd(); /* the document */
    test_ret += test_xmlACatalogDump(); /* the FILE * for the output */
    test_ret += test_xmlACatalogRemove(); /* the document */
    test_ret += test_xmlACatalogResolve(); /* the FILE * for the output */
    test_ret += test_xmlACatalogResolvePublic(); /* the node */
    test_ret += test_xmlACatalogResolveSystem(); /* the indentation level. */
    test_ret += test_xmlACatalogResolveURI(); /* the FILE * for the output */
    test_ret += test_xmlCatalogAdd(); /* the node list */
    test_ret += test_xmlCatalogCleanup(); /* the indentation level. */
    test_ret += test_xmlCatalogConvert(); /* the FILE * for the output */
    test_ret += test_xmlCatalogDump(); /* the node */
    test_ret += test_xmlCatalogGetDefaults(); /* the indentation level. */
    test_ret += test_xmlCatalogIsEmpty(); /* the FILE * for the output */
    test_ret += test_xmlCatalogLocalResolve(); /* the string */
    test_ret += test_xmlCatalogLocalResolveURI(); /* the node to count */
    test_ret += test_xmlCatalogRemove(); /* the FILE * for the output */
    test_ret += test_xmlCatalogResolve(); /* the node to dump */
    test_ret += test_xmlCatalogResolvePublic();
    test_ret += test_xmlCatalogResolveSystem();
    test_ret += test_xmlCatalogResolveURI();
    test_ret += test_xmlCatalogSetDefaultPrefer();
    test_ret += test_xmlCatalogSetDefaults();
    test_ret += test_xmlConvertSGMLCatalog();
    test_ret += test_xmlInitializeCatalog();
    test_ret += test_xmlLoadACatalog();
    test_ret += test_xmlLoadCatalog();
    test_ret += test_xmlLoadCatalogs();
    test_ret += test_xmlLoadSGMLSuperCatalog();
    test_ret += test_xmlNewCatalog();
    test_ret += test_xmlParseCatalogFile();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module catalog: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn gen_const_xmlChRangeGroup_ptr(mut no: std::os::raw::c_int,
                                                   mut nr: std::os::raw::c_int)
 -> *mut xmlChRangeGroup {
    return 0 as *mut xmlChRangeGroup;
}
unsafe extern "C" fn des_const_xmlChRangeGroup_ptr(mut no: std::os::raw::c_int,
                                                   mut val:
                                                       *const xmlChRangeGroup,
                                                   mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlCharInRange() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_uint = 0;
    let mut n_val: std::os::raw::c_int = 0;
    let mut rptr: *mut xmlChRangeGroup = 0 as *mut xmlChRangeGroup;
    let mut n_rptr: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 3 as std::os::raw::c_int {
        n_rptr = 0 as std::os::raw::c_int;
        while n_rptr < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            val = gen_unsigned_int(n_val, 0 as std::os::raw::c_int);
            rptr = gen_const_xmlChRangeGroup_ptr(n_rptr, 1 as std::os::raw::c_int);
            ret_val = xmlCharInRange(val, rptr as *const xmlChRangeGroup);
            desret_int(ret_val);
            call_tests += 1;
            des_unsigned_int(n_val, val, 0 as std::os::raw::c_int);
            des_const_xmlChRangeGroup_ptr(n_rptr,
                                          rptr as *const xmlChRangeGroup,
                                          1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCharInRange\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_rptr);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_rptr += 1
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsBaseChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    let mut n_ch: std::os::raw::c_int = 0;
    n_ch = 0 as std::os::raw::c_int;
    while n_ch < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0 as std::os::raw::c_int);
        ret_val = xmlIsBaseChar(ch);
        desret_int(ret_val);
        call_tests += 1;
        des_unsigned_int(n_ch, ch, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsBaseChar\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ch);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ch += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsBlank() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    let mut n_ch: std::os::raw::c_int = 0;
    n_ch = 0 as std::os::raw::c_int;
    while n_ch < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0 as std::os::raw::c_int);
        ret_val = xmlIsBlank(ch);
        desret_int(ret_val);
        call_tests += 1;
        des_unsigned_int(n_ch, ch, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsBlank\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ch);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ch += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    let mut n_ch: std::os::raw::c_int = 0;
    n_ch = 0 as std::os::raw::c_int;
    while n_ch < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0 as std::os::raw::c_int);
        ret_val = xmlIsChar(ch);
        desret_int(ret_val);
        call_tests += 1;
        des_unsigned_int(n_ch, ch, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsChar\x00" as *const u8 as
                       *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ch);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ch += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsCombining() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    let mut n_ch: std::os::raw::c_int = 0;
    n_ch = 0 as std::os::raw::c_int;
    while n_ch < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0 as std::os::raw::c_int);
        ret_val = xmlIsCombining(ch);
        desret_int(ret_val);
        call_tests += 1;
        des_unsigned_int(n_ch, ch, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsCombining\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ch);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ch += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsDigit() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    let mut n_ch: std::os::raw::c_int = 0;
    n_ch = 0 as std::os::raw::c_int;
    while n_ch < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0 as std::os::raw::c_int);
        ret_val = xmlIsDigit(ch);
        desret_int(ret_val);
        call_tests += 1;
        des_unsigned_int(n_ch, ch, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsDigit\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ch);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ch += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsExtender() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    let mut n_ch: std::os::raw::c_int = 0;
    n_ch = 0 as std::os::raw::c_int;
    while n_ch < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0 as std::os::raw::c_int);
        ret_val = xmlIsExtender(ch);
        desret_int(ret_val);
        call_tests += 1;
        des_unsigned_int(n_ch, ch, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsExtender\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ch);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ch += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsIdeographic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    let mut n_ch: std::os::raw::c_int = 0;
    n_ch = 0 as std::os::raw::c_int;
    while n_ch < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0 as std::os::raw::c_int);
        ret_val = xmlIsIdeographic(ch);
        desret_int(ret_val);
        call_tests += 1;
        des_unsigned_int(n_ch, ch, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsIdeographic\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ch);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ch += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsPubidChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    let mut n_ch: std::os::raw::c_int = 0;
    n_ch = 0 as std::os::raw::c_int;
    while n_ch < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0 as std::os::raw::c_int);
        ret_val = xmlIsPubidChar(ch);
        desret_int(ret_val);
        call_tests += 1;
        des_unsigned_int(n_ch, ch, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsPubidChar\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ch);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ch += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_chvalid() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing chvalid : 9 of 9 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char);
    }
    test_ret += test_xmlCharInRange();
    test_ret += test_xmlIsBaseChar();
    test_ret += test_xmlIsBlank();
    test_ret += test_xmlIsChar();
    test_ret += test_xmlIsCombining();
    test_ret += test_xmlIsDigit();
    test_ret += test_xmlIsExtender();
    test_ret += test_xmlIsIdeographic();
    test_ret += test_xmlIsPubidChar();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module chvalid: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlBoolToText() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut boolval: std::os::raw::c_int = 0;
    let mut n_boolval: std::os::raw::c_int = 0;
    n_boolval = 0 as std::os::raw::c_int;
    while n_boolval < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        boolval = gen_int(n_boolval, 0 as std::os::raw::c_int);
        ret_val = xmlBoolToText(boolval);
        desret_const_char_ptr(ret_val);
        call_tests += 1;
        des_int(n_boolval, boolval, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlBoolToText\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_boolval);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_boolval += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugCheckDocument() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            ret_val = xmlDebugCheckDocument(output, doc);
            desret_int(ret_val);
            call_tests += 1;
            des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDebugCheckDocument\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpAttr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut n_attr: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_attr = 0 as std::os::raw::c_int;
        while n_attr < 2 as std::os::raw::c_int {
            n_depth = 0 as std::os::raw::c_int;
            while n_depth < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
                attr = gen_xmlAttrPtr(n_attr, 1 as std::os::raw::c_int);
                depth = gen_int(n_depth, 2 as std::os::raw::c_int);
                xmlDebugDumpAttr(output, attr, depth);
                call_tests += 1;
                des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
                des_xmlAttrPtr(n_attr, attr, 1 as std::os::raw::c_int);
                des_int(n_depth, depth, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDebugDumpAttr\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_output);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_attr);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_depth);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_depth += 1
            }
            n_attr += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpAttrList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut n_attr: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_attr = 0 as std::os::raw::c_int;
        while n_attr < 2 as std::os::raw::c_int {
            n_depth = 0 as std::os::raw::c_int;
            while n_depth < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
                attr = gen_xmlAttrPtr(n_attr, 1 as std::os::raw::c_int);
                depth = gen_int(n_depth, 2 as std::os::raw::c_int);
                xmlDebugDumpAttrList(output, attr, depth);
                call_tests += 1;
                des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
                des_xmlAttrPtr(n_attr, attr, 1 as std::os::raw::c_int);
                des_int(n_depth, depth, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDebugDumpAttrList\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_output);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_attr);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_depth);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_depth += 1
            }
            n_attr += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpDTD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut n_dtd: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_dtd = 0 as std::os::raw::c_int;
        while n_dtd < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            dtd = gen_xmlDtdPtr(n_dtd, 1 as std::os::raw::c_int);
            xmlDebugDumpDTD(output, dtd);
            call_tests += 1;
            des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlDtdPtr(n_dtd, dtd, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDebugDumpDTD\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_dtd);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_dtd += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpDocument() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            xmlDebugDumpDocument(output, doc);
            call_tests += 1;
            des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDebugDumpDocument\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpDocumentHead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            xmlDebugDumpDocumentHead(output, doc);
            call_tests += 1;
            des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDebugDumpDocumentHead\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpEntities() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            xmlDebugDumpEntities(output, doc);
            call_tests += 1;
            des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDebugDumpEntities\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            n_depth = 0 as std::os::raw::c_int;
            while n_depth < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
                node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
                depth = gen_int(n_depth, 2 as std::os::raw::c_int);
                xmlDebugDumpNode(output, node, depth);
                call_tests += 1;
                des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
                des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
                des_int(n_depth, depth, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDebugDumpNode\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_output);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_depth);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_depth += 1
            }
            n_node += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpNodeList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            n_depth = 0 as std::os::raw::c_int;
            while n_depth < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
                node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
                depth = gen_int(n_depth, 2 as std::os::raw::c_int);
                xmlDebugDumpNodeList(output, node, depth);
                call_tests += 1;
                des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
                des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
                des_int(n_depth, depth, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDebugDumpNodeList\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_output);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_depth);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_depth += 1
            }
            n_node += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpOneNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            n_depth = 0 as std::os::raw::c_int;
            while n_depth < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
                node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
                depth = gen_int(n_depth, 2 as std::os::raw::c_int);
                xmlDebugDumpOneNode(output, node, depth);
                call_tests += 1;
                des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
                des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
                des_int(n_depth, depth, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDebugDumpOneNode\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_output);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_depth);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_depth += 1
            }
            n_node += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDebugDumpString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            str = gen_const_xmlChar_ptr(n_str, 1 as std::os::raw::c_int);
            xmlDebugDumpString(output, str as *const xmlChar);
            call_tests += 1;
            des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDebugDumpString\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlLsCountNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
        ret_val = xmlLsCountNode(node);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlLsCountNode\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_node);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlLsOneNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_debug_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            xmlLsOneNode(output, node);
            call_tests += 1;
            des_debug_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlLsOneNode\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_char_ptr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> *mut std::os::raw::c_char {
    return 0 as *mut std::os::raw::c_char;
}
unsafe extern "C" fn des_char_ptr(mut no: std::os::raw::c_int,
                                  mut val: *mut std::os::raw::c_char,
                                  mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlShell() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the shell context */
}
unsafe extern "C" fn test_xmlShellBase() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* unused */
    let mut mem_base: std::os::raw::c_int = 0; /* a node */
    let mut ret_val: std::os::raw::c_int = 0; /* unused */
    let mut ctxt: xmlShellCtxtPtr =
        0 as *mut xmlShellCtxt; /* the shell context */
    let mut n_ctxt: std::os::raw::c_int = 0; /* unused */
    let mut arg: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char; /* a node */
    let mut n_arg: std::os::raw::c_int = 0; /* unused */
    let mut node: xmlNodePtr = 0 as *mut xmlNode; /* the shell context */
    let mut n_node: std::os::raw::c_int = 0; /* unused */
    let mut node2: xmlNodePtr = 0 as *mut xmlNode; /* a node */
    let mut n_node2: std::os::raw::c_int = 0; /* unused */
    n_ctxt = 0 as std::os::raw::c_int; /* the shell context */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_arg = 0 as std::os::raw::c_int; /* unused */
        while n_arg < 1 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int; /* a node defining a subtree */
            while n_node < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int; /* unused */
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks(); /* the shell context */
                    ctxt =
                        gen_xmlShellCtxtPtr(n_ctxt,
                                            0 as std::os::raw::c_int); /* unused */
                    arg = gen_char_ptr(n_arg, 1 as std::os::raw::c_int); /* a node */
                    node =
                        gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int); /* unused */
                    node2 =
                        gen_xmlNodePtr(n_node2,
                                       3 as
                                           std::os::raw::c_int); /* the shell context */
                    ret_val =
                        xmlShellBase(ctxt, arg, node,
                                     node2); /* the file name */
                    desret_int(ret_val); /* unused */
                    call_tests += 1; /* unused */
                    des_xmlShellCtxtPtr(n_ctxt, ctxt,
                                        0 as
                                            std::os::raw::c_int); /* a valid result generated by an xpath evaluation */
                    des_char_ptr(n_arg, arg,
                                 1 as std::os::raw::c_int); /* the shell context */
                    des_xmlNodePtr(n_node, node,
                                   2 as std::os::raw::c_int); /* the output buffer */
                    des_xmlNodePtr(n_node2, node2,
                                   3 as std::os::raw::c_int); /* a node */
                    xmlResetLastError(); /* unused */
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellBase\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() -
                                   mem_base); /* the shell context */
                        test_ret += 1; /* the file name (optional) */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt); /* unused */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_arg); /* unused */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node); /* the shell context */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2); /* the DTD URI (optional) */
                        printf(b"\n\x00" as *const u8 as
                                   *const std::os::raw::c_char); /* unused */
                    } /* unused */
                    n_node2 += 1
                } /* the shell context */
                n_node += 1
            } /* the file name */
            n_arg += 1
        } /* a node in the tree */
        n_ctxt += 1
    } /* unused */
    function_tests += 1; /* an existing dictionary */
    return test_ret; /* the dictionary */
}
unsafe extern "C" fn test_xmlShellCat() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the name of the userdata */
    let mut mem_base: std::os::raw::c_int =
        0; /* the length of the name, if -1 it is recomputed */
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlShellCtxtPtr = 0 as *mut xmlShellCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut arg: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_arg: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_arg = 0 as std::os::raw::c_int;
        while n_arg < 1 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int;
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    arg = gen_char_ptr(n_arg, 1 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                    node2 = gen_xmlNodePtr(n_node2, 3 as std::os::raw::c_int);
                    ret_val = xmlShellCat(ctxt, arg, node, node2);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlShellCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_char_ptr(n_arg, arg, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node2, node2, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellCat\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_arg);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node2 += 1
                }
                n_node += 1
            }
            n_arg += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlShellDir() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlShellCtxtPtr = 0 as *mut xmlShellCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut arg: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_arg: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_arg = 0 as std::os::raw::c_int;
        while n_arg < 1 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int;
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    arg = gen_char_ptr(n_arg, 1 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                    node2 = gen_xmlNodePtr(n_node2, 3 as std::os::raw::c_int);
                    ret_val = xmlShellDir(ctxt, arg, node, node2);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlShellCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_char_ptr(n_arg, arg, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node2, node2, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellDir\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_arg);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node2 += 1
                }
                n_node += 1
            }
            n_arg += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlShellDu() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlShellCtxtPtr = 0 as *mut xmlShellCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut arg: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_arg: std::os::raw::c_int = 0;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_tree: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_arg = 0 as std::os::raw::c_int;
        while n_arg < 1 as std::os::raw::c_int {
            n_tree = 0 as std::os::raw::c_int;
            while n_tree < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int;
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    arg = gen_char_ptr(n_arg, 1 as std::os::raw::c_int);
                    tree = gen_xmlNodePtr(n_tree, 2 as std::os::raw::c_int);
                    node2 = gen_xmlNodePtr(n_node2, 3 as std::os::raw::c_int);
                    ret_val = xmlShellDu(ctxt, arg, tree, node2);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlShellCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_char_ptr(n_arg, arg, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_tree, tree, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node2, node2, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellDu\x00" as
                                   *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_arg);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_tree);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node2 += 1
                }
                n_tree += 1
            }
            n_arg += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlShellList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlShellCtxtPtr = 0 as *mut xmlShellCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut arg: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_arg: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_arg = 0 as std::os::raw::c_int;
        while n_arg < 1 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int;
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    arg = gen_char_ptr(n_arg, 1 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                    node2 = gen_xmlNodePtr(n_node2, 3 as std::os::raw::c_int);
                    ret_val = xmlShellList(ctxt, arg, node, node2);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlShellCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_char_ptr(n_arg, arg, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node2, node2, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellList\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_arg);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node2 += 1
                }
                n_node += 1
            }
            n_arg += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlShellLoad() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlShellCtxtPtr = 0 as *mut xmlShellCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 1 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int;
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    filename = gen_char_ptr(n_filename, 1 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                    node2 = gen_xmlNodePtr(n_node2, 3 as std::os::raw::c_int);
                    ret_val = xmlShellLoad(ctxt, filename, node, node2);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlShellCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_char_ptr(n_filename, filename, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node2, node2, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellLoad\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_filename);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node2 += 1
                }
                n_node += 1
            }
            n_filename += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlShellPrintXPathResult() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut list: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_list: std::os::raw::c_int = 0;
    n_list = 0 as std::os::raw::c_int;
    while n_list < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        list = gen_xmlXPathObjectPtr(n_list, 0 as std::os::raw::c_int);
        xmlShellPrintXPathResult(list);
        call_tests += 1;
        des_xmlXPathObjectPtr(n_list, list, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlShellPrintXPathResult\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_list);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_list += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlShellPwd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlShellCtxtPtr = 0 as *mut xmlShellCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 1 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int;
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    buffer = gen_char_ptr(n_buffer, 1 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                    node2 = gen_xmlNodePtr(n_node2, 3 as std::os::raw::c_int);
                    ret_val = xmlShellPwd(ctxt, buffer, node, node2);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlShellCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_char_ptr(n_buffer, buffer, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node2, node2, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellPwd\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buffer);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node2 += 1
                }
                n_node += 1
            }
            n_buffer += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlShellSave() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlShellCtxtPtr = 0 as *mut xmlShellCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 1 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int;
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    filename = gen_char_ptr(n_filename, 1 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                    node2 = gen_xmlNodePtr(n_node2, 3 as std::os::raw::c_int);
                    ret_val = xmlShellSave(ctxt, filename, node, node2);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlShellCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_char_ptr(n_filename, filename, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node2, node2, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellSave\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_filename);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node2 += 1
                }
                n_node += 1
            }
            n_filename += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlShellValidate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlShellCtxtPtr = 0 as *mut xmlShellCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut dtd: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_dtd: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_dtd = 0 as std::os::raw::c_int;
        while n_dtd < 1 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int;
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    dtd = gen_char_ptr(n_dtd, 1 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                    node2 = gen_xmlNodePtr(n_node2, 3 as std::os::raw::c_int);
                    ret_val = xmlShellValidate(ctxt, dtd, node, node2);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlShellCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_char_ptr(n_dtd, dtd, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node2, node2, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellValidate\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_dtd);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node2 += 1
                }
                n_node += 1
            }
            n_dtd += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlShellWrite() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlShellCtxtPtr = 0 as *mut xmlShellCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 1 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_node2 = 0 as std::os::raw::c_int;
                while n_node2 < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    filename = gen_char_ptr(n_filename, 1 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                    node2 = gen_xmlNodePtr(n_node2, 3 as std::os::raw::c_int);
                    ret_val = xmlShellWrite(ctxt, filename, node, node2);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlShellCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_char_ptr(n_filename, filename, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node2, node2, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlShellWrite\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_filename);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node2);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node2 += 1
                }
                n_node += 1
            }
            n_filename += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_debugXML() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing debugXML : 25 of 28 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlBoolToText();
    test_ret += test_xmlDebugCheckDocument();
    test_ret += test_xmlDebugDumpAttr();
    test_ret += test_xmlDebugDumpAttrList();
    test_ret += test_xmlDebugDumpDTD();
    test_ret += test_xmlDebugDumpDocument();
    test_ret += test_xmlDebugDumpDocumentHead();
    test_ret += test_xmlDebugDumpEntities();
    test_ret += test_xmlDebugDumpNode();
    test_ret += test_xmlDebugDumpNodeList();
    test_ret += test_xmlDebugDumpOneNode();
    test_ret += test_xmlDebugDumpString();
    test_ret += test_xmlLsCountNode();
    test_ret += test_xmlLsOneNode();
    test_ret += test_xmlShell();
    test_ret += test_xmlShellBase();
    test_ret += test_xmlShellCat();
    test_ret += test_xmlShellDir();
    test_ret += test_xmlShellDu();
    test_ret += test_xmlShellList();
    test_ret += test_xmlShellLoad();
    test_ret += test_xmlShellPrintXPathResult();
    test_ret += test_xmlShellPwd();
    test_ret += test_xmlShellSave();
    test_ret += test_xmlShellValidate();
    test_ret += test_xmlShellWrite();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module debugXML: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlDictCleanup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlDictCleanup();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlDictCleanup\x00" as *const u8
                   as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDictCreate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDictPtr = 0 as *mut xmlDict;
    mem_base = xmlMemBlocks();
    ret_val = xmlDictCreate();
    desret_xmlDictPtr(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlDictCreate\x00" as *const u8 as
                   *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDictCreateSub() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDictPtr = 0 as *mut xmlDict;
    let mut sub: xmlDictPtr = 0 as *mut xmlDict;
    let mut n_sub: std::os::raw::c_int = 0;
    n_sub = 0 as std::os::raw::c_int;
    while n_sub < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        sub = gen_xmlDictPtr(n_sub, 0 as std::os::raw::c_int);
        ret_val = xmlDictCreateSub(sub);
        desret_xmlDictPtr(ret_val);
        call_tests += 1;
        des_xmlDictPtr(n_sub, sub, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlDictCreateSub\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_sub);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_sub += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDictExists() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut dict: xmlDictPtr = 0 as *mut xmlDict;
    let mut n_dict: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_dict = 0 as std::os::raw::c_int;
    while n_dict < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                dict = gen_xmlDictPtr(n_dict, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!name.is_null() &&
                         len >
                             strlen(name as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlDictExists(dict, name as *const xmlChar, len);
                    desret_const_xmlChar_ptr(ret_val);
                    call_tests += 1;
                    des_xmlDictPtr(n_dict, dict, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlDictExists\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_dict);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_name += 1
        }
        n_dict += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDictGetUsage() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the dictionary */
}
unsafe extern "C" fn test_xmlDictLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the name of the userdata */
    let mut mem_base: std::os::raw::c_int =
        0; /* the length of the name, if -1 it is recomputed */
    let mut ret_val: *const xmlChar =
        0 as *const xmlChar; /* the dictionary */
    let mut dict: xmlDictPtr = 0 as *mut xmlDict; /* the string */
    let mut n_dict: std::os::raw::c_int = 0; /* the dictionary */
    let mut name: *mut xmlChar = 0 as *mut xmlChar; /* the prefix */
    let mut n_name: std::os::raw::c_int = 0; /* the name */
    let mut len: std::os::raw::c_int = 0; /* the dictionary */
    let mut n_len: std::os::raw::c_int = 0;
    n_dict = 0 as std::os::raw::c_int;
    while n_dict < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                dict = gen_xmlDictPtr(n_dict, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!name.is_null() &&
                         len >
                             strlen(name as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlDictLookup(dict, name as *const xmlChar, len);
                    desret_const_xmlChar_ptr(ret_val);
                    call_tests += 1;
                    des_xmlDictPtr(n_dict, dict, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlDictLookup\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_dict);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_name += 1
        }
        n_dict += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDictOwns() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut dict: xmlDictPtr = 0 as *mut xmlDict;
    let mut n_dict: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    n_dict = 0 as std::os::raw::c_int;
    while n_dict < 2 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            dict = gen_xmlDictPtr(n_dict, 0 as std::os::raw::c_int);
            str = gen_const_xmlChar_ptr(n_str, 1 as std::os::raw::c_int);
            ret_val = xmlDictOwns(dict, str as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlDictPtr(n_dict, dict, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDictOwns\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_dict);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str += 1
        }
        n_dict += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDictQLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut dict: xmlDictPtr = 0 as *mut xmlDict;
    let mut n_dict: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_dict = 0 as std::os::raw::c_int;
    while n_dict < 2 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                dict = gen_xmlDictPtr(n_dict, 0 as std::os::raw::c_int);
                prefix = gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                ret_val =
                    xmlDictQLookup(dict, prefix as *const xmlChar,
                                   name as *const xmlChar);
                desret_const_xmlChar_ptr(ret_val);
                call_tests += 1;
                des_xmlDictPtr(n_dict, dict, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDictQLookup\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_dict);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_prefix);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_name += 1
            }
            n_prefix += 1
        }
        n_dict += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDictReference() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut dict: xmlDictPtr = 0 as *mut xmlDict;
    let mut n_dict: std::os::raw::c_int = 0;
    n_dict = 0 as std::os::raw::c_int;
    while n_dict < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0 as std::os::raw::c_int);
        ret_val = xmlDictReference(dict);
        xmlDictFree(dict);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlDictPtr(n_dict, dict, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlDictReference\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_dict);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_dict += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDictSetLimit() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the dictionary */
}
unsafe extern "C" fn test_xmlDictSize() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* a pointer to an array of bytes to store the result */
    let mut mem_base: std::os::raw::c_int = 0; /* the length of @out */
    let mut ret_val: std::os::raw::c_int =
        0; /* a pointer to an array of UTF-8 chars */
    let mut dict: xmlDictPtr = 0 as *mut xmlDict; /* the length of @in */
    let mut n_dict: std::os::raw::c_int =
        0; /* a pointer to an array of bytes to store the result */
    n_dict = 0 as std::os::raw::c_int; /* the length of @out */
    while n_dict < 2 as std::os::raw::c_int {
        mem_base =
            xmlMemBlocks(); /* a pointer to an array of ISO Latin 1 chars */
        dict =
            gen_xmlDictPtr(n_dict, 0 as std::os::raw::c_int); /* the length of @in */
        ret_val =
            xmlDictSize(dict); /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
        desret_int(ret_val); /* the alias name as parsed, in UTF-8 format (ASCII actually) */
        call_tests += 1; /* char enconding transformation data structure */
        des_xmlDictPtr(n_dict, dict,
                       0 as
                           std::os::raw::c_int); /* char enconding transformation data structure */
        xmlResetLastError(); /* an xmlBuffer for the output. */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlDictSize\x00" as *const u8
                       as *const std::os::raw::c_char,
                   xmlMemBlocks() -
                       mem_base); /* an xmlBuffer for the input */
            test_ret += 1; /* char encoding transformation data structure */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_dict); /* an xmlBuffer for the output. */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* an xmlBuffer for the input */
        } /* char enconding transformation data structure */
        n_dict += 1
    } /* an xmlBuffer for the output. */
    function_tests += 1; /* an xmlBuffer for the input */
    return test_ret; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
}
unsafe extern "C" fn test_xmlInitializeDict() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* a pointer to the first bytes of the XML entity, must be at least 2 bytes long (at least 4 if encoding is UTF4 variant). */
    let mut mem_base: std::os::raw::c_int =
        0; /* pointer to the length of the buffer */
    let mut ret_val: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    ret_val = xmlInitializeDict();
    desret_int(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlInitializeDict\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_dict() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing dict : 10 of 13 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char);
    }
    test_ret += test_xmlDictCleanup();
    test_ret += test_xmlDictCreate();
    test_ret += test_xmlDictCreateSub();
    test_ret += test_xmlDictExists();
    test_ret += test_xmlDictGetUsage();
    test_ret += test_xmlDictLookup();
    test_ret += test_xmlDictOwns();
    test_ret += test_xmlDictQLookup();
    test_ret += test_xmlDictReference();
    test_ret += test_xmlDictSetLimit();
    test_ret += test_xmlDictSize();
    test_ret += test_xmlInitializeDict();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module dict: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_UTF8Toisolat1() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut out: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    let mut n_out: std::os::raw::c_int = 0;
    let mut outlen: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_outlen: std::os::raw::c_int = 0;
    let mut in_0: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    let mut n_in: std::os::raw::c_int = 0;
    let mut inlen: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_inlen: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 1 as std::os::raw::c_int {
        n_outlen = 0 as std::os::raw::c_int;
        while n_outlen < 2 as std::os::raw::c_int {
            n_in = 0 as std::os::raw::c_int;
            while n_in < 1 as std::os::raw::c_int {
                n_inlen = 0 as std::os::raw::c_int;
                while n_inlen < 2 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    out = gen_unsigned_char_ptr(n_out, 0 as std::os::raw::c_int);
                    outlen = gen_int_ptr(n_outlen, 1 as std::os::raw::c_int);
                    in_0 =
                        gen_const_unsigned_char_ptr(n_in, 2 as std::os::raw::c_int);
                    inlen = gen_int_ptr(n_inlen, 3 as std::os::raw::c_int);
                    ret_val =
                        UTF8Toisolat1(out, outlen,
                                      in_0 as *const std::os::raw::c_uchar, inlen);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_unsigned_char_ptr(n_out, out, 0 as std::os::raw::c_int);
                    des_int_ptr(n_outlen, outlen, 1 as std::os::raw::c_int);
                    des_const_unsigned_char_ptr(n_in,
                                                in_0 as *const std::os::raw::c_uchar,
                                                2 as std::os::raw::c_int);
                    des_int_ptr(n_inlen, inlen, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in UTF8Toisolat1\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_out);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_outlen);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_in);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_inlen);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_inlen += 1
                }
                n_in += 1
            }
            n_outlen += 1
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_isolat1ToUTF8() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut out: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    let mut n_out: std::os::raw::c_int = 0;
    let mut outlen: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_outlen: std::os::raw::c_int = 0;
    let mut in_0: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    let mut n_in: std::os::raw::c_int = 0;
    let mut inlen: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_inlen: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 1 as std::os::raw::c_int {
        n_outlen = 0 as std::os::raw::c_int;
        while n_outlen < 2 as std::os::raw::c_int {
            n_in = 0 as std::os::raw::c_int;
            while n_in < 1 as std::os::raw::c_int {
                n_inlen = 0 as std::os::raw::c_int;
                while n_inlen < 2 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    out = gen_unsigned_char_ptr(n_out, 0 as std::os::raw::c_int);
                    outlen = gen_int_ptr(n_outlen, 1 as std::os::raw::c_int);
                    in_0 =
                        gen_const_unsigned_char_ptr(n_in, 2 as std::os::raw::c_int);
                    inlen = gen_int_ptr(n_inlen, 3 as std::os::raw::c_int);
                    ret_val =
                        isolat1ToUTF8(out, outlen,
                                      in_0 as *const std::os::raw::c_uchar, inlen);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_unsigned_char_ptr(n_out, out, 0 as std::os::raw::c_int);
                    des_int_ptr(n_outlen, outlen, 1 as std::os::raw::c_int);
                    des_const_unsigned_char_ptr(n_in,
                                                in_0 as *const std::os::raw::c_uchar,
                                                2 as std::os::raw::c_int);
                    des_int_ptr(n_inlen, inlen, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in isolat1ToUTF8\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_out);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_outlen);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_in);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_inlen);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_inlen += 1
                }
                n_in += 1
            }
            n_outlen += 1
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAddEncodingAlias() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut name: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_name: std::os::raw::c_int = 0;
    let mut alias: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_alias: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 4 as std::os::raw::c_int {
        n_alias = 0 as std::os::raw::c_int;
        while n_alias < 4 as std::os::raw::c_int {
            name = gen_const_char_ptr(n_name, 0 as std::os::raw::c_int);
            alias = gen_const_char_ptr(n_alias, 1 as std::os::raw::c_int);
            ret_val =
                xmlAddEncodingAlias(name as *const std::os::raw::c_char,
                                    alias as *const std::os::raw::c_char);
            desret_int(ret_val);
            call_tests += 1;
            des_const_char_ptr(n_name, name as *const std::os::raw::c_char,
                               0 as std::os::raw::c_int);
            des_const_char_ptr(n_alias, alias as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            n_alias += 1
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlCharEncodingHandler_ptr(mut no: std::os::raw::c_int,
                                                    mut nr: std::os::raw::c_int)
 -> *mut xmlCharEncodingHandler {
    return 0 as *mut xmlCharEncodingHandler;
}
unsafe extern "C" fn des_xmlCharEncodingHandler_ptr(mut no: std::os::raw::c_int,
                                                    mut val:
                                                        *mut xmlCharEncodingHandler,
                                                    mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlCharEncCloseFunc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut handler: *mut xmlCharEncodingHandler =
        0 as *mut xmlCharEncodingHandler;
    let mut n_handler: std::os::raw::c_int = 0;
    n_handler = 0 as std::os::raw::c_int;
    while n_handler < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0 as std::os::raw::c_int);
        ret_val = xmlCharEncCloseFunc(handler);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCharEncCloseFunc\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_handler);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_handler += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCharEncFirstLine() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut handler: *mut xmlCharEncodingHandler =
        0 as *mut xmlCharEncodingHandler;
    let mut n_handler: std::os::raw::c_int = 0;
    let mut out: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_out: std::os::raw::c_int = 0;
    let mut in_0: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_in: std::os::raw::c_int = 0;
    n_handler = 0 as std::os::raw::c_int;
    while n_handler < 1 as std::os::raw::c_int {
        n_out = 0 as std::os::raw::c_int;
        while n_out < 3 as std::os::raw::c_int {
            n_in = 0 as std::os::raw::c_int;
            while n_in < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                handler =
                    gen_xmlCharEncodingHandler_ptr(n_handler,
                                                   0 as std::os::raw::c_int);
                out = gen_xmlBufferPtr(n_out, 1 as std::os::raw::c_int);
                in_0 = gen_xmlBufferPtr(n_in, 2 as std::os::raw::c_int);
                ret_val = xmlCharEncFirstLine(handler, out, in_0);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlCharEncodingHandler_ptr(n_handler, handler,
                                               0 as std::os::raw::c_int);
                des_xmlBufferPtr(n_out, out, 1 as std::os::raw::c_int);
                des_xmlBufferPtr(n_in, in_0, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlCharEncFirstLine\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_handler);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_out);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_in);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_in += 1
            }
            n_out += 1
        }
        n_handler += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCharEncInFunc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut handler: *mut xmlCharEncodingHandler =
        0 as *mut xmlCharEncodingHandler;
    let mut n_handler: std::os::raw::c_int = 0;
    let mut out: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_out: std::os::raw::c_int = 0;
    let mut in_0: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_in: std::os::raw::c_int = 0;
    n_handler = 0 as std::os::raw::c_int;
    while n_handler < 1 as std::os::raw::c_int {
        n_out = 0 as std::os::raw::c_int;
        while n_out < 3 as std::os::raw::c_int {
            n_in = 0 as std::os::raw::c_int;
            while n_in < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                handler =
                    gen_xmlCharEncodingHandler_ptr(n_handler,
                                                   0 as std::os::raw::c_int);
                out = gen_xmlBufferPtr(n_out, 1 as std::os::raw::c_int);
                in_0 = gen_xmlBufferPtr(n_in, 2 as std::os::raw::c_int);
                ret_val = xmlCharEncInFunc(handler, out, in_0);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlCharEncodingHandler_ptr(n_handler, handler,
                                               0 as std::os::raw::c_int);
                des_xmlBufferPtr(n_out, out, 1 as std::os::raw::c_int);
                des_xmlBufferPtr(n_in, in_0, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlCharEncInFunc\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_handler);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_out);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_in);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_in += 1
            }
            n_out += 1
        }
        n_handler += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCharEncOutFunc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut handler: *mut xmlCharEncodingHandler =
        0 as *mut xmlCharEncodingHandler;
    let mut n_handler: std::os::raw::c_int = 0;
    let mut out: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_out: std::os::raw::c_int = 0;
    let mut in_0: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_in: std::os::raw::c_int = 0;
    n_handler = 0 as std::os::raw::c_int;
    while n_handler < 1 as std::os::raw::c_int {
        n_out = 0 as std::os::raw::c_int;
        while n_out < 3 as std::os::raw::c_int {
            n_in = 0 as std::os::raw::c_int;
            while n_in < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                handler =
                    gen_xmlCharEncodingHandler_ptr(n_handler,
                                                   0 as std::os::raw::c_int);
                out = gen_xmlBufferPtr(n_out, 1 as std::os::raw::c_int);
                in_0 = gen_xmlBufferPtr(n_in, 2 as std::os::raw::c_int);
                ret_val = xmlCharEncOutFunc(handler, out, in_0);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlCharEncodingHandler_ptr(n_handler, handler,
                                               0 as std::os::raw::c_int);
                des_xmlBufferPtr(n_out, out, 1 as std::os::raw::c_int);
                des_xmlBufferPtr(n_in, in_0, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlCharEncOutFunc\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_handler);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_out);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_in);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_in += 1
            }
            n_out += 1
        }
        n_handler += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCleanupCharEncodingHandlers() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    xmlCleanupCharEncodingHandlers();
    call_tests += 1;
    xmlResetLastError();
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCleanupEncodingAliases() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlCleanupEncodingAliases();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlCleanupEncodingAliases\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDelEncodingAlias() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut alias: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_alias: std::os::raw::c_int = 0;
    n_alias = 0 as std::os::raw::c_int;
    while n_alias < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias, 0 as std::os::raw::c_int);
        ret_val = xmlDelEncodingAlias(alias as *const std::os::raw::c_char);
        desret_int(ret_val);
        call_tests += 1;
        des_const_char_ptr(n_alias, alias as *const std::os::raw::c_char,
                           0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlDelEncodingAlias\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_alias);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_alias += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDetectCharEncoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut in_0: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    let mut n_in: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_in = 0 as std::os::raw::c_int;
    while n_in < 1 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            in_0 = gen_const_unsigned_char_ptr(n_in, 0 as std::os::raw::c_int);
            len = gen_int(n_len, 1 as std::os::raw::c_int);
            ret_val =
                xmlDetectCharEncoding(in_0 as *const std::os::raw::c_uchar, len);
            desret_xmlCharEncoding(ret_val);
            call_tests += 1;
            des_const_unsigned_char_ptr(n_in, in_0 as *const std::os::raw::c_uchar,
                                        0 as std::os::raw::c_int);
            des_int(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDetectCharEncoding\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_in);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_in += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlFindCharEncodingHandler() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlGetCharEncodingHandler() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the encoding */
}
unsafe extern "C" fn test_xmlGetCharEncodingName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut n_enc: std::os::raw::c_int = 0;
    n_enc = 0 as std::os::raw::c_int;
    while n_enc < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        enc = gen_xmlCharEncoding(n_enc, 0 as std::os::raw::c_int);
        ret_val = xmlGetCharEncodingName(enc);
        desret_const_char_ptr(ret_val);
        call_tests += 1;
        des_xmlCharEncoding(n_enc, enc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlGetCharEncodingName\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_enc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_enc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetEncodingAlias() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut alias: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_alias: std::os::raw::c_int = 0;
    n_alias = 0 as std::os::raw::c_int;
    while n_alias < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias, 0 as std::os::raw::c_int);
        ret_val = xmlGetEncodingAlias(alias as *const std::os::raw::c_char);
        desret_const_char_ptr(ret_val);
        call_tests += 1;
        des_const_char_ptr(n_alias, alias as *const std::os::raw::c_char,
                           0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlGetEncodingAlias\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_alias);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_alias += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlInitCharEncodingHandlers() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    xmlInitCharEncodingHandlers();
    call_tests += 1;
    xmlResetLastError();
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewCharEncodingHandler() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
}
unsafe extern "C" fn test_xmlParseCharEncoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlCharEncodingHandlerPtr handler block */
    let mut mem_base: std::os::raw::c_int = 0; /* the document */
    let mut ret_val: xmlCharEncoding =
        XML_CHAR_ENCODING_NONE; /* the entity name */
    let mut name: *mut std::os::raw::c_char =
        0 as *mut std::os::raw::c_char; /* the entity type XML_xxx_yyy_ENTITY */
    let mut n_name: std::os::raw::c_int = 0; /* the entity external ID if available */
    n_name = 0 as std::os::raw::c_int; /* the entity system ID if available */
    while n_name < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the entity content */
        name =
            gen_const_char_ptr(n_name, 0 as std::os::raw::c_int); /* the document */
        ret_val =
            xmlParseCharEncoding(name as
                                     *const std::os::raw::c_char); /* the entity name */
        desret_xmlCharEncoding(ret_val); /* the entity type XML_xxx_yyy_ENTITY */
        call_tests += 1; /* the entity external ID if available */
        des_const_char_ptr(n_name, name as *const std::os::raw::c_char,
                           0 as
                               std::os::raw::c_int); /* the entity system ID if available */
        xmlResetLastError(); /* the entity content */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParseCharEncoding\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_name);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlCharEncodingHandlerPtr(mut no: std::os::raw::c_int,
                                                   mut nr: std::os::raw::c_int)
 -> xmlCharEncodingHandlerPtr {
    return 0 as xmlCharEncodingHandlerPtr;
}
unsafe extern "C" fn des_xmlCharEncodingHandlerPtr(mut no: std::os::raw::c_int,
                                                   mut val:
                                                       xmlCharEncodingHandlerPtr,
                                                   mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlRegisterCharEncodingHandler() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut handler: xmlCharEncodingHandlerPtr =
        0 as *mut xmlCharEncodingHandler;
    let mut n_handler: std::os::raw::c_int = 0;
    n_handler = 0 as std::os::raw::c_int;
    while n_handler < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 0 as std::os::raw::c_int);
        xmlRegisterCharEncodingHandler(handler);
        call_tests += 1;
        des_xmlCharEncodingHandlerPtr(n_handler, handler, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlRegisterCharEncodingHandler\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_handler);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_handler += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_encoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing encoding : 16 of 19 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_UTF8Toisolat1();
    test_ret += test_isolat1ToUTF8();
    test_ret += test_xmlAddEncodingAlias();
    test_ret += test_xmlCharEncCloseFunc();
    test_ret += test_xmlCharEncFirstLine();
    test_ret += test_xmlCharEncInFunc();
    test_ret += test_xmlCharEncOutFunc();
    test_ret += test_xmlCleanupCharEncodingHandlers();
    test_ret += test_xmlCleanupEncodingAliases();
    test_ret += test_xmlDelEncodingAlias();
    test_ret += test_xmlDetectCharEncoding();
    test_ret += test_xmlFindCharEncodingHandler();
    test_ret += test_xmlGetCharEncodingHandler();
    test_ret += test_xmlGetCharEncodingName();
    test_ret += test_xmlGetEncodingAlias();
    test_ret += test_xmlInitCharEncodingHandlers();
    test_ret += test_xmlNewCharEncodingHandler();
    test_ret += test_xmlParseCharEncoding();
    test_ret += test_xmlRegisterCharEncodingHandler();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module encoding: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlAddDocEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut type_0: std::os::raw::c_int = 0;
    let mut n_type: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_SystemID: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_type = 0 as std::os::raw::c_int;
            while n_type < 4 as std::os::raw::c_int {
                n_ExternalID = 0 as std::os::raw::c_int;
                while n_ExternalID < 5 as std::os::raw::c_int {
                    n_SystemID = 0 as std::os::raw::c_int;
                    while n_SystemID < 5 as std::os::raw::c_int {
                        n_content = 0 as std::os::raw::c_int;
                        while n_content < 5 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                            name =
                                gen_const_xmlChar_ptr(n_name,
                                                      1 as std::os::raw::c_int);
                            type_0 = gen_int(n_type, 2 as std::os::raw::c_int);
                            ExternalID =
                                gen_const_xmlChar_ptr(n_ExternalID,
                                                      3 as std::os::raw::c_int);
                            SystemID =
                                gen_const_xmlChar_ptr(n_SystemID,
                                                      4 as std::os::raw::c_int);
                            content =
                                gen_const_xmlChar_ptr(n_content,
                                                      5 as std::os::raw::c_int);
                            ret_val =
                                xmlAddDocEntity(doc, name as *const xmlChar,
                                                type_0,
                                                ExternalID as *const xmlChar,
                                                SystemID as *const xmlChar,
                                                content as *const xmlChar);
                            desret_xmlEntityPtr(ret_val);
                            call_tests += 1;
                            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_name,
                                                  name as *const xmlChar,
                                                  1 as std::os::raw::c_int);
                            des_int(n_type, type_0, 2 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_ExternalID,
                                                  ExternalID as
                                                      *const xmlChar,
                                                  3 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_SystemID,
                                                  SystemID as *const xmlChar,
                                                  4 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_content,
                                                  content as *const xmlChar,
                                                  5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlAddDocEntity\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_doc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_name);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_type);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ExternalID);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_SystemID);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_content);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_content += 1
                        }
                        n_SystemID += 1
                    }
                    n_ExternalID += 1
                }
                n_type += 1
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAddDtdEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut type_0: std::os::raw::c_int = 0;
    let mut n_type: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_SystemID: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_type = 0 as std::os::raw::c_int;
            while n_type < 4 as std::os::raw::c_int {
                n_ExternalID = 0 as std::os::raw::c_int;
                while n_ExternalID < 5 as std::os::raw::c_int {
                    n_SystemID = 0 as std::os::raw::c_int;
                    while n_SystemID < 5 as std::os::raw::c_int {
                        n_content = 0 as std::os::raw::c_int;
                        while n_content < 5 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                            name =
                                gen_const_xmlChar_ptr(n_name,
                                                      1 as std::os::raw::c_int);
                            type_0 = gen_int(n_type, 2 as std::os::raw::c_int);
                            ExternalID =
                                gen_const_xmlChar_ptr(n_ExternalID,
                                                      3 as std::os::raw::c_int);
                            SystemID =
                                gen_const_xmlChar_ptr(n_SystemID,
                                                      4 as std::os::raw::c_int);
                            content =
                                gen_const_xmlChar_ptr(n_content,
                                                      5 as std::os::raw::c_int);
                            ret_val =
                                xmlAddDtdEntity(doc, name as *const xmlChar,
                                                type_0,
                                                ExternalID as *const xmlChar,
                                                SystemID as *const xmlChar,
                                                content as *const xmlChar);
                            desret_xmlEntityPtr(ret_val);
                            call_tests += 1;
                            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_name,
                                                  name as *const xmlChar,
                                                  1 as std::os::raw::c_int);
                            des_int(n_type, type_0, 2 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_ExternalID,
                                                  ExternalID as
                                                      *const xmlChar,
                                                  3 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_SystemID,
                                                  SystemID as *const xmlChar,
                                                  4 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_content,
                                                  content as *const xmlChar,
                                                  5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlAddDtdEntity\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_doc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_name);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_type);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ExternalID);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_SystemID);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_content);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_content += 1
                        }
                        n_SystemID += 1
                    }
                    n_ExternalID += 1
                }
                n_type += 1
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCleanupPredefinedEntities() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlCleanupPredefinedEntities();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlCleanupPredefinedEntities\x00"
                   as *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlEntitiesTablePtr(mut no: std::os::raw::c_int,
                                             mut nr: std::os::raw::c_int)
 -> xmlEntitiesTablePtr {
    return 0 as xmlEntitiesTablePtr;
}
unsafe extern "C" fn des_xmlEntitiesTablePtr(mut no: std::os::raw::c_int,
                                             mut val: xmlEntitiesTablePtr,
                                             mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlCopyEntitiesTable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlCreateEntitiesTable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* An XML buffer. */
}
unsafe extern "C" fn test_xmlDumpEntitiesTable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* An entity table */
    let mut mem_base: std::os::raw::c_int = 0; /* An XML buffer. */
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer; /* An entity table */
    let mut n_buf: std::os::raw::c_int = 0; /* the document containing the string */
    let mut table: xmlEntitiesTablePtr =
        0 as *mut xmlEntitiesTable; /* A string to convert to XML. */
    let mut n_table: std::os::raw::c_int = 0; /* the document containing the string */
    n_buf = 0 as std::os::raw::c_int; /* A string to convert to XML. */
    while n_buf < 3 as std::os::raw::c_int {
        n_table = 0 as std::os::raw::c_int; /* the document referencing the entity */
        while n_table < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the entity name */
            buf =
                gen_xmlBufferPtr(n_buf,
                                 0 as
                                     std::os::raw::c_int); /* the document referencing the entity */
            table =
                gen_xmlEntitiesTablePtr(n_table,
                                        1 as
                                            std::os::raw::c_int); /* the entity name */
            xmlDumpEntitiesTable(buf,
                                 table); /* the document referencing the entity */
            call_tests += 1; /* the entity name */
            des_xmlBufferPtr(n_buf, buf,
                             0 as std::os::raw::c_int); /* the entity name */
            des_xmlEntitiesTablePtr(n_table, table,
                                    1 as std::os::raw::c_int); /* the document */
            xmlResetLastError(); /* the entity name */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDumpEntitiesTable\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the entity type XML_xxx_yyy_ENTITY */
                test_ret += 1; /* the entity external ID if available */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_buf); /* the entity system ID if available */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_table); /* the entity content */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the hash table */
            } /* the name of the userdata */
            n_table += 1
        } /* a pointer to the userdata */
        n_buf += 1
    } /* the hash table */
    function_tests += 1; /* the name of the userdata */
    return test_ret; /* a second name of the userdata */
}
unsafe extern "C" fn gen_xmlEntityPtr(mut no: std::os::raw::c_int,
                                      mut nr: std::os::raw::c_int) -> xmlEntityPtr {
    return 0 as xmlEntityPtr; /* a pointer to the userdata */
}
unsafe extern "C" fn des_xmlEntityPtr(mut no: std::os::raw::c_int,
                                      mut val: xmlEntityPtr,
                                      mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlDumpEntityDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the hash table */
    let mut mem_base: std::os::raw::c_int = 0; /* the name of the userdata */
    let mut buf: xmlBufferPtr =
        0 as *mut xmlBuffer; /* a second name of the userdata */
    let mut n_buf: std::os::raw::c_int = 0; /* a third name of the userdata */
    let mut ent: xmlEntityPtr =
        0 as *mut xmlEntity; /* a pointer to the userdata */
    let mut n_ent: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_ent = 0 as std::os::raw::c_int;
        while n_ent < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            ent = gen_xmlEntityPtr(n_ent, 1 as std::os::raw::c_int);
            xmlDumpEntityDecl(buf, ent);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_xmlEntityPtr(n_ent, ent, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDumpEntityDecl\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ent);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ent += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlEncodeEntitiesReentrant() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut input: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_input: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_input = 0 as std::os::raw::c_int;
        while n_input < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            input = gen_const_xmlChar_ptr(n_input, 1 as std::os::raw::c_int);
            ret_val =
                xmlEncodeEntitiesReentrant(doc, input as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_input, input as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlEncodeEntitiesReentrant\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_input);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_input += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_const_xmlDoc_ptr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> *mut xmlDoc {
    return 0 as *mut xmlDoc;
}
unsafe extern "C" fn des_const_xmlDoc_ptr(mut no: std::os::raw::c_int,
                                          mut val: *const xmlDoc,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlEncodeSpecialChars() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut input: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_input: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        n_input = 0 as std::os::raw::c_int;
        while n_input < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
            input = gen_const_xmlChar_ptr(n_input, 1 as std::os::raw::c_int);
            ret_val =
                xmlEncodeSpecialChars(doc as *const xmlDoc,
                                      input as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc,
                                 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_input, input as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlEncodeSpecialChars\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_input);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_input += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetDocEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val =
                xmlGetDocEntity(doc as *const xmlDoc, name as *const xmlChar);
            desret_xmlEntityPtr(ret_val);
            call_tests += 1;
            des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc,
                                 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlGetDocEntity\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetDtdEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlGetDtdEntity(doc, name as *const xmlChar);
            desret_xmlEntityPtr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlGetDtdEntity\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetParameterEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlGetParameterEntity(doc, name as *const xmlChar);
            desret_xmlEntityPtr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlGetParameterEntity\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetPredefinedEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
        ret_val = xmlGetPredefinedEntity(name as *const xmlChar);
        desret_xmlEntityPtr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlGetPredefinedEntity\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_name);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlInitializePredefinedEntities() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlInitializePredefinedEntities();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlInitializePredefinedEntities\x00"
                   as *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut type_0: std::os::raw::c_int = 0;
    let mut n_type: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_SystemID: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_type = 0 as std::os::raw::c_int;
            while n_type < 4 as std::os::raw::c_int {
                n_ExternalID = 0 as std::os::raw::c_int;
                while n_ExternalID < 5 as std::os::raw::c_int {
                    n_SystemID = 0 as std::os::raw::c_int;
                    while n_SystemID < 5 as std::os::raw::c_int {
                        n_content = 0 as std::os::raw::c_int;
                        while n_content < 5 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                            name =
                                gen_const_xmlChar_ptr(n_name,
                                                      1 as std::os::raw::c_int);
                            type_0 = gen_int(n_type, 2 as std::os::raw::c_int);
                            ExternalID =
                                gen_const_xmlChar_ptr(n_ExternalID,
                                                      3 as std::os::raw::c_int);
                            SystemID =
                                gen_const_xmlChar_ptr(n_SystemID,
                                                      4 as std::os::raw::c_int);
                            content =
                                gen_const_xmlChar_ptr(n_content,
                                                      5 as std::os::raw::c_int);
                            ret_val =
                                xmlNewEntity(doc, name as *const xmlChar,
                                             type_0,
                                             ExternalID as *const xmlChar,
                                             SystemID as *const xmlChar,
                                             content as *const xmlChar);
                            desret_xmlEntityPtr(ret_val);
                            call_tests += 1;
                            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_name,
                                                  name as *const xmlChar,
                                                  1 as std::os::raw::c_int);
                            des_int(n_type, type_0, 2 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_ExternalID,
                                                  ExternalID as
                                                      *const xmlChar,
                                                  3 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_SystemID,
                                                  SystemID as *const xmlChar,
                                                  4 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_content,
                                                  content as *const xmlChar,
                                                  5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlNewEntity\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_doc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_name);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_type);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ExternalID);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_SystemID);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_content);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_content += 1
                        }
                        n_SystemID += 1
                    }
                    n_ExternalID += 1
                }
                n_type += 1
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_entities() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing entities : 13 of 17 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlAddDocEntity();
    test_ret += test_xmlAddDtdEntity();
    test_ret += test_xmlCleanupPredefinedEntities();
    test_ret += test_xmlCopyEntitiesTable();
    test_ret += test_xmlCreateEntitiesTable();
    test_ret += test_xmlDumpEntitiesTable();
    test_ret += test_xmlDumpEntityDecl();
    test_ret += test_xmlEncodeEntitiesReentrant();
    test_ret += test_xmlEncodeSpecialChars();
    test_ret += test_xmlGetDocEntity();
    test_ret += test_xmlGetDtdEntity();
    test_ret += test_xmlGetParameterEntity();
    test_ret += test_xmlGetPredefinedEntity();
    test_ret += test_xmlInitializePredefinedEntities();
    test_ret += test_xmlNewEntity();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module entities: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlHashAddEntry() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut userdata: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_userdata: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_userdata = 0 as std::os::raw::c_int;
            while n_userdata < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                table = gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                userdata = gen_userdata(n_userdata, 2 as std::os::raw::c_int);
                ret_val =
                    xmlHashAddEntry(table, name as *const xmlChar, userdata);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_userdata(n_userdata, userdata, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlHashAddEntry\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_table);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_userdata);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_userdata += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashAddEntry2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    let mut userdata: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_userdata: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_name2 = 0 as std::os::raw::c_int;
            while n_name2 < 5 as std::os::raw::c_int {
                n_userdata = 0 as std::os::raw::c_int;
                while n_userdata < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    table = gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    name2 = gen_const_xmlChar_ptr(n_name2, 2 as std::os::raw::c_int);
                    userdata = gen_userdata(n_userdata, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlHashAddEntry2(table, name as *const xmlChar,
                                         name2 as *const xmlChar, userdata);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name2, name2 as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_userdata(n_userdata, userdata, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlHashAddEntry2\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_table);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name2);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_userdata);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_userdata += 1
                }
                n_name2 += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashAddEntry3() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    let mut name3: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name3: std::os::raw::c_int = 0;
    let mut userdata: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_userdata: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_name2 = 0 as std::os::raw::c_int;
            while n_name2 < 5 as std::os::raw::c_int {
                n_name3 = 0 as std::os::raw::c_int;
                while n_name3 < 5 as std::os::raw::c_int {
                    n_userdata = 0 as std::os::raw::c_int;
                    while n_userdata < 3 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        table =
                            gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                        name2 =
                            gen_const_xmlChar_ptr(n_name2, 2 as std::os::raw::c_int);
                        name3 =
                            gen_const_xmlChar_ptr(n_name3, 3 as std::os::raw::c_int);
                        userdata = gen_userdata(n_userdata, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlHashAddEntry3(table, name as *const xmlChar,
                                             name2 as *const xmlChar,
                                             name3 as *const xmlChar,
                                             userdata);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name2,
                                              name2 as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name3,
                                              name3 as *const xmlChar,
                                              3 as std::os::raw::c_int);
                        des_userdata(n_userdata, userdata, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlHashAddEntry3\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_table);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name2);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name3);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_userdata);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_userdata += 1
                    }
                    n_name3 += 1
                }
                n_name2 += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashCopy() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlHashCreate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlHashCreateDict() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the hash table entry */
}
unsafe extern "C" fn test_xmlHashDefaultDeallocator() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the entry's name */
    let mut mem_base: std::os::raw::c_int = 0; /* the hash table */
    let mut entry: *mut std::os::raw::c_void =
        0 as *mut std::os::raw::c_void; /* the name of the userdata */
    let mut n_entry: std::os::raw::c_int = 0; /* the hash table */
    let mut name: *mut xmlChar =
        0 as *mut xmlChar; /* the name of the userdata */
    let mut n_name: std::os::raw::c_int = 0; /* a second name of the userdata */
    n_entry = 0 as std::os::raw::c_int; /* the hash table */
    while n_entry < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* the name of the userdata */
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* a second name of the userdata */
            entry =
                gen_void_ptr(n_entry,
                             0 as
                                 std::os::raw::c_int); /* a third name of the userdata */
            name =
                gen_const_xmlChar_ptr(n_name,
                                      1 as std::os::raw::c_int); /* the hash table */
            xmlHashDefaultDeallocator(entry,
                                      name as
                                          *const xmlChar); /* the prefix of the userdata */
            call_tests += 1; /* the name of the userdata */
            des_void_ptr(n_entry, entry,
                         0 as std::os::raw::c_int); /* the hash table */
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as
                                      std::os::raw::c_int); /* the prefix of the userdata */
            xmlResetLastError(); /* the name of the userdata */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlHashDefaultDeallocator\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the second prefix of the userdata */
                test_ret += 1; /* a second name of the userdata */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_entry); /* the hash table */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name); /* the prefix of the userdata */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the name of the userdata */
            } /* the second prefix of the userdata */
            n_name += 1
        } /* a second name of the userdata */
        n_entry += 1
    } /* the third prefix of the userdata */
    function_tests += 1; /* a third name of the userdata */
    return test_ret; /* the hash table */
}
unsafe extern "C" fn test_xmlHashLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the name of the userdata */
    let mut mem_base: std::os::raw::c_int =
        0; /* the deallocator function for removed item (if any) */
    let mut ret_val: *mut std::os::raw::c_void =
        0 as *mut std::os::raw::c_void; /* the hash table */
    let mut table: xmlHashTablePtr =
        0 as *mut xmlHashTable; /* the name of the userdata */
    let mut n_table: std::os::raw::c_int = 0; /* a second name of the userdata */
    let mut name: *mut xmlChar =
        0 as
            *mut xmlChar; /* the deallocator function for removed item (if any) */
    let mut n_name: std::os::raw::c_int = 0; /* the hash table */
    n_table = 0 as std::os::raw::c_int; /* the name of the userdata */
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* a second name of the userdata */
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* a third name of the userdata */
            table =
                gen_xmlHashTablePtr(n_table,
                                    0 as
                                        std::os::raw::c_int); /* the deallocator function for removed item (if any) */
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlHashLookup(table, name as *const xmlChar);
            desret_void_ptr(ret_val);
            call_tests += 1;
            des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlHashLookup\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_table);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashLookup2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_name2 = 0 as std::os::raw::c_int;
            while n_name2 < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                table = gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                name2 = gen_const_xmlChar_ptr(n_name2, 2 as std::os::raw::c_int);
                ret_val =
                    xmlHashLookup2(table, name as *const xmlChar,
                                   name2 as *const xmlChar);
                desret_void_ptr(ret_val);
                call_tests += 1;
                des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name2, name2 as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlHashLookup2\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_table);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name2);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_name2 += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashLookup3() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    let mut name3: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name3: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_name2 = 0 as std::os::raw::c_int;
            while n_name2 < 5 as std::os::raw::c_int {
                n_name3 = 0 as std::os::raw::c_int;
                while n_name3 < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    table = gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    name2 = gen_const_xmlChar_ptr(n_name2, 2 as std::os::raw::c_int);
                    name3 = gen_const_xmlChar_ptr(n_name3, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlHashLookup3(table, name as *const xmlChar,
                                       name2 as *const xmlChar,
                                       name3 as *const xmlChar);
                    desret_void_ptr(ret_val);
                    call_tests += 1;
                    des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name2, name2 as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name3, name3 as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlHashLookup3\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_table);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name2);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name3);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_name3 += 1
                }
                n_name2 += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashQLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                table = gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                prefix = gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                ret_val =
                    xmlHashQLookup(table, prefix as *const xmlChar,
                                   name as *const xmlChar);
                desret_void_ptr(ret_val);
                call_tests += 1;
                des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlHashQLookup\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_table);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_prefix);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_name += 1
            }
            n_prefix += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashQLookup2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut prefix2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix2: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_prefix2 = 0 as std::os::raw::c_int;
                while n_prefix2 < 5 as std::os::raw::c_int {
                    n_name2 = 0 as std::os::raw::c_int;
                    while n_name2 < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        table =
                            gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                        prefix =
                            gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                        prefix2 =
                            gen_const_xmlChar_ptr(n_prefix2,
                                                  3 as std::os::raw::c_int);
                        name2 =
                            gen_const_xmlChar_ptr(n_name2, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlHashQLookup2(table, prefix as *const xmlChar,
                                            name as *const xmlChar,
                                            prefix2 as *const xmlChar,
                                            name2 as *const xmlChar);
                        desret_void_ptr(ret_val);
                        call_tests += 1;
                        des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_prefix,
                                              prefix as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_prefix2,
                                              prefix2 as *const xmlChar,
                                              3 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name2,
                                              name2 as *const xmlChar,
                                              4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlHashQLookup2\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_table);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_prefix);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_prefix2);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name2);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_name2 += 1
                    }
                    n_prefix2 += 1
                }
                n_name += 1
            }
            n_prefix += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashQLookup3() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut prefix2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix2: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    let mut prefix3: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix3: std::os::raw::c_int = 0;
    let mut name3: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name3: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_prefix2 = 0 as std::os::raw::c_int;
                while n_prefix2 < 5 as std::os::raw::c_int {
                    n_name2 = 0 as std::os::raw::c_int;
                    while n_name2 < 5 as std::os::raw::c_int {
                        n_prefix3 = 0 as std::os::raw::c_int;
                        while n_prefix3 < 5 as std::os::raw::c_int {
                            n_name3 = 0 as std::os::raw::c_int;
                            while n_name3 < 5 as std::os::raw::c_int {
                                mem_base = xmlMemBlocks();
                                table =
                                    gen_xmlHashTablePtr(n_table,
                                                        0 as std::os::raw::c_int);
                                prefix =
                                    gen_const_xmlChar_ptr(n_prefix,
                                                          1 as std::os::raw::c_int);
                                name =
                                    gen_const_xmlChar_ptr(n_name,
                                                          2 as std::os::raw::c_int);
                                prefix2 =
                                    gen_const_xmlChar_ptr(n_prefix2,
                                                          3 as std::os::raw::c_int);
                                name2 =
                                    gen_const_xmlChar_ptr(n_name2,
                                                          4 as std::os::raw::c_int);
                                prefix3 =
                                    gen_const_xmlChar_ptr(n_prefix3,
                                                          5 as std::os::raw::c_int);
                                name3 =
                                    gen_const_xmlChar_ptr(n_name3,
                                                          6 as std::os::raw::c_int);
                                ret_val =
                                    xmlHashQLookup3(table,
                                                    prefix as *const xmlChar,
                                                    name as *const xmlChar,
                                                    prefix2 as *const xmlChar,
                                                    name2 as *const xmlChar,
                                                    prefix3 as *const xmlChar,
                                                    name3 as *const xmlChar);
                                desret_void_ptr(ret_val);
                                call_tests += 1;
                                des_xmlHashTablePtr(n_table, table,
                                                    0 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_prefix,
                                                      prefix as
                                                          *const xmlChar,
                                                      1 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_name,
                                                      name as *const xmlChar,
                                                      2 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_prefix2,
                                                      prefix2 as
                                                          *const xmlChar,
                                                      3 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_name2,
                                                      name2 as *const xmlChar,
                                                      4 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_prefix3,
                                                      prefix3 as
                                                          *const xmlChar,
                                                      5 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_name3,
                                                      name3 as *const xmlChar,
                                                      6 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in xmlHashQLookup3\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_table);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_prefix);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_name);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_prefix2);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_name2);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_prefix3);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_name3);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                                n_name3 += 1
                            }
                            n_prefix3 += 1
                        }
                        n_name2 += 1
                    }
                    n_prefix2 += 1
                }
                n_name += 1
            }
            n_prefix += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashRemoveEntry() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut f: xmlHashDeallocator = None;
    let mut n_f: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_f = 0 as std::os::raw::c_int;
            while n_f < 2 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                table = gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                f = gen_xmlHashDeallocator(n_f, 2 as std::os::raw::c_int);
                ret_val =
                    xmlHashRemoveEntry(table, name as *const xmlChar, f);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_xmlHashDeallocator(n_f, f, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlHashRemoveEntry\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_table);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_f);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_f += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashRemoveEntry2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    let mut f: xmlHashDeallocator = None;
    let mut n_f: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_name2 = 0 as std::os::raw::c_int;
            while n_name2 < 5 as std::os::raw::c_int {
                n_f = 0 as std::os::raw::c_int;
                while n_f < 2 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    table = gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    name2 = gen_const_xmlChar_ptr(n_name2, 2 as std::os::raw::c_int);
                    f = gen_xmlHashDeallocator(n_f, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlHashRemoveEntry2(table, name as *const xmlChar,
                                            name2 as *const xmlChar, f);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name2, name2 as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_xmlHashDeallocator(n_f, f, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlHashRemoveEntry2\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_table);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name2);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_f);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_f += 1
                }
                n_name2 += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashRemoveEntry3() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    let mut name3: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name3: std::os::raw::c_int = 0;
    let mut f: xmlHashDeallocator = None;
    let mut n_f: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_name2 = 0 as std::os::raw::c_int;
            while n_name2 < 5 as std::os::raw::c_int {
                n_name3 = 0 as std::os::raw::c_int;
                while n_name3 < 5 as std::os::raw::c_int {
                    n_f = 0 as std::os::raw::c_int;
                    while n_f < 2 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        table =
                            gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                        name2 =
                            gen_const_xmlChar_ptr(n_name2, 2 as std::os::raw::c_int);
                        name3 =
                            gen_const_xmlChar_ptr(n_name3, 3 as std::os::raw::c_int);
                        f = gen_xmlHashDeallocator(n_f, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlHashRemoveEntry3(table, name as *const xmlChar,
                                                name2 as *const xmlChar,
                                                name3 as *const xmlChar, f);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name2,
                                              name2 as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name3,
                                              name3 as *const xmlChar,
                                              3 as std::os::raw::c_int);
                        des_xmlHashDeallocator(n_f, f, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlHashRemoveEntry3\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_table);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name2);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name3);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_f);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_f += 1
                    }
                    n_name3 += 1
                }
                n_name2 += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashScan() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlHashScan3() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlHashScanFull() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlHashScanFull3() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the hash table */
}
unsafe extern "C" fn test_xmlHashSize() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the hash table */
    let mut mem_base: std::os::raw::c_int = 0; /* the name of the userdata */
    let mut ret_val: std::os::raw::c_int = 0; /* a pointer to the userdata */
    let mut table: xmlHashTablePtr =
        0 as
            *mut xmlHashTable; /* the deallocator function for replaced item (if any) */
    let mut n_table: std::os::raw::c_int = 0; /* the hash table */
    n_table = 0 as std::os::raw::c_int; /* the name of the userdata */
    while n_table < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* a second name of the userdata */
        table =
            gen_xmlHashTablePtr(n_table,
                                0 as
                                    std::os::raw::c_int); /* a pointer to the userdata */
        ret_val =
            xmlHashSize(table); /* the deallocator function for replaced item (if any) */
        desret_int(ret_val); /* the hash table */
        call_tests += 1; /* the name of the userdata */
        des_xmlHashTablePtr(n_table, table,
                            0 as
                                std::os::raw::c_int); /* a second name of the userdata */
        xmlResetLastError(); /* a third name of the userdata */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlHashSize\x00" as *const u8
                       as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* a pointer to the userdata */
            test_ret +=
                1; /* the deallocator function for replaced item (if any) */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_table); /* a link */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* a list */
        } /* the data */
        n_table += 1
    } /* a list */
    function_tests += 1; /* the new list */
    return test_ret; /* the old list */
}
unsafe extern "C" fn test_xmlHashUpdateEntry() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut userdata: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_userdata: std::os::raw::c_int = 0;
    let mut f: xmlHashDeallocator = None;
    let mut n_f: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_userdata = 0 as std::os::raw::c_int;
            while n_userdata < 3 as std::os::raw::c_int {
                n_f = 0 as std::os::raw::c_int;
                while n_f < 2 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    table = gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    userdata = gen_userdata(n_userdata, 2 as std::os::raw::c_int);
                    f = gen_xmlHashDeallocator(n_f, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlHashUpdateEntry(table, name as *const xmlChar,
                                           userdata, f);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_userdata(n_userdata, userdata, 2 as std::os::raw::c_int);
                    des_xmlHashDeallocator(n_f, f, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlHashUpdateEntry\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_table);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_userdata);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_f);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_f += 1
                }
                n_userdata += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashUpdateEntry2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    let mut userdata: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_userdata: std::os::raw::c_int = 0;
    let mut f: xmlHashDeallocator = None;
    let mut n_f: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_name2 = 0 as std::os::raw::c_int;
            while n_name2 < 5 as std::os::raw::c_int {
                n_userdata = 0 as std::os::raw::c_int;
                while n_userdata < 3 as std::os::raw::c_int {
                    n_f = 0 as std::os::raw::c_int;
                    while n_f < 2 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        table =
                            gen_xmlHashTablePtr(n_table, 0 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                        name2 =
                            gen_const_xmlChar_ptr(n_name2, 2 as std::os::raw::c_int);
                        userdata = gen_userdata(n_userdata, 3 as std::os::raw::c_int);
                        f = gen_xmlHashDeallocator(n_f, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlHashUpdateEntry2(table, name as *const xmlChar,
                                                name2 as *const xmlChar,
                                                userdata, f);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlHashTablePtr(n_table, table, 0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name2,
                                              name2 as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_userdata(n_userdata, userdata, 3 as std::os::raw::c_int);
                        des_xmlHashDeallocator(n_f, f, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlHashUpdateEntry2\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_table);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name2);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_userdata);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_f);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_f += 1
                    }
                    n_userdata += 1
                }
                n_name2 += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlHashUpdateEntry3() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    let mut n_table: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut name2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name2: std::os::raw::c_int = 0;
    let mut name3: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name3: std::os::raw::c_int = 0;
    let mut userdata: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_userdata: std::os::raw::c_int = 0;
    let mut f: xmlHashDeallocator = None;
    let mut n_f: std::os::raw::c_int = 0;
    n_table = 0 as std::os::raw::c_int;
    while n_table < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_name2 = 0 as std::os::raw::c_int;
            while n_name2 < 5 as std::os::raw::c_int {
                n_name3 = 0 as std::os::raw::c_int;
                while n_name3 < 5 as std::os::raw::c_int {
                    n_userdata = 0 as std::os::raw::c_int;
                    while n_userdata < 3 as std::os::raw::c_int {
                        n_f = 0 as std::os::raw::c_int;
                        while n_f < 2 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            table =
                                gen_xmlHashTablePtr(n_table,
                                                    0 as std::os::raw::c_int);
                            name =
                                gen_const_xmlChar_ptr(n_name,
                                                      1 as std::os::raw::c_int);
                            name2 =
                                gen_const_xmlChar_ptr(n_name2,
                                                      2 as std::os::raw::c_int);
                            name3 =
                                gen_const_xmlChar_ptr(n_name3,
                                                      3 as std::os::raw::c_int);
                            userdata =
                                gen_userdata(n_userdata, 4 as std::os::raw::c_int);
                            f = gen_xmlHashDeallocator(n_f, 5 as std::os::raw::c_int);
                            ret_val =
                                xmlHashUpdateEntry3(table,
                                                    name as *const xmlChar,
                                                    name2 as *const xmlChar,
                                                    name3 as *const xmlChar,
                                                    userdata, f);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlHashTablePtr(n_table, table,
                                                0 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_name,
                                                  name as *const xmlChar,
                                                  1 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_name2,
                                                  name2 as *const xmlChar,
                                                  2 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_name3,
                                                  name3 as *const xmlChar,
                                                  3 as std::os::raw::c_int);
                            des_userdata(n_userdata, userdata,
                                         4 as std::os::raw::c_int);
                            des_xmlHashDeallocator(n_f, f, 5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlHashUpdateEntry3\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_table);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_name);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_name2);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_name3);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_userdata);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_f);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_f += 1
                        }
                        n_userdata += 1
                    }
                    n_name3 += 1
                }
                n_name2 += 1
            }
            n_name += 1
        }
        n_table += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_hash() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing hash : 17 of 25 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char);
    }
    test_ret += test_xmlHashAddEntry();
    test_ret += test_xmlHashAddEntry2();
    test_ret += test_xmlHashAddEntry3();
    test_ret += test_xmlHashCopy();
    test_ret += test_xmlHashCreate();
    test_ret += test_xmlHashCreateDict();
    test_ret += test_xmlHashDefaultDeallocator();
    test_ret += test_xmlHashLookup();
    test_ret += test_xmlHashLookup2();
    test_ret += test_xmlHashLookup3();
    test_ret += test_xmlHashQLookup();
    test_ret += test_xmlHashQLookup2();
    test_ret += test_xmlHashQLookup3();
    test_ret += test_xmlHashRemoveEntry();
    test_ret += test_xmlHashRemoveEntry2();
    test_ret += test_xmlHashRemoveEntry3();
    test_ret += test_xmlHashScan();
    test_ret += test_xmlHashScan3();
    test_ret += test_xmlHashScanFull();
    test_ret += test_xmlHashScanFull3();
    test_ret += test_xmlHashSize();
    test_ret += test_xmlHashUpdateEntry();
    test_ret += test_xmlHashUpdateEntry2();
    test_ret += test_xmlHashUpdateEntry3();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module hash: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn gen_xmlLinkPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlLinkPtr {
    return 0 as xmlLinkPtr;
}
unsafe extern "C" fn des_xmlLinkPtr(mut no: std::os::raw::c_int, mut val: xmlLinkPtr,
                                    mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlLinkGetData() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    let mut n_lk: std::os::raw::c_int = 0;
    n_lk = 0 as std::os::raw::c_int;
    while n_lk < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        lk = gen_xmlLinkPtr(n_lk, 0 as std::os::raw::c_int);
        ret_val = xmlLinkGetData(lk);
        desret_void_ptr(ret_val);
        call_tests += 1;
        des_xmlLinkPtr(n_lk, lk, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlLinkGetData\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_lk);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_lk += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListAppend() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
            data = gen_userdata(n_data, 1 as std::os::raw::c_int);
            ret_val = xmlListAppend(l, data);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
            des_userdata(n_data, data, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListAppend\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_data);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_data += 1
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListClear() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
        xmlListClear(l);
        call_tests += 1;
        des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlListClear\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_const_xmlListPtr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int) -> xmlListPtr {
    return 0 as xmlListPtr;
}
unsafe extern "C" fn des_const_xmlListPtr(mut no: std::os::raw::c_int,
                                          val: xmlListPtr,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlListCopy() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut cur: xmlListPtr = 0 as *mut xmlList;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut old: xmlListPtr = 0 as *mut xmlList;
    let mut n_old: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 2 as std::os::raw::c_int {
        n_old = 0 as std::os::raw::c_int;
        while n_old < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlListPtr(n_cur, 0 as std::os::raw::c_int);
            old = gen_const_xmlListPtr(n_old, 1 as std::os::raw::c_int);
            ret_val = xmlListCopy(cur, old);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlListPtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_const_xmlListPtr(n_old, old, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListCopy\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_old);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_old += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListCreate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlListDup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a list */
}
unsafe extern "C" fn test_xmlListEmpty() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
        ret_val = xmlListEmpty(l);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlListEmpty\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListEnd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlListFront() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a list */
}
unsafe extern "C" fn test_xmlListInsert() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the data */
    let mut mem_base: std::os::raw::c_int = 0; /* the original list */
    let mut ret_val: std::os::raw::c_int = 0; /* the new list */
    let mut l: xmlListPtr = 0 as *mut xmlList; /* a list */
    let mut n_l: std::os::raw::c_int = 0; /* a list */
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void; /* a list */
    let mut n_data: std::os::raw::c_int = 0; /* new data */
    n_l = 0 as std::os::raw::c_int; /* a list */
    while n_l < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int; /* new data */
        while n_data < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* a list */
            l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int); /* list data */
            data = gen_userdata(n_data, 1 as std::os::raw::c_int); /* a list */
            ret_val = xmlListInsert(l, data); /* list data */
            desret_int(ret_val); /* a list */
            call_tests += 1; /* list data */
            des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int); /* a list */
            des_userdata(n_data, data, 1 as std::os::raw::c_int); /* a list */
            xmlResetLastError(); /* a search value */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListInsert\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_data);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_data += 1
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListMerge() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut l1: xmlListPtr = 0 as *mut xmlList;
    let mut n_l1: std::os::raw::c_int = 0;
    let mut l2: xmlListPtr = 0 as *mut xmlList;
    let mut n_l2: std::os::raw::c_int = 0;
    n_l1 = 0 as std::os::raw::c_int;
    while n_l1 < 2 as std::os::raw::c_int {
        n_l2 = 0 as std::os::raw::c_int;
        while n_l2 < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            l1 = gen_xmlListPtr(n_l1, 0 as std::os::raw::c_int);
            l2 = gen_xmlListPtr(n_l2, 1 as std::os::raw::c_int);
            xmlListMerge(l1, l2);
            call_tests += 1;
            des_xmlListPtr(n_l1, l1, 0 as std::os::raw::c_int);
            des_xmlListPtr(n_l2, l2, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListMerge\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_l2 += 1
        }
        n_l1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListPopBack() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
        xmlListPopBack(l);
        call_tests += 1;
        des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlListPopBack\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListPopFront() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
        xmlListPopFront(l);
        call_tests += 1;
        des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlListPopFront\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListPushBack() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
            data = gen_userdata(n_data, 1 as std::os::raw::c_int);
            ret_val = xmlListPushBack(l, data);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
            des_userdata(n_data, data, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListPushBack\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_data);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_data += 1
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListPushFront() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
            data = gen_userdata(n_data, 1 as std::os::raw::c_int);
            ret_val = xmlListPushFront(l, data);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
            des_userdata(n_data, data, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListPushFront\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_data);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_data += 1
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListRemoveAll() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
            data = gen_userdata(n_data, 1 as std::os::raw::c_int);
            ret_val = xmlListRemoveAll(l, data);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
            des_userdata(n_data, data, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListRemoveAll\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_data);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_data += 1
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListRemoveFirst() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
            data = gen_userdata(n_data, 1 as std::os::raw::c_int);
            ret_val = xmlListRemoveFirst(l, data);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
            des_userdata(n_data, data, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListRemoveFirst\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_data);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_data += 1
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListRemoveLast() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
            data = gen_userdata(n_data, 1 as std::os::raw::c_int);
            ret_val = xmlListRemoveLast(l, data);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
            des_userdata(n_data, data, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListRemoveLast\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_data);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_data += 1
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListReverse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
        xmlListReverse(l);
        call_tests += 1;
        des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlListReverse\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListReverseSearch() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
            data = gen_userdata(n_data, 1 as std::os::raw::c_int);
            ret_val = xmlListReverseSearch(l, data);
            desret_void_ptr(ret_val);
            call_tests += 1;
            des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
            des_userdata(n_data, data, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListReverseSearch\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_data);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_data += 1
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListReverseWalk() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a list */
}
unsafe extern "C" fn test_xmlListSearch() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* a search value */
    let mut mem_base: std::os::raw::c_int = 0; /* a list */
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void; /* a list */
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
            data = gen_userdata(n_data, 1 as std::os::raw::c_int);
            ret_val = xmlListSearch(l, data);
            desret_void_ptr(ret_val);
            call_tests += 1;
            des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
            des_userdata(n_data, data, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlListSearch\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_data);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_data += 1
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListSize() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
        ret_val = xmlListSize(l);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlListSize\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListSort() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut l: xmlListPtr = 0 as *mut xmlList;
    let mut n_l: std::os::raw::c_int = 0;
    n_l = 0 as std::os::raw::c_int;
    while n_l < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0 as std::os::raw::c_int);
        xmlListSort(l);
        call_tests += 1;
        des_xmlListPtr(n_l, l, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlListSort\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_l);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_l += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlListWalk() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an FTP context */
}
unsafe extern "C" fn test_list() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* an FTP context */
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing list : 19 of 26 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char); /* an FTP context */
    } /* a directory on the server */
    test_ret += test_xmlLinkGetData(); /* an FTP context */
    test_ret += test_xmlListAppend(); /* a file or directory on the server */
    test_ret += test_xmlListClear();
    test_ret += test_xmlListCopy();
    test_ret += test_xmlListCreate();
    test_ret += test_xmlListDup();
    test_ret += test_xmlListEmpty();
    test_ret += test_xmlListEnd();
    test_ret += test_xmlListFront();
    test_ret += test_xmlListInsert();
    test_ret += test_xmlListMerge();
    test_ret += test_xmlListPopBack();
    test_ret += test_xmlListPopFront();
    test_ret += test_xmlListPushBack();
    test_ret += test_xmlListPushFront();
    test_ret += test_xmlListRemoveAll();
    test_ret += test_xmlListRemoveFirst();
    test_ret += test_xmlListRemoveLast();
    test_ret += test_xmlListReverse();
    test_ret += test_xmlListReverseSearch();
    test_ret += test_xmlListReverseWalk();
    test_ret += test_xmlListSearch();
    test_ret += test_xmlListSize();
    test_ret += test_xmlListSort();
    test_ret += test_xmlListWalk();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module list: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPCheckResponse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlNanoFTPCheckResponse(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoFTPCheckResponse\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPCleanup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlNanoFTPCleanup();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlNanoFTPCleanup\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPCloseConnection() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlNanoFTPCloseConnection(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoFTPCloseConnection\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPCwd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut directory: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_directory: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 4 as std::os::raw::c_int {
        n_directory = 0 as std::os::raw::c_int;
        while n_directory < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
            directory = gen_const_char_ptr(n_directory, 1 as std::os::raw::c_int);
            ret_val = xmlNanoFTPCwd(ctx, directory as *const std::os::raw::c_char);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_directory, directory as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNanoFTPCwd\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_directory);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_directory += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPDele() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut file: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_file: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 4 as std::os::raw::c_int {
        n_file = 0 as std::os::raw::c_int;
        while n_file < 8 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
            file = gen_filepath(n_file, 1 as std::os::raw::c_int);
            ret_val = xmlNanoFTPDele(ctx, file);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_filepath(n_file, file, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNanoFTPDele\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_file);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_file += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPGet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPGetConnection() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an FTP context */
}
unsafe extern "C" fn test_xmlNanoFTPGetResponse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlNanoFTPGetResponse(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoFTPGetResponse\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPGetSocket() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPInit() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlNanoFTPInit();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlNanoFTPInit\x00" as *const u8
                   as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* The URL used to initialize the context */
}
unsafe extern "C" fn test_xmlNanoFTPNewCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the URL to the resource */
    let mut mem_base: std::os::raw::c_int = 0; /* the proxy host name */
    let mut ret_val: *mut std::os::raw::c_void =
        0 as *mut std::os::raw::c_void; /* the proxy port */
    let mut URL: *const std::os::raw::c_char =
        0 as *const std::os::raw::c_char; /* the proxy user name */
    let mut n_URL: std::os::raw::c_int = 0; /* the proxy password */
    n_URL =
        0 as
            std::os::raw::c_int; /* the type of proxy 1 for using SITE, 2 for USER a@b */
    while n_URL < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* an FTP context */
        URL = gen_filepath(n_URL, 0 as std::os::raw::c_int); /* the FTP context */
        ret_val = xmlNanoFTPNewCtxt(URL); /* a buffer */
        desret_xmlNanoFTPCtxtPtr(ret_val); /* the buffer length */
        call_tests +=
            1; /* The proxy URL used to initialize the proxy context */
        des_filepath(n_URL, URL, 0 as std::os::raw::c_int); /* an FTP context */
        xmlResetLastError(); /* The URL used to update the context */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoFTPNewCtxt\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* the HTTP context */
            test_ret += 1; /* the HTTP context */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_URL); /* the HTTP context */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* The URL to load */
        } /* the filename where the content should be saved */
        n_URL += 1
    } /* if available the Content-Type information will be returned at that location */
    function_tests += 1; /* the HTTP context */
    return test_ret; /* The URL to load */
}
unsafe extern "C" fn test_xmlNanoFTPOpen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* if available the Content-Type information will be returned at that location */
    let mut mem_base: std::os::raw::c_int = 0; /* The URL to load */
    let mut ret_val: *mut std::os::raw::c_void =
        0 as
            *mut std::os::raw::c_void; /* if available the Content-Type information will be returned at that location */
    let mut URL: *const std::os::raw::c_char =
        0 as
            *const std::os::raw::c_char; /* if available the redirected URL will be returned */
    let mut n_URL: std::os::raw::c_int = 0; /* the HTTP context */
    n_URL = 0 as std::os::raw::c_int; /* a buffer */
    while n_URL < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the buffer length */
        URL = gen_filepath(n_URL, 0 as std::os::raw::c_int);
        ret_val = xmlNanoFTPOpen(URL);
        desret_xmlNanoFTPCtxtPtr(ret_val);
        call_tests += 1;
        des_filepath(n_URL, URL, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoFTPOpen\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URL);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPProxy() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut host: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_host: std::os::raw::c_int = 0;
    let mut port: std::os::raw::c_int = 0;
    let mut n_port: std::os::raw::c_int = 0;
    let mut user: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_user: std::os::raw::c_int = 0;
    let mut passwd: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_passwd: std::os::raw::c_int = 0;
    let mut type_0: std::os::raw::c_int = 0;
    let mut n_type: std::os::raw::c_int = 0;
    n_host = 0 as std::os::raw::c_int;
    while n_host < 4 as std::os::raw::c_int {
        n_port = 0 as std::os::raw::c_int;
        while n_port < 4 as std::os::raw::c_int {
            n_user = 0 as std::os::raw::c_int;
            while n_user < 4 as std::os::raw::c_int {
                n_passwd = 0 as std::os::raw::c_int;
                while n_passwd < 4 as std::os::raw::c_int {
                    n_type = 0 as std::os::raw::c_int;
                    while n_type < 4 as std::os::raw::c_int {
                        host = gen_const_char_ptr(n_host, 0 as std::os::raw::c_int);
                        port = gen_int(n_port, 1 as std::os::raw::c_int);
                        user = gen_const_char_ptr(n_user, 2 as std::os::raw::c_int);
                        passwd =
                            gen_const_char_ptr(n_passwd, 3 as std::os::raw::c_int);
                        type_0 = gen_int(n_type, 4 as std::os::raw::c_int);
                        xmlNanoFTPProxy(host as *const std::os::raw::c_char, port,
                                        user as *const std::os::raw::c_char,
                                        passwd as *const std::os::raw::c_char,
                                        type_0);
                        call_tests += 1;
                        des_const_char_ptr(n_host,
                                           host as *const std::os::raw::c_char,
                                           0 as std::os::raw::c_int);
                        des_int(n_port, port, 1 as std::os::raw::c_int);
                        des_const_char_ptr(n_user,
                                           user as *const std::os::raw::c_char,
                                           2 as std::os::raw::c_int);
                        des_const_char_ptr(n_passwd,
                                           passwd as *const std::os::raw::c_char,
                                           3 as std::os::raw::c_int);
                        des_int(n_type, type_0, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        n_type += 1
                    }
                    n_passwd += 1
                }
                n_user += 1
            }
            n_port += 1
        }
        n_host += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPQuit() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlNanoFTPQuit(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoFTPQuit\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPRead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut dest: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_dest: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 4 as std::os::raw::c_int {
        n_dest = 0 as std::os::raw::c_int;
        while n_dest < 2 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
                dest = gen_void_ptr(n_dest, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                ret_val = xmlNanoFTPRead(ctx, dest, len);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
                des_void_ptr(n_dest, dest, 1 as std::os::raw::c_int);
                des_int(n_len, len, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNanoFTPRead\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctx);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_dest);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_len += 1
            }
            n_dest += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPScanProxy() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 8 as std::os::raw::c_int {
        URL = gen_filepath(n_URL, 0 as std::os::raw::c_int);
        xmlNanoFTPScanProxy(URL);
        call_tests += 1;
        des_filepath(n_URL, URL, 0 as std::os::raw::c_int);
        xmlResetLastError();
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoFTPUpdateURL() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 4 as std::os::raw::c_int {
        n_URL = 0 as std::os::raw::c_int;
        while n_URL < 8 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
            URL = gen_filepath(n_URL, 1 as std::os::raw::c_int);
            ret_val = xmlNanoFTPUpdateURL(ctx, URL);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_filepath(n_URL, URL, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNanoFTPUpdateURL\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URL);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_URL += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_nanoftp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing nanoftp : 14 of 22 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlNanoFTPCheckResponse();
    test_ret += test_xmlNanoFTPCleanup();
    test_ret += test_xmlNanoFTPCloseConnection();
    test_ret += test_xmlNanoFTPCwd();
    test_ret += test_xmlNanoFTPDele();
    test_ret += test_xmlNanoFTPGet();
    test_ret += test_xmlNanoFTPGetConnection();
    test_ret += test_xmlNanoFTPGetResponse();
    test_ret += test_xmlNanoFTPGetSocket();
    test_ret += test_xmlNanoFTPInit();
    test_ret += test_xmlNanoFTPList();
    test_ret += test_xmlNanoFTPNewCtxt();
    test_ret += test_xmlNanoFTPOpen();
    test_ret += test_xmlNanoFTPProxy();
    test_ret += test_xmlNanoFTPQuit();
    test_ret += test_xmlNanoFTPRead();
    test_ret += test_xmlNanoFTPScanProxy();
    test_ret += test_xmlNanoFTPUpdateURL();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module nanoftp: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPAuthHeader() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlNanoHTTPAuthHeader(ctx);
        desret_const_char_ptr(ret_val);
        call_tests += 1;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoHTTPAuthHeader\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPCleanup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlNanoHTTPCleanup();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlNanoHTTPCleanup\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPContentLength() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlNanoHTTPContentLength(ctx);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoHTTPContentLength\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPEncoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlNanoHTTPEncoding(ctx);
        desret_const_char_ptr(ret_val);
        call_tests += 1;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoHTTPEncoding\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_char_ptr_ptr(mut no: std::os::raw::c_int,
                                      mut nr: std::os::raw::c_int)
 -> *mut *mut std::os::raw::c_char {
    return 0 as *mut *mut std::os::raw::c_char;
}
unsafe extern "C" fn des_char_ptr_ptr(mut no: std::os::raw::c_int,
                                      mut val: *mut *mut std::os::raw::c_char,
                                      mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlNanoHTTPFetch() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut contentType: *mut *mut std::os::raw::c_char = 0 as *mut *mut std::os::raw::c_char;
    let mut n_contentType: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 6 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 6 as std::os::raw::c_int {
            n_contentType = 0 as std::os::raw::c_int;
            while n_contentType < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                URL = gen_fileoutput(n_URL, 0 as std::os::raw::c_int);
                filename = gen_fileoutput(n_filename, 1 as std::os::raw::c_int);
                contentType =
                    gen_char_ptr_ptr(n_contentType, 2 as std::os::raw::c_int);
                ret_val = xmlNanoHTTPFetch(URL, filename, contentType);
                desret_int(ret_val);
                call_tests += 1;
                des_fileoutput(n_URL, URL, 0 as std::os::raw::c_int);
                des_fileoutput(n_filename, filename, 1 as std::os::raw::c_int);
                des_char_ptr_ptr(n_contentType, contentType,
                                 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNanoHTTPFetch\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_URL);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_contentType);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_contentType += 1
            }
            n_filename += 1
        }
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPInit() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlNanoHTTPInit();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlNanoHTTPInit\x00" as *const u8
                   as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPMimeType() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
        ret_val = xmlNanoHTTPMimeType(ctx);
        desret_const_char_ptr(ret_val);
        call_tests += 1;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoHTTPMimeType\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPOpen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut contentType: *mut *mut std::os::raw::c_char = 0 as *mut *mut std::os::raw::c_char;
    let mut n_contentType: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 8 as std::os::raw::c_int {
        n_contentType = 0 as std::os::raw::c_int;
        while n_contentType < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            URL = gen_filepath(n_URL, 0 as std::os::raw::c_int);
            contentType = gen_char_ptr_ptr(n_contentType, 1 as std::os::raw::c_int);
            ret_val = xmlNanoHTTPOpen(URL, contentType);
            desret_xmlNanoHTTPCtxtPtr(ret_val);
            call_tests += 1;
            des_filepath(n_URL, URL, 0 as std::os::raw::c_int);
            des_char_ptr_ptr(n_contentType, contentType, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNanoHTTPOpen\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URL);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_contentType);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_contentType += 1
        }
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPOpenRedir() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut contentType: *mut *mut std::os::raw::c_char = 0 as *mut *mut std::os::raw::c_char;
    let mut n_contentType: std::os::raw::c_int = 0;
    let mut redir: *mut *mut std::os::raw::c_char = 0 as *mut *mut std::os::raw::c_char;
    let mut n_redir: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 8 as std::os::raw::c_int {
        n_contentType = 0 as std::os::raw::c_int;
        while n_contentType < 1 as std::os::raw::c_int {
            n_redir = 0 as std::os::raw::c_int;
            while n_redir < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                URL = gen_filepath(n_URL, 0 as std::os::raw::c_int);
                contentType =
                    gen_char_ptr_ptr(n_contentType, 1 as std::os::raw::c_int);
                redir = gen_char_ptr_ptr(n_redir, 2 as std::os::raw::c_int);
                ret_val = xmlNanoHTTPOpenRedir(URL, contentType, redir);
                desret_xmlNanoHTTPCtxtPtr(ret_val);
                call_tests += 1;
                des_filepath(n_URL, URL, 0 as std::os::raw::c_int);
                des_char_ptr_ptr(n_contentType, contentType,
                                 1 as std::os::raw::c_int);
                des_char_ptr_ptr(n_redir, redir, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNanoHTTPOpenRedir\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_URL);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_contentType);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_redir);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_redir += 1
            }
            n_contentType += 1
        }
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPRead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut dest: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_dest: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 1 as std::os::raw::c_int {
        n_dest = 0 as std::os::raw::c_int;
        while n_dest < 2 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
                dest = gen_void_ptr(n_dest, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                ret_val = xmlNanoHTTPRead(ctx, dest, len);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
                des_void_ptr(n_dest, dest, 1 as std::os::raw::c_int);
                des_int(n_len, len, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNanoHTTPRead\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctx);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_dest);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_len += 1
            }
            n_dest += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPRedir() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the HTTP context */
}
unsafe extern "C" fn test_xmlNanoHTTPReturnCode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the HTTP context */
    let mut mem_base: std::os::raw::c_int =
        0; /* the filename where the content should be saved */
    let mut ret_val: std::os::raw::c_int =
        0; /* The proxy URL used to initialize the proxy context */
    let mut ctx: *mut std::os::raw::c_void =
        0 as *mut std::os::raw::c_void; /* an XML parser context */
    let mut n_ctx: std::os::raw::c_int = 0; /* a node info sequence pointer */
    n_ctx = 0 as std::os::raw::c_int; /* an XML parser context */
    while n_ctx < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* a pointer to an array of xmlChar */
        ctx =
            gen_xmlNanoHTTPCtxtPtr(n_ctx,
                                   0 as std::os::raw::c_int); /* a SAX handler */
        ret_val =
            xmlNanoHTTPReturnCode(ctx); /* The user data returned on SAX callbacks */
        desret_int(ret_val); /* a pointer to an array of chars */
        call_tests += 1; /* number of chars in the array */
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx,
                               0 as
                                   std::os::raw::c_int); /* an optional file name or URI */
        xmlResetLastError(); /* an XML parser context */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNanoHTTPReturnCode\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() -
                       mem_base); /* a pointer to a zero terminated string */
            test_ret += 1; /* the base URL to use for the document */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_ctx); /* the document encoding, or NULL */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* a combination of xmlParserOption */
        } /* an XML parser context */
        n_ctx += 1
    } /* a file or URL */
    function_tests += 1; /* the document encoding, or NULL */
    return test_ret; /* a combination of xmlParserOption */
}
unsafe extern "C" fn test_xmlNanoHTTPSave() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* an XML parser context */
    let mut mem_base: std::os::raw::c_int = 0; /* a pointer to a char array */
    let mut ret_val: std::os::raw::c_int = 0; /* the size of the array */
    let mut ctxt: *mut std::os::raw::c_void =
        0 as *mut std::os::raw::c_void; /* the base URL to use for the document */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the document encoding, or NULL */
    let mut filename: *const std::os::raw::c_char =
        0 as *const std::os::raw::c_char; /* a combination of xmlParserOption */
    let mut n_filename: std::os::raw::c_int = 0; /* an XML parser context */
    n_ctxt = 0 as std::os::raw::c_int; /* an XML parser context */
    while n_ctxt < 2 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int; /* a pointer to an array of chars */
        while n_filename < 6 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* number of chars in the array */
            ctxt =
                gen_void_ptr(n_ctxt,
                             0 as
                                 std::os::raw::c_int); /* an optional file name or URI */
            filename =
                gen_fileoutput(n_filename,
                               1 as
                                   std::os::raw::c_int); /* the document encoding, or NULL */
            ret_val =
                xmlNanoHTTPSave(ctxt, filename); /* an XML parser context */
            desret_int(ret_val); /* a combination of xmlParserOption */
            call_tests += 1;
            des_void_ptr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_fileoutput(n_filename, filename, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNanoHTTPSave\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_filename);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_filename += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNanoHTTPScanProxy() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 8 as std::os::raw::c_int {
        URL = gen_filepath(n_URL, 0 as std::os::raw::c_int);
        xmlNanoHTTPScanProxy(URL);
        call_tests += 1;
        des_filepath(n_URL, URL, 0 as std::os::raw::c_int);
        xmlResetLastError();
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_nanohttp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing nanohttp : 13 of 17 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlNanoHTTPAuthHeader();
    test_ret += test_xmlNanoHTTPCleanup();
    test_ret += test_xmlNanoHTTPContentLength();
    test_ret += test_xmlNanoHTTPEncoding();
    test_ret += test_xmlNanoHTTPFetch();
    test_ret += test_xmlNanoHTTPInit();
    test_ret += test_xmlNanoHTTPMimeType();
    test_ret += test_xmlNanoHTTPOpen();
    test_ret += test_xmlNanoHTTPOpenRedir();
    test_ret += test_xmlNanoHTTPRead();
    test_ret += test_xmlNanoHTTPRedir();
    test_ret += test_xmlNanoHTTPReturnCode();
    test_ret += test_xmlNanoHTTPSave();
    test_ret += test_xmlNanoHTTPScanProxy();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module nanohttp: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlByteConsumed() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_long = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlByteConsumed(ctxt);
        desret_long(ret_val);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlByteConsumed\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlClearNodeInfoSeq() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut seq: xmlParserNodeInfoSeqPtr = 0 as *mut xmlParserNodeInfoSeq;
    let mut n_seq: std::os::raw::c_int = 0;
    n_seq = 0 as std::os::raw::c_int;
    while n_seq < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        seq = gen_xmlParserNodeInfoSeqPtr(n_seq, 0 as std::os::raw::c_int);
        xmlClearNodeInfoSeq(seq);
        call_tests += 1;
        des_xmlParserNodeInfoSeqPtr(n_seq, seq, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlClearNodeInfoSeq\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_seq);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_seq += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlClearParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlClearParserCtxt(ctxt);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlClearParserCtxt\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCreateDocParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlCreateDocParserCtxt(cur as *const xmlChar);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_cur, cur as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCreateDocParserCtxt\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCreatePushParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut user_data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_user_data: std::os::raw::c_int = 0;
    let mut chunk: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_chunk: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_user_data = 0 as std::os::raw::c_int;
        while n_user_data < 3 as std::os::raw::c_int {
            n_chunk = 0 as std::os::raw::c_int;
            while n_chunk < 4 as std::os::raw::c_int {
                n_size = 0 as std::os::raw::c_int;
                while n_size < 4 as std::os::raw::c_int {
                    n_filename = 0 as std::os::raw::c_int;
                    while n_filename < 6 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
                        user_data =
                            gen_userdata(n_user_data, 1 as std::os::raw::c_int);
                        chunk = gen_const_char_ptr(n_chunk, 2 as std::os::raw::c_int);
                        size = gen_int(n_size, 3 as std::os::raw::c_int);
                        filename =
                            gen_fileoutput(n_filename, 4 as std::os::raw::c_int);
                        if !(!chunk.is_null() &&
                                 size >
                                     strlen(chunk as *const std::os::raw::c_char) as
                                         std::os::raw::c_int + 1 as std::os::raw::c_int) {
                            ret_val =
                                xmlCreatePushParserCtxt(sax, user_data,
                                                        chunk as
                                                            *const std::os::raw::c_char,
                                                        size, filename);
                            desret_xmlParserCtxtPtr(ret_val);
                            call_tests += 1;
                            des_xmlSAXHandlerPtr(n_sax, sax,
                                                 0 as std::os::raw::c_int);
                            des_userdata(n_user_data, user_data,
                                         1 as std::os::raw::c_int);
                            des_const_char_ptr(n_chunk,
                                               chunk as *const std::os::raw::c_char,
                                               2 as std::os::raw::c_int);
                            des_int(n_size, size, 3 as std::os::raw::c_int);
                            des_fileoutput(n_filename, filename,
                                           4 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlCreatePushParserCtxt\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_sax);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_user_data);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_chunk);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_size);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_filename);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                        }
                        n_filename += 1
                    }
                    n_size += 1
                }
                n_chunk += 1
            }
            n_user_data += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCtxtReadDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 5 as std::os::raw::c_int {
            n_URL = 0 as std::os::raw::c_int;
            while n_URL < 8 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    n_options = 0 as std::os::raw::c_int;
                    while n_options < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                        cur = gen_const_xmlChar_ptr(n_cur, 1 as std::os::raw::c_int);
                        URL = gen_filepath(n_URL, 2 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                        options =
                            gen_parseroptions(n_options, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlCtxtReadDoc(ctxt, cur as *const xmlChar, URL,
                                           encoding as *const std::os::raw::c_char,
                                           options);
                        desret_xmlDocPtr(ret_val);
                        call_tests += 1;
                        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_filepath(n_URL, URL, 2 as std::os::raw::c_int);
                        des_const_char_ptr(n_encoding,
                                           encoding as *const std::os::raw::c_char,
                                           3 as std::os::raw::c_int);
                        des_parseroptions(n_options, options,
                                          4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlCtxtReadDoc\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ctxt);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_cur);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_URL);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_encoding);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_options);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_options += 1
                    }
                    n_encoding += 1
                }
                n_URL += 1
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCtxtReadFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 8 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                n_options = 0 as std::os::raw::c_int;
                while n_options < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    filename = gen_filepath(n_filename, 1 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                    options = gen_parseroptions(n_options, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlCtxtReadFile(ctxt, filename,
                                        encoding as *const std::os::raw::c_char,
                                        options);
                    desret_xmlDocPtr(ret_val);
                    call_tests += 1;
                    des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_filepath(n_filename, filename, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_parseroptions(n_options, options, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlCtxtReadFile\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_filename);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_options);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_options += 1
                }
                n_encoding += 1
            }
            n_filename += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCtxtReadMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 4 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 4 as std::os::raw::c_int {
                n_URL = 0 as std::os::raw::c_int;
                while n_URL < 8 as std::os::raw::c_int {
                    n_encoding = 0 as std::os::raw::c_int;
                    while n_encoding < 4 as std::os::raw::c_int {
                        n_options = 0 as std::os::raw::c_int;
                        while n_options < 5 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            ctxt =
                                gen_xmlParserCtxtPtr(n_ctxt,
                                                     0 as std::os::raw::c_int);
                            buffer =
                                gen_const_char_ptr(n_buffer,
                                                   1 as std::os::raw::c_int);
                            size = gen_int(n_size, 2 as std::os::raw::c_int);
                            URL = gen_filepath(n_URL, 3 as std::os::raw::c_int);
                            encoding =
                                gen_const_char_ptr(n_encoding,
                                                   4 as std::os::raw::c_int);
                            options =
                                gen_parseroptions(n_options,
                                                  5 as std::os::raw::c_int);
                            if !(!buffer.is_null() &&
                                     size >
                                         strlen(buffer as *const std::os::raw::c_char)
                                             as std::os::raw::c_int +
                                             1 as std::os::raw::c_int) {
                                ret_val =
                                    xmlCtxtReadMemory(ctxt,
                                                      buffer as
                                                          *const std::os::raw::c_char,
                                                      size, URL,
                                                      encoding as
                                                          *const std::os::raw::c_char,
                                                      options);
                                desret_xmlDocPtr(ret_val);
                                call_tests += 1;
                                des_xmlParserCtxtPtr(n_ctxt, ctxt,
                                                     0 as std::os::raw::c_int);
                                des_const_char_ptr(n_buffer,
                                                   buffer as
                                                       *const std::os::raw::c_char,
                                                   1 as std::os::raw::c_int);
                                des_int(n_size, size, 2 as std::os::raw::c_int);
                                des_filepath(n_URL, URL, 3 as std::os::raw::c_int);
                                des_const_char_ptr(n_encoding,
                                                   encoding as
                                                       *const std::os::raw::c_char,
                                                   4 as std::os::raw::c_int);
                                des_parseroptions(n_options, options,
                                                  5 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in xmlCtxtReadMemory\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_ctxt);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_buffer);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_size);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_URL);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_encoding);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_options);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                            }
                            n_options += 1
                        }
                        n_encoding += 1
                    }
                    n_URL += 1
                }
                n_size += 1
            }
            n_buffer += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCtxtReset() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlCtxtReset(ctxt);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCtxtReset\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCtxtResetPush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut chunk: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_chunk: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_chunk = 0 as std::os::raw::c_int;
        while n_chunk < 4 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 4 as std::os::raw::c_int {
                n_filename = 0 as std::os::raw::c_int;
                while n_filename < 8 as std::os::raw::c_int {
                    n_encoding = 0 as std::os::raw::c_int;
                    while n_encoding < 4 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                        chunk = gen_const_char_ptr(n_chunk, 1 as std::os::raw::c_int);
                        size = gen_int(n_size, 2 as std::os::raw::c_int);
                        filename = gen_filepath(n_filename, 3 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 4 as std::os::raw::c_int);
                        if !(!chunk.is_null() &&
                                 size >
                                     strlen(chunk as *const std::os::raw::c_char) as
                                         std::os::raw::c_int + 1 as std::os::raw::c_int) {
                            ret_val =
                                xmlCtxtResetPush(ctxt,
                                                 chunk as *const std::os::raw::c_char,
                                                 size, filename,
                                                 encoding as
                                                     *const std::os::raw::c_char);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlParserCtxtPtr(n_ctxt, ctxt,
                                                 0 as std::os::raw::c_int);
                            des_const_char_ptr(n_chunk,
                                               chunk as *const std::os::raw::c_char,
                                               1 as std::os::raw::c_int);
                            des_int(n_size, size, 2 as std::os::raw::c_int);
                            des_filepath(n_filename, filename,
                                         3 as std::os::raw::c_int);
                            des_const_char_ptr(n_encoding,
                                               encoding as
                                                   *const std::os::raw::c_char,
                                               4 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlCtxtResetPush\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ctxt);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_chunk);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_size);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_filename);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_encoding);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                        }
                        n_encoding += 1
                    }
                    n_filename += 1
                }
                n_size += 1
            }
            n_chunk += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCtxtUseOptions() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_options = 0 as std::os::raw::c_int;
        while n_options < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            options = gen_parseroptions(n_options, 1 as std::os::raw::c_int);
            ret_val = xmlCtxtUseOptions(ctxt, options);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_parseroptions(n_options, options, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCtxtUseOptions\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_options);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_options += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetExternalEntityLoader() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an XML/HTML parser context */
}
unsafe extern "C" fn test_xmlGetFeature() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the feature name */
    let mut mem_base: std::os::raw::c_int = 0; /* location to store the result */
    let mut ret_val: std::os::raw::c_int =
        0; /* the length of the features name array (input/output) */
    let mut ctxt: xmlParserCtxtPtr =
        0 as
            *mut xmlParserCtxt; /* an array of string to be filled with the features name. */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the feature to be examined */
    let mut name: *mut std::os::raw::c_char =
        0 as *mut std::os::raw::c_char; /* the SAX handler block or NULL */
    let mut n_name: std::os::raw::c_int = 0; /* an Input Buffer */
    let mut result: *mut std::os::raw::c_void =
        0 as *mut std::os::raw::c_void; /* the charset encoding if known */
    let mut n_result: std::os::raw::c_int = 0; /* a node info sequence pointer */
    n_ctxt = 0 as std::os::raw::c_int; /* an XML parser context */
    while n_ctxt < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* int 0 or 1 */
        while n_name < 4 as std::os::raw::c_int {
            n_result = 0 as std::os::raw::c_int; /* int 0 or 1 */
            while n_result < 2 as std::os::raw::c_int {
                mem_base =
                    xmlMemBlocks(); /* the URL for the entity to load */
                ctxt =
                    gen_xmlParserCtxtPtr(n_ctxt,
                                         0 as
                                             std::os::raw::c_int); /* the Public ID for the entity to load */
                name =
                    gen_const_char_ptr(n_name,
                                       1 as
                                           std::os::raw::c_int); /* the context in which the entity is called or NULL */
                result =
                    gen_void_ptr(n_result,
                                 2 as
                                     std::os::raw::c_int); /* an XML parser context */
                ret_val =
                    xmlGetFeature(ctxt, name as *const std::os::raw::c_char,
                                  result); /* an I/O Input */
                desret_int(ret_val); /* the charset encoding if known */
                call_tests += 1; /* the document the chunk pertains to */
                des_xmlParserCtxtPtr(n_ctxt, ctxt,
                                     0 as
                                         std::os::raw::c_int); /* the SAX handler bloc (possibly NULL) */
                des_const_char_ptr(n_name, name as *const std::os::raw::c_char,
                                   1 as
                                       std::os::raw::c_int); /* The user data returned on SAX callbacks (possibly NULL) */
                des_void_ptr(n_result, result,
                             2 as
                                 std::os::raw::c_int); /* Used for loop detection, use 0 */
                xmlResetLastError(); /* the input string in UTF8 or ISO-Latin (zero terminated) */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlGetFeature\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() -
                               mem_base); /* the return value for the set of parsed nodes */
                    test_ret += 1; /* the document the chunk pertains to */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt); /* the SAX handler bloc (possibly NULL) */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name); /* The user data returned on SAX callbacks (possibly NULL) */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_result); /* Used for loop detection, use 0 */
                    printf(b"\n\x00" as *const u8 as
                               *const std::os::raw::c_char); /* the input string in UTF8 or ISO-Latin (zero terminated) */
                } /* the return value for the set of parsed nodes */
                n_result += 1
            } /* return nodes even if the data is broken (use 0) */
            n_name += 1
        } /* an XML parser context */
        n_ctxt += 1
    } /* an char array */
    function_tests += 1; /* the size in byte of the chunk */
    return test_ret; /* last chunk indicator */
}
unsafe extern "C" fn gen_const_char_ptr_ptr(mut no: std::os::raw::c_int,
                                            mut nr: std::os::raw::c_int)
 -> *mut *mut std::os::raw::c_char {
    return 0 as *mut *mut std::os::raw::c_char; /* the existing parsing context */
}
unsafe extern "C" fn des_const_char_ptr_ptr(mut no: std::os::raw::c_int,
                                            mut val: *mut *const std::os::raw::c_char,
                                            mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlGetFeaturesList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the URL for the entity to load */
    let mut mem_base: std::os::raw::c_int =
        0; /* the System ID for the entity to load */
    let mut ret_val: std::os::raw::c_int =
        0; /* the return value for the set of parsed nodes */
    let mut len: *mut std::os::raw::c_int =
        0 as
            *mut std::os::raw::c_int; /* a NAME* containing the External ID of the DTD */
    let mut n_len: std::os::raw::c_int =
        0; /* a NAME* containing the URL to the DTD */
    let mut result: *mut *mut std::os::raw::c_char =
        0 as *mut *mut std::os::raw::c_char; /* a pointer to an array of xmlChar */
    let mut n_result: std::os::raw::c_int = 0; /* an XML parser context */
    n_len = 0 as std::os::raw::c_int; /* the filename */
    while n_len < 2 as std::os::raw::c_int {
        n_result = 0 as std::os::raw::c_int; /* an XML parser context */
        while n_result < 1 as std::os::raw::c_int {
            mem_base =
                xmlMemBlocks(); /* the document the chunk pertains to */
            len =
                gen_int_ptr(n_len,
                            0 as
                                std::os::raw::c_int); /* the SAX handler bloc (possibly NULL) */
            result =
                gen_const_char_ptr_ptr(n_result,
                                       1 as
                                           std::os::raw::c_int); /* The user data returned on SAX callbacks (possibly NULL) */
            ret_val =
                xmlGetFeaturesList(len,
                                   result as
                                       *mut *const std::os::raw::c_char); /* Used for loop detection, use 0 */
            desret_int(ret_val); /* the URL for the entity to load */
            call_tests += 1; /* the System ID for the entity to load */
            des_int_ptr(n_len, len,
                        0 as
                            std::os::raw::c_int); /* the return value for the set of parsed nodes */
            des_const_char_ptr_ptr(n_result,
                                   result as *mut *const std::os::raw::c_char,
                                   1 as std::os::raw::c_int); /* the filename */
            xmlResetLastError(); /* the context node */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlGetFeaturesList\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base); /* the input string */
                test_ret += 1; /* the input string length in bytes */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_len); /* a combination of xmlParserOption */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_result); /* the return value for the set of parsed nodes */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* an pointer to a char array */
            } /* the size of the array */
            n_result += 1
        } /* an XML parser context */
        n_len += 1
    } /* a node info sequence pointer */
    function_tests += 1; /* an XML parser context */
    return test_ret; /* an XML node within the tree */
}
unsafe extern "C" fn test_xmlHasFeature() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* a node info sequence pointer */
    let mut mem_base: std::os::raw::c_int = 0; /* an XML node pointer */
    let mut ret_val: std::os::raw::c_int = 0; /* an XML parser input */
    let mut feature: xmlFeature =
        0 as xmlFeature; /* an indicative size for the lookahead */
    let mut n_feature: std::os::raw::c_int = 0; /* an XML parser input */
    n_feature = 0 as std::os::raw::c_int; /* an indicative size for the lookahead */
    while n_feature < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* int 0 or 1 */
        feature =
            gen_xmlFeature(n_feature,
                           0 as
                               std::os::raw::c_int); /* a pointer to a zero terminated string */
        ret_val =
            xmlHasFeature(feature); /* the base URL to use for the document */
        desret_int(ret_val); /* the document encoding, or NULL */
        call_tests += 1; /* a combination of xmlParserOption */
        des_xmlFeature(n_feature, feature,
                       0 as std::os::raw::c_int); /* a file or URL */
        xmlResetLastError(); /* the document encoding, or NULL */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlHasFeature\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() -
                       mem_base); /* a combination of xmlParserOption */
            test_ret += 1; /* a pointer to a char array */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_feature); /* the size of the array */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the base URL to use for the document */
        } /* the document encoding, or NULL */
        n_feature += 1
    } /* a combination of xmlParserOption */
    function_tests += 1; /* a pointer to an array of xmlChar */
    return test_ret; /* the filename */
}
unsafe extern "C" fn test_xmlIOParseDTD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* an pointer to a char array */
    let mut ret_val: xmlDtdPtr = 0 as *mut xmlDtd; /* the size of the array */
    let mut sax: xmlSAXHandlerPtr =
        0 as *mut xmlSAXHandler; /* the SAX handler block */
    let mut n_sax: std::os::raw::c_int =
        0; /* a NAME* containing the External ID of the DTD */
    let mut input: xmlParserInputBufferPtr =
        0 as
            *mut xmlParserInputBuffer; /* a NAME* containing the URL to the DTD */
    let mut n_input: std::os::raw::c_int = 0; /* the SAX handler block */
    let mut enc: xmlCharEncoding =
        XML_CHAR_ENCODING_NONE; /* a pointer to an array of xmlChar */
    let mut n_enc: std::os::raw::c_int =
        0; /* work in recovery mode, i.e. tries to read no Well Formed documents */
    n_sax = 0 as std::os::raw::c_int; /* the SAX handler block */
    while n_sax < 2 as std::os::raw::c_int {
        n_input = 0 as std::os::raw::c_int; /* the filename */
        while n_input < 8 as std::os::raw::c_int {
            n_enc = 0 as std::os::raw::c_int; /* the SAX handler block */
            while n_enc < 4 as std::os::raw::c_int {
                sax =
                    gen_xmlSAXHandlerPtr(n_sax,
                                         0 as std::os::raw::c_int); /* the filename */
                input =
                    gen_xmlParserInputBufferPtr(n_input,
                                                1 as
                                                    std::os::raw::c_int); /* work in recovery mode, i.e. tries to read no Well Formed documents */
                enc =
                    gen_xmlCharEncoding(n_enc,
                                        2 as
                                            std::os::raw::c_int); /* the SAX handler block */
                ret_val = xmlIOParseDTD(sax, input, enc); /* the filename */
                input =
                    0 as
                        xmlParserInputBufferPtr; /* work in recovery mode, i.e. tries to read no Well Formed documents */
                desret_xmlDtdPtr(ret_val); /* the userdata */
                call_tests += 1; /* the SAX handler block */
                des_xmlSAXHandlerPtr(n_sax, sax,
                                     0 as
                                         std::os::raw::c_int); /* an pointer to a char array */
                des_xmlParserInputBufferPtr(n_input, input,
                                            1 as
                                                std::os::raw::c_int); /* the size of the array */
                des_xmlCharEncoding(n_enc, enc,
                                    2 as
                                        std::os::raw::c_int); /* work in recovery mode, i.e. tries to read not Well Formed documents */
                xmlResetLastError(); /* the SAX handler block */
                n_enc += 1
            } /* an pointer to a char array */
            n_input += 1
        } /* the size of the array */
        n_sax += 1
    } /* work in recovery mode, i.e. tries to read no Well Formed documents */
    function_tests += 1; /* the userdata */
    return test_ret; /* a SAX handler */
}
unsafe extern "C" fn test_xmlInitNodeInfoSeq() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* The user data returned on SAX callbacks */
    let mut mem_base: std::os::raw::c_int = 0; /* a file name */
    let mut seq: xmlParserNodeInfoSeqPtr =
        0 as *mut xmlParserNodeInfoSeq; /* a SAX handler */
    let mut n_seq: std::os::raw::c_int =
        0; /* The user data returned on SAX callbacks */
    n_seq = 0 as std::os::raw::c_int; /* an in-memory XML document input */
    while n_seq < 1 as std::os::raw::c_int {
        mem_base =
            xmlMemBlocks(); /* the length of the XML document in bytes */
        seq = gen_xmlParserNodeInfoSeqPtr(n_seq, 0 as std::os::raw::c_int);
        xmlInitNodeInfoSeq(seq);
        call_tests += 1;
        des_xmlParserNodeInfoSeqPtr(n_seq, seq, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlInitNodeInfoSeq\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_seq);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_seq += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlInitParser() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlInitParser();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlInitParser\x00" as *const u8 as
                   *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlInitParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlInitParserCtxt(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlInitParserCtxt\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlKeepBlanksDefault() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlKeepBlanksDefault(val);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlKeepBlanksDefault\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlLineNumbersDefault() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlLineNumbersDefault(val);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlLineNumbersDefault\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlLoadExternalEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut ID: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_ID: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 8 as std::os::raw::c_int {
        n_ID = 0 as std::os::raw::c_int;
        while n_ID < 4 as std::os::raw::c_int {
            n_ctxt = 0 as std::os::raw::c_int;
            while n_ctxt < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                URL = gen_filepath(n_URL, 0 as std::os::raw::c_int);
                ID = gen_const_char_ptr(n_ID, 1 as std::os::raw::c_int);
                ctxt = gen_xmlParserCtxtPtr(n_ctxt, 2 as std::os::raw::c_int);
                ret_val =
                    xmlLoadExternalEntity(URL, ID as *const std::os::raw::c_char,
                                          ctxt);
                desret_xmlParserInputPtr(ret_val);
                call_tests += 1;
                des_filepath(n_URL, URL, 0 as std::os::raw::c_int);
                des_const_char_ptr(n_ID, ID as *const std::os::raw::c_char,
                                   1 as std::os::raw::c_int);
                des_xmlParserCtxtPtr(n_ctxt, ctxt, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlLoadExternalEntity\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_URL);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ID);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_ctxt += 1
            }
            n_ID += 1
        }
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewIOInputStream() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut n_input: std::os::raw::c_int = 0;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut n_enc: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_input = 0 as std::os::raw::c_int;
        while n_input < 8 as std::os::raw::c_int {
            n_enc = 0 as std::os::raw::c_int;
            while n_enc < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                input =
                    gen_xmlParserInputBufferPtr(n_input, 1 as std::os::raw::c_int);
                enc = gen_xmlCharEncoding(n_enc, 2 as std::os::raw::c_int);
                ret_val = xmlNewIOInputStream(ctxt, input, enc);
                if !ret_val.is_null() { input = 0 as xmlParserInputBufferPtr }
                desret_xmlParserInputPtr(ret_val);
                call_tests += 1;
                des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlParserInputBufferPtr(n_input, input, 1 as std::os::raw::c_int);
                des_xmlCharEncoding(n_enc, enc, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNewIOInputStream\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_input);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_enc);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_enc += 1
            }
            n_input += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    mem_base = xmlMemBlocks();
    ret_val = xmlNewParserCtxt();
    desret_xmlParserCtxtPtr(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlNewParserCtxt\x00" as *const u8
                   as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlNodePtr_ptr(mut no: std::os::raw::c_int,
                                        mut nr: std::os::raw::c_int)
 -> *mut xmlNodePtr {
    return 0 as *mut xmlNodePtr;
}
unsafe extern "C" fn des_xmlNodePtr_ptr(mut no: std::os::raw::c_int,
                                        mut val: *mut xmlNodePtr,
                                        mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlParseBalancedChunkMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut user_data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_user_data: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    let mut string: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_string: std::os::raw::c_int = 0;
    let mut lst: *mut xmlNodePtr = 0 as *mut xmlNodePtr;
    let mut n_lst: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_sax = 0 as std::os::raw::c_int;
        while n_sax < 2 as std::os::raw::c_int {
            n_user_data = 0 as std::os::raw::c_int;
            while n_user_data < 3 as std::os::raw::c_int {
                n_depth = 0 as std::os::raw::c_int;
                while n_depth < 4 as std::os::raw::c_int {
                    n_string = 0 as std::os::raw::c_int;
                    while n_string < 5 as std::os::raw::c_int {
                        n_lst = 0 as std::os::raw::c_int;
                        while n_lst < 1 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                            sax =
                                gen_xmlSAXHandlerPtr(n_sax, 1 as std::os::raw::c_int);
                            user_data =
                                gen_userdata(n_user_data, 2 as std::os::raw::c_int);
                            depth = gen_int(n_depth, 3 as std::os::raw::c_int);
                            string =
                                gen_const_xmlChar_ptr(n_string,
                                                      4 as std::os::raw::c_int);
                            lst = gen_xmlNodePtr_ptr(n_lst, 5 as std::os::raw::c_int);
                            if sax ==
                                   __xmlDefaultSAXHandler() as
                                       xmlSAXHandlerPtr {
                                user_data = 0 as *mut std::os::raw::c_void
                            }
                            ret_val =
                                xmlParseBalancedChunkMemory(doc, sax,
                                                            user_data, depth,
                                                            string as
                                                                *const xmlChar,
                                                            lst);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                            des_xmlSAXHandlerPtr(n_sax, sax,
                                                 1 as std::os::raw::c_int);
                            des_userdata(n_user_data, user_data,
                                         2 as std::os::raw::c_int);
                            des_int(n_depth, depth, 3 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_string,
                                                  string as *const xmlChar,
                                                  4 as std::os::raw::c_int);
                            des_xmlNodePtr_ptr(n_lst, lst, 5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlParseBalancedChunkMemory\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_doc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_sax);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_user_data);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_depth);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_string);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_lst);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_lst += 1
                        }
                        n_string += 1
                    }
                    n_depth += 1
                }
                n_user_data += 1
            }
            n_sax += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseBalancedChunkMemoryRecover()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut user_data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_user_data: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    let mut string: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_string: std::os::raw::c_int = 0;
    let mut lst: *mut xmlNodePtr = 0 as *mut xmlNodePtr;
    let mut n_lst: std::os::raw::c_int = 0;
    let mut recover: std::os::raw::c_int = 0;
    let mut n_recover: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_sax = 0 as std::os::raw::c_int;
        while n_sax < 2 as std::os::raw::c_int {
            n_user_data = 0 as std::os::raw::c_int;
            while n_user_data < 3 as std::os::raw::c_int {
                n_depth = 0 as std::os::raw::c_int;
                while n_depth < 4 as std::os::raw::c_int {
                    n_string = 0 as std::os::raw::c_int;
                    while n_string < 5 as std::os::raw::c_int {
                        n_lst = 0 as std::os::raw::c_int;
                        while n_lst < 1 as std::os::raw::c_int {
                            n_recover = 0 as std::os::raw::c_int;
                            while n_recover < 4 as std::os::raw::c_int {
                                mem_base = xmlMemBlocks();
                                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                                sax =
                                    gen_xmlSAXHandlerPtr(n_sax,
                                                         1 as std::os::raw::c_int);
                                user_data =
                                    gen_userdata(n_user_data,
                                                 2 as std::os::raw::c_int);
                                depth = gen_int(n_depth, 3 as std::os::raw::c_int);
                                string =
                                    gen_const_xmlChar_ptr(n_string,
                                                          4 as std::os::raw::c_int);
                                lst =
                                    gen_xmlNodePtr_ptr(n_lst,
                                                       5 as std::os::raw::c_int);
                                recover =
                                    gen_int(n_recover, 6 as std::os::raw::c_int);
                                if sax ==
                                       __xmlDefaultSAXHandler() as
                                           xmlSAXHandlerPtr {
                                    user_data = 0 as *mut std::os::raw::c_void
                                }
                                ret_val =
                                    xmlParseBalancedChunkMemoryRecover(doc,
                                                                       sax,
                                                                       user_data,
                                                                       depth,
                                                                       string
                                                                           as
                                                                           *const xmlChar,
                                                                       lst,
                                                                       recover);
                                desret_int(ret_val);
                                call_tests += 1;
                                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                                des_xmlSAXHandlerPtr(n_sax, sax,
                                                     1 as std::os::raw::c_int);
                                des_userdata(n_user_data, user_data,
                                             2 as std::os::raw::c_int);
                                des_int(n_depth, depth, 3 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_string,
                                                      string as
                                                          *const xmlChar,
                                                      4 as std::os::raw::c_int);
                                des_xmlNodePtr_ptr(n_lst, lst,
                                                   5 as std::os::raw::c_int);
                                des_int(n_recover, recover, 6 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in xmlParseBalancedChunkMemoryRecover\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_doc);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_sax);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_user_data);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_depth);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_string);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_lst);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_recover);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                                n_recover += 1
                            }
                            n_lst += 1
                        }
                        n_string += 1
                    }
                    n_depth += 1
                }
                n_user_data += 1
            }
            n_sax += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseChunk() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut chunk: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_chunk: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut terminate: std::os::raw::c_int = 0;
    let mut n_terminate: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_chunk = 0 as std::os::raw::c_int;
        while n_chunk < 4 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 4 as std::os::raw::c_int {
                n_terminate = 0 as std::os::raw::c_int;
                while n_terminate < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    chunk = gen_const_char_ptr(n_chunk, 1 as std::os::raw::c_int);
                    size = gen_int(n_size, 2 as std::os::raw::c_int);
                    terminate = gen_int(n_terminate, 3 as std::os::raw::c_int);
                    if !(!chunk.is_null() &&
                             size >
                                 strlen(chunk as *const std::os::raw::c_char) as
                                     std::os::raw::c_int + 1 as std::os::raw::c_int) {
                        ret_val =
                            xmlParseChunk(ctxt, chunk as *const std::os::raw::c_char,
                                          size, terminate);
                        if !ctxt.is_null() {
                            xmlFreeDoc((*ctxt).myDoc);
                            (*ctxt).myDoc = 0 as xmlDocPtr
                        }
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                        des_const_char_ptr(n_chunk,
                                           chunk as *const std::os::raw::c_char,
                                           1 as std::os::raw::c_int);
                        des_int(n_size, size, 2 as std::os::raw::c_int);
                        des_int(n_terminate, terminate, 3 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlParseChunk\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ctxt);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_chunk);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_size);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_terminate);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                    }
                    n_terminate += 1
                }
                n_size += 1
            }
            n_chunk += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseCtxtExternalEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctx: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut URL: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut ID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ID: std::os::raw::c_int = 0;
    let mut lst: *mut xmlNodePtr = 0 as *mut xmlNodePtr;
    let mut n_lst: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 3 as std::os::raw::c_int {
        n_URL = 0 as std::os::raw::c_int;
        while n_URL < 5 as std::os::raw::c_int {
            n_ID = 0 as std::os::raw::c_int;
            while n_ID < 5 as std::os::raw::c_int {
                n_lst = 0 as std::os::raw::c_int;
                while n_lst < 1 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctx = gen_xmlParserCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
                    URL = gen_const_xmlChar_ptr(n_URL, 1 as std::os::raw::c_int);
                    ID = gen_const_xmlChar_ptr(n_ID, 2 as std::os::raw::c_int);
                    lst = gen_xmlNodePtr_ptr(n_lst, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlParseCtxtExternalEntity(ctx, URL as *const xmlChar,
                                                   ID as *const xmlChar, lst);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlParserCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_URL, URL as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_ID, ID as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_xmlNodePtr_ptr(n_lst, lst, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlParseCtxtExternalEntity\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_URL);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ID);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_lst);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_lst += 1
                }
                n_ID += 1
            }
            n_URL += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseDTD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_SystemID: std::os::raw::c_int = 0;
    n_ExternalID = 0 as std::os::raw::c_int;
    while n_ExternalID < 5 as std::os::raw::c_int {
        n_SystemID = 0 as std::os::raw::c_int;
        while n_SystemID < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ExternalID =
                gen_const_xmlChar_ptr(n_ExternalID, 0 as std::os::raw::c_int);
            SystemID = gen_const_xmlChar_ptr(n_SystemID, 1 as std::os::raw::c_int);
            ret_val =
                xmlParseDTD(ExternalID as *const xmlChar,
                            SystemID as *const xmlChar);
            desret_xmlDtdPtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_ExternalID, ExternalID as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_SystemID, SystemID as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParseDTD\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ExternalID);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_SystemID);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_SystemID += 1
        }
        n_ExternalID += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlParseDoc(cur as *const xmlChar);
        desret_xmlDocPtr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_cur, cur as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParseDoc\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseDocument() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlParseDocument(ctxt);
        if !ctxt.is_null() {
            xmlFreeDoc((*ctxt).myDoc);
            (*ctxt).myDoc = 0 as xmlDocPtr
        }
        desret_int(ret_val);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParseDocument\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlParseEntity(filename);
        desret_xmlDocPtr(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParseEntity\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseExtParsedEnt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlParseExtParsedEnt(ctxt);
        if !ctxt.is_null() {
            xmlFreeDoc((*ctxt).myDoc);
            (*ctxt).myDoc = 0 as xmlDocPtr
        }
        desret_int(ret_val);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParseExtParsedEnt\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseExternalEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut user_data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_user_data: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    let mut URL: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut ID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ID: std::os::raw::c_int = 0;
    let mut lst: *mut xmlNodePtr = 0 as *mut xmlNodePtr;
    let mut n_lst: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_sax = 0 as std::os::raw::c_int;
        while n_sax < 2 as std::os::raw::c_int {
            n_user_data = 0 as std::os::raw::c_int;
            while n_user_data < 3 as std::os::raw::c_int {
                n_depth = 0 as std::os::raw::c_int;
                while n_depth < 4 as std::os::raw::c_int {
                    n_URL = 0 as std::os::raw::c_int;
                    while n_URL < 5 as std::os::raw::c_int {
                        n_ID = 0 as std::os::raw::c_int;
                        while n_ID < 5 as std::os::raw::c_int {
                            n_lst = 0 as std::os::raw::c_int;
                            while n_lst < 1 as std::os::raw::c_int {
                                mem_base = xmlMemBlocks();
                                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                                sax =
                                    gen_xmlSAXHandlerPtr(n_sax,
                                                         1 as std::os::raw::c_int);
                                user_data =
                                    gen_userdata(n_user_data,
                                                 2 as std::os::raw::c_int);
                                depth = gen_int(n_depth, 3 as std::os::raw::c_int);
                                URL =
                                    gen_const_xmlChar_ptr(n_URL,
                                                          4 as std::os::raw::c_int);
                                ID =
                                    gen_const_xmlChar_ptr(n_ID,
                                                          5 as std::os::raw::c_int);
                                lst =
                                    gen_xmlNodePtr_ptr(n_lst,
                                                       6 as std::os::raw::c_int);
                                ret_val =
                                    xmlParseExternalEntity(doc, sax,
                                                           user_data, depth,
                                                           URL as
                                                               *const xmlChar,
                                                           ID as
                                                               *const xmlChar,
                                                           lst);
                                desret_int(ret_val);
                                call_tests += 1;
                                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                                des_xmlSAXHandlerPtr(n_sax, sax,
                                                     1 as std::os::raw::c_int);
                                des_userdata(n_user_data, user_data,
                                             2 as std::os::raw::c_int);
                                des_int(n_depth, depth, 3 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_URL,
                                                      URL as *const xmlChar,
                                                      4 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_ID,
                                                      ID as *const xmlChar,
                                                      5 as std::os::raw::c_int);
                                des_xmlNodePtr_ptr(n_lst, lst,
                                                   6 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in xmlParseExternalEntity\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_doc);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_sax);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_user_data);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_depth);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_URL);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_ID);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_lst);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                                n_lst += 1
                            }
                            n_ID += 1
                        }
                        n_URL += 1
                    }
                    n_depth += 1
                }
                n_user_data += 1
            }
            n_sax += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlParseFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParseFile\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseInNodeContext() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserErrors = XML_ERR_OK;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_data: std::os::raw::c_int = 0;
    let mut datalen: std::os::raw::c_int = 0;
    let mut n_datalen: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    let mut lst: *mut xmlNodePtr = 0 as *mut xmlNodePtr;
    let mut n_lst: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 4 as std::os::raw::c_int {
            n_datalen = 0 as std::os::raw::c_int;
            while n_datalen < 4 as std::os::raw::c_int {
                n_options = 0 as std::os::raw::c_int;
                while n_options < 5 as std::os::raw::c_int {
                    n_lst = 0 as std::os::raw::c_int;
                    while n_lst < 1 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                        data = gen_const_char_ptr(n_data, 1 as std::os::raw::c_int);
                        datalen = gen_int(n_datalen, 2 as std::os::raw::c_int);
                        options =
                            gen_parseroptions(n_options, 3 as std::os::raw::c_int);
                        lst = gen_xmlNodePtr_ptr(n_lst, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlParseInNodeContext(node,
                                                  data as *const std::os::raw::c_char,
                                                  datalen, options, lst);
                        desret_xmlParserErrors(ret_val);
                        call_tests += 1;
                        des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                        des_const_char_ptr(n_data,
                                           data as *const std::os::raw::c_char,
                                           1 as std::os::raw::c_int);
                        des_int(n_datalen, datalen, 2 as std::os::raw::c_int);
                        des_parseroptions(n_options, options,
                                          3 as std::os::raw::c_int);
                        des_xmlNodePtr_ptr(n_lst, lst, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlParseInNodeContext\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_node);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_data);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_datalen);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_options);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_lst);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_lst += 1
                    }
                    n_options += 1
                }
                n_datalen += 1
            }
            n_data += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buffer = gen_const_char_ptr(n_buffer, 0 as std::os::raw::c_int);
            size = gen_int(n_size, 1 as std::os::raw::c_int);
            if !(!buffer.is_null() &&
                     size >
                         strlen(buffer as *const std::os::raw::c_char) as std::os::raw::c_int
                             + 1 as std::os::raw::c_int) {
                ret_val = xmlParseMemory(buffer as *const std::os::raw::c_char, size);
                desret_xmlDocPtr(ret_val);
                call_tests += 1;
                des_const_char_ptr(n_buffer, buffer as *const std::os::raw::c_char,
                                   0 as std::os::raw::c_int);
                des_int(n_size, size, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlParseMemory\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_size);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_size += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_const_xmlParserNodeInfoPtr(mut no: std::os::raw::c_int,
                                                    mut nr: std::os::raw::c_int)
 -> xmlParserNodeInfoPtr {
    return 0 as xmlParserNodeInfoPtr;
}
unsafe extern "C" fn des_const_xmlParserNodeInfoPtr(mut no: std::os::raw::c_int,
                                                    val: xmlParserNodeInfoPtr,
                                                    mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlParserAddNodeInfo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut info: xmlParserNodeInfoPtr = 0 as *mut xmlParserNodeInfo;
    let mut n_info: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_info = 0 as std::os::raw::c_int;
        while n_info < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            info = gen_const_xmlParserNodeInfoPtr(n_info, 1 as std::os::raw::c_int);
            xmlParserAddNodeInfo(ctxt, info);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_const_xmlParserNodeInfoPtr(n_info, info, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserAddNodeInfo\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_info);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_info += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_const_xmlParserCtxtPtr(mut no: std::os::raw::c_int,
                                                mut nr: std::os::raw::c_int)
 -> xmlParserCtxtPtr {
    return 0 as xmlParserCtxtPtr;
}
unsafe extern "C" fn des_const_xmlParserCtxtPtr(mut no: std::os::raw::c_int,
                                                val: xmlParserCtxtPtr,
                                                mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_const_xmlNodePtr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int) -> xmlNodePtr {
    return 0 as xmlNodePtr;
}
unsafe extern "C" fn des_const_xmlNodePtr(mut no: std::os::raw::c_int,
                                          val: xmlNodePtr,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlParserFindNodeInfo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlParserNodeInfo = 0 as *const xmlParserNodeInfo;
    let mut ctx: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctx: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctx = gen_const_xmlParserCtxtPtr(n_ctx, 0 as std::os::raw::c_int);
            node = gen_const_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            ret_val = xmlParserFindNodeInfo(ctx, node);
            desret_const_xmlParserNodeInfo_ptr(ret_val);
            call_tests += 1;
            des_const_xmlParserCtxtPtr(n_ctx, ctx, 0 as std::os::raw::c_int);
            des_const_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserFindNodeInfo\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_const_xmlParserNodeInfoSeqPtr(mut no: std::os::raw::c_int,
                                                       mut nr: std::os::raw::c_int)
 -> xmlParserNodeInfoSeqPtr {
    return 0 as xmlParserNodeInfoSeqPtr;
}
unsafe extern "C" fn des_const_xmlParserNodeInfoSeqPtr(mut no: std::os::raw::c_int,
                                                       val:
                                                           xmlParserNodeInfoSeqPtr,
                                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlParserFindNodeInfoIndex() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_ulong = 0;
    let mut seq: xmlParserNodeInfoSeqPtr = 0 as *mut xmlParserNodeInfoSeq;
    let mut n_seq: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_seq = 0 as std::os::raw::c_int;
    while n_seq < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            seq = gen_const_xmlParserNodeInfoSeqPtr(n_seq, 0 as std::os::raw::c_int);
            node = gen_const_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            ret_val = xmlParserFindNodeInfoIndex(seq, node);
            desret_unsigned_long(ret_val);
            call_tests += 1;
            des_const_xmlParserNodeInfoSeqPtr(n_seq, seq, 0 as std::os::raw::c_int);
            des_const_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserFindNodeInfoIndex\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_seq);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_seq += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlParserInputPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> xmlParserInputPtr {
    return 0 as xmlParserInputPtr;
}
unsafe extern "C" fn des_xmlParserInputPtr(mut no: std::os::raw::c_int,
                                           mut val: xmlParserInputPtr,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlParserInputGrow() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut n_in: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_in = 0 as std::os::raw::c_int;
    while n_in < 1 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            in_0 = gen_xmlParserInputPtr(n_in, 0 as std::os::raw::c_int);
            len = gen_int(n_len, 1 as std::os::raw::c_int);
            ret_val = xmlParserInputGrow(in_0, len);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserInputPtr(n_in, in_0, 0 as std::os::raw::c_int);
            des_int(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserInputGrow\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_in);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_in += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserInputRead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut n_in: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_in = 0 as std::os::raw::c_int;
    while n_in < 1 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            in_0 = gen_xmlParserInputPtr(n_in, 0 as std::os::raw::c_int);
            len = gen_int(n_len, 1 as std::os::raw::c_int);
            ret_val = xmlParserInputRead(in_0, len);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserInputPtr(n_in, in_0, 0 as std::os::raw::c_int);
            des_int(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserInputRead\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_in);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_in += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPedanticParserDefault() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlPedanticParserDefault(val);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlPedanticParserDefault\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReadDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 5 as std::os::raw::c_int {
        n_URL = 0 as std::os::raw::c_int;
        while n_URL < 8 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                n_options = 0 as std::os::raw::c_int;
                while n_options < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    cur = gen_const_xmlChar_ptr(n_cur, 0 as std::os::raw::c_int);
                    URL = gen_filepath(n_URL, 1 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                    options = gen_parseroptions(n_options, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlReadDoc(cur as *const xmlChar, URL,
                                   encoding as *const std::os::raw::c_char, options);
                    desret_xmlDocPtr(ret_val);
                    call_tests += 1;
                    des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                          0 as std::os::raw::c_int);
                    des_filepath(n_URL, URL, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_parseroptions(n_options, options, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlReadDoc\x00" as
                                   *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_URL);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_options);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_options += 1
                }
                n_encoding += 1
            }
            n_URL += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReadFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        n_encoding = 0 as std::os::raw::c_int;
        while n_encoding < 4 as std::os::raw::c_int {
            n_options = 0 as std::os::raw::c_int;
            while n_options < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
                encoding = gen_const_char_ptr(n_encoding, 1 as std::os::raw::c_int);
                options = gen_parseroptions(n_options, 2 as std::os::raw::c_int);
                ret_val =
                    xmlReadFile(filename, encoding as *const std::os::raw::c_char,
                                options);
                desret_xmlDocPtr(ret_val);
                call_tests += 1;
                des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
                des_const_char_ptr(n_encoding,
                                   encoding as *const std::os::raw::c_char,
                                   1 as std::os::raw::c_int);
                des_parseroptions(n_options, options, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlReadFile\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_encoding);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_options);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_options += 1
            }
            n_encoding += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReadMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            n_URL = 0 as std::os::raw::c_int;
            while n_URL < 8 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    n_options = 0 as std::os::raw::c_int;
                    while n_options < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        buffer =
                            gen_const_char_ptr(n_buffer, 0 as std::os::raw::c_int);
                        size = gen_int(n_size, 1 as std::os::raw::c_int);
                        URL = gen_filepath(n_URL, 2 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                        options =
                            gen_parseroptions(n_options, 4 as std::os::raw::c_int);
                        if !(!buffer.is_null() &&
                                 size >
                                     strlen(buffer as *const std::os::raw::c_char) as
                                         std::os::raw::c_int + 1 as std::os::raw::c_int) {
                            ret_val =
                                xmlReadMemory(buffer as *const std::os::raw::c_char,
                                              size, URL,
                                              encoding as *const std::os::raw::c_char,
                                              options);
                            desret_xmlDocPtr(ret_val);
                            call_tests += 1;
                            des_const_char_ptr(n_buffer,
                                               buffer as *const std::os::raw::c_char,
                                               0 as std::os::raw::c_int);
                            des_int(n_size, size, 1 as std::os::raw::c_int);
                            des_filepath(n_URL, URL, 2 as std::os::raw::c_int);
                            des_const_char_ptr(n_encoding,
                                               encoding as
                                                   *const std::os::raw::c_char,
                                               3 as std::os::raw::c_int);
                            des_parseroptions(n_options, options,
                                              4 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlReadMemory\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_buffer);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_size);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_URL);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_encoding);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_options);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                        }
                        n_options += 1
                    }
                    n_encoding += 1
                }
                n_URL += 1
            }
            n_size += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRecoverDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlRecoverDoc(cur as *const xmlChar);
        desret_xmlDocPtr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_cur, cur as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlRecoverDoc\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRecoverFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlRecoverFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlRecoverFile\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRecoverMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buffer = gen_const_char_ptr(n_buffer, 0 as std::os::raw::c_int);
            size = gen_int(n_size, 1 as std::os::raw::c_int);
            if !(!buffer.is_null() &&
                     size >
                         strlen(buffer as *const std::os::raw::c_char) as std::os::raw::c_int
                             + 1 as std::os::raw::c_int) {
                ret_val =
                    xmlRecoverMemory(buffer as *const std::os::raw::c_char, size);
                desret_xmlDocPtr(ret_val);
                call_tests += 1;
                des_const_char_ptr(n_buffer, buffer as *const std::os::raw::c_char,
                                   0 as std::os::raw::c_int);
                des_int(n_size, size, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlRecoverMemory\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_size);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_size += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXParseDTD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_SystemID: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_ExternalID = 0 as std::os::raw::c_int;
        while n_ExternalID < 5 as std::os::raw::c_int {
            n_SystemID = 0 as std::os::raw::c_int;
            while n_SystemID < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
                ExternalID =
                    gen_const_xmlChar_ptr(n_ExternalID, 1 as std::os::raw::c_int);
                SystemID =
                    gen_const_xmlChar_ptr(n_SystemID, 2 as std::os::raw::c_int);
                ret_val =
                    xmlSAXParseDTD(sax, ExternalID as *const xmlChar,
                                   SystemID as *const xmlChar);
                desret_xmlDtdPtr(ret_val);
                call_tests += 1;
                des_xmlSAXHandlerPtr(n_sax, sax, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_ExternalID,
                                      ExternalID as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_SystemID, SystemID as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSAXParseDTD\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_sax);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ExternalID);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_SystemID);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_SystemID += 1
            }
            n_ExternalID += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXParseDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut recovery: std::os::raw::c_int = 0;
    let mut n_recovery: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 5 as std::os::raw::c_int {
            n_recovery = 0 as std::os::raw::c_int;
            while n_recovery < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
                cur = gen_const_xmlChar_ptr(n_cur, 1 as std::os::raw::c_int);
                recovery = gen_int(n_recovery, 2 as std::os::raw::c_int);
                ret_val =
                    xmlSAXParseDoc(sax, cur as *const xmlChar, recovery);
                desret_xmlDocPtr(ret_val);
                call_tests += 1;
                des_xmlSAXHandlerPtr(n_sax, sax, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_int(n_recovery, recovery, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSAXParseDoc\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_sax);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_recovery);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_recovery += 1
            }
            n_cur += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXParseEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 8 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
            filename = gen_filepath(n_filename, 1 as std::os::raw::c_int);
            ret_val = xmlSAXParseEntity(sax, filename);
            desret_xmlDocPtr(ret_val);
            call_tests += 1;
            des_xmlSAXHandlerPtr(n_sax, sax, 0 as std::os::raw::c_int);
            des_filepath(n_filename, filename, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSAXParseEntity\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_sax);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_filename);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_filename += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXParseFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut recovery: std::os::raw::c_int = 0;
    let mut n_recovery: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 8 as std::os::raw::c_int {
            n_recovery = 0 as std::os::raw::c_int;
            while n_recovery < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
                filename = gen_filepath(n_filename, 1 as std::os::raw::c_int);
                recovery = gen_int(n_recovery, 2 as std::os::raw::c_int);
                ret_val = xmlSAXParseFile(sax, filename, recovery);
                desret_xmlDocPtr(ret_val);
                call_tests += 1;
                des_xmlSAXHandlerPtr(n_sax, sax, 0 as std::os::raw::c_int);
                des_filepath(n_filename, filename, 1 as std::os::raw::c_int);
                des_int(n_recovery, recovery, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSAXParseFile\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_sax);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_recovery);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_recovery += 1
            }
            n_filename += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXParseFileWithData() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut recovery: std::os::raw::c_int = 0;
    let mut n_recovery: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 8 as std::os::raw::c_int {
            n_recovery = 0 as std::os::raw::c_int;
            while n_recovery < 4 as std::os::raw::c_int {
                n_data = 0 as std::os::raw::c_int;
                while n_data < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
                    filename = gen_filepath(n_filename, 1 as std::os::raw::c_int);
                    recovery = gen_int(n_recovery, 2 as std::os::raw::c_int);
                    data = gen_userdata(n_data, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlSAXParseFileWithData(sax, filename, recovery,
                                                data);
                    desret_xmlDocPtr(ret_val);
                    call_tests += 1;
                    des_xmlSAXHandlerPtr(n_sax, sax, 0 as std::os::raw::c_int);
                    des_filepath(n_filename, filename, 1 as std::os::raw::c_int);
                    des_int(n_recovery, recovery, 2 as std::os::raw::c_int);
                    des_userdata(n_data, data, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSAXParseFileWithData\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_sax);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_filename);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_recovery);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_data);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_data += 1
                }
                n_recovery += 1
            }
            n_filename += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXParseMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut recovery: std::os::raw::c_int = 0;
    let mut n_recovery: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 4 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 4 as std::os::raw::c_int {
                n_recovery = 0 as std::os::raw::c_int;
                while n_recovery < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
                    buffer = gen_const_char_ptr(n_buffer, 1 as std::os::raw::c_int);
                    size = gen_int(n_size, 2 as std::os::raw::c_int);
                    recovery = gen_int(n_recovery, 3 as std::os::raw::c_int);
                    if !(!buffer.is_null() &&
                             size >
                                 strlen(buffer as *const std::os::raw::c_char) as
                                     std::os::raw::c_int + 1 as std::os::raw::c_int) {
                        ret_val =
                            xmlSAXParseMemory(sax,
                                              buffer as *const std::os::raw::c_char,
                                              size, recovery);
                        desret_xmlDocPtr(ret_val);
                        call_tests += 1;
                        des_xmlSAXHandlerPtr(n_sax, sax, 0 as std::os::raw::c_int);
                        des_const_char_ptr(n_buffer,
                                           buffer as *const std::os::raw::c_char,
                                           1 as std::os::raw::c_int);
                        des_int(n_size, size, 2 as std::os::raw::c_int);
                        des_int(n_recovery, recovery, 3 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlSAXParseMemory\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_sax);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_buffer);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_size);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_recovery);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                    }
                    n_recovery += 1
                }
                n_size += 1
            }
            n_buffer += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXParseMemoryWithData() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut recovery: std::os::raw::c_int = 0;
    let mut n_recovery: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 4 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 4 as std::os::raw::c_int {
                n_recovery = 0 as std::os::raw::c_int;
                while n_recovery < 4 as std::os::raw::c_int {
                    n_data = 0 as std::os::raw::c_int;
                    while n_data < 3 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
                        buffer =
                            gen_const_char_ptr(n_buffer, 1 as std::os::raw::c_int);
                        size = gen_int(n_size, 2 as std::os::raw::c_int);
                        recovery = gen_int(n_recovery, 3 as std::os::raw::c_int);
                        data = gen_userdata(n_data, 4 as std::os::raw::c_int);
                        if !(!buffer.is_null() &&
                                 size >
                                     strlen(buffer as *const std::os::raw::c_char) as
                                         std::os::raw::c_int + 1 as std::os::raw::c_int) {
                            ret_val =
                                xmlSAXParseMemoryWithData(sax,
                                                          buffer as
                                                              *const std::os::raw::c_char,
                                                          size, recovery,
                                                          data);
                            desret_xmlDocPtr(ret_val);
                            call_tests += 1;
                            des_xmlSAXHandlerPtr(n_sax, sax,
                                                 0 as std::os::raw::c_int);
                            des_const_char_ptr(n_buffer,
                                               buffer as *const std::os::raw::c_char,
                                               1 as std::os::raw::c_int);
                            des_int(n_size, size, 2 as std::os::raw::c_int);
                            des_int(n_recovery, recovery, 3 as std::os::raw::c_int);
                            des_userdata(n_data, data, 4 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlSAXParseMemoryWithData\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_sax);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_buffer);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_size);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_recovery);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_data);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                        }
                        n_data += 1
                    }
                    n_recovery += 1
                }
                n_size += 1
            }
            n_buffer += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXUserParseFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut user_data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_user_data: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_user_data = 0 as std::os::raw::c_int;
        while n_user_data < 3 as std::os::raw::c_int {
            n_filename = 0 as std::os::raw::c_int;
            while n_filename < 8 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
                user_data = gen_userdata(n_user_data, 1 as std::os::raw::c_int);
                filename = gen_filepath(n_filename, 2 as std::os::raw::c_int);
                if sax == __xmlDefaultSAXHandler() as xmlSAXHandlerPtr {
                    user_data = 0 as *mut std::os::raw::c_void
                }
                ret_val = xmlSAXUserParseFile(sax, user_data, filename);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlSAXHandlerPtr(n_sax, sax, 0 as std::os::raw::c_int);
                des_userdata(n_user_data, user_data, 1 as std::os::raw::c_int);
                des_filepath(n_filename, filename, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSAXUserParseFile\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_sax);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_user_data);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_filename += 1
            }
            n_user_data += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSAXUserParseMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    let mut n_sax: std::os::raw::c_int = 0;
    let mut user_data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_user_data: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    n_sax = 0 as std::os::raw::c_int;
    while n_sax < 2 as std::os::raw::c_int {
        n_user_data = 0 as std::os::raw::c_int;
        while n_user_data < 3 as std::os::raw::c_int {
            n_buffer = 0 as std::os::raw::c_int;
            while n_buffer < 4 as std::os::raw::c_int {
                n_size = 0 as std::os::raw::c_int;
                while n_size < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    sax = gen_xmlSAXHandlerPtr(n_sax, 0 as std::os::raw::c_int);
                    user_data = gen_userdata(n_user_data, 1 as std::os::raw::c_int);
                    buffer = gen_const_char_ptr(n_buffer, 2 as std::os::raw::c_int);
                    size = gen_int(n_size, 3 as std::os::raw::c_int);
                    if !(!buffer.is_null() &&
                             size >
                                 strlen(buffer as *const std::os::raw::c_char) as
                                     std::os::raw::c_int + 1 as std::os::raw::c_int) {
                        if sax == __xmlDefaultSAXHandler() as xmlSAXHandlerPtr
                           {
                            user_data = 0 as *mut std::os::raw::c_void
                        }
                        ret_val =
                            xmlSAXUserParseMemory(sax, user_data,
                                                  buffer as
                                                      *const std::os::raw::c_char,
                                                  size);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlSAXHandlerPtr(n_sax, sax, 0 as std::os::raw::c_int);
                        des_userdata(n_user_data, user_data,
                                     1 as std::os::raw::c_int);
                        des_const_char_ptr(n_buffer,
                                           buffer as *const std::os::raw::c_char,
                                           2 as std::os::raw::c_int);
                        des_int(n_size, size, 3 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlSAXUserParseMemory\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_sax);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_user_data);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_buffer);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_size);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                    }
                    n_size += 1
                }
                n_buffer += 1
            }
            n_user_data += 1
        }
        n_sax += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSetExternalEntityLoader() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an XML/HTML parser context */
}
unsafe extern "C" fn test_xmlSetFeature() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the feature name */
    let mut mem_base: std::os::raw::c_int =
        0; /* pointer to the location of the new value */
    let mut ret_val: std::os::raw::c_int = 0; /* an XML parser context */
    let mut ctxt: xmlParserCtxtPtr =
        0 as *mut xmlParserCtxt; /* a xmlChar * buffer */
    let mut n_ctxt: std::os::raw::c_int = 0; /* a file name */
    let mut name: *mut std::os::raw::c_char =
        0 as *mut std::os::raw::c_char; /* an XML parser context */
    let mut n_name: std::os::raw::c_int = 0; /* int 0 or 1 */
    let mut value: *mut std::os::raw::c_void =
        0 as *mut std::os::raw::c_void; /* the filename */
    let mut n_value: std::os::raw::c_int =
        0; /* a free form C string describing the HTML document encoding, or NULL */
    n_ctxt = 0 as std::os::raw::c_int; /* an XML parser context */
    while n_ctxt < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* an XML parser context */
        while n_name < 4 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int; /* the parser input */
            while n_value < 2 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* an XML parser context */
                ctxt =
                    gen_xmlParserCtxtPtr(n_ctxt,
                                         0 as
                                             std::os::raw::c_int); /* an XML parser context */
                name =
                    gen_const_char_ptr(n_name,
                                       1 as
                                           std::os::raw::c_int); /* the element name */
                value =
                    gen_void_ptr(n_value,
                                 2 as
                                     std::os::raw::c_int); /* an XML parser context */
                ret_val =
                    xmlSetFeature(ctxt, name as *const std::os::raw::c_char,
                                  value); /* an XML parser context */
                desret_int(ret_val); /* the element node */
                call_tests += 1; /* pointer to the string value */
                des_xmlParserCtxtPtr(n_ctxt, ctxt,
                                     0 as
                                         std::os::raw::c_int); /* Ignored, compatibility */
                des_const_char_ptr(n_name, name as *const std::os::raw::c_char,
                                   1 as
                                       std::os::raw::c_int); /* pointer to an array of xmlChar */
                des_void_ptr(n_value, value,
                             2 as std::os::raw::c_int); /* the char value */
                xmlResetLastError(); /* pointer to an array of xmlChar */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSetFeature\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base); /* the char value */
                    test_ret += 1; /* the entity URL */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt); /* the entity PUBLIC ID */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name); /* a possible base for the target URI */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_value); /* the filename */
                    printf(b"\n\x00" as *const u8 as
                               *const std::os::raw::c_char); /* a pointer to a char array */
                } /* the size of the array */
                n_value += 1
            } /* the filename or URL */
            n_name += 1
        } /* a combination of xmlParserOption */
        n_ctxt += 1
    } /* the XML parser context */
    function_tests += 1; /* pointer to the length of the char read */
    return test_ret; /* an XML parser context */
}
unsafe extern "C" fn test_xmlSetupParserForBuffer() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* extra informations */
    let mut mem_base: std::os::raw::c_int = 0; /* an unicode character (int) */
    let mut ctxt: xmlParserCtxtPtr =
        0 as *mut xmlParserCtxt; /* an XML parser context */
    let mut n_ctxt: std::os::raw::c_int = 0; /* an Entity pointer */
    let mut buffer: *mut xmlChar =
        0 as *mut xmlChar; /* an XML parser context */
    let mut n_buffer: std::os::raw::c_int = 0; /* the filename to use as entity */
    let mut filename: *const std::os::raw::c_char =
        0 as *const std::os::raw::c_char; /* an XML parser context */
    let mut n_filename: std::os::raw::c_int = 0; /* an XML parser context */
    n_ctxt = 0 as std::os::raw::c_int; /* an memory buffer */
    while n_ctxt < 3 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int; /* the XML parser context */
        while n_buffer < 5 as std::os::raw::c_int {
            n_filename = 0 as std::os::raw::c_int; /* an XML parser input */
            while n_filename < 8 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* an XML parser context */
                ctxt =
                    gen_xmlParserCtxtPtr(n_ctxt,
                                         0 as
                                             std::os::raw::c_int); /* an XML parser context */
                buffer =
                    gen_const_xmlChar_ptr(n_buffer,
                                          1 as
                                              std::os::raw::c_int); /* an XML parser input fragment (entity, XML fragment ...). */
                filename = gen_filepath(n_filename, 2 as std::os::raw::c_int);
                xmlSetupParserForBuffer(ctxt, buffer as *const xmlChar,
                                        filename);
                call_tests += 1;
                des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_buffer, buffer as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_filepath(n_filename, filename, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSetupParserForBuffer\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_filename += 1
            }
            n_buffer += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStopParser() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlStopParser(ctxt);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlStopParser\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSubstituteEntitiesDefault() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlSubstituteEntitiesDefault(val);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSubstituteEntitiesDefault\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_parser() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing parser : 61 of 70 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlByteConsumed();
    test_ret += test_xmlClearNodeInfoSeq();
    test_ret += test_xmlClearParserCtxt();
    test_ret += test_xmlCreateDocParserCtxt();
    test_ret += test_xmlCreatePushParserCtxt();
    test_ret += test_xmlCtxtReadDoc();
    test_ret += test_xmlCtxtReadFile();
    test_ret += test_xmlCtxtReadMemory();
    test_ret += test_xmlCtxtReset();
    test_ret += test_xmlCtxtResetPush();
    test_ret += test_xmlCtxtUseOptions();
    test_ret += test_xmlGetExternalEntityLoader();
    test_ret += test_xmlGetFeature();
    test_ret += test_xmlGetFeaturesList();
    test_ret += test_xmlHasFeature();
    test_ret += test_xmlIOParseDTD();
    test_ret += test_xmlInitNodeInfoSeq();
    test_ret += test_xmlInitParser();
    test_ret += test_xmlInitParserCtxt();
    test_ret += test_xmlKeepBlanksDefault();
    test_ret += test_xmlLineNumbersDefault();
    test_ret += test_xmlLoadExternalEntity();
    test_ret += test_xmlNewIOInputStream();
    test_ret += test_xmlNewParserCtxt();
    test_ret += test_xmlParseBalancedChunkMemory();
    test_ret += test_xmlParseBalancedChunkMemoryRecover();
    test_ret += test_xmlParseChunk();
    test_ret += test_xmlParseCtxtExternalEntity();
    test_ret += test_xmlParseDTD();
    test_ret += test_xmlParseDoc();
    test_ret += test_xmlParseDocument();
    test_ret += test_xmlParseEntity();
    test_ret += test_xmlParseExtParsedEnt();
    test_ret += test_xmlParseExternalEntity();
    test_ret += test_xmlParseFile();
    test_ret += test_xmlParseInNodeContext();
    test_ret += test_xmlParseMemory();
    test_ret += test_xmlParserAddNodeInfo();
    test_ret += test_xmlParserFindNodeInfo();
    test_ret += test_xmlParserFindNodeInfoIndex();
    test_ret += test_xmlParserInputGrow();
    test_ret += test_xmlParserInputRead();
    test_ret += test_xmlPedanticParserDefault();
    test_ret += test_xmlReadDoc();
    test_ret += test_xmlReadFile();
    test_ret += test_xmlReadMemory();
    test_ret += test_xmlRecoverDoc();
    test_ret += test_xmlRecoverFile();
    test_ret += test_xmlRecoverMemory();
    test_ret += test_xmlSAXParseDTD();
    test_ret += test_xmlSAXParseDoc();
    test_ret += test_xmlSAXParseEntity();
    test_ret += test_xmlSAXParseFile();
    test_ret += test_xmlSAXParseFileWithData();
    test_ret += test_xmlSAXParseMemory();
    test_ret += test_xmlSAXParseMemoryWithData();
    test_ret += test_xmlSAXUserParseFile();
    test_ret += test_xmlSAXUserParseMemory();
    test_ret += test_xmlSetExternalEntityLoader();
    test_ret += test_xmlSetFeature();
    test_ret += test_xmlSetupParserForBuffer();
    test_ret += test_xmlStopParser();
    test_ret += test_xmlSubstituteEntitiesDefault();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module parser: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_htmlCreateFileParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        n_encoding = 0 as std::os::raw::c_int;
        while n_encoding < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
            encoding = gen_const_char_ptr(n_encoding, 1 as std::os::raw::c_int);
            ret_val =
                htmlCreateFileParserCtxt(filename,
                                         encoding as *const std::os::raw::c_char);
            desret_htmlParserCtxtPtr(ret_val);
            call_tests += 1;
            des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_encoding, encoding as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in htmlCreateFileParserCtxt\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_filename);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_encoding);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_encoding += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_htmlInitAutoClose() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    htmlInitAutoClose();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in htmlInitAutoClose\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_inputPop() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = inputPop(ctxt);
        desret_xmlParserInputPtr(ret_val);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in inputPop\x00" as *const u8 as
                       *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_inputPush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut value: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut n_value: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            value = gen_xmlParserInputPtr(n_value, 1 as std::os::raw::c_int);
            ret_val = inputPush(ctxt, value);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlParserInputPtr(n_value, value, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in inputPush\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_value += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_namePop() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = namePop(ctxt);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in namePop\x00" as *const u8 as
                       *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_namePush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
            ret_val = namePush(ctxt, value as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in namePush\x00" as *const u8
                           as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_value += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_nodePop() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = nodePop(ctxt);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in nodePop\x00" as *const u8 as
                       *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_nodePush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut value: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_value: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            value = gen_xmlNodePtr(n_value, 1 as std::os::raw::c_int);
            ret_val = nodePush(ctxt, value);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_value, value, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in nodePush\x00" as *const u8
                           as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_value += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCheckLanguageID() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut lang: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_lang: std::os::raw::c_int = 0;
    n_lang = 0 as std::os::raw::c_int;
    while n_lang < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        lang = gen_const_xmlChar_ptr(n_lang, 0 as std::os::raw::c_int);
        ret_val = xmlCheckLanguageID(lang as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_lang, lang as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCheckLanguageID\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_lang);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_lang += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    let mut out: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_out: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_len = 0 as std::os::raw::c_int;
    while n_len < 4 as std::os::raw::c_int {
        n_out = 0 as std::os::raw::c_int;
        while n_out < 2 as std::os::raw::c_int {
            n_val = 0 as std::os::raw::c_int;
            while n_val < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                len = gen_int(n_len, 0 as std::os::raw::c_int);
                out = gen_xmlChar_ptr(n_out, 1 as std::os::raw::c_int);
                val = gen_int(n_val, 2 as std::os::raw::c_int);
                ret_val = xmlCopyChar(len, out, val);
                desret_int(ret_val);
                call_tests += 1;
                des_int(n_len, len, 0 as std::os::raw::c_int);
                des_xmlChar_ptr(n_out, out, 1 as std::os::raw::c_int);
                des_int(n_val, val, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlCopyChar\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_out);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_val);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_val += 1
            }
            n_out += 1
        }
        n_len += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyCharMultiByte() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut out: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_out: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 2 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            out = gen_xmlChar_ptr(n_out, 0 as std::os::raw::c_int);
            val = gen_int(n_val, 1 as std::os::raw::c_int);
            ret_val = xmlCopyCharMultiByte(out, val);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlChar_ptr(n_out, out, 0 as std::os::raw::c_int);
            des_int(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCopyCharMultiByte\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_out);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCreateEntityParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut URL: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut ID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ID: std::os::raw::c_int = 0;
    let mut base: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_base: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 5 as std::os::raw::c_int {
        n_ID = 0 as std::os::raw::c_int;
        while n_ID < 5 as std::os::raw::c_int {
            n_base = 0 as std::os::raw::c_int;
            while n_base < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                URL = gen_const_xmlChar_ptr(n_URL, 0 as std::os::raw::c_int);
                ID = gen_const_xmlChar_ptr(n_ID, 1 as std::os::raw::c_int);
                base = gen_const_xmlChar_ptr(n_base, 2 as std::os::raw::c_int);
                ret_val =
                    xmlCreateEntityParserCtxt(URL as *const xmlChar,
                                              ID as *const xmlChar,
                                              base as *const xmlChar);
                desret_xmlParserCtxtPtr(ret_val);
                call_tests += 1;
                des_const_xmlChar_ptr(n_URL, URL as *const xmlChar,
                                      0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_ID, ID as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_base, base as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlCreateEntityParserCtxt\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_URL);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ID);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_base);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_base += 1
            }
            n_ID += 1
        }
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCreateFileParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlCreateFileParserCtxt(filename);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests += 1;
        des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCreateFileParserCtxt\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCreateMemoryParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buffer = gen_const_char_ptr(n_buffer, 0 as std::os::raw::c_int);
            size = gen_int(n_size, 1 as std::os::raw::c_int);
            if !(!buffer.is_null() &&
                     size >
                         strlen(buffer as *const std::os::raw::c_char) as std::os::raw::c_int
                             + 1 as std::os::raw::c_int) {
                ret_val =
                    xmlCreateMemoryParserCtxt(buffer as *const std::os::raw::c_char,
                                              size);
                desret_xmlParserCtxtPtr(ret_val);
                call_tests += 1;
                des_const_char_ptr(n_buffer, buffer as *const std::os::raw::c_char,
                                   0 as std::os::raw::c_int);
                des_int(n_size, size, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlCreateMemoryParserCtxt\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_size);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_size += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCreateURLParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        n_options = 0 as std::os::raw::c_int;
        while n_options < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
            options = gen_int(n_options, 1 as std::os::raw::c_int);
            ret_val = xmlCreateURLParserCtxt(filename, options);
            desret_xmlParserCtxtPtr(ret_val);
            call_tests += 1;
            des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
            des_int(n_options, options, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCreateURLParserCtxt\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_filename);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_options);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_options += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCurrentChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut len: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            len = gen_int_ptr(n_len, 1 as std::os::raw::c_int);
            ret_val = xmlCurrentChar(ctxt, len);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int_ptr(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCurrentChar\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlErrMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut extra: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_extra: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_extra = 0 as std::os::raw::c_int;
        while n_extra < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            extra = gen_const_char_ptr(n_extra, 1 as std::os::raw::c_int);
            xmlErrMemory(ctxt, extra as *const std::os::raw::c_char);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_extra, extra as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlErrMemory\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_extra);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_extra += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsLetter() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_int = 0;
    let mut n_c: std::os::raw::c_int = 0;
    n_c = 0 as std::os::raw::c_int;
    while n_c < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        c = gen_int(n_c, 0 as std::os::raw::c_int);
        ret_val = xmlIsLetter(c);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_c, c, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsLetter\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_c);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_c += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewEntityInputStream() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut entity: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut n_entity: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_entity = 0 as std::os::raw::c_int;
        while n_entity < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            entity = gen_xmlEntityPtr(n_entity, 1 as std::os::raw::c_int);
            ret_val = xmlNewEntityInputStream(ctxt, entity);
            desret_xmlParserInputPtr(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlEntityPtr(n_entity, entity, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewEntityInputStream\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_entity);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_entity += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewInputFromFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 8 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            filename = gen_filepath(n_filename, 1 as std::os::raw::c_int);
            ret_val = xmlNewInputFromFile(ctxt, filename);
            desret_xmlParserInputPtr(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_filepath(n_filename, filename, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewInputFromFile\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_filename);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_filename += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewInputStream() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlNewInputStream(ctxt);
        desret_xmlParserInputPtr(ret_val);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNewInputStream\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewStringInputStream() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut buffer: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_buffer: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            buffer = gen_const_xmlChar_ptr(n_buffer, 1 as std::os::raw::c_int);
            ret_val = xmlNewStringInputStream(ctxt, buffer as *const xmlChar);
            desret_xmlParserInputPtr(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_buffer, buffer as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewStringInputStream\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_buffer);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_buffer += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNextChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlNextChar(ctxt);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNextChar\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserInputShrink() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut n_in: std::os::raw::c_int = 0;
    n_in = 0 as std::os::raw::c_int;
    while n_in < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        in_0 = gen_xmlParserInputPtr(n_in, 0 as std::os::raw::c_int);
        xmlParserInputShrink(in_0);
        call_tests += 1;
        des_xmlParserInputPtr(n_in, in_0, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParserInputShrink\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_in);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_in += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPopInput() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlChar = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlPopInput(ctxt);
        desret_xmlChar(ret_val);
        call_tests += 1;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlPopInput\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPushInput() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut n_input: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_input = 0 as std::os::raw::c_int;
        while n_input < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            input = gen_xmlParserInputPtr(n_input, 1 as std::os::raw::c_int);
            ret_val = xmlPushInput(ctxt, input);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlParserInputPtr(n_input, input, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlPushInput\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_input);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_input += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSetEntityReferenceFunc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an XML parser context */
}
unsafe extern "C" fn test_xmlSplitQName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* an XML parser context */
    let mut mem_base: std::os::raw::c_int = 0; /* a xmlChar ** */
    let mut ret_val: *mut xmlChar =
        0 as *mut xmlChar; /* the XML parser context */
    let mut ctxt: xmlParserCtxtPtr =
        0 as *mut xmlParserCtxt; /* pointer to the beginning of the char */
    let mut n_ctxt: std::os::raw::c_int =
        0; /* pointer to the length of the char read */
    let mut name: *mut xmlChar = 0 as *mut xmlChar; /* the parser context */
    let mut n_name: std::os::raw::c_int = 0; /* the input string */
    let mut prefix: *mut *mut xmlChar =
        0 as
            *mut *mut xmlChar; /* combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF */
    let mut n_prefix: std::os::raw::c_int = 0; /* an end marker xmlChar, 0 if none */
    n_ctxt = 0 as std::os::raw::c_int; /* an end marker xmlChar, 0 if none */
    while n_ctxt < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* an end marker xmlChar, 0 if none */
        while n_name < 5 as std::os::raw::c_int {
            n_prefix = 0 as std::os::raw::c_int; /* the parser context */
            while n_prefix < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* the input string */
                ctxt =
                    gen_xmlParserCtxtPtr(n_ctxt,
                                         0 as
                                             std::os::raw::c_int); /* the string length */
                name =
                    gen_const_xmlChar_ptr(n_name,
                                          1 as
                                              std::os::raw::c_int); /* combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF */
                prefix =
                    gen_xmlChar_ptr_ptr(n_prefix,
                                        2 as
                                            std::os::raw::c_int); /* an end marker xmlChar, 0 if none */
                ret_val =
                    xmlSplitQName(ctxt, name as *const xmlChar,
                                  prefix); /* an end marker xmlChar, 0 if none */
                desret_xmlChar_ptr(ret_val); /* an end marker xmlChar, 0 if none */
                call_tests += 1; /* the parser context */
                des_xmlParserCtxtPtr(n_ctxt, ctxt,
                                     0 as
                                         std::os::raw::c_int); /* the encoding value (number) */
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as
                                          std::os::raw::c_int); /* the parser context */
                des_xmlChar_ptr_ptr(n_prefix, prefix,
                                    2 as std::os::raw::c_int); /* the input stream */
                xmlResetLastError(); /* the encoding handler */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSplitQName\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() -
                               mem_base); /* the parser context */
                    test_ret += 1; /* the encoding handler */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt); /* the precompiled pattern */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_prefix);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_prefix += 1
            }
            n_name += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStringCurrentChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut len: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 2 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                cur = gen_const_xmlChar_ptr(n_cur, 1 as std::os::raw::c_int);
                len = gen_int_ptr(n_len, 2 as std::os::raw::c_int);
                ret_val =
                    xmlStringCurrentChar(ctxt, cur as *const xmlChar, len);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_int_ptr(n_len, len, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlStringCurrentChar\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_len += 1
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStringDecodeEntities() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    let mut what: std::os::raw::c_int = 0;
    let mut n_what: std::os::raw::c_int = 0;
    let mut end: xmlChar = 0;
    let mut n_end: std::os::raw::c_int = 0;
    let mut end2: xmlChar = 0;
    let mut n_end2: std::os::raw::c_int = 0;
    let mut end3: xmlChar = 0;
    let mut n_end3: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 5 as std::os::raw::c_int {
            n_what = 0 as std::os::raw::c_int;
            while n_what < 4 as std::os::raw::c_int {
                n_end = 0 as std::os::raw::c_int;
                while n_end < 4 as std::os::raw::c_int {
                    n_end2 = 0 as std::os::raw::c_int;
                    while n_end2 < 4 as std::os::raw::c_int {
                        n_end3 = 0 as std::os::raw::c_int;
                        while n_end3 < 4 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            ctxt =
                                gen_xmlParserCtxtPtr(n_ctxt,
                                                     0 as std::os::raw::c_int);
                            str =
                                gen_const_xmlChar_ptr(n_str,
                                                      1 as std::os::raw::c_int);
                            what = gen_int(n_what, 2 as std::os::raw::c_int);
                            end = gen_xmlChar(n_end, 3 as std::os::raw::c_int);
                            end2 = gen_xmlChar(n_end2, 4 as std::os::raw::c_int);
                            end3 = gen_xmlChar(n_end3, 5 as std::os::raw::c_int);
                            ret_val =
                                xmlStringDecodeEntities(ctxt,
                                                        str as *const xmlChar,
                                                        what, end, end2,
                                                        end3);
                            desret_xmlChar_ptr(ret_val);
                            call_tests += 1;
                            des_xmlParserCtxtPtr(n_ctxt, ctxt,
                                                 0 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_str,
                                                  str as *const xmlChar,
                                                  1 as std::os::raw::c_int);
                            des_int(n_what, what, 2 as std::os::raw::c_int);
                            des_xmlChar(n_end, end, 3 as std::os::raw::c_int);
                            des_xmlChar(n_end2, end2, 4 as std::os::raw::c_int);
                            des_xmlChar(n_end3, end3, 5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlStringDecodeEntities\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ctxt);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_str);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_what);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_end);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_end2);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_end3);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_end3 += 1
                        }
                        n_end2 += 1
                    }
                    n_end += 1
                }
                n_what += 1
            }
            n_str += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStringLenDecodeEntities() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    let mut what: std::os::raw::c_int = 0;
    let mut n_what: std::os::raw::c_int = 0;
    let mut end: xmlChar = 0;
    let mut n_end: std::os::raw::c_int = 0;
    let mut end2: xmlChar = 0;
    let mut n_end2: std::os::raw::c_int = 0;
    let mut end3: xmlChar = 0;
    let mut n_end3: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                n_what = 0 as std::os::raw::c_int;
                while n_what < 4 as std::os::raw::c_int {
                    n_end = 0 as std::os::raw::c_int;
                    while n_end < 4 as std::os::raw::c_int {
                        n_end2 = 0 as std::os::raw::c_int;
                        while n_end2 < 4 as std::os::raw::c_int {
                            n_end3 = 0 as std::os::raw::c_int;
                            while n_end3 < 4 as std::os::raw::c_int {
                                mem_base = xmlMemBlocks();
                                ctxt =
                                    gen_xmlParserCtxtPtr(n_ctxt,
                                                         0 as std::os::raw::c_int);
                                str =
                                    gen_const_xmlChar_ptr(n_str,
                                                          1 as std::os::raw::c_int);
                                len = gen_int(n_len, 2 as std::os::raw::c_int);
                                what = gen_int(n_what, 3 as std::os::raw::c_int);
                                end = gen_xmlChar(n_end, 4 as std::os::raw::c_int);
                                end2 = gen_xmlChar(n_end2, 5 as std::os::raw::c_int);
                                end3 = gen_xmlChar(n_end3, 6 as std::os::raw::c_int);
                                if !(!str.is_null() &&
                                         len >
                                             strlen(str as
                                                        *const std::os::raw::c_char)
                                                 as std::os::raw::c_int +
                                                 1 as std::os::raw::c_int) {
                                    ret_val =
                                        xmlStringLenDecodeEntities(ctxt,
                                                                   str as
                                                                       *const xmlChar,
                                                                   len, what,
                                                                   end, end2,
                                                                   end3);
                                    desret_xmlChar_ptr(ret_val);
                                    call_tests += 1;
                                    des_xmlParserCtxtPtr(n_ctxt, ctxt,
                                                         0 as std::os::raw::c_int);
                                    des_const_xmlChar_ptr(n_str,
                                                          str as
                                                              *const xmlChar,
                                                          1 as std::os::raw::c_int);
                                    des_int(n_len, len, 2 as std::os::raw::c_int);
                                    des_int(n_what, what, 3 as std::os::raw::c_int);
                                    des_xmlChar(n_end, end, 4 as std::os::raw::c_int);
                                    des_xmlChar(n_end2, end2,
                                                5 as std::os::raw::c_int);
                                    des_xmlChar(n_end3, end3,
                                                6 as std::os::raw::c_int);
                                    xmlResetLastError();
                                    if mem_base != xmlMemBlocks() {
                                        printf(b"Leak of %d blocks found in xmlStringLenDecodeEntities\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               xmlMemBlocks() - mem_base);
                                        test_ret += 1;
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_ctxt);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_str);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_len);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_what);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_end);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_end2);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_end3);
                                        printf(b"\n\x00" as *const u8 as
                                                   *const std::os::raw::c_char);
                                    }
                                }
                                n_end3 += 1
                            }
                            n_end2 += 1
                        }
                        n_end += 1
                    }
                    n_what += 1
                }
                n_len += 1
            }
            n_str += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSwitchEncoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut n_enc: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_enc = 0 as std::os::raw::c_int;
        while n_enc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            enc = gen_xmlCharEncoding(n_enc, 1 as std::os::raw::c_int);
            ret_val = xmlSwitchEncoding(ctxt, enc);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlCharEncoding(n_enc, enc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSwitchEncoding\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_enc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_enc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSwitchInputEncoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut n_input: std::os::raw::c_int = 0;
    let mut handler: xmlCharEncodingHandlerPtr =
        0 as *mut xmlCharEncodingHandler;
    let mut n_handler: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_input = 0 as std::os::raw::c_int;
        while n_input < 1 as std::os::raw::c_int {
            n_handler = 0 as std::os::raw::c_int;
            while n_handler < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                input = gen_xmlParserInputPtr(n_input, 1 as std::os::raw::c_int);
                handler =
                    gen_xmlCharEncodingHandlerPtr(n_handler,
                                                  2 as std::os::raw::c_int);
                ret_val = xmlSwitchInputEncoding(ctxt, input, handler);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlParserInputPtr(n_input, input, 1 as std::os::raw::c_int);
                des_xmlCharEncodingHandlerPtr(n_handler, handler,
                                              2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSwitchInputEncoding\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_input);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_handler);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_handler += 1
            }
            n_input += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSwitchToEncoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut handler: xmlCharEncodingHandlerPtr =
        0 as *mut xmlCharEncodingHandler;
    let mut n_handler: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_handler = 0 as std::os::raw::c_int;
        while n_handler < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            handler =
                gen_xmlCharEncodingHandlerPtr(n_handler, 1 as std::os::raw::c_int);
            ret_val = xmlSwitchToEncoding(ctxt, handler);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlCharEncodingHandlerPtr(n_handler, handler,
                                          1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSwitchToEncoding\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_handler);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_handler += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_parserInternals() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing parserInternals : 33 of 90 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    test_ret += test_htmlCreateFileParserCtxt();
    test_ret += test_htmlInitAutoClose();
    test_ret += test_inputPop();
    test_ret += test_inputPush();
    test_ret += test_namePop();
    test_ret += test_namePush();
    test_ret += test_nodePop();
    test_ret += test_nodePush();
    test_ret += test_xmlCheckLanguageID();
    test_ret += test_xmlCopyChar();
    test_ret += test_xmlCopyCharMultiByte();
    test_ret += test_xmlCreateEntityParserCtxt();
    test_ret += test_xmlCreateFileParserCtxt();
    test_ret += test_xmlCreateMemoryParserCtxt();
    test_ret += test_xmlCreateURLParserCtxt();
    test_ret += test_xmlCurrentChar();
    test_ret += test_xmlErrMemory();
    test_ret += test_xmlIsLetter();
    test_ret += test_xmlNewEntityInputStream();
    test_ret += test_xmlNewInputFromFile();
    test_ret += test_xmlNewInputStream();
    test_ret += test_xmlNewStringInputStream();
    test_ret += test_xmlNextChar();
    test_ret += test_xmlParserInputShrink();
    test_ret += test_xmlPopInput();
    test_ret += test_xmlPushInput();
    test_ret += test_xmlSetEntityReferenceFunc();
    test_ret += test_xmlSplitQName();
    test_ret += test_xmlStringCurrentChar();
    test_ret += test_xmlStringDecodeEntities();
    test_ret += test_xmlStringLenDecodeEntities();
    test_ret += test_xmlSwitchEncoding();
    test_ret += test_xmlSwitchInputEncoding();
    test_ret += test_xmlSwitchToEncoding();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module parserInternals: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlPatternFromRoot() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut comp: xmlPatternPtr = 0 as *mut xmlPattern;
    let mut n_comp: std::os::raw::c_int = 0;
    n_comp = 0 as std::os::raw::c_int;
    while n_comp < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0 as std::os::raw::c_int);
        ret_val = xmlPatternFromRoot(comp);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlPatternPtr(n_comp, comp, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlPatternFromRoot\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_comp);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_comp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPatternGetStreamCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the precompiled pattern */
}
unsafe extern "C" fn test_xmlPatternMatch() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* a node */
    let mut mem_base: std::os::raw::c_int = 0; /* the precompiled pattern */
    let mut ret_val: std::os::raw::c_int = 0; /* the precompiled pattern */
    let mut comp: xmlPatternPtr =
        0 as *mut xmlPattern; /* the precompiled pattern */
    let mut n_comp: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_comp = 0 as std::os::raw::c_int;
    while n_comp < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            comp = gen_xmlPatternPtr(n_comp, 0 as std::os::raw::c_int);
            node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            ret_val = xmlPatternMatch(comp, node);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlPatternPtr(n_comp, comp, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlPatternMatch\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_comp);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_comp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPatternMaxDepth() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut comp: xmlPatternPtr = 0 as *mut xmlPattern;
    let mut n_comp: std::os::raw::c_int = 0;
    n_comp = 0 as std::os::raw::c_int;
    while n_comp < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0 as std::os::raw::c_int);
        ret_val = xmlPatternMaxDepth(comp);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlPatternPtr(n_comp, comp, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlPatternMaxDepth\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_comp);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_comp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPatternMinDepth() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut comp: xmlPatternPtr = 0 as *mut xmlPattern;
    let mut n_comp: std::os::raw::c_int = 0;
    n_comp = 0 as std::os::raw::c_int;
    while n_comp < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0 as std::os::raw::c_int);
        ret_val = xmlPatternMinDepth(comp);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlPatternPtr(n_comp, comp, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlPatternMinDepth\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_comp);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_comp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPatternStreamable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut comp: xmlPatternPtr = 0 as *mut xmlPattern;
    let mut n_comp: std::os::raw::c_int = 0;
    n_comp = 0 as std::os::raw::c_int;
    while n_comp < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0 as std::os::raw::c_int);
        ret_val = xmlPatternStreamable(comp);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlPatternPtr(n_comp, comp, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlPatternStreamable\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_comp);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_comp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPatterncompile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the stream context */
}
unsafe extern "C" fn gen_xmlStreamCtxtPtr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlStreamCtxtPtr {
    return 0 as xmlStreamCtxtPtr; /* the stream context */
}
unsafe extern "C" fn des_xmlStreamCtxtPtr(mut no: std::os::raw::c_int,
                                          mut val: xmlStreamCtxtPtr,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlStreamPop() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the current name */
    let mut mem_base: std::os::raw::c_int = 0; /* the namespace name */
    let mut ret_val: std::os::raw::c_int = 0; /* the stream context */
    let mut stream: xmlStreamCtxtPtr =
        0 as *mut xmlStreamCtxt; /* the current name */
    let mut n_stream: std::os::raw::c_int = 0; /* the namespace name */
    n_stream = 0 as std::os::raw::c_int; /* the stream context */
    while n_stream < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the current name */
        stream =
            gen_xmlStreamCtxtPtr(n_stream,
                                 0 as std::os::raw::c_int); /* the namespace name */
        ret_val =
            xmlStreamPop(stream); /* the type of the node being pushed */
        desret_int(ret_val); /* the stream context */
        call_tests += 1; /* the file output */
        des_xmlStreamCtxtPtr(n_stream, stream,
                             0 as std::os::raw::c_int); /* a schema structure */
        xmlResetLastError(); /* the file output */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlStreamPop\x00" as *const u8
                       as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* a schema structure */
            test_ret += 1; /* a Relax-NG validation context */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_stream); /* the error callback result */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the warning callback result */
        } /* contextual data for the callbacks result */
        n_stream += 1
    } /* a Relax-NG validation context */
    function_tests += 1; /* the error function result */
    return test_ret; /* the warning function result */
}
unsafe extern "C" fn test_xmlStreamPush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the functions context result */
    let mut mem_base: std::os::raw::c_int = 0; /* a preparsed document tree */
    let mut ret_val: std::os::raw::c_int =
        0; /* a pointer to a char array containing the schemas */
    let mut stream: xmlStreamCtxtPtr =
        0 as *mut xmlStreamCtxt; /* the size of the array */
    let mut n_stream: std::os::raw::c_int = 0; /* the location of the schema */
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ns: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ns: std::os::raw::c_int = 0;
    n_stream = 0 as std::os::raw::c_int;
    while n_stream < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_ns = 0 as std::os::raw::c_int;
            while n_ns < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                stream = gen_xmlStreamCtxtPtr(n_stream, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                ns = gen_const_xmlChar_ptr(n_ns, 2 as std::os::raw::c_int);
                ret_val =
                    xmlStreamPush(stream, name as *const xmlChar,
                                  ns as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlStreamCtxtPtr(n_stream, stream, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_ns, ns as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlStreamPush\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_stream);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ns);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_ns += 1
            }
            n_name += 1
        }
        n_stream += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStreamPushAttr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut stream: xmlStreamCtxtPtr = 0 as *mut xmlStreamCtxt;
    let mut n_stream: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ns: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ns: std::os::raw::c_int = 0;
    n_stream = 0 as std::os::raw::c_int;
    while n_stream < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_ns = 0 as std::os::raw::c_int;
            while n_ns < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                stream = gen_xmlStreamCtxtPtr(n_stream, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                ns = gen_const_xmlChar_ptr(n_ns, 2 as std::os::raw::c_int);
                ret_val =
                    xmlStreamPushAttr(stream, name as *const xmlChar,
                                      ns as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlStreamCtxtPtr(n_stream, stream, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_ns, ns as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlStreamPushAttr\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_stream);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ns);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_ns += 1
            }
            n_name += 1
        }
        n_stream += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStreamPushNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut stream: xmlStreamCtxtPtr = 0 as *mut xmlStreamCtxt;
    let mut n_stream: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ns: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut nodeType: std::os::raw::c_int = 0;
    let mut n_nodeType: std::os::raw::c_int = 0;
    n_stream = 0 as std::os::raw::c_int;
    while n_stream < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_ns = 0 as std::os::raw::c_int;
            while n_ns < 5 as std::os::raw::c_int {
                n_nodeType = 0 as std::os::raw::c_int;
                while n_nodeType < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    stream = gen_xmlStreamCtxtPtr(n_stream, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    ns = gen_const_xmlChar_ptr(n_ns, 2 as std::os::raw::c_int);
                    nodeType = gen_int(n_nodeType, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlStreamPushNode(stream, name as *const xmlChar,
                                          ns as *const xmlChar, nodeType);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlStreamCtxtPtr(n_stream, stream, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_ns, ns as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_int(n_nodeType, nodeType, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlStreamPushNode\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_stream);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_nodeType);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_nodeType += 1
                }
                n_ns += 1
            }
            n_name += 1
        }
        n_stream += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStreamWantsAnyNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut streamCtxt: xmlStreamCtxtPtr = 0 as *mut xmlStreamCtxt;
    let mut n_streamCtxt: std::os::raw::c_int = 0;
    n_streamCtxt = 0 as std::os::raw::c_int;
    while n_streamCtxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        streamCtxt = gen_xmlStreamCtxtPtr(n_streamCtxt, 0 as std::os::raw::c_int);
        ret_val = xmlStreamWantsAnyNode(streamCtxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlStreamCtxtPtr(n_streamCtxt, streamCtxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlStreamWantsAnyNode\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_streamCtxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_streamCtxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_pattern() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing pattern : 10 of 15 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlPatternFromRoot();
    test_ret += test_xmlPatternGetStreamCtxt();
    test_ret += test_xmlPatternMatch();
    test_ret += test_xmlPatternMaxDepth();
    test_ret += test_xmlPatternMinDepth();
    test_ret += test_xmlPatternStreamable();
    test_ret += test_xmlPatterncompile();
    test_ret += test_xmlStreamPop();
    test_ret += test_xmlStreamPush();
    test_ret += test_xmlStreamPushAttr();
    test_ret += test_xmlStreamPushNode();
    test_ret += test_xmlStreamWantsAnyNode();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module pattern: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn gen_xmlRelaxNGPtr(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> xmlRelaxNGPtr {
    return 0 as xmlRelaxNGPtr;
}
unsafe extern "C" fn des_xmlRelaxNGPtr(mut no: std::os::raw::c_int,
                                       mut val: xmlRelaxNGPtr,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlRelaxNGDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut n_schema: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_schema = 0 as std::os::raw::c_int;
        while n_schema < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            schema = gen_xmlRelaxNGPtr(n_schema, 1 as std::os::raw::c_int);
            xmlRelaxNGDump(output, schema);
            call_tests += 1;
            des_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlRelaxNGPtr(n_schema, schema, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlRelaxNGDump\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_schema);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_schema += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGDumpTree() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut n_schema: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_schema = 0 as std::os::raw::c_int;
        while n_schema < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            schema = gen_xmlRelaxNGPtr(n_schema, 1 as std::os::raw::c_int);
            xmlRelaxNGDumpTree(output, schema);
            call_tests += 1;
            des_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlRelaxNGPtr(n_schema, schema, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlRelaxNGDumpTree\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_schema);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_schema += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlRelaxNGParserCtxtPtr(mut no: std::os::raw::c_int,
                                                 mut nr: std::os::raw::c_int)
 -> xmlRelaxNGParserCtxtPtr {
    return 0 as xmlRelaxNGParserCtxtPtr;
}
unsafe extern "C" fn des_xmlRelaxNGParserCtxtPtr(mut no: std::os::raw::c_int,
                                                 mut val:
                                                     xmlRelaxNGParserCtxtPtr,
                                                 mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlRelaxNGValidityErrorFunc_ptr(mut no: std::os::raw::c_int,
                                                         mut nr: std::os::raw::c_int)
 -> *mut xmlRelaxNGValidityErrorFunc {
    return 0 as *mut xmlRelaxNGValidityErrorFunc;
}
unsafe extern "C" fn des_xmlRelaxNGValidityErrorFunc_ptr(mut no: std::os::raw::c_int,
                                                         mut val:
                                                             *mut xmlRelaxNGValidityErrorFunc,
                                                         mut nr:
                                                             std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlRelaxNGValidityWarningFunc_ptr(mut no:
                                                               std::os::raw::c_int,
                                                           mut nr:
                                                               std::os::raw::c_int)
 -> *mut xmlRelaxNGValidityWarningFunc {
    return 0 as *mut xmlRelaxNGValidityWarningFunc;
}
unsafe extern "C" fn des_xmlRelaxNGValidityWarningFunc_ptr(mut no:
                                                               std::os::raw::c_int,
                                                           mut val:
                                                               *mut xmlRelaxNGValidityWarningFunc,
                                                           mut nr:
                                                               std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlRelaxNGGetParserErrors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut err: *mut xmlRelaxNGValidityErrorFunc =
        0 as *mut xmlRelaxNGValidityErrorFunc;
    let mut n_err: std::os::raw::c_int = 0;
    let mut warn: *mut xmlRelaxNGValidityWarningFunc =
        0 as *mut xmlRelaxNGValidityWarningFunc;
    let mut n_warn: std::os::raw::c_int = 0;
    let mut ctx: *mut *mut std::os::raw::c_void = 0 as *mut *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_err = 0 as std::os::raw::c_int;
        while n_err < 1 as std::os::raw::c_int {
            n_warn = 0 as std::os::raw::c_int;
            while n_warn < 1 as std::os::raw::c_int {
                n_ctx = 0 as std::os::raw::c_int;
                while n_ctx < 1 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt =
                        gen_xmlRelaxNGParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    err =
                        gen_xmlRelaxNGValidityErrorFunc_ptr(n_err,
                                                            1 as std::os::raw::c_int);
                    warn =
                        gen_xmlRelaxNGValidityWarningFunc_ptr(n_warn,
                                                              2 as
                                                                  std::os::raw::c_int);
                    ctx = gen_void_ptr_ptr(n_ctx, 3 as std::os::raw::c_int);
                    ret_val = xmlRelaxNGGetParserErrors(ctxt, err, warn, ctx);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlRelaxNGParserCtxtPtr(n_ctxt, ctxt,
                                                0 as std::os::raw::c_int);
                    des_xmlRelaxNGValidityErrorFunc_ptr(n_err, err,
                                                        1 as std::os::raw::c_int);
                    des_xmlRelaxNGValidityWarningFunc_ptr(n_warn, warn,
                                                          2 as std::os::raw::c_int);
                    des_void_ptr_ptr(n_ctx, ctx, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlRelaxNGGetParserErrors\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_err);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_warn);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_ctx += 1
                }
                n_warn += 1
            }
            n_err += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlRelaxNGValidCtxtPtr(mut no: std::os::raw::c_int,
                                                mut nr: std::os::raw::c_int)
 -> xmlRelaxNGValidCtxtPtr {
    return 0 as xmlRelaxNGValidCtxtPtr;
}
unsafe extern "C" fn des_xmlRelaxNGValidCtxtPtr(mut no: std::os::raw::c_int,
                                                mut val:
                                                    xmlRelaxNGValidCtxtPtr,
                                                mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlRelaxNGGetValidErrors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut err: *mut xmlRelaxNGValidityErrorFunc =
        0 as *mut xmlRelaxNGValidityErrorFunc;
    let mut n_err: std::os::raw::c_int = 0;
    let mut warn: *mut xmlRelaxNGValidityWarningFunc =
        0 as *mut xmlRelaxNGValidityWarningFunc;
    let mut n_warn: std::os::raw::c_int = 0;
    let mut ctx: *mut *mut std::os::raw::c_void = 0 as *mut *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_err = 0 as std::os::raw::c_int;
        while n_err < 1 as std::os::raw::c_int {
            n_warn = 0 as std::os::raw::c_int;
            while n_warn < 1 as std::os::raw::c_int {
                n_ctx = 0 as std::os::raw::c_int;
                while n_ctx < 1 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt =
                        gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    err =
                        gen_xmlRelaxNGValidityErrorFunc_ptr(n_err,
                                                            1 as std::os::raw::c_int);
                    warn =
                        gen_xmlRelaxNGValidityWarningFunc_ptr(n_warn,
                                                              2 as
                                                                  std::os::raw::c_int);
                    ctx = gen_void_ptr_ptr(n_ctx, 3 as std::os::raw::c_int);
                    ret_val = xmlRelaxNGGetValidErrors(ctxt, err, warn, ctx);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt,
                                               0 as std::os::raw::c_int);
                    des_xmlRelaxNGValidityErrorFunc_ptr(n_err, err,
                                                        1 as std::os::raw::c_int);
                    des_xmlRelaxNGValidityWarningFunc_ptr(n_warn, warn,
                                                          2 as std::os::raw::c_int);
                    des_void_ptr_ptr(n_ctx, ctx, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlRelaxNGGetValidErrors\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_err);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_warn);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_ctx += 1
                }
                n_warn += 1
            }
            n_err += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGInitTypes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    ret_val = xmlRelaxNGInitTypes();
    desret_int(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlRelaxNGInitTypes\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGNewDocParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
        ret_val = xmlRelaxNGNewDocParserCtxt(doc);
        desret_xmlRelaxNGParserCtxtPtr(ret_val);
        call_tests += 1;
        des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlRelaxNGNewDocParserCtxt\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGNewMemParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buffer = gen_const_char_ptr(n_buffer, 0 as std::os::raw::c_int);
            size = gen_int(n_size, 1 as std::os::raw::c_int);
            if !(!buffer.is_null() &&
                     size >
                         strlen(buffer as *const std::os::raw::c_char) as std::os::raw::c_int
                             + 1 as std::os::raw::c_int) {
                ret_val =
                    xmlRelaxNGNewMemParserCtxt(buffer as *const std::os::raw::c_char,
                                               size);
                desret_xmlRelaxNGParserCtxtPtr(ret_val);
                call_tests += 1;
                des_const_char_ptr(n_buffer, buffer as *const std::os::raw::c_char,
                                   0 as std::os::raw::c_int);
                des_int(n_size, size, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlRelaxNGNewMemParserCtxt\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_size);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_size += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGNewParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        URL = gen_const_char_ptr(n_URL, 0 as std::os::raw::c_int);
        ret_val = xmlRelaxNGNewParserCtxt(URL as *const std::os::raw::c_char);
        desret_xmlRelaxNGParserCtxtPtr(ret_val);
        call_tests += 1;
        des_const_char_ptr(n_URL, URL as *const std::os::raw::c_char,
                           0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlRelaxNGNewParserCtxt\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URL);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGNewValidCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGParse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGSetParserErrors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGSetParserStructuredErrors()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGSetValidErrors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGSetValidStructuredErrors()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a Relax-NG validation context */
}
unsafe extern "C" fn test_xmlRelaxNGValidateDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* a parsed document tree */
    let mut mem_base: std::os::raw::c_int = 0; /* the validation context */
    let mut ret_val: std::os::raw::c_int = 0; /* a document instance */
    let mut ctxt: xmlRelaxNGValidCtxtPtr =
        0 as *mut xmlRelaxNGValidCtxt; /* an element instance */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the RelaxNG validation context */
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc; /* a document instance */
    let mut n_doc: std::os::raw::c_int = 0; /* an element instance */
    n_ctxt = 0 as std::os::raw::c_int; /* the RelaxNG validation context */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int; /* some character data read */
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the length of the data */
            ctxt =
                gen_xmlRelaxNGValidCtxtPtr(n_ctxt,
                                           0 as
                                               std::os::raw::c_int); /* the validation context */
            doc =
                gen_xmlDocPtr(n_doc,
                              1 as std::os::raw::c_int); /* a document instance */
            ret_val =
                xmlRelaxNGValidateDoc(ctxt, doc); /* an element instance */
            desret_int(ret_val); /* a RelaxNG parser context */
            call_tests += 1; /* a set of flags values */
            des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlRelaxNGValidateDoc\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGValidateFullElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                ret_val = xmlRelaxNGValidateFullElement(ctxt, doc, elem);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlRelaxNGValidateFullElement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGValidatePopElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                ret_val = xmlRelaxNGValidatePopElement(ctxt, doc, elem);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlRelaxNGValidatePopElement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGValidatePushCData() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut data: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_data: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                data = gen_const_xmlChar_ptr(n_data, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!data.is_null() &&
                         len >
                             strlen(data as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlRelaxNGValidatePushCData(ctxt,
                                                    data as *const xmlChar,
                                                    len);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt,
                                               0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_data, data as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlRelaxNGValidatePushCData\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_data);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_data += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxNGValidatePushElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                ret_val = xmlRelaxNGValidatePushElement(ctxt, doc, elem);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlRelaxNGValidatePushElement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRelaxParserSetFlag() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut flags: std::os::raw::c_int = 0;
    let mut n_flags: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_flags = 0 as std::os::raw::c_int;
        while n_flags < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlRelaxNGParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            flags = gen_int(n_flags, 1 as std::os::raw::c_int);
            ret_val = xmlRelaxParserSetFlag(ctxt, flags);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlRelaxNGParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_flags, flags, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlRelaxParserSetFlag\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_flags);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_flags += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_relaxng() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing relaxng : 14 of 24 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlRelaxNGDump();
    test_ret += test_xmlRelaxNGDumpTree();
    test_ret += test_xmlRelaxNGGetParserErrors();
    test_ret += test_xmlRelaxNGGetValidErrors();
    test_ret += test_xmlRelaxNGInitTypes();
    test_ret += test_xmlRelaxNGNewDocParserCtxt();
    test_ret += test_xmlRelaxNGNewMemParserCtxt();
    test_ret += test_xmlRelaxNGNewParserCtxt();
    test_ret += test_xmlRelaxNGNewValidCtxt();
    test_ret += test_xmlRelaxNGParse();
    test_ret += test_xmlRelaxNGSetParserErrors();
    test_ret += test_xmlRelaxNGSetParserStructuredErrors();
    test_ret += test_xmlRelaxNGSetValidErrors();
    test_ret += test_xmlRelaxNGSetValidStructuredErrors();
    test_ret += test_xmlRelaxNGValidateDoc();
    test_ret += test_xmlRelaxNGValidateFullElement();
    test_ret += test_xmlRelaxNGValidatePopElement();
    test_ret += test_xmlRelaxNGValidatePushCData();
    test_ret += test_xmlRelaxNGValidatePushElement();
    test_ret += test_xmlRelaxParserSetFlag();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module relaxng: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_schemasInternals() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing schemasInternals : 0 of 2 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module schemasInternals: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlSchematronNewDocParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchematronNewMemParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchematronNewParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchematronNewValidCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchematronParse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn gen_xmlSchematronValidCtxtPtr(mut no: std::os::raw::c_int,
                                                   mut nr: std::os::raw::c_int)
 -> xmlSchematronValidCtxtPtr {
    return 0 as xmlSchematronValidCtxtPtr;
}
unsafe extern "C" fn des_xmlSchematronValidCtxtPtr(mut no: std::os::raw::c_int,
                                                   mut val:
                                                       xmlSchematronValidCtxtPtr,
                                                   mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSchematronSetValidStructuredErrors()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the schema validation context */
}
unsafe extern "C" fn test_xmlSchematronValidateDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the document instace tree */
    let mut mem_base: std::os::raw::c_int = 0; /* the parent node */
    let mut ret_val: std::os::raw::c_int = 0; /* the child node */
    let mut ctxt: xmlSchematronValidCtxtPtr =
        0 as *mut xmlSchematronValidCtxt; /* the parent node */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the first node in the list */
    let mut instance: xmlDocPtr = 0 as *mut xmlDoc; /* the child node */
    let mut n_instance: std::os::raw::c_int = 0; /* the new node */
    n_ctxt = 0 as std::os::raw::c_int; /* the child node */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_instance = 0 as std::os::raw::c_int; /* the new node */
        while n_instance < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the child node */
            ctxt =
                gen_xmlSchematronValidCtxtPtr(n_ctxt,
                                              0 as
                                                  std::os::raw::c_int); /* the new node */
            instance =
                gen_xmlDocPtr(n_instance,
                              1 as std::os::raw::c_int); /* the XML buffer output */
            ret_val =
                xmlSchematronValidateDoc(ctxt, instance); /* the document */
            desret_int(ret_val); /* the attribute node */
            call_tests += 1; /* the text content */
            des_xmlSchematronValidCtxtPtr(n_ctxt, ctxt,
                                          0 as std::os::raw::c_int); /* the buffer */
            des_xmlDocPtr(n_instance, instance,
                          1 as std::os::raw::c_int); /* the buffer */
            xmlResetLastError(); /* a buffer xmlBufPtr */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchematronValidateDoc\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base); /* the node being read */
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_instance);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_instance += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_schematron() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing schematron : 1 of 10 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    test_ret += test_xmlSchematronNewDocParserCtxt();
    test_ret += test_xmlSchematronNewMemParserCtxt();
    test_ret += test_xmlSchematronNewParserCtxt();
    test_ret += test_xmlSchematronNewValidCtxt();
    test_ret += test_xmlSchematronParse();
    test_ret += test_xmlSchematronSetValidStructuredErrors();
    test_ret += test_xmlSchematronValidateDoc();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module schematron: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlAddChild() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_parent: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_parent = 0 as std::os::raw::c_int;
    while n_parent < 3 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            parent = gen_xmlNodePtr(n_parent, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr_in(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlAddChild(parent, cur);
            if ret_val.is_null() { xmlFreeNode(cur); cur = 0 as xmlNodePtr }
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_parent, parent, 0 as std::os::raw::c_int);
            des_xmlNodePtr_in(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlAddChild\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_parent);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_parent += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAddChildList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_parent: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_parent = 0 as std::os::raw::c_int;
    while n_parent < 3 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            parent = gen_xmlNodePtr(n_parent, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr_in(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlAddChildList(parent, cur);
            if ret_val.is_null() {
                xmlFreeNodeList(cur);
                cur = 0 as xmlNodePtr
            }
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_parent, parent, 0 as std::os::raw::c_int);
            des_xmlNodePtr_in(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlAddChildList\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_parent);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_parent += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAddNextSibling() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
            elem = gen_xmlNodePtr_in(n_elem, 1 as std::os::raw::c_int);
            ret_val = xmlAddNextSibling(cur, elem);
            if ret_val.is_null() { xmlFreeNode(elem); elem = 0 as xmlNodePtr }
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_xmlNodePtr_in(n_elem, elem, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlAddNextSibling\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_elem);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_elem += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAddPrevSibling() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
            elem = gen_xmlNodePtr_in(n_elem, 1 as std::os::raw::c_int);
            ret_val = xmlAddPrevSibling(cur, elem);
            if ret_val.is_null() { xmlFreeNode(elem); elem = 0 as xmlNodePtr }
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_xmlNodePtr_in(n_elem, elem, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlAddPrevSibling\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_elem);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_elem += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAddSibling() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
            elem = gen_xmlNodePtr_in(n_elem, 1 as std::os::raw::c_int);
            ret_val = xmlAddSibling(cur, elem);
            if ret_val.is_null() { xmlFreeNode(elem); elem = 0 as xmlNodePtr }
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_xmlNodePtr_in(n_elem, elem, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlAddSibling\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_elem);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_elem += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAttrSerializeTxtContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut n_attr: std::os::raw::c_int = 0;
    let mut string: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_string: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_attr = 0 as std::os::raw::c_int;
            while n_attr < 2 as std::os::raw::c_int {
                n_string = 0 as std::os::raw::c_int;
                while n_string < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
                    doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                    attr = gen_xmlAttrPtr(n_attr, 2 as std::os::raw::c_int);
                    string =
                        gen_const_xmlChar_ptr(n_string, 3 as std::os::raw::c_int);
                    xmlAttrSerializeTxtContent(buf, doc, attr,
                                               string as *const xmlChar);
                    call_tests += 1;
                    des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
                    des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                    des_xmlAttrPtr(n_attr, attr, 2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_string, string as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlAttrSerializeTxtContent\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buf);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_attr);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_string);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_string += 1
                }
                n_attr += 1
            }
            n_doc += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_const_xmlBuf_ptr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> *mut xmlBuf {
    return 0 as *mut xmlBuf;
}
unsafe extern "C" fn des_const_xmlBuf_ptr(mut no: std::os::raw::c_int,
                                          mut val: *const xmlBuf,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlBufContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut buf: *mut xmlBuf = 0 as *mut xmlBuf;
    let mut n_buf: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        buf = gen_const_xmlBuf_ptr(n_buf, 0 as std::os::raw::c_int);
        ret_val = xmlBufContent(buf as *const xmlBuf);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlBuf_ptr(n_buf, buf as *const xmlBuf, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlBufContent\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlBufPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlBufPtr {
    return 0 as xmlBufPtr;
}
unsafe extern "C" fn des_xmlBufPtr(mut no: std::os::raw::c_int, mut val: xmlBufPtr,
                                   mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlBufEnd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut buf: xmlBufPtr = 0 as *mut xmlBuf;
    let mut n_buf: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufPtr(n_buf, 0 as std::os::raw::c_int);
        ret_val = xmlBufEnd(buf);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlBufPtr(n_buf, buf, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlBufEnd\x00" as *const u8 as
                       *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_const_xmlNode_ptr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> *mut xmlNode {
    return 0 as *mut xmlNode;
}
unsafe extern "C" fn des_const_xmlNode_ptr(mut no: std::os::raw::c_int,
                                           mut val: *const xmlNode,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlBufGetNodeContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlBufPtr = 0 as *mut xmlBuf;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufPtr(n_buf, 0 as std::os::raw::c_int);
            cur = gen_const_xmlNode_ptr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlBufGetNodeContent(buf, cur as *const xmlNode);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlBufPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_const_xmlNode_ptr(n_cur, cur as *const xmlNode,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufGetNodeContent\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufNodeDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlBufShrink() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlBufUse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the buffer to dump */
}
unsafe extern "C" fn test_xmlBufferAdd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the #xmlChar string */
    let mut mem_base: std::os::raw::c_int = 0; /* the number of #xmlChar to add */
    let mut ret_val: std::os::raw::c_int = 0; /* the buffer */
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer; /* the #xmlChar string */
    let mut n_buf: std::os::raw::c_int = 0; /* the number of #xmlChar to add */
    let mut str: *mut xmlChar = 0 as *mut xmlChar; /* the buffer to dump */
    let mut n_str: std::os::raw::c_int = 0; /* the C char string */
    let mut len: std::os::raw::c_int = 0; /* the buffer to add to */
    let mut n_len: std::os::raw::c_int = 0; /* the #xmlChar string */
    n_buf = 0 as std::os::raw::c_int; /* the buffer */
    while n_buf < 3 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
                str = gen_const_xmlChar_ptr(n_str, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!str.is_null() &&
                         len >
                             strlen(str as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    ret_val = xmlBufferAdd(buf, str as *const xmlChar, len);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlBufferAdd\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buf);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_str);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_str += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferAddHead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
                str = gen_const_xmlChar_ptr(n_str, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!str.is_null() &&
                         len >
                             strlen(str as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlBufferAddHead(buf, str as *const xmlChar, len);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlBufferAddHead\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buf);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_str);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_str += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferCCat() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut str: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_str: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            str = gen_const_char_ptr(n_str, 1 as std::os::raw::c_int);
            ret_val = xmlBufferCCat(buf, str as *const std::os::raw::c_char);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_str, str as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufferCCat\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferCat() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            str = gen_const_xmlChar_ptr(n_str, 1 as std::os::raw::c_int);
            ret_val = xmlBufferCat(buf, str as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufferCat\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_const_xmlBuffer_ptr(mut no: std::os::raw::c_int,
                                             mut nr: std::os::raw::c_int)
 -> *mut xmlBuffer {
    return 0 as *mut xmlBuffer;
}
unsafe extern "C" fn des_const_xmlBuffer_ptr(mut no: std::os::raw::c_int,
                                             mut val: *const xmlBuffer,
                                             mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlBufferContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut buf: *mut xmlBuffer = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        buf = gen_const_xmlBuffer_ptr(n_buf, 0 as std::os::raw::c_int);
        ret_val = xmlBufferContent(buf as *const xmlBuffer);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlBuffer_ptr(n_buf, buf as *const xmlBuffer,
                                0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlBufferContent\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferCreate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlBufferPtr = 0 as *mut xmlBuffer;
    mem_base = xmlMemBlocks();
    ret_val = xmlBufferCreate();
    desret_xmlBufferPtr(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlBufferCreate\x00" as *const u8
                   as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferCreateSize() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferCreateStatic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the buffer */
}
unsafe extern "C" fn test_xmlBufferDetach() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the buffer */
    let mut mem_base: std::os::raw::c_int = 0; /* the buffer */
    let mut ret_val: *mut xmlChar =
        0 as *mut xmlChar; /* the minimum free size to allocate */
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer; /* the buffer */
    let mut n_buf: std::os::raw::c_int = 0; /* the buffer to resize */
    n_buf = 0 as std::os::raw::c_int; /* the desired size */
    while n_buf < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the buffer to tune */
        buf =
            gen_xmlBufferPtr(n_buf,
                             0 as std::os::raw::c_int); /* allocation scheme to use */
        ret_val = xmlBufferDetach(buf); /* the buffer to dump */
        desret_xmlChar_ptr(ret_val); /* the number of xmlChar to remove */
        call_tests += 1; /* the XML buffer */
        des_xmlBufferPtr(n_buf, buf,
                         0 as std::os::raw::c_int); /* the string to add */
        xmlResetLastError(); /* the XML buffer output */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlBufferDetach\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* the string to add */
            test_ret += 1; /* the XML buffer output */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_buf); /* the string to add */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the Name */
        } /* the prefix */
        n_buf += 1
    } /* preallocated memory */
    function_tests += 1; /* preallocated memory length */
    return test_ret; /* the parent node */
}
unsafe extern "C" fn test_xmlBufferEmpty() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the document */
    let mut mem_base: std::os::raw::c_int = 0; /* if not zero do a recursive copy. */
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer; /* the dtd */
    let mut n_buf: std::os::raw::c_int = 0; /* the namespace */
    n_buf = 0 as std::os::raw::c_int; /* the first namespace */
    while n_buf < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the node */
        buf =
            gen_xmlBufferPtr(n_buf,
                             0 as
                                 std::os::raw::c_int); /* if 1 do a recursive copy (properties, namespaces and children when applicable) if 2 copy properties and namespaces (when applicable) */
        xmlBufferEmpty(buf); /* the first node in the list. */
        call_tests += 1; /* the element where the attribute will be grafted */
        des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int); /* the attribute */
        xmlResetLastError(); /* the element where the attributes will be grafted */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlBufferEmpty\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* the first attribute */
            test_ret += 1; /* the document pointer */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_buf); /* the DTD name */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the external (PUBLIC) ID */
        } /* the system ID */
        n_buf += 1
    } /* the optional context for custom processing */
    function_tests += 1; /* the optional sourceDoc */
    return test_ret; /* the node to start with */
}
unsafe extern "C" fn test_xmlBufferGrow() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the destination doc */
    let mut mem_base: std::os::raw::c_int =
        0; /* the optional new parent of @node in @destDoc */
    let mut ret_val: std::os::raw::c_int = 0; /* option flags */
    let mut buf: xmlBufferPtr =
        0 as *mut xmlBuffer; /* the optional context for custom processing */
    let mut n_buf: std::os::raw::c_int = 0; /* the optional sourceDoc */
    let mut len: std::os::raw::c_uint = 0; /* the node to start with */
    let mut n_len: std::os::raw::c_int = 0; /* the clone of the given @node */
    n_buf = 0 as std::os::raw::c_int; /* the destination doc */
    while n_buf < 3 as std::os::raw::c_int {
        n_len =
            0 as
                std::os::raw::c_int; /* the optional new parent of @node in @destDoc */
        while n_len < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* descend into child if set */
            buf =
                gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int); /* option flags */
            len = gen_unsigned_int(n_len, 1 as std::os::raw::c_int);
            ret_val = xmlBufferGrow(buf, len);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_unsigned_int(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufferGrow\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferLength() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: *mut xmlBuffer = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        buf = gen_const_xmlBuffer_ptr(n_buf, 0 as std::os::raw::c_int);
        ret_val = xmlBufferLength(buf as *const xmlBuffer);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlBuffer_ptr(n_buf, buf as *const xmlBuffer,
                                0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlBufferLength\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferResize() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_uint = 0;
    let mut n_size: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            size = gen_unsigned_int(n_size, 1 as std::os::raw::c_int);
            ret_val = xmlBufferResize(buf, size);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_unsigned_int(n_size, size, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufferResize\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_size);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_size += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferSetAllocationScheme() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut scheme: xmlBufferAllocationScheme = XML_BUFFER_ALLOC_DOUBLEIT;
    let mut n_scheme: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_scheme = 0 as std::os::raw::c_int;
        while n_scheme < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            scheme =
                gen_xmlBufferAllocationScheme(n_scheme, 1 as std::os::raw::c_int);
            xmlBufferSetAllocationScheme(buf, scheme);
            if !buf.is_null() &&
                   scheme as std::os::raw::c_uint ==
                       XML_BUFFER_ALLOC_IMMUTABLE as std::os::raw::c_int as
                           std::os::raw::c_uint && !(*buf).content.is_null() &&
                   (*buf).content != static_buf_content as *mut xmlChar {
                xmlFree.expect("non-null function pointer")((*buf).content as
                                                                *mut std::os::raw::c_void);
                (*buf).content = 0 as *mut xmlChar
            }
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_xmlBufferAllocationScheme(n_scheme, scheme, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufferSetAllocationScheme\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_scheme);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_scheme += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferShrink() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_uint = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            len = gen_unsigned_int(n_len, 1 as std::os::raw::c_int);
            ret_val = xmlBufferShrink(buf, len);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_unsigned_int(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufferShrink\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferWriteCHAR() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut string: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_string: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_string = 0 as std::os::raw::c_int;
        while n_string < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            string = gen_const_xmlChar_ptr(n_string, 1 as std::os::raw::c_int);
            xmlBufferWriteCHAR(buf, string as *const xmlChar);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_string, string as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufferWriteCHAR\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_string);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_string += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferWriteChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut string: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_string: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_string = 0 as std::os::raw::c_int;
        while n_string < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            string = gen_const_char_ptr(n_string, 1 as std::os::raw::c_int);
            xmlBufferWriteChar(buf, string as *const std::os::raw::c_char);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_string, string as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufferWriteChar\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_string);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_string += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBufferWriteQuotedString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut string: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_string: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_string = 0 as std::os::raw::c_int;
        while n_string < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            string = gen_const_xmlChar_ptr(n_string, 1 as std::os::raw::c_int);
            xmlBufferWriteQuotedString(buf, string as *const xmlChar);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_string, string as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBufferWriteQuotedString\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_string);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_string += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBuildQName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ncname: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ncname: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut memory: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_memory: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ncname = 0 as std::os::raw::c_int;
    while n_ncname < 5 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_memory = 0 as std::os::raw::c_int;
            while n_memory < 2 as std::os::raw::c_int {
                n_len = 0 as std::os::raw::c_int;
                while n_len < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ncname =
                        gen_const_xmlChar_ptr(n_ncname, 0 as std::os::raw::c_int);
                    prefix =
                        gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
                    memory = gen_xmlChar_ptr(n_memory, 2 as std::os::raw::c_int);
                    len = gen_int(n_len, 3 as std::os::raw::c_int);
                    if !(!prefix.is_null() &&
                             len >
                                 strlen(prefix as *const std::os::raw::c_char) as
                                     std::os::raw::c_int + 1 as std::os::raw::c_int) {
                        ret_val =
                            xmlBuildQName(ncname as *const xmlChar,
                                          prefix as *const xmlChar, memory,
                                          len);
                        if !ret_val.is_null() && ret_val != ncname &&
                               ret_val != prefix && ret_val != memory {
                            xmlFree.expect("non-null function pointer")(ret_val
                                                                            as
                                                                            *mut std::os::raw::c_void);
                        }
                        ret_val = 0 as *mut xmlChar;
                        desret_xmlChar_ptr(ret_val);
                        call_tests += 1;
                        des_const_xmlChar_ptr(n_ncname,
                                              ncname as *const xmlChar,
                                              0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_prefix,
                                              prefix as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_xmlChar_ptr(n_memory, memory, 2 as std::os::raw::c_int);
                        des_int(n_len, len, 3 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlBuildQName\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ncname);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_prefix);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_memory);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_len);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                    }
                    n_len += 1
                }
                n_memory += 1
            }
            n_prefix += 1
        }
        n_ncname += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlChildElementCount() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_ulong = 0;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_parent: std::os::raw::c_int = 0;
    n_parent = 0 as std::os::raw::c_int;
    while n_parent < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0 as std::os::raw::c_int);
        ret_val = xmlChildElementCount(parent);
        desret_unsigned_long(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_parent, parent, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlChildElementCount\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_parent);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_parent += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut recursive: std::os::raw::c_int = 0;
    let mut n_recursive: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_recursive = 0 as std::os::raw::c_int;
        while n_recursive < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            recursive = gen_int(n_recursive, 1 as std::os::raw::c_int);
            ret_val = xmlCopyDoc(doc, recursive);
            desret_xmlDocPtr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_int(n_recursive, recursive, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCopyDoc\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_recursive);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_recursive += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyDtd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut n_dtd: std::os::raw::c_int = 0;
    n_dtd = 0 as std::os::raw::c_int;
    while n_dtd < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        dtd = gen_xmlDtdPtr(n_dtd, 0 as std::os::raw::c_int);
        ret_val = xmlCopyDtd(dtd);
        desret_xmlDtdPtr(ret_val);
        call_tests += 1;
        des_xmlDtdPtr(n_dtd, dtd, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCopyDtd\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_dtd);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_dtd += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyNamespace() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNsPtr = 0 as *mut xmlNs;
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNsPtr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlCopyNamespace(cur);
        if !ret_val.is_null() { xmlFreeNs(ret_val); }
        desret_xmlNsPtr(ret_val);
        call_tests += 1;
        des_xmlNsPtr(n_cur, cur, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCopyNamespace\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyNamespaceList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNsPtr = 0 as *mut xmlNs;
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNsPtr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlCopyNamespaceList(cur);
        if !ret_val.is_null() { xmlFreeNsList(ret_val); }
        desret_xmlNsPtr(ret_val);
        call_tests += 1;
        des_xmlNsPtr(n_cur, cur, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCopyNamespaceList\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut extended: std::os::raw::c_int = 0;
    let mut n_extended: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_extended = 0 as std::os::raw::c_int;
        while n_extended < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
            extended = gen_int(n_extended, 1 as std::os::raw::c_int);
            ret_val = xmlCopyNode(node, extended);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
            des_int(n_extended, extended, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCopyNode\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_extended);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_extended += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyNodeList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
        ret_val = xmlCopyNodeList(node);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCopyNodeList\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_node);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut target: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_target: std::os::raw::c_int = 0;
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut n_cur: std::os::raw::c_int = 0;
    n_target = 0 as std::os::raw::c_int;
    while n_target < 3 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            target = gen_xmlNodePtr(n_target, 0 as std::os::raw::c_int);
            cur = gen_xmlAttrPtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlCopyProp(target, cur);
            desret_xmlAttrPtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_target, target, 0 as std::os::raw::c_int);
            des_xmlAttrPtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCopyProp\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_target);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_target += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyPropList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut target: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_target: std::os::raw::c_int = 0;
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut n_cur: std::os::raw::c_int = 0;
    n_target = 0 as std::os::raw::c_int;
    while n_target < 3 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            target = gen_xmlNodePtr(n_target, 0 as std::os::raw::c_int);
            cur = gen_xmlAttrPtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlCopyPropList(target, cur);
            desret_xmlAttrPtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_target, target, 0 as std::os::raw::c_int);
            des_xmlAttrPtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCopyPropList\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_target);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_target += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCreateIntSubset() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_SystemID: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_ExternalID = 0 as std::os::raw::c_int;
            while n_ExternalID < 5 as std::os::raw::c_int {
                n_SystemID = 0 as std::os::raw::c_int;
                while n_SystemID < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    ExternalID =
                        gen_const_xmlChar_ptr(n_ExternalID, 2 as std::os::raw::c_int);
                    SystemID =
                        gen_const_xmlChar_ptr(n_SystemID, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlCreateIntSubset(doc, name as *const xmlChar,
                                           ExternalID as *const xmlChar,
                                           SystemID as *const xmlChar);
                    desret_xmlDtdPtr(ret_val);
                    call_tests += 1;
                    des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_ExternalID,
                                          ExternalID as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_SystemID,
                                          SystemID as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlCreateIntSubset\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ExternalID);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_SystemID);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_SystemID += 1
                }
                n_ExternalID += 1
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlDOMWrapCtxtPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> xmlDOMWrapCtxtPtr {
    return 0 as xmlDOMWrapCtxtPtr;
}
unsafe extern "C" fn des_xmlDOMWrapCtxtPtr(mut no: std::os::raw::c_int,
                                           mut val: xmlDOMWrapCtxtPtr,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlDOMWrapAdoptNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlDOMWrapCtxtPtr = 0 as *mut xmlDOMWrapCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut sourceDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_sourceDoc: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut destDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_destDoc: std::os::raw::c_int = 0;
    let mut destParent: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_destParent: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_sourceDoc = 0 as std::os::raw::c_int;
        while n_sourceDoc < 4 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_destDoc = 0 as std::os::raw::c_int;
                while n_destDoc < 4 as std::os::raw::c_int {
                    n_destParent = 0 as std::os::raw::c_int;
                    while n_destParent < 3 as std::os::raw::c_int {
                        n_options = 0 as std::os::raw::c_int;
                        while n_options < 4 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            ctxt =
                                gen_xmlDOMWrapCtxtPtr(n_ctxt,
                                                      0 as std::os::raw::c_int);
                            sourceDoc =
                                gen_xmlDocPtr(n_sourceDoc, 1 as std::os::raw::c_int);
                            node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                            destDoc =
                                gen_xmlDocPtr(n_destDoc, 3 as std::os::raw::c_int);
                            destParent =
                                gen_xmlNodePtr(n_destParent,
                                               4 as std::os::raw::c_int);
                            options = gen_int(n_options, 5 as std::os::raw::c_int);
                            ret_val =
                                xmlDOMWrapAdoptNode(ctxt, sourceDoc, node,
                                                    destDoc, destParent,
                                                    options);
                            if !node.is_null() && (*node).parent.is_null() {
                                xmlUnlinkNode(node);
                                xmlFreeNode(node);
                                node = 0 as xmlNodePtr
                            }
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt,
                                                  0 as std::os::raw::c_int);
                            des_xmlDocPtr(n_sourceDoc, sourceDoc,
                                          1 as std::os::raw::c_int);
                            des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                            des_xmlDocPtr(n_destDoc, destDoc,
                                          3 as std::os::raw::c_int);
                            des_xmlNodePtr(n_destParent, destParent,
                                           4 as std::os::raw::c_int);
                            des_int(n_options, options, 5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlDOMWrapAdoptNode\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ctxt);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_sourceDoc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_node);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_destDoc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_destParent);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_options);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_options += 1
                        }
                        n_destParent += 1
                    }
                    n_destDoc += 1
                }
                n_node += 1
            }
            n_sourceDoc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDOMWrapCloneNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlDOMWrapCtxtPtr = 0 as *mut xmlDOMWrapCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut sourceDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_sourceDoc: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut resNode: *mut xmlNodePtr = 0 as *mut xmlNodePtr;
    let mut n_resNode: std::os::raw::c_int = 0;
    let mut destDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_destDoc: std::os::raw::c_int = 0;
    let mut destParent: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_destParent: std::os::raw::c_int = 0;
    let mut deep: std::os::raw::c_int = 0;
    let mut n_deep: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_sourceDoc = 0 as std::os::raw::c_int;
        while n_sourceDoc < 4 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_resNode = 0 as std::os::raw::c_int;
                while n_resNode < 1 as std::os::raw::c_int {
                    n_destDoc = 0 as std::os::raw::c_int;
                    while n_destDoc < 4 as std::os::raw::c_int {
                        n_destParent = 0 as std::os::raw::c_int;
                        while n_destParent < 3 as std::os::raw::c_int {
                            n_deep = 0 as std::os::raw::c_int;
                            while n_deep < 4 as std::os::raw::c_int {
                                n_options = 0 as std::os::raw::c_int;
                                while n_options < 4 as std::os::raw::c_int {
                                    mem_base = xmlMemBlocks();
                                    ctxt =
                                        gen_xmlDOMWrapCtxtPtr(n_ctxt,
                                                              0 as
                                                                  std::os::raw::c_int);
                                    sourceDoc =
                                        gen_xmlDocPtr(n_sourceDoc,
                                                      1 as std::os::raw::c_int);
                                    node =
                                        gen_xmlNodePtr(n_node,
                                                       2 as std::os::raw::c_int);
                                    resNode =
                                        gen_xmlNodePtr_ptr(n_resNode,
                                                           3 as std::os::raw::c_int);
                                    destDoc =
                                        gen_xmlDocPtr(n_destDoc,
                                                      4 as std::os::raw::c_int);
                                    destParent =
                                        gen_xmlNodePtr(n_destParent,
                                                       5 as std::os::raw::c_int);
                                    deep = gen_int(n_deep, 6 as std::os::raw::c_int);
                                    options =
                                        gen_int(n_options, 7 as std::os::raw::c_int);
                                    ret_val =
                                        xmlDOMWrapCloneNode(ctxt, sourceDoc,
                                                            node, resNode,
                                                            destDoc,
                                                            destParent, deep,
                                                            options);
                                    desret_int(ret_val);
                                    call_tests += 1;
                                    des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt,
                                                          0 as std::os::raw::c_int);
                                    des_xmlDocPtr(n_sourceDoc, sourceDoc,
                                                  1 as std::os::raw::c_int);
                                    des_xmlNodePtr(n_node, node,
                                                   2 as std::os::raw::c_int);
                                    des_xmlNodePtr_ptr(n_resNode, resNode,
                                                       3 as std::os::raw::c_int);
                                    des_xmlDocPtr(n_destDoc, destDoc,
                                                  4 as std::os::raw::c_int);
                                    des_xmlNodePtr(n_destParent, destParent,
                                                   5 as std::os::raw::c_int);
                                    des_int(n_deep, deep, 6 as std::os::raw::c_int);
                                    des_int(n_options, options,
                                            7 as std::os::raw::c_int);
                                    xmlResetLastError();
                                    if mem_base != xmlMemBlocks() {
                                        printf(b"Leak of %d blocks found in xmlDOMWrapCloneNode\x00"
                                                   as *const u8 as
                                                   *const std::os::raw::c_char,
                                               xmlMemBlocks() - mem_base);
                                        test_ret += 1;
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_ctxt);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_sourceDoc);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_node);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_resNode);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_destDoc);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_destParent);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_deep);
                                        printf(b" %d\x00" as *const u8 as
                                                   *const std::os::raw::c_char,
                                               n_options);
                                        printf(b"\n\x00" as *const u8 as
                                                   *const std::os::raw::c_char);
                                    }
                                    n_options += 1
                                }
                                n_deep += 1
                            }
                            n_destParent += 1
                        }
                        n_destDoc += 1
                    }
                    n_resNode += 1
                }
                n_node += 1
            }
            n_sourceDoc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDOMWrapNewCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* DOM wrapper context, unused at the moment */
}
unsafe extern "C" fn test_xmlDOMWrapReconcileNamespaces() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the element-node */
    let mut mem_base: std::os::raw::c_int = 0; /* option flags */
    let mut ret_val: std::os::raw::c_int = 0; /* a DOM wrapper context */
    let mut ctxt: xmlDOMWrapCtxtPtr = 0 as *mut xmlDOMWrapCtxt; /* the doc */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the node to be removed. */
    let mut elem: xmlNodePtr =
        0 as *mut xmlNode; /* set of options, unused at the moment */
    let mut n_elem: std::os::raw::c_int = 0; /* the node */
    let mut options: std::os::raw::c_int = 0; /* the document */
    let mut n_options: std::os::raw::c_int =
        0; /* if 1 do a recursive copy (properties, namespaces and children when applicable) if 2 copy properties and namespaces (when applicable) */
    n_ctxt = 0 as std::os::raw::c_int; /* the target document */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int; /* the first node in the list. */
        while n_elem < 3 as std::os::raw::c_int {
            n_options = 0 as std::os::raw::c_int; /* the FILE* */
            while n_options < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* the document */
                ctxt =
                    gen_xmlDOMWrapCtxtPtr(n_ctxt,
                                          0 as
                                              std::os::raw::c_int); /* the document */
                elem =
                    gen_xmlNodePtr(n_elem,
                                   1 as
                                       std::os::raw::c_int); /* OUT: the memory pointer */
                options =
                    gen_int(n_options,
                            2 as std::os::raw::c_int); /* OUT: the memory length */
                ret_val =
                    xmlDOMWrapReconcileNamespaces(ctxt, elem,
                                                  options); /* should formatting spaces been added */
                desret_int(ret_val); /* Document to generate XML text from */
                call_tests += 1; /* Memory pointer for allocated XML text */
                des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt,
                                      0 as
                                          std::os::raw::c_int); /* Length of the generated XML text */
                des_xmlNodePtr(n_elem, elem,
                               1 as
                                   std::os::raw::c_int); /* Character encoding to use when generating XML text */
                des_int(n_options, options,
                        2 as
                            std::os::raw::c_int); /* should formatting spaces been added */
                xmlResetLastError(); /* the document */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDOMWrapReconcileNamespaces\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() -
                               mem_base); /* OUT: the memory pointer */
                    test_ret += 1; /* OUT: the memory length */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt); /* Document to generate XML text from */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem); /* Memory pointer for allocated XML text */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_options); /* Length of the generated XML text */
                    printf(b"\n\x00" as *const u8 as
                               *const std::os::raw::c_char); /* Character encoding to use when generating XML text */
                } /* the FILE* */
                n_options += 1
            } /* the document */
            n_elem += 1
        } /* should formatting spaces been added */
        n_ctxt += 1
    } /* the document */
    function_tests += 1; /* the document */
    return test_ret; /* the new document root element, if root is NULL no action is taken, to remove a node from a document use xmlUnlinkNode(root) instead. */
}
unsafe extern "C" fn test_xmlDOMWrapRemoveNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the FILE * for the output */
    let mut mem_base: std::os::raw::c_int = 0; /* the document */
    let mut ret_val: std::os::raw::c_int = 0; /* the current node */
    let mut ctxt: xmlDOMWrapCtxtPtr =
        0 as *mut xmlDOMWrapCtxt; /* the parent node */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the document */
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc; /* the document pointer */
    let mut n_doc: std::os::raw::c_int = 0; /* the parent node */
    let mut node: xmlNodePtr = 0 as *mut xmlNode; /* valid node */
    let mut n_node: std::os::raw::c_int = 0; /* the node */
    let mut options: std::os::raw::c_int = 0; /* the attribute name */
    let mut n_options: std::os::raw::c_int = 0; /* a node */
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_node = 0 as std::os::raw::c_int;
            while n_node < 3 as std::os::raw::c_int {
                n_options = 0 as std::os::raw::c_int;
                while n_options < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlDOMWrapCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 2 as std::os::raw::c_int);
                    options = gen_int(n_options, 3 as std::os::raw::c_int);
                    ret_val = xmlDOMWrapRemoveNode(ctxt, doc, node, options);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 2 as std::os::raw::c_int);
                    des_int(n_options, options, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlDOMWrapRemoveNode\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_options);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_options += 1
                }
                n_node += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocCopyNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut extended: std::os::raw::c_int = 0;
    let mut n_extended: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_extended = 0 as std::os::raw::c_int;
            while n_extended < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                extended = gen_int(n_extended, 2 as std::os::raw::c_int);
                ret_val = xmlDocCopyNode(node, doc, extended);
                desret_xmlNodePtr(ret_val);
                call_tests += 1;
                des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_int(n_extended, extended, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDocCopyNode\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_extended);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_extended += 1
            }
            n_doc += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocCopyNodeList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            ret_val = xmlDocCopyNodeList(doc, node);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDocCopyNodeList\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut n_f: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    n_f = 0 as std::os::raw::c_int;
    while n_f < 2 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            f = gen_FILE_ptr(n_f, 0 as std::os::raw::c_int);
            cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlDocDump(f, cur);
            desret_int(ret_val);
            call_tests += 1;
            des_FILE_ptr(n_f, f, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDocDump\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_f);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_f += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocDumpFormatMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut mem: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_mem: std::os::raw::c_int = 0;
    let mut size: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_size: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 4 as std::os::raw::c_int {
        n_mem = 0 as std::os::raw::c_int;
        while n_mem < 1 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 2 as std::os::raw::c_int {
                n_format = 0 as std::os::raw::c_int;
                while n_format < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    cur = gen_xmlDocPtr(n_cur, 0 as std::os::raw::c_int);
                    mem = gen_xmlChar_ptr_ptr(n_mem, 1 as std::os::raw::c_int);
                    size = gen_int_ptr(n_size, 2 as std::os::raw::c_int);
                    format = gen_int(n_format, 3 as std::os::raw::c_int);
                    xmlDocDumpFormatMemory(cur, mem, size, format);
                    call_tests += 1;
                    des_xmlDocPtr(n_cur, cur, 0 as std::os::raw::c_int);
                    des_xmlChar_ptr_ptr(n_mem, mem, 1 as std::os::raw::c_int);
                    des_int_ptr(n_size, size, 2 as std::os::raw::c_int);
                    des_int(n_format, format, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlDocDumpFormatMemory\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_mem);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_size);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_format);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_format += 1
                }
                n_size += 1
            }
            n_mem += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocDumpFormatMemoryEnc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut out_doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_out_doc: std::os::raw::c_int = 0;
    let mut doc_txt_ptr: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_doc_txt_ptr: std::os::raw::c_int = 0;
    let mut doc_txt_len: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_doc_txt_len: std::os::raw::c_int = 0;
    let mut txt_encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_txt_encoding: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_out_doc = 0 as std::os::raw::c_int;
    while n_out_doc < 4 as std::os::raw::c_int {
        n_doc_txt_ptr = 0 as std::os::raw::c_int;
        while n_doc_txt_ptr < 1 as std::os::raw::c_int {
            n_doc_txt_len = 0 as std::os::raw::c_int;
            while n_doc_txt_len < 2 as std::os::raw::c_int {
                n_txt_encoding = 0 as std::os::raw::c_int;
                while n_txt_encoding < 4 as std::os::raw::c_int {
                    n_format = 0 as std::os::raw::c_int;
                    while n_format < 4 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        out_doc = gen_xmlDocPtr(n_out_doc, 0 as std::os::raw::c_int);
                        doc_txt_ptr =
                            gen_xmlChar_ptr_ptr(n_doc_txt_ptr,
                                                1 as std::os::raw::c_int);
                        doc_txt_len =
                            gen_int_ptr(n_doc_txt_len, 2 as std::os::raw::c_int);
                        txt_encoding =
                            gen_const_char_ptr(n_txt_encoding,
                                               3 as std::os::raw::c_int);
                        format = gen_int(n_format, 4 as std::os::raw::c_int);
                        xmlDocDumpFormatMemoryEnc(out_doc, doc_txt_ptr,
                                                  doc_txt_len,
                                                  txt_encoding as
                                                      *const std::os::raw::c_char,
                                                  format);
                        call_tests += 1;
                        des_xmlDocPtr(n_out_doc, out_doc, 0 as std::os::raw::c_int);
                        des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr,
                                            1 as std::os::raw::c_int);
                        des_int_ptr(n_doc_txt_len, doc_txt_len,
                                    2 as std::os::raw::c_int);
                        des_const_char_ptr(n_txt_encoding,
                                           txt_encoding as
                                               *const std::os::raw::c_char,
                                           3 as std::os::raw::c_int);
                        des_int(n_format, format, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlDocDumpFormatMemoryEnc\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_out_doc);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_doc_txt_ptr);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_doc_txt_len);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_txt_encoding);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_format);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_format += 1
                    }
                    n_txt_encoding += 1
                }
                n_doc_txt_len += 1
            }
            n_doc_txt_ptr += 1
        }
        n_out_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocDumpMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut mem: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_mem: std::os::raw::c_int = 0;
    let mut size: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_size: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 4 as std::os::raw::c_int {
        n_mem = 0 as std::os::raw::c_int;
        while n_mem < 1 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 2 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                cur = gen_xmlDocPtr(n_cur, 0 as std::os::raw::c_int);
                mem = gen_xmlChar_ptr_ptr(n_mem, 1 as std::os::raw::c_int);
                size = gen_int_ptr(n_size, 2 as std::os::raw::c_int);
                xmlDocDumpMemory(cur, mem, size);
                call_tests += 1;
                des_xmlDocPtr(n_cur, cur, 0 as std::os::raw::c_int);
                des_xmlChar_ptr_ptr(n_mem, mem, 1 as std::os::raw::c_int);
                des_int_ptr(n_size, size, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDocDumpMemory\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_mem);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_size);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_size += 1
            }
            n_mem += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocDumpMemoryEnc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut out_doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_out_doc: std::os::raw::c_int = 0;
    let mut doc_txt_ptr: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_doc_txt_ptr: std::os::raw::c_int = 0;
    let mut doc_txt_len: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_doc_txt_len: std::os::raw::c_int = 0;
    let mut txt_encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_txt_encoding: std::os::raw::c_int = 0;
    n_out_doc = 0 as std::os::raw::c_int;
    while n_out_doc < 4 as std::os::raw::c_int {
        n_doc_txt_ptr = 0 as std::os::raw::c_int;
        while n_doc_txt_ptr < 1 as std::os::raw::c_int {
            n_doc_txt_len = 0 as std::os::raw::c_int;
            while n_doc_txt_len < 2 as std::os::raw::c_int {
                n_txt_encoding = 0 as std::os::raw::c_int;
                while n_txt_encoding < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    out_doc = gen_xmlDocPtr(n_out_doc, 0 as std::os::raw::c_int);
                    doc_txt_ptr =
                        gen_xmlChar_ptr_ptr(n_doc_txt_ptr, 1 as std::os::raw::c_int);
                    doc_txt_len =
                        gen_int_ptr(n_doc_txt_len, 2 as std::os::raw::c_int);
                    txt_encoding =
                        gen_const_char_ptr(n_txt_encoding, 3 as std::os::raw::c_int);
                    xmlDocDumpMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len,
                                        txt_encoding as *const std::os::raw::c_char);
                    call_tests += 1;
                    des_xmlDocPtr(n_out_doc, out_doc, 0 as std::os::raw::c_int);
                    des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr,
                                        1 as std::os::raw::c_int);
                    des_int_ptr(n_doc_txt_len, doc_txt_len, 2 as std::os::raw::c_int);
                    des_const_char_ptr(n_txt_encoding,
                                       txt_encoding as *const std::os::raw::c_char,
                                       3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlDocDumpMemoryEnc\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_out_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc_txt_ptr);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc_txt_len);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_txt_encoding);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_txt_encoding += 1
                }
                n_doc_txt_len += 1
            }
            n_doc_txt_ptr += 1
        }
        n_out_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocFormatDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut n_f: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_f = 0 as std::os::raw::c_int;
    while n_f < 2 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            n_format = 0 as std::os::raw::c_int;
            while n_format < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                f = gen_FILE_ptr(n_f, 0 as std::os::raw::c_int);
                cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
                format = gen_int(n_format, 2 as std::os::raw::c_int);
                ret_val = xmlDocFormatDump(f, cur, format);
                desret_int(ret_val);
                call_tests += 1;
                des_FILE_ptr(n_f, f, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
                des_int(n_format, format, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlDocFormatDump\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_f);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_format);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_format += 1
            }
            n_cur += 1
        }
        n_f += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocGetRootElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
        ret_val = xmlDocGetRootElement(doc as *const xmlDoc);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlDocGetRootElement\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDocSetRootElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut root: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_root: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_root = 0 as std::os::raw::c_int;
        while n_root < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            root = gen_xmlNodePtr_in(n_root, 1 as std::os::raw::c_int);
            ret_val = xmlDocSetRootElement(doc, root);
            if doc.is_null() { xmlFreeNode(root); root = 0 as xmlNodePtr }
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_xmlNodePtr_in(n_root, root, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDocSetRootElement\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_root);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_root += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlElemDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut n_f: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_f = 0 as std::os::raw::c_int;
    while n_f < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_cur = 0 as std::os::raw::c_int;
            while n_cur < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                f = gen_FILE_ptr(n_f, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                cur = gen_xmlNodePtr(n_cur, 2 as std::os::raw::c_int);
                xmlElemDump(f, doc, cur);
                call_tests += 1;
                des_FILE_ptr(n_f, f, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlNodePtr(n_cur, cur, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlElemDump\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_f);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_cur += 1
            }
            n_doc += 1
        }
        n_f += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlFirstElementChild() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_parent: std::os::raw::c_int = 0;
    n_parent = 0 as std::os::raw::c_int;
    while n_parent < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0 as std::os::raw::c_int);
        ret_val = xmlFirstElementChild(parent);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_parent, parent, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlFirstElementChild\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_parent);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_parent += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetBufferAllocationScheme() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlBufferAllocationScheme = XML_BUFFER_ALLOC_DOUBLEIT;
    mem_base = xmlMemBlocks();
    ret_val = xmlGetBufferAllocationScheme();
    desret_xmlBufferAllocationScheme(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlGetBufferAllocationScheme\x00"
                   as *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetCompressMode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    ret_val = xmlGetCompressMode();
    desret_int(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlGetCompressMode\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetDocCompressMode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
        ret_val = xmlGetDocCompressMode(doc as *const xmlDoc);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlGetDocCompressMode\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetIntSubset() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
        ret_val = xmlGetIntSubset(doc as *const xmlDoc);
        desret_xmlDtdPtr(ret_val);
        call_tests += 1;
        des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlGetIntSubset\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetLastChild() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_parent: std::os::raw::c_int = 0;
    n_parent = 0 as std::os::raw::c_int;
    while n_parent < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        parent = gen_const_xmlNode_ptr(n_parent, 0 as std::os::raw::c_int);
        ret_val = xmlGetLastChild(parent as *const xmlNode);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_const_xmlNode_ptr(n_parent, parent as *const xmlNode,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlGetLastChild\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_parent);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_parent += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetLineNo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_long = 0;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNode_ptr(n_node, 0 as std::os::raw::c_int);
        ret_val = xmlGetLineNo(node as *const xmlNode);
        desret_long(ret_val);
        call_tests += 1;
        des_const_xmlNode_ptr(n_node, node as *const xmlNode,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlGetLineNo\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_node);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetNoNsProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            node = gen_const_xmlNode_ptr(n_node, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val =
                xmlGetNoNsProp(node as *const xmlNode,
                               name as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlNode_ptr(n_node, node as *const xmlNode,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlGetNoNsProp\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetNodePath() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNode_ptr(n_node, 0 as std::os::raw::c_int);
        ret_val = xmlGetNodePath(node as *const xmlNode);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlNode_ptr(n_node, node as *const xmlNode,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlGetNodePath\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_node);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetNsList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the node */
}
unsafe extern "C" fn test_xmlGetNsProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the attribute name */
    let mut mem_base: std::os::raw::c_int = 0; /* the URI of the namespace */
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar; /* the node */
    let mut node: *mut xmlNode = 0 as *mut xmlNode; /* the attribute name */
    let mut n_node: std::os::raw::c_int = 0; /* the node */
    let mut name: *mut xmlChar = 0 as *mut xmlChar; /* the attribute name */
    let mut n_name: std::os::raw::c_int = 0; /* the URI of the namespace */
    let mut nameSpace: *mut xmlChar = 0 as *mut xmlChar; /* the node */
    let mut n_nameSpace: std::os::raw::c_int = 0; /* the attribute name */
    n_node = 0 as std::os::raw::c_int; /* the node */
    while n_node < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* the system identifier */
        while n_name < 5 as std::os::raw::c_int {
            n_nameSpace = 0 as std::os::raw::c_int; /* the public identifier */
            while n_nameSpace < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* the parent node */
                node =
                    gen_const_xmlNode_ptr(n_node,
                                          0 as
                                              std::os::raw::c_int); /* the document */
                name =
                    gen_const_xmlChar_ptr(n_name,
                                          1 as
                                              std::os::raw::c_int); /* the CDATA block content content */
                nameSpace =
                    gen_const_xmlChar_ptr(n_nameSpace,
                                          2 as
                                              std::os::raw::c_int); /* the length of the block */
                ret_val =
                    xmlGetNsProp(node as *const xmlNode,
                                 name as *const xmlChar,
                                 nameSpace as
                                     *const xmlChar); /* the document */
                desret_xmlChar_ptr(ret_val); /* the char ref string, starting with # or "&# ... ;" */
                call_tests += 1; /* the parent node */
                des_const_xmlNode_ptr(n_node, node as *const xmlNode,
                                      0 as
                                          std::os::raw::c_int); /* a namespace if any */
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as
                                          std::os::raw::c_int); /* the name of the child */
                des_const_xmlChar_ptr(n_nameSpace,
                                      nameSpace as *const xmlChar,
                                      2 as
                                          std::os::raw::c_int); /* the XML content of the child if any. */
                xmlResetLastError(); /* the comment content */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlGetNsProp\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() -
                               mem_base); /* xmlChar string giving the version of XML "1.0" */
                    test_ret += 1; /* the document */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node); /* the comment content */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name); /* the document owning the fragment */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_nameSpace); /* the document */
                    printf(b"\n\x00" as *const u8 as
                               *const std::os::raw::c_char); /* namespace if any */
                } /* the node name */
                n_nameSpace += 1
            } /* the XML text content if any */
            n_name += 1
        } /* the document */
        n_node += 1
    } /* namespace if any */
    function_tests += 1; /* the node name */
    return test_ret; /* the XML text content if any */
}
unsafe extern "C" fn test_xmlGetProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the target document */
    let mut mem_base: std::os::raw::c_int = 0; /* the processing instruction name */
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar; /* the PI content */
    let mut node: *mut xmlNode = 0 as *mut xmlNode; /* the document */
    let mut n_node: std::os::raw::c_int = 0; /* the name of the attribute */
    let mut name: *mut xmlChar =
        0 as *mut xmlChar; /* the value of the attribute */
    let mut n_name: std::os::raw::c_int = 0; /* the document */
    n_node = 0 as std::os::raw::c_int; /* namespace if any */
    while n_node < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* the node name */
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the text content if any */
            node =
                gen_const_xmlNode_ptr(n_node,
                                      0 as std::os::raw::c_int); /* the document */
            name =
                gen_const_xmlChar_ptr(n_name,
                                      1 as
                                          std::os::raw::c_int); /* the text content */
            ret_val =
                xmlGetProp(node as *const xmlNode,
                           name as *const xmlChar); /* the document */
            desret_xmlChar_ptr(ret_val); /* the text content */
            call_tests += 1; /* the text len. */
            des_const_xmlNode_ptr(n_node, node as *const xmlNode,
                                  0 as
                                      std::os::raw::c_int); /* the document pointer */
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int); /* the DTD name */
            xmlResetLastError(); /* the external ID */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlGetProp\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base); /* the system ID */
                test_ret += 1; /* namespace if any */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node); /* the node name */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name); /* namespace if any */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the node name */
            } /* the element carrying the namespace */
            n_name += 1
        } /* the URI associated */
        n_node += 1
    } /* the prefix for the namespace */
    function_tests += 1; /* the holding node */
    return test_ret; /* the namespace */
}
unsafe extern "C" fn test_xmlHasNsProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the name of the attribute */
    let mut mem_base: std::os::raw::c_int = 0; /* the value of the attribute */
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr; /* the holding node */
    let mut node: *mut xmlNode = 0 as *mut xmlNode; /* the namespace */
    let mut n_node: std::os::raw::c_int = 0; /* the name of the attribute */
    let mut name: *mut xmlChar =
        0 as *mut xmlChar; /* the value of the attribute */
    let mut n_name: std::os::raw::c_int = 0; /* the processing instruction name */
    let mut nameSpace: *mut xmlChar = 0 as *mut xmlChar; /* the PI content */
    let mut n_nameSpace: std::os::raw::c_int = 0; /* the holding node */
    n_node = 0 as std::os::raw::c_int; /* the name of the attribute */
    while n_node < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* the value of the attribute */
        while n_name < 5 as std::os::raw::c_int {
            n_nameSpace = 0 as std::os::raw::c_int; /* the document */
            while n_nameSpace < 5 as std::os::raw::c_int {
                mem_base =
                    xmlMemBlocks(); /* the reference name, or the reference string with & and ; */
                node =
                    gen_const_xmlNode_ptr(n_node,
                                          0 as
                                              std::os::raw::c_int); /* the text content */
                name =
                    gen_const_xmlChar_ptr(n_name,
                                          1 as
                                              std::os::raw::c_int); /* the parent node */
                nameSpace =
                    gen_const_xmlChar_ptr(n_nameSpace,
                                          2 as
                                              std::os::raw::c_int); /* a namespace if any */
                ret_val =
                    xmlHasNsProp(node as *const xmlNode,
                                 name as *const xmlChar,
                                 nameSpace as
                                     *const xmlChar); /* the name of the child */
                desret_xmlAttrPtr(ret_val); /* the text content of the child if any. */
                call_tests += 1; /* the text content */
                des_const_xmlNode_ptr(n_node, node as *const xmlNode,
                                      0 as std::os::raw::c_int); /* the text len. */
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as
                                          std::os::raw::c_int); /* the current node */
                des_const_xmlChar_ptr(n_nameSpace,
                                      nameSpace as *const xmlChar,
                                      2 as
                                          std::os::raw::c_int); /* the node being modified */
                xmlResetLastError(); /* extra content */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlHasNsProp\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() -
                               mem_base); /* the node being modified */
                    test_ret += 1; /* extra content */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node); /* the size of @content */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name); /* a buffer */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_nameSpace); /* the node being read */
                    printf(b"\n\x00" as *const u8 as
                               *const std::os::raw::c_char); /* the XML buffer output */
                } /* the document */
                n_nameSpace += 1
            } /* the current node */
            n_name += 1
        } /* the imbrication level for indenting */
        n_node += 1
    } /* is formatting allowed */
    function_tests += 1; /* the XML buffer output */
    return test_ret; /* the document */
}
unsafe extern "C" fn test_xmlHasProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the current node */
    let mut mem_base: std::os::raw::c_int =
        0; /* the imbrication level for indenting */
    let mut ret_val: xmlAttrPtr =
        0 as *mut xmlAttr; /* is formatting allowed */
    let mut node: *mut xmlNode =
        0 as *mut xmlNode; /* an optional encoding string */
    let mut n_node: std::os::raw::c_int = 0; /* the document the node pertains to */
    let mut name: *mut xmlChar =
        0 as *mut xmlChar; /* the node being checked */
    let mut n_name: std::os::raw::c_int = 0; /* the node being read */
    n_node = 0 as std::os::raw::c_int; /* the node being checked */
    while n_node < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* the node being checked */
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the node */
            node =
                gen_const_xmlNode_ptr(n_node,
                                      0 as std::os::raw::c_int); /* the document */
            name =
                gen_const_xmlChar_ptr(n_name,
                                      1 as std::os::raw::c_int); /* a Node list */
            ret_val =
                xmlHasProp(node as *const xmlNode,
                           name as
                               *const xmlChar); /* should we replace entity contents or show their external form */
            desret_xmlAttrPtr(ret_val); /* the document */
            call_tests += 1; /* a Node list */
            des_const_xmlNode_ptr(n_node, node as *const xmlNode,
                                  0 as
                                      std::os::raw::c_int); /* should we replace entity contents or show their external form */
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as
                                      std::os::raw::c_int); /* the node being changed */
            xmlResetLastError(); /* the new base URI */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlHasProp\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the node being modified */
                test_ret += 1; /* the new value of the content */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node); /* the node being modified */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name); /* the new value of the content */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the size of @content */
            } /* the node being changed */
            n_name += 1
        } /* the language description */
        n_node += 1
    } /* the node being changed */
    function_tests += 1; /* the new tag name */
    return test_ret; /* the node being changed */
}
unsafe extern "C" fn test_xmlIsBlankNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* the xml:space value ("0": default, 1: "preserve") */
    let mut mem_base: std::os::raw::c_int = 0; /* the current node */
    let mut ret_val: std::os::raw::c_int = 0; /* the document */
    let mut node: *mut xmlNode =
        0 as *mut xmlNode; /* a node defining the subtree to reconciliate */
    let mut n_node: std::os::raw::c_int = 0; /* an attribute */
    n_node = 0 as std::os::raw::c_int; /* the old node */
    while n_node < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the node */
        node =
            gen_const_xmlNode_ptr(n_node,
                                  0 as
                                      std::os::raw::c_int); /* the filename (or URL) */
        ret_val = xmlIsBlankNode(node as *const xmlNode); /* the document */
        desret_int(ret_val); /* the filename (or URL) */
        call_tests += 1; /* the document */
        des_const_xmlNode_ptr(n_node, node as *const xmlNode,
                              0 as
                                  std::os::raw::c_int); /* the name of an encoding (or NULL) */
        xmlResetLastError(); /* an output I/O buffer */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIsBlankNode\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* the document */
            test_ret +=
                1; /* the encoding if any assuming the I/O layer handles the trancoding */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_node); /* the filename (or URL) */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the document */
        } /* should formatting spaces been added */
        n_node += 1
    } /* the filename or URL to output */
    function_tests += 1; /* the document being saved */
    return test_ret; /* the name of the encoding to use or NULL. */
}
unsafe extern "C" fn test_xmlIsXHTML() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* should formatting spaces be added. */
    let mut mem_base: std::os::raw::c_int = 0; /* an output I/O buffer */
    let mut ret_val: std::os::raw::c_int = 0; /* the document */
    let mut systemID: *mut xmlChar =
        0 as
            *mut xmlChar; /* the encoding if any assuming the I/O layer handles the trancoding */
    let mut n_systemID: std::os::raw::c_int =
        0; /* should formatting spaces been added */
    let mut publicID: *mut xmlChar = 0 as *mut xmlChar; /* the document */
    let mut n_publicID: std::os::raw::c_int = 0; /* the current node */
    n_systemID = 0 as std::os::raw::c_int; /* the namespace prefix */
    while n_systemID < 5 as std::os::raw::c_int {
        n_publicID = 0 as std::os::raw::c_int; /* the document */
        while n_publicID < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the current node */
            systemID =
                gen_const_xmlChar_ptr(n_systemID,
                                      0 as
                                          std::os::raw::c_int); /* the namespace value */
            publicID =
                gen_const_xmlChar_ptr(n_publicID,
                                      1 as
                                          std::os::raw::c_int); /* allocation method to use */
            ret_val =
                xmlIsXHTML(systemID as *const xmlChar,
                           publicID as
                               *const xmlChar); /* the compression ratio */
            desret_int(ret_val); /* the document */
            call_tests += 1; /* the compression ratio */
            des_const_xmlChar_ptr(n_systemID, systemID as *const xmlChar,
                                  0 as
                                      std::os::raw::c_int); /* a node in the document */
            des_const_xmlChar_ptr(n_publicID, publicID as *const xmlChar,
                                  1 as std::os::raw::c_int); /* a namespace pointer */
            xmlResetLastError(); /* the node */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlIsXHTML\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the namespace definition */
                test_ret += 1; /* the attribute name */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_systemID); /* the attribute value */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_publicID); /* the node */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the attribute name (a QName) */
            } /* the attribute value */
            n_publicID += 1
        } /* the full QName */
        n_systemID += 1
    } /* a xmlChar ** */
    function_tests += 1; /* the full QName */
    return test_ret; /* an int * */
}
unsafe extern "C" fn test_xmlLastElementChild() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the document */
    let mut mem_base: std::os::raw::c_int = 0; /* the value of the attribute */
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode; /* the document */
    let mut parent: xmlNodePtr =
        0 as *mut xmlNode; /* the value of the text */
    let mut n_parent: std::os::raw::c_int = 0; /* the length of the string value */
    n_parent = 0 as std::os::raw::c_int; /* the node */
    while n_parent < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the content */
        parent =
            gen_xmlNodePtr(n_parent, 0 as std::os::raw::c_int); /* @content length */
        ret_val = xmlLastElementChild(parent); /* the first text node */
        desret_xmlNodePtr(ret_val); /* the second text node being merged */
        call_tests += 1; /* the node */
        des_xmlNodePtr(n_parent, parent,
                       0 as std::os::raw::c_int); /* the namespace definition */
        xmlResetLastError(); /* the attribute name */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlLastElementChild\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* the node */
            test_ret += 1; /* the attribute name */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_parent); /* the value to check */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* allow spaces in front and end of the string */
        } /* the value to check */
        n_parent += 1
    } /* allow spaces in front and end of the string */
    function_tests += 1; /* the value to check */
    return test_ret; /* allow spaces in front and end of the string */
}
unsafe extern "C" fn test_xmlNewCDataBlock() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the value to check */
    let mut mem_base: std::os::raw::c_int =
        0; /* allow spaces in front and end of the string */
    let mut ret_val: xmlNodePtr =
        0 as *mut xmlNode; /* the URI reference under consideration */
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc; /* the base value */
    let mut n_doc: std::os::raw::c_int =
        0; /* the URI instance found in the document */
    let mut content: *mut xmlChar = 0 as *mut xmlChar; /* the base value */
    let mut n_content: std::os::raw::c_int =
        0; /* the resource locator in a filesystem notation */
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!content.is_null() &&
                         len >
                             strlen(content as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlNewCDataBlock(doc, content as *const xmlChar, len);
                    desret_xmlNodePtr(ret_val);
                    call_tests += 1;
                    des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewCDataBlock\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_content += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewCharRef() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlNewCharRef(doc, name as *const xmlChar);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewCharRef\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewChild() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_parent: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_parent = 0 as std::os::raw::c_int;
    while n_parent < 3 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_content = 0 as std::os::raw::c_int;
                while n_content < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    parent = gen_xmlNodePtr(n_parent, 0 as std::os::raw::c_int);
                    ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    content =
                        gen_const_xmlChar_ptr(n_content, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlNewChild(parent, ns, name as *const xmlChar,
                                    content as *const xmlChar);
                    desret_xmlNodePtr(ret_val);
                    call_tests += 1;
                    des_xmlNodePtr(n_parent, parent, 0 as std::os::raw::c_int);
                    des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewChild\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_parent);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_content += 1
                }
                n_name += 1
            }
            n_ns += 1
        }
        n_parent += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewComment() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_content = 0 as std::os::raw::c_int;
    while n_content < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0 as std::os::raw::c_int);
        ret_val = xmlNewComment(content as *const xmlChar);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNewComment\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_content);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_content += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut version: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_version: std::os::raw::c_int = 0;
    n_version = 0 as std::os::raw::c_int;
    while n_version < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        version = gen_const_xmlChar_ptr(n_version, 0 as std::os::raw::c_int);
        ret_val = xmlNewDoc(version as *const xmlChar);
        desret_xmlDocPtr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_version, version as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNewDoc\x00" as *const u8 as
                       *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_version);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_version += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocComment() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            ret_val = xmlNewDocComment(doc, content as *const xmlChar);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewDocComment\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocFragment() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
        ret_val = xmlNewDocFragment(doc);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNewDocFragment\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_content = 0 as std::os::raw::c_int;
                while n_content < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                    ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    content =
                        gen_const_xmlChar_ptr(n_content, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlNewDocNode(doc, ns, name as *const xmlChar,
                                      content as *const xmlChar);
                    desret_xmlNodePtr(ret_val);
                    call_tests += 1;
                    des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                    des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewDocNode\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_content += 1
                }
                n_name += 1
            }
            n_ns += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocNodeEatName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 2 as std::os::raw::c_int {
                n_content = 0 as std::os::raw::c_int;
                while n_content < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                    ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
                    name = gen_eaten_name(n_name, 2 as std::os::raw::c_int);
                    content =
                        gen_const_xmlChar_ptr(n_content, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlNewDocNodeEatName(doc, ns, name,
                                             content as *const xmlChar);
                    desret_xmlNodePtr(ret_val);
                    call_tests += 1;
                    des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                    des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
                    des_eaten_name(n_name, name, 2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewDocNodeEatName\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_content += 1
                }
                n_name += 1
            }
            n_ns += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocPI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_content = 0 as std::os::raw::c_int;
            while n_content < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 2 as std::os::raw::c_int);
                ret_val =
                    xmlNewDocPI(doc, name as *const xmlChar,
                                content as *const xmlChar);
                desret_xmlNodePtr(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNewDocPI\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_content);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_content += 1
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int;
            while n_value < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                value = gen_const_xmlChar_ptr(n_value, 2 as std::os::raw::c_int);
                ret_val =
                    xmlNewDocProp(doc, name as *const xmlChar,
                                  value as *const xmlChar);
                desret_xmlAttrPtr(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNewDocProp\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_value);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_value += 1
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocRawNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_content = 0 as std::os::raw::c_int;
                while n_content < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                    ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    content =
                        gen_const_xmlChar_ptr(n_content, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlNewDocRawNode(doc, ns, name as *const xmlChar,
                                         content as *const xmlChar);
                    desret_xmlNodePtr(ret_val);
                    call_tests += 1;
                    des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                    des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewDocRawNode\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_content += 1
                }
                n_name += 1
            }
            n_ns += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocText() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            ret_val =
                xmlNewDocText(doc as *const xmlDoc,
                              content as *const xmlChar);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc,
                                 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewDocText\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocTextLen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!content.is_null() &&
                         len >
                             strlen(content as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlNewDocTextLen(doc, content as *const xmlChar, len);
                    desret_xmlNodePtr(ret_val);
                    call_tests += 1;
                    des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewDocTextLen\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_content += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDtd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ExternalID: std::os::raw::c_int = 0;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_SystemID: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_ExternalID = 0 as std::os::raw::c_int;
            while n_ExternalID < 5 as std::os::raw::c_int {
                n_SystemID = 0 as std::os::raw::c_int;
                while n_SystemID < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    ExternalID =
                        gen_const_xmlChar_ptr(n_ExternalID, 2 as std::os::raw::c_int);
                    SystemID =
                        gen_const_xmlChar_ptr(n_SystemID, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlNewDtd(doc, name as *const xmlChar,
                                  ExternalID as *const xmlChar,
                                  SystemID as *const xmlChar);
                    desret_xmlDtdPtr(ret_val);
                    call_tests += 1;
                    des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_ExternalID,
                                          ExternalID as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_SystemID,
                                          SystemID as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewDtd\x00" as
                                   *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ExternalID);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_SystemID);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_SystemID += 1
                }
                n_ExternalID += 1
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_ns = 0 as std::os::raw::c_int;
    while n_ns < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ns = gen_xmlNsPtr(n_ns, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlNewNode(ns, name as *const xmlChar);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNsPtr(n_ns, ns, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewNode\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ns);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_ns += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewNodeEatName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_ns = 0 as std::os::raw::c_int;
    while n_ns < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ns = gen_xmlNsPtr(n_ns, 0 as std::os::raw::c_int);
            name = gen_eaten_name(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlNewNodeEatName(ns, name);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNsPtr(n_ns, ns, 0 as std::os::raw::c_int);
            des_eaten_name(n_name, name, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewNodeEatName\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ns);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_ns += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNsPtr = 0 as *mut xmlNs;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut href: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_href: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_href = 0 as std::os::raw::c_int;
        while n_href < 5 as std::os::raw::c_int {
            n_prefix = 0 as std::os::raw::c_int;
            while n_prefix < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                href = gen_const_xmlChar_ptr(n_href, 1 as std::os::raw::c_int);
                prefix = gen_const_xmlChar_ptr(n_prefix, 2 as std::os::raw::c_int);
                ret_val =
                    xmlNewNs(node, href as *const xmlChar,
                             prefix as *const xmlChar);
                if node.is_null() && !ret_val.is_null() {
                    xmlFreeNs(ret_val);
                }
                desret_xmlNsPtr(ret_val);
                call_tests += 1;
                des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_href, href as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNewNs\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_href);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_prefix);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_prefix += 1
            }
            n_href += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewNsProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_value = 0 as std::os::raw::c_int;
                while n_value < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                    ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    value = gen_const_xmlChar_ptr(n_value, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlNewNsProp(node, ns, name as *const xmlChar,
                                     value as *const xmlChar);
                    desret_xmlAttrPtr(ret_val);
                    call_tests += 1;
                    des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                    des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewNsProp\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_value += 1
                }
                n_name += 1
            }
            n_ns += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewNsPropEatName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 2 as std::os::raw::c_int {
                n_value = 0 as std::os::raw::c_int;
                while n_value < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                    ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
                    name = gen_eaten_name(n_name, 2 as std::os::raw::c_int);
                    value = gen_const_xmlChar_ptr(n_value, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlNewNsPropEatName(node, ns, name,
                                            value as *const xmlChar);
                    desret_xmlAttrPtr(ret_val);
                    call_tests += 1;
                    des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                    des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
                    des_eaten_name(n_name, name, 2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewNsPropEatName\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_value += 1
                }
                n_name += 1
            }
            n_ns += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewPI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            ret_val =
                xmlNewPI(name as *const xmlChar, content as *const xmlChar);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewPI\x00" as *const u8
                           as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int;
            while n_value < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                value = gen_const_xmlChar_ptr(n_value, 2 as std::os::raw::c_int);
                ret_val =
                    xmlNewProp(node, name as *const xmlChar,
                               value as *const xmlChar);
                desret_xmlAttrPtr(ret_val);
                call_tests += 1;
                des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNewProp\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_value);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_value += 1
            }
            n_name += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewReference() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val =
                xmlNewReference(doc as *const xmlDoc, name as *const xmlChar);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc,
                                 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewReference\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewText() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_content = 0 as std::os::raw::c_int;
    while n_content < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0 as std::os::raw::c_int);
        ret_val = xmlNewText(content as *const xmlChar);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNewText\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_content);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_content += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewTextChild() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_parent: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_parent = 0 as std::os::raw::c_int;
    while n_parent < 3 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_content = 0 as std::os::raw::c_int;
                while n_content < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    parent = gen_xmlNodePtr(n_parent, 0 as std::os::raw::c_int);
                    ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    content =
                        gen_const_xmlChar_ptr(n_content, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlNewTextChild(parent, ns, name as *const xmlChar,
                                        content as *const xmlChar);
                    desret_xmlNodePtr(ret_val);
                    call_tests += 1;
                    des_xmlNodePtr(n_parent, parent, 0 as std::os::raw::c_int);
                    des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNewTextChild\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_parent);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_content += 1
                }
                n_name += 1
            }
            n_ns += 1
        }
        n_parent += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewTextLen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_content = 0 as std::os::raw::c_int;
    while n_content < 5 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            content = gen_const_xmlChar_ptr(n_content, 0 as std::os::raw::c_int);
            len = gen_int(n_len, 1 as std::os::raw::c_int);
            if !(!content.is_null() &&
                     len >
                         strlen(content as *const std::os::raw::c_char) as std::os::raw::c_int
                             + 1 as std::os::raw::c_int) {
                ret_val = xmlNewTextLen(content as *const xmlChar, len);
                desret_xmlNodePtr(ret_val);
                call_tests += 1;
                des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                      0 as std::os::raw::c_int);
                des_int(n_len, len, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNewTextLen\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_content);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_len += 1
        }
        n_content += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNextElementSibling() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
        ret_val = xmlNextElementSibling(node);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNextElementSibling\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_node);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeAddContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            xmlNodeAddContent(cur, content as *const xmlChar);
            call_tests += 1;
            des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNodeAddContent\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeAddContentLen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!content.is_null() &&
                         len >
                             strlen(content as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    xmlNodeAddContentLen(cur, content as *const xmlChar, len);
                    call_tests += 1;
                    des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNodeAddContentLen\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_content += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeBufGetContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buffer: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 3 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buffer = gen_xmlBufferPtr(n_buffer, 0 as std::os::raw::c_int);
            cur = gen_const_xmlNode_ptr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlNodeBufGetContent(buffer, cur as *const xmlNode);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlBufferPtr(n_buffer, buffer, 0 as std::os::raw::c_int);
            des_const_xmlNode_ptr(n_cur, cur as *const xmlNode,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNodeBufGetContent\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_buffer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut level: std::os::raw::c_int = 0;
    let mut n_level: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_cur = 0 as std::os::raw::c_int;
            while n_cur < 3 as std::os::raw::c_int {
                n_level = 0 as std::os::raw::c_int;
                while n_level < 4 as std::os::raw::c_int {
                    n_format = 0 as std::os::raw::c_int;
                    while n_format < 4 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
                        doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                        cur = gen_xmlNodePtr(n_cur, 2 as std::os::raw::c_int);
                        level = gen_int(n_level, 3 as std::os::raw::c_int);
                        format = gen_int(n_format, 4 as std::os::raw::c_int);
                        ret_val = xmlNodeDump(buf, doc, cur, level, format);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
                        des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                        des_xmlNodePtr(n_cur, cur, 2 as std::os::raw::c_int);
                        des_int(n_level, level, 3 as std::os::raw::c_int);
                        des_int(n_format, format, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlNodeDump\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_buf);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_doc);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_cur);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_level);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_format);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_format += 1
                    }
                    n_level += 1
                }
                n_cur += 1
            }
            n_doc += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeDumpOutput() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut level: std::os::raw::c_int = 0;
    let mut n_level: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_cur = 0 as std::os::raw::c_int;
            while n_cur < 3 as std::os::raw::c_int {
                n_level = 0 as std::os::raw::c_int;
                while n_level < 4 as std::os::raw::c_int {
                    n_format = 0 as std::os::raw::c_int;
                    while n_format < 4 as std::os::raw::c_int {
                        n_encoding = 0 as std::os::raw::c_int;
                        while n_encoding < 4 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            buf =
                                gen_xmlOutputBufferPtr(n_buf,
                                                       0 as std::os::raw::c_int);
                            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                            cur = gen_xmlNodePtr(n_cur, 2 as std::os::raw::c_int);
                            level = gen_int(n_level, 3 as std::os::raw::c_int);
                            format = gen_int(n_format, 4 as std::os::raw::c_int);
                            encoding =
                                gen_const_char_ptr(n_encoding,
                                                   5 as std::os::raw::c_int);
                            xmlNodeDumpOutput(buf, doc, cur, level, format,
                                              encoding as
                                                  *const std::os::raw::c_char);
                            call_tests += 1;
                            des_xmlOutputBufferPtr(n_buf, buf,
                                                   0 as std::os::raw::c_int);
                            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                            des_xmlNodePtr(n_cur, cur, 2 as std::os::raw::c_int);
                            des_int(n_level, level, 3 as std::os::raw::c_int);
                            des_int(n_format, format, 4 as std::os::raw::c_int);
                            des_const_char_ptr(n_encoding,
                                               encoding as
                                                   *const std::os::raw::c_char,
                                               5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlNodeDumpOutput\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_buf);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_doc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_cur);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_level);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_format);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_encoding);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_encoding += 1
                        }
                        n_format += 1
                    }
                    n_level += 1
                }
                n_cur += 1
            }
            n_doc += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeGetBase() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
            cur = gen_const_xmlNode_ptr(n_cur, 1 as std::os::raw::c_int);
            ret_val =
                xmlNodeGetBase(doc as *const xmlDoc, cur as *const xmlNode);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc,
                                 0 as std::os::raw::c_int);
            des_const_xmlNode_ptr(n_cur, cur as *const xmlNode,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNodeGetBase\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeGetContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlNode_ptr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlNodeGetContent(cur as *const xmlNode);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlNode_ptr(n_cur, cur as *const xmlNode, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNodeGetContent\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeGetLang() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlNode_ptr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlNodeGetLang(cur as *const xmlNode);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlNode_ptr(n_cur, cur as *const xmlNode, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNodeGetLang\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeGetSpacePreserve() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlNode_ptr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlNodeGetSpacePreserve(cur as *const xmlNode);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlNode_ptr(n_cur, cur as *const xmlNode, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNodeGetSpacePreserve\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeIsText() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNode_ptr(n_node, 0 as std::os::raw::c_int);
        ret_val = xmlNodeIsText(node as *const xmlNode);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlNode_ptr(n_node, node as *const xmlNode,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNodeIsText\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_node);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeListGetRawString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut list: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_list: std::os::raw::c_int = 0;
    let mut inLine: std::os::raw::c_int = 0;
    let mut n_inLine: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        n_list = 0 as std::os::raw::c_int;
        while n_list < 1 as std::os::raw::c_int {
            n_inLine = 0 as std::os::raw::c_int;
            while n_inLine < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
                list = gen_const_xmlNode_ptr(n_list, 1 as std::os::raw::c_int);
                inLine = gen_int(n_inLine, 2 as std::os::raw::c_int);
                ret_val =
                    xmlNodeListGetRawString(doc as *const xmlDoc,
                                            list as *const xmlNode, inLine);
                desret_xmlChar_ptr(ret_val);
                call_tests += 1;
                des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc,
                                     0 as std::os::raw::c_int);
                des_const_xmlNode_ptr(n_list, list as *const xmlNode,
                                      1 as std::os::raw::c_int);
                des_int(n_inLine, inLine, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNodeListGetRawString\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_list);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_inLine);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_inLine += 1
            }
            n_list += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeListGetString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut list: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_list: std::os::raw::c_int = 0;
    let mut inLine: std::os::raw::c_int = 0;
    let mut n_inLine: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_list = 0 as std::os::raw::c_int;
        while n_list < 1 as std::os::raw::c_int {
            n_inLine = 0 as std::os::raw::c_int;
            while n_inLine < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                list = gen_const_xmlNode_ptr(n_list, 1 as std::os::raw::c_int);
                inLine = gen_int(n_inLine, 2 as std::os::raw::c_int);
                ret_val =
                    xmlNodeListGetString(doc, list as *const xmlNode, inLine);
                desret_xmlChar_ptr(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_const_xmlNode_ptr(n_list, list as *const xmlNode,
                                      1 as std::os::raw::c_int);
                des_int(n_inLine, inLine, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNodeListGetString\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_list);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_inLine);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_inLine += 1
            }
            n_list += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeSetBase() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut uri: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_uri: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_uri = 0 as std::os::raw::c_int;
        while n_uri < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
            uri = gen_const_xmlChar_ptr(n_uri, 1 as std::os::raw::c_int);
            xmlNodeSetBase(cur, uri as *const xmlChar);
            call_tests += 1;
            des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_uri, uri as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNodeSetBase\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_uri);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_uri += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeSetContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            xmlNodeSetContent(cur, content as *const xmlChar);
            call_tests += 1;
            des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNodeSetContent\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeSetContentLen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!content.is_null() &&
                         len >
                             strlen(content as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    xmlNodeSetContentLen(cur, content as *const xmlChar, len);
                    call_tests += 1;
                    des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlNodeSetContentLen\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_content += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeSetLang() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut lang: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_lang: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_lang = 0 as std::os::raw::c_int;
        while n_lang < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
            lang = gen_const_xmlChar_ptr(n_lang, 1 as std::os::raw::c_int);
            xmlNodeSetLang(cur, lang as *const xmlChar);
            call_tests += 1;
            des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_lang, lang as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNodeSetLang\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_lang);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_lang += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeSetName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            xmlNodeSetName(cur, name as *const xmlChar);
            call_tests += 1;
            des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNodeSetName\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNodeSetSpacePreserve() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 3 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodePtr(n_cur, 0 as std::os::raw::c_int);
            val = gen_int(n_val, 1 as std::os::raw::c_int);
            xmlNodeSetSpacePreserve(cur, val);
            call_tests += 1;
            des_xmlNodePtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_int(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNodeSetSpacePreserve\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPreviousElementSibling() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
        ret_val = xmlPreviousElementSibling(node);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlPreviousElementSibling\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_node);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReconciliateNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_tree: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_tree = 0 as std::os::raw::c_int;
        while n_tree < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            tree = gen_xmlNodePtr(n_tree, 1 as std::os::raw::c_int);
            ret_val = xmlReconciliateNs(doc, tree);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_tree, tree, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlReconciliateNs\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_tree);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_tree += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRemoveProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_xmlAttrPtr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlRemoveProp(cur);
        cur = 0 as xmlAttrPtr;
        desret_int(ret_val);
        call_tests += 1;
        des_xmlAttrPtr(n_cur, cur, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlRemoveProp\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReplaceNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut old: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_old: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_old = 0 as std::os::raw::c_int;
    while n_old < 3 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            old = gen_xmlNodePtr(n_old, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr_in(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlReplaceNode(old, cur);
            if !cur.is_null() {
                xmlUnlinkNode(cur);
                xmlFreeNode(cur);
                cur = 0 as xmlNodePtr
            }
            if !old.is_null() {
                xmlUnlinkNode(old);
                xmlFreeNode(old);
                old = 0 as xmlNodePtr
            }
            ret_val = 0 as xmlNodePtr;
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_old, old, 0 as std::os::raw::c_int);
            des_xmlNodePtr_in(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlReplaceNode\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_old);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_old += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
            cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlSaveFile(filename, cur);
            desret_int(ret_val);
            call_tests += 1;
            des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSaveFile\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_filename);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveFileEnc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
                cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
                encoding = gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                ret_val =
                    xmlSaveFileEnc(filename, cur,
                                   encoding as *const std::os::raw::c_char);
                desret_int(ret_val);
                call_tests += 1;
                des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
                des_const_char_ptr(n_encoding,
                                   encoding as *const std::os::raw::c_char,
                                   2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSaveFileEnc\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_encoding);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_encoding += 1
            }
            n_cur += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveFileTo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 2 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                buf = gen_xmlOutputBufferPtr(n_buf, 0 as std::os::raw::c_int);
                cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
                encoding = gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                ret_val =
                    xmlSaveFileTo(buf, cur, encoding as *const std::os::raw::c_char);
                buf = 0 as xmlOutputBufferPtr;
                desret_int(ret_val);
                call_tests += 1;
                des_xmlOutputBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
                des_const_char_ptr(n_encoding,
                                   encoding as *const std::os::raw::c_char,
                                   2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSaveFileTo\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buf);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_encoding);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_encoding += 1
            }
            n_cur += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveFormatFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            n_format = 0 as std::os::raw::c_int;
            while n_format < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
                cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
                format = gen_int(n_format, 2 as std::os::raw::c_int);
                ret_val = xmlSaveFormatFile(filename, cur, format);
                desret_int(ret_val);
                call_tests += 1;
                des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
                des_int(n_format, format, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSaveFormatFile\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_format);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_format += 1
            }
            n_cur += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveFormatFileEnc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 6 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                n_format = 0 as std::os::raw::c_int;
                while n_format < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    filename = gen_fileoutput(n_filename, 0 as std::os::raw::c_int);
                    cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                    format = gen_int(n_format, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlSaveFormatFileEnc(filename, cur,
                                             encoding as *const std::os::raw::c_char,
                                             format);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_fileoutput(n_filename, filename, 0 as std::os::raw::c_int);
                    des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_int(n_format, format, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSaveFormatFileEnc\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_filename);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_format);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_format += 1
                }
                n_encoding += 1
            }
            n_cur += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveFormatFileTo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut n_format: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 2 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 4 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                n_format = 0 as std::os::raw::c_int;
                while n_format < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    buf = gen_xmlOutputBufferPtr(n_buf, 0 as std::os::raw::c_int);
                    cur = gen_xmlDocPtr(n_cur, 1 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                    format = gen_int(n_format, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlSaveFormatFileTo(buf, cur,
                                            encoding as *const std::os::raw::c_char,
                                            format);
                    buf = 0 as xmlOutputBufferPtr;
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlOutputBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
                    des_xmlDocPtr(n_cur, cur, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_int(n_format, format, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSaveFormatFileTo\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buf);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_format);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_format += 1
                }
                n_encoding += 1
            }
            n_cur += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSearchNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNsPtr = 0 as *mut xmlNs;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut nameSpace: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_nameSpace: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            n_nameSpace = 0 as std::os::raw::c_int;
            while n_nameSpace < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
                nameSpace =
                    gen_const_xmlChar_ptr(n_nameSpace, 2 as std::os::raw::c_int);
                ret_val = xmlSearchNs(doc, node, nameSpace as *const xmlChar);
                desret_xmlNsPtr(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_nameSpace,
                                      nameSpace as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSearchNs\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_nameSpace);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_nameSpace += 1
            }
            n_node += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSearchNsByHref() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNsPtr = 0 as *mut xmlNs;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut href: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_href: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            n_href = 0 as std::os::raw::c_int;
            while n_href < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
                href = gen_const_xmlChar_ptr(n_href, 2 as std::os::raw::c_int);
                ret_val =
                    xmlSearchNsByHref(doc, node, href as *const xmlChar);
                desret_xmlNsPtr(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_href, href as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSearchNsByHref\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_href);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_href += 1
            }
            n_node += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSetBufferAllocationScheme() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut scheme: xmlBufferAllocationScheme = XML_BUFFER_ALLOC_DOUBLEIT;
    let mut n_scheme: std::os::raw::c_int = 0;
    n_scheme = 0 as std::os::raw::c_int;
    while n_scheme < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        scheme = gen_xmlBufferAllocationScheme(n_scheme, 0 as std::os::raw::c_int);
        xmlSetBufferAllocationScheme(scheme);
        call_tests += 1;
        des_xmlBufferAllocationScheme(n_scheme, scheme, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSetBufferAllocationScheme\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_scheme);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_scheme += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSetCompressMode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut mode: std::os::raw::c_int = 0;
    let mut n_mode: std::os::raw::c_int = 0;
    n_mode = 0 as std::os::raw::c_int;
    while n_mode < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        mode = gen_int(n_mode, 0 as std::os::raw::c_int);
        xmlSetCompressMode(mode);
        call_tests += 1;
        des_int(n_mode, mode, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSetCompressMode\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_mode);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_mode += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSetDocCompressMode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut mode: std::os::raw::c_int = 0;
    let mut n_mode: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_mode = 0 as std::os::raw::c_int;
        while n_mode < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            mode = gen_int(n_mode, 1 as std::os::raw::c_int);
            xmlSetDocCompressMode(doc, mode);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_int(n_mode, mode, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSetDocCompressMode\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_mode);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_mode += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSetNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
            ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
            xmlSetNs(node, ns);
            call_tests += 1;
            des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
            des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSetNs\x00" as *const u8
                           as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ns);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ns += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSetNsProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_value = 0 as std::os::raw::c_int;
                while n_value < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                    ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    value = gen_const_xmlChar_ptr(n_value, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlSetNsProp(node, ns, name as *const xmlChar,
                                     value as *const xmlChar);
                    desret_xmlAttrPtr(ret_val);
                    call_tests += 1;
                    des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                    des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSetNsProp\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_value += 1
                }
                n_name += 1
            }
            n_ns += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSetProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int;
            while n_value < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                value = gen_const_xmlChar_ptr(n_value, 2 as std::os::raw::c_int);
                ret_val =
                    xmlSetProp(node, name as *const xmlChar,
                               value as *const xmlChar);
                desret_xmlAttrPtr(ret_val);
                call_tests += 1;
                des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSetProp\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_value);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_value += 1
            }
            n_name += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSplitQName2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut prefix: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
            prefix = gen_xmlChar_ptr_ptr(n_prefix, 1 as std::os::raw::c_int);
            ret_val = xmlSplitQName2(name as *const xmlChar, prefix);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_xmlChar_ptr_ptr(n_prefix, prefix, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSplitQName2\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_prefix);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_prefix += 1
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSplitQName3() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut len: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_len: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
            len = gen_int_ptr(n_len, 1 as std::os::raw::c_int);
            ret_val = xmlSplitQName3(name as *const xmlChar, len);
            desret_const_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_int_ptr(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSplitQName3\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStringGetNodeList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
            value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
            ret_val =
                xmlStringGetNodeList(doc as *const xmlDoc,
                                     value as *const xmlChar);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc,
                                 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlStringGetNodeList\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_value += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStringLenGetNodeList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_const_xmlDoc_ptr(n_doc, 0 as std::os::raw::c_int);
                value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!value.is_null() &&
                         len >
                             strlen(value as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlStringLenGetNodeList(doc as *const xmlDoc,
                                                value as *const xmlChar, len);
                    desret_xmlNodePtr(ret_val);
                    call_tests += 1;
                    des_const_xmlDoc_ptr(n_doc, doc as *const xmlDoc,
                                         0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlStringLenGetNodeList\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_value += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextConcat() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!content.is_null() &&
                         len >
                             strlen(content as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlTextConcat(node, content as *const xmlChar, len);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlTextConcat\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_content += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextMerge() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut first: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_first: std::os::raw::c_int = 0;
    let mut second: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_second: std::os::raw::c_int = 0;
    n_first = 0 as std::os::raw::c_int;
    while n_first < 3 as std::os::raw::c_int {
        n_second = 0 as std::os::raw::c_int;
        while n_second < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            first = gen_xmlNodePtr_in(n_first, 0 as std::os::raw::c_int);
            second = gen_xmlNodePtr_in(n_second, 1 as std::os::raw::c_int);
            ret_val = xmlTextMerge(first, second);
            if !first.is_null() &&
                   (*first).type_0 as std::os::raw::c_uint !=
                       XML_TEXT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
                xmlUnlinkNode(second);
                xmlFreeNode(second);
                second = 0 as xmlNodePtr
            }
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr_in(n_first, first, 0 as std::os::raw::c_int);
            des_xmlNodePtr_in(n_second, second, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextMerge\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_first);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_second);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_second += 1
        }
        n_first += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUnsetNsProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 2 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
                ns = gen_xmlNsPtr(n_ns, 1 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                ret_val = xmlUnsetNsProp(node, ns, name as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
                des_xmlNsPtr(n_ns, ns, 1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlUnsetNsProp\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ns);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_name += 1
            }
            n_ns += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUnsetProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlUnsetProp(node, name as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlUnsetProp\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateNCName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut space: std::os::raw::c_int = 0;
    let mut n_space: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        n_space = 0 as std::os::raw::c_int;
        while n_space < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
            space = gen_int(n_space, 1 as std::os::raw::c_int);
            ret_val = xmlValidateNCName(value as *const xmlChar, space);
            desret_int(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_int(n_space, space, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidateNCName\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_space);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_space += 1
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateNMToken() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut space: std::os::raw::c_int = 0;
    let mut n_space: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        n_space = 0 as std::os::raw::c_int;
        while n_space < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
            space = gen_int(n_space, 1 as std::os::raw::c_int);
            ret_val = xmlValidateNMToken(value as *const xmlChar, space);
            desret_int(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_int(n_space, space, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidateNMToken\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_space);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_space += 1
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut space: std::os::raw::c_int = 0;
    let mut n_space: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        n_space = 0 as std::os::raw::c_int;
        while n_space < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
            space = gen_int(n_space, 1 as std::os::raw::c_int);
            ret_val = xmlValidateName(value as *const xmlChar, space);
            desret_int(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_int(n_space, space, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidateName\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_space);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_space += 1
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateQName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut space: std::os::raw::c_int = 0;
    let mut n_space: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        n_space = 0 as std::os::raw::c_int;
        while n_space < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
            space = gen_int(n_space, 1 as std::os::raw::c_int);
            ret_val = xmlValidateQName(value as *const xmlChar, space);
            desret_int(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_int(n_space, space, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidateQName\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_space);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_space += 1
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_tree() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing tree : 142 of 164 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlAddChild();
    test_ret += test_xmlAddChildList();
    test_ret += test_xmlAddNextSibling();
    test_ret += test_xmlAddPrevSibling();
    test_ret += test_xmlAddSibling();
    test_ret += test_xmlAttrSerializeTxtContent();
    test_ret += test_xmlBufContent();
    test_ret += test_xmlBufEnd();
    test_ret += test_xmlBufGetNodeContent();
    test_ret += test_xmlBufNodeDump();
    test_ret += test_xmlBufShrink();
    test_ret += test_xmlBufUse();
    test_ret += test_xmlBufferAdd();
    test_ret += test_xmlBufferAddHead();
    test_ret += test_xmlBufferCCat();
    test_ret += test_xmlBufferCat();
    test_ret += test_xmlBufferContent();
    test_ret += test_xmlBufferCreate();
    test_ret += test_xmlBufferCreateSize();
    test_ret += test_xmlBufferCreateStatic();
    test_ret += test_xmlBufferDetach();
    test_ret += test_xmlBufferEmpty();
    test_ret += test_xmlBufferGrow();
    test_ret += test_xmlBufferLength();
    test_ret += test_xmlBufferResize();
    test_ret += test_xmlBufferSetAllocationScheme();
    test_ret += test_xmlBufferShrink();
    test_ret += test_xmlBufferWriteCHAR();
    test_ret += test_xmlBufferWriteChar();
    test_ret += test_xmlBufferWriteQuotedString();
    test_ret += test_xmlBuildQName();
    test_ret += test_xmlChildElementCount();
    test_ret += test_xmlCopyDoc();
    test_ret += test_xmlCopyDtd();
    test_ret += test_xmlCopyNamespace();
    test_ret += test_xmlCopyNamespaceList();
    test_ret += test_xmlCopyNode();
    test_ret += test_xmlCopyNodeList();
    test_ret += test_xmlCopyProp();
    test_ret += test_xmlCopyPropList();
    test_ret += test_xmlCreateIntSubset();
    test_ret += test_xmlDOMWrapAdoptNode();
    test_ret += test_xmlDOMWrapCloneNode();
    test_ret += test_xmlDOMWrapNewCtxt();
    test_ret += test_xmlDOMWrapReconcileNamespaces();
    test_ret += test_xmlDOMWrapRemoveNode();
    test_ret += test_xmlDocCopyNode();
    test_ret += test_xmlDocCopyNodeList();
    test_ret += test_xmlDocDump();
    test_ret += test_xmlDocDumpFormatMemory();
    test_ret += test_xmlDocDumpFormatMemoryEnc();
    test_ret += test_xmlDocDumpMemory();
    test_ret += test_xmlDocDumpMemoryEnc();
    test_ret += test_xmlDocFormatDump();
    test_ret += test_xmlDocGetRootElement();
    test_ret += test_xmlDocSetRootElement();
    test_ret += test_xmlElemDump();
    test_ret += test_xmlFirstElementChild();
    test_ret += test_xmlGetBufferAllocationScheme();
    test_ret += test_xmlGetCompressMode();
    test_ret += test_xmlGetDocCompressMode();
    test_ret += test_xmlGetIntSubset();
    test_ret += test_xmlGetLastChild();
    test_ret += test_xmlGetLineNo();
    test_ret += test_xmlGetNoNsProp();
    test_ret += test_xmlGetNodePath();
    test_ret += test_xmlGetNsList();
    test_ret += test_xmlGetNsProp();
    test_ret += test_xmlGetProp();
    test_ret += test_xmlHasNsProp();
    test_ret += test_xmlHasProp();
    test_ret += test_xmlIsBlankNode();
    test_ret += test_xmlIsXHTML();
    test_ret += test_xmlLastElementChild();
    test_ret += test_xmlNewCDataBlock();
    test_ret += test_xmlNewCharRef();
    test_ret += test_xmlNewChild();
    test_ret += test_xmlNewComment();
    test_ret += test_xmlNewDoc();
    test_ret += test_xmlNewDocComment();
    test_ret += test_xmlNewDocFragment();
    test_ret += test_xmlNewDocNode();
    test_ret += test_xmlNewDocNodeEatName();
    test_ret += test_xmlNewDocPI();
    test_ret += test_xmlNewDocProp();
    test_ret += test_xmlNewDocRawNode();
    test_ret += test_xmlNewDocText();
    test_ret += test_xmlNewDocTextLen();
    test_ret += test_xmlNewDtd();
    test_ret += test_xmlNewNode();
    test_ret += test_xmlNewNodeEatName();
    test_ret += test_xmlNewNs();
    test_ret += test_xmlNewNsProp();
    test_ret += test_xmlNewNsPropEatName();
    test_ret += test_xmlNewPI();
    test_ret += test_xmlNewProp();
    test_ret += test_xmlNewReference();
    test_ret += test_xmlNewText();
    test_ret += test_xmlNewTextChild();
    test_ret += test_xmlNewTextLen();
    test_ret += test_xmlNextElementSibling();
    test_ret += test_xmlNodeAddContent();
    test_ret += test_xmlNodeAddContentLen();
    test_ret += test_xmlNodeBufGetContent();
    test_ret += test_xmlNodeDump();
    test_ret += test_xmlNodeDumpOutput();
    test_ret += test_xmlNodeGetBase();
    test_ret += test_xmlNodeGetContent();
    test_ret += test_xmlNodeGetLang();
    test_ret += test_xmlNodeGetSpacePreserve();
    test_ret += test_xmlNodeIsText();
    test_ret += test_xmlNodeListGetRawString();
    test_ret += test_xmlNodeListGetString();
    test_ret += test_xmlNodeSetBase();
    test_ret += test_xmlNodeSetContent();
    test_ret += test_xmlNodeSetContentLen();
    test_ret += test_xmlNodeSetLang();
    test_ret += test_xmlNodeSetName();
    test_ret += test_xmlNodeSetSpacePreserve();
    test_ret += test_xmlPreviousElementSibling();
    test_ret += test_xmlReconciliateNs();
    test_ret += test_xmlRemoveProp();
    test_ret += test_xmlReplaceNode();
    test_ret += test_xmlSaveFile();
    test_ret += test_xmlSaveFileEnc();
    test_ret += test_xmlSaveFileTo();
    test_ret += test_xmlSaveFormatFile();
    test_ret += test_xmlSaveFormatFileEnc();
    test_ret += test_xmlSaveFormatFileTo();
    test_ret += test_xmlSearchNs();
    test_ret += test_xmlSearchNsByHref();
    test_ret += test_xmlSetBufferAllocationScheme();
    test_ret += test_xmlSetCompressMode();
    test_ret += test_xmlSetDocCompressMode();
    test_ret += test_xmlSetNs();
    test_ret += test_xmlSetNsProp();
    test_ret += test_xmlSetProp();
    test_ret += test_xmlSplitQName2();
    test_ret += test_xmlSplitQName3();
    test_ret += test_xmlStringGetNodeList();
    test_ret += test_xmlStringLenGetNodeList();
    test_ret += test_xmlTextConcat();
    test_ret += test_xmlTextMerge();
    test_ret += test_xmlUnsetNsProp();
    test_ret += test_xmlUnsetProp();
    test_ret += test_xmlValidateNCName();
    test_ret += test_xmlValidateNMToken();
    test_ret += test_xmlValidateName();
    test_ret += test_xmlValidateQName();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module tree: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlBuildRelativeURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URI: std::os::raw::c_int = 0;
    let mut base: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_base: std::os::raw::c_int = 0;
    n_URI = 0 as std::os::raw::c_int;
    while n_URI < 5 as std::os::raw::c_int {
        n_base = 0 as std::os::raw::c_int;
        while n_base < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            URI = gen_const_xmlChar_ptr(n_URI, 0 as std::os::raw::c_int);
            base = gen_const_xmlChar_ptr(n_base, 1 as std::os::raw::c_int);
            ret_val =
                xmlBuildRelativeURI(URI as *const xmlChar,
                                    base as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_URI, URI as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_base, base as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBuildRelativeURI\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URI);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_base);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_base += 1
        }
        n_URI += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlBuildURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_URI: std::os::raw::c_int = 0;
    let mut base: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_base: std::os::raw::c_int = 0;
    n_URI = 0 as std::os::raw::c_int;
    while n_URI < 5 as std::os::raw::c_int {
        n_base = 0 as std::os::raw::c_int;
        while n_base < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            URI = gen_const_xmlChar_ptr(n_URI, 0 as std::os::raw::c_int);
            base = gen_const_xmlChar_ptr(n_base, 1 as std::os::raw::c_int);
            ret_val =
                xmlBuildURI(URI as *const xmlChar, base as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_URI, URI as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_base, base as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlBuildURI\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URI);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_base);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_base += 1
        }
        n_URI += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCanonicPath() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut path: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_path: std::os::raw::c_int = 0;
    n_path = 0 as std::os::raw::c_int;
    while n_path < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0 as std::os::raw::c_int);
        ret_val = xmlCanonicPath(path as *const xmlChar);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_path, path as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCanonicPath\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_path);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_path += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCreateURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* pointer to the path string */
}
unsafe extern "C" fn test_xmlNormalizeURIPath() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut path: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_path: std::os::raw::c_int = 0;
    n_path = 0 as std::os::raw::c_int;
    while n_path < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        path = gen_char_ptr(n_path, 0 as std::os::raw::c_int);
        ret_val = xmlNormalizeURIPath(path);
        desret_int(ret_val);
        call_tests += 1;
        des_char_ptr(n_path, path, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNormalizeURIPath\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_path);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_path += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParseURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlParseURIRaw() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* pointer to an URI structure */
}
unsafe extern "C" fn gen_xmlURIPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlURIPtr {
    return 0 as xmlURIPtr; /* the string to analyze */
}
unsafe extern "C" fn des_xmlURIPtr(mut no: std::os::raw::c_int, mut val: xmlURIPtr,
                                   mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlParseURIReference() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the resource locator in a filesystem notation */
    let mut mem_base: std::os::raw::c_int = 0; /* a FILE* for the output */
    let mut ret_val: std::os::raw::c_int = 0; /* pointer to an xmlURI */
    let mut uri: xmlURIPtr = 0 as *mut xmlURI; /* pointer to an xmlURI */
    let mut n_uri: std::os::raw::c_int = 0; /* the string of the URI to escape */
    let mut str: *mut std::os::raw::c_char =
        0 as *mut std::os::raw::c_char; /* string to escape */
    let mut n_str: std::os::raw::c_int =
        0; /* exception list string of chars not to escape */
    n_uri = 0 as std::os::raw::c_int;
    while n_uri < 1 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            uri = gen_xmlURIPtr(n_uri, 0 as std::os::raw::c_int);
            str = gen_const_char_ptr(n_str, 1 as std::os::raw::c_int);
            ret_val = xmlParseURIReference(uri, str as *const std::os::raw::c_char);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlURIPtr(n_uri, uri, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_str, str as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParseURIReference\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_uri);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str += 1
        }
        n_uri += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPathToURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut path: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_path: std::os::raw::c_int = 0;
    n_path = 0 as std::os::raw::c_int;
    while n_path < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0 as std::os::raw::c_int);
        ret_val = xmlPathToURI(path as *const xmlChar);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_path, path as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlPathToURI\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_path);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_path += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPrintURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut stream: *mut FILE = 0 as *mut FILE;
    let mut n_stream: std::os::raw::c_int = 0;
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut n_uri: std::os::raw::c_int = 0;
    n_stream = 0 as std::os::raw::c_int;
    while n_stream < 2 as std::os::raw::c_int {
        n_uri = 0 as std::os::raw::c_int;
        while n_uri < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            stream = gen_FILE_ptr(n_stream, 0 as std::os::raw::c_int);
            uri = gen_xmlURIPtr(n_uri, 1 as std::os::raw::c_int);
            xmlPrintURI(stream, uri);
            call_tests += 1;
            des_FILE_ptr(n_stream, stream, 0 as std::os::raw::c_int);
            des_xmlURIPtr(n_uri, uri, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlPrintURI\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_stream);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_uri);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_uri += 1
        }
        n_stream += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveUri() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut n_uri: std::os::raw::c_int = 0;
    n_uri = 0 as std::os::raw::c_int;
    while n_uri < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        uri = gen_xmlURIPtr(n_uri, 0 as std::os::raw::c_int);
        ret_val = xmlSaveUri(uri);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlURIPtr(n_uri, uri, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSaveUri\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_uri);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_uri += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlURIEscape() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    n_str = 0 as std::os::raw::c_int;
    while n_str < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0 as std::os::raw::c_int);
        ret_val = xmlURIEscape(str as *const xmlChar);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_str, str as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlURIEscape\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_str += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlURIEscapeStr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    let mut list: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_list: std::os::raw::c_int = 0;
    n_str = 0 as std::os::raw::c_int;
    while n_str < 5 as std::os::raw::c_int {
        n_list = 0 as std::os::raw::c_int;
        while n_list < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            str = gen_const_xmlChar_ptr(n_str, 0 as std::os::raw::c_int);
            list = gen_const_xmlChar_ptr(n_list, 1 as std::os::raw::c_int);
            ret_val =
                xmlURIEscapeStr(str as *const xmlChar,
                                list as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_list, list as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlURIEscapeStr\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_list);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_list += 1
        }
        n_str += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlURIUnescapeString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the validation context */
}
unsafe extern "C" fn test_uri() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* pointer to the DTD */
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing uri : 10 of 15 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char); /* the element name */
    } /* the attribute name */
    test_ret +=
        test_xmlBuildRelativeURI(); /* the attribute namespace prefix */
    test_ret += test_xmlBuildURI(); /* the attribute type */
    test_ret += test_xmlCanonicPath(); /* the attribute default type */
    test_ret += test_xmlCreateURI(); /* the attribute default value */
    test_ret +=
        test_xmlNormalizeURIPath(); /* if it's an enumeration, the associated list */
    test_ret += test_xmlParseURI(); /* the validation context */
    test_ret += test_xmlParseURIRaw(); /* pointer to the DTD */
    test_ret += test_xmlParseURIReference(); /* the entity name */
    test_ret += test_xmlPathToURI(); /* the element type */
    test_ret += test_xmlPrintURI(); /* the element content tree or NULL */
    test_ret += test_xmlSaveUri();
    test_ret += test_xmlURIEscape();
    test_ret += test_xmlURIEscapeStr();
    test_ret += test_xmlURIUnescapeString();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module uri: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlAddAttributeDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttributePtr = 0 as *mut xmlAttribute;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut n_dtd: std::os::raw::c_int = 0;
    let mut elem: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ns: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut type_0: xmlAttributeType = 0 as xmlAttributeType;
    let mut n_type: std::os::raw::c_int = 0;
    let mut def: xmlAttributeDefault = 0 as xmlAttributeDefault;
    let mut n_def: std::os::raw::c_int = 0;
    let mut defaultValue: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_defaultValue: std::os::raw::c_int = 0;
    let mut tree: xmlEnumerationPtr = 0 as *mut xmlEnumeration;
    let mut n_tree: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_dtd = 0 as std::os::raw::c_int;
        while n_dtd < 3 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 5 as std::os::raw::c_int {
                n_name = 0 as std::os::raw::c_int;
                while n_name < 5 as std::os::raw::c_int {
                    n_ns = 0 as std::os::raw::c_int;
                    while n_ns < 5 as std::os::raw::c_int {
                        n_type = 0 as std::os::raw::c_int;
                        while n_type < 4 as std::os::raw::c_int {
                            n_def = 0 as std::os::raw::c_int;
                            while n_def < 4 as std::os::raw::c_int {
                                n_defaultValue = 0 as std::os::raw::c_int;
                                while n_defaultValue < 5 as std::os::raw::c_int {
                                    n_tree = 0 as std::os::raw::c_int;
                                    while n_tree < 1 as std::os::raw::c_int {
                                        mem_base = xmlMemBlocks();
                                        ctxt =
                                            gen_xmlValidCtxtPtr(n_ctxt,
                                                                0 as
                                                                    std::os::raw::c_int);
                                        dtd =
                                            gen_xmlDtdPtr(n_dtd,
                                                          1 as std::os::raw::c_int);
                                        elem =
                                            gen_const_xmlChar_ptr(n_elem,
                                                                  2 as
                                                                      std::os::raw::c_int);
                                        name =
                                            gen_const_xmlChar_ptr(n_name,
                                                                  3 as
                                                                      std::os::raw::c_int);
                                        ns =
                                            gen_const_xmlChar_ptr(n_ns,
                                                                  4 as
                                                                      std::os::raw::c_int);
                                        type_0 =
                                            gen_xmlAttributeType(n_type,
                                                                 5 as
                                                                     std::os::raw::c_int);
                                        def =
                                            gen_xmlAttributeDefault(n_def,
                                                                    6 as
                                                                        std::os::raw::c_int);
                                        defaultValue =
                                            gen_const_xmlChar_ptr(n_defaultValue,
                                                                  7 as
                                                                      std::os::raw::c_int);
                                        tree =
                                            gen_xmlEnumerationPtr(n_tree,
                                                                  8 as
                                                                      std::os::raw::c_int);
                                        ret_val =
                                            xmlAddAttributeDecl(ctxt, dtd,
                                                                elem as
                                                                    *const xmlChar,
                                                                name as
                                                                    *const xmlChar,
                                                                ns as
                                                                    *const xmlChar,
                                                                type_0, def,
                                                                defaultValue
                                                                    as
                                                                    *const xmlChar,
                                                                tree);
                                        desret_xmlAttributePtr(ret_val);
                                        call_tests += 1;
                                        des_xmlValidCtxtPtr(n_ctxt, ctxt,
                                                            0 as std::os::raw::c_int);
                                        des_xmlDtdPtr(n_dtd, dtd,
                                                      1 as std::os::raw::c_int);
                                        des_const_xmlChar_ptr(n_elem,
                                                              elem as
                                                                  *const xmlChar,
                                                              2 as
                                                                  std::os::raw::c_int);
                                        des_const_xmlChar_ptr(n_name,
                                                              name as
                                                                  *const xmlChar,
                                                              3 as
                                                                  std::os::raw::c_int);
                                        des_const_xmlChar_ptr(n_ns,
                                                              ns as
                                                                  *const xmlChar,
                                                              4 as
                                                                  std::os::raw::c_int);
                                        des_xmlAttributeType(n_type, type_0,
                                                             5 as
                                                                 std::os::raw::c_int);
                                        des_xmlAttributeDefault(n_def, def,
                                                                6 as
                                                                    std::os::raw::c_int);
                                        des_const_xmlChar_ptr(n_defaultValue,
                                                              defaultValue as
                                                                  *const xmlChar,
                                                              7 as
                                                                  std::os::raw::c_int);
                                        des_xmlEnumerationPtr(n_tree, tree,
                                                              8 as
                                                                  std::os::raw::c_int);
                                        xmlResetLastError();
                                        if mem_base != xmlMemBlocks() {
                                            printf(b"Leak of %d blocks found in xmlAddAttributeDecl\x00"
                                                       as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   xmlMemBlocks() - mem_base);
                                            test_ret += 1;
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_ctxt);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_dtd);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_elem);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_name);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_ns);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_type);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_def);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_defaultValue);
                                            printf(b" %d\x00" as *const u8 as
                                                       *const std::os::raw::c_char,
                                                   n_tree);
                                            printf(b"\n\x00" as *const u8 as
                                                       *const std::os::raw::c_char);
                                        }
                                        n_tree += 1
                                    }
                                    n_defaultValue += 1
                                }
                                n_def += 1
                            }
                            n_type += 1
                        }
                        n_ns += 1
                    }
                    n_name += 1
                }
                n_elem += 1
            }
            n_dtd += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAddElementDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlElementPtr = 0 as *mut xmlElement;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut n_dtd: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut type_0: xmlElementTypeVal = XML_ELEMENT_TYPE_UNDEFINED;
    let mut n_type: std::os::raw::c_int = 0;
    let mut content: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut n_content: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_dtd = 0 as std::os::raw::c_int;
        while n_dtd < 3 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_type = 0 as std::os::raw::c_int;
                while n_type < 4 as std::os::raw::c_int {
                    n_content = 0 as std::os::raw::c_int;
                    while n_content < 1 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                        dtd = gen_xmlDtdPtr(n_dtd, 1 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                        type_0 =
                            gen_xmlElementTypeVal(n_type, 3 as std::os::raw::c_int);
                        content =
                            gen_xmlElementContentPtr(n_content,
                                                     4 as std::os::raw::c_int);
                        ret_val =
                            xmlAddElementDecl(ctxt, dtd,
                                              name as *const xmlChar, type_0,
                                              content);
                        desret_xmlElementPtr(ret_val);
                        call_tests += 1;
                        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                        des_xmlDtdPtr(n_dtd, dtd, 1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_xmlElementTypeVal(n_type, type_0,
                                              3 as std::os::raw::c_int);
                        des_xmlElementContentPtr(n_content, content,
                                                 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlAddElementDecl\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ctxt);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_dtd);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_type);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_content);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_content += 1
                    }
                    n_type += 1
                }
                n_name += 1
            }
            n_dtd += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAddID() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAddNotationDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAddRef() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn gen_xmlAttributeTablePtr(mut no: std::os::raw::c_int,
                                              mut nr: std::os::raw::c_int)
 -> xmlAttributeTablePtr {
    return 0 as xmlAttributeTablePtr;
}
unsafe extern "C" fn des_xmlAttributeTablePtr(mut no: std::os::raw::c_int,
                                              mut val: xmlAttributeTablePtr,
                                              mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlCopyAttributeTable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the document owning the element declaration */
}
unsafe extern "C" fn test_xmlCopyDocElementContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* An element content pointer. */
    let mut mem_base: std::os::raw::c_int = 0; /* An element content pointer. */
    let mut ret_val: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut cur: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut n_cur: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            cur = gen_xmlElementContentPtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlCopyDocElementContent(doc, cur);
            desret_xmlElementContentPtr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_xmlElementContentPtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCopyDocElementContent\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyElementContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut cur: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_xmlElementContentPtr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlCopyElementContent(cur);
        desret_xmlElementContentPtr(ret_val);
        call_tests += 1;
        des_xmlElementContentPtr(n_cur, cur, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCopyElementContent\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlElementTablePtr(mut no: std::os::raw::c_int,
                                            mut nr: std::os::raw::c_int)
 -> xmlElementTablePtr {
    return 0 as xmlElementTablePtr;
}
unsafe extern "C" fn des_xmlElementTablePtr(mut no: std::os::raw::c_int,
                                            mut val: xmlElementTablePtr,
                                            mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlCopyElementTable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlCopyEnumeration() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn gen_xmlNotationTablePtr(mut no: std::os::raw::c_int,
                                             mut nr: std::os::raw::c_int)
 -> xmlNotationTablePtr {
    return 0 as xmlNotationTablePtr;
}
unsafe extern "C" fn des_xmlNotationTablePtr(mut no: std::os::raw::c_int,
                                             mut val: xmlNotationTablePtr,
                                             mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlCopyNotationTable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlCreateEnumeration() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the XML buffer output */
}
unsafe extern "C" fn gen_xmlAttributePtr(mut no: std::os::raw::c_int,
                                         mut nr: std::os::raw::c_int)
 -> xmlAttributePtr {
    return 0 as xmlAttributePtr; /* An attribute declaration */
}
unsafe extern "C" fn des_xmlAttributePtr(mut no: std::os::raw::c_int,
                                         mut val: xmlAttributePtr,
                                         mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlDumpAttributeDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the XML buffer output */
    let mut mem_base: std::os::raw::c_int = 0; /* An attribute table */
    let mut buf: xmlBufferPtr =
        0 as *mut xmlBuffer; /* the XML buffer output */
    let mut n_buf: std::os::raw::c_int = 0; /* An element table */
    let mut attr: xmlAttributePtr =
        0 as *mut xmlAttribute; /* the XML buffer output */
    let mut n_attr: std::os::raw::c_int = 0; /* An element table */
    n_buf = 0 as std::os::raw::c_int; /* the XML buffer output */
    while n_buf < 3 as std::os::raw::c_int {
        n_attr = 0 as std::os::raw::c_int; /* A notation declaration */
        while n_attr < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the XML buffer output */
            buf =
                gen_xmlBufferPtr(n_buf,
                                 0 as std::os::raw::c_int); /* A notation table */
            attr =
                gen_xmlAttributePtr(n_attr,
                                    1 as
                                        std::os::raw::c_int); /* a pointer to the DtD to search */
            xmlDumpAttributeDecl(buf, attr); /* the element name */
            call_tests += 1; /* the attribute name */
            des_xmlBufferPtr(n_buf, buf,
                             0 as
                                 std::os::raw::c_int); /* a pointer to the DtD to search */
            des_xmlAttributePtr(n_attr, attr,
                                1 as std::os::raw::c_int); /* the element name */
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDumpAttributeDecl\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_attr);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_attr += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDumpAttributeTable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut table: xmlAttributeTablePtr = 0 as *mut xmlAttributeTable;
    let mut n_table: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_table = 0 as std::os::raw::c_int;
        while n_table < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            table = gen_xmlAttributeTablePtr(n_table, 1 as std::os::raw::c_int);
            xmlDumpAttributeTable(buf, table);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_xmlAttributeTablePtr(n_table, table, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDumpAttributeTable\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_table);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_table += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlElementPtr(mut no: std::os::raw::c_int,
                                       mut nr: std::os::raw::c_int) -> xmlElementPtr {
    return 0 as xmlElementPtr;
}
unsafe extern "C" fn des_xmlElementPtr(mut no: std::os::raw::c_int,
                                       mut val: xmlElementPtr,
                                       mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlDumpElementDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut elem: xmlElementPtr = 0 as *mut xmlElement;
    let mut n_elem: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            elem = gen_xmlElementPtr(n_elem, 1 as std::os::raw::c_int);
            xmlDumpElementDecl(buf, elem);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_xmlElementPtr(n_elem, elem, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDumpElementDecl\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_elem);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_elem += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDumpElementTable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut table: xmlElementTablePtr = 0 as *mut xmlElementTable;
    let mut n_table: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_table = 0 as std::os::raw::c_int;
        while n_table < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            table = gen_xmlElementTablePtr(n_table, 1 as std::os::raw::c_int);
            xmlDumpElementTable(buf, table);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_xmlElementTablePtr(n_table, table, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDumpElementTable\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_table);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_table += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlNotationPtr(mut no: std::os::raw::c_int,
                                        mut nr: std::os::raw::c_int)
 -> xmlNotationPtr {
    return 0 as xmlNotationPtr;
}
unsafe extern "C" fn des_xmlNotationPtr(mut no: std::os::raw::c_int,
                                        mut val: xmlNotationPtr,
                                        mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlDumpNotationDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut nota: xmlNotationPtr = 0 as *mut xmlNotation;
    let mut n_nota: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_nota = 0 as std::os::raw::c_int;
        while n_nota < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            nota = gen_xmlNotationPtr(n_nota, 1 as std::os::raw::c_int);
            xmlDumpNotationDecl(buf, nota);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_xmlNotationPtr(n_nota, nota, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDumpNotationDecl\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nota);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nota += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlDumpNotationTable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut table: xmlNotationTablePtr = 0 as *mut xmlNotationTable;
    let mut n_table: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_table = 0 as std::os::raw::c_int;
        while n_table < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            table = gen_xmlNotationTablePtr(n_table, 1 as std::os::raw::c_int);
            xmlDumpNotationTable(buf, table);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_xmlNotationTablePtr(n_table, table, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlDumpNotationTable\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_table);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_table += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetDtdAttrDesc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttributePtr = 0 as *mut xmlAttribute;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut n_dtd: std::os::raw::c_int = 0;
    let mut elem: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_dtd = 0 as std::os::raw::c_int;
    while n_dtd < 3 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                dtd = gen_xmlDtdPtr(n_dtd, 0 as std::os::raw::c_int);
                elem = gen_const_xmlChar_ptr(n_elem, 1 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                ret_val =
                    xmlGetDtdAttrDesc(dtd, elem as *const xmlChar,
                                      name as *const xmlChar);
                desret_xmlAttributePtr(ret_val);
                call_tests += 1;
                des_xmlDtdPtr(n_dtd, dtd, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_elem, elem as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlGetDtdAttrDesc\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_dtd);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_name += 1
            }
            n_elem += 1
        }
        n_dtd += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetDtdElementDesc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlElementPtr = 0 as *mut xmlElement;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut n_dtd: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_dtd = 0 as std::os::raw::c_int;
    while n_dtd < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            dtd = gen_xmlDtdPtr(n_dtd, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlGetDtdElementDesc(dtd, name as *const xmlChar);
            desret_xmlElementPtr(ret_val);
            call_tests += 1;
            des_xmlDtdPtr(n_dtd, dtd, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlGetDtdElementDesc\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_dtd);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_dtd += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetDtdNotationDesc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a pointer to the DtD to search */
}
unsafe extern "C" fn test_xmlGetDtdQAttrDesc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the element name */
    let mut mem_base: std::os::raw::c_int = 0; /* the attribute name */
    let mut ret_val: xmlAttributePtr =
        0 as *mut xmlAttribute; /* the attribute namespace prefix */
    let mut dtd: xmlDtdPtr =
        0 as *mut xmlDtd; /* a pointer to the DtD to search */
    let mut n_dtd: std::os::raw::c_int = 0; /* the element name */
    let mut elem: *mut xmlChar =
        0 as *mut xmlChar; /* the element namespace prefix */
    let mut n_elem: std::os::raw::c_int = 0; /* pointer to the document */
    let mut name: *mut xmlChar = 0 as *mut xmlChar; /* the ID value */
    let mut n_name: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    n_dtd = 0 as std::os::raw::c_int;
    while n_dtd < 3 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_prefix = 0 as std::os::raw::c_int;
                while n_prefix < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    dtd = gen_xmlDtdPtr(n_dtd, 0 as std::os::raw::c_int);
                    elem = gen_const_xmlChar_ptr(n_elem, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    prefix =
                        gen_const_xmlChar_ptr(n_prefix, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlGetDtdQAttrDesc(dtd, elem as *const xmlChar,
                                           name as *const xmlChar,
                                           prefix as *const xmlChar);
                    desret_xmlAttributePtr(ret_val);
                    call_tests += 1;
                    des_xmlDtdPtr(n_dtd, dtd, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_elem, elem as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlGetDtdQAttrDesc\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_dtd);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_elem);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_prefix);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_prefix += 1
                }
                n_name += 1
            }
            n_elem += 1
        }
        n_dtd += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetDtdQElementDesc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlElementPtr = 0 as *mut xmlElement;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut n_dtd: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    n_dtd = 0 as std::os::raw::c_int;
    while n_dtd < 3 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_prefix = 0 as std::os::raw::c_int;
            while n_prefix < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                dtd = gen_xmlDtdPtr(n_dtd, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                prefix = gen_const_xmlChar_ptr(n_prefix, 2 as std::os::raw::c_int);
                ret_val =
                    xmlGetDtdQElementDesc(dtd, name as *const xmlChar,
                                          prefix as *const xmlChar);
                desret_xmlElementPtr(ret_val);
                call_tests += 1;
                des_xmlDtdPtr(n_dtd, dtd, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlGetDtdQElementDesc\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_dtd);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_prefix);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_prefix += 1
            }
            n_name += 1
        }
        n_dtd += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetID() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut ID: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ID: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_ID = 0 as std::os::raw::c_int;
        while n_ID < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            ID = gen_const_xmlChar_ptr(n_ID, 1 as std::os::raw::c_int);
            ret_val = xmlGetID(doc, ID as *const xmlChar);
            desret_xmlAttrPtr(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_ID, ID as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlGetID\x00" as *const u8
                           as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ID);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ID += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetRefs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the document */
}
unsafe extern "C" fn test_xmlIsID() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the element carrying the attribute */
    let mut mem_base: std::os::raw::c_int = 0; /* the attribute */
    let mut ret_val: std::os::raw::c_int = 0; /* the document */
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc; /* the element name */
    let mut n_doc: std::os::raw::c_int = 0; /* the document */
    let mut elem: xmlNodePtr =
        0 as *mut xmlNode; /* the element carrying the attribute */
    let mut n_elem: std::os::raw::c_int = 0; /* the attribute */
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr; /* the document */
    let mut n_attr: std::os::raw::c_int = 0; /* the subelement name or NULL */
    n_doc = 0 as std::os::raw::c_int; /* the type of element content decl */
    while n_doc < 4 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int; /* the subelement name or NULL */
        while n_elem < 3 as std::os::raw::c_int {
            n_attr = 0 as std::os::raw::c_int; /* the type of element content decl */
            while n_attr < 2 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                elem = gen_xmlNodePtr(n_elem, 1 as std::os::raw::c_int);
                attr = gen_xmlAttrPtr(n_attr, 2 as std::os::raw::c_int);
                ret_val = xmlIsID(doc, elem, attr);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_xmlNodePtr(n_elem, elem, 1 as std::os::raw::c_int);
                des_xmlAttrPtr(n_attr, attr, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlIsID\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_attr);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_attr += 1
            }
            n_elem += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsMixedElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlIsMixedElement(doc, name as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlIsMixedElement\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIsRef() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut n_attr: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 3 as std::os::raw::c_int {
            n_attr = 0 as std::os::raw::c_int;
            while n_attr < 2 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                elem = gen_xmlNodePtr(n_elem, 1 as std::os::raw::c_int);
                attr = gen_xmlAttrPtr(n_attr, 2 as std::os::raw::c_int);
                ret_val = xmlIsRef(doc, elem, attr);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_xmlNodePtr(n_elem, elem, 1 as std::os::raw::c_int);
                des_xmlAttrPtr(n_attr, attr, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlIsRef\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_attr);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_attr += 1
            }
            n_elem += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewDocElementContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut type_0: xmlElementContentType = 0 as xmlElementContentType;
    let mut n_type: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_type = 0 as std::os::raw::c_int;
            while n_type < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                type_0 = gen_xmlElementContentType(n_type, 2 as std::os::raw::c_int);
                ret_val =
                    xmlNewDocElementContent(doc, name as *const xmlChar,
                                            type_0);
                xmlFreeDocElementContent(doc, ret_val);
                ret_val = 0 as xmlElementContentPtr;
                desret_xmlElementContentPtr(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_xmlElementContentType(n_type, type_0, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNewDocElementContent\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_type);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_type += 1
            }
            n_name += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewElementContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut type_0: xmlElementContentType = 0 as xmlElementContentType;
    let mut n_type: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        n_type = 0 as std::os::raw::c_int;
        while n_type < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
            type_0 = gen_xmlElementContentType(n_type, 1 as std::os::raw::c_int);
            ret_val = xmlNewElementContent(name as *const xmlChar, type_0);
            desret_xmlElementContentPtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_xmlElementContentType(n_type, type_0, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewElementContent\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_type);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_type += 1
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewValidCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the document */
}
unsafe extern "C" fn test_xmlRemoveID() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the attribute */
    let mut mem_base: std::os::raw::c_int = 0; /* the document */
    let mut ret_val: std::os::raw::c_int = 0; /* the attribute */
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc; /* an output buffer */
    let mut n_doc: std::os::raw::c_int = 0; /* the buffer size */
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr; /* An element table */
    let mut n_attr: std::os::raw::c_int =
        0; /* 1 if one must print the englobing parenthesis, 0 otherwise */
    n_doc = 0 as std::os::raw::c_int; /* an output buffer */
    while n_doc < 4 as std::os::raw::c_int {
        n_attr = 0 as std::os::raw::c_int; /* An element table */
        while n_attr < 2 as std::os::raw::c_int {
            mem_base =
                xmlMemBlocks(); /* 1 if one must print the englobing parenthesis, 0 otherwise */
            doc =
                gen_xmlDocPtr(n_doc,
                              0 as std::os::raw::c_int); /* a validation context */
            attr =
                gen_xmlAttrPtr(n_attr,
                               1 as
                                   std::os::raw::c_int); /* an element declaration node */
            ret_val =
                xmlRemoveID(doc, attr); /* the validation context or NULL */
            desret_int(ret_val); /* the document */
            call_tests += 1; /* the parent */
            des_xmlDocPtr(n_doc, doc,
                          0 as std::os::raw::c_int); /* the attribute name */
            des_xmlAttrPtr(n_attr, attr,
                           1 as std::os::raw::c_int); /* the attribute value */
            xmlResetLastError(); /* an element content tree */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlRemoveID\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* an array to store the list of child names */
                test_ret +=
                    1; /* a pointer to the number of element in the list */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_doc); /* the size of the array */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_attr); /* an element to insert after */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* an element to insert next */
            } /* an array to store the list of child names */
            n_attr += 1
        } /* the size of the array */
        n_doc += 1
    } /* the document */
    function_tests += 1; /* the parent */
    return test_ret; /* the attribute name */
}
unsafe extern "C" fn test_xmlRemoveRef() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the attribute value */
    let mut mem_base: std::os::raw::c_int = 0; /* the validation context */
    let mut ret_val: std::os::raw::c_int = 0; /* a document instance */
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc; /* an attribute definition */
    let mut n_doc: std::os::raw::c_int = 0; /* an attribute type */
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr; /* an attribute value */
    let mut n_attr: std::os::raw::c_int = 0; /* the validation context */
    n_doc = 0 as std::os::raw::c_int; /* a document instance */
    while n_doc < 4 as std::os::raw::c_int {
        n_attr = 0 as std::os::raw::c_int; /* the validation context */
        while n_attr < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* a document instance */
            doc =
                gen_xmlDocPtr(n_doc,
                              0 as std::os::raw::c_int); /* the validation context */
            attr =
                gen_xmlAttrPtr(n_attr,
                               1 as std::os::raw::c_int); /* a document instance */
            ret_val = xmlRemoveRef(doc, attr); /* a dtd instance */
            desret_int(ret_val); /* the validation context */
            call_tests += 1; /* a document instance */
            des_xmlDocPtr(n_doc, doc,
                          0 as std::os::raw::c_int); /* the validation context */
            des_xmlAttrPtr(n_attr, attr,
                           1 as std::os::raw::c_int); /* a document instance */
            xmlResetLastError(); /* an element instance */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlRemoveRef\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the validation context */
                test_ret += 1; /* a document instance */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_doc); /* an element definition */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_attr); /* an Name value */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* an Names value */
            } /* an Nmtoken value */
            n_attr += 1
        } /* an Nmtokens value */
        n_doc += 1
    } /* the validation context */
    function_tests += 1; /* a document instance */
    return test_ret; /* a notation definition */
}
unsafe extern "C" fn test_xmlSnprintfElementContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the validation context */
    let mut mem_base: std::os::raw::c_int = 0; /* the document */
    let mut buf: *mut std::os::raw::c_char =
        0 as *mut std::os::raw::c_char; /* the notation name to check */
    let mut n_buf: std::os::raw::c_int = 0; /* the validation context */
    let mut size: std::os::raw::c_int = 0; /* a document instance */
    let mut n_size: std::os::raw::c_int = 0; /* an element instance */
    let mut content: xmlElementContentPtr =
        0 as *mut xmlElementContent; /* an attribute instance */
    let mut n_content: std::os::raw::c_int =
        0; /* the attribute value (without entities processing) */
    let mut englob: std::os::raw::c_int = 0; /* the validation context */
    let mut n_englob: std::os::raw::c_int = 0; /* a document instance */
    n_buf = 0 as std::os::raw::c_int; /* an element instance */
    while n_buf < 1 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int; /* the validation context */
        while n_size < 4 as std::os::raw::c_int {
            n_content = 0 as std::os::raw::c_int; /* a document instance */
            while n_content < 1 as std::os::raw::c_int {
                n_englob = 0 as std::os::raw::c_int; /* an element instance */
                while n_englob < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks(); /* the namespace prefix */
                    buf =
                        gen_char_ptr(n_buf,
                                     0 as
                                         std::os::raw::c_int); /* an namespace declaration instance */
                    size =
                        gen_int(n_size,
                                1 as
                                    std::os::raw::c_int); /* the attribute value (without entities processing) */
                    content =
                        gen_xmlElementContentPtr(n_content,
                                                 2 as
                                                     std::os::raw::c_int); /* the validation context */
                    englob =
                        gen_int(n_englob,
                                3 as std::os::raw::c_int); /* a document instance */
                    xmlSnprintfElementContent(buf, size, content,
                                              englob); /* an element instance */
                    call_tests +=
                        1; /* the qualified name as appearing in the serialization */
                    des_char_ptr(n_buf, buf,
                                 0 as
                                     std::os::raw::c_int); /* the validation context */
                    des_int(n_size, size,
                            1 as std::os::raw::c_int); /* some character data read */
                    des_xmlElementContentPtr(n_content, content,
                                             2 as
                                                 std::os::raw::c_int); /* the length of the data */
                    des_int(n_englob, englob,
                            3 as std::os::raw::c_int); /* the validation context */
                    xmlResetLastError(); /* a document instance */
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSnprintfElementContent\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() -
                                   mem_base); /* an element instance */
                        test_ret +=
                            1; /* the qualified name as appearing in the serialization */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buf); /* the validation context */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_size); /* a document instance */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_englob);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_englob += 1
                }
                n_content += 1
            }
            n_size += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSprintfElementContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut content: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut n_content: std::os::raw::c_int = 0;
    let mut englob: std::os::raw::c_int = 0;
    let mut n_englob: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 1 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 1 as std::os::raw::c_int {
            n_englob = 0 as std::os::raw::c_int;
            while n_englob < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                buf = gen_char_ptr(n_buf, 0 as std::os::raw::c_int);
                content =
                    gen_xmlElementContentPtr(n_content, 1 as std::os::raw::c_int);
                englob = gen_int(n_englob, 2 as std::os::raw::c_int);
                xmlSprintfElementContent(buf, content, englob);
                call_tests += 1;
                des_char_ptr(n_buf, buf, 0 as std::os::raw::c_int);
                des_xmlElementContentPtr(n_content, content,
                                         1 as std::os::raw::c_int);
                des_int(n_englob, englob, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSprintfElementContent\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buf);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_content);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_englob);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_englob += 1
            }
            n_content += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidBuildContentModel() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut elem: xmlElementPtr = 0 as *mut xmlElement;
    let mut n_elem: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            elem = gen_xmlElementPtr(n_elem, 1 as std::os::raw::c_int);
            ret_val = xmlValidBuildContentModel(ctxt, elem);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlElementPtr(n_elem, elem, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidBuildContentModel\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_elem);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_elem += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidCtxtNormalizeAttributeValue()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                n_name = 0 as std::os::raw::c_int;
                while n_name < 5 as std::os::raw::c_int {
                    n_value = 0 as std::os::raw::c_int;
                    while n_value < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                        doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                        elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 3 as std::os::raw::c_int);
                        value =
                            gen_const_xmlChar_ptr(n_value, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlValidCtxtNormalizeAttributeValue(ctxt, doc,
                                                                elem,
                                                                name as
                                                                    *const xmlChar,
                                                                value as
                                                                    *const xmlChar);
                        desret_xmlChar_ptr(ret_val);
                        call_tests += 1;
                        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                        des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                        des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              3 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_value,
                                              value as *const xmlChar,
                                              4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlValidCtxtNormalizeAttributeValue\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ctxt);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_doc);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_elem);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_value);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_value += 1
                    }
                    n_name += 1
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlElementContent_ptr(mut no: std::os::raw::c_int,
                                               mut nr: std::os::raw::c_int)
 -> *mut xmlElementContent {
    return 0 as *mut xmlElementContent;
}
unsafe extern "C" fn des_xmlElementContent_ptr(mut no: std::os::raw::c_int,
                                               mut val:
                                                   *mut xmlElementContent,
                                               mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlValidGetPotentialChildren() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctree: *mut xmlElementContent = 0 as *mut xmlElementContent;
    let mut n_ctree: std::os::raw::c_int = 0;
    let mut names: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_names: std::os::raw::c_int = 0;
    let mut len: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_len: std::os::raw::c_int = 0;
    let mut max: std::os::raw::c_int = 0;
    let mut n_max: std::os::raw::c_int = 0;
    n_ctree = 0 as std::os::raw::c_int;
    while n_ctree < 1 as std::os::raw::c_int {
        n_names = 0 as std::os::raw::c_int;
        while n_names < 1 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 2 as std::os::raw::c_int {
                n_max = 0 as std::os::raw::c_int;
                while n_max < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctree =
                        gen_xmlElementContent_ptr(n_ctree, 0 as std::os::raw::c_int);
                    names =
                        gen_const_xmlChar_ptr_ptr(n_names, 1 as std::os::raw::c_int);
                    len = gen_int_ptr(n_len, 2 as std::os::raw::c_int);
                    max = gen_int(n_max, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlValidGetPotentialChildren(ctree,
                                                     names as
                                                         *mut *const xmlChar,
                                                     len, max);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlElementContent_ptr(n_ctree, ctree,
                                              0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr_ptr(n_names,
                                              names as *mut *const xmlChar,
                                              1 as std::os::raw::c_int);
                    des_int_ptr(n_len, len, 2 as std::os::raw::c_int);
                    des_int(n_max, max, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlValidGetPotentialChildren\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctree);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_names);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_max);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_max += 1
                }
                n_len += 1
            }
            n_names += 1
        }
        n_ctree += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidGetValidElements() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut prev: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_prev: std::os::raw::c_int = 0;
    let mut next: *mut xmlNode = 0 as *mut xmlNode;
    let mut n_next: std::os::raw::c_int = 0;
    let mut names: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_names: std::os::raw::c_int = 0;
    let mut max: std::os::raw::c_int = 0;
    let mut n_max: std::os::raw::c_int = 0;
    n_prev = 0 as std::os::raw::c_int;
    while n_prev < 3 as std::os::raw::c_int {
        n_next = 0 as std::os::raw::c_int;
        while n_next < 3 as std::os::raw::c_int {
            n_names = 0 as std::os::raw::c_int;
            while n_names < 1 as std::os::raw::c_int {
                n_max = 0 as std::os::raw::c_int;
                while n_max < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    prev = gen_xmlNodePtr(n_prev, 0 as std::os::raw::c_int);
                    next = gen_xmlNodePtr(n_next, 1 as std::os::raw::c_int);
                    names =
                        gen_const_xmlChar_ptr_ptr(n_names, 2 as std::os::raw::c_int);
                    max = gen_int(n_max, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlValidGetValidElements(prev, next,
                                                 names as *mut *const xmlChar,
                                                 max);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlNodePtr(n_prev, prev, 0 as std::os::raw::c_int);
                    des_xmlNodePtr(n_next, next, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr_ptr(n_names,
                                              names as *mut *const xmlChar,
                                              2 as std::os::raw::c_int);
                    des_int(n_max, max, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlValidGetValidElements\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_prev);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_next);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_names);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_max);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_max += 1
                }
                n_names += 1
            }
            n_next += 1
        }
        n_prev += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidNormalizeAttributeValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 3 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_value = 0 as std::os::raw::c_int;
                while n_value < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                    elem = gen_xmlNodePtr(n_elem, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    value = gen_const_xmlChar_ptr(n_value, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlValidNormalizeAttributeValue(doc, elem,
                                                        name as
                                                            *const xmlChar,
                                                        value as
                                                            *const xmlChar);
                    desret_xmlChar_ptr(ret_val);
                    call_tests += 1;
                    des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                    des_xmlNodePtr(n_elem, elem, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlValidNormalizeAttributeValue\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_elem);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_value += 1
                }
                n_name += 1
            }
            n_elem += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateAttributeDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut attr: xmlAttributePtr = 0 as *mut xmlAttribute;
    let mut n_attr: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_attr = 0 as std::os::raw::c_int;
            while n_attr < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                attr = gen_xmlAttributePtr(n_attr, 2 as std::os::raw::c_int);
                ret_val = xmlValidateAttributeDecl(ctxt, doc, attr);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlAttributePtr(n_attr, attr, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlValidateAttributeDecl\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_attr);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_attr += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateAttributeValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut type_0: xmlAttributeType = 0 as xmlAttributeType;
    let mut n_type: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_type = 0 as std::os::raw::c_int;
    while n_type < 4 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            type_0 = gen_xmlAttributeType(n_type, 0 as std::os::raw::c_int);
            value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
            ret_val =
                xmlValidateAttributeValue(type_0, value as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlAttributeType(n_type, type_0, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidateAttributeValue\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_type);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_value += 1
        }
        n_type += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateDocument() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            ret_val = xmlValidateDocument(ctxt, doc);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidateDocument\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateDocumentFinal() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            ret_val = xmlValidateDocumentFinal(ctxt, doc);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidateDocumentFinal\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateDtd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut n_dtd: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_dtd = 0 as std::os::raw::c_int;
            while n_dtd < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                dtd = gen_xmlDtdPtr(n_dtd, 2 as std::os::raw::c_int);
                ret_val = xmlValidateDtd(ctxt, doc, dtd);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlDtdPtr(n_dtd, dtd, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlValidateDtd\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_dtd);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_dtd += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateDtdFinal() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            ret_val = xmlValidateDtdFinal(ctxt, doc);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidateDtdFinal\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                ret_val = xmlValidateElement(ctxt, doc, elem);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlValidateElement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateElementDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlElementPtr = 0 as *mut xmlElement;
    let mut n_elem: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                elem = gen_xmlElementPtr(n_elem, 2 as std::os::raw::c_int);
                ret_val = xmlValidateElementDecl(ctxt, doc, elem);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlElementPtr(n_elem, elem, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlValidateElementDecl\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateNameValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
        ret_val = xmlValidateNameValue(value as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlValidateNameValue\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_value);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateNamesValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
        ret_val = xmlValidateNamesValue(value as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlValidateNamesValue\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_value);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateNmtokenValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
        ret_val = xmlValidateNmtokenValue(value as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlValidateNmtokenValue\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_value);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateNmtokensValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
        ret_val = xmlValidateNmtokensValue(value as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlValidateNmtokensValue\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_value);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateNotationDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut nota: xmlNotationPtr = 0 as *mut xmlNotation;
    let mut n_nota: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_nota = 0 as std::os::raw::c_int;
            while n_nota < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                nota = gen_xmlNotationPtr(n_nota, 2 as std::os::raw::c_int);
                ret_val = xmlValidateNotationDecl(ctxt, doc, nota);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlNotationPtr(n_nota, nota, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlValidateNotationDecl\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_nota);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_nota += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateNotationUse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut notationName: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_notationName: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_notationName = 0 as std::os::raw::c_int;
            while n_notationName < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                notationName =
                    gen_const_xmlChar_ptr(n_notationName, 2 as std::os::raw::c_int);
                ret_val =
                    xmlValidateNotationUse(ctxt, doc,
                                           notationName as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_notationName,
                                      notationName as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlValidateNotationUse\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_notationName);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_notationName += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateOneAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut n_attr: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                n_attr = 0 as std::os::raw::c_int;
                while n_attr < 2 as std::os::raw::c_int {
                    n_value = 0 as std::os::raw::c_int;
                    while n_value < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                        doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                        elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                        attr = gen_xmlAttrPtr(n_attr, 3 as std::os::raw::c_int);
                        value =
                            gen_const_xmlChar_ptr(n_value, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlValidateOneAttribute(ctxt, doc, elem, attr,
                                                    value as *const xmlChar);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                        des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                        des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                        des_xmlAttrPtr(n_attr, attr, 3 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_value,
                                              value as *const xmlChar,
                                              4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlValidateOneAttribute\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ctxt);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_doc);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_elem);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_attr);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_value);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_value += 1
                    }
                    n_attr += 1
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateOneElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                ret_val = xmlValidateOneElement(ctxt, doc, elem);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlValidateOneElement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_elem);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateOneNamespace() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                n_prefix = 0 as std::os::raw::c_int;
                while n_prefix < 5 as std::os::raw::c_int {
                    n_ns = 0 as std::os::raw::c_int;
                    while n_ns < 2 as std::os::raw::c_int {
                        n_value = 0 as std::os::raw::c_int;
                        while n_value < 5 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            ctxt =
                                gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                            elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                            prefix =
                                gen_const_xmlChar_ptr(n_prefix,
                                                      3 as std::os::raw::c_int);
                            ns = gen_xmlNsPtr(n_ns, 4 as std::os::raw::c_int);
                            value =
                                gen_const_xmlChar_ptr(n_value,
                                                      5 as std::os::raw::c_int);
                            ret_val =
                                xmlValidateOneNamespace(ctxt, doc, elem,
                                                        prefix as
                                                            *const xmlChar,
                                                        ns,
                                                        value as
                                                            *const xmlChar);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlValidCtxtPtr(n_ctxt, ctxt,
                                                0 as std::os::raw::c_int);
                            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                            des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_prefix,
                                                  prefix as *const xmlChar,
                                                  3 as std::os::raw::c_int);
                            des_xmlNsPtr(n_ns, ns, 4 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_value,
                                                  value as *const xmlChar,
                                                  5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlValidateOneNamespace\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ctxt);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_doc);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_elem);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_prefix);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ns);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_value);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_value += 1
                        }
                        n_ns += 1
                    }
                    n_prefix += 1
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidatePopElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut qname: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_qname: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                n_qname = 0 as std::os::raw::c_int;
                while n_qname < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                    elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                    qname = gen_const_xmlChar_ptr(n_qname, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlValidatePopElement(ctxt, doc, elem,
                                              qname as *const xmlChar);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_qname, qname as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlValidatePopElement\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_elem);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_qname);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_qname += 1
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidatePushCData() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut data: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_data: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                data = gen_const_xmlChar_ptr(n_data, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!data.is_null() &&
                         len >
                             strlen(data as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlValidatePushCData(ctxt, data as *const xmlChar,
                                             len);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_data, data as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlValidatePushCData\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_data);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_data += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidatePushElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    let mut qname: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_qname: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            n_elem = 0 as std::os::raw::c_int;
            while n_elem < 3 as std::os::raw::c_int {
                n_qname = 0 as std::os::raw::c_int;
                while n_qname < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
                    elem = gen_xmlNodePtr(n_elem, 2 as std::os::raw::c_int);
                    qname = gen_const_xmlChar_ptr(n_qname, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlValidatePushElement(ctxt, doc, elem,
                                               qname as *const xmlChar);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_elem, elem, 2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_qname, qname as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlValidatePushElement\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_doc);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_elem);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_qname);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_qname += 1
                }
                n_elem += 1
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlValidateRoot() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 2 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            ret_val = xmlValidateRoot(ctxt, doc);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlValidateRoot\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_valid() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing valid : 50 of 70 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char);
    }
    test_ret += test_xmlAddAttributeDecl();
    test_ret += test_xmlAddElementDecl();
    test_ret += test_xmlAddID();
    test_ret += test_xmlAddNotationDecl();
    test_ret += test_xmlAddRef();
    test_ret += test_xmlCopyAttributeTable();
    test_ret += test_xmlCopyDocElementContent();
    test_ret += test_xmlCopyElementContent();
    test_ret += test_xmlCopyElementTable();
    test_ret += test_xmlCopyEnumeration();
    test_ret += test_xmlCopyNotationTable();
    test_ret += test_xmlCreateEnumeration();
    test_ret += test_xmlDumpAttributeDecl();
    test_ret += test_xmlDumpAttributeTable();
    test_ret += test_xmlDumpElementDecl();
    test_ret += test_xmlDumpElementTable();
    test_ret += test_xmlDumpNotationDecl();
    test_ret += test_xmlDumpNotationTable();
    test_ret += test_xmlGetDtdAttrDesc();
    test_ret += test_xmlGetDtdElementDesc();
    test_ret += test_xmlGetDtdNotationDesc();
    test_ret += test_xmlGetDtdQAttrDesc();
    test_ret += test_xmlGetDtdQElementDesc();
    test_ret += test_xmlGetID();
    test_ret += test_xmlGetRefs();
    test_ret += test_xmlIsID();
    test_ret += test_xmlIsMixedElement();
    test_ret += test_xmlIsRef();
    test_ret += test_xmlNewDocElementContent();
    test_ret += test_xmlNewElementContent();
    test_ret += test_xmlNewValidCtxt();
    test_ret += test_xmlRemoveID();
    test_ret += test_xmlRemoveRef();
    test_ret += test_xmlSnprintfElementContent();
    test_ret += test_xmlSprintfElementContent();
    test_ret += test_xmlValidBuildContentModel();
    test_ret += test_xmlValidCtxtNormalizeAttributeValue();
    test_ret += test_xmlValidGetPotentialChildren();
    test_ret += test_xmlValidGetValidElements();
    test_ret += test_xmlValidNormalizeAttributeValue();
    test_ret += test_xmlValidateAttributeDecl();
    test_ret += test_xmlValidateAttributeValue();
    test_ret += test_xmlValidateDocument();
    test_ret += test_xmlValidateDocumentFinal();
    test_ret += test_xmlValidateDtd();
    test_ret += test_xmlValidateDtdFinal();
    test_ret += test_xmlValidateElement();
    test_ret += test_xmlValidateElementDecl();
    test_ret += test_xmlValidateNameValue();
    test_ret += test_xmlValidateNamesValue();
    test_ret += test_xmlValidateNmtokenValue();
    test_ret += test_xmlValidateNmtokensValue();
    test_ret += test_xmlValidateNotationDecl();
    test_ret += test_xmlValidateNotationUse();
    test_ret += test_xmlValidateOneAttribute();
    test_ret += test_xmlValidateOneElement();
    test_ret += test_xmlValidateOneNamespace();
    test_ret += test_xmlValidatePopElement();
    test_ret += test_xmlValidatePushCData();
    test_ret += test_xmlValidatePushElement();
    test_ret += test_xmlValidateRoot();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module valid: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlXIncludeNewContext() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an XML document */
}
unsafe extern "C" fn test_xmlXIncludeProcess() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* an XML document */
    let mut mem_base: std::os::raw::c_int =
        0; /* a set of xmlParserOption used for parsing XML includes */
    let mut ret_val: std::os::raw::c_int = 0; /* an XML document */
    let mut doc: xmlDocPtr =
        0 as
            *mut xmlDoc; /* a set of xmlParserOption used for parsing XML includes */
    let mut n_doc: std::os::raw::c_int =
        0; /* application data that will be passed to the parser context in the _private field of the parser context(s) */
    n_doc = 0 as std::os::raw::c_int; /* an existing XInclude context */
    while n_doc < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* a node in an XML document */
        doc =
            gen_xmlDocPtr(n_doc,
                          0 as std::os::raw::c_int); /* a node in an XML document */
        ret_val = xmlXIncludeProcess(doc); /* a node in an XML document */
        desret_int(ret_val); /* a set of xmlParserOption used for parsing XML includes */
        call_tests += 1; /* an XML node */
        des_xmlDocPtr(n_doc, doc,
                      0 as
                          std::os::raw::c_int); /* a set of xmlParserOption used for parsing XML includes */
        xmlResetLastError(); /* application data that will be passed to the parser context in the _private field of the parser context(s) */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXIncludeProcess\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() -
                       mem_base); /* an XInclude processing context */
            test_ret +=
                1; /* a set of xmlParserOption used for parsing XML includes */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_doc); /* the encoding converter or NULL */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the charset encoding if known */
        } /* the path to check */
        n_doc += 1
    } /* an XML parser context */
    function_tests += 1; /* an XML parser input */
    return test_ret; /* the I/O context */
}
unsafe extern "C" fn test_xmlXIncludeProcessFlags() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the URI for matching */
    let mut mem_base: std::os::raw::c_int = 0; /* the URI for matching */
    let mut ret_val: std::os::raw::c_int = 0; /* the I/O context */
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc; /* where to drop data */
    let mut n_doc: std::os::raw::c_int = 0; /* number of bytes to write */
    let mut flags: std::os::raw::c_int = 0; /* the I/O context */
    let mut n_flags: std::os::raw::c_int = 0; /* the URI for matching */
    n_doc = 0 as std::os::raw::c_int; /* the URI for matching */
    while n_doc < 4 as std::os::raw::c_int {
        n_flags = 0 as std::os::raw::c_int; /* the I/O context */
        while n_flags < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* where to drop data */
            doc =
                gen_xmlDocPtr(n_doc,
                              0 as
                                  std::os::raw::c_int); /* number of bytes to write */
            flags = gen_int(n_flags, 1 as std::os::raw::c_int); /* the I/O context */
            ret_val =
                xmlXIncludeProcessFlags(doc,
                                        flags); /* the URI for matching */
            desret_int(ret_val); /* the URI for matching */
            call_tests += 1; /* the I/O context */
            des_xmlDocPtr(n_doc, doc,
                          0 as std::os::raw::c_int); /* where to drop data */
            des_int(n_flags, flags,
                    1 as std::os::raw::c_int); /* number of bytes to write */
            xmlResetLastError(); /* the URL for the entity to load */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXIncludeProcessFlags\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the System ID for the entity to load */
                test_ret +=
                    1; /* the context in which the entity is called or NULL */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_doc); /* the input file path */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_flags); /* a xmlBufferPtr */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the encoding converter or NULL */
            } /* a file descriptor number */
            n_flags += 1
        } /* the encoding converter or NULL */
        n_doc += 1
    } /* a FILE* */
    function_tests += 1; /* the encoding converter or NULL */
    return test_ret; /* a C string containing the URI or filename */
}
unsafe extern "C" fn test_xmlXIncludeProcessFlagsData() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the encoding converter or NULL */
    let mut mem_base: std::os::raw::c_int =
        0; /* the compression ration (0 none, 9 max). */
    let mut ret_val: std::os::raw::c_int = 0; /* a buffered output */
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc; /* an xmlOutputBufferPtr */
    let mut n_doc: std::os::raw::c_int = 0;
    let mut flags: std::os::raw::c_int = 0;
    let mut n_flags: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_flags = 0 as std::os::raw::c_int;
        while n_flags < 4 as std::os::raw::c_int {
            n_data = 0 as std::os::raw::c_int;
            while n_data < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                flags = gen_int(n_flags, 1 as std::os::raw::c_int);
                data = gen_userdata(n_data, 2 as std::os::raw::c_int);
                ret_val = xmlXIncludeProcessFlagsData(doc, flags, data);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_int(n_flags, flags, 1 as std::os::raw::c_int);
                des_userdata(n_data, data, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXIncludeProcessFlagsData\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_flags);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_data);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_data += 1
            }
            n_flags += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlXIncludeCtxtPtr(mut no: std::os::raw::c_int,
                                            mut nr: std::os::raw::c_int)
 -> xmlXIncludeCtxtPtr {
    return 0 as xmlXIncludeCtxtPtr;
}
unsafe extern "C" fn des_xmlXIncludeCtxtPtr(mut no: std::os::raw::c_int,
                                            mut val: xmlXIncludeCtxtPtr,
                                            mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlXIncludeProcessNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXIncludeCtxtPtr = 0 as *mut xmlXIncludeCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXIncludeCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            ret_val = xmlXIncludeProcessNode(ctxt, node);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlXIncludeCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXIncludeProcessNode\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXIncludeProcessTree() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_tree: std::os::raw::c_int = 0;
    n_tree = 0 as std::os::raw::c_int;
    while n_tree < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree, 0 as std::os::raw::c_int);
        ret_val = xmlXIncludeProcessTree(tree);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_tree, tree, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXIncludeProcessTree\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_tree);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_tree += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXIncludeProcessTreeFlags() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_tree: std::os::raw::c_int = 0;
    let mut flags: std::os::raw::c_int = 0;
    let mut n_flags: std::os::raw::c_int = 0;
    n_tree = 0 as std::os::raw::c_int;
    while n_tree < 3 as std::os::raw::c_int {
        n_flags = 0 as std::os::raw::c_int;
        while n_flags < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            tree = gen_xmlNodePtr(n_tree, 0 as std::os::raw::c_int);
            flags = gen_int(n_flags, 1 as std::os::raw::c_int);
            ret_val = xmlXIncludeProcessTreeFlags(tree, flags);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_tree, tree, 0 as std::os::raw::c_int);
            des_int(n_flags, flags, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXIncludeProcessTreeFlags\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_tree);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_flags);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_flags += 1
        }
        n_tree += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXIncludeProcessTreeFlagsData() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_tree: std::os::raw::c_int = 0;
    let mut flags: std::os::raw::c_int = 0;
    let mut n_flags: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_tree = 0 as std::os::raw::c_int;
    while n_tree < 3 as std::os::raw::c_int {
        n_flags = 0 as std::os::raw::c_int;
        while n_flags < 4 as std::os::raw::c_int {
            n_data = 0 as std::os::raw::c_int;
            while n_data < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                tree = gen_xmlNodePtr(n_tree, 0 as std::os::raw::c_int);
                flags = gen_int(n_flags, 1 as std::os::raw::c_int);
                data = gen_userdata(n_data, 2 as std::os::raw::c_int);
                ret_val = xmlXIncludeProcessTreeFlagsData(tree, flags, data);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlNodePtr(n_tree, tree, 0 as std::os::raw::c_int);
                des_int(n_flags, flags, 1 as std::os::raw::c_int);
                des_userdata(n_data, data, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXIncludeProcessTreeFlagsData\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_tree);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_flags);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_data);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_data += 1
            }
            n_flags += 1
        }
        n_tree += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXIncludeSetFlags() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXIncludeCtxtPtr = 0 as *mut xmlXIncludeCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut flags: std::os::raw::c_int = 0;
    let mut n_flags: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_flags = 0 as std::os::raw::c_int;
        while n_flags < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXIncludeCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            flags = gen_int(n_flags, 1 as std::os::raw::c_int);
            ret_val = xmlXIncludeSetFlags(ctxt, flags);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlXIncludeCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_flags, flags, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXIncludeSetFlags\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_flags);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_flags += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xinclude() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xinclude : 8 of 10 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlXIncludeNewContext();
    test_ret += test_xmlXIncludeProcess();
    test_ret += test_xmlXIncludeProcessFlags();
    test_ret += test_xmlXIncludeProcessFlagsData();
    test_ret += test_xmlXIncludeProcessNode();
    test_ret += test_xmlXIncludeProcessTree();
    test_ret += test_xmlXIncludeProcessTreeFlags();
    test_ret += test_xmlXIncludeProcessTreeFlagsData();
    test_ret += test_xmlXIncludeSetFlags();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xinclude: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlAllocOutputBuffer() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut encoder: xmlCharEncodingHandlerPtr =
        0 as *mut xmlCharEncodingHandler;
    let mut n_encoder: std::os::raw::c_int = 0;
    n_encoder = 0 as std::os::raw::c_int;
    while n_encoder < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 0 as std::os::raw::c_int);
        ret_val = xmlAllocOutputBuffer(encoder);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests += 1;
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlAllocOutputBuffer\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_encoder);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_encoder += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAllocParserInputBuffer() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut n_enc: std::os::raw::c_int = 0;
    n_enc = 0 as std::os::raw::c_int;
    while n_enc < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        enc = gen_xmlCharEncoding(n_enc, 0 as std::os::raw::c_int);
        ret_val = xmlAllocParserInputBuffer(enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests += 1;
        des_xmlCharEncoding(n_enc, enc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlAllocParserInputBuffer\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_enc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_enc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCheckFilename() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut path: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_path: std::os::raw::c_int = 0;
    n_path = 0 as std::os::raw::c_int;
    while n_path < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        path = gen_const_char_ptr(n_path, 0 as std::os::raw::c_int);
        ret_val = xmlCheckFilename(path as *const std::os::raw::c_char);
        desret_int(ret_val);
        call_tests += 1;
        des_const_char_ptr(n_path, path as *const std::os::raw::c_char,
                           0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCheckFilename\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_path);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_path += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCheckHTTPInput() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut ret: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut n_ret: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_ret = 0 as std::os::raw::c_int;
        while n_ret < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            ret = gen_xmlParserInputPtr(n_ret, 1 as std::os::raw::c_int);
            ret_val = xmlCheckHTTPInput(ctxt, ret);
            desret_xmlParserInputPtr(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlParserInputPtr(n_ret, ret, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCheckHTTPInput\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ret);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ret += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCleanupInputCallbacks() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlCleanupInputCallbacks();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlCleanupInputCallbacks\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCleanupOutputCallbacks() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlCleanupOutputCallbacks();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlCleanupOutputCallbacks\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlFileClose() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut context: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_context: std::os::raw::c_int = 0;
    n_context = 0 as std::os::raw::c_int;
    while n_context < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0 as std::os::raw::c_int);
        ret_val = xmlFileClose(context);
        desret_int(ret_val);
        call_tests += 1;
        des_void_ptr(n_context, context, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlFileClose\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_context);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_context += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlFileMatch() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlFileMatch(filename);
        desret_int(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlFileMatch\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlFileOpen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlFileOpen(filename);
        desret_void_ptr(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlFileOpen\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlFileRead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut context: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_context: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_context = 0 as std::os::raw::c_int;
    while n_context < 2 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 1 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                context = gen_void_ptr(n_context, 0 as std::os::raw::c_int);
                buffer = gen_char_ptr(n_buffer, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                ret_val = xmlFileRead(context, buffer, len);
                desret_int(ret_val);
                call_tests += 1;
                des_void_ptr(n_context, context, 0 as std::os::raw::c_int);
                des_char_ptr(n_buffer, buffer, 1 as std::os::raw::c_int);
                des_int(n_len, len, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlFileRead\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_context);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_len += 1
            }
            n_buffer += 1
        }
        n_context += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIOFTPClose() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut context: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_context: std::os::raw::c_int = 0;
    n_context = 0 as std::os::raw::c_int;
    while n_context < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0 as std::os::raw::c_int);
        ret_val = xmlIOFTPClose(context);
        desret_int(ret_val);
        call_tests += 1;
        des_void_ptr(n_context, context, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIOFTPClose\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_context);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_context += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIOFTPMatch() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlIOFTPMatch(filename);
        desret_int(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIOFTPMatch\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIOFTPOpen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlIOFTPOpen(filename);
        desret_void_ptr(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIOFTPOpen\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIOFTPRead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut context: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_context: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_context = 0 as std::os::raw::c_int;
    while n_context < 2 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 1 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                context = gen_void_ptr(n_context, 0 as std::os::raw::c_int);
                buffer = gen_char_ptr(n_buffer, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                ret_val = xmlIOFTPRead(context, buffer, len);
                desret_int(ret_val);
                call_tests += 1;
                des_void_ptr(n_context, context, 0 as std::os::raw::c_int);
                des_char_ptr(n_buffer, buffer, 1 as std::os::raw::c_int);
                des_int(n_len, len, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlIOFTPRead\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_context);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_len += 1
            }
            n_buffer += 1
        }
        n_context += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIOHTTPClose() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut context: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_context: std::os::raw::c_int = 0;
    n_context = 0 as std::os::raw::c_int;
    while n_context < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0 as std::os::raw::c_int);
        ret_val = xmlIOHTTPClose(context);
        desret_int(ret_val);
        call_tests += 1;
        des_void_ptr(n_context, context, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIOHTTPClose\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_context);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_context += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIOHTTPMatch() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlIOHTTPMatch(filename);
        desret_int(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIOHTTPMatch\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIOHTTPOpen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
        ret_val = xmlIOHTTPOpen(filename);
        desret_xmlNanoHTTPCtxtPtr(ret_val);
        call_tests += 1;
        des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlIOHTTPOpen\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_filename);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIOHTTPRead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut context: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_context: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_context = 0 as std::os::raw::c_int;
    while n_context < 2 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 1 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                context = gen_void_ptr(n_context, 0 as std::os::raw::c_int);
                buffer = gen_char_ptr(n_buffer, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                ret_val = xmlIOHTTPRead(context, buffer, len);
                desret_int(ret_val);
                call_tests += 1;
                des_void_ptr(n_context, context, 0 as std::os::raw::c_int);
                des_char_ptr(n_buffer, buffer, 1 as std::os::raw::c_int);
                des_int(n_len, len, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlIOHTTPRead\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_context);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_len += 1
            }
            n_buffer += 1
        }
        n_context += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNoNetExternalEntityLoader() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut ID: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_ID: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 8 as std::os::raw::c_int {
        n_ID = 0 as std::os::raw::c_int;
        while n_ID < 4 as std::os::raw::c_int {
            n_ctxt = 0 as std::os::raw::c_int;
            while n_ctxt < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                URL = gen_filepath(n_URL, 0 as std::os::raw::c_int);
                ID = gen_const_char_ptr(n_ID, 1 as std::os::raw::c_int);
                ctxt = gen_xmlParserCtxtPtr(n_ctxt, 2 as std::os::raw::c_int);
                ret_val =
                    xmlNoNetExternalEntityLoader(URL,
                                                 ID as *const std::os::raw::c_char,
                                                 ctxt);
                desret_xmlParserInputPtr(ret_val);
                call_tests += 1;
                des_filepath(n_URL, URL, 0 as std::os::raw::c_int);
                des_const_char_ptr(n_ID, ID as *const std::os::raw::c_char,
                                   1 as std::os::raw::c_int);
                des_xmlParserCtxtPtr(n_ctxt, ctxt, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNoNetExternalEntityLoader\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_URL);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ID);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_ctxt += 1
            }
            n_ID += 1
        }
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNormalizeWindowsPath() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut path: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_path: std::os::raw::c_int = 0;
    n_path = 0 as std::os::raw::c_int;
    while n_path < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0 as std::os::raw::c_int);
        ret_val = xmlNormalizeWindowsPath(path as *const xmlChar);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_path, path as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNormalizeWindowsPath\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_path);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_path += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlOutputBufferCreateBuffer() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut buffer: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut encoder: xmlCharEncodingHandlerPtr =
        0 as *mut xmlCharEncodingHandler;
    let mut n_encoder: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 3 as std::os::raw::c_int {
        n_encoder = 0 as std::os::raw::c_int;
        while n_encoder < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buffer = gen_xmlBufferPtr(n_buffer, 0 as std::os::raw::c_int);
            encoder =
                gen_xmlCharEncodingHandlerPtr(n_encoder, 1 as std::os::raw::c_int);
            ret_val = xmlOutputBufferCreateBuffer(buffer, encoder);
            desret_xmlOutputBufferPtr(ret_val);
            call_tests += 1;
            des_xmlBufferPtr(n_buffer, buffer, 0 as std::os::raw::c_int);
            des_xmlCharEncodingHandlerPtr(n_encoder, encoder,
                                          1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlOutputBufferCreateBuffer\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_buffer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_encoder);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_encoder += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlOutputBufferCreateFd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut fd: std::os::raw::c_int = 0;
    let mut n_fd: std::os::raw::c_int = 0;
    let mut encoder: xmlCharEncodingHandlerPtr =
        0 as *mut xmlCharEncodingHandler;
    let mut n_encoder: std::os::raw::c_int = 0;
    n_fd = 0 as std::os::raw::c_int;
    while n_fd < 4 as std::os::raw::c_int {
        n_encoder = 0 as std::os::raw::c_int;
        while n_encoder < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            fd = gen_int(n_fd, 0 as std::os::raw::c_int);
            encoder =
                gen_xmlCharEncodingHandlerPtr(n_encoder, 1 as std::os::raw::c_int);
            ret_val = xmlOutputBufferCreateFd(fd, encoder);
            desret_xmlOutputBufferPtr(ret_val);
            call_tests += 1;
            des_int(n_fd, fd, 0 as std::os::raw::c_int);
            des_xmlCharEncodingHandlerPtr(n_encoder, encoder,
                                          1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlOutputBufferCreateFd\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_fd);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_encoder);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_encoder += 1
        }
        n_fd += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlOutputBufferCreateFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut file: *mut FILE = 0 as *mut FILE;
    let mut n_file: std::os::raw::c_int = 0;
    let mut encoder: xmlCharEncodingHandlerPtr =
        0 as *mut xmlCharEncodingHandler;
    let mut n_encoder: std::os::raw::c_int = 0;
    n_file = 0 as std::os::raw::c_int;
    while n_file < 2 as std::os::raw::c_int {
        n_encoder = 0 as std::os::raw::c_int;
        while n_encoder < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            file = gen_FILE_ptr(n_file, 0 as std::os::raw::c_int);
            encoder =
                gen_xmlCharEncodingHandlerPtr(n_encoder, 1 as std::os::raw::c_int);
            ret_val = xmlOutputBufferCreateFile(file, encoder);
            desret_xmlOutputBufferPtr(ret_val);
            call_tests += 1;
            des_FILE_ptr(n_file, file, 0 as std::os::raw::c_int);
            des_xmlCharEncodingHandlerPtr(n_encoder, encoder,
                                          1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlOutputBufferCreateFile\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_file);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_encoder);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_encoder += 1
        }
        n_file += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlOutputBufferCreateFilename() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut URI: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URI: std::os::raw::c_int = 0;
    let mut encoder: xmlCharEncodingHandlerPtr =
        0 as *mut xmlCharEncodingHandler;
    let mut n_encoder: std::os::raw::c_int = 0;
    let mut compression: std::os::raw::c_int = 0;
    let mut n_compression: std::os::raw::c_int = 0;
    n_URI = 0 as std::os::raw::c_int;
    while n_URI < 6 as std::os::raw::c_int {
        n_encoder = 0 as std::os::raw::c_int;
        while n_encoder < 1 as std::os::raw::c_int {
            n_compression = 0 as std::os::raw::c_int;
            while n_compression < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                URI = gen_fileoutput(n_URI, 0 as std::os::raw::c_int);
                encoder =
                    gen_xmlCharEncodingHandlerPtr(n_encoder,
                                                  1 as std::os::raw::c_int);
                compression = gen_int(n_compression, 2 as std::os::raw::c_int);
                ret_val =
                    xmlOutputBufferCreateFilename(URI, encoder, compression);
                desret_xmlOutputBufferPtr(ret_val);
                call_tests += 1;
                des_fileoutput(n_URI, URI, 0 as std::os::raw::c_int);
                des_xmlCharEncodingHandlerPtr(n_encoder, encoder,
                                              1 as std::os::raw::c_int);
                des_int(n_compression, compression, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlOutputBufferCreateFilename\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_URI);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_encoder);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_compression);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_compression += 1
            }
            n_encoder += 1
        }
        n_URI += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlOutputBufferFlush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_out: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0 as std::os::raw::c_int);
        ret_val = xmlOutputBufferFlush(out);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlOutputBufferPtr(n_out, out, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlOutputBufferFlush\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_out);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlOutputBufferGetContent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_out: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0 as std::os::raw::c_int);
        ret_val = xmlOutputBufferGetContent(out);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlOutputBufferPtr(n_out, out, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlOutputBufferGetContent\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_out);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlOutputBufferGetSize() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a buffered parser output */
}
unsafe extern "C" fn test_xmlOutputBufferWrite() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the size in bytes of the array. */
    let mut mem_base: std::os::raw::c_int = 0; /* an char array */
    let mut ret_val: std::os::raw::c_int = 0;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_out: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    let mut buf: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buf: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 2 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            n_buf = 0 as std::os::raw::c_int;
            while n_buf < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                out = gen_xmlOutputBufferPtr(n_out, 0 as std::os::raw::c_int);
                len = gen_int(n_len, 1 as std::os::raw::c_int);
                buf = gen_const_char_ptr(n_buf, 2 as std::os::raw::c_int);
                if !(!buf.is_null() &&
                         len >
                             strlen(buf as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlOutputBufferWrite(out, len,
                                             buf as *const std::os::raw::c_char);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlOutputBufferPtr(n_out, out, 0 as std::os::raw::c_int);
                    des_int(n_len, len, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_buf, buf as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlOutputBufferWrite\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_out);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buf);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_buf += 1
            }
            n_len += 1
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlOutputBufferWriteEscape() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a buffered parser output */
}
unsafe extern "C" fn test_xmlOutputBufferWriteString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* a zero terminated C string */
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_out: std::os::raw::c_int = 0;
    let mut str: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_str: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 2 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            out = gen_xmlOutputBufferPtr(n_out, 0 as std::os::raw::c_int);
            str = gen_const_char_ptr(n_str, 1 as std::os::raw::c_int);
            ret_val =
                xmlOutputBufferWriteString(out, str as *const std::os::raw::c_char);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlOutputBufferPtr(n_out, out, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_str, str as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlOutputBufferWriteString\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_out);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str += 1
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserGetDirectory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a file descriptor number */
}
unsafe extern "C" fn test_xmlParserInputBufferCreateFd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the charset encoding if known */
    let mut mem_base: std::os::raw::c_int = 0; /* a FILE* */
    let mut ret_val: xmlParserInputBufferPtr =
        0 as *mut xmlParserInputBuffer; /* the charset encoding if known */
    let mut fd: std::os::raw::c_int =
        0; /* a C string containing the URI or filename */
    let mut n_fd: std::os::raw::c_int = 0; /* the charset encoding if known */
    let mut enc: xmlCharEncoding =
        XML_CHAR_ENCODING_NONE; /* the memory input */
    let mut n_enc: std::os::raw::c_int = 0; /* the length of the memory block */
    n_fd = 0 as std::os::raw::c_int; /* the charset encoding if known */
    while n_fd < 4 as std::os::raw::c_int {
        n_enc = 0 as std::os::raw::c_int; /* the memory input */
        while n_enc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the length of the memory block */
            fd =
                gen_int(n_fd,
                        0 as std::os::raw::c_int); /* the charset encoding if known */
            enc =
                gen_xmlCharEncoding(n_enc,
                                    1 as
                                        std::os::raw::c_int); /* a buffered parser input */
            if fd >= 0 as std::os::raw::c_int {
                fd = -(1 as std::os::raw::c_int)
            } /* indicative value of the amount of chars to read */
            ret_val =
                xmlParserInputBufferCreateFd(fd,
                                             enc); /* a buffered parser input */
            desret_xmlParserInputBufferPtr(ret_val); /* the size in bytes of the array. */
            call_tests += 1; /* an char array */
            des_int(n_fd, fd, 0 as std::os::raw::c_int); /* a buffered parser input */
            des_xmlCharEncoding(n_enc, enc,
                                1 as
                                    std::os::raw::c_int); /* indicative value of the amount of chars to read */
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserInputBufferCreateFd\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_fd);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_enc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_enc += 1
        }
        n_fd += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserInputBufferCreateFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut file: *mut FILE = 0 as *mut FILE;
    let mut n_file: std::os::raw::c_int = 0;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut n_enc: std::os::raw::c_int = 0;
    n_file = 0 as std::os::raw::c_int;
    while n_file < 2 as std::os::raw::c_int {
        n_enc = 0 as std::os::raw::c_int;
        while n_enc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            file = gen_FILE_ptr(n_file, 0 as std::os::raw::c_int);
            enc = gen_xmlCharEncoding(n_enc, 1 as std::os::raw::c_int);
            ret_val = xmlParserInputBufferCreateFile(file, enc);
            desret_xmlParserInputBufferPtr(ret_val);
            call_tests += 1;
            des_FILE_ptr(n_file, file, 0 as std::os::raw::c_int);
            des_xmlCharEncoding(n_enc, enc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserInputBufferCreateFile\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_file);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_enc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_enc += 1
        }
        n_file += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserInputBufferCreateFilename()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut URI: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URI: std::os::raw::c_int = 0;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut n_enc: std::os::raw::c_int = 0;
    n_URI = 0 as std::os::raw::c_int;
    while n_URI < 6 as std::os::raw::c_int {
        n_enc = 0 as std::os::raw::c_int;
        while n_enc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            URI = gen_fileoutput(n_URI, 0 as std::os::raw::c_int);
            enc = gen_xmlCharEncoding(n_enc, 1 as std::os::raw::c_int);
            ret_val = xmlParserInputBufferCreateFilename(URI, enc);
            desret_xmlParserInputBufferPtr(ret_val);
            call_tests += 1;
            des_fileoutput(n_URI, URI, 0 as std::os::raw::c_int);
            des_xmlCharEncoding(n_enc, enc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserInputBufferCreateFilename\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URI);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_enc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_enc += 1
        }
        n_URI += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserInputBufferCreateMem() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut mem: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_mem: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut n_enc: std::os::raw::c_int = 0;
    n_mem = 0 as std::os::raw::c_int;
    while n_mem < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            n_enc = 0 as std::os::raw::c_int;
            while n_enc < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                mem = gen_const_char_ptr(n_mem, 0 as std::os::raw::c_int);
                size = gen_int(n_size, 1 as std::os::raw::c_int);
                enc = gen_xmlCharEncoding(n_enc, 2 as std::os::raw::c_int);
                if !(!mem.is_null() &&
                         size >
                             strlen(mem as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlParserInputBufferCreateMem(mem as
                                                          *const std::os::raw::c_char,
                                                      size, enc);
                    desret_xmlParserInputBufferPtr(ret_val);
                    call_tests += 1;
                    des_const_char_ptr(n_mem, mem as *const std::os::raw::c_char,
                                       0 as std::os::raw::c_int);
                    des_int(n_size, size, 1 as std::os::raw::c_int);
                    des_xmlCharEncoding(n_enc, enc, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlParserInputBufferCreateMem\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_mem);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_size);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_enc);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_enc += 1
            }
            n_size += 1
        }
        n_mem += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserInputBufferCreateStatic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut mem: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_mem: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut n_enc: std::os::raw::c_int = 0;
    n_mem = 0 as std::os::raw::c_int;
    while n_mem < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            n_enc = 0 as std::os::raw::c_int;
            while n_enc < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                mem = gen_const_char_ptr(n_mem, 0 as std::os::raw::c_int);
                size = gen_int(n_size, 1 as std::os::raw::c_int);
                enc = gen_xmlCharEncoding(n_enc, 2 as std::os::raw::c_int);
                if !(!mem.is_null() &&
                         size >
                             strlen(mem as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlParserInputBufferCreateStatic(mem as
                                                             *const std::os::raw::c_char,
                                                         size, enc);
                    desret_xmlParserInputBufferPtr(ret_val);
                    call_tests += 1;
                    des_const_char_ptr(n_mem, mem as *const std::os::raw::c_char,
                                       0 as std::os::raw::c_int);
                    des_int(n_size, size, 1 as std::os::raw::c_int);
                    des_xmlCharEncoding(n_enc, enc, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlParserInputBufferCreateStatic\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_mem);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_size);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_enc);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_enc += 1
            }
            n_size += 1
        }
        n_mem += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserInputBufferGrow() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut n_in: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_in = 0 as std::os::raw::c_int;
    while n_in < 8 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            in_0 = gen_xmlParserInputBufferPtr(n_in, 0 as std::os::raw::c_int);
            len = gen_int(n_len, 1 as std::os::raw::c_int);
            ret_val = xmlParserInputBufferGrow(in_0, len);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserInputBufferPtr(n_in, in_0, 0 as std::os::raw::c_int);
            des_int(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserInputBufferGrow\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_in);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_in += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserInputBufferPush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut n_in: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    let mut buf: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buf: std::os::raw::c_int = 0;
    n_in = 0 as std::os::raw::c_int;
    while n_in < 8 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            n_buf = 0 as std::os::raw::c_int;
            while n_buf < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                in_0 = gen_xmlParserInputBufferPtr(n_in, 0 as std::os::raw::c_int);
                len = gen_int(n_len, 1 as std::os::raw::c_int);
                buf = gen_const_char_ptr(n_buf, 2 as std::os::raw::c_int);
                if !(!buf.is_null() &&
                         len >
                             strlen(buf as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlParserInputBufferPush(in_0, len,
                                                 buf as *const std::os::raw::c_char);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlParserInputBufferPtr(n_in, in_0, 0 as std::os::raw::c_int);
                    des_int(n_len, len, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_buf, buf as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlParserInputBufferPush\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_in);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_buf);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_buf += 1
            }
            n_len += 1
        }
        n_in += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserInputBufferRead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut n_in: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_in = 0 as std::os::raw::c_int;
    while n_in < 8 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            in_0 = gen_xmlParserInputBufferPtr(n_in, 0 as std::os::raw::c_int);
            len = gen_int(n_len, 1 as std::os::raw::c_int);
            ret_val = xmlParserInputBufferRead(in_0, len);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlParserInputBufferPtr(n_in, in_0, 0 as std::os::raw::c_int);
            des_int(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlParserInputBufferRead\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_in);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_in += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlPopInputCallbacks() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    ret_val = xmlPopInputCallbacks();
    desret_int(ret_val);
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlPopInputCallbacks\x00" as
                   *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRegisterDefaultInputCallbacks() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlRegisterDefaultInputCallbacks();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlRegisterDefaultInputCallbacks\x00"
                   as *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRegisterDefaultOutputCallbacks() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlRegisterDefaultOutputCallbacks();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlRegisterDefaultOutputCallbacks\x00"
                   as *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRegisterHTTPPostCallbacks() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlRegisterHTTPPostCallbacks();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlRegisterHTTPPostCallbacks\x00"
                   as *const u8 as *const std::os::raw::c_char,
               xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlIO() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlIO : 40 of 50 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char);
    }
    test_ret += test_xmlAllocOutputBuffer();
    test_ret += test_xmlAllocParserInputBuffer();
    test_ret += test_xmlCheckFilename();
    test_ret += test_xmlCheckHTTPInput();
    test_ret += test_xmlCleanupInputCallbacks();
    test_ret += test_xmlCleanupOutputCallbacks();
    test_ret += test_xmlFileClose();
    test_ret += test_xmlFileMatch();
    test_ret += test_xmlFileOpen();
    test_ret += test_xmlFileRead();
    test_ret += test_xmlIOFTPClose();
    test_ret += test_xmlIOFTPMatch();
    test_ret += test_xmlIOFTPOpen();
    test_ret += test_xmlIOFTPRead();
    test_ret += test_xmlIOHTTPClose();
    test_ret += test_xmlIOHTTPMatch();
    test_ret += test_xmlIOHTTPOpen();
    test_ret += test_xmlIOHTTPRead();
    test_ret += test_xmlNoNetExternalEntityLoader();
    test_ret += test_xmlNormalizeWindowsPath();
    test_ret += test_xmlOutputBufferCreateBuffer();
    test_ret += test_xmlOutputBufferCreateFd();
    test_ret += test_xmlOutputBufferCreateFile();
    test_ret += test_xmlOutputBufferCreateFilename();
    test_ret += test_xmlOutputBufferFlush();
    test_ret += test_xmlOutputBufferGetContent();
    test_ret += test_xmlOutputBufferGetSize();
    test_ret += test_xmlOutputBufferWrite();
    test_ret += test_xmlOutputBufferWriteEscape();
    test_ret += test_xmlOutputBufferWriteString();
    test_ret += test_xmlParserGetDirectory();
    test_ret += test_xmlParserInputBufferCreateFd();
    test_ret += test_xmlParserInputBufferCreateFile();
    test_ret += test_xmlParserInputBufferCreateFilename();
    test_ret += test_xmlParserInputBufferCreateMem();
    test_ret += test_xmlParserInputBufferCreateStatic();
    test_ret += test_xmlParserInputBufferGrow();
    test_ret += test_xmlParserInputBufferPush();
    test_ret += test_xmlParserInputBufferRead();
    test_ret += test_xmlPopInputCallbacks();
    test_ret += test_xmlRegisterDefaultInputCallbacks();
    test_ret += test_xmlRegisterDefaultOutputCallbacks();
    test_ret += test_xmlRegisterHTTPPostCallbacks();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlIO: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn gen_xmlAutomataPtr(mut no: std::os::raw::c_int,
                                        mut nr: std::os::raw::c_int)
 -> xmlAutomataPtr {
    return 0 as xmlAutomataPtr;
}
unsafe extern "C" fn des_xmlAutomataPtr(mut no: std::os::raw::c_int,
                                        mut val: xmlAutomataPtr,
                                        mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlAutomataCompile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataGetInitState() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an automata */
}
unsafe extern "C" fn test_xmlAutomataIsDeterminist() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut am: xmlAutomataPtr = 0 as *mut xmlAutomata;
    let mut n_am: std::os::raw::c_int = 0;
    n_am = 0 as std::os::raw::c_int;
    while n_am < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        am = gen_xmlAutomataPtr(n_am, 0 as std::os::raw::c_int);
        ret_val = xmlAutomataIsDeterminist(am);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlAutomataPtr(n_am, am, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlAutomataIsDeterminist\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_am);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_am += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlAutomataStatePtr(mut no: std::os::raw::c_int,
                                             mut nr: std::os::raw::c_int)
 -> xmlAutomataStatePtr {
    return 0 as xmlAutomataStatePtr;
}
unsafe extern "C" fn des_xmlAutomataStatePtr(mut no: std::os::raw::c_int,
                                             mut val: xmlAutomataStatePtr,
                                             mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlAutomataNewAllTrans() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewCountTrans() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewCountTrans2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewCountedTrans() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an automata */
}
unsafe extern "C" fn test_xmlAutomataNewCounter() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the minimal value on the counter */
    let mut mem_base: std::os::raw::c_int = 0; /* the maximal value on the counter */
    let mut ret_val: std::os::raw::c_int = 0;
    let mut am: xmlAutomataPtr = 0 as *mut xmlAutomata;
    let mut n_am: std::os::raw::c_int = 0;
    let mut min: std::os::raw::c_int = 0;
    let mut n_min: std::os::raw::c_int = 0;
    let mut max: std::os::raw::c_int = 0;
    let mut n_max: std::os::raw::c_int = 0;
    n_am = 0 as std::os::raw::c_int;
    while n_am < 1 as std::os::raw::c_int {
        n_min = 0 as std::os::raw::c_int;
        while n_min < 4 as std::os::raw::c_int {
            n_max = 0 as std::os::raw::c_int;
            while n_max < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                am = gen_xmlAutomataPtr(n_am, 0 as std::os::raw::c_int);
                min = gen_int(n_min, 1 as std::os::raw::c_int);
                max = gen_int(n_max, 2 as std::os::raw::c_int);
                ret_val = xmlAutomataNewCounter(am, min, max);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlAutomataPtr(n_am, am, 0 as std::os::raw::c_int);
                des_int(n_min, min, 1 as std::os::raw::c_int);
                des_int(n_max, max, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlAutomataNewCounter\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_am);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_min);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_max);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_max += 1
            }
            n_min += 1
        }
        n_am += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewCounterTrans() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewEpsilon() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewNegTrans() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewOnceTrans() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewOnceTrans2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewState() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewTransition() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlAutomataNewTransition2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an automata */
}
unsafe extern "C" fn test_xmlAutomataSetFinalState() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* a state in this automata */
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut am: xmlAutomataPtr = 0 as *mut xmlAutomata;
    let mut n_am: std::os::raw::c_int = 0;
    let mut state: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
    let mut n_state: std::os::raw::c_int = 0;
    n_am = 0 as std::os::raw::c_int;
    while n_am < 1 as std::os::raw::c_int {
        n_state = 0 as std::os::raw::c_int;
        while n_state < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            am = gen_xmlAutomataPtr(n_am, 0 as std::os::raw::c_int);
            state = gen_xmlAutomataStatePtr(n_state, 1 as std::os::raw::c_int);
            ret_val = xmlAutomataSetFinalState(am, state);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlAutomataPtr(n_am, am, 0 as std::os::raw::c_int);
            des_xmlAutomataStatePtr(n_state, state, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlAutomataSetFinalState\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_am);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_state);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_state += 1
        }
        n_am += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewAutomata() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the handler */
}
unsafe extern "C" fn test_xmlautomata() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* a source error */
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlautomata : 3 of 19 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char); /* a target error */
    }
    test_ret += test_xmlAutomataCompile();
    test_ret += test_xmlAutomataGetInitState();
    test_ret += test_xmlAutomataIsDeterminist();
    test_ret += test_xmlAutomataNewAllTrans();
    test_ret += test_xmlAutomataNewCountTrans();
    test_ret += test_xmlAutomataNewCountTrans2();
    test_ret += test_xmlAutomataNewCountedTrans();
    test_ret += test_xmlAutomataNewCounter();
    test_ret += test_xmlAutomataNewCounterTrans();
    test_ret += test_xmlAutomataNewEpsilon();
    test_ret += test_xmlAutomataNewNegTrans();
    test_ret += test_xmlAutomataNewOnceTrans();
    test_ret += test_xmlAutomataNewOnceTrans2();
    test_ret += test_xmlAutomataNewState();
    test_ret += test_xmlAutomataNewTransition();
    test_ret += test_xmlAutomataNewTransition2();
    test_ret += test_xmlAutomataSetFinalState();
    test_ret += test_xmlNewAutomata();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlautomata: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn gen_xmlGenericErrorFunc_ptr(mut no: std::os::raw::c_int,
                                                 mut nr: std::os::raw::c_int)
 -> *mut xmlGenericErrorFunc {
    return 0 as *mut xmlGenericErrorFunc;
}
unsafe extern "C" fn des_xmlGenericErrorFunc_ptr(mut no: std::os::raw::c_int,
                                                 mut val:
                                                     *mut xmlGenericErrorFunc,
                                                 mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_initGenericErrorDefaultFunc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut handler: *mut xmlGenericErrorFunc = 0 as *mut xmlGenericErrorFunc;
    let mut n_handler: std::os::raw::c_int = 0;
    n_handler = 0 as std::os::raw::c_int;
    while n_handler < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        handler = gen_xmlGenericErrorFunc_ptr(n_handler, 0 as std::os::raw::c_int);
        initGenericErrorDefaultFunc(handler);
        call_tests += 1;
        des_xmlGenericErrorFunc_ptr(n_handler, handler, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in initGenericErrorDefaultFunc\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_handler);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_handler += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlErrorPtr(mut no: std::os::raw::c_int, mut nr: std::os::raw::c_int)
 -> xmlErrorPtr {
    return 0 as xmlErrorPtr;
}
unsafe extern "C" fn des_xmlErrorPtr(mut no: std::os::raw::c_int,
                                     mut val: xmlErrorPtr,
                                     mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlCopyError() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut from: xmlErrorPtr = 0 as *mut xmlError;
    let mut n_from: std::os::raw::c_int = 0;
    let mut to: xmlErrorPtr = 0 as *mut xmlError;
    let mut n_to: std::os::raw::c_int = 0;
    n_from = 0 as std::os::raw::c_int;
    while n_from < 1 as std::os::raw::c_int {
        n_to = 0 as std::os::raw::c_int;
        while n_to < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            from = gen_xmlErrorPtr(n_from, 0 as std::os::raw::c_int);
            to = gen_xmlErrorPtr(n_to, 1 as std::os::raw::c_int);
            ret_val = xmlCopyError(from, to);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlErrorPtr(n_from, from, 0 as std::os::raw::c_int);
            des_xmlErrorPtr(n_to, to, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlCopyError\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_from);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_to);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_to += 1
        }
        n_from += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCtxtGetLastError() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an XML parser context */
}
unsafe extern "C" fn test_xmlCtxtResetLastError() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctx: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctx = 0 as std::os::raw::c_int;
    while n_ctx < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0 as std::os::raw::c_int);
        xmlCtxtResetLastError(ctx);
        call_tests += 1;
        des_void_ptr(n_ctx, ctx, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCtxtResetLastError\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctx += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetLastError() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlParserError() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an xmlParserInputPtr input */
}
unsafe extern "C" fn test_xmlParserPrintFileContext() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* an xmlParserInputPtr input */
    let mut mem_base: std::os::raw::c_int = 0;
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut n_input: std::os::raw::c_int = 0;
    n_input = 0 as std::os::raw::c_int;
    while n_input < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        input = gen_xmlParserInputPtr(n_input, 0 as std::os::raw::c_int);
        xmlParserPrintFileContext(input);
        call_tests += 1;
        des_xmlParserInputPtr(n_input, input, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParserPrintFileContext\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_input);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_input += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserPrintFileInfo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut n_input: std::os::raw::c_int = 0;
    n_input = 0 as std::os::raw::c_int;
    while n_input < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        input = gen_xmlParserInputPtr(n_input, 0 as std::os::raw::c_int);
        xmlParserPrintFileInfo(input);
        call_tests += 1;
        des_xmlParserInputPtr(n_input, input, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlParserPrintFileInfo\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_input);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_input += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlParserValidityError() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlParserValidityWarning() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlParserWarning() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* pointer to the error. */
}
unsafe extern "C" fn test_xmlResetError() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut err: xmlErrorPtr = 0 as *mut xmlError;
    let mut n_err: std::os::raw::c_int = 0;
    n_err = 0 as std::os::raw::c_int;
    while n_err < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        err = gen_xmlErrorPtr(n_err, 0 as std::os::raw::c_int);
        xmlResetError(err);
        call_tests += 1;
        des_xmlErrorPtr(n_err, err, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlResetError\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_err);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_err += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlResetLastError() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    xmlResetLastError();
    call_tests += 1;
    xmlResetLastError();
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSetGenericErrorFunc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSetStructuredErrorFunc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the module handle */
}
unsafe extern "C" fn test_xmlerror() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlerror : 7 of 15 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_initGenericErrorDefaultFunc();
    test_ret += test_xmlCopyError();
    test_ret += test_xmlCtxtGetLastError();
    test_ret += test_xmlCtxtResetLastError();
    test_ret += test_xmlGetLastError();
    test_ret += test_xmlParserError();
    test_ret += test_xmlParserPrintFileContext();
    test_ret += test_xmlParserPrintFileInfo();
    test_ret += test_xmlParserValidityError();
    test_ret += test_xmlParserValidityWarning();
    test_ret += test_xmlParserWarning();
    test_ret += test_xmlResetError();
    test_ret += test_xmlResetLastError();
    test_ret += test_xmlSetGenericErrorFunc();
    test_ret += test_xmlSetStructuredErrorFunc();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlerror: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn gen_xmlModulePtr(mut no: std::os::raw::c_int,
                                      mut nr: std::os::raw::c_int) -> xmlModulePtr {
    return 0 as xmlModulePtr;
}
unsafe extern "C" fn des_xmlModulePtr(mut no: std::os::raw::c_int,
                                      mut val: xmlModulePtr,
                                      mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlModuleClose() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut module: xmlModulePtr = 0 as *mut xmlModule;
    let mut n_module: std::os::raw::c_int = 0;
    n_module = 0 as std::os::raw::c_int;
    while n_module < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        module = gen_xmlModulePtr(n_module, 0 as std::os::raw::c_int);
        ret_val = xmlModuleClose(module);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlModulePtr(n_module, module, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlModuleClose\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_module);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_module += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlModuleOpen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the module */
}
unsafe extern "C" fn test_xmlModuleSymbol() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the name of the symbol */
    let mut mem_base: std::os::raw::c_int = 0; /* the resulting symbol address */
    let mut ret_val: std::os::raw::c_int =
        0; /* the xmlParserInputBufferPtr used to read data */
    let mut module: xmlModulePtr =
        0 as
            *mut xmlModule; /* the URI information for the source if available */
    let mut n_module: std::os::raw::c_int =
        0; /* the URI of the resource to process */
    let mut name: *mut std::os::raw::c_char =
        0 as *mut std::os::raw::c_char; /* a pointer to a zero terminated string */
    let mut n_name: std::os::raw::c_int =
        0; /* the base URL to use for the document */
    let mut symbol: *mut *mut std::os::raw::c_void =
        0 as *mut *mut std::os::raw::c_void; /* the document encoding, or NULL */
    let mut n_symbol: std::os::raw::c_int = 0; /* a combination of xmlParserOption */
    n_module = 0 as std::os::raw::c_int; /* a file or URL */
    while n_module < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* the document encoding, or NULL */
        while n_name < 4 as std::os::raw::c_int {
            n_symbol =
                0 as std::os::raw::c_int; /* a combination of xmlParserOption */
            while n_symbol < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* a pointer to a char array */
                module =
                    gen_xmlModulePtr(n_module,
                                     0 as
                                         std::os::raw::c_int); /* the size of the array */
                name =
                    gen_const_char_ptr(n_name,
                                       1 as
                                           std::os::raw::c_int); /* the base URL to use for the document */
                symbol =
                    gen_void_ptr_ptr(n_symbol,
                                     2 as
                                         std::os::raw::c_int); /* the document encoding, or NULL */
                ret_val =
                    xmlModuleSymbol(module, name as *const std::os::raw::c_char,
                                    symbol); /* a combination of xmlParserOption */
                desret_int(ret_val); /* an XML reader */
                call_tests += 1; /* a pointer to a zero terminated string */
                des_xmlModulePtr(n_module, module,
                                 0 as
                                     std::os::raw::c_int); /* the base URL to use for the document */
                des_const_char_ptr(n_name, name as *const std::os::raw::c_char,
                                   1 as
                                       std::os::raw::c_int); /* the document encoding, or NULL */
                des_void_ptr_ptr(n_symbol, symbol,
                                 2 as
                                     std::os::raw::c_int); /* a combination of xmlParserOption */
                xmlResetLastError(); /* an XML reader */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlModuleSymbol\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base); /* a file or URL */
                    test_ret += 1; /* the document encoding, or NULL */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_module); /* a combination of xmlParserOption */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name); /* an XML reader */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_symbol); /* a pointer to a char array */
                    printf(b"\n\x00" as *const u8 as
                               *const std::os::raw::c_char); /* the size of the array */
                } /* the base URL to use for the document */
                n_symbol += 1
            } /* the document encoding, or NULL */
            n_name += 1
        } /* a combination of xmlParserOption */
        n_module += 1
    } /* an XML reader */
    function_tests += 1; /* a preparsed document */
    return test_ret; /* a preparsed document */
}
unsafe extern "C" fn test_xmlmodule() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlTextReaderPtr used */
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlmodule : 2 of 4 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char); /* the xmlTextReaderPtr used */
    } /* an XML reader */
    test_ret += test_xmlModuleClose(); /* the xmlTextReaderPtr used */
    test_ret += test_xmlModuleOpen(); /* the xmlTextReaderPtr used */
    test_ret += test_xmlModuleSymbol(); /* the xmlTextReaderPtr used */
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlmodule: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char,
               test_ret); /* the xmlTextReaderPtr used */
    } /* the xmlTextReaderPtr used */
    return test_ret; /* the xmlTextReaderPtr used */
}
unsafe extern "C" fn test_xmlNewTextReader() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlTextReaderPtr used */
    let mut mem_base: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut ret_val: xmlTextReaderPtr =
        0 as *mut xmlTextReader; /* the string to intern. */
    let mut input: xmlParserInputBufferPtr =
        0 as *mut xmlParserInputBuffer; /* the xmlTextReaderPtr used */
    let mut n_input: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut URI: *const std::os::raw::c_char =
        0 as *const std::os::raw::c_char; /* the xmlTextReaderPtr used */
    let mut n_URI: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    n_input = 0 as std::os::raw::c_int; /* the xmlTextReaderPtr used */
    while n_input < 8 as std::os::raw::c_int {
        n_URI = 0 as std::os::raw::c_int; /* the xmlTextReaderPtr used */
        while n_URI < 8 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the xmlTextReaderPtr used */
            input =
                gen_xmlParserInputBufferPtr(n_input,
                                            0 as
                                                std::os::raw::c_int); /* the xmlTextReaderPtr used */
            URI =
                gen_filepath(n_URI,
                             1 as
                                 std::os::raw::c_int); /* the qualified name of the attribute. */
            ret_val =
                xmlNewTextReader(input, URI); /* the xmlTextReaderPtr used */
            desret_xmlTextReaderPtr(ret_val); /* the zero-based index of the attribute relative to the containing element */
            call_tests += 1; /* the xmlTextReaderPtr used */
            des_xmlParserInputBufferPtr(n_input, input,
                                        0 as
                                            std::os::raw::c_int); /* the local name of the attribute. */
            des_filepath(n_URI, URI,
                         1 as
                             std::os::raw::c_int); /* the namespace URI of the attribute. */
            xmlResetLastError(); /* the xmlTextReaderPtr used */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewTextReader\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the callback function or NULL is no callback has been registered */
                test_ret += 1; /* a user argument */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_input); /* the user data (XML reader context) */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_URI); /* the user data (XML reader context) */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the xmlTextReaderPtr used */
            } /* the xmlParserProperties to get */
            n_URI += 1
        } /* the xmlTextReaderPtr used */
        n_input += 1
    } /* the xmlTextReaderPtr used */
    function_tests += 1; /* the xmlTextReaderPtr used */
    return test_ret; /* the xmlTextReaderPtr used */
}
unsafe extern "C" fn test_xmlNewTextReaderFilename() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlTextReaderPtr used */
    let mut mem_base: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut ret_val: xmlTextReaderPtr =
        0 as *mut xmlTextReader; /* the xmlTextReaderPtr used */
    let mut URI: *const std::os::raw::c_char =
        0 as *const std::os::raw::c_char; /* the xmlTextReaderPtr used */
    let mut n_URI: std::os::raw::c_int = 0; /* the xmlTextReaderLocatorPtr used */
    n_URI = 0 as std::os::raw::c_int; /* the xmlTextReaderLocatorPtr used */
    while n_URI < 8 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the xmlTextReaderPtr used */
        URI =
            gen_filepath(n_URI,
                         0 as
                             std::os::raw::c_int); /* the prefix whose namespace URI is to be resolved. To return the default namespace, specify NULL */
        ret_val =
            xmlNewTextReaderFilename(URI); /* the xmlTextReaderPtr used */
        desret_xmlTextReaderPtr(ret_val); /* the qualified name of the attribute. */
        call_tests += 1; /* the xmlTextReaderPtr used */
        des_filepath(n_URI, URI,
                     0 as
                         std::os::raw::c_int); /* the zero-based index of the attribute relative to the containing element. */
        xmlResetLastError(); /* the xmlTextReaderPtr used */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNewTextReaderFilename\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() -
                       mem_base); /* the local name of the attribute. */
            test_ret += 1; /* the namespace URI of the attribute. */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_URI); /* the xmlTextReaderPtr used */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the xmlTextReaderPtr used */
        } /* the xmlTextReaderPtr used */
        n_URI += 1
    } /* the xmlTextReaderPtr used */
    function_tests += 1; /* the xmlTextReaderPtr used */
    return test_ret; /* the xmlTextReaderPtr used */
}
unsafe extern "C" fn test_xmlReaderForDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlTextReaderPtr used */
    let mut mem_base: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut ret_val: xmlTextReaderPtr =
        0 as *mut xmlTextReader; /* the xmlTextReaderPtr used */
    let mut cur: *mut xmlChar =
        0 as *mut xmlChar; /* the xmlTextReaderPtr used */
    let mut n_cur: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut URL: *const std::os::raw::c_char =
        0 as *const std::os::raw::c_char; /* the xmlTextReaderPtr used */
    let mut n_URL: std::os::raw::c_int = 0; /* an XPath subset pattern */
    let mut encoding: *mut std::os::raw::c_char =
        0 as
            *mut std::os::raw::c_char; /* the prefix definitions, array of [URI, prefix] or NULL */
    let mut n_encoding: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut options: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut n_options: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    n_cur = 0 as std::os::raw::c_int; /* the xmlTextReaderPtr used */
    while n_cur < 5 as std::os::raw::c_int {
        n_URL = 0 as std::os::raw::c_int; /* the xmlTextReaderPtr used */
        while n_URL < 8 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int; /* a precompiled RelaxNG schema */
            while n_encoding < 4 as std::os::raw::c_int {
                n_options = 0 as std::os::raw::c_int; /* the xmlTextReaderPtr used */
                while n_options < 5 as std::os::raw::c_int {
                    mem_base =
                        xmlMemBlocks(); /* the path to a RelaxNG schema or NULL */
                    cur =
                        gen_const_xmlChar_ptr(n_cur,
                                              0 as
                                                  std::os::raw::c_int); /* the xmlTextReaderPtr used */
                    URL =
                        gen_filepath(n_URL,
                                     1 as
                                         std::os::raw::c_int); /* the RelaxNG schema validation context or NULL */
                    encoding =
                        gen_const_char_ptr(n_encoding,
                                           2 as
                                               std::os::raw::c_int); /* options (not used yet) */
                    options =
                        gen_parseroptions(n_options,
                                          3 as
                                              std::os::raw::c_int); /* the xmlTextReaderPtr used */
                    ret_val =
                        xmlReaderForDoc(cur as *const xmlChar, URL,
                                        encoding as *const std::os::raw::c_char,
                                        options); /* the path to a W3C XSD schema or NULL */
                    desret_xmlTextReaderPtr(ret_val); /* the xmlTextReaderPtr used */
                    call_tests +=
                        1; /* the XML Schema validation context or NULL */
                    des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                          0 as
                                              std::os::raw::c_int); /* options (not used yet) */
                    des_filepath(n_URL, URL, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_parseroptions(n_options, options, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlReaderForDoc\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_cur);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_URL);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_options);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_options += 1
                }
                n_encoding += 1
            }
            n_URL += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReaderForFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_filename = 0 as std::os::raw::c_int;
    while n_filename < 8 as std::os::raw::c_int {
        n_encoding = 0 as std::os::raw::c_int;
        while n_encoding < 4 as std::os::raw::c_int {
            n_options = 0 as std::os::raw::c_int;
            while n_options < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                filename = gen_filepath(n_filename, 0 as std::os::raw::c_int);
                encoding = gen_const_char_ptr(n_encoding, 1 as std::os::raw::c_int);
                options = gen_parseroptions(n_options, 2 as std::os::raw::c_int);
                ret_val =
                    xmlReaderForFile(filename,
                                     encoding as *const std::os::raw::c_char,
                                     options);
                desret_xmlTextReaderPtr(ret_val);
                call_tests += 1;
                des_filepath(n_filename, filename, 0 as std::os::raw::c_int);
                des_const_char_ptr(n_encoding,
                                   encoding as *const std::os::raw::c_char,
                                   1 as std::os::raw::c_int);
                des_parseroptions(n_options, options, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlReaderForFile\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_encoding);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_options);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_options += 1
            }
            n_encoding += 1
        }
        n_filename += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReaderForMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            n_URL = 0 as std::os::raw::c_int;
            while n_URL < 8 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    n_options = 0 as std::os::raw::c_int;
                    while n_options < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        buffer =
                            gen_const_char_ptr(n_buffer, 0 as std::os::raw::c_int);
                        size = gen_int(n_size, 1 as std::os::raw::c_int);
                        URL = gen_filepath(n_URL, 2 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                        options =
                            gen_parseroptions(n_options, 4 as std::os::raw::c_int);
                        if !(!buffer.is_null() &&
                                 size >
                                     strlen(buffer as *const std::os::raw::c_char) as
                                         std::os::raw::c_int + 1 as std::os::raw::c_int) {
                            ret_val =
                                xmlReaderForMemory(buffer as
                                                       *const std::os::raw::c_char,
                                                   size, URL,
                                                   encoding as
                                                       *const std::os::raw::c_char,
                                                   options);
                            desret_xmlTextReaderPtr(ret_val);
                            call_tests += 1;
                            des_const_char_ptr(n_buffer,
                                               buffer as *const std::os::raw::c_char,
                                               0 as std::os::raw::c_int);
                            des_int(n_size, size, 1 as std::os::raw::c_int);
                            des_filepath(n_URL, URL, 2 as std::os::raw::c_int);
                            des_const_char_ptr(n_encoding,
                                               encoding as
                                                   *const std::os::raw::c_char,
                                               3 as std::os::raw::c_int);
                            des_parseroptions(n_options, options,
                                              4 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlReaderForMemory\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_buffer);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_size);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_URL);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_encoding);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_options);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                        }
                        n_options += 1
                    }
                    n_encoding += 1
                }
                n_URL += 1
            }
            n_size += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReaderNewDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 5 as std::os::raw::c_int {
            n_URL = 0 as std::os::raw::c_int;
            while n_URL < 8 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    n_options = 0 as std::os::raw::c_int;
                    while n_options < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        reader =
                            gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                        cur = gen_const_xmlChar_ptr(n_cur, 1 as std::os::raw::c_int);
                        URL = gen_filepath(n_URL, 2 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                        options =
                            gen_parseroptions(n_options, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlReaderNewDoc(reader, cur as *const xmlChar,
                                            URL,
                                            encoding as *const std::os::raw::c_char,
                                            options);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlTextReaderPtr(n_reader, reader,
                                             0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_filepath(n_URL, URL, 2 as std::os::raw::c_int);
                        des_const_char_ptr(n_encoding,
                                           encoding as *const std::os::raw::c_char,
                                           3 as std::os::raw::c_int);
                        des_parseroptions(n_options, options,
                                          4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlReaderNewDoc\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_reader);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_cur);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_URL);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_encoding);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_options);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_options += 1
                    }
                    n_encoding += 1
                }
                n_URL += 1
            }
            n_cur += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReaderNewFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 8 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                n_options = 0 as std::os::raw::c_int;
                while n_options < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                    filename = gen_filepath(n_filename, 1 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                    options = gen_parseroptions(n_options, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlReaderNewFile(reader, filename,
                                         encoding as *const std::os::raw::c_char,
                                         options);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
                    des_filepath(n_filename, filename, 1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_parseroptions(n_options, options, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlReaderNewFile\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_reader);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_filename);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_options);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_options += 1
                }
                n_encoding += 1
            }
            n_filename += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReaderNewMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    let mut URL: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_buffer = 0 as std::os::raw::c_int;
        while n_buffer < 4 as std::os::raw::c_int {
            n_size = 0 as std::os::raw::c_int;
            while n_size < 4 as std::os::raw::c_int {
                n_URL = 0 as std::os::raw::c_int;
                while n_URL < 8 as std::os::raw::c_int {
                    n_encoding = 0 as std::os::raw::c_int;
                    while n_encoding < 4 as std::os::raw::c_int {
                        n_options = 0 as std::os::raw::c_int;
                        while n_options < 5 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            reader =
                                gen_xmlTextReaderPtr(n_reader,
                                                     0 as std::os::raw::c_int);
                            buffer =
                                gen_const_char_ptr(n_buffer,
                                                   1 as std::os::raw::c_int);
                            size = gen_int(n_size, 2 as std::os::raw::c_int);
                            URL = gen_filepath(n_URL, 3 as std::os::raw::c_int);
                            encoding =
                                gen_const_char_ptr(n_encoding,
                                                   4 as std::os::raw::c_int);
                            options =
                                gen_parseroptions(n_options,
                                                  5 as std::os::raw::c_int);
                            if !(!buffer.is_null() &&
                                     size >
                                         strlen(buffer as *const std::os::raw::c_char)
                                             as std::os::raw::c_int +
                                             1 as std::os::raw::c_int) {
                                ret_val =
                                    xmlReaderNewMemory(reader,
                                                       buffer as
                                                           *const std::os::raw::c_char,
                                                       size, URL,
                                                       encoding as
                                                           *const std::os::raw::c_char,
                                                       options);
                                desret_int(ret_val);
                                call_tests += 1;
                                des_xmlTextReaderPtr(n_reader, reader,
                                                     0 as std::os::raw::c_int);
                                des_const_char_ptr(n_buffer,
                                                   buffer as
                                                       *const std::os::raw::c_char,
                                                   1 as std::os::raw::c_int);
                                des_int(n_size, size, 2 as std::os::raw::c_int);
                                des_filepath(n_URL, URL, 3 as std::os::raw::c_int);
                                des_const_char_ptr(n_encoding,
                                                   encoding as
                                                       *const std::os::raw::c_char,
                                                   4 as std::os::raw::c_int);
                                des_parseroptions(n_options, options,
                                                  5 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in xmlReaderNewMemory\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_reader);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_buffer);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_size);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_URL);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_encoding);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_options);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                            }
                            n_options += 1
                        }
                        n_encoding += 1
                    }
                    n_URL += 1
                }
                n_size += 1
            }
            n_buffer += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReaderNewWalker() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            ret_val = xmlReaderNewWalker(reader, doc);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlReaderNewWalker\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlReaderWalker() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
        ret_val = xmlReaderWalker(doc);
        desret_xmlTextReaderPtr(ret_val);
        call_tests += 1;
        des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlReaderWalker\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderAttributeCount() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderAttributeCount(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderAttributeCount\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderBaseUri() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderBaseUri(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderBaseUri\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderByteConsumed() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_long = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderByteConsumed(reader);
        desret_long(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderByteConsumed\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderClose() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderClose(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderClose\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstBaseUri() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderConstBaseUri(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderConstBaseUri\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstEncoding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderConstEncoding(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderConstEncoding\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstLocalName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderConstLocalName(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderConstLocalName\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderConstName(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderConstName\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstNamespaceUri() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderConstNamespaceUri(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderConstNamespaceUri\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstPrefix() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderConstPrefix(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderConstPrefix\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            str = gen_const_xmlChar_ptr(n_str, 1 as std::os::raw::c_int);
            ret_val = xmlTextReaderConstString(reader, str as *const xmlChar);
            desret_const_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderConstString\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderConstValue(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderConstValue\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstXmlLang() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderConstXmlLang(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderConstXmlLang\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderConstXmlVersion() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderConstXmlVersion(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderConstXmlVersion\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderCurrentDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlDocPtr = 0 as *mut xmlDoc;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderCurrentDoc(reader);
        desret_xmlDocPtr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderCurrentDoc\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderCurrentNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderCurrentNode(reader);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderCurrentNode\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderDepth() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderDepth(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderDepth\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderExpand() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderExpand(reader);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderExpand\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderGetAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextReaderGetAttribute(reader, name as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderGetAttribute\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderGetAttributeNo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut no: std::os::raw::c_int = 0;
    let mut n_no: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_no = 0 as std::os::raw::c_int;
        while n_no < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            no = gen_int(n_no, 1 as std::os::raw::c_int);
            ret_val = xmlTextReaderGetAttributeNo(reader, no);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_int(n_no, no, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderGetAttributeNo\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_no);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_no += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderGetAttributeNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_localName: std::os::raw::c_int = 0;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_namespaceURI: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_localName = 0 as std::os::raw::c_int;
        while n_localName < 5 as std::os::raw::c_int {
            n_namespaceURI = 0 as std::os::raw::c_int;
            while n_namespaceURI < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                localName =
                    gen_const_xmlChar_ptr(n_localName, 1 as std::os::raw::c_int);
                namespaceURI =
                    gen_const_xmlChar_ptr(n_namespaceURI, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextReaderGetAttributeNs(reader,
                                                localName as *const xmlChar,
                                                namespaceURI as
                                                    *const xmlChar);
                desret_xmlChar_ptr(ret_val);
                call_tests += 1;
                des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_localName,
                                      localName as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_namespaceURI,
                                      namespaceURI as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextReaderGetAttributeNs\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_reader);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_localName);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_namespaceURI);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_namespaceURI += 1
            }
            n_localName += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlTextReaderErrorFunc_ptr(mut no: std::os::raw::c_int,
                                                    mut nr: std::os::raw::c_int)
 -> *mut xmlTextReaderErrorFunc {
    return 0 as *mut xmlTextReaderErrorFunc;
}
unsafe extern "C" fn des_xmlTextReaderErrorFunc_ptr(mut no: std::os::raw::c_int,
                                                    mut val:
                                                        *mut xmlTextReaderErrorFunc,
                                                    mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlTextReaderGetErrorHandler() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut f: *mut xmlTextReaderErrorFunc = 0 as *mut xmlTextReaderErrorFunc;
    let mut n_f: std::os::raw::c_int = 0;
    let mut arg: *mut *mut std::os::raw::c_void = 0 as *mut *mut std::os::raw::c_void;
    let mut n_arg: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_f = 0 as std::os::raw::c_int;
        while n_f < 1 as std::os::raw::c_int {
            n_arg = 0 as std::os::raw::c_int;
            while n_arg < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                f = gen_xmlTextReaderErrorFunc_ptr(n_f, 1 as std::os::raw::c_int);
                arg = gen_void_ptr_ptr(n_arg, 2 as std::os::raw::c_int);
                xmlTextReaderGetErrorHandler(reader, f, arg);
                call_tests += 1;
                des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
                des_xmlTextReaderErrorFunc_ptr(n_f, f, 1 as std::os::raw::c_int);
                des_void_ptr_ptr(n_arg, arg, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextReaderGetErrorHandler\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_reader);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_f);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_arg);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_arg += 1
            }
            n_f += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderGetParserColumnNumber()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderGetParserColumnNumber(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderGetParserColumnNumber\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderGetParserLineNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderGetParserLineNumber(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderGetParserLineNumber\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderGetParserProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut prop: std::os::raw::c_int = 0;
    let mut n_prop: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_prop = 0 as std::os::raw::c_int;
        while n_prop < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            prop = gen_int(n_prop, 1 as std::os::raw::c_int);
            ret_val = xmlTextReaderGetParserProp(reader, prop);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_int(n_prop, prop, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderGetParserProp\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_prop);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_prop += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderGetRemainder() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderGetRemainder(reader);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderGetRemainder\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderHasAttributes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderHasAttributes(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderHasAttributes\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderHasValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderHasValue(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderHasValue\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderIsDefault() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderIsDefault(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderIsDefault\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderIsEmptyElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderIsEmptyElement(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderIsEmptyElement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderIsNamespaceDecl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderIsNamespaceDecl(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderIsNamespaceDecl\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderIsValid() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderIsValid(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderIsValid\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderLocalName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderLocalName(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderLocalName\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlTextReaderLocatorPtr(mut no: std::os::raw::c_int,
                                                 mut nr: std::os::raw::c_int)
 -> xmlTextReaderLocatorPtr {
    return 0 as *mut std::os::raw::c_void;
}
unsafe extern "C" fn des_xmlTextReaderLocatorPtr(mut no: std::os::raw::c_int,
                                                 mut val:
                                                     xmlTextReaderLocatorPtr,
                                                 mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlTextReaderLocatorBaseURI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut locator: xmlTextReaderLocatorPtr = 0 as *mut std::os::raw::c_void;
    let mut n_locator: std::os::raw::c_int = 0;
    n_locator = 0 as std::os::raw::c_int;
    while n_locator < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderLocatorBaseURI(locator);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderLocatorPtr(n_locator, locator, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderLocatorBaseURI\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_locator);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_locator += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderLocatorLineNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut locator: xmlTextReaderLocatorPtr = 0 as *mut std::os::raw::c_void;
    let mut n_locator: std::os::raw::c_int = 0;
    n_locator = 0 as std::os::raw::c_int;
    while n_locator < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderLocatorLineNumber(locator);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderLocatorPtr(n_locator, locator, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderLocatorLineNumber\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_locator);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_locator += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderLookupNamespace() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            prefix = gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextReaderLookupNamespace(reader,
                                             prefix as *const xmlChar);
            desret_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderLookupNamespace\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_prefix);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_prefix += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderMoveToAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextReaderMoveToAttribute(reader, name as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderMoveToAttribute\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderMoveToAttributeNo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut no: std::os::raw::c_int = 0;
    let mut n_no: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_no = 0 as std::os::raw::c_int;
        while n_no < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            no = gen_int(n_no, 1 as std::os::raw::c_int);
            ret_val = xmlTextReaderMoveToAttributeNo(reader, no);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_int(n_no, no, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderMoveToAttributeNo\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_no);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_no += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderMoveToAttributeNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_localName: std::os::raw::c_int = 0;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_namespaceURI: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_localName = 0 as std::os::raw::c_int;
        while n_localName < 5 as std::os::raw::c_int {
            n_namespaceURI = 0 as std::os::raw::c_int;
            while n_namespaceURI < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                localName =
                    gen_const_xmlChar_ptr(n_localName, 1 as std::os::raw::c_int);
                namespaceURI =
                    gen_const_xmlChar_ptr(n_namespaceURI, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextReaderMoveToAttributeNs(reader,
                                                   localName as
                                                       *const xmlChar,
                                                   namespaceURI as
                                                       *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_localName,
                                      localName as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_namespaceURI,
                                      namespaceURI as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextReaderMoveToAttributeNs\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_reader);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_localName);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_namespaceURI);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_namespaceURI += 1
            }
            n_localName += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderMoveToElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderMoveToElement(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderMoveToElement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderMoveToFirstAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderMoveToFirstAttribute(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderMoveToFirstAttribute\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderMoveToNextAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderMoveToNextAttribute(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderMoveToNextAttribute\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderName(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderName\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderNamespaceUri() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderNamespaceUri(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderNamespaceUri\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderNext() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderNext(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderNext\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderNextSibling() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderNextSibling(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderNextSibling\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderNodeType() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderNodeType(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderNodeType\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderNormalization() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderNormalization(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderNormalization\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderPrefix() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderPrefix(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderPrefix\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderPreserve() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderPreserve(reader);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderPreserve\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderPreservePattern() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut pattern: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pattern: std::os::raw::c_int = 0;
    let mut namespaces: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_namespaces: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_pattern = 0 as std::os::raw::c_int;
        while n_pattern < 5 as std::os::raw::c_int {
            n_namespaces = 0 as std::os::raw::c_int;
            while n_namespaces < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                pattern = gen_const_xmlChar_ptr(n_pattern, 1 as std::os::raw::c_int);
                namespaces =
                    gen_const_xmlChar_ptr_ptr(n_namespaces, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextReaderPreservePattern(reader,
                                                 pattern as *const xmlChar,
                                                 namespaces as
                                                     *mut *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_pattern, pattern as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr_ptr(n_namespaces,
                                          namespaces as *mut *const xmlChar,
                                          2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextReaderPreservePattern\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_reader);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_pattern);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_namespaces);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_namespaces += 1
            }
            n_pattern += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderQuoteChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderQuoteChar(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderQuoteChar\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderRead() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderRead(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderRead\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderReadAttributeValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderReadAttributeValue(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderReadAttributeValue\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderReadState() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderReadState(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderReadState\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderRelaxNGSetSchema() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut n_schema: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_schema = 0 as std::os::raw::c_int;
        while n_schema < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            schema = gen_xmlRelaxNGPtr(n_schema, 1 as std::os::raw::c_int);
            ret_val = xmlTextReaderRelaxNGSetSchema(reader, schema);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_xmlRelaxNGPtr(n_schema, schema, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderRelaxNGSetSchema\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_schema);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_schema += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderRelaxNGValidate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut rng: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_rng: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_rng = 0 as std::os::raw::c_int;
        while n_rng < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            rng = gen_const_char_ptr(n_rng, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextReaderRelaxNGValidate(reader,
                                             rng as *const std::os::raw::c_char);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_rng, rng as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderRelaxNGValidate\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_rng);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_rng += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderRelaxNGValidateCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_ctxt = 0 as std::os::raw::c_int;
        while n_ctxt < 1 as std::os::raw::c_int {
            n_options = 0 as std::os::raw::c_int;
            while n_options < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 1 as std::os::raw::c_int);
                options = gen_parseroptions(n_options, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextReaderRelaxNGValidateCtxt(reader, ctxt, options);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
                des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 1 as std::os::raw::c_int);
                des_parseroptions(n_options, options, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextReaderRelaxNGValidateCtxt\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_reader);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_options);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_options += 1
            }
            n_ctxt += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderSchemaValidate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut xsd: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_xsd: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_xsd = 0 as std::os::raw::c_int;
        while n_xsd < 4 as std::os::raw::c_int {
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            xsd = gen_const_char_ptr(n_xsd, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextReaderSchemaValidate(reader,
                                            xsd as *const std::os::raw::c_char);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_xsd, xsd as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            n_xsd += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderSchemaValidateCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_ctxt = 0 as std::os::raw::c_int;
        while n_ctxt < 1 as std::os::raw::c_int {
            n_options = 0 as std::os::raw::c_int;
            while n_options < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 1 as std::os::raw::c_int);
                options = gen_parseroptions(n_options, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextReaderSchemaValidateCtxt(reader, ctxt, options);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
                des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 1 as std::os::raw::c_int);
                des_parseroptions(n_options, options, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextReaderSchemaValidateCtxt\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_reader);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_options);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_options += 1
            }
            n_ctxt += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderSetErrorHandler() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the xmlTextReaderPtr used */
}
unsafe extern "C" fn test_xmlTextReaderSetParserProp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlParserProperties to set */
    let mut mem_base: std::os::raw::c_int = 0; /* usually 0 or 1 to (de)activate it */
    let mut ret_val: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut reader: xmlTextReaderPtr =
        0 as *mut xmlTextReader; /* a precompiled Schema schema */
    let mut n_reader: std::os::raw::c_int = 0;
    let mut prop: std::os::raw::c_int = 0;
    let mut n_prop: std::os::raw::c_int = 0;
    let mut value: std::os::raw::c_int = 0;
    let mut n_value: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_prop = 0 as std::os::raw::c_int;
        while n_prop < 4 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int;
            while n_value < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                prop = gen_int(n_prop, 1 as std::os::raw::c_int);
                value = gen_int(n_value, 2 as std::os::raw::c_int);
                ret_val = xmlTextReaderSetParserProp(reader, prop, value);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
                des_int(n_prop, prop, 1 as std::os::raw::c_int);
                des_int(n_value, value, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextReaderSetParserProp\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_reader);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_prop);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_value);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_value += 1
            }
            n_prop += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderSetSchema() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut n_schema: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_schema = 0 as std::os::raw::c_int;
        while n_schema < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
            schema = gen_xmlSchemaPtr(n_schema, 1 as std::os::raw::c_int);
            ret_val = xmlTextReaderSetSchema(reader, schema);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
            des_xmlSchemaPtr(n_schema, schema, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextReaderSetSchema\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_reader);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_schema);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_schema += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderSetStructuredErrorHandler()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* an XML reader */
}
unsafe extern "C" fn test_xmlTextReaderSetup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* xmlParserInputBufferPtr used to feed the reader, will be destroyed with it. */
    let mut mem_base: std::os::raw::c_int =
        0; /* the base URL to use for the document */
    let mut ret_val: std::os::raw::c_int = 0; /* the document encoding, or NULL */
    let mut reader: xmlTextReaderPtr =
        0 as *mut xmlTextReader; /* a combination of xmlParserOption */
    let mut n_reader: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut input: xmlParserInputBufferPtr =
        0 as *mut xmlParserInputBuffer; /* the xmlTextReaderPtr used */
    let mut n_input: std::os::raw::c_int = 0; /* the xmlTextReaderPtr used */
    let mut URL: *const std::os::raw::c_char =
        0 as *const std::os::raw::c_char; /* an expression context */
    let mut n_URL: std::os::raw::c_int = 0; /* an expression context */
    let mut encoding: *mut std::os::raw::c_char =
        0 as *mut std::os::raw::c_char; /* a buffer to receive the output */
    let mut n_encoding: std::os::raw::c_int = 0; /* the compiled expression */
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        n_input = 0 as std::os::raw::c_int;
        while n_input < 8 as std::os::raw::c_int {
            n_URL = 0 as std::os::raw::c_int;
            while n_URL < 8 as std::os::raw::c_int {
                n_encoding = 0 as std::os::raw::c_int;
                while n_encoding < 4 as std::os::raw::c_int {
                    n_options = 0 as std::os::raw::c_int;
                    while n_options < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        reader =
                            gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
                        input =
                            gen_xmlParserInputBufferPtr(n_input,
                                                        1 as std::os::raw::c_int);
                        URL = gen_filepath(n_URL, 2 as std::os::raw::c_int);
                        encoding =
                            gen_const_char_ptr(n_encoding, 3 as std::os::raw::c_int);
                        options =
                            gen_parseroptions(n_options, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlTextReaderSetup(reader, input, URL,
                                               encoding as
                                                   *const std::os::raw::c_char,
                                               options);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlTextReaderPtr(n_reader, reader,
                                             0 as std::os::raw::c_int);
                        des_filepath(n_URL, URL, 2 as std::os::raw::c_int);
                        des_const_char_ptr(n_encoding,
                                           encoding as *const std::os::raw::c_char,
                                           3 as std::os::raw::c_int);
                        des_parseroptions(n_options, options,
                                          4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlTextReaderSetup\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_reader);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_input);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_URL);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_encoding);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_options);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_options += 1
                    }
                    n_encoding += 1
                }
                n_URL += 1
            }
            n_input += 1
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderStandalone() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderStandalone(reader);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderStandalone\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderValue(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderValue\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextReaderXmlLang() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut n_reader: std::os::raw::c_int = 0;
    n_reader = 0 as std::os::raw::c_int;
    while n_reader < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0 as std::os::raw::c_int);
        ret_val = xmlTextReaderXmlLang(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlTextReaderPtr(n_reader, reader, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextReaderXmlLang\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_reader);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_reader += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlreader() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlreader : 76 of 86 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    test_ret += test_xmlNewTextReader();
    test_ret += test_xmlNewTextReaderFilename();
    test_ret += test_xmlReaderForDoc();
    test_ret += test_xmlReaderForFile();
    test_ret += test_xmlReaderForMemory();
    test_ret += test_xmlReaderNewDoc();
    test_ret += test_xmlReaderNewFile();
    test_ret += test_xmlReaderNewMemory();
    test_ret += test_xmlReaderNewWalker();
    test_ret += test_xmlReaderWalker();
    test_ret += test_xmlTextReaderAttributeCount();
    test_ret += test_xmlTextReaderBaseUri();
    test_ret += test_xmlTextReaderByteConsumed();
    test_ret += test_xmlTextReaderClose();
    test_ret += test_xmlTextReaderConstBaseUri();
    test_ret += test_xmlTextReaderConstEncoding();
    test_ret += test_xmlTextReaderConstLocalName();
    test_ret += test_xmlTextReaderConstName();
    test_ret += test_xmlTextReaderConstNamespaceUri();
    test_ret += test_xmlTextReaderConstPrefix();
    test_ret += test_xmlTextReaderConstString();
    test_ret += test_xmlTextReaderConstValue();
    test_ret += test_xmlTextReaderConstXmlLang();
    test_ret += test_xmlTextReaderConstXmlVersion();
    test_ret += test_xmlTextReaderCurrentDoc();
    test_ret += test_xmlTextReaderCurrentNode();
    test_ret += test_xmlTextReaderDepth();
    test_ret += test_xmlTextReaderExpand();
    test_ret += test_xmlTextReaderGetAttribute();
    test_ret += test_xmlTextReaderGetAttributeNo();
    test_ret += test_xmlTextReaderGetAttributeNs();
    test_ret += test_xmlTextReaderGetErrorHandler();
    test_ret += test_xmlTextReaderGetParserColumnNumber();
    test_ret += test_xmlTextReaderGetParserLineNumber();
    test_ret += test_xmlTextReaderGetParserProp();
    test_ret += test_xmlTextReaderGetRemainder();
    test_ret += test_xmlTextReaderHasAttributes();
    test_ret += test_xmlTextReaderHasValue();
    test_ret += test_xmlTextReaderIsDefault();
    test_ret += test_xmlTextReaderIsEmptyElement();
    test_ret += test_xmlTextReaderIsNamespaceDecl();
    test_ret += test_xmlTextReaderIsValid();
    test_ret += test_xmlTextReaderLocalName();
    test_ret += test_xmlTextReaderLocatorBaseURI();
    test_ret += test_xmlTextReaderLocatorLineNumber();
    test_ret += test_xmlTextReaderLookupNamespace();
    test_ret += test_xmlTextReaderMoveToAttribute();
    test_ret += test_xmlTextReaderMoveToAttributeNo();
    test_ret += test_xmlTextReaderMoveToAttributeNs();
    test_ret += test_xmlTextReaderMoveToElement();
    test_ret += test_xmlTextReaderMoveToFirstAttribute();
    test_ret += test_xmlTextReaderMoveToNextAttribute();
    test_ret += test_xmlTextReaderName();
    test_ret += test_xmlTextReaderNamespaceUri();
    test_ret += test_xmlTextReaderNext();
    test_ret += test_xmlTextReaderNextSibling();
    test_ret += test_xmlTextReaderNodeType();
    test_ret += test_xmlTextReaderNormalization();
    test_ret += test_xmlTextReaderPrefix();
    test_ret += test_xmlTextReaderPreserve();
    test_ret += test_xmlTextReaderPreservePattern();
    test_ret += test_xmlTextReaderQuoteChar();
    test_ret += test_xmlTextReaderRead();
    test_ret += test_xmlTextReaderReadAttributeValue();
    test_ret += test_xmlTextReaderReadState();
    test_ret += test_xmlTextReaderRelaxNGSetSchema();
    test_ret += test_xmlTextReaderRelaxNGValidate();
    test_ret += test_xmlTextReaderRelaxNGValidateCtxt();
    test_ret += test_xmlTextReaderSchemaValidate();
    test_ret += test_xmlTextReaderSchemaValidateCtxt();
    test_ret += test_xmlTextReaderSetErrorHandler();
    test_ret += test_xmlTextReaderSetParserProp();
    test_ret += test_xmlTextReaderSetSchema();
    test_ret += test_xmlTextReaderSetStructuredErrorHandler();
    test_ret += test_xmlTextReaderSetup();
    test_ret += test_xmlTextReaderStandalone();
    test_ret += test_xmlTextReaderValue();
    test_ret += test_xmlTextReaderXmlLang();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlreader: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlExpCtxtNbCons() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlExpCtxtPtr = 0 as *mut xmlExpCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlExpCtxtNbCons(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlExpCtxtNbCons\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlExpCtxtNbNodes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlExpCtxtPtr = 0 as *mut xmlExpCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlExpCtxtNbNodes(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlExpCtxtNbNodes\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlExpDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut expr: xmlExpNodePtr = 0 as *mut xmlExpNode;
    let mut n_expr: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_expr = 0 as std::os::raw::c_int;
        while n_expr < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            expr = gen_xmlExpNodePtr(n_expr, 1 as std::os::raw::c_int);
            xmlExpDump(buf, expr);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_xmlExpNodePtr(n_expr, expr, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlExpDump\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_expr);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_expr += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlExpExpDerive() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the expression context */
}
unsafe extern "C" fn test_xmlExpGetLanguage() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the expression */
    let mut mem_base: std::os::raw::c_int = 0; /* where to store the tokens */
    let mut ret_val: std::os::raw::c_int = 0; /* the allocated length of @list */
    let mut ctxt: xmlExpCtxtPtr =
        0 as *mut xmlExpCtxt; /* the expression context */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the expression */
    let mut exp: xmlExpNodePtr =
        0 as *mut xmlExpNode; /* where to store the tokens */
    let mut n_exp: std::os::raw::c_int = 0; /* the allocated length of @list */
    let mut langList: *mut *mut xmlChar =
        0 as *mut *mut xmlChar; /* the expression */
    let mut n_langList: std::os::raw::c_int = 0; /* a compiled expression */
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_exp = 0 as std::os::raw::c_int;
        while n_exp < 1 as std::os::raw::c_int {
            n_langList = 0 as std::os::raw::c_int;
            while n_langList < 1 as std::os::raw::c_int {
                n_len = 0 as std::os::raw::c_int;
                while n_len < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    exp = gen_xmlExpNodePtr(n_exp, 1 as std::os::raw::c_int);
                    langList =
                        gen_const_xmlChar_ptr_ptr(n_langList,
                                                  2 as std::os::raw::c_int);
                    len = gen_int(n_len, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlExpGetLanguage(ctxt, exp,
                                          langList as *mut *const xmlChar,
                                          len);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlExpCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_xmlExpNodePtr(n_exp, exp, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr_ptr(n_langList,
                                              langList as *mut *const xmlChar,
                                              2 as std::os::raw::c_int);
                    des_int(n_len, len, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlExpGetLanguage\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_exp);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_langList);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_len += 1
                }
                n_langList += 1
            }
            n_exp += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlExpGetStart() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlExpCtxtPtr = 0 as *mut xmlExpCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut exp: xmlExpNodePtr = 0 as *mut xmlExpNode;
    let mut n_exp: std::os::raw::c_int = 0;
    let mut tokList: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_tokList: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_exp = 0 as std::os::raw::c_int;
        while n_exp < 1 as std::os::raw::c_int {
            n_tokList = 0 as std::os::raw::c_int;
            while n_tokList < 1 as std::os::raw::c_int {
                n_len = 0 as std::os::raw::c_int;
                while n_len < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    exp = gen_xmlExpNodePtr(n_exp, 1 as std::os::raw::c_int);
                    tokList =
                        gen_const_xmlChar_ptr_ptr(n_tokList,
                                                  2 as std::os::raw::c_int);
                    len = gen_int(n_len, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlExpGetStart(ctxt, exp,
                                       tokList as *mut *const xmlChar, len);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlExpCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_xmlExpNodePtr(n_exp, exp, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr_ptr(n_tokList,
                                              tokList as *mut *const xmlChar,
                                              2 as std::os::raw::c_int);
                    des_int(n_len, len, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlExpGetStart\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_exp);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_tokList);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_len += 1
                }
                n_tokList += 1
            }
            n_exp += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlExpIsNillable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut exp: xmlExpNodePtr = 0 as *mut xmlExpNode;
    let mut n_exp: std::os::raw::c_int = 0;
    n_exp = 0 as std::os::raw::c_int;
    while n_exp < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        exp = gen_xmlExpNodePtr(n_exp, 0 as std::os::raw::c_int);
        ret_val = xmlExpIsNillable(exp);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlExpNodePtr(n_exp, exp, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlExpIsNillable\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_exp);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_exp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlExpMaxToken() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut expr: xmlExpNodePtr = 0 as *mut xmlExpNode;
    let mut n_expr: std::os::raw::c_int = 0;
    n_expr = 0 as std::os::raw::c_int;
    while n_expr < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        expr = gen_xmlExpNodePtr(n_expr, 0 as std::os::raw::c_int);
        ret_val = xmlExpMaxToken(expr);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlExpNodePtr(n_expr, expr, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlExpMaxToken\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_expr);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_expr += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlExpNewAtom() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlExpNewCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlExpNewOr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlExpNewRange() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlExpNewSeq() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlExpParse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the expression */
}
unsafe extern "C" fn test_xmlExpRef() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut exp: xmlExpNodePtr = 0 as *mut xmlExpNode;
    let mut n_exp: std::os::raw::c_int = 0;
    n_exp = 0 as std::os::raw::c_int;
    while n_exp < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        exp = gen_xmlExpNodePtr(n_exp, 0 as std::os::raw::c_int);
        xmlExpRef(exp);
        call_tests += 1;
        des_xmlExpNodePtr(n_exp, exp, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlExpRef\x00" as *const u8 as
                       *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_exp);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_exp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlExpStringDerive() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the expressions context */
}
unsafe extern "C" fn test_xmlExpSubsume() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the englobing expression */
    let mut mem_base: std::os::raw::c_int = 0; /* the subexpression */
    let mut ret_val: std::os::raw::c_int =
        0; /* a regexp execution context generating an error */
    let mut ctxt: xmlExpCtxtPtr =
        0 as *mut xmlExpCtxt; /* return value for the error string */
    let mut n_ctxt: std::os::raw::c_int =
        0; /* pointer to the number of accepted values IN/OUT */
    let mut exp: xmlExpNodePtr =
        0 as *mut xmlExpNode; /* return number of negative transitions */
    let mut n_exp: std::os::raw::c_int =
        0; /* pointer to the array of acceptable values */
    let mut sub: xmlExpNodePtr =
        0 as *mut xmlExpNode; /* return value if this was a terminal state */
    let mut n_sub: std::os::raw::c_int = 0; /* a regexp execution context */
    n_ctxt =
        0 as
            std::os::raw::c_int; /* pointer to the number of accepted values IN/OUT */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_exp = 0 as std::os::raw::c_int; /* return number of negative transitions */
        while n_exp < 1 as std::os::raw::c_int {
            n_sub =
                0 as
                    std::os::raw::c_int; /* pointer to the array of acceptable values */
            while n_sub < 1 as std::os::raw::c_int {
                mem_base =
                    xmlMemBlocks(); /* return value if this was a terminal state */
                ctxt =
                    gen_xmlExpCtxtPtr(n_ctxt,
                                      0 as
                                          std::os::raw::c_int); /* a regexp execution context or NULL to indicate the end */
                exp =
                    gen_xmlExpNodePtr(n_exp,
                                      1 as
                                          std::os::raw::c_int); /* a string token input */
                sub =
                    gen_xmlExpNodePtr(n_sub,
                                      2 as
                                          std::os::raw::c_int); /* data associated to the token to reuse in callbacks */
                ret_val =
                    xmlExpSubsume(ctxt, exp,
                                  sub); /* a regexp execution context or NULL to indicate the end */
                desret_int(ret_val); /* the first string token input */
                call_tests += 1; /* the second string token input */
                des_xmlExpCtxtPtr(n_ctxt, ctxt,
                                  0 as
                                      std::os::raw::c_int); /* data associated to the token to reuse in callbacks */
                des_xmlExpNodePtr(n_exp, exp, 1 as std::os::raw::c_int);
                des_xmlExpNodePtr(n_sub, sub, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlExpSubsume\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_exp);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_sub);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_sub += 1
            }
            n_exp += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlRegExecCtxtPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> xmlRegExecCtxtPtr {
    return 0 as xmlRegExecCtxtPtr;
}
unsafe extern "C" fn des_xmlRegExecCtxtPtr(mut no: std::os::raw::c_int,
                                           mut val: xmlRegExecCtxtPtr,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlRegExecErrInfo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut exec: xmlRegExecCtxtPtr = 0 as *mut xmlRegExecCtxt;
    let mut n_exec: std::os::raw::c_int = 0;
    let mut string: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_string: std::os::raw::c_int = 0;
    let mut nbval: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_nbval: std::os::raw::c_int = 0;
    let mut nbneg: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_nbneg: std::os::raw::c_int = 0;
    let mut values: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_values: std::os::raw::c_int = 0;
    let mut terminal: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_terminal: std::os::raw::c_int = 0;
    n_exec = 0 as std::os::raw::c_int;
    while n_exec < 1 as std::os::raw::c_int {
        n_string = 0 as std::os::raw::c_int;
        while n_string < 1 as std::os::raw::c_int {
            n_nbval = 0 as std::os::raw::c_int;
            while n_nbval < 2 as std::os::raw::c_int {
                n_nbneg = 0 as std::os::raw::c_int;
                while n_nbneg < 2 as std::os::raw::c_int {
                    n_values = 0 as std::os::raw::c_int;
                    while n_values < 1 as std::os::raw::c_int {
                        n_terminal = 0 as std::os::raw::c_int;
                        while n_terminal < 2 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            exec =
                                gen_xmlRegExecCtxtPtr(n_exec,
                                                      0 as std::os::raw::c_int);
                            string =
                                gen_const_xmlChar_ptr_ptr(n_string,
                                                          1 as std::os::raw::c_int);
                            nbval = gen_int_ptr(n_nbval, 2 as std::os::raw::c_int);
                            nbneg = gen_int_ptr(n_nbneg, 3 as std::os::raw::c_int);
                            values =
                                gen_xmlChar_ptr_ptr(n_values,
                                                    4 as std::os::raw::c_int);
                            terminal =
                                gen_int_ptr(n_terminal, 5 as std::os::raw::c_int);
                            ret_val =
                                xmlRegExecErrInfo(exec,
                                                  string as
                                                      *mut *const xmlChar,
                                                  nbval, nbneg, values,
                                                  terminal);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlRegExecCtxtPtr(n_exec, exec,
                                                  0 as std::os::raw::c_int);
                            des_const_xmlChar_ptr_ptr(n_string,
                                                      string as
                                                          *mut *const xmlChar,
                                                      1 as std::os::raw::c_int);
                            des_int_ptr(n_nbval, nbval, 2 as std::os::raw::c_int);
                            des_int_ptr(n_nbneg, nbneg, 3 as std::os::raw::c_int);
                            des_xmlChar_ptr_ptr(n_values, values,
                                                4 as std::os::raw::c_int);
                            des_int_ptr(n_terminal, terminal,
                                        5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlRegExecErrInfo\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_exec);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_string);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_nbval);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_nbneg);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_values);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_terminal);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_terminal += 1
                        }
                        n_values += 1
                    }
                    n_nbneg += 1
                }
                n_nbval += 1
            }
            n_string += 1
        }
        n_exec += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRegExecNextValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut exec: xmlRegExecCtxtPtr = 0 as *mut xmlRegExecCtxt;
    let mut n_exec: std::os::raw::c_int = 0;
    let mut nbval: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_nbval: std::os::raw::c_int = 0;
    let mut nbneg: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_nbneg: std::os::raw::c_int = 0;
    let mut values: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_values: std::os::raw::c_int = 0;
    let mut terminal: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_terminal: std::os::raw::c_int = 0;
    n_exec = 0 as std::os::raw::c_int;
    while n_exec < 1 as std::os::raw::c_int {
        n_nbval = 0 as std::os::raw::c_int;
        while n_nbval < 2 as std::os::raw::c_int {
            n_nbneg = 0 as std::os::raw::c_int;
            while n_nbneg < 2 as std::os::raw::c_int {
                n_values = 0 as std::os::raw::c_int;
                while n_values < 1 as std::os::raw::c_int {
                    n_terminal = 0 as std::os::raw::c_int;
                    while n_terminal < 2 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        exec =
                            gen_xmlRegExecCtxtPtr(n_exec, 0 as std::os::raw::c_int);
                        nbval = gen_int_ptr(n_nbval, 1 as std::os::raw::c_int);
                        nbneg = gen_int_ptr(n_nbneg, 2 as std::os::raw::c_int);
                        values =
                            gen_xmlChar_ptr_ptr(n_values, 3 as std::os::raw::c_int);
                        terminal = gen_int_ptr(n_terminal, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlRegExecNextValues(exec, nbval, nbneg, values,
                                                 terminal);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlRegExecCtxtPtr(n_exec, exec, 0 as std::os::raw::c_int);
                        des_int_ptr(n_nbval, nbval, 1 as std::os::raw::c_int);
                        des_int_ptr(n_nbneg, nbneg, 2 as std::os::raw::c_int);
                        des_xmlChar_ptr_ptr(n_values, values,
                                            3 as std::os::raw::c_int);
                        des_int_ptr(n_terminal, terminal, 4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlRegExecNextValues\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_exec);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_nbval);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_nbneg);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_values);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_terminal);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_terminal += 1
                    }
                    n_values += 1
                }
                n_nbneg += 1
            }
            n_nbval += 1
        }
        n_exec += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRegExecPushString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut exec: xmlRegExecCtxtPtr = 0 as *mut xmlRegExecCtxt;
    let mut n_exec: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_exec = 0 as std::os::raw::c_int;
    while n_exec < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            n_data = 0 as std::os::raw::c_int;
            while n_data < 3 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                exec = gen_xmlRegExecCtxtPtr(n_exec, 0 as std::os::raw::c_int);
                value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
                data = gen_userdata(n_data, 2 as std::os::raw::c_int);
                ret_val =
                    xmlRegExecPushString(exec, value as *const xmlChar, data);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlRegExecCtxtPtr(n_exec, exec, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_userdata(n_data, data, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlRegExecPushString\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_exec);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_value);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_data);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_data += 1
            }
            n_value += 1
        }
        n_exec += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRegExecPushString2() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut exec: xmlRegExecCtxtPtr = 0 as *mut xmlRegExecCtxt;
    let mut n_exec: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut value2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value2: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_data: std::os::raw::c_int = 0;
    n_exec = 0 as std::os::raw::c_int;
    while n_exec < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            n_value2 = 0 as std::os::raw::c_int;
            while n_value2 < 5 as std::os::raw::c_int {
                n_data = 0 as std::os::raw::c_int;
                while n_data < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    exec = gen_xmlRegExecCtxtPtr(n_exec, 0 as std::os::raw::c_int);
                    value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
                    value2 =
                        gen_const_xmlChar_ptr(n_value2, 2 as std::os::raw::c_int);
                    data = gen_userdata(n_data, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlRegExecPushString2(exec, value as *const xmlChar,
                                              value2 as *const xmlChar, data);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlRegExecCtxtPtr(n_exec, exec, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value2, value2 as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_userdata(n_data, data, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlRegExecPushString2\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_exec);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value2);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_data);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_data += 1
                }
                n_value2 += 1
            }
            n_value += 1
        }
        n_exec += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlRegexpPtr(mut no: std::os::raw::c_int,
                                      mut nr: std::os::raw::c_int) -> xmlRegexpPtr {
    return 0 as xmlRegexpPtr;
}
unsafe extern "C" fn des_xmlRegexpPtr(mut no: std::os::raw::c_int,
                                      mut val: xmlRegexpPtr,
                                      mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlRegNewExecCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlRegexpCompile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the compiled regular expression */
}
unsafe extern "C" fn test_xmlRegexpExec() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* the value to check against the regular expression */
    let mut mem_base: std::os::raw::c_int = 0; /* the compiled regular expression */
    let mut ret_val: std::os::raw::c_int = 0; /* the file for the output debug */
    let mut comp: xmlRegexpPtr =
        0 as *mut xmlRegexp; /* the compiled regexp */
    let mut n_comp: std::os::raw::c_int = 0; /* a document saving context */
    let mut content: *mut xmlChar =
        0 as *mut xmlChar; /* a document saving context */
    let mut n_content: std::os::raw::c_int = 0; /* a document */
    n_comp = 0 as std::os::raw::c_int; /* a document saving context */
    while n_comp < 1 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            comp = gen_xmlRegexpPtr(n_comp, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            ret_val = xmlRegexpExec(comp, content as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlRegexpPtr(n_comp, comp, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlRegexpExec\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_comp);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_comp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRegexpIsDeterminist() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut comp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut n_comp: std::os::raw::c_int = 0;
    n_comp = 0 as std::os::raw::c_int;
    while n_comp < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        comp = gen_xmlRegexpPtr(n_comp, 0 as std::os::raw::c_int);
        ret_val = xmlRegexpIsDeterminist(comp);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlRegexpPtr(n_comp, comp, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlRegexpIsDeterminist\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_comp);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_comp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlRegexpPrint() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut regexp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut n_regexp: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_regexp = 0 as std::os::raw::c_int;
        while n_regexp < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            regexp = gen_xmlRegexpPtr(n_regexp, 1 as std::os::raw::c_int);
            xmlRegexpPrint(output, regexp);
            call_tests += 1;
            des_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlRegexpPtr(n_regexp, regexp, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlRegexpPrint\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_regexp);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_regexp += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlregexp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlregexp : 16 of 30 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    test_ret += test_xmlExpCtxtNbCons();
    test_ret += test_xmlExpCtxtNbNodes();
    test_ret += test_xmlExpDump();
    test_ret += test_xmlExpExpDerive();
    test_ret += test_xmlExpGetLanguage();
    test_ret += test_xmlExpGetStart();
    test_ret += test_xmlExpIsNillable();
    test_ret += test_xmlExpMaxToken();
    test_ret += test_xmlExpNewAtom();
    test_ret += test_xmlExpNewCtxt();
    test_ret += test_xmlExpNewOr();
    test_ret += test_xmlExpNewRange();
    test_ret += test_xmlExpNewSeq();
    test_ret += test_xmlExpParse();
    test_ret += test_xmlExpRef();
    test_ret += test_xmlExpStringDerive();
    test_ret += test_xmlExpSubsume();
    test_ret += test_xmlRegExecErrInfo();
    test_ret += test_xmlRegExecNextValues();
    test_ret += test_xmlRegExecPushString();
    test_ret += test_xmlRegExecPushString2();
    test_ret += test_xmlRegNewExecCtxt();
    test_ret += test_xmlRegexpCompile();
    test_ret += test_xmlRegexpExec();
    test_ret += test_xmlRegexpIsDeterminist();
    test_ret += test_xmlRegexpPrint();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlregexp: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn gen_xmlSaveCtxtPtr(mut no: std::os::raw::c_int,
                                        mut nr: std::os::raw::c_int)
 -> xmlSaveCtxtPtr {
    return 0 as xmlSaveCtxtPtr;
}
unsafe extern "C" fn des_xmlSaveCtxtPtr(mut no: std::os::raw::c_int,
                                        mut val: xmlSaveCtxtPtr,
                                        mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSaveClose() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlSaveCtxtPtr = 0 as *mut xmlSaveCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlSaveClose(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSaveClose\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_long = 0;
    let mut ctxt: xmlSaveCtxtPtr = 0 as *mut xmlSaveCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            ret_val = xmlSaveDoc(ctxt, doc);
            desret_long(ret_val);
            call_tests += 1;
            des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSaveDoc\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveFlush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlSaveCtxtPtr = 0 as *mut xmlSaveCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlSaveFlush(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSaveFlush\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveSetAttrEscape() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveSetEscape() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveToBuffer() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveToFd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSaveToFilename() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a document saving context */
}
unsafe extern "C" fn test_xmlSaveTree() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the top node of the subtree to save */
    let mut mem_base: std::os::raw::c_int = 0; /* the file output */
    let mut ret_val: std::os::raw::c_long = 0; /* a schema structure */
    let mut ctxt: xmlSaveCtxtPtr =
        0 as *mut xmlSaveCtxt; /* a XMl-Schema parser context */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the error callback result */
    let mut node: xmlNodePtr =
        0 as *mut xmlNode; /* the warning callback result */
    let mut n_node: std::os::raw::c_int =
        0; /* contextual data for the callbacks result */
    n_ctxt = 0 as std::os::raw::c_int; /* a XML-Schema validation context */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int; /* the error function result */
        while n_node < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the warning function result */
            ctxt =
                gen_xmlSaveCtxtPtr(n_ctxt,
                                   0 as
                                       std::os::raw::c_int); /* the functions context result */
            node =
                gen_xmlNodePtr(n_node,
                               1 as
                                   std::os::raw::c_int); /* the schema validation context */
            ret_val = xmlSaveTree(ctxt, node); /* a preparsed document tree */
            desret_long(ret_val); /* a pointer to a char array containing the schemas */
            call_tests += 1; /* the size of the array */
            des_xmlSaveCtxtPtr(n_ctxt, ctxt,
                               0 as
                                   std::os::raw::c_int); /* the location of the schema */
            des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSaveTree\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlsave() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlsave : 4 of 10 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlSaveClose();
    test_ret += test_xmlSaveDoc();
    test_ret += test_xmlSaveFlush();
    test_ret += test_xmlSaveSetAttrEscape();
    test_ret += test_xmlSaveSetEscape();
    test_ret += test_xmlSaveToBuffer();
    test_ret += test_xmlSaveToFd();
    test_ret += test_xmlSaveToFilename();
    test_ret += test_xmlSaveTree();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlsave: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaDump() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut n_schema: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_schema = 0 as std::os::raw::c_int;
        while n_schema < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            output = gen_FILE_ptr(n_output, 0 as std::os::raw::c_int);
            schema = gen_xmlSchemaPtr(n_schema, 1 as std::os::raw::c_int);
            xmlSchemaDump(output, schema);
            call_tests += 1;
            des_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
            des_xmlSchemaPtr(n_schema, schema, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaDump\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_output);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_schema);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_schema += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlSchemaParserCtxtPtr(mut no: std::os::raw::c_int,
                                                mut nr: std::os::raw::c_int)
 -> xmlSchemaParserCtxtPtr {
    return 0 as xmlSchemaParserCtxtPtr;
}
unsafe extern "C" fn des_xmlSchemaParserCtxtPtr(mut no: std::os::raw::c_int,
                                                mut val:
                                                    xmlSchemaParserCtxtPtr,
                                                mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlSchemaValidityErrorFunc_ptr(mut no: std::os::raw::c_int,
                                                        mut nr: std::os::raw::c_int)
 -> *mut xmlSchemaValidityErrorFunc {
    return 0 as *mut xmlSchemaValidityErrorFunc;
}
unsafe extern "C" fn des_xmlSchemaValidityErrorFunc_ptr(mut no: std::os::raw::c_int,
                                                        mut val:
                                                            *mut xmlSchemaValidityErrorFunc,
                                                        mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlSchemaValidityWarningFunc_ptr(mut no: std::os::raw::c_int,
                                                          mut nr: std::os::raw::c_int)
 -> *mut xmlSchemaValidityWarningFunc {
    return 0 as *mut xmlSchemaValidityWarningFunc;
}
unsafe extern "C" fn des_xmlSchemaValidityWarningFunc_ptr(mut no: std::os::raw::c_int,
                                                          mut val:
                                                              *mut xmlSchemaValidityWarningFunc,
                                                          mut nr:
                                                              std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSchemaGetParserErrors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut err: *mut xmlSchemaValidityErrorFunc =
        0 as *mut xmlSchemaValidityErrorFunc;
    let mut n_err: std::os::raw::c_int = 0;
    let mut warn: *mut xmlSchemaValidityWarningFunc =
        0 as *mut xmlSchemaValidityWarningFunc;
    let mut n_warn: std::os::raw::c_int = 0;
    let mut ctx: *mut *mut std::os::raw::c_void = 0 as *mut *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_err = 0 as std::os::raw::c_int;
        while n_err < 1 as std::os::raw::c_int {
            n_warn = 0 as std::os::raw::c_int;
            while n_warn < 1 as std::os::raw::c_int {
                n_ctx = 0 as std::os::raw::c_int;
                while n_ctx < 1 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt =
                        gen_xmlSchemaParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    err =
                        gen_xmlSchemaValidityErrorFunc_ptr(n_err,
                                                           1 as std::os::raw::c_int);
                    warn =
                        gen_xmlSchemaValidityWarningFunc_ptr(n_warn,
                                                             2 as
                                                                 std::os::raw::c_int);
                    ctx = gen_void_ptr_ptr(n_ctx, 3 as std::os::raw::c_int);
                    ret_val = xmlSchemaGetParserErrors(ctxt, err, warn, ctx);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlSchemaParserCtxtPtr(n_ctxt, ctxt,
                                               0 as std::os::raw::c_int);
                    des_xmlSchemaValidityErrorFunc_ptr(n_err, err,
                                                       1 as std::os::raw::c_int);
                    des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn,
                                                         2 as std::os::raw::c_int);
                    des_void_ptr_ptr(n_ctx, ctx, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSchemaGetParserErrors\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_err);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_warn);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_ctx += 1
                }
                n_warn += 1
            }
            n_err += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaGetValidErrors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut err: *mut xmlSchemaValidityErrorFunc =
        0 as *mut xmlSchemaValidityErrorFunc;
    let mut n_err: std::os::raw::c_int = 0;
    let mut warn: *mut xmlSchemaValidityWarningFunc =
        0 as *mut xmlSchemaValidityWarningFunc;
    let mut n_warn: std::os::raw::c_int = 0;
    let mut ctx: *mut *mut std::os::raw::c_void = 0 as *mut *mut std::os::raw::c_void;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_err = 0 as std::os::raw::c_int;
        while n_err < 1 as std::os::raw::c_int {
            n_warn = 0 as std::os::raw::c_int;
            while n_warn < 1 as std::os::raw::c_int {
                n_ctx = 0 as std::os::raw::c_int;
                while n_ctx < 1 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt =
                        gen_xmlSchemaValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                    err =
                        gen_xmlSchemaValidityErrorFunc_ptr(n_err,
                                                           1 as std::os::raw::c_int);
                    warn =
                        gen_xmlSchemaValidityWarningFunc_ptr(n_warn,
                                                             2 as
                                                                 std::os::raw::c_int);
                    ctx = gen_void_ptr_ptr(n_ctx, 3 as std::os::raw::c_int);
                    ret_val = xmlSchemaGetValidErrors(ctxt, err, warn, ctx);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_xmlSchemaValidityErrorFunc_ptr(n_err, err,
                                                       1 as std::os::raw::c_int);
                    des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn,
                                                         2 as std::os::raw::c_int);
                    des_void_ptr_ptr(n_ctx, ctx, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSchemaGetValidErrors\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_err);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_warn);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctx);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_ctx += 1
                }
                n_warn += 1
            }
            n_err += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaIsValid() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaIsValid(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaIsValid\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaNewDocParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaNewDocParserCtxt(doc);
        desret_xmlSchemaParserCtxtPtr(ret_val);
        call_tests += 1;
        des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaNewDocParserCtxt\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaNewMemParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_buffer: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut n_size: std::os::raw::c_int = 0;
    n_buffer = 0 as std::os::raw::c_int;
    while n_buffer < 4 as std::os::raw::c_int {
        n_size = 0 as std::os::raw::c_int;
        while n_size < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buffer = gen_const_char_ptr(n_buffer, 0 as std::os::raw::c_int);
            size = gen_int(n_size, 1 as std::os::raw::c_int);
            if !(!buffer.is_null() &&
                     size >
                         strlen(buffer as *const std::os::raw::c_char) as std::os::raw::c_int
                             + 1 as std::os::raw::c_int) {
                ret_val =
                    xmlSchemaNewMemParserCtxt(buffer as *const std::os::raw::c_char,
                                              size);
                desret_xmlSchemaParserCtxtPtr(ret_val);
                call_tests += 1;
                des_const_char_ptr(n_buffer, buffer as *const std::os::raw::c_char,
                                   0 as std::os::raw::c_int);
                des_int(n_size, size, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSchemaNewMemParserCtxt\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_buffer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_size);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_size += 1
        }
        n_buffer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaNewParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_URL: std::os::raw::c_int = 0;
    n_URL = 0 as std::os::raw::c_int;
    while n_URL < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        URL = gen_const_char_ptr(n_URL, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaNewParserCtxt(URL as *const std::os::raw::c_char);
        desret_xmlSchemaParserCtxtPtr(ret_val);
        call_tests += 1;
        des_const_char_ptr(n_URL, URL as *const std::os::raw::c_char,
                           0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaNewParserCtxt\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_URL);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_URL += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaNewValidCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaParse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaSAXPlug() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a data structure returned by xmlSchemaSAXPlug */
}
unsafe extern "C" fn gen_xmlSchemaSAXPlugPtr(mut no: std::os::raw::c_int,
                                             mut nr: std::os::raw::c_int)
 -> xmlSchemaSAXPlugPtr {
    return 0 as xmlSchemaSAXPlugPtr;
}
unsafe extern "C" fn des_xmlSchemaSAXPlugPtr(mut no: std::os::raw::c_int,
                                             mut val: xmlSchemaSAXPlugPtr,
                                             mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSchemaSAXUnplug() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut plug: xmlSchemaSAXPlugPtr = 0 as *mut xmlSchemaSAXPlugStruct;
    let mut n_plug: std::os::raw::c_int = 0;
    n_plug = 0 as std::os::raw::c_int;
    while n_plug < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        plug = gen_xmlSchemaSAXPlugPtr(n_plug, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaSAXUnplug(plug);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlSchemaSAXPlugPtr(n_plug, plug, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaSAXUnplug\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_plug);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_plug += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaSetParserErrors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaSetParserStructuredErrors()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaSetValidErrors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a schema validation context */
}
unsafe extern "C" fn test_xmlSchemaSetValidOptions() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* a combination of xmlSchemaValidOption */
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_options = 0 as std::os::raw::c_int;
        while n_options < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            options = gen_int(n_options, 1 as std::os::raw::c_int);
            ret_val = xmlSchemaSetValidOptions(ctxt, options);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_options, options, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaSetValidOptions\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_options);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_options += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaSetValidStructuredErrors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a schema validation context */
}
unsafe extern "C" fn test_xmlSchemaValidCtxtGetOptions() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* a schema validation context */
    let mut mem_base: std::os::raw::c_int = 0; /* a schema validation context */
    let mut ret_val: std::os::raw::c_int = 0; /* a parsed document tree */
    let mut ctxt: xmlSchemaValidCtxtPtr =
        0 as *mut xmlSchemaValidCtxt; /* a schema validation context */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the URI of the instance */
    n_ctxt = 0 as std::os::raw::c_int; /* a future set of options, currently unused */
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* a schema validation context */
        ctxt =
            gen_xmlSchemaValidCtxtPtr(n_ctxt,
                                      0 as std::os::raw::c_int); /* an element node */
        ret_val =
            xmlSchemaValidCtxtGetOptions(ctxt); /* the schema validation context */
        desret_int(ret_val); /* the file name */
        call_tests += 1;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaValidCtxtGetOptions\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidCtxtGetParserCtxt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaValidCtxtGetParserCtxt(ctxt);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests += 1;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaValidCtxtGetParserCtxt\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateDoc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_doc = 0 as std::os::raw::c_int;
        while n_doc < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            doc = gen_xmlDocPtr(n_doc, 1 as std::os::raw::c_int);
            ret_val = xmlSchemaValidateDoc(ctxt, doc);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlDocPtr(n_doc, doc, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaValidateDoc\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_doc += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateFile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 8 as std::os::raw::c_int {
            n_options = 0 as std::os::raw::c_int;
            while n_options < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
                filename = gen_filepath(n_filename, 1 as std::os::raw::c_int);
                options = gen_int(n_options, 2 as std::os::raw::c_int);
                ret_val = xmlSchemaValidateFile(ctxt, filename, options);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_filepath(n_filename, filename, 1 as std::os::raw::c_int);
                des_int(n_options, options, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSchemaValidateFile\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_filename);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_options);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_options += 1
            }
            n_filename += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateOneElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_elem: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_elem = 0 as std::os::raw::c_int;
        while n_elem < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            elem = gen_xmlNodePtr(n_elem, 1 as std::os::raw::c_int);
            ret_val = xmlSchemaValidateOneElement(ctxt, elem);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_elem, elem, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaValidateOneElement\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_elem);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_elem += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateSetFilename() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut vctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut n_vctxt: std::os::raw::c_int = 0;
    let mut filename: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_filename: std::os::raw::c_int = 0;
    n_vctxt = 0 as std::os::raw::c_int;
    while n_vctxt < 1 as std::os::raw::c_int {
        n_filename = 0 as std::os::raw::c_int;
        while n_filename < 8 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            vctxt = gen_xmlSchemaValidCtxtPtr(n_vctxt, 0 as std::os::raw::c_int);
            filename = gen_filepath(n_filename, 1 as std::os::raw::c_int);
            xmlSchemaValidateSetFilename(vctxt, filename);
            call_tests += 1;
            des_xmlSchemaValidCtxtPtr(n_vctxt, vctxt, 0 as std::os::raw::c_int);
            des_filepath(n_filename, filename, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaValidateSetFilename\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_vctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_filename);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_filename += 1
        }
        n_vctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateSetLocator() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a schema validation context */
}
unsafe extern "C" fn test_xmlSchemaValidateStream() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the input to use for reading the data */
    let mut mem_base: std::os::raw::c_int = 0; /* an optional encoding information */
    let mut ret_val: std::os::raw::c_int =
        0; /* a SAX handler for the resulting events */
    let mut ctxt: xmlSchemaValidCtxtPtr =
        0 as
            *mut xmlSchemaValidCtxt; /* the context to provide to the SAX handler. */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the facet */
    let mut input: xmlParserInputBufferPtr =
        0 as *mut xmlParserInputBuffer; /* the schema type definition */
    let mut n_input: std::os::raw::c_int = 0; /* the schema parser context or NULL */
    let mut enc: xmlCharEncoding =
        XML_CHAR_ENCODING_NONE; /* the optional name of the type */
    let mut n_enc: std::os::raw::c_int = 0; /* a value */
    let mut sax: xmlSAXHandlerPtr =
        0 as *mut xmlSAXHandler; /* a first value */
    let mut n_sax: std::os::raw::c_int = 0; /* a second value */
    let mut user_data: *mut std::os::raw::c_void =
        0 as *mut std::os::raw::c_void; /* a first value */
    let mut n_user_data: std::os::raw::c_int = 0; /* the whitespace value of x */
    n_ctxt = 0 as std::os::raw::c_int; /* a second value */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_input = 0 as std::os::raw::c_int; /* the whitespace value of y */
        while n_input < 8 as std::os::raw::c_int {
            n_enc = 0 as std::os::raw::c_int;
            while n_enc < 4 as std::os::raw::c_int {
                n_sax = 0 as std::os::raw::c_int;
                while n_sax < 2 as std::os::raw::c_int {
                    n_user_data = 0 as std::os::raw::c_int;
                    while n_user_data < 3 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        ctxt =
                            gen_xmlSchemaValidCtxtPtr(n_ctxt,
                                                      0 as std::os::raw::c_int);
                        input =
                            gen_xmlParserInputBufferPtr(n_input,
                                                        1 as std::os::raw::c_int);
                        enc = gen_xmlCharEncoding(n_enc, 2 as std::os::raw::c_int);
                        sax = gen_xmlSAXHandlerPtr(n_sax, 3 as std::os::raw::c_int);
                        user_data =
                            gen_userdata(n_user_data, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlSchemaValidateStream(ctxt, input, enc, sax,
                                                    user_data);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt,
                                                  0 as std::os::raw::c_int);
                        des_xmlParserInputBufferPtr(n_input, input,
                                                    1 as std::os::raw::c_int);
                        des_xmlCharEncoding(n_enc, enc, 2 as std::os::raw::c_int);
                        des_xmlSAXHandlerPtr(n_sax, sax, 3 as std::os::raw::c_int);
                        des_userdata(n_user_data, user_data,
                                     4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlSchemaValidateStream\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_ctxt);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_input);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_enc);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_sax);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_user_data);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_user_data += 1
                    }
                    n_sax += 1
                }
                n_enc += 1
            }
            n_input += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlschemas() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlschemas : 16 of 27 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    test_ret += test_xmlSchemaDump();
    test_ret += test_xmlSchemaGetParserErrors();
    test_ret += test_xmlSchemaGetValidErrors();
    test_ret += test_xmlSchemaIsValid();
    test_ret += test_xmlSchemaNewDocParserCtxt();
    test_ret += test_xmlSchemaNewMemParserCtxt();
    test_ret += test_xmlSchemaNewParserCtxt();
    test_ret += test_xmlSchemaNewValidCtxt();
    test_ret += test_xmlSchemaParse();
    test_ret += test_xmlSchemaSAXPlug();
    test_ret += test_xmlSchemaSAXUnplug();
    test_ret += test_xmlSchemaSetParserErrors();
    test_ret += test_xmlSchemaSetParserStructuredErrors();
    test_ret += test_xmlSchemaSetValidErrors();
    test_ret += test_xmlSchemaSetValidOptions();
    test_ret += test_xmlSchemaSetValidStructuredErrors();
    test_ret += test_xmlSchemaValidCtxtGetOptions();
    test_ret += test_xmlSchemaValidCtxtGetParserCtxt();
    test_ret += test_xmlSchemaValidateDoc();
    test_ret += test_xmlSchemaValidateFile();
    test_ret += test_xmlSchemaValidateOneElement();
    test_ret += test_xmlSchemaValidateSetFilename();
    test_ret += test_xmlSchemaValidateSetLocator();
    test_ret += test_xmlSchemaValidateStream();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlschemas: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn gen_xmlSchemaFacetPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> xmlSchemaFacetPtr {
    return 0 as xmlSchemaFacetPtr;
}
unsafe extern "C" fn des_xmlSchemaFacetPtr(mut no: std::os::raw::c_int,
                                           mut val: xmlSchemaFacetPtr,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlSchemaTypePtr(mut no: std::os::raw::c_int,
                                          mut nr: std::os::raw::c_int)
 -> xmlSchemaTypePtr {
    return 0 as xmlSchemaTypePtr;
}
unsafe extern "C" fn des_xmlSchemaTypePtr(mut no: std::os::raw::c_int,
                                          mut val: xmlSchemaTypePtr,
                                          mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSchemaCheckFacet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut n_facet: std::os::raw::c_int = 0;
    let mut typeDecl: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut n_typeDecl: std::os::raw::c_int = 0;
    let mut pctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut n_pctxt: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_facet = 0 as std::os::raw::c_int;
    while n_facet < 1 as std::os::raw::c_int {
        n_typeDecl = 0 as std::os::raw::c_int;
        while n_typeDecl < 1 as std::os::raw::c_int {
            n_pctxt = 0 as std::os::raw::c_int;
            while n_pctxt < 1 as std::os::raw::c_int {
                n_name = 0 as std::os::raw::c_int;
                while n_name < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    facet = gen_xmlSchemaFacetPtr(n_facet, 0 as std::os::raw::c_int);
                    typeDecl =
                        gen_xmlSchemaTypePtr(n_typeDecl, 1 as std::os::raw::c_int);
                    pctxt =
                        gen_xmlSchemaParserCtxtPtr(n_pctxt, 2 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlSchemaCheckFacet(facet, typeDecl, pctxt,
                                            name as *const xmlChar);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlSchemaFacetPtr(n_facet, facet, 0 as std::os::raw::c_int);
                    des_xmlSchemaTypePtr(n_typeDecl, typeDecl,
                                         1 as std::os::raw::c_int);
                    des_xmlSchemaParserCtxtPtr(n_pctxt, pctxt,
                                               2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSchemaCheckFacet\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_facet);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_typeDecl);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_pctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_name += 1
                }
                n_pctxt += 1
            }
            n_typeDecl += 1
        }
        n_facet += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaCleanupTypes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    xmlSchemaCleanupTypes();
    call_tests += 1;
    xmlResetLastError();
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaCollapseString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    n_value = 0 as std::os::raw::c_int;
    while n_value < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaCollapseString(value as *const xmlChar);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaCollapseString\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_value);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlSchemaValPtr(mut no: std::os::raw::c_int,
                                         mut nr: std::os::raw::c_int)
 -> xmlSchemaValPtr {
    return 0 as xmlSchemaValPtr;
}
unsafe extern "C" fn des_xmlSchemaValPtr(mut no: std::os::raw::c_int,
                                         mut val: xmlSchemaValPtr,
                                         mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSchemaCompareValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut x: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_x: std::os::raw::c_int = 0;
    let mut y: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_y: std::os::raw::c_int = 0;
    n_x = 0 as std::os::raw::c_int;
    while n_x < 1 as std::os::raw::c_int {
        n_y = 0 as std::os::raw::c_int;
        while n_y < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            x = gen_xmlSchemaValPtr(n_x, 0 as std::os::raw::c_int);
            y = gen_xmlSchemaValPtr(n_y, 1 as std::os::raw::c_int);
            ret_val = xmlSchemaCompareValues(x, y);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlSchemaValPtr(n_x, x, 0 as std::os::raw::c_int);
            des_xmlSchemaValPtr(n_y, y, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaCompareValues\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_x);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_y);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_y += 1
        }
        n_x += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaCompareValuesWhtsp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut x: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_x: std::os::raw::c_int = 0;
    let mut xws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut n_xws: std::os::raw::c_int = 0;
    let mut y: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_y: std::os::raw::c_int = 0;
    let mut yws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut n_yws: std::os::raw::c_int = 0;
    n_x = 0 as std::os::raw::c_int;
    while n_x < 1 as std::os::raw::c_int {
        n_xws = 0 as std::os::raw::c_int;
        while n_xws < 4 as std::os::raw::c_int {
            n_y = 0 as std::os::raw::c_int;
            while n_y < 1 as std::os::raw::c_int {
                n_yws = 0 as std::os::raw::c_int;
                while n_yws < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    x = gen_xmlSchemaValPtr(n_x, 0 as std::os::raw::c_int);
                    xws =
                        gen_xmlSchemaWhitespaceValueType(n_xws,
                                                         1 as std::os::raw::c_int);
                    y = gen_xmlSchemaValPtr(n_y, 2 as std::os::raw::c_int);
                    yws =
                        gen_xmlSchemaWhitespaceValueType(n_yws,
                                                         3 as std::os::raw::c_int);
                    ret_val = xmlSchemaCompareValuesWhtsp(x, xws, y, yws);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlSchemaValPtr(n_x, x, 0 as std::os::raw::c_int);
                    des_xmlSchemaWhitespaceValueType(n_xws, xws,
                                                     1 as std::os::raw::c_int);
                    des_xmlSchemaValPtr(n_y, y, 2 as std::os::raw::c_int);
                    des_xmlSchemaWhitespaceValueType(n_yws, yws,
                                                     3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSchemaCompareValuesWhtsp\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_x);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_xws);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_y);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_yws);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_yws += 1
                }
                n_y += 1
            }
            n_xws += 1
        }
        n_x += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaCopyValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the built-in simple type. */
}
unsafe extern "C" fn test_xmlSchemaGetBuiltInListSimpleTypeItemType()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the type of the built in type */
    let mut mem_base: std::os::raw::c_int = 0; /* the precomputed value */
    let mut ret_val: xmlSchemaTypePtr =
        0 as *mut xmlSchemaType; /* the returned value */
    let mut type_0: xmlSchemaTypePtr =
        0 as *mut xmlSchemaType; /* the precomputed value */
    let mut n_type: std::os::raw::c_int = 0; /* the returned value */
    n_type = 0 as std::os::raw::c_int; /* the whitespace type of the value */
    while n_type < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* an schemas type facet */
        type_0 =
            gen_xmlSchemaTypePtr(n_type,
                                 0 as std::os::raw::c_int); /* the type name */
        ret_val =
            xmlSchemaGetBuiltInListSimpleTypeItemType(type_0); /* the URI of the namespace usually "http://www.w3.org/2001/XMLSchema" */
        desret_xmlSchemaTypePtr(ret_val); /* a schemas value */
        call_tests += 1; /* the built-in type */
        des_xmlSchemaTypePtr(n_type, type_0,
                             0 as std::os::raw::c_int); /* the facet type */
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaGetBuiltInListSimpleTypeItemType\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_type);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_type += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaGetBuiltInType() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret_val: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut type_0: xmlSchemaValType = XML_SCHEMAS_UNKNOWN;
    let mut n_type: std::os::raw::c_int = 0;
    n_type = 0 as std::os::raw::c_int;
    while n_type < 4 as std::os::raw::c_int {
        type_0 = gen_xmlSchemaValType(n_type, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaGetBuiltInType(type_0);
        desret_xmlSchemaTypePtr(ret_val);
        call_tests += 1;
        des_xmlSchemaValType(n_type, type_0, 0 as std::os::raw::c_int);
        xmlResetLastError();
        n_type += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaGetCanonValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_val: std::os::raw::c_int = 0;
    let mut retValue: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_retValue: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 1 as std::os::raw::c_int {
        n_retValue = 0 as std::os::raw::c_int;
        while n_retValue < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            val = gen_xmlSchemaValPtr(n_val, 0 as std::os::raw::c_int);
            retValue =
                gen_const_xmlChar_ptr_ptr(n_retValue, 1 as std::os::raw::c_int);
            ret_val =
                xmlSchemaGetCanonValue(val, retValue as *mut *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlSchemaValPtr(n_val, val, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr_ptr(n_retValue,
                                      retValue as *mut *const xmlChar,
                                      1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaGetCanonValue\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_retValue);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_retValue += 1
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaGetCanonValueWhtsp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_val: std::os::raw::c_int = 0;
    let mut retValue: *mut *mut xmlChar = 0 as *mut *mut xmlChar;
    let mut n_retValue: std::os::raw::c_int = 0;
    let mut ws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut n_ws: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 1 as std::os::raw::c_int {
        n_retValue = 0 as std::os::raw::c_int;
        while n_retValue < 1 as std::os::raw::c_int {
            n_ws = 0 as std::os::raw::c_int;
            while n_ws < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                val = gen_xmlSchemaValPtr(n_val, 0 as std::os::raw::c_int);
                retValue =
                    gen_const_xmlChar_ptr_ptr(n_retValue, 1 as std::os::raw::c_int);
                ws = gen_xmlSchemaWhitespaceValueType(n_ws, 2 as std::os::raw::c_int);
                ret_val =
                    xmlSchemaGetCanonValueWhtsp(val,
                                                retValue as
                                                    *mut *const xmlChar, ws);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlSchemaValPtr(n_val, val, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr_ptr(n_retValue,
                                          retValue as *mut *const xmlChar,
                                          1 as std::os::raw::c_int);
                des_xmlSchemaWhitespaceValueType(n_ws, ws, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSchemaGetCanonValueWhtsp\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_val);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_retValue);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ws);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_ws += 1
            }
            n_retValue += 1
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaGetFacetValueAsULong() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_ulong = 0;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut n_facet: std::os::raw::c_int = 0;
    n_facet = 0 as std::os::raw::c_int;
    while n_facet < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        facet = gen_xmlSchemaFacetPtr(n_facet, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaGetFacetValueAsULong(facet);
        desret_unsigned_long(ret_val);
        call_tests += 1;
        des_xmlSchemaFacetPtr(n_facet, facet, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaGetFacetValueAsULong\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_facet);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_facet += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaGetPredefinedType() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ns: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ns: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        n_ns = 0 as std::os::raw::c_int;
        while n_ns < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
            ns = gen_const_xmlChar_ptr(n_ns, 1 as std::os::raw::c_int);
            ret_val =
                xmlSchemaGetPredefinedType(name as *const xmlChar,
                                           ns as *const xmlChar);
            desret_xmlSchemaTypePtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_ns, ns as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaGetPredefinedType\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ns);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ns += 1
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaGetValType() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlSchemaValType = XML_SCHEMAS_UNKNOWN;
    let mut val: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlSchemaValPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaGetValType(val);
        desret_xmlSchemaValType(ret_val);
        call_tests += 1;
        des_xmlSchemaValPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaGetValType\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaInitTypes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    xmlSchemaInitTypes();
    call_tests += 1;
    xmlResetLastError();
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaIsBuiltInTypeFacet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut n_type: std::os::raw::c_int = 0;
    let mut facetType: std::os::raw::c_int = 0;
    let mut n_facetType: std::os::raw::c_int = 0;
    n_type = 0 as std::os::raw::c_int;
    while n_type < 1 as std::os::raw::c_int {
        n_facetType = 0 as std::os::raw::c_int;
        while n_facetType < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            type_0 = gen_xmlSchemaTypePtr(n_type, 0 as std::os::raw::c_int);
            facetType = gen_int(n_facetType, 1 as std::os::raw::c_int);
            ret_val = xmlSchemaIsBuiltInTypeFacet(type_0, facetType);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlSchemaTypePtr(n_type, type_0, 0 as std::os::raw::c_int);
            des_int(n_facetType, facetType, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaIsBuiltInTypeFacet\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_type);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_facetType);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_facetType += 1
        }
        n_type += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaNewFacet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaNewNOTATIONValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaNewQNameValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaNewStringValue() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the predefined type */
}
unsafe extern "C" fn gen_xmlSchemaValPtr_ptr(mut no: std::os::raw::c_int,
                                             mut nr: std::os::raw::c_int)
 -> *mut xmlSchemaValPtr {
    return 0 as *mut xmlSchemaValPtr; /* the value to check */
}
unsafe extern "C" fn des_xmlSchemaValPtr_ptr(mut no: std::os::raw::c_int,
                                             mut val: *mut xmlSchemaValPtr,
                                             mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlSchemaValPredefTypeNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the return computed value */
    let mut mem_base: std::os::raw::c_int = 0; /* the node containing the value */
    let mut ret_val: std::os::raw::c_int = 0; /* the predefined type */
    let mut type_0: xmlSchemaTypePtr =
        0 as *mut xmlSchemaType; /* the value to check */
    let mut n_type: std::os::raw::c_int = 0; /* the return computed value */
    let mut value: *mut xmlChar =
        0 as *mut xmlChar; /* the node containing the value */
    let mut n_value: std::os::raw::c_int = 0; /* the base type */
    let mut val: *mut xmlSchemaValPtr =
        0 as *mut xmlSchemaValPtr; /* the facet to check */
    let mut n_val: std::os::raw::c_int =
        0; /* the lexical repr of the value to validate */
    let mut node: xmlNodePtr = 0 as *mut xmlNode; /* the precomputed value */
    let mut n_node: std::os::raw::c_int = 0; /* the facet to check */
    n_type = 0 as std::os::raw::c_int; /* the whitespace type of the facet's value */
    while n_type < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int; /* the built-in type of the value */
        while n_value < 5 as std::os::raw::c_int {
            n_val =
                0 as
                    std::os::raw::c_int; /* the lexical (or normalized for pattern) repr of the value to validate */
            while n_val < 1 as std::os::raw::c_int {
                n_node = 0 as std::os::raw::c_int; /* the precomputed value */
                while n_node < 3 as std::os::raw::c_int {
                    mem_base =
                        xmlMemBlocks(); /* the whitespace type of the value */
                    type_0 =
                        gen_xmlSchemaTypePtr(n_type,
                                             0 as
                                                 std::os::raw::c_int); /* the built-in type */
                    value =
                        gen_const_xmlChar_ptr(n_value,
                                              1 as
                                                  std::os::raw::c_int); /* the facet to check */
                    val =
                        gen_xmlSchemaValPtr_ptr(n_val,
                                                2 as
                                                    std::os::raw::c_int); /* the lexical repr. of the value to be validated */
                    node =
                        gen_xmlNodePtr(n_node,
                                       3 as
                                           std::os::raw::c_int); /* the precomputed value */
                    ret_val =
                        xmlSchemaValPredefTypeNode(type_0,
                                                   value as *const xmlChar,
                                                   val,
                                                   node); /* the actual length of the value */
                    desret_int(ret_val); /* the facet to check */
                    call_tests += 1; /* the built-in type */
                    des_xmlSchemaTypePtr(n_type, type_0,
                                         0 as
                                             std::os::raw::c_int); /* the lexical repr. of the value to be validated */
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          1 as
                                              std::os::raw::c_int); /* the precomputed value */
                    des_xmlSchemaValPtr_ptr(n_val, val,
                                            2 as
                                                std::os::raw::c_int); /* the actual length of the value */
                    des_xmlNodePtr(n_node, node,
                                   3 as
                                       std::os::raw::c_int); /* the whitespace type of the value */
                    xmlResetLastError(); /* the facet to check */
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSchemaValPredefTypeNode\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() -
                                   mem_base); /* the lexical repr of the value to validate */
                        test_ret += 1; /* the number of list items */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_type); /* the resulting expected number of list items */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value); /* the predefined type */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_val); /* the value to check */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node); /* the return computed value */
                        printf(b"\n\x00" as *const u8 as
                                   *const std::os::raw::c_char); /* the value */
                    } /* the value to be appended */
                    n_node += 1
                } /* the value */
                n_val += 1
            } /* the value */
            n_value += 1
        }
        n_type += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValPredefTypeNodeNoNorm() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut n_type: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut val: *mut xmlSchemaValPtr = 0 as *mut xmlSchemaValPtr;
    let mut n_val: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_type = 0 as std::os::raw::c_int;
    while n_type < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            n_val = 0 as std::os::raw::c_int;
            while n_val < 1 as std::os::raw::c_int {
                n_node = 0 as std::os::raw::c_int;
                while n_node < 3 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    type_0 = gen_xmlSchemaTypePtr(n_type, 0 as std::os::raw::c_int);
                    value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
                    val = gen_xmlSchemaValPtr_ptr(n_val, 2 as std::os::raw::c_int);
                    node = gen_xmlNodePtr(n_node, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlSchemaValPredefTypeNodeNoNorm(type_0,
                                                         value as
                                                             *const xmlChar,
                                                         val, node);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlSchemaTypePtr(n_type, type_0, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_xmlSchemaValPtr_ptr(n_val, val, 2 as std::os::raw::c_int);
                    des_xmlNodePtr(n_node, node, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSchemaValPredefTypeNodeNoNorm\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_type);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_val);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_node);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_node += 1
                }
                n_val += 1
            }
            n_value += 1
        }
        n_type += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateFacet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut n_base: std::os::raw::c_int = 0;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut n_facet: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut val: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_val: std::os::raw::c_int = 0;
    n_base = 0 as std::os::raw::c_int;
    while n_base < 1 as std::os::raw::c_int {
        n_facet = 0 as std::os::raw::c_int;
        while n_facet < 1 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int;
            while n_value < 5 as std::os::raw::c_int {
                n_val = 0 as std::os::raw::c_int;
                while n_val < 1 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    base = gen_xmlSchemaTypePtr(n_base, 0 as std::os::raw::c_int);
                    facet = gen_xmlSchemaFacetPtr(n_facet, 1 as std::os::raw::c_int);
                    value = gen_const_xmlChar_ptr(n_value, 2 as std::os::raw::c_int);
                    val = gen_xmlSchemaValPtr(n_val, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlSchemaValidateFacet(base, facet,
                                               value as *const xmlChar, val);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlSchemaTypePtr(n_base, base, 0 as std::os::raw::c_int);
                    des_xmlSchemaFacetPtr(n_facet, facet, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_xmlSchemaValPtr(n_val, val, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSchemaValidateFacet\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_base);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_facet);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_val);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_val += 1
                }
                n_value += 1
            }
            n_facet += 1
        }
        n_base += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateFacetWhtsp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut n_facet: std::os::raw::c_int = 0;
    let mut fws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut n_fws: std::os::raw::c_int = 0;
    let mut valType: xmlSchemaValType = XML_SCHEMAS_UNKNOWN;
    let mut n_valType: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut val: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_val: std::os::raw::c_int = 0;
    let mut ws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut n_ws: std::os::raw::c_int = 0;
    n_facet = 0 as std::os::raw::c_int;
    while n_facet < 1 as std::os::raw::c_int {
        n_fws = 0 as std::os::raw::c_int;
        while n_fws < 4 as std::os::raw::c_int {
            n_valType = 0 as std::os::raw::c_int;
            while n_valType < 4 as std::os::raw::c_int {
                n_value = 0 as std::os::raw::c_int;
                while n_value < 5 as std::os::raw::c_int {
                    n_val = 0 as std::os::raw::c_int;
                    while n_val < 1 as std::os::raw::c_int {
                        n_ws = 0 as std::os::raw::c_int;
                        while n_ws < 4 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            facet =
                                gen_xmlSchemaFacetPtr(n_facet,
                                                      0 as std::os::raw::c_int);
                            fws =
                                gen_xmlSchemaWhitespaceValueType(n_fws,
                                                                 1 as
                                                                     std::os::raw::c_int);
                            valType =
                                gen_xmlSchemaValType(n_valType,
                                                     2 as std::os::raw::c_int);
                            value =
                                gen_const_xmlChar_ptr(n_value,
                                                      3 as std::os::raw::c_int);
                            val =
                                gen_xmlSchemaValPtr(n_val, 4 as std::os::raw::c_int);
                            ws =
                                gen_xmlSchemaWhitespaceValueType(n_ws,
                                                                 5 as
                                                                     std::os::raw::c_int);
                            ret_val =
                                xmlSchemaValidateFacetWhtsp(facet, fws,
                                                            valType,
                                                            value as
                                                                *const xmlChar,
                                                            val, ws);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlSchemaFacetPtr(n_facet, facet,
                                                  0 as std::os::raw::c_int);
                            des_xmlSchemaWhitespaceValueType(n_fws, fws,
                                                             1 as
                                                                 std::os::raw::c_int);
                            des_xmlSchemaValType(n_valType, valType,
                                                 2 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_value,
                                                  value as *const xmlChar,
                                                  3 as std::os::raw::c_int);
                            des_xmlSchemaValPtr(n_val, val, 4 as std::os::raw::c_int);
                            des_xmlSchemaWhitespaceValueType(n_ws, ws,
                                                             5 as
                                                                 std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlSchemaValidateFacetWhtsp\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_facet);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_fws);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_valType);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_value);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_val);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ws);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_ws += 1
                        }
                        n_val += 1
                    }
                    n_value += 1
                }
                n_valType += 1
            }
            n_fws += 1
        }
        n_facet += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateLengthFacet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut n_type: std::os::raw::c_int = 0;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut n_facet: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut val: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_val: std::os::raw::c_int = 0;
    let mut length: *mut std::os::raw::c_ulong = 0 as *mut std::os::raw::c_ulong;
    let mut n_length: std::os::raw::c_int = 0;
    n_type = 0 as std::os::raw::c_int;
    while n_type < 1 as std::os::raw::c_int {
        n_facet = 0 as std::os::raw::c_int;
        while n_facet < 1 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int;
            while n_value < 5 as std::os::raw::c_int {
                n_val = 0 as std::os::raw::c_int;
                while n_val < 1 as std::os::raw::c_int {
                    n_length = 0 as std::os::raw::c_int;
                    while n_length < 2 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        type_0 =
                            gen_xmlSchemaTypePtr(n_type, 0 as std::os::raw::c_int);
                        facet =
                            gen_xmlSchemaFacetPtr(n_facet, 1 as std::os::raw::c_int);
                        value =
                            gen_const_xmlChar_ptr(n_value, 2 as std::os::raw::c_int);
                        val = gen_xmlSchemaValPtr(n_val, 3 as std::os::raw::c_int);
                        length =
                            gen_unsigned_long_ptr(n_length, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlSchemaValidateLengthFacet(type_0, facet,
                                                         value as
                                                             *const xmlChar,
                                                         val, length);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlSchemaTypePtr(n_type, type_0,
                                             0 as std::os::raw::c_int);
                        des_xmlSchemaFacetPtr(n_facet, facet,
                                              1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_value,
                                              value as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_xmlSchemaValPtr(n_val, val, 3 as std::os::raw::c_int);
                        des_unsigned_long_ptr(n_length, length,
                                              4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlSchemaValidateLengthFacet\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_type);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_facet);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_value);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_val);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_length);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_length += 1
                    }
                    n_val += 1
                }
                n_value += 1
            }
            n_facet += 1
        }
        n_type += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateLengthFacetWhtsp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut n_facet: std::os::raw::c_int = 0;
    let mut valType: xmlSchemaValType = XML_SCHEMAS_UNKNOWN;
    let mut n_valType: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut val: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_val: std::os::raw::c_int = 0;
    let mut length: *mut std::os::raw::c_ulong = 0 as *mut std::os::raw::c_ulong;
    let mut n_length: std::os::raw::c_int = 0;
    let mut ws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut n_ws: std::os::raw::c_int = 0;
    n_facet = 0 as std::os::raw::c_int;
    while n_facet < 1 as std::os::raw::c_int {
        n_valType = 0 as std::os::raw::c_int;
        while n_valType < 4 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int;
            while n_value < 5 as std::os::raw::c_int {
                n_val = 0 as std::os::raw::c_int;
                while n_val < 1 as std::os::raw::c_int {
                    n_length = 0 as std::os::raw::c_int;
                    while n_length < 2 as std::os::raw::c_int {
                        n_ws = 0 as std::os::raw::c_int;
                        while n_ws < 4 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            facet =
                                gen_xmlSchemaFacetPtr(n_facet,
                                                      0 as std::os::raw::c_int);
                            valType =
                                gen_xmlSchemaValType(n_valType,
                                                     1 as std::os::raw::c_int);
                            value =
                                gen_const_xmlChar_ptr(n_value,
                                                      2 as std::os::raw::c_int);
                            val =
                                gen_xmlSchemaValPtr(n_val, 3 as std::os::raw::c_int);
                            length =
                                gen_unsigned_long_ptr(n_length,
                                                      4 as std::os::raw::c_int);
                            ws =
                                gen_xmlSchemaWhitespaceValueType(n_ws,
                                                                 5 as
                                                                     std::os::raw::c_int);
                            ret_val =
                                xmlSchemaValidateLengthFacetWhtsp(facet,
                                                                  valType,
                                                                  value as
                                                                      *const xmlChar,
                                                                  val, length,
                                                                  ws);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlSchemaFacetPtr(n_facet, facet,
                                                  0 as std::os::raw::c_int);
                            des_xmlSchemaValType(n_valType, valType,
                                                 1 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_value,
                                                  value as *const xmlChar,
                                                  2 as std::os::raw::c_int);
                            des_xmlSchemaValPtr(n_val, val, 3 as std::os::raw::c_int);
                            des_unsigned_long_ptr(n_length, length,
                                                  4 as std::os::raw::c_int);
                            des_xmlSchemaWhitespaceValueType(n_ws, ws,
                                                             5 as
                                                                 std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlSchemaValidateLengthFacetWhtsp\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_facet);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_valType);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_value);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_val);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_length);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ws);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_ws += 1
                        }
                        n_length += 1
                    }
                    n_val += 1
                }
                n_value += 1
            }
            n_valType += 1
        }
        n_facet += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidateListSimpleTypeFacet()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut n_facet: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut actualLen: std::os::raw::c_ulong = 0;
    let mut n_actualLen: std::os::raw::c_int = 0;
    let mut expectedLen: *mut std::os::raw::c_ulong = 0 as *mut std::os::raw::c_ulong;
    let mut n_expectedLen: std::os::raw::c_int = 0;
    n_facet = 0 as std::os::raw::c_int;
    while n_facet < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            n_actualLen = 0 as std::os::raw::c_int;
            while n_actualLen < 4 as std::os::raw::c_int {
                n_expectedLen = 0 as std::os::raw::c_int;
                while n_expectedLen < 2 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    facet = gen_xmlSchemaFacetPtr(n_facet, 0 as std::os::raw::c_int);
                    value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
                    actualLen =
                        gen_unsigned_long(n_actualLen, 2 as std::os::raw::c_int);
                    expectedLen =
                        gen_unsigned_long_ptr(n_expectedLen,
                                              3 as std::os::raw::c_int);
                    ret_val =
                        xmlSchemaValidateListSimpleTypeFacet(facet,
                                                             value as
                                                                 *const xmlChar,
                                                             actualLen,
                                                             expectedLen);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlSchemaFacetPtr(n_facet, facet, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_unsigned_long(n_actualLen, actualLen,
                                      2 as std::os::raw::c_int);
                    des_unsigned_long_ptr(n_expectedLen, expectedLen,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlSchemaValidateListSimpleTypeFacet\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_facet);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_actualLen);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_expectedLen);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_expectedLen += 1
                }
                n_actualLen += 1
            }
            n_value += 1
        }
        n_facet += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValidatePredefinedType() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut n_type: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_value: std::os::raw::c_int = 0;
    let mut val: *mut xmlSchemaValPtr = 0 as *mut xmlSchemaValPtr;
    let mut n_val: std::os::raw::c_int = 0;
    n_type = 0 as std::os::raw::c_int;
    while n_type < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            n_val = 0 as std::os::raw::c_int;
            while n_val < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                type_0 = gen_xmlSchemaTypePtr(n_type, 0 as std::os::raw::c_int);
                value = gen_const_xmlChar_ptr(n_value, 1 as std::os::raw::c_int);
                val = gen_xmlSchemaValPtr_ptr(n_val, 2 as std::os::raw::c_int);
                ret_val =
                    xmlSchemaValidatePredefinedType(type_0,
                                                    value as *const xmlChar,
                                                    val);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlSchemaTypePtr(n_type, type_0, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_xmlSchemaValPtr_ptr(n_val, val, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlSchemaValidatePredefinedType\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_type);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_value);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_val);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_val += 1
            }
            n_value += 1
        }
        n_type += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValueAppend() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut prev: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_prev: std::os::raw::c_int = 0;
    let mut cur: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_cur: std::os::raw::c_int = 0;
    n_prev = 0 as std::os::raw::c_int;
    while n_prev < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            prev = gen_xmlSchemaValPtr(n_prev, 0 as std::os::raw::c_int);
            cur = gen_xmlSchemaValPtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlSchemaValueAppend(prev, cur);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlSchemaValPtr(n_prev, prev, 0 as std::os::raw::c_int);
            des_xmlSchemaValPtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlSchemaValueAppend\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_prev);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_prev += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValueGetAsBoolean() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlSchemaValPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaValueGetAsBoolean(val);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlSchemaValPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaValueGetAsBoolean\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValueGetAsString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut val: xmlSchemaValPtr = 0 as *mut xmlSchemaVal;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlSchemaValPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlSchemaValueGetAsString(val);
        desret_const_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlSchemaValPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaValueGetAsString\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlSchemaValueGetNext() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a value */
}
unsafe extern "C" fn test_xmlSchemaWhiteSpaceReplace() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the input char * */
    let mut mem_base: std::os::raw::c_int = 0; /* the input char * */
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar; /* the len of @cur */
    let mut value: *mut xmlChar =
        0 as *mut xmlChar; /* Pointer to putative UTF-8 encoded string. */
    let mut n_value: std::os::raw::c_int = 0; /* a sequence of UTF-8 encoded bytes */
    n_value =
        0 as
            std::os::raw::c_int; /* a pointer to the minimum number of bytes present in the sequence.  This is used to assure the next character is completely contained within the sequence. */
    while n_value < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the first xmlChar * */
        value =
            gen_const_xmlChar_ptr(n_value,
                                  0 as
                                      std::os::raw::c_int); /* the second xmlChar * */
        ret_val = xmlSchemaWhiteSpaceReplace(value as *const xmlChar);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_value, value as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlSchemaWhiteSpaceReplace\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_value);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_value += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlschemastypes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlschemastypes : 26 of 34 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    test_ret += test_xmlSchemaCheckFacet();
    test_ret += test_xmlSchemaCleanupTypes();
    test_ret += test_xmlSchemaCollapseString();
    test_ret += test_xmlSchemaCompareValues();
    test_ret += test_xmlSchemaCompareValuesWhtsp();
    test_ret += test_xmlSchemaCopyValue();
    test_ret += test_xmlSchemaGetBuiltInListSimpleTypeItemType();
    test_ret += test_xmlSchemaGetBuiltInType();
    test_ret += test_xmlSchemaGetCanonValue();
    test_ret += test_xmlSchemaGetCanonValueWhtsp();
    test_ret += test_xmlSchemaGetFacetValueAsULong();
    test_ret += test_xmlSchemaGetPredefinedType();
    test_ret += test_xmlSchemaGetValType();
    test_ret += test_xmlSchemaInitTypes();
    test_ret += test_xmlSchemaIsBuiltInTypeFacet();
    test_ret += test_xmlSchemaNewFacet();
    test_ret += test_xmlSchemaNewNOTATIONValue();
    test_ret += test_xmlSchemaNewQNameValue();
    test_ret += test_xmlSchemaNewStringValue();
    test_ret += test_xmlSchemaValPredefTypeNode();
    test_ret += test_xmlSchemaValPredefTypeNodeNoNorm();
    test_ret += test_xmlSchemaValidateFacet();
    test_ret += test_xmlSchemaValidateFacetWhtsp();
    test_ret += test_xmlSchemaValidateLengthFacet();
    test_ret += test_xmlSchemaValidateLengthFacetWhtsp();
    test_ret += test_xmlSchemaValidateListSimpleTypeFacet();
    test_ret += test_xmlSchemaValidatePredefinedType();
    test_ret += test_xmlSchemaValueAppend();
    test_ret += test_xmlSchemaValueGetAsBoolean();
    test_ret += test_xmlSchemaValueGetAsString();
    test_ret += test_xmlSchemaValueGetNext();
    test_ret += test_xmlSchemaWhiteSpaceReplace();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlschemastypes: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlCharStrdup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_cur: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        cur = gen_const_char_ptr(n_cur, 0 as std::os::raw::c_int);
        ret_val = xmlCharStrdup(cur as *const std::os::raw::c_char);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_const_char_ptr(n_cur, cur as *const std::os::raw::c_char,
                           0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCharStrdup\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCharStrndup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 4 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_const_char_ptr(n_cur, 0 as std::os::raw::c_int);
            len = gen_int(n_len, 1 as std::os::raw::c_int);
            if !(!cur.is_null() &&
                     len >
                         strlen(cur as *const std::os::raw::c_char) as std::os::raw::c_int +
                             1 as std::os::raw::c_int) {
                ret_val = xmlCharStrndup(cur as *const std::os::raw::c_char, len);
                desret_xmlChar_ptr(ret_val);
                call_tests += 1;
                des_const_char_ptr(n_cur, cur as *const std::os::raw::c_char,
                                   0 as std::os::raw::c_int);
                des_int(n_len, len, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlCharStrndup\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_len += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlCheckUTF8() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut utf: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    let mut n_utf: std::os::raw::c_int = 0;
    n_utf = 0 as std::os::raw::c_int;
    while n_utf < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        utf = gen_const_unsigned_char_ptr(n_utf, 0 as std::os::raw::c_int);
        ret_val = xmlCheckUTF8(utf as *const std::os::raw::c_uchar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_unsigned_char_ptr(n_utf, utf as *const std::os::raw::c_uchar,
                                    0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlCheckUTF8\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_utf);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_utf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlGetUTF8Char() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut utf: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    let mut n_utf: std::os::raw::c_int = 0;
    let mut len: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut n_len: std::os::raw::c_int = 0;
    n_utf = 0 as std::os::raw::c_int;
    while n_utf < 1 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 2 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            utf = gen_const_unsigned_char_ptr(n_utf, 0 as std::os::raw::c_int);
            len = gen_int_ptr(n_len, 1 as std::os::raw::c_int);
            ret_val = xmlGetUTF8Char(utf as *const std::os::raw::c_uchar, len);
            desret_int(ret_val);
            call_tests += 1;
            des_const_unsigned_char_ptr(n_utf, utf as *const std::os::raw::c_uchar,
                                        0 as std::os::raw::c_int);
            des_int_ptr(n_len, len, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlGetUTF8Char\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_utf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_len);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_len += 1
        }
        n_utf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStrEqual() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str1: std::os::raw::c_int = 0;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str2: std::os::raw::c_int = 0;
    n_str1 = 0 as std::os::raw::c_int;
    while n_str1 < 5 as std::os::raw::c_int {
        n_str2 = 0 as std::os::raw::c_int;
        while n_str2 < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            str1 = gen_const_xmlChar_ptr(n_str1, 0 as std::os::raw::c_int);
            str2 = gen_const_xmlChar_ptr(n_str2, 1 as std::os::raw::c_int);
            ret_val =
                xmlStrEqual(str1 as *const xmlChar, str2 as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_str1, str1 as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_str2, str2 as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlStrEqual\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_str1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_str2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str2 += 1
        }
        n_str1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStrPrintf() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the prefix of the QName */
}
unsafe extern "C" fn test_xmlStrQEqual() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the localname of the QName */
    let mut mem_base: std::os::raw::c_int = 0; /* the second xmlChar * */
    let mut ret_val: std::os::raw::c_int = 0;
    let mut pref: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pref: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    n_pref = 0 as std::os::raw::c_int;
    while n_pref < 5 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_str = 0 as std::os::raw::c_int;
            while n_str < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                pref = gen_const_xmlChar_ptr(n_pref, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                str = gen_const_xmlChar_ptr(n_str, 2 as std::os::raw::c_int);
                ret_val =
                    xmlStrQEqual(pref as *const xmlChar,
                                 name as *const xmlChar,
                                 str as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_const_xmlChar_ptr(n_pref, pref as *const xmlChar,
                                      0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlStrQEqual\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_pref);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_str);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_str += 1
            }
            n_name += 1
        }
        n_pref += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlStrVPrintf() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the first xmlChar * */
}
unsafe extern "C" fn test_xmlStrcasecmp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the second xmlChar * */
    let mut mem_base: std::os::raw::c_int = 0; /* the xmlChar * array (haystack) */
    let mut ret_val: std::os::raw::c_int = 0; /* the xmlChar to search (needle) */
    let mut str1: *mut xmlChar = 0 as *mut xmlChar; /* the xmlChar * array */
    let mut n_str1: std::os::raw::c_int = 0; /* the xmlChar to search */
    let mut str2: *mut xmlChar = 0 as *mut xmlChar; /* the first xmlChar * */
    let mut n_str2: std::os::raw::c_int = 0; /* the second xmlChar * */
    n_str1 = 0 as std::os::raw::c_int; /* the input xmlChar * */
    while n_str1 < 5 as std::os::raw::c_int {
        n_str2 = 0 as std::os::raw::c_int; /* the xmlChar * array */
        while n_str2 < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the first xmlChar * */
            str1 =
                gen_const_xmlChar_ptr(n_str1,
                                      0 as
                                          std::os::raw::c_int); /* the second xmlChar * */
            str2 =
                gen_const_xmlChar_ptr(n_str2,
                                      1 as
                                          std::os::raw::c_int); /* the max comparison length */
            ret_val =
                xmlStrcasecmp(str1 as *const xmlChar,
                              str2 as
                                  *const xmlChar); /* first xmlChar string */
            desret_int(ret_val); /* second xmlChar string */
            call_tests += 1; /* the len of @str2 or < 0 */
            des_const_xmlChar_ptr(n_str1, str1 as *const xmlChar,
                                  0 as std::os::raw::c_int); /* the first xmlChar * */
            des_const_xmlChar_ptr(n_str2, str2 as *const xmlChar,
                                  1 as
                                      std::os::raw::c_int); /* the second xmlChar * */
            xmlResetLastError(); /* the max comparison length */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlStrcasecmp\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base); /* the input xmlChar * */
                test_ret += 1; /* the len of @cur */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_str1); /* the xmlChar * array (haystack) */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_str2); /* the xmlChar to search (needle) */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the xmlChar * array (haystack) */
            } /* the index of the first char (zero based) */
            n_str2 += 1
        } /* the length of the substring */
        n_str1 += 1
    } /* pointer to first UTF8 char */
    function_tests += 1; /* pointer to second UTF8 char */
    return test_ret; /* pointer to the UTF8 character */
}
unsafe extern "C" fn test_xmlStrcasestr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* a sequence of UTF-8 encoded bytes */
    let mut mem_base: std::os::raw::c_int = 0; /* the input UTF8 * */
    let mut ret_val: *const xmlChar =
        0 as *const xmlChar; /* the UTF8 character to be found */
    let mut str: *mut xmlChar = 0 as *mut xmlChar; /* the input UTF8 * */
    let mut n_str: std::os::raw::c_int = 0; /* the len of @utf (in chars) */
    let mut val: *mut xmlChar = 0 as *mut xmlChar; /* the input UTF8 * */
    let mut n_val: std::os::raw::c_int =
        0; /* the position of the desired UTF8 char (in chars) */
    n_str = 0 as std::os::raw::c_int; /* a sequence of UTF-8 encoded bytes */
    while n_str < 5 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int; /* the number of characters in the array */
        while n_val < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* a sequence of UTF-8 encoded bytes */
            str =
                gen_const_xmlChar_ptr(n_str,
                                      0 as
                                          std::os::raw::c_int); /* relative pos of first char */
            val =
                gen_const_xmlChar_ptr(n_val,
                                      1 as
                                          std::os::raw::c_int); /* total number to copy */
            ret_val =
                xmlStrcasestr(str as *const xmlChar,
                              val as *const xmlChar); /* UCS code point */
            desret_const_xmlChar_ptr(ret_val); /* UCS code point */
            call_tests += 1; /* UCS code point */
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  0 as std::os::raw::c_int); /* UCS code point */
            des_const_xmlChar_ptr(n_val, val as *const xmlChar,
                                  1 as std::os::raw::c_int); /* UCS code point */
            xmlResetLastError(); /* UCS code point */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlStrcasestr\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base); /* UCS code point */
                test_ret += 1; /* UCS code point */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_str); /* UCS code point */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_val); /* UCS code point */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* UCS block name */
            } /* UCS code point */
            n_val += 1
        } /* UCS code point */
        n_str += 1
    } /* UCS code point */
    function_tests += 1; /* UCS code point */
    return test_ret; /* UCS code point */
}
unsafe extern "C" fn test_xmlStrchr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* UCS code point */
    let mut mem_base: std::os::raw::c_int = 0; /* UCS code point */
    let mut ret_val: *const xmlChar =
        0 as *const xmlChar; /* UCS code point */
    let mut str: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut n_str: std::os::raw::c_int = 0; /* UCS code point */
    let mut val: xmlChar = 0; /* UCS code point */
    let mut n_val: std::os::raw::c_int = 0; /* UCS code point */
    n_str = 0 as std::os::raw::c_int; /* UCS code point */
    while n_str < 5 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int; /* UCS code point */
        while n_val < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* UCS code point */
            str =
                gen_const_xmlChar_ptr(n_str,
                                      0 as std::os::raw::c_int); /* UCS code point */
            val = gen_xmlChar(n_val, 1 as std::os::raw::c_int); /* UCS code point */
            ret_val =
                xmlStrchr(str as *const xmlChar, val); /* UCS Category name */
            desret_const_xmlChar_ptr(ret_val); /* UCS code point */
            call_tests += 1; /* UCS code point */
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  0 as std::os::raw::c_int); /* UCS code point */
            des_xmlChar(n_val, val, 1 as std::os::raw::c_int); /* UCS code point */
            xmlResetLastError(); /* UCS code point */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlStrchr\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base); /* UCS code point */
                test_ret += 1; /* UCS code point */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_str); /* UCS code point */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_val); /* UCS code point */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* UCS code point */
            } /* UCS code point */
            n_val += 1
        } /* UCS code point */
        n_str += 1
    } /* UCS code point */
    function_tests += 1; /* UCS code point */
    return test_ret; /* UCS code point */
}
unsafe extern "C" fn test_xmlStrcmp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* UCS code point */
    let mut mem_base: std::os::raw::c_int = 0; /* UCS code point */
    let mut ret_val: std::os::raw::c_int = 0; /* UCS code point */
    let mut str1: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut n_str1: std::os::raw::c_int = 0; /* UCS code point */
    let mut str2: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut n_str2: std::os::raw::c_int = 0; /* UCS code point */
    n_str1 = 0 as std::os::raw::c_int; /* UCS code point */
    while n_str1 < 5 as std::os::raw::c_int {
        n_str2 = 0 as std::os::raw::c_int; /* UCS code point */
        while n_str2 < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* UCS code point */
            str1 =
                gen_const_xmlChar_ptr(n_str1,
                                      0 as std::os::raw::c_int); /* UCS code point */
            str2 =
                gen_const_xmlChar_ptr(n_str2,
                                      1 as std::os::raw::c_int); /* UCS code point */
            ret_val =
                xmlStrcmp(str1 as *const xmlChar,
                          str2 as *const xmlChar); /* UCS code point */
            desret_int(ret_val); /* UCS code point */
            call_tests += 1; /* UCS code point */
            des_const_xmlChar_ptr(n_str1, str1 as *const xmlChar,
                                  0 as std::os::raw::c_int); /* UCS code point */
            des_const_xmlChar_ptr(n_str2, str2 as *const xmlChar,
                                  1 as std::os::raw::c_int); /* UCS code point */
            xmlResetLastError(); /* UCS code point */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlStrcmp\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base); /* UCS code point */
                test_ret += 1; /* UCS code point */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_str1); /* UCS code point */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_str2); /* UCS code point */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* UCS code point */
            } /* UCS code point */
            n_str2 += 1
        } /* UCS code point */
        n_str1 += 1
    } /* UCS code point */
    function_tests += 1; /* UCS code point */
    return test_ret; /* UCS code point */
}
unsafe extern "C" fn test_xmlStrdup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* UCS code point */
    let mut mem_base: std::os::raw::c_int = 0; /* UCS code point */
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut cur: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut n_cur: std::os::raw::c_int = 0; /* UCS code point */
    n_cur = 0 as std::os::raw::c_int; /* UCS code point */
    while n_cur < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* UCS code point */
        cur =
            gen_const_xmlChar_ptr(n_cur,
                                  0 as std::os::raw::c_int); /* UCS code point */
        ret_val = xmlStrdup(cur as *const xmlChar); /* UCS code point */
        desret_xmlChar_ptr(ret_val); /* UCS code point */
        call_tests += 1; /* UCS code point */
        des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                              0 as std::os::raw::c_int); /* UCS code point */
        xmlResetLastError(); /* UCS code point */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlStrdup\x00" as *const u8 as
                       *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* UCS code point */
            test_ret += 1; /* UCS code point */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_cur); /* UCS code point */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* UCS code point */
        } /* UCS code point */
        n_cur += 1
    } /* UCS code point */
    function_tests += 1; /* UCS code point */
    return test_ret; /* UCS code point */
}
unsafe extern "C" fn test_xmlStrlen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* UCS code point */
    let mut mem_base: std::os::raw::c_int = 0; /* UCS code point */
    let mut ret_val: std::os::raw::c_int = 0; /* UCS code point */
    let mut str: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut n_str: std::os::raw::c_int = 0; /* UCS code point */
    n_str = 0 as std::os::raw::c_int; /* UCS code point */
    while n_str < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* UCS code point */
        str =
            gen_const_xmlChar_ptr(n_str,
                                  0 as std::os::raw::c_int); /* UCS code point */
        ret_val = xmlStrlen(str as *const xmlChar); /* UCS code point */
        desret_int(ret_val); /* UCS code point */
        call_tests += 1; /* UCS code point */
        des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                              0 as std::os::raw::c_int); /* UCS code point */
        xmlResetLastError(); /* UCS code point */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlStrlen\x00" as *const u8 as
                       *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* UCS code point */
            test_ret += 1; /* UCS code point */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_str); /* UCS code point */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* UCS code point */
        } /* UCS code point */
        n_str += 1
    } /* UCS code point */
    function_tests += 1; /* UCS code point */
    return test_ret; /* UCS code point */
}
unsafe extern "C" fn test_xmlStrncasecmp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* UCS code point */
    let mut mem_base: std::os::raw::c_int = 0; /* UCS code point */
    let mut ret_val: std::os::raw::c_int = 0; /* UCS code point */
    let mut str1: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut n_str1: std::os::raw::c_int = 0; /* UCS code point */
    let mut str2: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut n_str2: std::os::raw::c_int = 0; /* UCS code point */
    let mut len: std::os::raw::c_int = 0; /* UCS code point */
    let mut n_len: std::os::raw::c_int = 0; /* UCS code point */
    n_str1 = 0 as std::os::raw::c_int; /* UCS code point */
    while n_str1 < 5 as std::os::raw::c_int {
        n_str2 = 0 as std::os::raw::c_int; /* UCS code point */
        while n_str2 < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int; /* UCS code point */
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* UCS code point */
                str1 =
                    gen_const_xmlChar_ptr(n_str1,
                                          0 as
                                              std::os::raw::c_int); /* UCS code point */
                str2 =
                    gen_const_xmlChar_ptr(n_str2,
                                          1 as
                                              std::os::raw::c_int); /* UCS code point */
                len = gen_int(n_len, 2 as std::os::raw::c_int); /* UCS code point */
                if !(!str2.is_null() &&
                         len >
                             strlen(str2 as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlStrncasecmp(str1 as *const xmlChar,
                                       str2 as *const xmlChar,
                                       len); /* UCS code point */
                    desret_int(ret_val); /* UCS code point */
                    call_tests += 1; /* UCS code point */
                    des_const_xmlChar_ptr(n_str1, str1 as *const xmlChar,
                                          0 as
                                              std::os::raw::c_int); /* UCS code point */
                    des_const_xmlChar_ptr(n_str2, str2 as *const xmlChar,
                                          1 as
                                              std::os::raw::c_int); /* UCS code point */
                    des_int(n_len, len,
                            2 as std::os::raw::c_int); /* UCS code point */
                    xmlResetLastError(); /* UCS code point */
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlStrncasecmp\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() -
                                   mem_base); /* UCS code point */
                        test_ret += 1; /* UCS code point */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_str1); /* UCS code point */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_str2); /* UCS code point */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len); /* UCS code point */
                        printf(b"\n\x00" as *const u8 as
                                   *const std::os::raw::c_char); /* UCS code point */
                    }
                } /* UCS code point */
                n_len += 1
            } /* UCS code point */
            n_str2 += 1
        } /* UCS code point */
        n_str1 += 1
    } /* UCS code point */
    function_tests += 1; /* UCS code point */
    return test_ret; /* UCS code point */
}
unsafe extern "C" fn test_xmlStrncatNew() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* UCS code point */
    let mut mem_base: std::os::raw::c_int = 0; /* UCS code point */
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut str1: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut n_str1: std::os::raw::c_int = 0; /* UCS code point */
    let mut str2: *mut xmlChar = 0 as *mut xmlChar; /* UCS code point */
    let mut n_str2: std::os::raw::c_int = 0; /* UCS code point */
    let mut len: std::os::raw::c_int = 0; /* UCS code point */
    let mut n_len: std::os::raw::c_int = 0; /* UCS code point */
    n_str1 = 0 as std::os::raw::c_int; /* UCS code point */
    while n_str1 < 5 as std::os::raw::c_int {
        n_str2 = 0 as std::os::raw::c_int; /* UCS code point */
        while n_str2 < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int; /* UCS code point */
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* UCS code point */
                str1 =
                    gen_const_xmlChar_ptr(n_str1,
                                          0 as
                                              std::os::raw::c_int); /* UCS code point */
                str2 =
                    gen_const_xmlChar_ptr(n_str2,
                                          1 as
                                              std::os::raw::c_int); /* UCS code point */
                len = gen_int(n_len, 2 as std::os::raw::c_int); /* UCS code point */
                if !(!str2.is_null() &&
                         len >
                             strlen(str2 as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlStrncatNew(str1 as *const xmlChar,
                                      str2 as *const xmlChar,
                                      len); /* UCS code point */
                    desret_xmlChar_ptr(ret_val); /* UCS code point */
                    call_tests += 1; /* UCS code point */
                    des_const_xmlChar_ptr(n_str1, str1 as *const xmlChar,
                                          0 as
                                              std::os::raw::c_int); /* an xmlOutputBufferPtr */
                    des_const_xmlChar_ptr(n_str2, str2 as *const xmlChar,
                                          1 as
                                              std::os::raw::c_int); /* the URI of the resource for the output */
                    des_int(n_len, len,
                            2 as std::os::raw::c_int); /* compress the output? */
                    xmlResetLastError(); /* xmlBufferPtr */
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlStrncatNew\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() -
                                   mem_base); /* compress the output? */
                        test_ret +=
                            1; /* xmlParserCtxtPtr to hold the new XML document tree */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_str1); /* compress the output? */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_str2); /* xmlDocPtr */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len); /* xmlNodePtr or NULL for doc->children */
                        printf(b"\n\x00" as *const u8 as
                                   *const std::os::raw::c_char); /* compress the output? */
                    }
                } /* the xmlTextWriterPtr */
                n_len += 1
            } /* the xmlTextWriterPtr */
            n_str2 += 1
        } /* the xmlTextWriterPtr */
        n_str1 += 1
    } /* the xmlTextWriterPtr */
    function_tests += 1; /* the xmlTextWriterPtr */
    return test_ret; /* the xmlTextWriterPtr */
}
unsafe extern "C" fn test_xmlStrncmp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlTextWriterPtr */
    let mut mem_base: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    let mut ret_val: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    let mut str1: *mut xmlChar = 0 as *mut xmlChar; /* the xmlTextWriterPtr */
    let mut n_str1: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    let mut str2: *mut xmlChar = 0 as *mut xmlChar; /* the xmlTextWriterPtr */
    let mut n_str2: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    let mut len: std::os::raw::c_int = 0; /* do indentation? */
    let mut n_len: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    n_str1 = 0 as std::os::raw::c_int; /* the xmlChar string */
    while n_str1 < 5 as std::os::raw::c_int {
        n_str2 = 0 as std::os::raw::c_int; /* the xmlTextWriterPtr */
        while n_str2 < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int; /* the quote character */
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* the xmlTextWriterPtr */
                str1 =
                    gen_const_xmlChar_ptr(n_str1,
                                          0 as
                                              std::os::raw::c_int); /* element name */
                str2 =
                    gen_const_xmlChar_ptr(n_str2,
                                          1 as
                                              std::os::raw::c_int); /* the xmlTextWriterPtr */
                len =
                    gen_int(n_len,
                            2 as std::os::raw::c_int); /* namespace prefix or NULL */
                if !(!str2.is_null() &&
                         len >
                             strlen(str2 as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlStrncmp(str1 as *const xmlChar,
                                   str2 as *const xmlChar,
                                   len); /* element local name */
                    desret_int(ret_val); /* namespace URI or NULL */
                    call_tests += 1; /* the xmlTextWriterPtr */
                    des_const_xmlChar_ptr(n_str1, str1 as *const xmlChar,
                                          0 as
                                              std::os::raw::c_int); /* the xmlTextWriterPtr */
                    des_const_xmlChar_ptr(n_str2, str2 as *const xmlChar,
                                          1 as
                                              std::os::raw::c_int); /* the xmlTextWriterPtr */
                    des_int(n_len, len,
                            2 as std::os::raw::c_int); /* the name of the DTD */
                    xmlResetLastError(); /* the public identifier, which is an alternative to the system identifier */
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlStrncmp\x00" as
                                   *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() -
                                   mem_base); /* the system identifier, which is the URI of the DTD */
                        test_ret += 1; /* the xmlTextWriterPtr */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_str1); /* the name of the DTD ATTLIST */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_str2); /* the xmlTextWriterPtr */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len); /* the name of the DTD element */
                        printf(b"\n\x00" as *const u8 as
                                   *const std::os::raw::c_char); /* the xmlTextWriterPtr */
                    }
                } /* TRUE if this is a parameter entity, FALSE if not */
                n_len += 1
            } /* the name of the DTD ATTLIST */
            n_str2 += 1
        } /* the xmlTextWriterPtr */
        n_str1 += 1
    } /* the xml version ("1.0") or NULL for default ("1.0") */
    function_tests += 1; /* the encoding or NULL for default */
    return test_ret; /* "yes" or "no" or NULL for default */
}
unsafe extern "C" fn test_xmlStrndup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlTextWriterPtr */
    let mut mem_base: std::os::raw::c_int = 0; /* element name */
    let mut ret_val: *mut xmlChar =
        0 as *mut xmlChar; /* the xmlTextWriterPtr */
    let mut cur: *mut xmlChar =
        0 as *mut xmlChar; /* namespace prefix or NULL */
    let mut n_cur: std::os::raw::c_int = 0; /* element local name */
    let mut len: std::os::raw::c_int = 0; /* namespace URI or NULL */
    let mut n_len: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    n_cur = 0 as std::os::raw::c_int; /* PI target */
    while n_cur < 5 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int; /* the xmlTextWriterPtr */
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* attribute name */
            cur =
                gen_const_xmlChar_ptr(n_cur,
                                      0 as
                                          std::os::raw::c_int); /* attribute content */
            len = gen_int(n_len, 1 as std::os::raw::c_int); /* the xmlTextWriterPtr */
            if !(!cur.is_null() &&
                     len >
                         strlen(cur as *const std::os::raw::c_char) as std::os::raw::c_int +
                             1 as std::os::raw::c_int) {
                ret_val =
                    xmlStrndup(cur as *const xmlChar,
                               len); /* namespace prefix */
                desret_xmlChar_ptr(ret_val); /* attribute local name */
                call_tests += 1; /* namespace URI */
                des_const_xmlChar_ptr(n_cur, cur as *const xmlChar,
                                      0 as
                                          std::os::raw::c_int); /* attribute content */
                des_int(n_len, len,
                        1 as std::os::raw::c_int); /* the xmlTextWriterPtr */
                xmlResetLastError(); /* binary data */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlStrndup\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() -
                               mem_base); /* the position within the data of the first byte to encode */
                    test_ret += 1; /* the number of bytes to encode */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur); /* the xmlTextWriterPtr */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len); /* binary data */
                    printf(b"\n\x00" as *const u8 as
                               *const std::os::raw::c_char); /* the position within the data of the first byte to encode */
                }
            } /* the number of bytes to encode */
            n_len += 1
        } /* the xmlTextWriterPtr */
        n_cur += 1
    } /* CDATA content */
    function_tests += 1; /* the xmlTextWriterPtr */
    return test_ret; /* comment string */
}
unsafe extern "C" fn test_xmlStrstr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlTextWriterPtr */
    let mut mem_base: std::os::raw::c_int = 0; /* the name of the DTD */
    let mut ret_val: *const xmlChar =
        0 as
            *const xmlChar; /* the public identifier, which is an alternative to the system identifier */
    let mut str: *mut xmlChar =
        0 as
            *mut xmlChar; /* the system identifier, which is the URI of the DTD */
    let mut n_str: std::os::raw::c_int = 0; /* string content of the DTD */
    let mut val: *mut xmlChar = 0 as *mut xmlChar; /* the xmlTextWriterPtr */
    let mut n_val: std::os::raw::c_int = 0; /* the name of the DTD ATTLIST */
    n_str = 0 as std::os::raw::c_int; /* content of the ATTLIST */
    while n_str < 5 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int; /* the xmlTextWriterPtr */
        while n_val < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the name of the DTD element */
            str =
                gen_const_xmlChar_ptr(n_str,
                                      0 as
                                          std::os::raw::c_int); /* content of the element */
            val =
                gen_const_xmlChar_ptr(n_val,
                                      1 as
                                          std::os::raw::c_int); /* the xmlTextWriterPtr */
            ret_val =
                xmlStrstr(str as *const xmlChar,
                          val as
                              *const xmlChar); /* TRUE if this is a parameter entity, FALSE if not */
            desret_const_xmlChar_ptr(ret_val); /* the name of the DTD entity */
            call_tests +=
                1; /* the public identifier, which is an alternative to the system identifier */
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  0 as
                                      std::os::raw::c_int); /* the system identifier, which is the URI of the DTD */
            des_const_xmlChar_ptr(n_val, val as *const xmlChar,
                                  1 as
                                      std::os::raw::c_int); /* the xml notation name. */
            xmlResetLastError(); /* content of the entity */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlStrstr\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base); /* the xmlTextWriterPtr */
                test_ret +=
                    1; /* TRUE if this is a parameter entity, FALSE if not */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_str); /* the name of the DTD entity */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_val); /* the public identifier, which is an alternative to the system identifier */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the system identifier, which is the URI of the DTD */
            } /* the xml notation name. */
            n_val += 1
        } /* the xmlTextWriterPtr */
        n_str += 1
    } /* the public identifier, which is an alternative to the system identifier */
    function_tests +=
        1; /* the system identifier, which is the URI of the DTD */
    return test_ret; /* the xml notation name. */
}
unsafe extern "C" fn test_xmlStrsub() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the xmlTextWriterPtr */
    let mut mem_base: std::os::raw::c_int =
        0; /* TRUE if this is a parameter entity, FALSE if not */
    let mut ret_val: *mut xmlChar =
        0 as *mut xmlChar; /* the name of the DTD entity */
    let mut str: *mut xmlChar = 0 as *mut xmlChar; /* content of the entity */
    let mut n_str: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    let mut start: std::os::raw::c_int = 0; /* the name of the xml notation */
    let mut n_start: std::os::raw::c_int =
        0; /* the public identifier, which is an alternative to the system identifier */
    let mut len: std::os::raw::c_int =
        0; /* the system identifier, which is the URI of the DTD */
    let mut n_len: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    n_str = 0 as std::os::raw::c_int; /* element name */
    while n_str < 5 as std::os::raw::c_int {
        n_start = 0 as std::os::raw::c_int; /* element content */
        while n_start < 4 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int; /* the xmlTextWriterPtr */
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* namespace prefix */
                str =
                    gen_const_xmlChar_ptr(n_str,
                                          0 as
                                              std::os::raw::c_int); /* element local name */
                start =
                    gen_int(n_start, 1 as std::os::raw::c_int); /* namespace URI */
                len = gen_int(n_len, 2 as std::os::raw::c_int); /* element content */
                if !(!str.is_null() &&
                         start >
                             strlen(str as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    if !(!str.is_null() &&
                             len >
                                 strlen(str as *const std::os::raw::c_char) as
                                     std::os::raw::c_int + 1 as std::os::raw::c_int) {
                        ret_val =
                            xmlStrsub(str as *const xmlChar, start, len);
                        desret_xmlChar_ptr(ret_val);
                        call_tests += 1;
                        des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                              0 as std::os::raw::c_int);
                        des_int(n_start, start, 1 as std::os::raw::c_int);
                        des_int(n_len, len, 2 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlStrsub\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_str);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_start);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_len);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                    }
                }
                n_len += 1
            }
            n_start += 1
        }
        n_str += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUTF8Charcmp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut utf1: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utf1: std::os::raw::c_int = 0;
    let mut utf2: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utf2: std::os::raw::c_int = 0;
    n_utf1 = 0 as std::os::raw::c_int;
    while n_utf1 < 5 as std::os::raw::c_int {
        n_utf2 = 0 as std::os::raw::c_int;
        while n_utf2 < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            utf1 = gen_const_xmlChar_ptr(n_utf1, 0 as std::os::raw::c_int);
            utf2 = gen_const_xmlChar_ptr(n_utf2, 1 as std::os::raw::c_int);
            ret_val =
                xmlUTF8Charcmp(utf1 as *const xmlChar,
                               utf2 as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_utf1, utf1 as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_utf2, utf2 as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlUTF8Charcmp\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_utf1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_utf2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_utf2 += 1
        }
        n_utf1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUTF8Size() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utf: std::os::raw::c_int = 0;
    n_utf = 0 as std::os::raw::c_int;
    while n_utf < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0 as std::os::raw::c_int);
        ret_val = xmlUTF8Size(utf as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_utf, utf as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUTF8Size\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_utf);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_utf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUTF8Strlen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utf: std::os::raw::c_int = 0;
    n_utf = 0 as std::os::raw::c_int;
    while n_utf < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0 as std::os::raw::c_int);
        ret_val = xmlUTF8Strlen(utf as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_utf, utf as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUTF8Strlen\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_utf);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_utf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUTF8Strloc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utf: std::os::raw::c_int = 0;
    let mut utfchar: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utfchar: std::os::raw::c_int = 0;
    n_utf = 0 as std::os::raw::c_int;
    while n_utf < 5 as std::os::raw::c_int {
        n_utfchar = 0 as std::os::raw::c_int;
        while n_utfchar < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            utf = gen_const_xmlChar_ptr(n_utf, 0 as std::os::raw::c_int);
            utfchar = gen_const_xmlChar_ptr(n_utfchar, 1 as std::os::raw::c_int);
            ret_val =
                xmlUTF8Strloc(utf as *const xmlChar,
                              utfchar as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_utf, utf as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_utfchar, utfchar as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlUTF8Strloc\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_utf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_utfchar);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_utfchar += 1
        }
        n_utf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUTF8Strndup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utf: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_utf = 0 as std::os::raw::c_int;
    while n_utf < 5 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            utf = gen_const_xmlChar_ptr(n_utf, 0 as std::os::raw::c_int);
            len = gen_int(n_len, 1 as std::os::raw::c_int);
            if !(!utf.is_null() &&
                     len >
                         strlen(utf as *const std::os::raw::c_char) as std::os::raw::c_int +
                             1 as std::os::raw::c_int) {
                ret_val = xmlUTF8Strndup(utf as *const xmlChar, len);
                desret_xmlChar_ptr(ret_val);
                call_tests += 1;
                des_const_xmlChar_ptr(n_utf, utf as *const xmlChar,
                                      0 as std::os::raw::c_int);
                des_int(n_len, len, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlUTF8Strndup\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_utf);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_len += 1
        }
        n_utf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUTF8Strpos() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utf: std::os::raw::c_int = 0;
    let mut pos: std::os::raw::c_int = 0;
    let mut n_pos: std::os::raw::c_int = 0;
    n_utf = 0 as std::os::raw::c_int;
    while n_utf < 5 as std::os::raw::c_int {
        n_pos = 0 as std::os::raw::c_int;
        while n_pos < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            utf = gen_const_xmlChar_ptr(n_utf, 0 as std::os::raw::c_int);
            pos = gen_int(n_pos, 1 as std::os::raw::c_int);
            ret_val = xmlUTF8Strpos(utf as *const xmlChar, pos);
            desret_const_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_utf, utf as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_int(n_pos, pos, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlUTF8Strpos\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_utf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_pos);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_pos += 1
        }
        n_utf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUTF8Strsize() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utf: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_utf = 0 as std::os::raw::c_int;
    while n_utf < 5 as std::os::raw::c_int {
        n_len = 0 as std::os::raw::c_int;
        while n_len < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            utf = gen_const_xmlChar_ptr(n_utf, 0 as std::os::raw::c_int);
            len = gen_int(n_len, 1 as std::os::raw::c_int);
            if !(!utf.is_null() &&
                     len >
                         strlen(utf as *const std::os::raw::c_char) as std::os::raw::c_int +
                             1 as std::os::raw::c_int) {
                ret_val = xmlUTF8Strsize(utf as *const xmlChar, len);
                desret_int(ret_val);
                call_tests += 1;
                des_const_xmlChar_ptr(n_utf, utf as *const xmlChar,
                                      0 as std::os::raw::c_int);
                des_int(n_len, len, 1 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlUTF8Strsize\x00" as
                               *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_utf);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_len);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
            n_len += 1
        }
        n_utf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUTF8Strsub() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_utf: std::os::raw::c_int = 0;
    let mut start: std::os::raw::c_int = 0;
    let mut n_start: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_utf = 0 as std::os::raw::c_int;
    while n_utf < 5 as std::os::raw::c_int {
        n_start = 0 as std::os::raw::c_int;
        while n_start < 4 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                utf = gen_const_xmlChar_ptr(n_utf, 0 as std::os::raw::c_int);
                start = gen_int(n_start, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!utf.is_null() &&
                         start >
                             strlen(utf as *const std::os::raw::c_char) as std::os::raw::c_int
                                 + 1 as std::os::raw::c_int) {
                    if !(!utf.is_null() &&
                             len >
                                 strlen(utf as *const std::os::raw::c_char) as
                                     std::os::raw::c_int + 1 as std::os::raw::c_int) {
                        ret_val =
                            xmlUTF8Strsub(utf as *const xmlChar, start, len);
                        desret_xmlChar_ptr(ret_val);
                        call_tests += 1;
                        des_const_xmlChar_ptr(n_utf, utf as *const xmlChar,
                                              0 as std::os::raw::c_int);
                        des_int(n_start, start, 1 as std::os::raw::c_int);
                        des_int(n_len, len, 2 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlUTF8Strsub\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_utf);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_start);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_len);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                    }
                }
                n_len += 1
            }
            n_start += 1
        }
        n_utf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlstring() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlstring : 26 of 30 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    test_ret += test_xmlCharStrdup();
    test_ret += test_xmlCharStrndup();
    test_ret += test_xmlCheckUTF8();
    test_ret += test_xmlGetUTF8Char();
    test_ret += test_xmlStrEqual();
    test_ret += test_xmlStrPrintf();
    test_ret += test_xmlStrQEqual();
    test_ret += test_xmlStrVPrintf();
    test_ret += test_xmlStrcasecmp();
    test_ret += test_xmlStrcasestr();
    test_ret += test_xmlStrchr();
    test_ret += test_xmlStrcmp();
    test_ret += test_xmlStrdup();
    test_ret += test_xmlStrlen();
    test_ret += test_xmlStrncasecmp();
    test_ret += test_xmlStrncatNew();
    test_ret += test_xmlStrncmp();
    test_ret += test_xmlStrndup();
    test_ret += test_xmlStrstr();
    test_ret += test_xmlStrsub();
    test_ret += test_xmlUTF8Charcmp();
    test_ret += test_xmlUTF8Size();
    test_ret += test_xmlUTF8Strlen();
    test_ret += test_xmlUTF8Strloc();
    test_ret += test_xmlUTF8Strndup();
    test_ret += test_xmlUTF8Strpos();
    test_ret += test_xmlUTF8Strsize();
    test_ret += test_xmlUTF8Strsub();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlstring: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsAegeanNumbers() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsAegeanNumbers(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsAegeanNumbers\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsAlphabeticPresentationForms()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsAlphabeticPresentationForms(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsAlphabeticPresentationForms\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsArabic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsArabic(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsArabic\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsArabicPresentationFormsA() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsArabicPresentationFormsA(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsArabicPresentationFormsA\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsArabicPresentationFormsB() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsArabicPresentationFormsB(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsArabicPresentationFormsB\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsArmenian() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsArmenian(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsArmenian\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsArrows() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsArrows(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsArrows\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsBasicLatin() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsBasicLatin(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsBasicLatin\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsBengali() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsBengali(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsBengali\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsBlock() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    let mut block: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_block: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        n_block = 0 as std::os::raw::c_int;
        while n_block < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            code = gen_int(n_code, 0 as std::os::raw::c_int);
            block = gen_const_char_ptr(n_block, 1 as std::os::raw::c_int);
            ret_val = xmlUCSIsBlock(code, block as *const std::os::raw::c_char);
            desret_int(ret_val);
            call_tests += 1;
            des_int(n_code, code, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_block, block as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlUCSIsBlock\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_code);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_block);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_block += 1
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsBlockElements() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsBlockElements(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsBlockElements\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsBopomofo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsBopomofo(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsBopomofo\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsBopomofoExtended() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsBopomofoExtended(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsBopomofoExtended\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsBoxDrawing() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsBoxDrawing(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsBoxDrawing\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsBraillePatterns() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsBraillePatterns(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsBraillePatterns\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsBuhid() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsBuhid(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsBuhid\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsByzantineMusicalSymbols() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsByzantineMusicalSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsByzantineMusicalSymbols\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCJKCompatibility() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCJKCompatibility(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCJKCompatibility\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCJKCompatibilityForms() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCJKCompatibilityForms(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCJKCompatibilityForms\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCJKCompatibilityIdeographs()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCJKCompatibilityIdeographs(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographs\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCJKCompatibilityIdeographsSupplement()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCJKCompatibilityIdeographsSupplement(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographsSupplement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCJKRadicalsSupplement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCJKRadicalsSupplement(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCJKRadicalsSupplement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCJKSymbolsandPunctuation() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCJKSymbolsandPunctuation(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCJKSymbolsandPunctuation\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCJKUnifiedIdeographs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCJKUnifiedIdeographs(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographs\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCJKUnifiedIdeographsExtensionA()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionA(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionA\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCJKUnifiedIdeographsExtensionB()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionB(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionB\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCat() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    let mut cat: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_cat: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        n_cat = 0 as std::os::raw::c_int;
        while n_cat < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            code = gen_int(n_code, 0 as std::os::raw::c_int);
            cat = gen_const_char_ptr(n_cat, 1 as std::os::raw::c_int);
            ret_val = xmlUCSIsCat(code, cat as *const std::os::raw::c_char);
            desret_int(ret_val);
            call_tests += 1;
            des_int(n_code, code, 0 as std::os::raw::c_int);
            des_const_char_ptr(n_cat, cat as *const std::os::raw::c_char,
                               1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlUCSIsCat\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_code);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cat);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cat += 1
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatC() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatC(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatC\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatCc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatCc(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatCc\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatCf() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatCf(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatCf\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatCo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatCo(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatCo\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatCs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatCs(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatCs\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatL() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatL(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatL\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatLl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatLl(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatLl\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatLm() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatLm(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatLm\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatLo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatLo(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatLo\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatLt() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatLt(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatLt\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatLu() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatLu(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatLu\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatM() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatM(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatM\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatMc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatMc(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatMc\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatMe() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatMe(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatMe\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatMn() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatMn(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatMn\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatN() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatN(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatN\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatNd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatNd(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatNd\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatNl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatNl(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatNl\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatNo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatNo(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatNo\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatP() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatP(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatP\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatPc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatPc(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatPc\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatPd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatPd(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatPd\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatPe() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatPe(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatPe\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatPf() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatPf(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatPf\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatPi() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatPi(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatPi\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatPo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatPo(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatPo\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatPs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatPs(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatPs\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatS(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatS\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatSc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatSc(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatSc\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatSk() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatSk(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatSk\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatSm() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatSm(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatSm\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatSo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatSo(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatSo\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatZ() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatZ(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatZ\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatZl() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatZl(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatZl\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatZp() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatZp(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatZp\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCatZs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCatZs(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCatZs\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCherokee() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCherokee(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCherokee\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCombiningDiacriticalMarks() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCombiningDiacriticalMarks(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarks\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCombiningDiacriticalMarksforSymbols()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCombiningDiacriticalMarksforSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarksforSymbols\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCombiningHalfMarks() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCombiningHalfMarks(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCombiningHalfMarks\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCombiningMarksforSymbols() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCombiningMarksforSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCombiningMarksforSymbols\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsControlPictures() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsControlPictures(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsControlPictures\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCurrencySymbols() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCurrencySymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCurrencySymbols\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCypriotSyllabary() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCypriotSyllabary(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCypriotSyllabary\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCyrillic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCyrillic(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCyrillic\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsCyrillicSupplement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsCyrillicSupplement(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsCyrillicSupplement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsDeseret() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsDeseret(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsDeseret\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsDevanagari() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsDevanagari(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsDevanagari\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsDingbats() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsDingbats(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsDingbats\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsEnclosedAlphanumerics() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsEnclosedAlphanumerics(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsEnclosedAlphanumerics\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsEnclosedCJKLettersandMonths()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsEnclosedCJKLettersandMonths(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsEnclosedCJKLettersandMonths\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsEthiopic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsEthiopic(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsEthiopic\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsGeneralPunctuation() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsGeneralPunctuation(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsGeneralPunctuation\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsGeometricShapes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsGeometricShapes(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsGeometricShapes\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsGeorgian() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsGeorgian(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsGeorgian\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsGothic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsGothic(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsGothic\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsGreek() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsGreek(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsGreek\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsGreekExtended() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsGreekExtended(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsGreekExtended\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsGreekandCoptic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsGreekandCoptic(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsGreekandCoptic\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsGujarati() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsGujarati(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsGujarati\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsGurmukhi() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsGurmukhi(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsGurmukhi\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsHalfwidthandFullwidthForms()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsHalfwidthandFullwidthForms(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsHalfwidthandFullwidthForms\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsHangulCompatibilityJamo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsHangulCompatibilityJamo(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsHangulCompatibilityJamo\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsHangulJamo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsHangulJamo(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsHangulJamo\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsHangulSyllables() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsHangulSyllables(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsHangulSyllables\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsHanunoo() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsHanunoo(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsHanunoo\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsHebrew() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsHebrew(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsHebrew\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsHighPrivateUseSurrogates() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsHighPrivateUseSurrogates(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsHighPrivateUseSurrogates\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsHighSurrogates() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsHighSurrogates(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsHighSurrogates\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsHiragana() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsHiragana(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsHiragana\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsIPAExtensions() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsIPAExtensions(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsIPAExtensions\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsIdeographicDescriptionCharacters()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsIdeographicDescriptionCharacters(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsIdeographicDescriptionCharacters\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsKanbun() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsKanbun(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsKanbun\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsKangxiRadicals() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsKangxiRadicals(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsKangxiRadicals\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsKannada() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsKannada(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsKannada\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsKatakana() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsKatakana(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsKatakana\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsKatakanaPhoneticExtensions()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsKatakanaPhoneticExtensions(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsKatakanaPhoneticExtensions\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsKhmer() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsKhmer(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsKhmer\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsKhmerSymbols() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsKhmerSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsKhmerSymbols\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLao() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLao(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLao\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLatin1Supplement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLatin1Supplement(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLatin1Supplement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLatinExtendedA() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLatinExtendedA(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLatinExtendedA\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLatinExtendedAdditional() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLatinExtendedAdditional(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLatinExtendedAdditional\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLatinExtendedB() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLatinExtendedB(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLatinExtendedB\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLetterlikeSymbols() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLetterlikeSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLetterlikeSymbols\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLimbu() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLimbu(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLimbu\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLinearBIdeograms() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLinearBIdeograms(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLinearBIdeograms\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLinearBSyllabary() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLinearBSyllabary(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLinearBSyllabary\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsLowSurrogates() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsLowSurrogates(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsLowSurrogates\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMalayalam() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMalayalam(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMalayalam\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMathematicalAlphanumericSymbols()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMathematicalAlphanumericSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMathematicalAlphanumericSymbols\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMathematicalOperators() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMathematicalOperators(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMathematicalOperators\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMiscellaneousMathematicalSymbolsA()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsA(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsA\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMiscellaneousMathematicalSymbolsB()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsB(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsB\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMiscellaneousSymbols() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMiscellaneousSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMiscellaneousSymbols\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMiscellaneousSymbolsandArrows()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMiscellaneousSymbolsandArrows(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMiscellaneousSymbolsandArrows\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMiscellaneousTechnical() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMiscellaneousTechnical(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMiscellaneousTechnical\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMongolian() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMongolian(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMongolian\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMusicalSymbols() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMusicalSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMusicalSymbols\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsMyanmar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsMyanmar(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsMyanmar\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsNumberForms() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsNumberForms(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsNumberForms\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsOgham() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsOgham(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsOgham\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsOldItalic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsOldItalic(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsOldItalic\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsOpticalCharacterRecognition()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsOpticalCharacterRecognition(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsOpticalCharacterRecognition\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsOriya() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsOriya(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsOriya\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsOsmanya() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsOsmanya(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsOsmanya\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsPhoneticExtensions() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsPhoneticExtensions(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsPhoneticExtensions\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsPrivateUse() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsPrivateUse(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsPrivateUse\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsPrivateUseArea() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsPrivateUseArea(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsPrivateUseArea\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsRunic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsRunic(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsRunic\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsShavian() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsShavian(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsShavian\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSinhala() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSinhala(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSinhala\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSmallFormVariants() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSmallFormVariants(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSmallFormVariants\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSpacingModifierLetters() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSpacingModifierLetters(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSpacingModifierLetters\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSpecials() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSpecials(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSpecials\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSuperscriptsandSubscripts() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSuperscriptsandSubscripts(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSuperscriptsandSubscripts\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSupplementalArrowsA() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSupplementalArrowsA(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSupplementalArrowsA\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSupplementalArrowsB() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSupplementalArrowsB(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSupplementalArrowsB\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSupplementalMathematicalOperators()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSupplementalMathematicalOperators(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSupplementalMathematicalOperators\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSupplementaryPrivateUseAreaA()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSupplementaryPrivateUseAreaA(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaA\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSupplementaryPrivateUseAreaB()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSupplementaryPrivateUseAreaB(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaB\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsSyriac() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsSyriac(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsSyriac\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsTagalog() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsTagalog(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsTagalog\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsTagbanwa() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsTagbanwa(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsTagbanwa\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsTags() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsTags(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsTags\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsTaiLe() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsTaiLe(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsTaiLe\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsTaiXuanJingSymbols() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsTaiXuanJingSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsTaiXuanJingSymbols\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsTamil() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsTamil(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsTamil\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsTelugu() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsTelugu(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsTelugu\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsThaana() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsThaana(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsThaana\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsThai() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsThai(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsThai\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsTibetan() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsTibetan(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsTibetan\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsUgaritic() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsUgaritic(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsUgaritic\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsUnifiedCanadianAboriginalSyllabics()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsUnifiedCanadianAboriginalSyllabics(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsUnifiedCanadianAboriginalSyllabics\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsVariationSelectors() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsVariationSelectors(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsVariationSelectors\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsVariationSelectorsSupplement()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsVariationSelectorsSupplement(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsVariationSelectorsSupplement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsYiRadicals() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsYiRadicals(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsYiRadicals\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsYiSyllables() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsYiSyllables(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsYiSyllables\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlUCSIsYijingHexagramSymbols() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut n_code: std::os::raw::c_int = 0;
    n_code = 0 as std::os::raw::c_int;
    while n_code < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0 as std::os::raw::c_int);
        ret_val = xmlUCSIsYijingHexagramSymbols(code);
        desret_int(ret_val);
        call_tests += 1;
        des_int(n_code, code, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlUCSIsYijingHexagramSymbols\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_code);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_code += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlunicode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlunicode : 166 of 166 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    test_ret += test_xmlUCSIsAegeanNumbers();
    test_ret += test_xmlUCSIsAlphabeticPresentationForms();
    test_ret += test_xmlUCSIsArabic();
    test_ret += test_xmlUCSIsArabicPresentationFormsA();
    test_ret += test_xmlUCSIsArabicPresentationFormsB();
    test_ret += test_xmlUCSIsArmenian();
    test_ret += test_xmlUCSIsArrows();
    test_ret += test_xmlUCSIsBasicLatin();
    test_ret += test_xmlUCSIsBengali();
    test_ret += test_xmlUCSIsBlock();
    test_ret += test_xmlUCSIsBlockElements();
    test_ret += test_xmlUCSIsBopomofo();
    test_ret += test_xmlUCSIsBopomofoExtended();
    test_ret += test_xmlUCSIsBoxDrawing();
    test_ret += test_xmlUCSIsBraillePatterns();
    test_ret += test_xmlUCSIsBuhid();
    test_ret += test_xmlUCSIsByzantineMusicalSymbols();
    test_ret += test_xmlUCSIsCJKCompatibility();
    test_ret += test_xmlUCSIsCJKCompatibilityForms();
    test_ret += test_xmlUCSIsCJKCompatibilityIdeographs();
    test_ret += test_xmlUCSIsCJKCompatibilityIdeographsSupplement();
    test_ret += test_xmlUCSIsCJKRadicalsSupplement();
    test_ret += test_xmlUCSIsCJKSymbolsandPunctuation();
    test_ret += test_xmlUCSIsCJKUnifiedIdeographs();
    test_ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionA();
    test_ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionB();
    test_ret += test_xmlUCSIsCat();
    test_ret += test_xmlUCSIsCatC();
    test_ret += test_xmlUCSIsCatCc();
    test_ret += test_xmlUCSIsCatCf();
    test_ret += test_xmlUCSIsCatCo();
    test_ret += test_xmlUCSIsCatCs();
    test_ret += test_xmlUCSIsCatL();
    test_ret += test_xmlUCSIsCatLl();
    test_ret += test_xmlUCSIsCatLm();
    test_ret += test_xmlUCSIsCatLo();
    test_ret += test_xmlUCSIsCatLt();
    test_ret += test_xmlUCSIsCatLu();
    test_ret += test_xmlUCSIsCatM();
    test_ret += test_xmlUCSIsCatMc();
    test_ret += test_xmlUCSIsCatMe();
    test_ret += test_xmlUCSIsCatMn();
    test_ret += test_xmlUCSIsCatN();
    test_ret += test_xmlUCSIsCatNd();
    test_ret += test_xmlUCSIsCatNl();
    test_ret += test_xmlUCSIsCatNo();
    test_ret += test_xmlUCSIsCatP();
    test_ret += test_xmlUCSIsCatPc();
    test_ret += test_xmlUCSIsCatPd();
    test_ret += test_xmlUCSIsCatPe();
    test_ret += test_xmlUCSIsCatPf();
    test_ret += test_xmlUCSIsCatPi();
    test_ret += test_xmlUCSIsCatPo();
    test_ret += test_xmlUCSIsCatPs();
    test_ret += test_xmlUCSIsCatS();
    test_ret += test_xmlUCSIsCatSc();
    test_ret += test_xmlUCSIsCatSk();
    test_ret += test_xmlUCSIsCatSm();
    test_ret += test_xmlUCSIsCatSo();
    test_ret += test_xmlUCSIsCatZ();
    test_ret += test_xmlUCSIsCatZl();
    test_ret += test_xmlUCSIsCatZp();
    test_ret += test_xmlUCSIsCatZs();
    test_ret += test_xmlUCSIsCherokee();
    test_ret += test_xmlUCSIsCombiningDiacriticalMarks();
    test_ret += test_xmlUCSIsCombiningDiacriticalMarksforSymbols();
    test_ret += test_xmlUCSIsCombiningHalfMarks();
    test_ret += test_xmlUCSIsCombiningMarksforSymbols();
    test_ret += test_xmlUCSIsControlPictures();
    test_ret += test_xmlUCSIsCurrencySymbols();
    test_ret += test_xmlUCSIsCypriotSyllabary();
    test_ret += test_xmlUCSIsCyrillic();
    test_ret += test_xmlUCSIsCyrillicSupplement();
    test_ret += test_xmlUCSIsDeseret();
    test_ret += test_xmlUCSIsDevanagari();
    test_ret += test_xmlUCSIsDingbats();
    test_ret += test_xmlUCSIsEnclosedAlphanumerics();
    test_ret += test_xmlUCSIsEnclosedCJKLettersandMonths();
    test_ret += test_xmlUCSIsEthiopic();
    test_ret += test_xmlUCSIsGeneralPunctuation();
    test_ret += test_xmlUCSIsGeometricShapes();
    test_ret += test_xmlUCSIsGeorgian();
    test_ret += test_xmlUCSIsGothic();
    test_ret += test_xmlUCSIsGreek();
    test_ret += test_xmlUCSIsGreekExtended();
    test_ret += test_xmlUCSIsGreekandCoptic();
    test_ret += test_xmlUCSIsGujarati();
    test_ret += test_xmlUCSIsGurmukhi();
    test_ret += test_xmlUCSIsHalfwidthandFullwidthForms();
    test_ret += test_xmlUCSIsHangulCompatibilityJamo();
    test_ret += test_xmlUCSIsHangulJamo();
    test_ret += test_xmlUCSIsHangulSyllables();
    test_ret += test_xmlUCSIsHanunoo();
    test_ret += test_xmlUCSIsHebrew();
    test_ret += test_xmlUCSIsHighPrivateUseSurrogates();
    test_ret += test_xmlUCSIsHighSurrogates();
    test_ret += test_xmlUCSIsHiragana();
    test_ret += test_xmlUCSIsIPAExtensions();
    test_ret += test_xmlUCSIsIdeographicDescriptionCharacters();
    test_ret += test_xmlUCSIsKanbun();
    test_ret += test_xmlUCSIsKangxiRadicals();
    test_ret += test_xmlUCSIsKannada();
    test_ret += test_xmlUCSIsKatakana();
    test_ret += test_xmlUCSIsKatakanaPhoneticExtensions();
    test_ret += test_xmlUCSIsKhmer();
    test_ret += test_xmlUCSIsKhmerSymbols();
    test_ret += test_xmlUCSIsLao();
    test_ret += test_xmlUCSIsLatin1Supplement();
    test_ret += test_xmlUCSIsLatinExtendedA();
    test_ret += test_xmlUCSIsLatinExtendedAdditional();
    test_ret += test_xmlUCSIsLatinExtendedB();
    test_ret += test_xmlUCSIsLetterlikeSymbols();
    test_ret += test_xmlUCSIsLimbu();
    test_ret += test_xmlUCSIsLinearBIdeograms();
    test_ret += test_xmlUCSIsLinearBSyllabary();
    test_ret += test_xmlUCSIsLowSurrogates();
    test_ret += test_xmlUCSIsMalayalam();
    test_ret += test_xmlUCSIsMathematicalAlphanumericSymbols();
    test_ret += test_xmlUCSIsMathematicalOperators();
    test_ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsA();
    test_ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsB();
    test_ret += test_xmlUCSIsMiscellaneousSymbols();
    test_ret += test_xmlUCSIsMiscellaneousSymbolsandArrows();
    test_ret += test_xmlUCSIsMiscellaneousTechnical();
    test_ret += test_xmlUCSIsMongolian();
    test_ret += test_xmlUCSIsMusicalSymbols();
    test_ret += test_xmlUCSIsMyanmar();
    test_ret += test_xmlUCSIsNumberForms();
    test_ret += test_xmlUCSIsOgham();
    test_ret += test_xmlUCSIsOldItalic();
    test_ret += test_xmlUCSIsOpticalCharacterRecognition();
    test_ret += test_xmlUCSIsOriya();
    test_ret += test_xmlUCSIsOsmanya();
    test_ret += test_xmlUCSIsPhoneticExtensions();
    test_ret += test_xmlUCSIsPrivateUse();
    test_ret += test_xmlUCSIsPrivateUseArea();
    test_ret += test_xmlUCSIsRunic();
    test_ret += test_xmlUCSIsShavian();
    test_ret += test_xmlUCSIsSinhala();
    test_ret += test_xmlUCSIsSmallFormVariants();
    test_ret += test_xmlUCSIsSpacingModifierLetters();
    test_ret += test_xmlUCSIsSpecials();
    test_ret += test_xmlUCSIsSuperscriptsandSubscripts();
    test_ret += test_xmlUCSIsSupplementalArrowsA();
    test_ret += test_xmlUCSIsSupplementalArrowsB();
    test_ret += test_xmlUCSIsSupplementalMathematicalOperators();
    test_ret += test_xmlUCSIsSupplementaryPrivateUseAreaA();
    test_ret += test_xmlUCSIsSupplementaryPrivateUseAreaB();
    test_ret += test_xmlUCSIsSyriac();
    test_ret += test_xmlUCSIsTagalog();
    test_ret += test_xmlUCSIsTagbanwa();
    test_ret += test_xmlUCSIsTags();
    test_ret += test_xmlUCSIsTaiLe();
    test_ret += test_xmlUCSIsTaiXuanJingSymbols();
    test_ret += test_xmlUCSIsTamil();
    test_ret += test_xmlUCSIsTelugu();
    test_ret += test_xmlUCSIsThaana();
    test_ret += test_xmlUCSIsThai();
    test_ret += test_xmlUCSIsTibetan();
    test_ret += test_xmlUCSIsUgaritic();
    test_ret += test_xmlUCSIsUnifiedCanadianAboriginalSyllabics();
    test_ret += test_xmlUCSIsVariationSelectors();
    test_ret += test_xmlUCSIsVariationSelectorsSupplement();
    test_ret += test_xmlUCSIsYiRadicals();
    test_ret += test_xmlUCSIsYiSyllables();
    test_ret += test_xmlUCSIsYijingHexagramSymbols();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlunicode: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlNewTextWriter() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut n_out: std::os::raw::c_int = 0;
    n_out = 0 as std::os::raw::c_int;
    while n_out < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0 as std::os::raw::c_int);
        ret_val = xmlNewTextWriter(out);
        if !ret_val.is_null() { out = 0 as xmlOutputBufferPtr }
        desret_xmlTextWriterPtr(ret_val);
        call_tests += 1;
        des_xmlOutputBufferPtr(n_out, out, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlNewTextWriter\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_out);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_out += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewTextWriterFilename() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut uri: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_uri: std::os::raw::c_int = 0;
    let mut compression: std::os::raw::c_int = 0;
    let mut n_compression: std::os::raw::c_int = 0;
    n_uri = 0 as std::os::raw::c_int;
    while n_uri < 6 as std::os::raw::c_int {
        n_compression = 0 as std::os::raw::c_int;
        while n_compression < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            uri = gen_fileoutput(n_uri, 0 as std::os::raw::c_int);
            compression = gen_int(n_compression, 1 as std::os::raw::c_int);
            ret_val = xmlNewTextWriterFilename(uri, compression);
            desret_xmlTextWriterPtr(ret_val);
            call_tests += 1;
            des_fileoutput(n_uri, uri, 0 as std::os::raw::c_int);
            des_int(n_compression, compression, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewTextWriterFilename\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_uri);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_compression);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_compression += 1
        }
        n_uri += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewTextWriterMemory() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut n_buf: std::os::raw::c_int = 0;
    let mut compression: std::os::raw::c_int = 0;
    let mut n_compression: std::os::raw::c_int = 0;
    n_buf = 0 as std::os::raw::c_int;
    while n_buf < 3 as std::os::raw::c_int {
        n_compression = 0 as std::os::raw::c_int;
        while n_compression < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            buf = gen_xmlBufferPtr(n_buf, 0 as std::os::raw::c_int);
            compression = gen_int(n_compression, 1 as std::os::raw::c_int);
            ret_val = xmlNewTextWriterMemory(buf, compression);
            desret_xmlTextWriterPtr(ret_val);
            call_tests += 1;
            des_xmlBufferPtr(n_buf, buf, 0 as std::os::raw::c_int);
            des_int(n_compression, compression, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewTextWriterMemory\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_buf);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_compression);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_compression += 1
        }
        n_buf += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewTextWriterPushParser() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut compression: std::os::raw::c_int = 0;
    let mut n_compression: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 3 as std::os::raw::c_int {
        n_compression = 0 as std::os::raw::c_int;
        while n_compression < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0 as std::os::raw::c_int);
            compression = gen_int(n_compression, 1 as std::os::raw::c_int);
            ret_val = xmlNewTextWriterPushParser(ctxt, compression);
            if !ctxt.is_null() {
                xmlFreeDoc((*ctxt).myDoc);
                (*ctxt).myDoc = 0 as xmlDocPtr
            }
            if !ret_val.is_null() { ctxt = 0 as xmlParserCtxtPtr }
            desret_xmlTextWriterPtr(ret_val);
            call_tests += 1;
            des_xmlParserCtxtPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_compression, compression, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlNewTextWriterPushParser\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_compression);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_compression += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlNewTextWriterTree() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut compression: std::os::raw::c_int = 0;
    let mut n_compression: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            n_compression = 0 as std::os::raw::c_int;
            while n_compression < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
                node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
                compression = gen_int(n_compression, 2 as std::os::raw::c_int);
                ret_val = xmlNewTextWriterTree(doc, node, compression);
                desret_xmlTextWriterPtr(ret_val);
                call_tests += 1;
                des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
                des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
                des_int(n_compression, compression, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlNewTextWriterTree\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_doc);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_compression);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_compression += 1
            }
            n_node += 1
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndAttribute(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndAttribute\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndCDATA() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndCDATA(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndCDATA\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndComment() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndComment(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndComment\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndDTD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndDTD(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndDTD\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndDTDAttlist() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndDTDAttlist(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndDTDAttlist\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndDTDElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndDTDElement(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndDTDElement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndDTDEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndDTDEntity(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndDTDEntity\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndDocument() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndDocument(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndDocument\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndElement(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndElement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterEndPI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterEndPI(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterEndPI\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterFlush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterFlush(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterFlush\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterFullEndElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterFullEndElement(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterFullEndElement\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterSetIndent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut indent: std::os::raw::c_int = 0;
    let mut n_indent: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_indent = 0 as std::os::raw::c_int;
        while n_indent < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            indent = gen_int(n_indent, 1 as std::os::raw::c_int);
            ret_val = xmlTextWriterSetIndent(writer, indent);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_int(n_indent, indent, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterSetIndent\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_indent);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_indent += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterSetIndentString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int;
        while n_str < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            str = gen_const_xmlChar_ptr(n_str, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextWriterSetIndentString(writer, str as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterSetIndentString\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_str += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterSetQuoteChar() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut quotechar: xmlChar = 0;
    let mut n_quotechar: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_quotechar = 0 as std::os::raw::c_int;
        while n_quotechar < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            quotechar = gen_xmlChar(n_quotechar, 1 as std::os::raw::c_int);
            ret_val = xmlTextWriterSetQuoteChar(writer, quotechar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_xmlChar(n_quotechar, quotechar, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterSetQuoteChar\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_quotechar);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_quotechar += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextWriterStartAttribute(writer, name as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterStartAttribute\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartAttributeNS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_namespaceURI: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_namespaceURI = 0 as std::os::raw::c_int;
                while n_namespaceURI < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                    prefix =
                        gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    namespaceURI =
                        gen_const_xmlChar_ptr(n_namespaceURI,
                                              3 as std::os::raw::c_int);
                    ret_val =
                        xmlTextWriterStartAttributeNS(writer,
                                                      prefix as
                                                          *const xmlChar,
                                                      name as *const xmlChar,
                                                      namespaceURI as
                                                          *const xmlChar);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_namespaceURI,
                                          namespaceURI as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlTextWriterStartAttributeNS\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_writer);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_prefix);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_namespaceURI);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_namespaceURI += 1
                }
                n_name += 1
            }
            n_prefix += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartCDATA() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterStartCDATA(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterStartCDATA\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartComment() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
        ret_val = xmlTextWriterStartComment(writer);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlTextWriterStartComment\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_writer);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartDTD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut pubid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubid: std::os::raw::c_int = 0;
    let mut sysid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysid: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_pubid = 0 as std::os::raw::c_int;
            while n_pubid < 5 as std::os::raw::c_int {
                n_sysid = 0 as std::os::raw::c_int;
                while n_sysid < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    pubid = gen_const_xmlChar_ptr(n_pubid, 2 as std::os::raw::c_int);
                    sysid = gen_const_xmlChar_ptr(n_sysid, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlTextWriterStartDTD(writer, name as *const xmlChar,
                                              pubid as *const xmlChar,
                                              sysid as *const xmlChar);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_pubid, pubid as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_sysid, sysid as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlTextWriterStartDTD\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_writer);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_pubid);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_sysid);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_sysid += 1
                }
                n_pubid += 1
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartDTDAttlist() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextWriterStartDTDAttlist(writer, name as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterStartDTDAttlist\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartDTDElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextWriterStartDTDElement(writer, name as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterStartDTDElement\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartDTDEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut pe: std::os::raw::c_int = 0;
    let mut n_pe: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_pe = 0 as std::os::raw::c_int;
        while n_pe < 4 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                pe = gen_int(n_pe, 1 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextWriterStartDTDEntity(writer, pe,
                                                name as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                des_int(n_pe, pe, 1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextWriterStartDTDEntity\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_writer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_pe);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_name += 1
            }
            n_pe += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartDocument() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut version: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_version: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_encoding: std::os::raw::c_int = 0;
    let mut standalone: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_standalone: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_version = 0 as std::os::raw::c_int;
        while n_version < 4 as std::os::raw::c_int {
            n_encoding = 0 as std::os::raw::c_int;
            while n_encoding < 4 as std::os::raw::c_int {
                n_standalone = 0 as std::os::raw::c_int;
                while n_standalone < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                    version = gen_const_char_ptr(n_version, 1 as std::os::raw::c_int);
                    encoding =
                        gen_const_char_ptr(n_encoding, 2 as std::os::raw::c_int);
                    standalone =
                        gen_const_char_ptr(n_standalone, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlTextWriterStartDocument(writer,
                                                   version as
                                                       *const std::os::raw::c_char,
                                                   encoding as
                                                       *const std::os::raw::c_char,
                                                   standalone as
                                                       *const std::os::raw::c_char);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                    des_const_char_ptr(n_version,
                                       version as *const std::os::raw::c_char,
                                       1 as std::os::raw::c_int);
                    des_const_char_ptr(n_encoding,
                                       encoding as *const std::os::raw::c_char,
                                       2 as std::os::raw::c_int);
                    des_const_char_ptr(n_standalone,
                                       standalone as *const std::os::raw::c_char,
                                       3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlTextWriterStartDocument\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_writer);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_version);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_encoding);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_standalone);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_standalone += 1
                }
                n_encoding += 1
            }
            n_version += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextWriterStartElement(writer, name as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterStartElement\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartElementNS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_namespaceURI: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_namespaceURI = 0 as std::os::raw::c_int;
                while n_namespaceURI < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                    prefix =
                        gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    namespaceURI =
                        gen_const_xmlChar_ptr(n_namespaceURI,
                                              3 as std::os::raw::c_int);
                    ret_val =
                        xmlTextWriterStartElementNS(writer,
                                                    prefix as *const xmlChar,
                                                    name as *const xmlChar,
                                                    namespaceURI as
                                                        *const xmlChar);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_namespaceURI,
                                          namespaceURI as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlTextWriterStartElementNS\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_writer);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_prefix);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_namespaceURI);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_namespaceURI += 1
                }
                n_name += 1
            }
            n_prefix += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterStartPI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut target: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_target: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_target = 0 as std::os::raw::c_int;
        while n_target < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            target = gen_const_xmlChar_ptr(n_target, 1 as std::os::raw::c_int);
            ret_val = xmlTextWriterStartPI(writer, target as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_target, target as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterStartPI\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_target);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_target += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_content = 0 as std::os::raw::c_int;
            while n_content < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextWriterWriteAttribute(writer,
                                                name as *const xmlChar,
                                                content as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextWriterWriteAttribute\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_writer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_content);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_content += 1
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteAttributeNS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_namespaceURI: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_namespaceURI = 0 as std::os::raw::c_int;
                while n_namespaceURI < 5 as std::os::raw::c_int {
                    n_content = 0 as std::os::raw::c_int;
                    while n_content < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        writer =
                            gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                        prefix =
                            gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                        namespaceURI =
                            gen_const_xmlChar_ptr(n_namespaceURI,
                                                  3 as std::os::raw::c_int);
                        content =
                            gen_const_xmlChar_ptr(n_content,
                                                  4 as std::os::raw::c_int);
                        ret_val =
                            xmlTextWriterWriteAttributeNS(writer,
                                                          prefix as
                                                              *const xmlChar,
                                                          name as
                                                              *const xmlChar,
                                                          namespaceURI as
                                                              *const xmlChar,
                                                          content as
                                                              *const xmlChar);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlTextWriterPtr(n_writer, writer,
                                             0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_prefix,
                                              prefix as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_namespaceURI,
                                              namespaceURI as *const xmlChar,
                                              3 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_content,
                                              content as *const xmlChar,
                                              4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlTextWriterWriteAttributeNS\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_writer);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_prefix);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_namespaceURI);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_content);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_content += 1
                    }
                    n_namespaceURI += 1
                }
                n_name += 1
            }
            n_prefix += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteBase64() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_data: std::os::raw::c_int = 0;
    let mut start: std::os::raw::c_int = 0;
    let mut n_start: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 4 as std::os::raw::c_int {
            n_start = 0 as std::os::raw::c_int;
            while n_start < 4 as std::os::raw::c_int {
                n_len = 0 as std::os::raw::c_int;
                while n_len < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                    data = gen_const_char_ptr(n_data, 1 as std::os::raw::c_int);
                    start = gen_int(n_start, 2 as std::os::raw::c_int);
                    len = gen_int(n_len, 3 as std::os::raw::c_int);
                    if !(!data.is_null() &&
                             start >
                                 strlen(data as *const std::os::raw::c_char) as
                                     std::os::raw::c_int + 1 as std::os::raw::c_int) {
                        if !(!data.is_null() &&
                                 len >
                                     strlen(data as *const std::os::raw::c_char) as
                                         std::os::raw::c_int + 1 as std::os::raw::c_int) {
                            ret_val =
                                xmlTextWriterWriteBase64(writer,
                                                         data as
                                                             *const std::os::raw::c_char,
                                                         start, len);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlTextWriterPtr(n_writer, writer,
                                                 0 as std::os::raw::c_int);
                            des_const_char_ptr(n_data,
                                               data as *const std::os::raw::c_char,
                                               1 as std::os::raw::c_int);
                            des_int(n_start, start, 2 as std::os::raw::c_int);
                            des_int(n_len, len, 3 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlTextWriterWriteBase64\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_writer);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_data);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_start);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_len);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                        }
                    }
                    n_len += 1
                }
                n_start += 1
            }
            n_data += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteBinHex() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut data: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_data: std::os::raw::c_int = 0;
    let mut start: std::os::raw::c_int = 0;
    let mut n_start: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_data = 0 as std::os::raw::c_int;
        while n_data < 4 as std::os::raw::c_int {
            n_start = 0 as std::os::raw::c_int;
            while n_start < 4 as std::os::raw::c_int {
                n_len = 0 as std::os::raw::c_int;
                while n_len < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                    data = gen_const_char_ptr(n_data, 1 as std::os::raw::c_int);
                    start = gen_int(n_start, 2 as std::os::raw::c_int);
                    len = gen_int(n_len, 3 as std::os::raw::c_int);
                    if !(!data.is_null() &&
                             start >
                                 strlen(data as *const std::os::raw::c_char) as
                                     std::os::raw::c_int + 1 as std::os::raw::c_int) {
                        if !(!data.is_null() &&
                                 len >
                                     strlen(data as *const std::os::raw::c_char) as
                                         std::os::raw::c_int + 1 as std::os::raw::c_int) {
                            ret_val =
                                xmlTextWriterWriteBinHex(writer,
                                                         data as
                                                             *const std::os::raw::c_char,
                                                         start, len);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlTextWriterPtr(n_writer, writer,
                                                 0 as std::os::raw::c_int);
                            des_const_char_ptr(n_data,
                                               data as *const std::os::raw::c_char,
                                               1 as std::os::raw::c_int);
                            des_int(n_start, start, 2 as std::os::raw::c_int);
                            des_int(n_len, len, 3 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlTextWriterWriteBinHex\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_writer);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_data);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_start);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_len);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                        }
                    }
                    n_len += 1
                }
                n_start += 1
            }
            n_data += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteCDATA() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextWriterWriteCDATA(writer, content as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterWriteCDATA\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteComment() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextWriterWriteComment(writer, content as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterWriteComment\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteDTD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut pubid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubid: std::os::raw::c_int = 0;
    let mut sysid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysid: std::os::raw::c_int = 0;
    let mut subset: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_subset: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_pubid = 0 as std::os::raw::c_int;
            while n_pubid < 5 as std::os::raw::c_int {
                n_sysid = 0 as std::os::raw::c_int;
                while n_sysid < 5 as std::os::raw::c_int {
                    n_subset = 0 as std::os::raw::c_int;
                    while n_subset < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        writer =
                            gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                        pubid =
                            gen_const_xmlChar_ptr(n_pubid, 2 as std::os::raw::c_int);
                        sysid =
                            gen_const_xmlChar_ptr(n_sysid, 3 as std::os::raw::c_int);
                        subset =
                            gen_const_xmlChar_ptr(n_subset, 4 as std::os::raw::c_int);
                        ret_val =
                            xmlTextWriterWriteDTD(writer,
                                                  name as *const xmlChar,
                                                  pubid as *const xmlChar,
                                                  sysid as *const xmlChar,
                                                  subset as *const xmlChar);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlTextWriterPtr(n_writer, writer,
                                             0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_pubid,
                                              pubid as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_sysid,
                                              sysid as *const xmlChar,
                                              3 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_subset,
                                              subset as *const xmlChar,
                                              4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlTextWriterWriteDTD\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_writer);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_pubid);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_sysid);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_subset);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_subset += 1
                    }
                    n_sysid += 1
                }
                n_pubid += 1
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteDTDAttlist() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_content = 0 as std::os::raw::c_int;
            while n_content < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextWriterWriteDTDAttlist(writer,
                                                 name as *const xmlChar,
                                                 content as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextWriterWriteDTDAttlist\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_writer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_content);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_content += 1
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteDTDElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_content = 0 as std::os::raw::c_int;
            while n_content < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextWriterWriteDTDElement(writer,
                                                 name as *const xmlChar,
                                                 content as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextWriterWriteDTDElement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_writer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_content);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_content += 1
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteDTDEntity() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut pe: std::os::raw::c_int = 0;
    let mut n_pe: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut pubid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubid: std::os::raw::c_int = 0;
    let mut sysid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysid: std::os::raw::c_int = 0;
    let mut ndataid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ndataid: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_pe = 0 as std::os::raw::c_int;
        while n_pe < 4 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_pubid = 0 as std::os::raw::c_int;
                while n_pubid < 5 as std::os::raw::c_int {
                    n_sysid = 0 as std::os::raw::c_int;
                    while n_sysid < 5 as std::os::raw::c_int {
                        n_ndataid = 0 as std::os::raw::c_int;
                        while n_ndataid < 5 as std::os::raw::c_int {
                            n_content = 0 as std::os::raw::c_int;
                            while n_content < 5 as std::os::raw::c_int {
                                mem_base = xmlMemBlocks();
                                writer =
                                    gen_xmlTextWriterPtr(n_writer,
                                                         0 as std::os::raw::c_int);
                                pe = gen_int(n_pe, 1 as std::os::raw::c_int);
                                name =
                                    gen_const_xmlChar_ptr(n_name,
                                                          2 as std::os::raw::c_int);
                                pubid =
                                    gen_const_xmlChar_ptr(n_pubid,
                                                          3 as std::os::raw::c_int);
                                sysid =
                                    gen_const_xmlChar_ptr(n_sysid,
                                                          4 as std::os::raw::c_int);
                                ndataid =
                                    gen_const_xmlChar_ptr(n_ndataid,
                                                          5 as std::os::raw::c_int);
                                content =
                                    gen_const_xmlChar_ptr(n_content,
                                                          6 as std::os::raw::c_int);
                                ret_val =
                                    xmlTextWriterWriteDTDEntity(writer, pe,
                                                                name as
                                                                    *const xmlChar,
                                                                pubid as
                                                                    *const xmlChar,
                                                                sysid as
                                                                    *const xmlChar,
                                                                ndataid as
                                                                    *const xmlChar,
                                                                content as
                                                                    *const xmlChar);
                                desret_int(ret_val);
                                call_tests += 1;
                                des_xmlTextWriterPtr(n_writer, writer,
                                                     0 as std::os::raw::c_int);
                                des_int(n_pe, pe, 1 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_name,
                                                      name as *const xmlChar,
                                                      2 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_pubid,
                                                      pubid as *const xmlChar,
                                                      3 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_sysid,
                                                      sysid as *const xmlChar,
                                                      4 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_ndataid,
                                                      ndataid as
                                                          *const xmlChar,
                                                      5 as std::os::raw::c_int);
                                des_const_xmlChar_ptr(n_content,
                                                      content as
                                                          *const xmlChar,
                                                      6 as std::os::raw::c_int);
                                xmlResetLastError();
                                if mem_base != xmlMemBlocks() {
                                    printf(b"Leak of %d blocks found in xmlTextWriterWriteDTDEntity\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char,
                                           xmlMemBlocks() - mem_base);
                                    test_ret += 1;
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_writer);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_pe);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_name);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_pubid);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char, n_sysid);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_ndataid);
                                    printf(b" %d\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           n_content);
                                    printf(b"\n\x00" as *const u8 as
                                               *const std::os::raw::c_char);
                                }
                                n_content += 1
                            }
                            n_ndataid += 1
                        }
                        n_sysid += 1
                    }
                    n_pubid += 1
                }
                n_name += 1
            }
            n_pe += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteDTDExternalEntity()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut pe: std::os::raw::c_int = 0;
    let mut n_pe: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut pubid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubid: std::os::raw::c_int = 0;
    let mut sysid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysid: std::os::raw::c_int = 0;
    let mut ndataid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ndataid: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_pe = 0 as std::os::raw::c_int;
        while n_pe < 4 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_pubid = 0 as std::os::raw::c_int;
                while n_pubid < 5 as std::os::raw::c_int {
                    n_sysid = 0 as std::os::raw::c_int;
                    while n_sysid < 5 as std::os::raw::c_int {
                        n_ndataid = 0 as std::os::raw::c_int;
                        while n_ndataid < 5 as std::os::raw::c_int {
                            mem_base = xmlMemBlocks();
                            writer =
                                gen_xmlTextWriterPtr(n_writer,
                                                     0 as std::os::raw::c_int);
                            pe = gen_int(n_pe, 1 as std::os::raw::c_int);
                            name =
                                gen_const_xmlChar_ptr(n_name,
                                                      2 as std::os::raw::c_int);
                            pubid =
                                gen_const_xmlChar_ptr(n_pubid,
                                                      3 as std::os::raw::c_int);
                            sysid =
                                gen_const_xmlChar_ptr(n_sysid,
                                                      4 as std::os::raw::c_int);
                            ndataid =
                                gen_const_xmlChar_ptr(n_ndataid,
                                                      5 as std::os::raw::c_int);
                            ret_val =
                                xmlTextWriterWriteDTDExternalEntity(writer,
                                                                    pe,
                                                                    name as
                                                                        *const xmlChar,
                                                                    pubid as
                                                                        *const xmlChar,
                                                                    sysid as
                                                                        *const xmlChar,
                                                                    ndataid as
                                                                        *const xmlChar);
                            desret_int(ret_val);
                            call_tests += 1;
                            des_xmlTextWriterPtr(n_writer, writer,
                                                 0 as std::os::raw::c_int);
                            des_int(n_pe, pe, 1 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_name,
                                                  name as *const xmlChar,
                                                  2 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_pubid,
                                                  pubid as *const xmlChar,
                                                  3 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_sysid,
                                                  sysid as *const xmlChar,
                                                  4 as std::os::raw::c_int);
                            des_const_xmlChar_ptr(n_ndataid,
                                                  ndataid as *const xmlChar,
                                                  5 as std::os::raw::c_int);
                            xmlResetLastError();
                            if mem_base != xmlMemBlocks() {
                                printf(b"Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntity\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char,
                                       xmlMemBlocks() - mem_base);
                                test_ret += 1;
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_writer);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_pe);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_name);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_pubid);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_sysid);
                                printf(b" %d\x00" as *const u8 as
                                           *const std::os::raw::c_char, n_ndataid);
                                printf(b"\n\x00" as *const u8 as
                                           *const std::os::raw::c_char);
                            }
                            n_ndataid += 1
                        }
                        n_sysid += 1
                    }
                    n_pubid += 1
                }
                n_name += 1
            }
            n_pe += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteDTDExternalEntityContents()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut pubid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubid: std::os::raw::c_int = 0;
    let mut sysid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysid: std::os::raw::c_int = 0;
    let mut ndataid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ndataid: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_pubid = 0 as std::os::raw::c_int;
        while n_pubid < 5 as std::os::raw::c_int {
            n_sysid = 0 as std::os::raw::c_int;
            while n_sysid < 5 as std::os::raw::c_int {
                n_ndataid = 0 as std::os::raw::c_int;
                while n_ndataid < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                    pubid = gen_const_xmlChar_ptr(n_pubid, 1 as std::os::raw::c_int);
                    sysid = gen_const_xmlChar_ptr(n_sysid, 2 as std::os::raw::c_int);
                    ndataid =
                        gen_const_xmlChar_ptr(n_ndataid, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlTextWriterWriteDTDExternalEntityContents(writer,
                                                                    pubid as
                                                                        *const xmlChar,
                                                                    sysid as
                                                                        *const xmlChar,
                                                                    ndataid as
                                                                        *const xmlChar);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_pubid, pubid as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_sysid, sysid as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_ndataid,
                                          ndataid as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntityContents\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_writer);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_pubid);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_sysid);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ndataid);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_ndataid += 1
                }
                n_sysid += 1
            }
            n_pubid += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteDTDInternalEntity()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut pe: std::os::raw::c_int = 0;
    let mut n_pe: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_pe = 0 as std::os::raw::c_int;
        while n_pe < 4 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_content = 0 as std::os::raw::c_int;
                while n_content < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                    pe = gen_int(n_pe, 1 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                    content =
                        gen_const_xmlChar_ptr(n_content, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlTextWriterWriteDTDInternalEntity(writer, pe,
                                                            name as
                                                                *const xmlChar,
                                                            content as
                                                                *const xmlChar);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                    des_int(n_pe, pe, 1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlTextWriterWriteDTDInternalEntity\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_writer);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_pe);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_content += 1
                }
                n_name += 1
            }
            n_pe += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteDTDNotation() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut pubid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_pubid: std::os::raw::c_int = 0;
    let mut sysid: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_sysid: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_pubid = 0 as std::os::raw::c_int;
            while n_pubid < 5 as std::os::raw::c_int {
                n_sysid = 0 as std::os::raw::c_int;
                while n_sysid < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                    name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                    pubid = gen_const_xmlChar_ptr(n_pubid, 2 as std::os::raw::c_int);
                    sysid = gen_const_xmlChar_ptr(n_sysid, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlTextWriterWriteDTDNotation(writer,
                                                      name as *const xmlChar,
                                                      pubid as *const xmlChar,
                                                      sysid as
                                                          *const xmlChar);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_pubid, pubid as *const xmlChar,
                                          2 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_sysid, sysid as *const xmlChar,
                                          3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlTextWriterWriteDTDNotation\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_writer);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_pubid);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_sysid);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_sysid += 1
                }
                n_pubid += 1
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_content = 0 as std::os::raw::c_int;
            while n_content < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextWriterWriteElement(writer, name as *const xmlChar,
                                              content as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextWriterWriteElement\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_writer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_content);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_content += 1
            }
            n_name += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteElementNS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_namespaceURI: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_name = 0 as std::os::raw::c_int;
            while n_name < 5 as std::os::raw::c_int {
                n_namespaceURI = 0 as std::os::raw::c_int;
                while n_namespaceURI < 5 as std::os::raw::c_int {
                    n_content = 0 as std::os::raw::c_int;
                    while n_content < 5 as std::os::raw::c_int {
                        mem_base = xmlMemBlocks();
                        writer =
                            gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                        prefix =
                            gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
                        name =
                            gen_const_xmlChar_ptr(n_name, 2 as std::os::raw::c_int);
                        namespaceURI =
                            gen_const_xmlChar_ptr(n_namespaceURI,
                                                  3 as std::os::raw::c_int);
                        content =
                            gen_const_xmlChar_ptr(n_content,
                                                  4 as std::os::raw::c_int);
                        ret_val =
                            xmlTextWriterWriteElementNS(writer,
                                                        prefix as
                                                            *const xmlChar,
                                                        name as
                                                            *const xmlChar,
                                                        namespaceURI as
                                                            *const xmlChar,
                                                        content as
                                                            *const xmlChar);
                        desret_int(ret_val);
                        call_tests += 1;
                        des_xmlTextWriterPtr(n_writer, writer,
                                             0 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_prefix,
                                              prefix as *const xmlChar,
                                              1 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                              2 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_namespaceURI,
                                              namespaceURI as *const xmlChar,
                                              3 as std::os::raw::c_int);
                        des_const_xmlChar_ptr(n_content,
                                              content as *const xmlChar,
                                              4 as std::os::raw::c_int);
                        xmlResetLastError();
                        if mem_base != xmlMemBlocks() {
                            printf(b"Leak of %d blocks found in xmlTextWriterWriteElementNS\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                                   xmlMemBlocks() - mem_base);
                            test_ret += 1;
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_writer);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_prefix);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_name);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_namespaceURI);
                            printf(b" %d\x00" as *const u8 as
                                       *const std::os::raw::c_char, n_content);
                            printf(b"\n\x00" as *const u8 as
                                       *const std::os::raw::c_char);
                        }
                        n_content += 1
                    }
                    n_namespaceURI += 1
                }
                n_name += 1
            }
            n_prefix += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatAttributeNS()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatCDATA() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatComment() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatDTD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatDTDAttlist()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatDTDElement()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatDTDInternalEntity()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatElementNS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatPI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatRaw() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteFormatString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the xmlTextWriterPtr */
}
unsafe extern "C" fn test_xmlTextWriterWritePI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* PI target */
    let mut mem_base: std::os::raw::c_int = 0; /* PI content */
    let mut ret_val: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    let mut writer: xmlTextWriterPtr =
        0 as *mut xmlTextWriter; /* text string */
    let mut n_writer: std::os::raw::c_int = 0; /* the xmlTextWriterPtr */
    let mut target: *mut xmlChar = 0 as *mut xmlChar; /* text string */
    let mut n_target: std::os::raw::c_int = 0; /* length of the text string */
    let mut content: *mut xmlChar =
        0 as *mut xmlChar; /* the xmlTextWriterPtr */
    let mut n_content: std::os::raw::c_int = 0; /* text string */
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_target = 0 as std::os::raw::c_int;
        while n_target < 5 as std::os::raw::c_int {
            n_content = 0 as std::os::raw::c_int;
            while n_content < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                target = gen_const_xmlChar_ptr(n_target, 1 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 2 as std::os::raw::c_int);
                ret_val =
                    xmlTextWriterWritePI(writer, target as *const xmlChar,
                                         content as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_target, target as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlTextWriterWritePI\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_writer);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_target);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_content);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_content += 1
            }
            n_target += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteRaw() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextWriterWriteRaw(writer, content as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterWriteRaw\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteRawLen() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut n_len: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            n_len = 0 as std::os::raw::c_int;
            while n_len < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
                content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
                len = gen_int(n_len, 2 as std::os::raw::c_int);
                if !(!content.is_null() &&
                         len >
                             strlen(content as *const std::os::raw::c_char) as
                                 std::os::raw::c_int + 1 as std::os::raw::c_int) {
                    ret_val =
                        xmlTextWriterWriteRawLen(writer,
                                                 content as *const xmlChar,
                                                 len);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
                    des_const_xmlChar_ptr(n_content,
                                          content as *const xmlChar,
                                          1 as std::os::raw::c_int);
                    des_int(n_len, len, 2 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlTextWriterWriteRawLen\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_writer);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_content);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_len);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                }
                n_len += 1
            }
            n_content += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut writer: xmlTextWriterPtr = 0 as *mut xmlTextWriter;
    let mut n_writer: std::os::raw::c_int = 0;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_content: std::os::raw::c_int = 0;
    n_writer = 0 as std::os::raw::c_int;
    while n_writer < 2 as std::os::raw::c_int {
        n_content = 0 as std::os::raw::c_int;
        while n_content < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            writer = gen_xmlTextWriterPtr(n_writer, 0 as std::os::raw::c_int);
            content = gen_const_xmlChar_ptr(n_content, 1 as std::os::raw::c_int);
            ret_val =
                xmlTextWriterWriteString(writer, content as *const xmlChar);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlTextWriterPtr(n_writer, writer, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_content, content as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlTextWriterWriteString\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_writer);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_content);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_content += 1
        }
        n_writer += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatAttribute()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatAttributeNS()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatCDATA() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatComment() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatDTD() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatDTDAttlist()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatDTDElement()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatDTDInternalEntity()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatElement() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatElementNS()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatPI() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatRaw() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlTextWriterWriteVFormatString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a boolean */
}
unsafe extern "C" fn test_xmlwriter() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* a boolean */
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xmlwriter : 52 of 80 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char); /* a node-set */
    } /* a node-set */
    test_ret += test_xmlNewTextWriter(); /* a node-set */
    test_ret += test_xmlNewTextWriterFilename(); /* a node */
    test_ret += test_xmlNewTextWriterMemory(); /* a node */
    test_ret += test_xmlNewTextWriterPushParser(); /* a number */
    test_ret += test_xmlNewTextWriterTree(); /* a number */
    test_ret += test_xmlTextWriterEndAttribute(); /* a string */
    test_ret += test_xmlTextWriterEndCDATA(); /* a string */
    test_ret += test_xmlTextWriterEndComment(); /* an XPath object */
    test_ret += test_xmlTextWriterEndDTD(); /* an XPath object */
    test_ret += test_xmlTextWriterEndDTDAttlist(); /* an XPath object */
    test_ret += test_xmlTextWriterEndDTDElement(); /* the first node */
    test_ret += test_xmlTextWriterEndDTDEntity(); /* the second node */
    test_ret += test_xmlTextWriterEndDocument();
    test_ret += test_xmlTextWriterEndElement();
    test_ret += test_xmlTextWriterEndPI();
    test_ret += test_xmlTextWriterFlush();
    test_ret += test_xmlTextWriterFullEndElement();
    test_ret += test_xmlTextWriterSetIndent();
    test_ret += test_xmlTextWriterSetIndentString();
    test_ret += test_xmlTextWriterSetQuoteChar();
    test_ret += test_xmlTextWriterStartAttribute();
    test_ret += test_xmlTextWriterStartAttributeNS();
    test_ret += test_xmlTextWriterStartCDATA();
    test_ret += test_xmlTextWriterStartComment();
    test_ret += test_xmlTextWriterStartDTD();
    test_ret += test_xmlTextWriterStartDTDAttlist();
    test_ret += test_xmlTextWriterStartDTDElement();
    test_ret += test_xmlTextWriterStartDTDEntity();
    test_ret += test_xmlTextWriterStartDocument();
    test_ret += test_xmlTextWriterStartElement();
    test_ret += test_xmlTextWriterStartElementNS();
    test_ret += test_xmlTextWriterStartPI();
    test_ret += test_xmlTextWriterWriteAttribute();
    test_ret += test_xmlTextWriterWriteAttributeNS();
    test_ret += test_xmlTextWriterWriteBase64();
    test_ret += test_xmlTextWriterWriteBinHex();
    test_ret += test_xmlTextWriterWriteCDATA();
    test_ret += test_xmlTextWriterWriteComment();
    test_ret += test_xmlTextWriterWriteDTD();
    test_ret += test_xmlTextWriterWriteDTDAttlist();
    test_ret += test_xmlTextWriterWriteDTDElement();
    test_ret += test_xmlTextWriterWriteDTDEntity();
    test_ret += test_xmlTextWriterWriteDTDExternalEntity();
    test_ret += test_xmlTextWriterWriteDTDExternalEntityContents();
    test_ret += test_xmlTextWriterWriteDTDInternalEntity();
    test_ret += test_xmlTextWriterWriteDTDNotation();
    test_ret += test_xmlTextWriterWriteElement();
    test_ret += test_xmlTextWriterWriteElementNS();
    test_ret += test_xmlTextWriterWriteFormatAttribute();
    test_ret += test_xmlTextWriterWriteFormatAttributeNS();
    test_ret += test_xmlTextWriterWriteFormatCDATA();
    test_ret += test_xmlTextWriterWriteFormatComment();
    test_ret += test_xmlTextWriterWriteFormatDTD();
    test_ret += test_xmlTextWriterWriteFormatDTDAttlist();
    test_ret += test_xmlTextWriterWriteFormatDTDElement();
    test_ret += test_xmlTextWriterWriteFormatDTDInternalEntity();
    test_ret += test_xmlTextWriterWriteFormatElement();
    test_ret += test_xmlTextWriterWriteFormatElementNS();
    test_ret += test_xmlTextWriterWriteFormatPI();
    test_ret += test_xmlTextWriterWriteFormatRaw();
    test_ret += test_xmlTextWriterWriteFormatString();
    test_ret += test_xmlTextWriterWritePI();
    test_ret += test_xmlTextWriterWriteRaw();
    test_ret += test_xmlTextWriterWriteRawLen();
    test_ret += test_xmlTextWriterWriteString();
    test_ret += test_xmlTextWriterWriteVFormatAttribute();
    test_ret += test_xmlTextWriterWriteVFormatAttributeNS();
    test_ret += test_xmlTextWriterWriteVFormatCDATA();
    test_ret += test_xmlTextWriterWriteVFormatComment();
    test_ret += test_xmlTextWriterWriteVFormatDTD();
    test_ret += test_xmlTextWriterWriteVFormatDTDAttlist();
    test_ret += test_xmlTextWriterWriteVFormatDTDElement();
    test_ret += test_xmlTextWriterWriteVFormatDTDInternalEntity();
    test_ret += test_xmlTextWriterWriteVFormatElement();
    test_ret += test_xmlTextWriterWriteVFormatElementNS();
    test_ret += test_xmlTextWriterWriteVFormatPI();
    test_ret += test_xmlTextWriterWriteVFormatRaw();
    test_ret += test_xmlTextWriterWriteVFormatString();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xmlwriter: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastBooleanToNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_double = 0.;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastBooleanToNumber(val);
        desret_double(ret_val);
        call_tests += 1;
        des_int(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastBooleanToNumber\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastBooleanToString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastBooleanToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_int(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastBooleanToString\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastNodeSetToBoolean() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ns: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_ns: std::os::raw::c_int = 0;
    n_ns = 0 as std::os::raw::c_int;
    while n_ns < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNodeSetPtr(n_ns, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastNodeSetToBoolean(ns);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlNodeSetPtr(n_ns, ns, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastNodeSetToBoolean\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ns);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ns += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastNodeSetToNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_double = 0.;
    let mut ns: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_ns: std::os::raw::c_int = 0;
    n_ns = 0 as std::os::raw::c_int;
    while n_ns < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNodeSetPtr(n_ns, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastNodeSetToNumber(ns);
        desret_double(ret_val);
        call_tests += 1;
        des_xmlNodeSetPtr(n_ns, ns, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastNodeSetToNumber\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ns);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ns += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastNodeSetToString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ns: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_ns: std::os::raw::c_int = 0;
    n_ns = 0 as std::os::raw::c_int;
    while n_ns < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNodeSetPtr(n_ns, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastNodeSetToString(ns);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlNodeSetPtr(n_ns, ns, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastNodeSetToString\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ns);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ns += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastNodeToNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_double = 0.;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastNodeToNumber(node);
        desret_double(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastNodeToNumber\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_node);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastNodeToString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastNodeToString(node);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastNodeToString\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_node);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastNumberToBoolean() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_double = 0.;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastNumberToBoolean(val);
        desret_int(ret_val);
        call_tests += 1;
        des_double(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastNumberToBoolean\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastNumberToString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: std::os::raw::c_double = 0.;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastNumberToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_double(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastNumberToString\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastStringToBoolean() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastStringToBoolean(val as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_val, val as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastStringToBoolean\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastStringToNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_double = 0.;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastStringToNumber(val as *const xmlChar);
        desret_double(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_val, val as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastStringToNumber\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastToBoolean() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastToBoolean(val);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlXPathObjectPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastToBoolean\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastToNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_double = 0.;
    let mut val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastToNumber(val);
        desret_double(ret_val);
        call_tests += 1;
        des_xmlXPathObjectPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastToNumber\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCastToString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathCastToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlXPathObjectPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathCastToString\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCmpNodes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut node1: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node1: std::os::raw::c_int = 0;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node2: std::os::raw::c_int = 0;
    n_node1 = 0 as std::os::raw::c_int;
    while n_node1 < 3 as std::os::raw::c_int {
        n_node2 = 0 as std::os::raw::c_int;
        while n_node2 < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            node1 = gen_xmlNodePtr(n_node1, 0 as std::os::raw::c_int);
            node2 = gen_xmlNodePtr(n_node2, 1 as std::os::raw::c_int);
            ret_val = xmlXPathCmpNodes(node1, node2);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_node1, node1, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_node2, node2, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathCmpNodes\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node2 += 1
        }
        n_node1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCompile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the compiled XPath expression */
}
unsafe extern "C" fn gen_xmlXPathCompExprPtr(mut no: std::os::raw::c_int,
                                             mut nr: std::os::raw::c_int)
 -> xmlXPathCompExprPtr {
    return 0 as xmlXPathCompExprPtr; /* the XPath context */
}
unsafe extern "C" fn des_xmlXPathCompExprPtr(mut no: std::os::raw::c_int,
                                             mut val: xmlXPathCompExprPtr,
                                             mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn gen_xmlXPathContextPtr(mut no: std::os::raw::c_int,
                                            mut nr: std::os::raw::c_int)
 -> xmlXPathContextPtr {
    return 0 as xmlXPathContextPtr; /* the compiled XPath expression */
}
unsafe extern "C" fn des_xmlXPathContextPtr(mut no: std::os::raw::c_int,
                                            mut val: xmlXPathContextPtr,
                                            mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlXPathCompiledEval() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the XPath context */
    let mut mem_base: std::os::raw::c_int = 0; /* the XPath context */
    let mut ret_val: xmlXPathObjectPtr =
        0 as
            *mut xmlXPathObject; /* enables/disables (creates/frees) the cache */
    let mut comp: xmlXPathCompExprPtr =
        0 as
            *mut xmlXPathCompExpr; /* a value with semantics dependant on @options */
    let mut n_comp: std::os::raw::c_int =
        0; /* options (currently only the value 0 is used) */
    let mut ctx: xmlXPathContextPtr =
        0 as *mut xmlXPathContext; /* an XPath object */
    let mut n_ctx: std::os::raw::c_int = 0; /* an XPath object */
    n_comp = 0 as std::os::raw::c_int; /* an XPath object */
    while n_comp < 1 as std::os::raw::c_int {
        n_ctx = 0 as std::os::raw::c_int;
        while n_ctx < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            comp = gen_xmlXPathCompExprPtr(n_comp, 0 as std::os::raw::c_int);
            ctx = gen_xmlXPathContextPtr(n_ctx, 1 as std::os::raw::c_int);
            ret_val = xmlXPathCompiledEval(comp, ctx);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_xmlXPathCompExprPtr(n_comp, comp, 0 as std::os::raw::c_int);
            des_xmlXPathContextPtr(n_ctx, ctx, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathCompiledEval\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_comp);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ctx += 1
        }
        n_comp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCompiledEvalToBoolean() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut comp: xmlXPathCompExprPtr = 0 as *mut xmlXPathCompExpr;
    let mut n_comp: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_comp = 0 as std::os::raw::c_int;
    while n_comp < 1 as std::os::raw::c_int {
        n_ctxt = 0 as std::os::raw::c_int;
        while n_ctxt < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            comp = gen_xmlXPathCompExprPtr(n_comp, 0 as std::os::raw::c_int);
            ctxt = gen_xmlXPathContextPtr(n_ctxt, 1 as std::os::raw::c_int);
            ret_val = xmlXPathCompiledEvalToBoolean(comp, ctxt);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlXPathCompExprPtr(n_comp, comp, 0 as std::os::raw::c_int);
            des_xmlXPathContextPtr(n_ctxt, ctxt, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathCompiledEvalToBoolean\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_comp);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ctxt += 1
        }
        n_comp += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathContextSetCache() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut active: std::os::raw::c_int = 0;
    let mut n_active: std::os::raw::c_int = 0;
    let mut value: std::os::raw::c_int = 0;
    let mut n_value: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    let mut n_options: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_active = 0 as std::os::raw::c_int;
        while n_active < 4 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int;
            while n_value < 4 as std::os::raw::c_int {
                n_options = 0 as std::os::raw::c_int;
                while n_options < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
                    active = gen_int(n_active, 1 as std::os::raw::c_int);
                    value = gen_int(n_value, 2 as std::os::raw::c_int);
                    options = gen_int(n_options, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlXPathContextSetCache(ctxt, active, value, options);
                    desret_int(ret_val);
                    call_tests += 1;
                    des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                    des_int(n_active, active, 1 as std::os::raw::c_int);
                    des_int(n_value, value, 2 as std::os::raw::c_int);
                    des_int(n_options, options, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlXPathContextSetCache\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_active);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_options);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_options += 1
                }
                n_value += 1
            }
            n_active += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathConvertBoolean() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathConvertBoolean(val);
        val = 0 as xmlXPathObjectPtr;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlXPathObjectPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathConvertBoolean\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathConvertNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathConvertNumber(val);
        val = 0 as xmlXPathObjectPtr;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlXPathObjectPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathConvertNumber\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathConvertString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathConvertString(val);
        val = 0 as xmlXPathObjectPtr;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlXPathObjectPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathConvertString\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCtxtCompile() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the XPath expression */
}
unsafe extern "C" fn test_xmlXPathEval() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the XPath context */
    let mut mem_base: std::os::raw::c_int = 0; /* the XPath expression */
    let mut ret_val: xmlXPathObjectPtr =
        0 as *mut xmlXPathObject; /* the XPath context */
    let mut str: *mut xmlChar = 0 as *mut xmlChar; /* the XPath context */
    let mut n_str: std::os::raw::c_int =
        0; /* the Predicate Expression evaluation result */
    let mut ctx: xmlXPathContextPtr =
        0 as *mut xmlXPathContext; /* a double value */
    let mut n_ctx: std::os::raw::c_int = 0; /* a double value */
    n_str = 0 as std::os::raw::c_int;
    while n_str < 5 as std::os::raw::c_int {
        n_ctx = 0 as std::os::raw::c_int;
        while n_ctx < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            str = gen_const_xmlChar_ptr(n_str, 0 as std::os::raw::c_int);
            ctx = gen_xmlXPathContextPtr(n_ctx, 1 as std::os::raw::c_int);
            ret_val = xmlXPathEval(str as *const xmlChar, ctx);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_xmlXPathContextPtr(n_ctx, ctx, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathEval\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ctx += 1
        }
        n_str += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathEvalExpression() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_str = 0 as std::os::raw::c_int;
    while n_str < 5 as std::os::raw::c_int {
        n_ctxt = 0 as std::os::raw::c_int;
        while n_ctxt < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            str = gen_const_xmlChar_ptr(n_str, 0 as std::os::raw::c_int);
            ctxt = gen_xmlXPathContextPtr(n_ctxt, 1 as std::os::raw::c_int);
            ret_val = xmlXPathEvalExpression(str as *const xmlChar, ctxt);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_xmlXPathContextPtr(n_ctxt, ctxt, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathEvalExpression\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ctxt += 1
        }
        n_str += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathEvalPredicate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut res: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_res: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_res = 0 as std::os::raw::c_int;
        while n_res < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            res = gen_xmlXPathObjectPtr(n_res, 1 as std::os::raw::c_int);
            ret_val = xmlXPathEvalPredicate(ctxt, res);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlXPathObjectPtr(n_res, res, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathEvalPredicate\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_res);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_res += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathInit() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    mem_base = xmlMemBlocks();
    xmlXPathInit();
    call_tests += 1;
    xmlResetLastError();
    if mem_base != xmlMemBlocks() {
        printf(b"Leak of %d blocks found in xmlXPathInit\x00" as *const u8 as
                   *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
        test_ret += 1;
        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathIsInf() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_double = 0.;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathIsInf(val);
        desret_int(ret_val);
        call_tests += 1;
        des_double(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathIsInf\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathIsNaN() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_double = 0.;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathIsNaN(val);
        desret_int(ret_val);
        call_tests += 1;
        des_double(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathIsNaN\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNewContext() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the node to to use as the context node */
}
unsafe extern "C" fn test_xmlXPathNodeEval() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the XPath expression */
    let mut mem_base: std::os::raw::c_int = 0; /* the XPath context */
    let mut ret_val: xmlXPathObjectPtr =
        0 as *mut xmlXPathObject; /* an initial xmlNodePtr, or NULL */
    let mut node: xmlNodePtr = 0 as *mut xmlNode; /* the original object */
    let mut n_node: std::os::raw::c_int = 0; /* an input document */
    let mut str: *mut xmlChar =
        0 as *mut xmlChar; /* the node to to use as the context node */
    let mut n_str: std::os::raw::c_int = 0; /* the XPath context */
    let mut ctx: xmlXPathContextPtr =
        0 as *mut xmlXPathContext; /* an XPath evaluation context */
    let mut n_ctx: std::os::raw::c_int = 0; /* an XPath evaluation context */
    n_node = 0 as std::os::raw::c_int; /* the XPath object */
    while n_node < 3 as std::os::raw::c_int {
        n_str = 0 as std::os::raw::c_int; /* the XPath Parser context */
        while n_str < 5 as std::os::raw::c_int {
            n_ctx = 0 as std::os::raw::c_int; /* the XPath Parser context */
            while n_ctx < 1 as std::os::raw::c_int {
                mem_base = xmlMemBlocks(); /* the number of arguments */
                node =
                    gen_xmlNodePtr(n_node,
                                   0 as
                                       std::os::raw::c_int); /* the XPath Parser context */
                str =
                    gen_const_xmlChar_ptr(n_str,
                                          1 as
                                              std::os::raw::c_int); /* the number of arguments */
                ctx =
                    gen_xmlXPathContextPtr(n_ctx,
                                           2 as
                                               std::os::raw::c_int); /* the XPath Parser context */
                ret_val =
                    xmlXPathNodeEval(node, str as *const xmlChar,
                                     ctx); /* less than (1) or greater than (0) */
                desret_xmlXPathObjectPtr(ret_val); /* is the comparison strict */
                call_tests += 1; /* the XPath Parser context */
                des_xmlNodePtr(n_node, node,
                               0 as
                                   std::os::raw::c_int); /* the number of arguments */
                des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                      1 as
                                          std::os::raw::c_int); /* the XPath Parser context */
                des_xmlXPathContextPtr(n_ctx, ctx,
                                       2 as
                                           std::os::raw::c_int); /* the number of arguments */
                xmlResetLastError(); /* the XPath Parser context */
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXPathNodeEval\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() -
                               mem_base); /* the number of arguments */
                    test_ret += 1; /* the FILE * for the output */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node); /* the precompiled XPath expression */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_str); /* the indentation level. */
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctx); /* the FILE * to dump the output */
                    printf(b"\n\x00" as *const u8 as
                               *const std::os::raw::c_char); /* the object to inspect */
                } /* indentation level */
                n_ctx += 1
            } /* a node-set */
            n_str += 1
        } /* a node-set */
        n_node += 1
    } /* a node-set */
    function_tests += 1; /* a node-set, sorted by document order */
    return test_ret; /* the XPath Parser context */
}
unsafe extern "C" fn test_xmlXPathNodeSetCreate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the XPath Parser context */
    let mut mem_base: std::os::raw::c_int = 0; /* a XPath parser context */
    let mut ret_val: xmlNodeSetPtr =
        0 as *mut xmlNodeSet; /* the error code */
    let mut val: xmlNodePtr =
        0 as *mut xmlNode; /* the XPath Parser context */
    let mut n_val: std::os::raw::c_int = 0; /* the XPath Parser context */
    n_val = 0 as std::os::raw::c_int; /* the Predicate Expression evaluation result */
    while n_val < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the XPath Parser context */
        val =
            gen_xmlNodePtr(n_val,
                           0 as std::os::raw::c_int); /* the number of arguments */
        ret_val = xmlXPathNodeSetCreate(val); /* the XPath Parser context */
        desret_xmlNodeSetPtr(ret_val); /* the number of arguments */
        call_tests += 1;
        des_xmlNodePtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathNodeSetCreate\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathObjectCopy() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathObjectCopy(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlXPathObjectPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathObjectCopy\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathOrderDocElems() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_long = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut n_doc: std::os::raw::c_int = 0;
    n_doc = 0 as std::os::raw::c_int;
    while n_doc < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0 as std::os::raw::c_int);
        ret_val = xmlXPathOrderDocElems(doc);
        desret_long(ret_val);
        call_tests += 1;
        des_xmlDocPtr(n_doc, doc, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathOrderDocElems\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_doc);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_doc += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathSetContextNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut ctx: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_node = 0 as std::os::raw::c_int;
    while n_node < 3 as std::os::raw::c_int {
        n_ctx = 0 as std::os::raw::c_int;
        while n_ctx < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            node = gen_xmlNodePtr(n_node, 0 as std::os::raw::c_int);
            ctx = gen_xmlXPathContextPtr(n_ctx, 1 as std::os::raw::c_int);
            ret_val = xmlXPathSetContextNode(node, ctx);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_node, node, 0 as std::os::raw::c_int);
            des_xmlXPathContextPtr(n_ctx, ctx, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathSetContextNode\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ctx += 1
        }
        n_node += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xpath() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xpath : 32 of 40 functions ...\n\x00" as *const u8 as
                   *const std::os::raw::c_char);
    }
    test_ret += test_xmlXPathCastBooleanToNumber();
    test_ret += test_xmlXPathCastBooleanToString();
    test_ret += test_xmlXPathCastNodeSetToBoolean();
    test_ret += test_xmlXPathCastNodeSetToNumber();
    test_ret += test_xmlXPathCastNodeSetToString();
    test_ret += test_xmlXPathCastNodeToNumber();
    test_ret += test_xmlXPathCastNodeToString();
    test_ret += test_xmlXPathCastNumberToBoolean();
    test_ret += test_xmlXPathCastNumberToString();
    test_ret += test_xmlXPathCastStringToBoolean();
    test_ret += test_xmlXPathCastStringToNumber();
    test_ret += test_xmlXPathCastToBoolean();
    test_ret += test_xmlXPathCastToNumber();
    test_ret += test_xmlXPathCastToString();
    test_ret += test_xmlXPathCmpNodes();
    test_ret += test_xmlXPathCompile();
    test_ret += test_xmlXPathCompiledEval();
    test_ret += test_xmlXPathCompiledEvalToBoolean();
    test_ret += test_xmlXPathContextSetCache();
    test_ret += test_xmlXPathConvertBoolean();
    test_ret += test_xmlXPathConvertNumber();
    test_ret += test_xmlXPathConvertString();
    test_ret += test_xmlXPathCtxtCompile();
    test_ret += test_xmlXPathEval();
    test_ret += test_xmlXPathEvalExpression();
    test_ret += test_xmlXPathEvalPredicate();
    test_ret += test_xmlXPathInit();
    test_ret += test_xmlXPathIsInf();
    test_ret += test_xmlXPathIsNaN();
    test_ret += test_xmlXPathNewContext();
    test_ret += test_xmlXPathNodeEval();
    test_ret += test_xmlXPathNodeSetCreate();
    test_ret += test_xmlXPathObjectCopy();
    test_ret += test_xmlXPathOrderDocElems();
    test_ret += test_xmlXPathSetContextNode();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xpath: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn gen_xmlXPathParserContextPtr(mut no: std::os::raw::c_int,
                                                  mut nr: std::os::raw::c_int)
 -> xmlXPathParserContextPtr {
    return 0 as xmlXPathParserContextPtr;
}
unsafe extern "C" fn des_xmlXPathParserContextPtr(mut no: std::os::raw::c_int,
                                                  mut val:
                                                      xmlXPathParserContextPtr,
                                                  mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_valuePop() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = valuePop(ctxt);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in valuePop\x00" as *const u8 as
                       *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_valuePush() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut value: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_value: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_value = 0 as std::os::raw::c_int;
        while n_value < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            value = gen_xmlXPathObjectPtr(n_value, 1 as std::os::raw::c_int);
            ret_val = valuePush(ctxt, value);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlXPathObjectPtr(n_value, value, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in valuePush\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_value);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_value += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathAddValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathAddValues(ctxt);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathAddValues\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathBooleanFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathBooleanFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathBooleanFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCeilingFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathCeilingFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathCeilingFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCompareValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut inf: std::os::raw::c_int = 0;
    let mut n_inf: std::os::raw::c_int = 0;
    let mut strict: std::os::raw::c_int = 0;
    let mut n_strict: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_inf = 0 as std::os::raw::c_int;
        while n_inf < 4 as std::os::raw::c_int {
            n_strict = 0 as std::os::raw::c_int;
            while n_strict < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
                inf = gen_int(n_inf, 1 as std::os::raw::c_int);
                strict = gen_int(n_strict, 2 as std::os::raw::c_int);
                ret_val = xmlXPathCompareValues(ctxt, inf, strict);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_int(n_inf, inf, 1 as std::os::raw::c_int);
                des_int(n_strict, strict, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXPathCompareValues\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_inf);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_strict);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_strict += 1
            }
            n_inf += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathConcatFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathConcatFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathConcatFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathContainsFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathContainsFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathContainsFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathCountFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathCountFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathCountFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathDebugDumpCompExpr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut comp: xmlXPathCompExprPtr = 0 as *mut xmlXPathCompExpr;
    let mut n_comp: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_comp = 0 as std::os::raw::c_int;
        while n_comp < 1 as std::os::raw::c_int {
            n_depth = 0 as std::os::raw::c_int;
            while n_depth < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                output = gen_FILE_ptr(n_output, 0 as std::os::raw::c_int);
                comp = gen_xmlXPathCompExprPtr(n_comp, 1 as std::os::raw::c_int);
                depth = gen_int(n_depth, 2 as std::os::raw::c_int);
                xmlXPathDebugDumpCompExpr(output, comp, depth);
                call_tests += 1;
                des_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
                des_xmlXPathCompExprPtr(n_comp, comp, 1 as std::os::raw::c_int);
                des_int(n_depth, depth, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXPathDebugDumpCompExpr\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_output);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_comp);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_depth);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_depth += 1
            }
            n_comp += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathDebugDumpObject() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut n_output: std::os::raw::c_int = 0;
    let mut cur: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut n_depth: std::os::raw::c_int = 0;
    n_output = 0 as std::os::raw::c_int;
    while n_output < 2 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 5 as std::os::raw::c_int {
            n_depth = 0 as std::os::raw::c_int;
            while n_depth < 4 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                output = gen_FILE_ptr(n_output, 0 as std::os::raw::c_int);
                cur = gen_xmlXPathObjectPtr(n_cur, 1 as std::os::raw::c_int);
                depth = gen_int(n_depth, 2 as std::os::raw::c_int);
                xmlXPathDebugDumpObject(output, cur, depth);
                call_tests += 1;
                des_FILE_ptr(n_output, output, 0 as std::os::raw::c_int);
                des_xmlXPathObjectPtr(n_cur, cur, 1 as std::os::raw::c_int);
                des_int(n_depth, depth, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXPathDebugDumpObject\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_output);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_depth);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_depth += 1
            }
            n_cur += 1
        }
        n_output += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathDifference() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes1: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes1: std::os::raw::c_int = 0;
    let mut nodes2: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes2: std::os::raw::c_int = 0;
    n_nodes1 = 0 as std::os::raw::c_int;
    while n_nodes1 < 1 as std::os::raw::c_int {
        n_nodes2 = 0 as std::os::raw::c_int;
        while n_nodes2 < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0 as std::os::raw::c_int);
            nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1 as std::os::raw::c_int);
            ret_val = xmlXPathDifference(nodes1, nodes2);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes1, nodes1, 0 as std::os::raw::c_int);
            des_xmlNodeSetPtr(n_nodes2, nodes2, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathDifference\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nodes2 += 1
        }
        n_nodes1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathDistinct() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes: std::os::raw::c_int = 0;
    n_nodes = 0 as std::os::raw::c_int;
    while n_nodes < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        nodes = gen_xmlNodeSetPtr(n_nodes, 0 as std::os::raw::c_int);
        ret_val = xmlXPathDistinct(nodes);
        desret_xmlNodeSetPtr(ret_val);
        call_tests += 1;
        des_xmlNodeSetPtr(n_nodes, nodes, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathDistinct\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_nodes);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_nodes += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathDistinctSorted() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes: std::os::raw::c_int = 0;
    n_nodes = 0 as std::os::raw::c_int;
    while n_nodes < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        nodes = gen_xmlNodeSetPtr(n_nodes, 0 as std::os::raw::c_int);
        ret_val = xmlXPathDistinctSorted(nodes);
        desret_xmlNodeSetPtr(ret_val);
        call_tests += 1;
        des_xmlNodeSetPtr(n_nodes, nodes, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathDistinctSorted\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_nodes);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_nodes += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathDivValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathDivValues(ctxt);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathDivValues\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathEqualValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlXPathEqualValues(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathEqualValues\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathErr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut error: std::os::raw::c_int = 0;
    let mut n_error: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_error = 0 as std::os::raw::c_int;
        while n_error < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            error = gen_int(n_error, 1 as std::os::raw::c_int);
            xmlXPathErr(ctxt, error);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_error, error, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathErr\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_error);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_error += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathEvalExpr() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathEvalExpr(ctxt);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathEvalExpr\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathEvaluatePredicateResult() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut res: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_res: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_res = 0 as std::os::raw::c_int;
        while n_res < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            res = gen_xmlXPathObjectPtr(n_res, 1 as std::os::raw::c_int);
            ret_val = xmlXPathEvaluatePredicateResult(ctxt, res);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlXPathObjectPtr(n_res, res, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathEvaluatePredicateResult\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_res);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_res += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathFalseFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathFalseFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathFalseFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathFloorFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathFloorFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathFloorFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathFunctionLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathFunctionLookupNS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a node-set */
}
unsafe extern "C" fn test_xmlXPathHasSameNodes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* a node-set */
    let mut mem_base: std::os::raw::c_int = 0; /* the XPath Parser context */
    let mut ret_val: std::os::raw::c_int = 0; /* the number of arguments */
    let mut nodes1: xmlNodeSetPtr = 0 as *mut xmlNodeSet; /* a node-set */
    let mut n_nodes1: std::os::raw::c_int = 0; /* a node-set */
    let mut nodes2: xmlNodeSetPtr = 0 as *mut xmlNodeSet; /* a name string */
    let mut n_nodes2: std::os::raw::c_int = 0; /* the XPath Parser context */
    n_nodes1 = 0 as std::os::raw::c_int; /* the number of arguments */
    while n_nodes1 < 1 as std::os::raw::c_int {
        n_nodes2 = 0 as std::os::raw::c_int; /* the XPath Parser context */
        while n_nodes2 < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the number of arguments */
            nodes1 =
                gen_xmlNodeSetPtr(n_nodes1,
                                  0 as std::os::raw::c_int); /* a node-set */
            nodes2 =
                gen_xmlNodeSetPtr(n_nodes2,
                                  1 as std::os::raw::c_int); /* a node-set */
            ret_val =
                xmlXPathHasSameNodes(nodes1,
                                     nodes2); /* a node-set, sorted by document order */
            desret_int(ret_val); /* a node-set, sorted by document order */
            call_tests += 1; /* the XPath Parser context */
            des_xmlNodeSetPtr(n_nodes1, nodes1,
                              0 as std::os::raw::c_int); /* the number of arguments */
            des_xmlNodeSetPtr(n_nodes2, nodes2,
                              1 as
                                  std::os::raw::c_int); /* the XPath Parser context */
            xmlResetLastError(); /* the XPath Parser context */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathHasSameNodes\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the XPath Parser context */
                test_ret += 1; /* the number of arguments */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes1); /* the boolean value */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes2); /* the char * value */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the double value */
            } /* the NodePtr value */
            n_nodes2 += 1
        } /* an existing NodeSet */
        n_nodes1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathIdFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathIdFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathIdFunction\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathIntersection() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes1: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes1: std::os::raw::c_int = 0;
    let mut nodes2: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes2: std::os::raw::c_int = 0;
    n_nodes1 = 0 as std::os::raw::c_int;
    while n_nodes1 < 1 as std::os::raw::c_int {
        n_nodes2 = 0 as std::os::raw::c_int;
        while n_nodes2 < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0 as std::os::raw::c_int);
            nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1 as std::os::raw::c_int);
            ret_val = xmlXPathIntersection(nodes1, nodes2);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes1, nodes1, 0 as std::os::raw::c_int);
            des_xmlNodeSetPtr(n_nodes2, nodes2, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathIntersection\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nodes2 += 1
        }
        n_nodes1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathIsNodeType() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_name = 0 as std::os::raw::c_int;
    while n_name < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0 as std::os::raw::c_int);
        ret_val = xmlXPathIsNodeType(name as *const xmlChar);
        desret_int(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                              0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathIsNodeType\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_name);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_name += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathLangFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathLangFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathLangFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathLastFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathLastFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathLastFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathLeading() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes1: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes1: std::os::raw::c_int = 0;
    let mut nodes2: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes2: std::os::raw::c_int = 0;
    n_nodes1 = 0 as std::os::raw::c_int;
    while n_nodes1 < 1 as std::os::raw::c_int {
        n_nodes2 = 0 as std::os::raw::c_int;
        while n_nodes2 < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0 as std::os::raw::c_int);
            nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1 as std::os::raw::c_int);
            ret_val = xmlXPathLeading(nodes1, nodes2);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes1, nodes1, 0 as std::os::raw::c_int);
            des_xmlNodeSetPtr(n_nodes2, nodes2, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathLeading\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nodes2 += 1
        }
        n_nodes1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathLeadingSorted() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes1: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes1: std::os::raw::c_int = 0;
    let mut nodes2: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes2: std::os::raw::c_int = 0;
    n_nodes1 = 0 as std::os::raw::c_int;
    while n_nodes1 < 1 as std::os::raw::c_int {
        n_nodes2 = 0 as std::os::raw::c_int;
        while n_nodes2 < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0 as std::os::raw::c_int);
            nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1 as std::os::raw::c_int);
            ret_val = xmlXPathLeadingSorted(nodes1, nodes2);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes1, nodes1, 0 as std::os::raw::c_int);
            des_xmlNodeSetPtr(n_nodes2, nodes2, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathLeadingSorted\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nodes2 += 1
        }
        n_nodes1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathLocalNameFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathLocalNameFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathLocalNameFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathModValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathModValues(ctxt);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathModValues\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathMultValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathMultValues(ctxt);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathMultValues\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNamespaceURIFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathNamespaceURIFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNamespaceURIFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNewBoolean() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathNewBoolean(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_int(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathNewBoolean\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNewCString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_const_char_ptr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathNewCString(val as *const std::os::raw::c_char);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_const_char_ptr(n_val, val as *const std::os::raw::c_char,
                           0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathNewCString\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNewFloat() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: std::os::raw::c_double = 0.;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 4 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathNewFloat(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_double(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathNewFloat\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNewNodeSet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlNodePtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathNewNodeSet(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathNewNodeSet\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNewNodeSetList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlNodeSetPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathNewNodeSetList(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlNodeSetPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathNewNodeSetList\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNewParserContext() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the xmlChar * value */
}
unsafe extern "C" fn test_xmlXPathNewString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the XPath Parser context */
    let mut mem_base: std::os::raw::c_int = 0; /* the current node in the traversal */
    let mut ret_val: xmlXPathObjectPtr =
        0 as *mut xmlXPathObject; /* the XPath Parser context */
    let mut val: *mut xmlChar =
        0 as *mut xmlChar; /* the current node in the traversal */
    let mut n_val: std::os::raw::c_int = 0; /* the XPath Parser context */
    n_val = 0 as std::os::raw::c_int; /* the current attribute in the traversal */
    while n_val < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the XPath Parser context */
        val =
            gen_const_xmlChar_ptr(n_val,
                                  0 as
                                      std::os::raw::c_int); /* the current node in the traversal */
        ret_val =
            xmlXPathNewString(val as
                                  *const xmlChar); /* the XPath Parser context */
        desret_xmlXPathObjectPtr(ret_val); /* the current node in the traversal */
        call_tests += 1; /* the XPath Parser context */
        des_const_xmlChar_ptr(n_val, val as *const xmlChar,
                              0 as
                                  std::os::raw::c_int); /* the current node in the traversal */
        xmlResetLastError(); /* the XPath Parser context */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathNewString\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() -
                       mem_base); /* the current node in the traversal */
            test_ret += 1; /* the XPath Parser context */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_val); /* the current node in the traversal */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the XPath Parser context */
        } /* the current attribute in the traversal */
        n_val += 1
    } /* the XPath Parser context */
    function_tests += 1; /* the current node in the traversal */
    return test_ret; /* the XPath Parser context */
}
unsafe extern "C" fn test_xmlXPathNextAncestor() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the current node in the traversal */
    let mut mem_base: std::os::raw::c_int = 0; /* the XPath Parser context */
    let mut ret_val: xmlNodePtr =
        0 as *mut xmlNode; /* the current node in the traversal */
    let mut ctxt: xmlXPathParserContextPtr =
        0 as *mut xmlXPathParserContext; /* the XPath Parser context */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the current node in the traversal */
    let mut cur: xmlNodePtr = 0 as *mut xmlNode; /* a node-set */
    let mut n_cur: std::os::raw::c_int = 0; /* a node */
    n_ctxt = 0 as std::os::raw::c_int; /* a node-set, sorted by document order */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int; /* a node */
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the initial node set */
            ctxt =
                gen_xmlXPathParserContextPtr(n_ctxt,
                                             0 as
                                                 std::os::raw::c_int); /* a new xmlNodePtr */
            cur =
                gen_xmlNodePtr(n_cur,
                               1 as std::os::raw::c_int); /* the initial node set */
            ret_val = xmlXPathNextAncestor(ctxt, cur); /* the hosting node */
            desret_xmlNodePtr(ret_val); /* a the namespace node */
            call_tests += 1; /* the initial node set */
            des_xmlXPathParserContextPtr(n_ctxt, ctxt,
                                         0 as
                                             std::os::raw::c_int); /* a new xmlNodePtr */
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int); /* the node-set */
            xmlResetLastError(); /* the node */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextAncestor\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base); /* the initial node set */
                test_ret += 1; /* an xmlNodePtr */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt); /* the first NodeSet or NULL */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_cur); /* the second NodeSet */
                printf(b"\n\x00" as *const u8 as
                           *const std::os::raw::c_char); /* the initial node set */
            } /* the index to remove */
            n_cur += 1
        } /* the node set */
        n_ctxt += 1
    } /* a node-set */
    function_tests += 1; /* a node */
    return test_ret; /* a node-set, sorted by document order */
}
unsafe extern "C" fn test_xmlXPathNextAncestorOrSelf() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* a node */
    let mut mem_base: std::os::raw::c_int = 0; /* the XPath Parser context */
    let mut ret_val: xmlNodePtr =
        0 as *mut xmlNode; /* the number of arguments */
    let mut ctxt: xmlXPathParserContextPtr =
        0 as *mut xmlXPathParserContext; /* the XPath Parser context */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the XPath Parser context */
    let mut cur: xmlNodePtr = 0 as *mut xmlNode; /* the number of arguments */
    let mut n_cur: std::os::raw::c_int = 0; /* the XPath context */
    n_ctxt = 0 as std::os::raw::c_int; /* the namespace prefix value */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int; /* the XPath Parser context */
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks(); /* the number of arguments */
            ctxt =
                gen_xmlXPathParserContextPtr(n_ctxt,
                                             0 as
                                                 std::os::raw::c_int); /* the XPath Parser context */
            cur =
                gen_xmlNodePtr(n_cur,
                               1 as
                                   std::os::raw::c_int); /* the XPath Parser context */
            ret_val =
                xmlXPathNextAncestorOrSelf(ctxt,
                                           cur); /* an XPath parser context */
            desret_xmlNodePtr(ret_val); /* an XPath parser context */
            call_tests += 1; /* an XPath parser context */
            des_xmlXPathParserContextPtr(n_ctxt, ctxt,
                                         0 as
                                             std::os::raw::c_int); /* an XPath parser context */
            des_xmlNodePtr(n_cur, cur,
                           1 as std::os::raw::c_int); /* an XPath parser context */
            xmlResetLastError(); /* the XPath Parser context */
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextAncestorOrSelf\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() -
                           mem_base); /* the number of arguments */
                test_ret += 1; /* the XPath context */
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextAttribute() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextAttribute(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextAttribute\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextChild() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextChild(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextChild\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextDescendant() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextDescendant(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextDescendant\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextDescendantOrSelf() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextDescendantOrSelf(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextDescendantOrSelf\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextFollowing() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextFollowing(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextFollowing\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextFollowingSibling() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextFollowingSibling(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextFollowingSibling\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextNamespace() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextNamespace(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextNamespace\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextParent() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextParent(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextParent\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextPreceding() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextPreceding(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextPreceding\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextPrecedingSibling() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextPrecedingSibling(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextPrecedingSibling\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNextSelf() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_cur: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_cur = 0 as std::os::raw::c_int;
        while n_cur < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            cur = gen_xmlNodePtr(n_cur, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNextSelf(ctxt, cur);
            desret_xmlNodePtr(ret_val);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_cur, cur, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNextSelf\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_cur += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeLeading() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_nodes = 0 as std::os::raw::c_int;
    while n_nodes < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes = gen_xmlNodeSetPtr(n_nodes, 0 as std::os::raw::c_int);
            node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNodeLeading(nodes, node);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes, nodes, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeLeading\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_nodes += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeLeadingSorted() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_nodes = 0 as std::os::raw::c_int;
    while n_nodes < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes = gen_xmlNodeSetPtr(n_nodes, 0 as std::os::raw::c_int);
            node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNodeLeadingSorted(nodes, node);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes, nodes, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeLeadingSorted\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_nodes += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeSetAdd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut cur: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut val: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_val: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodeSetPtr(n_cur, 0 as std::os::raw::c_int);
            val = gen_xmlNodePtr(n_val, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNodeSetAdd(cur, val);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeSetAdd\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeSetAddNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut cur: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut n_ns: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            n_ns = 0 as std::os::raw::c_int;
            while n_ns < 2 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                cur = gen_xmlNodeSetPtr(n_cur, 0 as std::os::raw::c_int);
                node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
                ns = gen_xmlNsPtr(n_ns, 2 as std::os::raw::c_int);
                ret_val = xmlXPathNodeSetAddNs(cur, node, ns);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlNodeSetPtr(n_cur, cur, 0 as std::os::raw::c_int);
                des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
                des_xmlNsPtr(n_ns, ns, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXPathNodeSetAddNs\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_cur);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_node);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ns);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_ns += 1
            }
            n_node += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeSetAddUnique() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut cur: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut val: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_val: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodeSetPtr(n_cur, 0 as std::os::raw::c_int);
            val = gen_xmlNodePtr(n_val, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNodeSetAddUnique(cur, val);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeSetAddUnique\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeSetContains() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut cur: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut val: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_val: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodeSetPtr(n_cur, 0 as std::os::raw::c_int);
            val = gen_xmlNodePtr(n_val, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNodeSetContains(cur, val);
            desret_int(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeSetContains\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeSetDel() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut val: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_val: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodeSetPtr(n_cur, 0 as std::os::raw::c_int);
            val = gen_xmlNodePtr(n_val, 1 as std::os::raw::c_int);
            xmlXPathNodeSetDel(cur, val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeSetDel\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeSetMerge() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut val1: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_val1: std::os::raw::c_int = 0;
    let mut val2: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_val2: std::os::raw::c_int = 0;
    n_val1 = 0 as std::os::raw::c_int;
    while n_val1 < 1 as std::os::raw::c_int {
        n_val2 = 0 as std::os::raw::c_int;
        while n_val2 < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            val1 = gen_xmlNodeSetPtr(n_val1, 0 as std::os::raw::c_int);
            val2 = gen_xmlNodeSetPtr(n_val2, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNodeSetMerge(val1, val2);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_val1, val1, 0 as std::os::raw::c_int);
            des_xmlNodeSetPtr(n_val2, val2, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeSetMerge\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_val1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_val2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val2 += 1
        }
        n_val1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeSetRemove() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlNodeSetPtr(n_cur, 0 as std::os::raw::c_int);
            val = gen_int(n_val, 1 as std::os::raw::c_int);
            xmlXPathNodeSetRemove(cur, val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_int(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeSetRemove\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeSetSort() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut set: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_set: std::os::raw::c_int = 0;
    n_set = 0 as std::os::raw::c_int;
    while n_set < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        set = gen_xmlNodeSetPtr(n_set, 0 as std::os::raw::c_int);
        xmlXPathNodeSetSort(set);
        call_tests += 1;
        des_xmlNodeSetPtr(n_set, set, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathNodeSetSort\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_set);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_set += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeTrailing() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_nodes = 0 as std::os::raw::c_int;
    while n_nodes < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes = gen_xmlNodeSetPtr(n_nodes, 0 as std::os::raw::c_int);
            node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNodeTrailing(nodes, node);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes, nodes, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeTrailing\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_nodes += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNodeTrailingSorted() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_node: std::os::raw::c_int = 0;
    n_nodes = 0 as std::os::raw::c_int;
    while n_nodes < 1 as std::os::raw::c_int {
        n_node = 0 as std::os::raw::c_int;
        while n_node < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes = gen_xmlNodeSetPtr(n_nodes, 0 as std::os::raw::c_int);
            node = gen_xmlNodePtr(n_node, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNodeTrailingSorted(nodes, node);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes, nodes, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_node, node, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNodeTrailingSorted\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_node);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_node += 1
        }
        n_nodes += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNormalizeFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathNormalizeFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNormalizeFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNotEqualValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlXPathNotEqualValues(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathNotEqualValues\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNotFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathNotFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNotFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNsLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            prefix = gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
            ret_val = xmlXPathNsLookup(ctxt, prefix as *const xmlChar);
            desret_const_xmlChar_ptr(ret_val);
            call_tests += 1;
            des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNsLookup\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_prefix);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_prefix += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathNumberFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathNumberFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathNumberFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathParseNCName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlXPathParseNCName(ctxt);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathParseNCName\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathParseName() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlXPathParseName(ctxt);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathParseName\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathPopBoolean() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlXPathPopBoolean(ctxt);
        desret_int(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathPopBoolean\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathPopExternal() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlXPathPopExternal(ctxt);
        desret_void_ptr(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathPopExternal\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathPopNodeSet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlXPathPopNodeSet(ctxt);
        desret_xmlNodeSetPtr(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathPopNodeSet\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathPopNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_double = 0.;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlXPathPopNumber(ctxt);
        desret_double(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathPopNumber\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathPopString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        ret_val = xmlXPathPopString(ctxt);
        desret_xmlChar_ptr(ret_val);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathPopString\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathPositionFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathPositionFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathPositionFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRegisterAllFunctions() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathRegisterAllFunctions(ctxt);
        call_tests += 1;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathRegisterAllFunctions\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRegisterFunc() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRegisterFuncLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRegisterFuncNS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the XPath context */
}
unsafe extern "C" fn test_xmlXPathRegisterNs() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as
            std::os::raw::c_int; /* the namespace prefix cannot be NULL or empty string */
    let mut mem_base: std::os::raw::c_int = 0; /* the namespace name */
    let mut ret_val: std::os::raw::c_int = 0; /* the XPath context */
    let mut ctxt: xmlXPathContextPtr =
        0 as *mut xmlXPathContext; /* the variable name */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the variable value or NULL */
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_prefix: std::os::raw::c_int = 0;
    let mut ns_uri: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ns_uri: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_prefix = 0 as std::os::raw::c_int;
        while n_prefix < 5 as std::os::raw::c_int {
            n_ns_uri = 0 as std::os::raw::c_int;
            while n_ns_uri < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
                prefix = gen_const_xmlChar_ptr(n_prefix, 1 as std::os::raw::c_int);
                ns_uri = gen_const_xmlChar_ptr(n_ns_uri, 2 as std::os::raw::c_int);
                ret_val =
                    xmlXPathRegisterNs(ctxt, prefix as *const xmlChar,
                                       ns_uri as *const xmlChar);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_prefix, prefix as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_ns_uri, ns_uri as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXPathRegisterNs\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_prefix);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ns_uri);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_ns_uri += 1
            }
            n_prefix += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRegisterVariable() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut value: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_value: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_value = 0 as std::os::raw::c_int;
            while n_value < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                value = gen_xmlXPathObjectPtr(n_value, 2 as std::os::raw::c_int);
                ret_val =
                    xmlXPathRegisterVariable(ctxt, name as *const xmlChar,
                                             value);
                desret_int(ret_val);
                call_tests += 1;
                des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_xmlXPathObjectPtr(n_value, value, 2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXPathRegisterVariable\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_value);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_value += 1
            }
            n_name += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRegisterVariableLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the XPath context */
}
unsafe extern "C" fn test_xmlXPathRegisterVariableNS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int; /* the variable name */
    let mut mem_base: std::os::raw::c_int = 0; /* the variable namespace URI */
    let mut ret_val: std::os::raw::c_int = 0; /* the variable value or NULL */
    let mut ctxt: xmlXPathContextPtr =
        0 as *mut xmlXPathContext; /* the XPath context */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the XPath context */
    let mut name: *mut xmlChar = 0 as *mut xmlChar; /* the XPath context */
    let mut n_name: std::os::raw::c_int = 0; /* the XPath Parser context */
    let mut ns_uri: *mut xmlChar =
        0 as *mut xmlChar; /* the XPath Parser context */
    let mut n_ns_uri: std::os::raw::c_int = 0; /* the number of arguments */
    let mut value: xmlXPathObjectPtr =
        0 as *mut xmlXPathObject; /* the XPath Parser context */
    let mut n_value: std::os::raw::c_int = 0; /* the number of arguments */
    n_ctxt = 0 as std::os::raw::c_int; /* A string to scan */
    while n_ctxt < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int; /* the XPath Parser context */
        while n_name < 5 as std::os::raw::c_int {
            n_ns_uri = 0 as std::os::raw::c_int; /* the number of arguments */
            while n_ns_uri < 5 as std::os::raw::c_int {
                n_value = 0 as std::os::raw::c_int; /* the XPath Parser context */
                while n_value < 5 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks(); /* the number of arguments */
                    ctxt =
                        gen_xmlXPathContextPtr(n_ctxt,
                                               0 as
                                                   std::os::raw::c_int); /* the XPath Parser context */
                    name =
                        gen_const_xmlChar_ptr(n_name,
                                              1 as
                                                  std::os::raw::c_int); /* the XPath Parser context */
                    ns_uri =
                        gen_const_xmlChar_ptr(n_ns_uri,
                                              2 as
                                                  std::os::raw::c_int); /* the number of arguments */
                    value =
                        gen_xmlXPathObjectPtr(n_value,
                                              3 as
                                                  std::os::raw::c_int); /* the XPath Parser context */
                    ret_val =
                        xmlXPathRegisterVariableNS(ctxt,
                                                   name as *const xmlChar,
                                                   ns_uri as *const xmlChar,
                                                   value); /* the number of arguments */
                    desret_int(ret_val); /* the XPath Parser context */
                    call_tests += 1; /* the number of arguments */
                    des_xmlXPathContextPtr(n_ctxt, ctxt,
                                           0 as
                                               std::os::raw::c_int); /* the XPath Parser context */
                    des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                          1 as
                                              std::os::raw::c_int); /* the number of arguments */
                    des_const_xmlChar_ptr(n_ns_uri, ns_uri as *const xmlChar,
                                          2 as std::os::raw::c_int); /* a node-set */
                    des_xmlXPathObjectPtr(n_value, value,
                                          3 as std::os::raw::c_int); /* a node-set */
                    xmlResetLastError(); /* a node-set, sorted by document order */
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlXPathRegisterVariableNS\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() -
                                   mem_base); /* a node-set, sorted by document order */
                        test_ret += 1; /* the XPath Parser context */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt); /* the number of arguments */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_name); /* the XPath Parser context */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ns_uri); /* the number of arguments */
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_value); /* the XPath Parser context */
                        printf(b"\n\x00" as *const u8 as
                                   *const std::os::raw::c_char); /* the XPath context */
                    } /* the variable name */
                    n_value += 1
                } /* the XPath context */
                n_ns_uri += 1
            } /* the variable name */
            n_name += 1
        } /* the variable namespace URI */
        n_ctxt += 1
    } /* the char * value */
    function_tests += 1; /* the user data */
    return test_ret; /* the NodePtr value */
}
unsafe extern "C" fn test_xmlXPathRegisteredFuncsCleanup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the XPath Parser context */
    let mut mem_base: std::os::raw::c_int = 0; /* the file name */
    let mut ctxt: xmlXPathContextPtr =
        0 as *mut xmlXPathContext; /* the line number */
    let mut n_ctxt: std::os::raw::c_int = 0; /* the error number */
    n_ctxt = 0 as std::os::raw::c_int; /* the XPointer result from the evaluation. */
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the XPointer expression */
        ctxt =
            gen_xmlXPathContextPtr(n_ctxt,
                                   0 as
                                       std::os::raw::c_int); /* the XPointer context */
        xmlXPathRegisteredFuncsCleanup(ctxt); /* the XPointer Parser context */
        call_tests += 1; /* the initial range set */
        des_xmlXPathContextPtr(n_ctxt, ctxt,
                               0 as
                                   std::os::raw::c_int); /* a new xmlXPathObjectPtr */
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathRegisteredFuncsCleanup\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRegisteredNsCleanup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathRegisteredNsCleanup(ctxt);
        call_tests += 1;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathRegisteredNsCleanup\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRegisteredVariablesCleanup()
 -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathRegisteredVariablesCleanup(ctxt);
        call_tests += 1;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathRegisteredVariablesCleanup\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRoot() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathRoot(ctxt);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathRoot\x00" as *const u8
                       as *const std::os::raw::c_char, xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathRoundFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathRoundFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathRoundFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathStartsWithFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathStartsWithFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathStartsWithFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathStringEvalNumber() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: std::os::raw::c_double = 0.;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    n_str = 0 as std::os::raw::c_int;
    while n_str < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0 as std::os::raw::c_int);
        ret_val = xmlXPathStringEvalNumber(str as *const xmlChar);
        desret_double(ret_val);
        call_tests += 1;
        des_const_xmlChar_ptr(n_str, str as *const xmlChar, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathStringEvalNumber\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_str += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathStringFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathStringFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathStringFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathStringLengthFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathStringLengthFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathStringLengthFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathSubValues() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathSubValues(ctxt);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathSubValues\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathSubstringAfterFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathSubstringAfterFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathSubstringAfterFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathSubstringBeforeFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathSubstringBeforeFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathSubstringBeforeFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathSubstringFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathSubstringFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathSubstringFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathSumFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathSumFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathSumFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathTrailing() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes1: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes1: std::os::raw::c_int = 0;
    let mut nodes2: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes2: std::os::raw::c_int = 0;
    n_nodes1 = 0 as std::os::raw::c_int;
    while n_nodes1 < 1 as std::os::raw::c_int {
        n_nodes2 = 0 as std::os::raw::c_int;
        while n_nodes2 < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0 as std::os::raw::c_int);
            nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1 as std::os::raw::c_int);
            ret_val = xmlXPathTrailing(nodes1, nodes2);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes1, nodes1, 0 as std::os::raw::c_int);
            des_xmlNodeSetPtr(n_nodes2, nodes2, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathTrailing\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nodes2 += 1
        }
        n_nodes1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathTrailingSorted() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut nodes1: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes1: std::os::raw::c_int = 0;
    let mut nodes2: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_nodes2: std::os::raw::c_int = 0;
    n_nodes1 = 0 as std::os::raw::c_int;
    while n_nodes1 < 1 as std::os::raw::c_int {
        n_nodes2 = 0 as std::os::raw::c_int;
        while n_nodes2 < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0 as std::os::raw::c_int);
            nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1 as std::os::raw::c_int);
            ret_val = xmlXPathTrailingSorted(nodes1, nodes2);
            desret_xmlNodeSetPtr(ret_val);
            call_tests += 1;
            des_xmlNodeSetPtr(n_nodes1, nodes1, 0 as std::os::raw::c_int);
            des_xmlNodeSetPtr(n_nodes2, nodes2, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathTrailingSorted\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes1);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nodes2);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nodes2 += 1
        }
        n_nodes1 += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathTranslateFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathTranslateFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathTranslateFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathTrueFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPathTrueFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathTrueFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathValueFlipSign() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPathValueFlipSign(ctxt);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathValueFlipSign\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathVariableLookup() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
            ret_val = xmlXPathVariableLookup(ctxt, name as *const xmlChar);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                  1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPathVariableLookup\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_name);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_name += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathVariableLookupNS() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_name: std::os::raw::c_int = 0;
    let mut ns_uri: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_ns_uri: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_name = 0 as std::os::raw::c_int;
        while n_name < 5 as std::os::raw::c_int {
            n_ns_uri = 0 as std::os::raw::c_int;
            while n_ns_uri < 5 as std::os::raw::c_int {
                mem_base = xmlMemBlocks();
                ctxt = gen_xmlXPathContextPtr(n_ctxt, 0 as std::os::raw::c_int);
                name = gen_const_xmlChar_ptr(n_name, 1 as std::os::raw::c_int);
                ns_uri = gen_const_xmlChar_ptr(n_ns_uri, 2 as std::os::raw::c_int);
                ret_val =
                    xmlXPathVariableLookupNS(ctxt, name as *const xmlChar,
                                             ns_uri as *const xmlChar);
                desret_xmlXPathObjectPtr(ret_val);
                call_tests += 1;
                des_xmlXPathContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_name, name as *const xmlChar,
                                      1 as std::os::raw::c_int);
                des_const_xmlChar_ptr(n_ns_uri, ns_uri as *const xmlChar,
                                      2 as std::os::raw::c_int);
                xmlResetLastError();
                if mem_base != xmlMemBlocks() {
                    printf(b"Leak of %d blocks found in xmlXPathVariableLookupNS\x00"
                               as *const u8 as *const std::os::raw::c_char,
                           xmlMemBlocks() - mem_base);
                    test_ret += 1;
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ctxt);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_name);
                    printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                           n_ns_uri);
                    printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                n_ns_uri += 1
            }
            n_name += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathWrapCString() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_char_ptr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathWrapCString(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_char_ptr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathWrapCString\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathWrapExternal() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 2 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_void_ptr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathWrapExternal(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_void_ptr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathWrapExternal\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPathWrapNodeSet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlNodeSetPtr = 0 as *mut xmlNodeSet;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlNodeSetPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPathWrapNodeSet(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlNodeSetPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPathWrapNodeSet\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPatherror() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut file: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut n_file: std::os::raw::c_int = 0;
    let mut line: std::os::raw::c_int = 0;
    let mut n_line: std::os::raw::c_int = 0;
    let mut no: std::os::raw::c_int = 0;
    let mut n_no: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_file = 0 as std::os::raw::c_int;
        while n_file < 8 as std::os::raw::c_int {
            n_line = 0 as std::os::raw::c_int;
            while n_line < 4 as std::os::raw::c_int {
                n_no = 0 as std::os::raw::c_int;
                while n_no < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    ctxt =
                        gen_xmlXPathParserContextPtr(n_ctxt,
                                                     0 as std::os::raw::c_int);
                    file = gen_filepath(n_file, 1 as std::os::raw::c_int);
                    line = gen_int(n_line, 2 as std::os::raw::c_int);
                    no = gen_int(n_no, 3 as std::os::raw::c_int);
                    xmlXPatherror(ctxt, file, line, no);
                    call_tests += 1;
                    des_xmlXPathParserContextPtr(n_ctxt, ctxt,
                                                 0 as std::os::raw::c_int);
                    des_filepath(n_file, file, 1 as std::os::raw::c_int);
                    des_int(n_line, line, 2 as std::os::raw::c_int);
                    des_int(n_no, no, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlXPatherror\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_ctxt);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_file);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_line);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_no);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_no += 1
                }
                n_line += 1
            }
            n_file += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xpathInternals() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xpathInternals : 106 of 117 functions ...\n\x00" as
                   *const u8 as *const std::os::raw::c_char);
    }
    test_ret += test_valuePop();
    test_ret += test_valuePush();
    test_ret += test_xmlXPathAddValues();
    test_ret += test_xmlXPathBooleanFunction();
    test_ret += test_xmlXPathCeilingFunction();
    test_ret += test_xmlXPathCompareValues();
    test_ret += test_xmlXPathConcatFunction();
    test_ret += test_xmlXPathContainsFunction();
    test_ret += test_xmlXPathCountFunction();
    test_ret += test_xmlXPathDebugDumpCompExpr();
    test_ret += test_xmlXPathDebugDumpObject();
    test_ret += test_xmlXPathDifference();
    test_ret += test_xmlXPathDistinct();
    test_ret += test_xmlXPathDistinctSorted();
    test_ret += test_xmlXPathDivValues();
    test_ret += test_xmlXPathEqualValues();
    test_ret += test_xmlXPathErr();
    test_ret += test_xmlXPathEvalExpr();
    test_ret += test_xmlXPathEvaluatePredicateResult();
    test_ret += test_xmlXPathFalseFunction();
    test_ret += test_xmlXPathFloorFunction();
    test_ret += test_xmlXPathFunctionLookup();
    test_ret += test_xmlXPathFunctionLookupNS();
    test_ret += test_xmlXPathHasSameNodes();
    test_ret += test_xmlXPathIdFunction();
    test_ret += test_xmlXPathIntersection();
    test_ret += test_xmlXPathIsNodeType();
    test_ret += test_xmlXPathLangFunction();
    test_ret += test_xmlXPathLastFunction();
    test_ret += test_xmlXPathLeading();
    test_ret += test_xmlXPathLeadingSorted();
    test_ret += test_xmlXPathLocalNameFunction();
    test_ret += test_xmlXPathModValues();
    test_ret += test_xmlXPathMultValues();
    test_ret += test_xmlXPathNamespaceURIFunction();
    test_ret += test_xmlXPathNewBoolean();
    test_ret += test_xmlXPathNewCString();
    test_ret += test_xmlXPathNewFloat();
    test_ret += test_xmlXPathNewNodeSet();
    test_ret += test_xmlXPathNewNodeSetList();
    test_ret += test_xmlXPathNewParserContext();
    test_ret += test_xmlXPathNewString();
    test_ret += test_xmlXPathNextAncestor();
    test_ret += test_xmlXPathNextAncestorOrSelf();
    test_ret += test_xmlXPathNextAttribute();
    test_ret += test_xmlXPathNextChild();
    test_ret += test_xmlXPathNextDescendant();
    test_ret += test_xmlXPathNextDescendantOrSelf();
    test_ret += test_xmlXPathNextFollowing();
    test_ret += test_xmlXPathNextFollowingSibling();
    test_ret += test_xmlXPathNextNamespace();
    test_ret += test_xmlXPathNextParent();
    test_ret += test_xmlXPathNextPreceding();
    test_ret += test_xmlXPathNextPrecedingSibling();
    test_ret += test_xmlXPathNextSelf();
    test_ret += test_xmlXPathNodeLeading();
    test_ret += test_xmlXPathNodeLeadingSorted();
    test_ret += test_xmlXPathNodeSetAdd();
    test_ret += test_xmlXPathNodeSetAddNs();
    test_ret += test_xmlXPathNodeSetAddUnique();
    test_ret += test_xmlXPathNodeSetContains();
    test_ret += test_xmlXPathNodeSetDel();
    test_ret += test_xmlXPathNodeSetMerge();
    test_ret += test_xmlXPathNodeSetRemove();
    test_ret += test_xmlXPathNodeSetSort();
    test_ret += test_xmlXPathNodeTrailing();
    test_ret += test_xmlXPathNodeTrailingSorted();
    test_ret += test_xmlXPathNormalizeFunction();
    test_ret += test_xmlXPathNotEqualValues();
    test_ret += test_xmlXPathNotFunction();
    test_ret += test_xmlXPathNsLookup();
    test_ret += test_xmlXPathNumberFunction();
    test_ret += test_xmlXPathParseNCName();
    test_ret += test_xmlXPathParseName();
    test_ret += test_xmlXPathPopBoolean();
    test_ret += test_xmlXPathPopExternal();
    test_ret += test_xmlXPathPopNodeSet();
    test_ret += test_xmlXPathPopNumber();
    test_ret += test_xmlXPathPopString();
    test_ret += test_xmlXPathPositionFunction();
    test_ret += test_xmlXPathRegisterAllFunctions();
    test_ret += test_xmlXPathRegisterFunc();
    test_ret += test_xmlXPathRegisterFuncLookup();
    test_ret += test_xmlXPathRegisterFuncNS();
    test_ret += test_xmlXPathRegisterNs();
    test_ret += test_xmlXPathRegisterVariable();
    test_ret += test_xmlXPathRegisterVariableLookup();
    test_ret += test_xmlXPathRegisterVariableNS();
    test_ret += test_xmlXPathRegisteredFuncsCleanup();
    test_ret += test_xmlXPathRegisteredNsCleanup();
    test_ret += test_xmlXPathRegisteredVariablesCleanup();
    test_ret += test_xmlXPathRoot();
    test_ret += test_xmlXPathRoundFunction();
    test_ret += test_xmlXPathStartsWithFunction();
    test_ret += test_xmlXPathStringEvalNumber();
    test_ret += test_xmlXPathStringFunction();
    test_ret += test_xmlXPathStringLengthFunction();
    test_ret += test_xmlXPathSubValues();
    test_ret += test_xmlXPathSubstringAfterFunction();
    test_ret += test_xmlXPathSubstringBeforeFunction();
    test_ret += test_xmlXPathSubstringFunction();
    test_ret += test_xmlXPathSumFunction();
    test_ret += test_xmlXPathTrailing();
    test_ret += test_xmlXPathTrailingSorted();
    test_ret += test_xmlXPathTranslateFunction();
    test_ret += test_xmlXPathTrueFunction();
    test_ret += test_xmlXPathValueFlipSign();
    test_ret += test_xmlXPathVariableLookup();
    test_ret += test_xmlXPathVariableLookupNS();
    test_ret += test_xmlXPathWrapCString();
    test_ret += test_xmlXPathWrapExternal();
    test_ret += test_xmlXPathWrapNodeSet();
    test_ret += test_xmlXPatherror();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xpathInternals: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrBuildNodeList() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlNodePtr = 0 as *mut xmlNode;
    let mut obj: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_obj: std::os::raw::c_int = 0;
    n_obj = 0 as std::os::raw::c_int;
    while n_obj < 5 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        obj = gen_xmlXPathObjectPtr(n_obj, 0 as std::os::raw::c_int);
        ret_val = xmlXPtrBuildNodeList(obj);
        desret_xmlNodePtr(ret_val);
        call_tests += 1;
        des_xmlXPathObjectPtr(n_obj, obj, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPtrBuildNodeList\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_obj);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_obj += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrEval() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut n_str: std::os::raw::c_int = 0;
    let mut ctx: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut n_ctx: std::os::raw::c_int = 0;
    n_str = 0 as std::os::raw::c_int;
    while n_str < 5 as std::os::raw::c_int {
        n_ctx = 0 as std::os::raw::c_int;
        while n_ctx < 1 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            str = gen_const_xmlChar_ptr(n_str, 0 as std::os::raw::c_int);
            ctx = gen_xmlXPathContextPtr(n_ctx, 1 as std::os::raw::c_int);
            ret_val = xmlXPtrEval(str as *const xmlChar, ctx);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_const_xmlChar_ptr(n_str, str as *const xmlChar,
                                  0 as std::os::raw::c_int);
            des_xmlXPathContextPtr(n_ctx, ctx, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrEval\x00" as
                           *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_str);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctx);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_ctx += 1
        }
        n_str += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrEvalRangePredicate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
        xmlXPtrEvalRangePredicate(ctxt);
        call_tests += 1;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPtrEvalRangePredicate\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_ctxt);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn gen_xmlLocationSetPtr(mut no: std::os::raw::c_int,
                                           mut nr: std::os::raw::c_int)
 -> xmlLocationSetPtr {
    return 0 as xmlLocationSetPtr;
}
unsafe extern "C" fn des_xmlLocationSetPtr(mut no: std::os::raw::c_int,
                                           mut val: xmlLocationSetPtr,
                                           mut nr: std::os::raw::c_int) {
}
unsafe extern "C" fn test_xmlXPtrLocationSetAdd() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlLocationSetPtr = 0 as *mut xmlLocationSet;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_val: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlLocationSetPtr(n_cur, 0 as std::os::raw::c_int);
            val = gen_xmlXPathObjectPtr(n_val, 1 as std::os::raw::c_int);
            xmlXPtrLocationSetAdd(cur, val);
            call_tests += 1;
            des_xmlLocationSetPtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_xmlXPathObjectPtr(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrLocationSetAdd\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrLocationSetCreate() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the initial range set */
}
unsafe extern "C" fn test_xmlXPtrLocationSetDel() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* an xmlXPathObjectPtr */
    let mut mem_base: std::os::raw::c_int = 0;
    let mut cur: xmlLocationSetPtr = 0 as *mut xmlLocationSet;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_val: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlLocationSetPtr(n_cur, 0 as std::os::raw::c_int);
            val = gen_xmlXPathObjectPtr(n_val, 1 as std::os::raw::c_int);
            xmlXPtrLocationSetDel(cur, val);
            call_tests += 1;
            des_xmlLocationSetPtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_xmlXPathObjectPtr(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrLocationSetDel\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrLocationSetMerge() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* the initial range set */
}
unsafe extern "C" fn test_xmlXPtrLocationSetRemove() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the index to remove */
    let mut mem_base: std::os::raw::c_int = 0; /* the starting and ending node */
    let mut cur: xmlLocationSetPtr = 0 as *mut xmlLocationSet;
    let mut n_cur: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    let mut n_val: std::os::raw::c_int = 0;
    n_cur = 0 as std::os::raw::c_int;
    while n_cur < 1 as std::os::raw::c_int {
        n_val = 0 as std::os::raw::c_int;
        while n_val < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            cur = gen_xmlLocationSetPtr(n_cur, 0 as std::os::raw::c_int);
            val = gen_int(n_val, 1 as std::os::raw::c_int);
            xmlXPtrLocationSetRemove(cur, val);
            call_tests += 1;
            des_xmlLocationSetPtr(n_cur, cur, 0 as std::os::raw::c_int);
            des_int(n_val, val, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrLocationSetRemove\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_cur);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_val += 1
        }
        n_cur += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrNewCollapsedRange() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_start: std::os::raw::c_int = 0;
    n_start = 0 as std::os::raw::c_int;
    while n_start < 3 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0 as std::os::raw::c_int);
        ret_val = xmlXPtrNewCollapsedRange(start);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlNodePtr(n_start, start, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPtrNewCollapsedRange\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_start);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_start += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrNewContext() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* missing type support */
    return test_ret; /* a node set */
}
unsafe extern "C" fn test_xmlXPtrNewLocationSetNodeSet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int =
        0 as std::os::raw::c_int; /* the start NodePtr value */
    let mut mem_base: std::os::raw::c_int = 0; /* the end NodePtr value or NULL */
    let mut ret_val: xmlXPathObjectPtr =
        0 as *mut xmlXPathObject; /* the starting node */
    let mut set: xmlNodeSetPtr = 0 as *mut xmlNodeSet; /* the start index */
    let mut n_set: std::os::raw::c_int = 0; /* the ending point */
    n_set = 0 as std::os::raw::c_int; /* the ending index */
    while n_set < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks(); /* the starting node */
        set =
            gen_xmlNodeSetPtr(n_set,
                              0 as std::os::raw::c_int); /* the ending object */
        ret_val = xmlXPtrNewLocationSetNodeSet(set); /* the starting node */
        desret_xmlXPathObjectPtr(ret_val); /* the ending point */
        call_tests += 1; /* the starting node */
        des_xmlNodeSetPtr(n_set, set, 0 as std::os::raw::c_int); /* the ending node */
        xmlResetLastError(); /* the starting point */
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPtrNewLocationSetNodeSet\x00"
                       as *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base); /* the ending node */
            test_ret += 1; /* the starting point */
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                   n_set); /* the ending point */
            printf(b"\n\x00" as *const u8 as
                       *const std::os::raw::c_char); /* the XPointer Parser context */
        } /* the number of args */
        n_set += 1
    } /* the LocationSet value */
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrNewLocationSetNodes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_start: std::os::raw::c_int = 0;
    let mut end: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_end: std::os::raw::c_int = 0;
    n_start = 0 as std::os::raw::c_int;
    while n_start < 3 as std::os::raw::c_int {
        n_end = 0 as std::os::raw::c_int;
        while n_end < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            start = gen_xmlNodePtr(n_start, 0 as std::os::raw::c_int);
            end = gen_xmlNodePtr(n_end, 1 as std::os::raw::c_int);
            ret_val = xmlXPtrNewLocationSetNodes(start, end);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_start, start, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_end, end, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrNewLocationSetNodes\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_start);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_end);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_end += 1
        }
        n_start += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrNewRange() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_start: std::os::raw::c_int = 0;
    let mut startindex: std::os::raw::c_int = 0;
    let mut n_startindex: std::os::raw::c_int = 0;
    let mut end: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_end: std::os::raw::c_int = 0;
    let mut endindex: std::os::raw::c_int = 0;
    let mut n_endindex: std::os::raw::c_int = 0;
    n_start = 0 as std::os::raw::c_int;
    while n_start < 3 as std::os::raw::c_int {
        n_startindex = 0 as std::os::raw::c_int;
        while n_startindex < 4 as std::os::raw::c_int {
            n_end = 0 as std::os::raw::c_int;
            while n_end < 3 as std::os::raw::c_int {
                n_endindex = 0 as std::os::raw::c_int;
                while n_endindex < 4 as std::os::raw::c_int {
                    mem_base = xmlMemBlocks();
                    start = gen_xmlNodePtr(n_start, 0 as std::os::raw::c_int);
                    startindex = gen_int(n_startindex, 1 as std::os::raw::c_int);
                    end = gen_xmlNodePtr(n_end, 2 as std::os::raw::c_int);
                    endindex = gen_int(n_endindex, 3 as std::os::raw::c_int);
                    ret_val =
                        xmlXPtrNewRange(start, startindex, end, endindex);
                    desret_xmlXPathObjectPtr(ret_val);
                    call_tests += 1;
                    des_xmlNodePtr(n_start, start, 0 as std::os::raw::c_int);
                    des_int(n_startindex, startindex, 1 as std::os::raw::c_int);
                    des_xmlNodePtr(n_end, end, 2 as std::os::raw::c_int);
                    des_int(n_endindex, endindex, 3 as std::os::raw::c_int);
                    xmlResetLastError();
                    if mem_base != xmlMemBlocks() {
                        printf(b"Leak of %d blocks found in xmlXPtrNewRange\x00"
                                   as *const u8 as *const std::os::raw::c_char,
                               xmlMemBlocks() - mem_base);
                        test_ret += 1;
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_start);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_startindex);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_end);
                        printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                               n_endindex);
                        printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                    }
                    n_endindex += 1
                }
                n_end += 1
            }
            n_startindex += 1
        }
        n_start += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrNewRangeNodeObject() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_start: std::os::raw::c_int = 0;
    let mut end: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_end: std::os::raw::c_int = 0;
    n_start = 0 as std::os::raw::c_int;
    while n_start < 3 as std::os::raw::c_int {
        n_end = 0 as std::os::raw::c_int;
        while n_end < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            start = gen_xmlNodePtr(n_start, 0 as std::os::raw::c_int);
            end = gen_xmlXPathObjectPtr(n_end, 1 as std::os::raw::c_int);
            ret_val = xmlXPtrNewRangeNodeObject(start, end);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_start, start, 0 as std::os::raw::c_int);
            des_xmlXPathObjectPtr(n_end, end, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrNewRangeNodeObject\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_start);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_end);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_end += 1
        }
        n_start += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrNewRangeNodePoint() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_start: std::os::raw::c_int = 0;
    let mut end: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_end: std::os::raw::c_int = 0;
    n_start = 0 as std::os::raw::c_int;
    while n_start < 3 as std::os::raw::c_int {
        n_end = 0 as std::os::raw::c_int;
        while n_end < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            start = gen_xmlNodePtr(n_start, 0 as std::os::raw::c_int);
            end = gen_xmlXPathObjectPtr(n_end, 1 as std::os::raw::c_int);
            ret_val = xmlXPtrNewRangeNodePoint(start, end);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_start, start, 0 as std::os::raw::c_int);
            des_xmlXPathObjectPtr(n_end, end, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrNewRangeNodePoint\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_start);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_end);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_end += 1
        }
        n_start += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrNewRangeNodes() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_start: std::os::raw::c_int = 0;
    let mut end: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_end: std::os::raw::c_int = 0;
    n_start = 0 as std::os::raw::c_int;
    while n_start < 3 as std::os::raw::c_int {
        n_end = 0 as std::os::raw::c_int;
        while n_end < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            start = gen_xmlNodePtr(n_start, 0 as std::os::raw::c_int);
            end = gen_xmlNodePtr(n_end, 1 as std::os::raw::c_int);
            ret_val = xmlXPtrNewRangeNodes(start, end);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_xmlNodePtr(n_start, start, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_end, end, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrNewRangeNodes\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_start);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_end);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_end += 1
        }
        n_start += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrNewRangePointNode() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_start: std::os::raw::c_int = 0;
    let mut end: xmlNodePtr = 0 as *mut xmlNode;
    let mut n_end: std::os::raw::c_int = 0;
    n_start = 0 as std::os::raw::c_int;
    while n_start < 5 as std::os::raw::c_int {
        n_end = 0 as std::os::raw::c_int;
        while n_end < 3 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            start = gen_xmlXPathObjectPtr(n_start, 0 as std::os::raw::c_int);
            end = gen_xmlNodePtr(n_end, 1 as std::os::raw::c_int);
            ret_val = xmlXPtrNewRangePointNode(start, end);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_xmlXPathObjectPtr(n_start, start, 0 as std::os::raw::c_int);
            des_xmlNodePtr(n_end, end, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrNewRangePointNode\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_start);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_end);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_end += 1
        }
        n_start += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrNewRangePoints() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_start: std::os::raw::c_int = 0;
    let mut end: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut n_end: std::os::raw::c_int = 0;
    n_start = 0 as std::os::raw::c_int;
    while n_start < 5 as std::os::raw::c_int {
        n_end = 0 as std::os::raw::c_int;
        while n_end < 5 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            start = gen_xmlXPathObjectPtr(n_start, 0 as std::os::raw::c_int);
            end = gen_xmlXPathObjectPtr(n_end, 1 as std::os::raw::c_int);
            ret_val = xmlXPtrNewRangePoints(start, end);
            desret_xmlXPathObjectPtr(ret_val);
            call_tests += 1;
            des_xmlXPathObjectPtr(n_start, start, 0 as std::os::raw::c_int);
            des_xmlXPathObjectPtr(n_end, end, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrNewRangePoints\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_start);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_end);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_end += 1
        }
        n_start += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrRangeToFunction() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut n_ctxt: std::os::raw::c_int = 0;
    let mut nargs: std::os::raw::c_int = 0;
    let mut n_nargs: std::os::raw::c_int = 0;
    n_ctxt = 0 as std::os::raw::c_int;
    while n_ctxt < 1 as std::os::raw::c_int {
        n_nargs = 0 as std::os::raw::c_int;
        while n_nargs < 4 as std::os::raw::c_int {
            mem_base = xmlMemBlocks();
            ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0 as std::os::raw::c_int);
            nargs = gen_int(n_nargs, 1 as std::os::raw::c_int);
            xmlXPtrRangeToFunction(ctxt, nargs);
            call_tests += 1;
            des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0 as std::os::raw::c_int);
            des_int(n_nargs, nargs, 1 as std::os::raw::c_int);
            xmlResetLastError();
            if mem_base != xmlMemBlocks() {
                printf(b"Leak of %d blocks found in xmlXPtrRangeToFunction\x00"
                           as *const u8 as *const std::os::raw::c_char,
                       xmlMemBlocks() - mem_base);
                test_ret += 1;
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_ctxt);
                printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char,
                       n_nargs);
                printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
            }
            n_nargs += 1
        }
        n_ctxt += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xmlXPtrWrapLocationSet() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mem_base: std::os::raw::c_int = 0;
    let mut ret_val: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlLocationSetPtr = 0 as *mut xmlLocationSet;
    let mut n_val: std::os::raw::c_int = 0;
    n_val = 0 as std::os::raw::c_int;
    while n_val < 1 as std::os::raw::c_int {
        mem_base = xmlMemBlocks();
        val = gen_xmlLocationSetPtr(n_val, 0 as std::os::raw::c_int);
        ret_val = xmlXPtrWrapLocationSet(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests += 1;
        des_xmlLocationSetPtr(n_val, val, 0 as std::os::raw::c_int);
        xmlResetLastError();
        if mem_base != xmlMemBlocks() {
            printf(b"Leak of %d blocks found in xmlXPtrWrapLocationSet\x00" as
                       *const u8 as *const std::os::raw::c_char,
                   xmlMemBlocks() - mem_base);
            test_ret += 1;
            printf(b" %d\x00" as *const u8 as *const std::os::raw::c_char, n_val);
            printf(b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        n_val += 1
    }
    function_tests += 1;
    return test_ret;
}
unsafe extern "C" fn test_xpointer() -> std::os::raw::c_int {
    let mut test_ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if quiet == 0 as std::os::raw::c_int {
        printf(b"Testing xpointer : 17 of 21 functions ...\n\x00" as *const u8
                   as *const std::os::raw::c_char);
    }
    test_ret += test_xmlXPtrBuildNodeList();
    test_ret += test_xmlXPtrEval();
    test_ret += test_xmlXPtrEvalRangePredicate();
    test_ret += test_xmlXPtrLocationSetAdd();
    test_ret += test_xmlXPtrLocationSetCreate();
    test_ret += test_xmlXPtrLocationSetDel();
    test_ret += test_xmlXPtrLocationSetMerge();
    test_ret += test_xmlXPtrLocationSetRemove();
    test_ret += test_xmlXPtrNewCollapsedRange();
    test_ret += test_xmlXPtrNewContext();
    test_ret += test_xmlXPtrNewLocationSetNodeSet();
    test_ret += test_xmlXPtrNewLocationSetNodes();
    test_ret += test_xmlXPtrNewRange();
    test_ret += test_xmlXPtrNewRangeNodeObject();
    test_ret += test_xmlXPtrNewRangeNodePoint();
    test_ret += test_xmlXPtrNewRangeNodes();
    test_ret += test_xmlXPtrNewRangePointNode();
    test_ret += test_xmlXPtrNewRangePoints();
    test_ret += test_xmlXPtrRangeToFunction();
    test_ret += test_xmlXPtrWrapLocationSet();
    if test_ret != 0 as std::os::raw::c_int {
        printf(b"Module xpointer: %d errors\n\x00" as *const u8 as
                   *const std::os::raw::c_char, test_ret);
    }
    return test_ret;
}
unsafe extern "C" fn test_module(mut module: *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    if strcmp(module, b"HTMLparser\x00" as *const u8 as *const std::os::raw::c_char)
           == 0 {
        return test_HTMLparser()
    }
    if strcmp(module, b"HTMLtree\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_HTMLtree()
    }
    if strcmp(module, b"SAX2\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_SAX2()
    }
    if strcmp(module, b"c14n\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_c14n()
    }
    if strcmp(module, b"catalog\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_catalog()
    }
    if strcmp(module, b"chvalid\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_chvalid()
    }
    if strcmp(module, b"debugXML\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_debugXML()
    }
    if strcmp(module, b"dict\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_dict()
    }
    if strcmp(module, b"encoding\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_encoding()
    }
    if strcmp(module, b"entities\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_entities()
    }
    if strcmp(module, b"hash\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_hash()
    }
    if strcmp(module, b"list\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_list()
    }
    if strcmp(module, b"nanoftp\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_nanoftp()
    }
    if strcmp(module, b"nanohttp\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_nanohttp()
    }
    if strcmp(module, b"parser\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_parser()
    }
    if strcmp(module,
              b"parserInternals\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_parserInternals()
    }
    if strcmp(module, b"pattern\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_pattern()
    }
    if strcmp(module, b"relaxng\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_relaxng()
    }
    if strcmp(module,
              b"schemasInternals\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_schemasInternals()
    }
    if strcmp(module, b"schematron\x00" as *const u8 as *const std::os::raw::c_char)
           == 0 {
        return test_schematron()
    }
    if strcmp(module, b"tree\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_tree()
    }
    if strcmp(module, b"uri\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_uri()
    }
    if strcmp(module, b"valid\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_valid()
    }
    if strcmp(module, b"xinclude\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_xinclude()
    }
    if strcmp(module, b"xmlIO\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_xmlIO()
    }
    if strcmp(module, b"xmlautomata\x00" as *const u8 as *const std::os::raw::c_char)
           == 0 {
        return test_xmlautomata()
    }
    if strcmp(module, b"xmlerror\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_xmlerror()
    }
    if strcmp(module, b"xmlmodule\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_xmlmodule()
    }
    if strcmp(module, b"xmlreader\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_xmlreader()
    }
    if strcmp(module, b"xmlregexp\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_xmlregexp()
    }
    if strcmp(module, b"xmlsave\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_xmlsave()
    }
    if strcmp(module, b"xmlschemas\x00" as *const u8 as *const std::os::raw::c_char)
           == 0 {
        return test_xmlschemas()
    }
    if strcmp(module,
              b"xmlschemastypes\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_xmlschemastypes()
    }
    if strcmp(module, b"xmlstring\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_xmlstring()
    }
    if strcmp(module, b"xmlunicode\x00" as *const u8 as *const std::os::raw::c_char)
           == 0 {
        return test_xmlunicode()
    }
    if strcmp(module, b"xmlwriter\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_xmlwriter()
    }
    if strcmp(module, b"xpath\x00" as *const u8 as *const std::os::raw::c_char) == 0 {
        return test_xpath()
    }
    if strcmp(module,
              b"xpathInternals\x00" as *const u8 as *const std::os::raw::c_char) == 0
       {
        return test_xpathInternals()
    }
    if strcmp(module, b"xpointer\x00" as *const u8 as *const std::os::raw::c_char) ==
           0 {
        return test_xpointer()
    }
    return 0 as std::os::raw::c_int;
}
#[main]
pub fn main() {
    let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
    };
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0((args.len() - 1) as std::os::raw::c_int,
                                    args.as_mut_ptr() as
                                        *mut *mut std::os::raw::c_char) as i32)
    }
}
