
extern "C" {
    pub type _xmlDict;
    /*
 * Summary: Chained hash tables
 * Description: This module implements the hash table support used in
 *		various places in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Bjorn Reese <bjorn.reese@systematic.dk>
 */
    /*
 * The hash table.
 */
    pub type _xmlHashTable;
    pub type _xmlBuf;
    pub type _xmlAutomataState;
    pub type _xmlAutomata;
    pub type _xmlValidState;
    #[no_mangle]
    fn snprintf(_: *mut std::os::raw::c_char, _: std::os::raw::c_ulong,
                _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrlen(str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrncasecmp(str1: *const xmlChar, str2: *const xmlChar,
                      len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcasecmp(str1: *const xmlChar, str2: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcmp(str1: *const xmlChar, str2: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcasestr(str: *const xmlChar, val: *const xmlChar)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlStrndup(cur: *const xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn memcpy(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_void, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn memset(_: *mut std::os::raw::c_void, _: std::os::raw::c_int, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn strcpy(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strcat(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strlen(_: *const std::os::raw::c_char) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn __ctype_toupper_loc() -> *mut *const __int32_t;
    #[no_mangle]
    fn xmlFindCharEncodingHandler(name: *const std::os::raw::c_char)
     -> xmlCharEncodingHandlerPtr;
    #[no_mangle]
    static mut xmlMallocAtomic: xmlMallocFunc;
    #[no_mangle]
    static mut xmlMalloc: xmlMallocFunc;
    #[no_mangle]
    fn xmlParseCharEncoding(name: *const std::os::raw::c_char) -> xmlCharEncoding;
    /*
 * Summary: interfaces for tree manipulation
 * Description: this module describes the structures found in an tree resulting
 *              from an XML or HTML parsing, as well as the API provided for
 *              various processing on that tree
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * Some of the basic types pointer to structures:
 */
/* xmlIO.h */
    /* parser.h */
    /* entities.h */
    /* *
 * BASE_BUFFER_SIZE:
 *
 * default buffer size 4000.
 */
    /* *
 * LIBXML_NAMESPACE_DICT:
 *
 * Defines experimental behaviour:
 * 1) xmlNs gets an additional field @context (a xmlDoc)
 * 2) when creating a tree, xmlNs->href is stored in the dict of xmlDoc.
 */
/* #define LIBXML_NAMESPACE_DICT */
    /* *
 * xmlBufferAllocationScheme:
 *
 * A buffer allocation scheme can be defined to either match exactly the
 * need or double it's allocated size each time it is found too small.
 */
    /* double each time one need to grow */
    /* grow only to the minimal size */
    /* immutable buffer */
    /* special allocation scheme used for I/O */
    /* exact up to a threshold, and doubleit thereafter */
    /* limit the upper size of the buffer */
    /* *
 * xmlBuffer:
 *
 * A buffer structure, this old construct is limited to 2GB and
 * is being deprecated, use API with xmlBuf instead
 */
    /* The buffer content UTF8 */
    /* The buffer size used */
    /* The buffer size */
    /* The realloc method */
    /* in IO mode we may have a different base */
    /* *
 * xmlBuf:
 *
 * A buffer structure, new one, the actual structure internals are not public
 */
    /* *
 * xmlBufPtr:
 *
 * A pointer to a buffer structure, the actual structure internals are not
 * public
 */
    /*
 * A few public routines for xmlBuf. As those are expected to be used
 * mostly internally the bulk of the routines are internal in buf.h
 */
    #[no_mangle]
    fn xmlBufShrink(buf: xmlBufPtr, len: size_t) -> size_t;
    #[no_mangle]
    fn __xmlLineNumbersDefaultValue() -> *mut std::os::raw::c_int;
    #[no_mangle]
    fn __xmlKeepBlanksDefaultValue() -> *mut std::os::raw::c_int;
    #[no_mangle]
    fn __xmlDefaultSAXLocator() -> *mut xmlSAXLocator;
    #[no_mangle]
    fn __xmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
    #[no_mangle]
    fn __htmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
    #[no_mangle]
    fn htmlDefaultSAXHandlerInit();
    #[no_mangle]
    fn xmlSAX2IgnorableWhitespace(ctx: *mut std::os::raw::c_void, ch: *const xmlChar,
                                  len: std::os::raw::c_int);
    /*
 * Summary: the core parser module
 * Description: Interfaces, constants and types related to the XML parser
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * XML_DEFAULT_VERSION:
 *
 * The default version of XML used: 1.0
 */
    /* *
 * xmlParserInput:
 *
 * An xmlParserInput is an input flow for the XML processor.
 * Each entity parsed is associated an xmlParserInput (except the
 * few predefined ones). This is the case both for internal entities
 * - in which case the flow is already completely in memory - or
 * external entities - in which case we use the buf structure for
 * progressive reading and I18N conversions to the internal UTF-8 format.
 */
    /* *
 * xmlParserInputDeallocate:
 * @str:  the string to deallocate
 *
 * Callback for freeing some parser input allocations.
 */
    /* Input buffer */
    /* UTF-8 encoded buffer */
    /* The file analyzed, if any */
    /* the directory/base of the file */
    /* Base of the array to parse */
    /* Current char being parsed */
    /* end of the array to parse */
    /* length if known */
    /* Current line */
    /* Current column */
    /*
     * NOTE: consumed is only tested for equality in the parser code,
     *       so even if there is an overflow this should not give troubles
     *       for parsing very large instances.
     */
    /* How many xmlChars already consumed */
    /* function to deallocate the base */
    /* the encoding string for entity */
    /* the version string for entity */
    /* Was that entity marked standalone */
    /* an unique identifier for the entity */
    /* *
 * xmlParserNodeInfo:
 *
 * The parser can be asked to collect Node informations, i.e. at what
 * place in the file they were detected.
 * NOTE: This is off by default and not very well tested.
 */
    /* Position & line # that text that created the node begins & ends on */
    /* *
 * xmlParserInputState:
 *
 * The parser is now working also as a state based parser.
 * The recursive one use the state info for entities processing.
 */
    /* nothing is to be parsed */
    /* nothing has been parsed */
    /* Misc* before int subset */
    /* Within a processing instruction */
    /* within some DTD content */
    /* Misc* after internal subset */
    /* within a comment */
    /* within a start tag */
    /* within the content */
    /* within a CDATA section */
    /* within a closing tag */
    /* within an entity declaration */
    /* within an entity value in a decl */
    /* within an attribute value */
    /* within a SYSTEM value */
    /* the Misc* after the last end tag */
    /* within an IGNORED section */
    /* within a PUBLIC value */
    /* *
 * XML_DETECT_IDS:
 *
 * Bit in the loadsubset context field to tell to do ID/REFs lookups.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
    /* *
 * XML_COMPLETE_ATTRS:
 *
 * Bit in the loadsubset context field to tell to do complete the
 * elements attributes lists with the ones defaulted from the DTDs.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
    /* *
 * XML_SKIP_IDS:
 *
 * Bit in the loadsubset context field to tell to not do ID/REFs registration.
 * Used to initialize xmlLoadExtDtdDefaultValue in some special cases.
 */
    /* *
 * xmlParserMode:
 *
 * A parser can operate in various modes
 */
    /* *
 * xmlParserCtxt:
 *
 * The parser context.
 * NOTE This doesn't completely define the parser state, the (current ?)
 *      design of the parser uses recursive function calls since this allow
 *      and easy mapping from the production rules of the specification
 *      to the actual code. The drawback is that the actual function call
 *      also reflect the parser state. However most of the parsing routines
 *      takes as the only argument the parser context pointer, so migrating
 *      to a state based parser for progressive parsing shouldn't be too hard.
 */
    /* The SAX handler */
    /* For SAX interface only, used by DOM build */
    /* the document being built */
    /* is the document well formed */
    /* shall we replace entities ? */
    /* the XML version string */
    /* the declared encoding, if any */
    /* standalone document */
    /* an HTML(1)/Docbook(2) document
                                       * 3 is HTML after <head>
                                       * 10 is HTML after <body>
                                       */
    /* Input stream stack */
    /* Current input stream */
    /* Number of current input streams */
    /* Max number of input streams */
    /* stack of inputs */
    /* Node analysis stack only used for DOM building */
    /* Current parsed Node */
    /* Depth of the parsing stack */
    /* Max depth of the parsing stack */
    /* array of nodes */
    /* Whether node info should be kept */
    /* info about each node parsed */
    /* error code */
    /* reference and external subset */
    /* the internal subset has PE refs */
    /* are we parsing an external entity */
    /* is the document valid */
    /* shall we try to validate ? */
    /* The validity context */
    /* current type of input */
    /* next char look-ahead */
    /* the data directory */
    /* Node name stack */
    /* Current parsed Node */
    /* Depth of the parsing stack */
    /* Max depth of the parsing stack */
    /* array of nodes */
    /* number of xmlChar processed */
    /* used by progressive parsing lookup */
    /* ugly but ... */
    /* SAX callbacks are disabled */
    /* Parsing is in int 1/ext 2 subset */
    /* name of subset */
    /* URI of external subset */
    /* SYSTEM ID of external subset */
    /* xml:space values */
    /* Should the parser preserve spaces */
    /* Depth of the parsing stack */
    /* Max depth of the parsing stack */
    /* array of space infos */
    /* to prevent entity substitution loops */
    /* used to check entities boundaries */
    /* encoding of the in-memory content
				         actually an xmlCharEncoding */
    /* Those two fields are there to */
    /* Speed up large node parsing */
    /* signal pedantic warnings */
    /* For user data, libxml won't touch it */
    /* should the external subset be loaded */
    /* set line number in element content */
    /* document's own catalog */
    /* run in recovery mode */
    /* is this a progressive parsing */
    /* dictionary for the parser */
    /* array for the attributes callbacks */
    /* the size of the array */
    /* use strings from dict to build tree */
    /*
     * pre-interned strings
     */
    /*
     * Everything below is used only by the new SAX mode
     */
    /* operating in the new SAX mode */
    /* the number of inherited namespaces */
    /* the size of the arrays */
    /* the array of prefix/namespace name */
    /* which attribute were allocated */
    /* array of data for push */
    /* defaulted attributes if any */
    /* non-CDATA attributes if any */
    /* is the document XML Nanespace okay */
    /* Extra options */
    /*
     * Those fields are needed only for treaming parsing so far
     */
    /* Use dictionary names for the tree */
    /* number of freed element nodes */
    /* List of freed element nodes */
    /* number of freed attributes nodes */
    /* List of freed attributes nodes */
    /*
     * the complete error informations for the last error.
     */
    /* the parser mode */
    /* number of entities references */
    /* size of parsed entities */
    /* for use by HTML non-recursive parser */
    /* Current NodeInfo */
    /* Depth of the parsing stack */
    /* Max depth of the parsing stack */
    /* array of nodeInfos */
    /* we need to label inputs */
    /* volume of entity copy */
    /* *
 * xmlSAXLocator:
 *
 * A SAX Locator.
 */
    /* *
 * xmlSAXHandler:
 *
 * A SAX handler is bunch of callbacks called by the parser when processing
 * of the input generate data or structure informations.
 */
    /* *
 * resolveEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * Callback:
 * The entity loader, to control the loading of external entities,
 * the application can either:
 *    - override this resolveEntity() callback in the SAX block
 *    - or better use the xmlSetExternalEntityLoader() function to
 *      set up it's own entity resolution routine
 *
 * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
 */
    /* *
 * internalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on internal subset declaration.
 */
    /* *
 * externalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on external subset declaration.
 */
    /* *
 * getEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get an entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
    /* *
 * getParameterEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get a parameter entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
    /* *
 * entityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the entity name
 * @type:  the entity type
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @content: the entity value (without processing).
 *
 * An entity definition has been parsed.
 */
    /* *
 * notationDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the notation
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * What to do when a notation declaration has been parsed.
 */
    /* *
 * attributeDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @elem:  the name of the element
 * @fullname:  the attribute name
 * @type:  the attribute type
 * @def:  the type of default value
 * @defaultValue: the attribute default value
 * @tree:  the tree of enumerated value set
 *
 * An attribute definition has been parsed.
 */
    /* *
 * elementDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the element name
 * @type:  the element type
 * @content: the element value tree
 *
 * An element definition has been parsed.
 */
    /* *
 * unparsedEntityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the entity
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @notationName: the name of the notation
 *
 * What to do when an unparsed entity declaration is parsed.
 */
    /* *
 * setDocumentLocatorSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @loc: A SAX Locator
 *
 * Receive the document locator at startup, actually xmlDefaultSAXLocator.
 * Everything is available on the context, so this is useless in our case.
 */
    /* *
 * startDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document start being processed.
 */
    /* *
 * endDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document end has been detected.
 */
    /* *
 * startElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name, including namespace prefix
 * @atts:  An array of name/value attributes pairs, NULL terminated
 *
 * Called when an opening tag has been processed.
 */
    /* *
 * endElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name
 *
 * Called when the end of an element has been detected.
 */
    /* *
 * attributeSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The attribute name, including namespace prefix
 * @value:  The attribute value
 *
 * Handle an attribute that has been read by the parser.
 * The default handling is to convert the attribute into an
 * DOM subtree and past it in a new xmlAttr element added to
 * the element.
 */
    /* *
 * referenceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The entity name
 *
 * Called when an entity reference is detected.
 */
    /* *
 * charactersSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some chars from the parser.
 */
    /* *
 * ignorableWhitespaceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some ignorable whitespaces from the parser.
 * UNUSED: by default the DOM building will use characters.
 */
    /* *
 * processingInstructionSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @target:  the target name
 * @data: the PI data's
 *
 * A processing instruction has been parsed.
 */
    /* *
 * commentSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  the comment content
 *
 * A comment has been parsed.
 */
    /* *
 * cdataBlockSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  The pcdata content
 * @len:  the block length
 *
 * Called when a pcdata block has been parsed.
 */
    /* *
 * warningSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format a warning messages, callback.
 */
    /* *
 * errorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format an error messages, callback.
 */
    /* *
 * fatalErrorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format fatal error messages, callback.
 * Note: so far fatalError() SAX callbacks are not used, error()
 *       get all the callbacks for errors.
 */
    /* *
 * isStandaloneSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Is this document tagged standalone?
 *
 * Returns 1 if true
 */
    /* *
 * hasInternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an internal subset.
 *
 * Returns 1 if true
 */
    /* *
 * hasExternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an external subset?
 *
 * Returns 1 if true
 */
    /* ***********************************************************************
 *									*
 *			The SAX version 2 API extensions		*
 *									*
 ************************************************************************/
/* *
 * XML_SAX2_MAGIC:
 *
 * Special constant found in SAX2 blocks initialized fields
 */
    /* *
 * startElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 * @nb_namespaces:  number of namespace definitions on that node
 * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
 * @nb_attributes:  the number of attributes on that node
 * @nb_defaulted:  the number of defaulted attributes. The defaulted
 *                  ones are at the end of the array
 * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
 *               attribute values.
 *
 * SAX2 callback when an element start has been detected by the parser.
 * It provides the namespace informations for the element, as well as
 * the new namespace declarations on the element.
 */
    /* *
 * endElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 *
 * SAX2 callback when an element end has been detected by the parser.
 * It provides the namespace informations for the element.
 */
    /* unused error() get all the errors */
    /* The following fields are extensions available only on version 2 */
    /*
 * SAX Version 1
 */
    /* unused error() get all the errors */
    /* *
 * xmlExternalEntityLoader:
 * @URL: The System ID of the resource requested
 * @ID: The Public ID of the resource requested
 * @context: the XML parser context
 *
 * External entity loaders types.
 *
 * Returns the entity input parser.
 */
    /*
 * Init/Cleanup
 */
    /*
 * Input functions
 */
    /*
 * Basic parsing Interfaces
 */
    /* LIBXML_SAX1_ENABLED */
    /*
 * Recovery mode
 */
    /* LIBXML_SAX1_ENABLED */
    /*
 * Less common routines and SAX interfaces
 */
    /* LIBXML_SAX1_ENABLED */
    /* LIBXML_VALID_ENABLE */
    /* LIBXML_SAX1_ENABLED */
    /* LIBXML_SAX1_ENABLED */
    /*
 * Parser contexts handling.
 */
    /* LIBXML_SAX1_ENABLED */
    /*
 * Reading/setting optional parsing features.
 */
    /* LIBXML_LEGACY_ENABLED */
    /*
 * Interfaces for the Push mode.
 */
    /* LIBXML_PUSH_ENABLED */
    /*
 * Special I/O mode.
 */
    /*
 * Node infos.
 */
    #[no_mangle]
    fn xmlParserAddNodeInfo(ctxt: xmlParserCtxtPtr,
                            info: xmlParserNodeInfoPtr);
    /*
 * Summary: string dictionary
 * Description: dictionary of reusable strings, just used to avoid allocation
 *         and freeing operations.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * The dictionary.
 */
    /*
 * Initializer
 */
    /*
 * Constructor and destructor.
 */
    /*
 * Lookup of entry in the dictionary.
 */
    #[no_mangle]
    fn xmlDictLookup(dict: xmlDictPtr, name: *const xmlChar, len: std::os::raw::c_int)
     -> *const xmlChar;
    /*
 * LIBXML2_NEW_BUFFER:
 *
 * Macro used to express that the API use the new buffers for
 * xmlParserInputBuffer and xmlOutputBuffer. The change was
 * introduced in 2.9.0.
 */
    /* *
 * XML_XML_NAMESPACE:
 *
 * This is the namespace for the special xml: prefix predefined in the
 * XML Namespace specification.
 */
    /* *
 * XML_XML_ID:
 *
 * This is the name for the special xml:id attribute
 */
    /*
 * The different element types carried by an XML tree.
 *
 * NOTE: This is synchronized with DOM Level1 values
 *       See http://www.w3.org/TR/REC-DOM-Level-1/
 *
 * Actually this had diverged a bit, and now XML_DOCUMENT_TYPE_NODE should
 * be deprecated to use an XML_DTD_NODE.
 */
    /* *
 * xmlNotation:
 *
 * A DTD Notation definition.
 */
    /* Notation name */
    /* Public identifier, if any */
    /* System identifier, if any */
    /* *
 * xmlAttributeType:
 *
 * A DTD Attribute type definition.
 */
    /* *
 * xmlAttributeDefault:
 *
 * A DTD Attribute default definition.
 */
    /* *
 * xmlEnumeration:
 *
 * List structure used when there is an enumeration in DTDs.
 */
    /* next one */
    /* Enumeration name */
    /* *
 * xmlAttribute:
 *
 * An Attribute declaration in a DTD.
 */
    /* application data */
    /* XML_ATTRIBUTE_DECL, must be second ! */
    /* Attribute name */
    /* NULL */
    /* NULL */
    /* -> DTD */
    /* next sibling link  */
    /* previous sibling link  */
    /* the containing document */
    /* next in hash table */
    /* The attribute type */
    /* the default */
    /* or the default value */
    /* or the enumeration tree if any */
    /* the namespace prefix if any */
    /* Element holding the attribute */
    /* *
 * xmlElementContentType:
 *
 * Possible definitions of element content types.
 */
    /* *
 * xmlElementContentOccur:
 *
 * Possible definitions of element content occurrences.
 */
    /* *
 * xmlElementContent:
 *
 * An XML Element content as stored after parsing an element definition
 * in a DTD.
 */
    /* PCDATA, ELEMENT, SEQ or OR */
    /* ONCE, OPT, MULT or PLUS */
    /* Element name */
    /* first child */
    /* second child */
    /* parent */
    /* Namespace prefix */
    /* *
 * xmlElementTypeVal:
 *
 * The different possibilities for an element content type.
 */
    /* *
 * xmlElement:
 *
 * An XML Element declaration from a DTD.
 */
    /* application data */
    /* XML_ELEMENT_DECL, must be second ! */
    /* Element name */
    /* NULL */
    /* NULL */
    /* -> DTD */
    /* next sibling link  */
    /* previous sibling link  */
    /* the containing document */
    /* The type */
    /* the allowed element content */
    /* List of the declared attributes */
    /* the namespace prefix if any */
    /* the validating regexp */
    /* *
 * XML_LOCAL_NAMESPACE:
 *
 * A namespace declaration node.
 */
    /* *
 * xmlNs:
 *
 * An XML namespace.
 * Note that prefix == NULL is valid, it defines the default namespace
 * within the subtree (until overridden).
 *
 * xmlNsType is unified with xmlElementType.
 */
    /* next Ns link for this node  */
    /* global or local */
    /* URL for the namespace */
    /* prefix for the namespace */
    /* application data */
    /* normally an xmlDoc */
    /* *
 * xmlDtd:
 *
 * An XML DTD, as defined by <!DOCTYPE ... There is actually one for
 * the internal subset and for the external subset.
 */
    /* application data */
    /* XML_DTD_NODE, must be second ! */
    /* Name of the DTD */
    /* the value of the property link */
    /* last child link */
    /* child->parent link */
    /* next sibling link  */
    /* previous sibling link  */
    /* the containing document */
    /* End of common part */
    /* Hash table for notations if any */
    /* Hash table for elements if any */
    /* Hash table for attributes if any */
    /* Hash table for entities if any */
    /* External identifier for PUBLIC DTD */
    /* URI for a SYSTEM or PUBLIC DTD */
    /* Hash table for param entities if any */
    /* *
 * xmlAttr:
 *
 * An attribute on an XML node.
 */
    /* application data */
    /* XML_ATTRIBUTE_NODE, must be second ! */
    /* the name of the property */
    /* the value of the property */
    /* NULL */
    /* child->parent link */
    /* next sibling link  */
    /* previous sibling link  */
    /* the containing document */
    /* pointer to the associated namespace */
    /* the attribute type if validating */
    /* for type/PSVI informations */
    /* *
 * xmlID:
 *
 * An XML ID instance.
 */
    /* next ID */
    /* The ID name */
    /* The attribute holding it */
    /* The attribute if attr is not available */
    /* The line number if attr is not available */
    /* The document holding the ID */
    /* *
 * xmlRef:
 *
 * An XML IDREF instance.
 */
    /* next Ref */
    /* The Ref name */
    /* The attribute holding it */
    /* The attribute if attr is not available */
    /* The line number if attr is not available */
    /* *
 * xmlNode:
 *
 * A node in an XML tree.
 */
    /* application data */
    /* type number, must be second ! */
    /* the name of the node, or the entity */
    /* parent->childs link */
    /* last child link */
    /* child->parent link */
    /* next sibling link  */
    /* previous sibling link  */
    /* the containing document */
    /* End of common part */
    /* pointer to the associated namespace */
    /* the content */
    /* properties list */
    /* namespace definitions on this node */
    /* for type/PSVI informations */
    /* line number */
    /* extra data for XPath/XSLT */
    /* *
 * XML_GET_CONTENT:
 *
 * Macro to extract the content pointer of a node.
 */
    /* *
 * XML_GET_LINE:
 *
 * Macro to extract the line number of an element node.
 */
    /* *
 * xmlDocProperty
 *
 * Set of properties of the document as found by the parser
 * Some of them are linked to similary named xmlParserOption
 */
    /* document is XML well formed */
    /* document is Namespace valid */
    /* parsed with old XML-1.0 parser */
    /* DTD validation was successful */
    /* XInclude substitution was done */
    /* Document was built using the API
                                           and not by parsing an instance */
    /* built for internal processing */
    /* parsed or built HTML document */
    /* *
 * xmlDoc:
 *
 * An XML document.
 */
    /* application data */
    /* XML_DOCUMENT_NODE, must be second ! */
    /* name/filename/URI of the document */
    /* the document tree */
    /* last child link */
    /* child->parent link */
    /* next sibling link  */
    /* previous sibling link  */
    /* autoreference to itself */
    /* End of common part */
    /* level of zlib compression */
    /* standalone document (no external refs)
				     1 if standalone="yes"
				     0 if standalone="no"
				    -1 if there is no XML declaration
				    -2 if there is an XML declaration, but no
					standalone attribute was specified */
    /* the document internal subset */
    /* the document external subset */
    /* Global namespace, the old way */
    /* the XML version string */
    /* external initial encoding, if any */
    /* Hash table for ID attributes if any */
    /* Hash table for IDREFs attributes if any */
    /* The URI for that document */
    /* encoding of the in-memory content
				   actually an xmlCharEncoding */
    /* dict used to allocate names or NULL */
    /* for type/PSVI informations */
    /* set of xmlParserOption used to parse the
				   document */
    /* set of xmlDocProperties for this document
				   set at the end of parsing */
    /* *
 * xmlDOMWrapAcquireNsFunction:
 * @ctxt:  a DOM wrapper context
 * @node:  the context node (element or attribute)
 * @nsName:  the requested namespace name
 * @nsPrefix:  the requested namespace prefix
 *
 * A function called to acquire namespaces (xmlNs) from the wrapper.
 *
 * Returns an xmlNsPtr or NULL in case of an error.
 */
    /* *
 * xmlDOMWrapCtxt:
 *
 * Context for DOM wrapper-operations.
 */
    /*
    * The type of this context, just in case we need specialized
    * contexts in the future.
    */
    /*
    * Internal namespace map used for various operations.
    */
    /*
    * Use this one to acquire an xmlNsPtr intended for node->ns.
    * (Note that this is not intended for elem->nsDef).
    */
    /* *
 * xmlChildrenNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children."
 */
    /* *
 * xmlRootNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children".
 */
    /*
 * Variables.
 */
    /*
 * Some helper functions
 */
    /*
 * Handling Buffers, the old ones see @xmlBuf for the new ones.
 */
    /*
 * Creating/freeing new structures.
 */
    #[no_mangle]
    fn xmlGetIntSubset(doc: *const xmlDoc) -> xmlDtdPtr;
    /* LIBXML_LEGACY_ENABLED */
    /* LIBXML_TREE_ENABLED */
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
    /*
 * Creating new nodes.
 */
    /* LIBXML_TREE_ENABLED */
    /*
 * Navigating.
 */
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
    #[no_mangle]
    fn xmlGetLastChild(parent: *const xmlNode) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNodeIsText(node: *const xmlNode) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlLoadExternalEntity(URL: *const std::os::raw::c_char,
                             ID: *const std::os::raw::c_char, ctxt: xmlParserCtxtPtr)
     -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlInitNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
    #[no_mangle]
    fn xmlNewIOInputStream(ctxt: xmlParserCtxtPtr,
                           input: xmlParserInputBufferPtr,
                           enc: xmlCharEncoding) -> xmlParserInputPtr;
    #[no_mangle]
    static mut xmlRealloc: xmlReallocFunc;
    /*
 * Summary: error handling
 * Description: the API used to report errors
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlErrorLevel:
 *
 * Indicates the level of an error
 */
    /* A simple warning */
    /* A recoverable error */
    /* A fatal error */
    /* *
 * xmlErrorDomain:
 *
 * Indicates where an error may have come from
 */
    /* The XML parser */
    /* The tree module */
    /* The XML Namespace module */
    /* The XML DTD validation with parser context*/
    /* The HTML parser */
    /* The memory allocator */
    /* The serialization code */
    /* The Input/Output stack */
    /* The FTP module */
    /* The HTTP module */
    /* The XInclude processing */
    /* The XPath module */
    /* The XPointer module */
    /* The regular expressions module */
    /* The W3C XML Schemas Datatype module */
    /* The W3C XML Schemas parser module */
    /* The W3C XML Schemas validation module */
    /* The Relax-NG parser module */
    /* The Relax-NG validator module */
    /* The Catalog module */
    /* The Canonicalization module */
    /* The XSLT engine from libxslt */
    /* The XML DTD validation with valid context */
    /* The error checking module */
    /* The xmlwriter module */
    /* The dynamically loaded module module*/
    /* The module handling character conversion */
    /* The Schematron validator module */
    /* The buffers module */
    /* The URI module */
    /* *
 * xmlError:
 *
 * An XML Error instance.
 */
    /* What part of the library raised this error */
    /* The error code, e.g. an xmlParserError */
    /* human-readable informative error message */
    /* how consequent is the error */
    /* the filename */
    /* the line number if available */
    /* extra string information */
    /* extra string information */
    /* extra string information */
    /* extra number information */
    /* error column # or 0 if N/A (todo: rename field when we would brk ABI) */
    /* the parser context if available */
    /* the node in the tree */
    /* *
 * xmlParserError:
 *
 * This is an error that the XML (or HTML) parser can generate
 */
    /* 1 */
    /* 2 */
    /* 3 */
    /* 4 */
    /* 5 */
    /* 6 */
    /* 7 */
    /* 8 */
    /* 9 */
    /* 10 */
    /* 11 */
    /* 12 */
    /* 13 */
    /* 14 */
    /* 15 */
    /* 16 */
    /* 17 */
    /* 18 */
    /* 19 */
    /* 20 */
    /* 21 */
    /* 22 */
    /* 23 */
    /* 24 */
    /* 25 */
    /* 26 */
    /* 27 */
    /* 28 */
    /* 29 */
    /* 30 */
    /* 31 */
    /* 32 */
    /* 33 */
    /* 34 */
    /* 35 */
    /* 36 */
    /* 37 */
    /* 38 */
    /* 39 */
    /* 40 */
    /* 41 */
    /* 42 */
    /* 43 */
    /* 44 */
    /* 45 */
    /* 46 */
    /* 47 */
    /* 48 */
    /* 49 */
    /* 50 */
    /* 51 */
    /* 52 */
    /* 53 */
    /* 54 */
    /* 55 */
    /* 56 */
    /* 57 */
    /* 58 */
    /* 59 */
    /* 60 */
    /* 61 */
    /* 62 */
    /* 63 */
    /* 64 */
    /* 65 */
    /* 66 */
    /* 67 */
    /* 68 */
    /* 69 */
    /* 70 */
    /* 71 */
    /* 72 */
    /* 73 */
    /* 74 */
    /* 75 */
    /* 76 */
    /* 77 */
    /* 78 */
    /* 79 */
    /* 80 */
    /* 81 */
    /* 82 */
    /* 83 */
    /* 84 */
    /* 85 */
    /* 86 */
    /* 87 */
    /* 88 */
    /* 89 */
    /* 90 */
    /* 91 */
    /* 92 */
    /* 93 */
    /* 94 */
    /* 95 */
    /* 96 */
    /* 97 */
    /* 98 */
    /* 99 */
    /* 100 */
    /* 101 */
    /* 102 */
    /* 103 */
    /* 104 */
    /* 105 */
    /* 106 */
    /* 107 */
    /* 108 */
    /* 109 */
    /* 110 */
    /* 111 */
    /* 201 */
    /* 202 */
    /* 203 */
    /* 204 */
    /* 205 */
    /* 501 */
    /* 502 */
    /* 503 */
    /* 504 */
    /* 505 */
    /* 506 */
    /* 507 */
    /* 508 */
    /* 509 */
    /* 510 */
    /* 511 */
    /* 512 */
    /* 513 */
    /* 514 */
    /* 515 */
    /* 516 */
    /* 517 */
    /* 518 */
    /* 519 */
    /* 520 */
    /* 521 */
    /* 522 */
    /* 523 */
    /* 524 */
    /* 525 */
    /* 526 */
    /* 527 */
    /* 528 */
    /* 529 */
    /* 530 */
    /* 531 */
    /* 532 */
    /* 533 */
    /* 534 */
    /* 535 */
    /* 536 */
    /* 537 */
    /* 538 */
    /* 539 */
    /* 540 */
    /* 541 */
    /* 801 */
    /* 1001 */
    /* 1002 */
    /* 1003 */
    /* 1004 */
    /* 1005 */
    /* 1006 */
    /* 1007 */
    /* 1008 */
    /* 1009 */
    /* 1010 */
    /* 1011 */
    /* 1012 */
    /* 1013 */
    /* 1014 */
    /* 1015 */
    /* 1016 */
    /* 1017 */
    /* 1018 */
    /* 1019 */
    /* 1020 */
    /* 1021 */
    /* 1022 */
    /* 1023 */
    /* 1024 */
    /* 1025 */
    /* 1026 */
    /* 1027 */
    /* 1028 */
    /* 1029 */
    /* 1030 */
    /* 1031 */
    /* 1032 */
    /* 1033 */
    /* 1034 */
    /* 1035 */
    /* 1036 */
    /* 1037 */
    /* 1038 */
    /* 1039 */
    /* 1040 */
    /* 1041 */
    /* 1042 */
    /* 1043 */
    /* 1044 */
    /* 1045 */
    /* 1046 */
    /* 1047 */
    /* 1048 */
    /* 1049 */
    /* 1050 */
    /* 1051 */
    /* 1052 */
    /* 1053 */
    /* 1054 */
    /* 1055 */
    /* 1056 */
    /* 1057 */
    /* 1058 */
    /* 1059 */
    /* 1060 */
    /* 1061 */
    /* 1062 */
    /* 1063 */
    /* 1064 */
    /* 1065 */
    /* 1066 */
    /* 1067 */
    /* 1068 */
    /* 1069 */
    /* 1070 */
    /* 1071 */
    /* 1072 */
    /* 1073 */
    /* 1074 */
    /* 1075 */
    /* 1076 */
    /* 1077 */
    /* 1078 */
    /* 1079 */
    /* 1080 */
    /* 1081 */
    /* 1082 */
    /* 1083 */
    /* 1084 */
    /* 1085 */
    /* 1086 */
    /* 1087 */
    /* 1088 */
    /* 1089 */
    /* 1090 */
    /* 1091 */
    /* 1092 */
    /* 1093 */
    /* 1094 */
    /* 1095 */
    /* 1096 */
    /* 1097 */
    /* 1098 */
    /* 1099 */
    /* 1100 */
    /* 1101 */
    /* 1102 */
    /* 1103 */
    /* 1104 */
    /* 1105 */
    /* 1106 */
    /* 1107 */
    /* 1108 */
    /* 1109 */
    /* 1110 */
    /* 1111 */
    /* 1112 */
    /* 1113 */
    /* 1114 */
    /* 1115 */
    /* 1116 */
    /* 1117 */
    /* 1118 */
    /* 1119 */
    /* 1120 */
    /* 1121 */
    /* 1122 */
    /* 1201 */
    /* 1202 */
    /* 1203 */
    /* 1204 */
    /* 1205 */
    /* 1206 */
    /* 1207 */
    /* 1208 */
    /* 1209 */
    /* 1210 */
    /* 1211 */
    /* 1212 */
    /* 1213 */
    /* 1214 */
    /* 1215 */
    /* 1216 */
    /* 1217 */
    /* 1218 */
    /* 1219 */
    /* 1220 */
    /* 1221 */
    /* 1301 */
    /* 1302 */
    /* 1303 */
    /* 1401 */
    /* 1402 */
    /* 1403 */
    /* 1501 */
    /* 1502 */
    /* 1503 */
    /* 1504 */
    /* 1505 */
    /* 1506 */
    /* 1507 */
    /* 1508 */
    /* 1509 */
    /* 1510 */
    /* 1511 */
    /* 1512 */
    /* 1513 */
    /* 1514 */
    /* 1515 */
    /* 1516 */
    /* 1517 */
    /* 1518 */
    /* 1519 */
    /* 1520 */
    /* 1521 */
    /* 1522 */
    /* 1523 */
    /* 1524 */
    /* 1525 */
    /* 1526 */
    /* 1527 */
    /* 1528 */
    /* 1529 */
    /* 1530 */
    /* 1531 */
    /* 1532 */
    /* 1533 */
    /* 1534 */
    /* 1535 */
    /* 1536 */
    /* 1537 */
    /* 1538 */
    /* 1539 */
    /* 1540 */
    /* 1541 */
    /* 1542 */
    /* 1543 */
    /* 1544 */
    /* 1545 */
    /* 1546 */
    /* 1547 */
    /* 1548 */
    /* 1549 */
    /* 1550 */
    /* 1551 */
    /* 1552 */
    /* 1553 */
    /* 1554 */
    /* 1555 */
    /* 1556 */
    /* 1601 */
    /* 1602 */
    /* 1603 */
    /* 1604 */
    /* 1605 */
    /* 1606 */
    /* 1607 */
    /* 1608 */
    /* 1609 */
    /* 1610 */
    /* 1611 */
    /* 1612 */
    /* 1613 */
    /* 1614 */
    /* 1615 */
    /* 1616 */
    /* 1617 */
    /* 1618 */
    /* 1651 */
    /* 1652 */
    /* 1653 */
    /* 1654 */
    /* 1701 */
    /* 1702 */
    /* 1703 */
    /* 1704 */
    /* 1705 */
    /* 1706 */
    /* 1707 */
    /* 1708 */
    /* 1709 */
    /* 1710 */
    /* 1711 */
    /* 1712 */
    /* 1713 */
    /* 1714 */
    /* 1715 */
    /* 1716 */
    /* 1717 */
    /* 1718 */
    /* 1719 */
    /* 1720 */
    /* 1721 */
    /* 1722 */
    /* 1723 */
    /* 1724 */
    /* 1725 */
    /* 1726 */
    /* 1727 */
    /* 1728 */
    /* 1729 */
    /* 1730 */
    /* 1731 */
    /* 1732 */
    /* 1733 */
    /* 1734 */
    /* 1735 */
    /* 1736 */
    /* 1737 */
    /* 1738 */
    /* 1739 */
    /* 1740 */
    /* 1741 */
    /* 1742 */
    /* 1743 */
    /* 1744 */
    /* 1745 */
    /* 1746 */
    /* 1747 */
    /* 1748 */
    /* 1749 */
    /* 1750 */
    /* 1751 */
    /* 1752 */
    /* 1753 */
    /* 1754 */
    /* 1755 */
    /* 1756 */
    /* 1757 */
    /* 1758 */
    /* 1759 */
    /* 1760 */
    /* 1761 */
    /* 1762 */
    /* 1763 */
    /* 1764 */
    /* 1765 */
    /* 1766 */
    /* 1767 */
    /* 1768 */
    /* 1769 */
    /* 1770 */
    /* 1771 */
    /* 1772 */
    /* 1773 */
    /* 1774 */
    /* 1775 */
    /* 1776 */
    /* 1777 */
    /* 1778 */
    /* 1779 */
    /* 1780 */
    /* 1781 */
    /* 1782 */
    /* 1783 */
    /* 1784 */
    /* 1785 */
    /* 1786 */
    /* 1787 */
    /* 1788 */
    /* 1789 */
    /* 1790 */
    /* 1791 */
    /* 1792 */
    /* 1793 */
    /* 1794 */
    /* 1795 */
    /* 1796 */
    /* 1797 */
    /* 1798 */
    /* 1799 */
    /* 1800 */
    /* 1802 */
    /* 1803 */
    /* 1804 */
    /* 1805 */
    /* 1806 */
    /* 1807 */
    /* 1808 */
    /* 1809 */
    /* 1810 */
    /* 1811 */
    /* 1812 */
    /* 1813 */
    /* 1814 */
    /* 1815 */
    /* 1816 */
    /* 1817 */
    /* 1818 */
    /* 1819 */
    /* 1820 */
    /* 1821 */
    /* 1822 */
    /* 1823 */
    /* 1824 */
    /* 1825 */
    /* 1826 */
    /* 1827 */
    /* 1828 */
    /* 1829 */
    /* 1830 */
    /* 1831 */
    /* 1832 */
    /* 1833 */
    /* 1834 */
    /* 1835 */
    /* 1836 */
    /* 1837 */
    /* 1838 */
    /* 1839 */
    /* 1840 */
    /* 1841 */
    /* 1842 */
    /* 1843 */
    /* 1844 */
    /* 1845 */
    /* 1846 */
    /* 1847 */
    /* 1848 */
    /* 1849 */
    /* 1850 */
    /* 1851 */
    /* 1852 */
    /* 1853 */
    /* 1854 */
    /* 1855 */
    /* 1856 */
    /* 1857 */
    /* 1858 */
    /* 1859 */
    /* 1860 */
    /* 1861 */
    /* 1862 */
    /* 1863 */
    /* 1864 */
    /* 1865 */
    /* 1866 */
    /* 1867 */
    /* 1868 */
    /* 1869 */
    /* 1870 */
    /* 1871 */
    /* 1872 */
    /* 1873 */
    /* 1874 */
    /* 1875 */
    /* 1876 */
    /* 1877 */
    /* 1878 */
    /* 1879 */
    /* 1901 */
    /* 1902 */
    /* 1903 */
    /* 1951 */
    /* 1952 */
    /* 1953 */
    /* 1954 */
    /* 1955 */
    /* 2001 */
    /* 2002 */
    /* 2003 */
    /* 2021 */
    /* 2022 */
    /* 3001 */
    /* 3002 */
    /* 3003 */
    /* 3004 */
    /* 3005 */
    /* 3006 */
    /* 3007 */
    /* 3008 */
    /* 3009 */
    /* 3010 */
    /* 3011 */
    /* 3012 */
    /* 3013 */
    /* 3014 */
    /* 3015 */
    /* 3016 */
    /* 3017 */
    /* 3018 */
    /* 3019 */
    /* 3020 */
    /* 3021 */
    /* 3022 */
    /* 3023 */
    /* 3024 */
    /* 3025 */
    /* 3026 */
    /* 3027 */
    /* 3028 */
    /* 3029 */
    /* 3030 */
    /* 3031 */
    /* 3032 */
    /* 3033 */
    /* 3034 */
    /* 3035 */
    /* 3036 */
    /* 3037 */
    /* 3038 */
    /* 3039 */
    /* 3040 */
    /* 3041 */
    /* 3042 */
    /* 3043 */
    /* 3044 */
    /* 3045 */
    /* 3046 */
    /* 3047 */
    /* 3048 */
    /* 3049 */
    /* 3050 */
    /* 3051 */
    /* 3052 */
    /* 3053 */
    /* 3054 */
    /* 3055 */
    /* 3056 */
    /* 3057 */
    /* 3058 */
    /* 3059 */
    /* 3060 */
    /* 3061 */
    /* 3062 */
    /* 3063 */
    /* 3064 */
    /* 3065 */
    /* 3066 */
    /* 3067 */
    /* 3068 */
    /* 3069 non-W3C */
    /* 3070 non-W3C */
    /* 3071 */
    /* 3072 */
    /* 3073 */
    /* 3074 */
    /* 3075 */
    /* 3076 */
    /* 3077 */
    /* 3078 */
    /* 3079 */
    /* 3080 */
    /* 3081 */
    /* 3082 */
    /* 3083 */
    /* 3084 */
    /* 3085 */
    /* 3085 */
    /* 3086 */
    /* 3087 */
    /* 3088 */
    /* 3089 */
    /* 3090 */
    /* 4000 */
    /* 4900 */
    /* 4901 */
    /* 5001 */
    /* 5002 */
    /* 5003 */
    /* 5004 */
    /* 5005 */
    /* 5006 */
    /* 5007 */
    /* 5008 */
    /* 5009 */
    /* 5010 */
    /* 5011 */
    /* 5012 */
    /* 5013 */
    /* 5014 */
    /* 5015 */
    /* 5016 */
    /* 5017 */
    /* 5018 */
    /* 5019 */
    /* 5020 */
    /* 5021 */
    /* 5022 */
    /* 5023 */
    /* 5024 */
    /* 5025 */
    /* 5026 */
    /* 5027 */
    /* 5028 */
    /* 5029 */
    /* 5030 */
    /* 5031 */
    /* 5032 */
    /* 5033 */
    /* 5034 */
    /* 5035 */
    /* 5036 */
    /* 5037 */
    /* 6001 */
    /* 6002 */
    /* 6003 */
    /* 6004 */
    /* *
 * xmlGenericErrorFunc:
 * @ctx:  a parsing context
 * @msg:  the message
 * @...:  the extra arguments of the varags to format the message
 *
 * Signature of the function to use when there is an error and
 * no parsing or validity context available .
 */
    /* *
 * xmlStructuredErrorFunc:
 * @userData:  user provided data for the error callback
 * @error:  the error being raised.
 *
 * Signature of the function to use when there is an error and
 * the module handles the new error reporting mechanism.
 */
    /*
 * Use the following function to reset the two global variables
 * xmlGenericError and xmlGenericErrorContext.
 */
    /*
 * Default message routines used by SAX and Valid context for error
 * and warning reporting.
 */
    /*
 * Extended error information routines
 */
    /*
 * Internal callback reporting routine
 */
    #[no_mangle]
    fn __xmlRaiseError(schannel: xmlStructuredErrorFunc,
                       channel: xmlGenericErrorFunc, data: *mut std::os::raw::c_void,
                       ctx: *mut std::os::raw::c_void, node: *mut std::os::raw::c_void,
                       domain: std::os::raw::c_int, code: std::os::raw::c_int,
                       level: xmlErrorLevel, file: *const std::os::raw::c_char,
                       line: std::os::raw::c_int, str1: *const std::os::raw::c_char,
                       str2: *const std::os::raw::c_char, str3: *const std::os::raw::c_char,
                       int1: std::os::raw::c_int, col: std::os::raw::c_int,
                       msg: *const std::os::raw::c_char, _: ...);
    #[no_mangle]
    fn xmlParserInputGrow(in_0: xmlParserInputPtr, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    #[no_mangle]
    fn xmlBufContent(buf: *const xmlBuf) -> *mut xmlChar;
    #[no_mangle]
    fn xmlBufUse(buf: xmlBufPtr) -> size_t;
    #[no_mangle]
    fn xmlDictCreate() -> xmlDictPtr;
    #[no_mangle]
    fn xmlDictOwns(dict: xmlDictPtr, str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCreateIntSubset(doc: xmlDocPtr, name: *const xmlChar,
                          ExternalID: *const xmlChar,
                          SystemID: *const xmlChar) -> xmlDtdPtr;
    #[no_mangle]
    fn xmlFreeDoc(cur: xmlDocPtr);
    #[no_mangle]
    fn xmlHashFree(table: xmlHashTablePtr, f: xmlHashDeallocator);
    #[no_mangle]
    fn xmlHashDefaultDeallocator(entry: *mut std::os::raw::c_void,
                                 name: *const xmlChar);
    #[no_mangle]
    fn xmlParserValidityError(ctx: *mut std::os::raw::c_void,
                              msg: *const std::os::raw::c_char, _: ...);
    #[no_mangle]
    fn xmlParserValidityWarning(ctx: *mut std::os::raw::c_void,
                                msg: *const std::os::raw::c_char, _: ...);
    #[no_mangle]
    fn xmlFreeParserCtxt(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
    /*
 * Interfaces directly used by the parsers.
 */
    #[no_mangle]
    fn xmlDetectCharEncoding(in_0: *const std::os::raw::c_uchar, len: std::os::raw::c_int)
     -> xmlCharEncoding;
    #[no_mangle]
    fn xmlAllocParserInputBuffer(enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateFd(fd: std::os::raw::c_int, enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateMem(mem: *const std::os::raw::c_char,
                                     size: std::os::raw::c_int, enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateIO(ioread: xmlInputReadCallback,
                                    ioclose: xmlInputCloseCallback,
                                    ioctx: *mut std::os::raw::c_void,
                                    enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferPush(in_0: xmlParserInputBufferPtr,
                                len: std::os::raw::c_int, buf: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlFreeParserInputBuffer(in_0: xmlParserInputBufferPtr);
    #[no_mangle]
    fn xmlParserGetDirectory(filename: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn xmlInitParser();
    /*
 * Summary: internals routines and limits exported by the parser.
 * Description: this module exports a number of internal parsing routines
 *              they are not really all intended for applications but
 *              can prove useful doing low level processing.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlParserMaxDepth:
 *
 * arbitrary depth limit for the XML documents that we allow to
 * process. This is not a limitation of the parser but a safety
 * boundary feature, use XML_PARSE_HUGE option to override it.
 */
    /* *
 * XML_MAX_TEXT_LENGTH:
 *
 * Maximum size allowed for a single text node when building a tree.
 * This is not a limitation of the parser but a safety boundary feature,
 * use XML_PARSE_HUGE option to override it.
 * Introduced in 2.9.0
 */
    /* *
 * XML_MAX_NAME_LENGTH:
 *
 * Maximum size allowed for a markup identitier
 * This is not a limitation of the parser but a safety boundary feature,
 * use XML_PARSE_HUGE option to override it.
 * Note that with the use of parsing dictionaries overriding the limit
 * may result in more runtime memory usage in face of "unfriendly' content
 * Introduced in 2.9.0
 */
    /* *
 * XML_MAX_DICTIONARY_LIMIT:
 *
 * Maximum size allowed by the parser for a dictionary by default
 * This is not a limitation of the parser but a safety boundary feature,
 * use XML_PARSE_HUGE option to override it.
 * Introduced in 2.9.0
 */
    /* *
 * XML_MAX_LOOKUP_LIMIT:
 *
 * Maximum size allowed by the parser for ahead lookup
 * This is an upper boundary enforced by the parser to avoid bad
 * behaviour on "unfriendly' content
 * Introduced in 2.9.0
 */
    /* *
 * XML_MAX_NAMELEN:
 *
 * Identifiers can be longer, but this will be more costly
 * at runtime.
 */
    /* *
 * INPUT_CHUNK:
 *
 * The parser tries to always have that amount of input ready.
 * One of the point is providing context when reporting errors.
 */
    /* ***********************************************************************
 *									*
 * UNICODE version of the macros.					*
 *									*
 ************************************************************************/
/* *
 * IS_BYTE_CHAR:
 * @c:  an byte value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [2] Char ::= #x9 | #xA | #xD | [#x20...]
 * any byte character in the accepted range
 */
    /* *
 * IS_CHAR:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]
 *                  | [#x10000-#x10FFFF]
 * any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
 */
    /* *
 * IS_CHAR_CH:
 * @c: an xmlChar (usually an unsigned char)
 *
 * Behaves like IS_CHAR on single-byte value
 */
    /* *
 * IS_BLANK:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [3] S ::= (#x20 | #x9 | #xD | #xA)+
 */
    /* *
 * IS_BLANK_CH:
 * @c:  an xmlChar value (normally unsigned char)
 *
 * Behaviour same as IS_BLANK
 */
    /* *
 * IS_BASECHAR:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [85] BaseChar ::= ... long list see REC ...
 */
    /* *
 * IS_DIGIT:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [88] Digit ::= ... long list see REC ...
 */
    /* *
 * IS_DIGIT_CH:
 * @c:  an xmlChar value (usually an unsigned char)
 *
 * Behaves like IS_DIGIT but with a single byte argument
 */
    /* *
 * IS_COMBINING:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 * [87] CombiningChar ::= ... long list see REC ...
 */
    /* *
 * IS_COMBINING_CH:
 * @c:  an xmlChar (usually an unsigned char)
 *
 * Always false (all combining chars > 0xff)
 */
    /* *
 * IS_EXTENDER:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 *
 * [89] Extender ::= #x00B7 | #x02D0 | #x02D1 | #x0387 | #x0640 |
 *                   #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] |
 *                   [#x309D-#x309E] | [#x30FC-#x30FE]
 */
    /* *
 * IS_EXTENDER_CH:
 * @c:  an xmlChar value (usually an unsigned char)
 *
 * Behaves like IS_EXTENDER but with a single-byte argument
 */
    /* *
 * IS_IDEOGRAPHIC:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 *
 * [86] Ideographic ::= [#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029]
 */
    /* *
 * IS_LETTER:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 *
 * [84] Letter ::= BaseChar | Ideographic
 */
    /* *
 * IS_LETTER_CH:
 * @c:  an xmlChar value (normally unsigned char)
 *
 * Macro behaves like IS_LETTER, but only check base chars
 *
 */
    /* *
 * IS_ASCII_LETTER:
 * @c: an xmlChar value
 *
 * Macro to check [a-zA-Z]
 *
 */
    /* *
 * IS_ASCII_DIGIT:
 * @c: an xmlChar value
 *
 * Macro to check [0-9]
 *
 */
    /* *
 * IS_PUBIDCHAR:
 * @c:  an UNICODE value (int)
 *
 * Macro to check the following production in the XML spec:
 *
 *
 * [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
 */
    /* *
 * IS_PUBIDCHAR_CH:
 * @c:  an xmlChar value (normally unsigned char)
 *
 * Same as IS_PUBIDCHAR but for single-byte value
 */
    /* *
 * SKIP_EOL:
 * @p:  and UTF8 string pointer
 *
 * Skips the end of line chars.
 */
    /* *
 * MOVETO_ENDTAG:
 * @p:  and UTF8 string pointer
 *
 * Skips to the next '>' char.
 */
    /* *
 * MOVETO_STARTTAG:
 * @p:  and UTF8 string pointer
 *
 * Skips to the next '<' char.
 */
    /* *
 * Global variables used for predefined strings.
 */
    /*
 * Function to finish the work of the macros where needed.
 */
    /* *
 * Parser context.
 */
    /* internal error reporting */
    /* *
 * Input Streams.
 */
    /* *
 * Namespaces.
 */
    /* *
 * Generic production rules.
 */
    /* LIBXML_SAX1_ENABLED */
    /* *
 * XML_SUBSTITUTE_NONE:
 *
 * If no entities need to be substituted.
 */
    /* *
 * XML_SUBSTITUTE_REF:
 *
 * Whether general entities need to be substituted.
 */
    /* *
 * XML_SUBSTITUTE_PEREF:
 *
 * Whether parameter entities need to be substituted.
 */
    /* *
 * XML_SUBSTITUTE_BOTH:
 *
 * Both general and parameter entities need to be substituted.
 */
    /*
 * Generated by MACROS on top of parser.c c.f. PUSH_AND_POP.
 */
    /*
 * other commodities shared between parser.c and parserInternals.
 */
    /*
 * Really core function shared with HTML parser.
 */
    #[no_mangle]
    fn xmlCurrentChar(ctxt: xmlParserCtxtPtr, len: *mut std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSwitchToEncoding(ctxt: xmlParserCtxtPtr,
                           handler: xmlCharEncodingHandlerPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSwitchEncoding(ctxt: xmlParserCtxtPtr, enc: xmlCharEncoding)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParserInputShrink(in_0: xmlParserInputPtr);
    #[no_mangle]
    fn xmlCopyChar(len: std::os::raw::c_int, out: *mut xmlChar, val: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNextChar(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    static xmlIsExtenderGroup: xmlChRangeGroup;
    #[no_mangle]
    fn xmlCharInRange(val: std::os::raw::c_uint, group: *const xmlChRangeGroup)
     -> std::os::raw::c_int;
    #[no_mangle]
    static xmlIsCombiningGroup: xmlChRangeGroup;
    #[no_mangle]
    static xmlIsDigitGroup: xmlChRangeGroup;
    #[no_mangle]
    static xmlIsBaseCharGroup: xmlChRangeGroup;
    #[no_mangle]
    fn nodePop(ctxt: xmlParserCtxtPtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlPopInput(ctxt: xmlParserCtxtPtr) -> xmlChar;
    #[no_mangle]
    fn xmlNewStringInputStream(ctxt: xmlParserCtxtPtr, buffer: *const xmlChar)
     -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlCreateMemoryParserCtxt(buffer: *const std::os::raw::c_char,
                                 size: std::os::raw::c_int) -> xmlParserCtxtPtr;
    #[no_mangle]
    fn inputPop(ctxt: xmlParserCtxtPtr) -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlFreeInputStream(input: xmlParserInputPtr);
    #[no_mangle]
    fn xmlNewInputStream(ctxt: xmlParserCtxtPtr) -> xmlParserInputPtr;
    #[no_mangle]
    fn inputPush(ctxt: xmlParserCtxtPtr, value: xmlParserInputPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    static xmlIsPubidChar_tab: [std::os::raw::c_uchar; 256];
    #[no_mangle]
    fn xmlCanonicPath(path: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlBufResetInput(buf: xmlBufPtr, input: xmlParserInputPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufGetInputBase(buf: xmlBufPtr, input: xmlParserInputPtr) -> size_t;
    #[no_mangle]
    fn xmlBufSetInputBaseCur(buf: xmlBufPtr, input: xmlParserInputPtr,
                             base: size_t, cur: size_t) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCharEncInput(input: xmlParserInputBufferPtr, flush: std::os::raw::c_int)
     -> std::os::raw::c_int;
}
pub type xmlChar = std::os::raw::c_uchar;
pub type size_t = std::os::raw::c_ulong;
pub type __int32_t = std::os::raw::c_int;
pub type htmlParserCtxtPtr = xmlParserCtxtPtr;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
pub type xmlParserCtxt = _xmlParserCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserCtxt {
    pub sax: *mut _xmlSAXHandler,
    pub userData: *mut std::os::raw::c_void,
    pub myDoc: xmlDocPtr,
    pub wellFormed: std::os::raw::c_int,
    pub replaceEntities: std::os::raw::c_int,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub html: std::os::raw::c_int,
    pub input: xmlParserInputPtr,
    pub inputNr: std::os::raw::c_int,
    pub inputMax: std::os::raw::c_int,
    pub inputTab: *mut xmlParserInputPtr,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub record_info: std::os::raw::c_int,
    pub node_seq: xmlParserNodeInfoSeq,
    pub errNo: std::os::raw::c_int,
    pub hasExternalSubset: std::os::raw::c_int,
    pub hasPErefs: std::os::raw::c_int,
    pub external: std::os::raw::c_int,
    pub valid: std::os::raw::c_int,
    pub validate: std::os::raw::c_int,
    pub vctxt: xmlValidCtxt,
    pub instate: xmlParserInputState,
    pub token: std::os::raw::c_int,
    pub directory: *mut std::os::raw::c_char,
    pub name: *const xmlChar,
    pub nameNr: std::os::raw::c_int,
    pub nameMax: std::os::raw::c_int,
    pub nameTab: *mut *const xmlChar,
    pub nbChars: std::os::raw::c_long,
    pub checkIndex: std::os::raw::c_long,
    pub keepBlanks: std::os::raw::c_int,
    pub disableSAX: std::os::raw::c_int,
    pub inSubset: std::os::raw::c_int,
    pub intSubName: *const xmlChar,
    pub extSubURI: *mut xmlChar,
    pub extSubSystem: *mut xmlChar,
    pub space: *mut std::os::raw::c_int,
    pub spaceNr: std::os::raw::c_int,
    pub spaceMax: std::os::raw::c_int,
    pub spaceTab: *mut std::os::raw::c_int,
    pub depth: std::os::raw::c_int,
    pub entity: xmlParserInputPtr,
    pub charset: std::os::raw::c_int,
    pub nodelen: std::os::raw::c_int,
    pub nodemem: std::os::raw::c_int,
    pub pedantic: std::os::raw::c_int,
    pub _private: *mut std::os::raw::c_void,
    pub loadsubset: std::os::raw::c_int,
    pub linenumbers: std::os::raw::c_int,
    pub catalogs: *mut std::os::raw::c_void,
    pub recovery: std::os::raw::c_int,
    pub progressive: std::os::raw::c_int,
    pub dict: xmlDictPtr,
    pub atts: *mut *const xmlChar,
    pub maxatts: std::os::raw::c_int,
    pub docdict: std::os::raw::c_int,
    pub str_xml: *const xmlChar,
    pub str_xmlns: *const xmlChar,
    pub str_xml_ns: *const xmlChar,
    pub sax2: std::os::raw::c_int,
    pub nsNr: std::os::raw::c_int,
    pub nsMax: std::os::raw::c_int,
    pub nsTab: *mut *const xmlChar,
    pub attallocs: *mut std::os::raw::c_int,
    pub pushTab: *mut *mut std::os::raw::c_void,
    pub attsDefault: xmlHashTablePtr,
    pub attsSpecial: xmlHashTablePtr,
    pub nsWellFormed: std::os::raw::c_int,
    pub options: std::os::raw::c_int,
    pub dictNames: std::os::raw::c_int,
    pub freeElemsNr: std::os::raw::c_int,
    pub freeElems: xmlNodePtr,
    pub freeAttrsNr: std::os::raw::c_int,
    pub freeAttrs: xmlAttrPtr,
    pub lastError: xmlError,
    pub parseMode: xmlParserMode,
    pub nbentities: std::os::raw::c_ulong,
    pub sizeentities: std::os::raw::c_ulong,
    pub nodeInfo: *mut xmlParserNodeInfo,
    pub nodeInfoNr: std::os::raw::c_int,
    pub nodeInfoMax: std::os::raw::c_int,
    pub nodeInfoTab: *mut xmlParserNodeInfo,
    pub input_id: std::os::raw::c_int,
    pub sizeentcopy: std::os::raw::c_ulong,
}
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfo {
    pub node: *const _xmlNode,
    pub begin_pos: std::os::raw::c_ulong,
    pub begin_line: std::os::raw::c_ulong,
    pub end_pos: std::os::raw::c_ulong,
    pub end_line: std::os::raw::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNode {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub content: *mut xmlChar,
    pub properties: *mut _xmlAttr,
    pub nsDef: *mut xmlNs,
    pub psvi: *mut std::os::raw::c_void,
    pub line: std::os::raw::c_ushort,
    pub extra: std::os::raw::c_ushort,
}
pub type xmlNs = _xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNs {
    pub next: *mut _xmlNs,
    pub type_0: xmlNsType,
    pub href: *const xmlChar,
    pub prefix: *const xmlChar,
    pub _private: *mut std::os::raw::c_void,
    pub context: *mut _xmlDoc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDoc {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *mut std::os::raw::c_char,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub compression: std::os::raw::c_int,
    pub standalone: std::os::raw::c_int,
    pub intSubset: *mut _xmlDtd,
    pub extSubset: *mut _xmlDtd,
    pub oldNs: *mut _xmlNs,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub ids: *mut std::os::raw::c_void,
    pub refs: *mut std::os::raw::c_void,
    pub URL: *const xmlChar,
    pub charset: std::os::raw::c_int,
    pub dict: *mut _xmlDict,
    pub psvi: *mut std::os::raw::c_void,
    pub parseFlags: std::os::raw::c_int,
    pub properties: std::os::raw::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDtd {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDoc,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub notations: *mut std::os::raw::c_void,
    pub elements: *mut std::os::raw::c_void,
    pub attributes: *mut std::os::raw::c_void,
    pub entities: *mut std::os::raw::c_void,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub pentities: *mut std::os::raw::c_void,
}
pub type xmlElementType = std::os::raw::c_uint;
pub const XML_DOCB_DOCUMENT_NODE: xmlElementType = 21;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
pub type xmlNsType = xmlElementType;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttr {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlAttr,
    pub prev: *mut _xmlAttr,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub atype: xmlAttributeType,
    pub psvi: *mut std::os::raw::c_void,
}
pub type xmlAttributeType = std::os::raw::c_uint;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = std::os::raw::c_uint;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
pub type xmlError = _xmlError;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlError {
    pub domain: std::os::raw::c_int,
    pub code: std::os::raw::c_int,
    pub message: *mut std::os::raw::c_char,
    pub level: xmlErrorLevel,
    pub file: *mut std::os::raw::c_char,
    pub line: std::os::raw::c_int,
    pub str1: *mut std::os::raw::c_char,
    pub str2: *mut std::os::raw::c_char,
    pub str3: *mut std::os::raw::c_char,
    pub int1: std::os::raw::c_int,
    pub int2: std::os::raw::c_int,
    pub ctxt: *mut std::os::raw::c_void,
    pub node: *mut std::os::raw::c_void,
}
pub type xmlErrorLevel = std::os::raw::c_uint;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
pub type xmlAttrPtr = *mut xmlAttr;
pub type xmlAttr = _xmlAttr;
pub type xmlNodePtr = *mut xmlNode;
pub type xmlNode = _xmlNode;
pub type xmlHashTablePtr = *mut xmlHashTable;
pub type xmlHashTable = _xmlHashTable;
pub type xmlDictPtr = *mut xmlDict;
pub type xmlDict = _xmlDict;
pub type xmlParserInputPtr = *mut xmlParserInput;
pub type xmlParserInput = _xmlParserInput;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInput {
    pub buf: xmlParserInputBufferPtr,
    pub filename: *const std::os::raw::c_char,
    pub directory: *const std::os::raw::c_char,
    pub base: *const xmlChar,
    pub cur: *const xmlChar,
    pub end: *const xmlChar,
    pub length: std::os::raw::c_int,
    pub line: std::os::raw::c_int,
    pub col: std::os::raw::c_int,
    pub consumed: std::os::raw::c_ulong,
    pub free: xmlParserInputDeallocate,
    pub encoding: *const xmlChar,
    pub version: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub id: std::os::raw::c_int,
}
pub type xmlParserInputDeallocate
    =
    Option<unsafe extern "C" fn(_: *mut xmlChar) -> ()>;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
/*
 * Those are the functions and datatypes for the library output
 * I/O structures.
 */
/* *
 * xmlOutputMatchCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Output API to detect if the current handler
 * can provide output fonctionnalities for this resource.
 *
 * Returns 1 if yes and 0 if another Output module should be used
 */
/* *
 * xmlOutputOpenCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Output API to open the resource
 *
 * Returns an Output context or NULL in case or error
 */
/* *
 * xmlOutputWriteCallback:
 * @context:  an Output context
 * @buffer:  the buffer of data to write
 * @len:  the length of the buffer in bytes
 *
 * Callback used in the I/O Output API to write to the resource
 *
 * Returns the number of bytes written or -1 in case of error
 */
/* *
 * xmlOutputCloseCallback:
 * @context:  an Output context
 *
 * Callback used in the I/O Output API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
/* LIBXML_OUTPUT_ENABLED */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInputBuffer {
    pub context: *mut std::os::raw::c_void,
    pub readcallback: xmlInputReadCallback,
    pub closecallback: xmlInputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub raw: xmlBufPtr,
    pub compressed: std::os::raw::c_int,
    pub error: std::os::raw::c_int,
    pub rawconsumed: std::os::raw::c_ulong,
}
pub type xmlBufPtr = *mut xmlBuf;
pub type xmlBuf = _xmlBuf;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
/*
 * Block defining the handlers for non UTF-8 encodings.
 * If iconv is supported, there are two extra fields.
 */
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlCharEncodingHandler {
    pub name: *mut std::os::raw::c_char,
    pub input: xmlCharEncodingInputFunc,
    pub output: xmlCharEncodingOutputFunc,
    pub iconv_in: iconv_t,
    pub iconv_out: iconv_t,
}
pub type iconv_t = *mut std::os::raw::c_void;
/* *
 * xmlCharEncodingOutputFunc:
 * @out:  a pointer to an array of bytes to store the result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of UTF-8 chars
 * @inlen:  the length of @in
 *
 * Take a block of UTF-8 chars in and try to convert it to another
 * encoding.
 * Note: a first call designed to produce heading info is called with
 * in = NULL. If stateful this should also initialize the encoder state.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets produced.
 */
pub type xmlCharEncodingOutputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
/* *
 * xmlCharEncodingInputFunc:
 * @out:  a pointer to an array of bytes to store the UTF-8 result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of chars in the original encoding
 * @inlen:  the length of @in
 *
 * Take a block of chars in the original encoding and try to convert
 * it to an UTF-8 block of chars out.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets consumed.
 */
pub type xmlCharEncodingInputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
/* *
 * xmlInputCloseCallback:
 * @context:  an Input context
 *
 * Callback used in the I/O Input API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
pub type xmlInputCloseCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
/*
 * Summary: interface for the I/O interfaces used by the parser
 * Description: interface for the I/O interfaces used by the parser
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Those are the functions and datatypes for the parser input
 * I/O structures.
 */
/* *
 * xmlInputMatchCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Input API to detect if the current handler
 * can provide input fonctionnalities for this resource.
 *
 * Returns 1 if yes and 0 if another Input module should be used
 */
/* *
 * xmlInputOpenCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Input API to open the resource
 *
 * Returns an Input context or NULL in case or error
 */
/* *
 * xmlInputReadCallback:
 * @context:  an Input context
 * @buffer:  the buffer to store data read
 * @len:  the length of the buffer in bytes
 *
 * Callback used in the I/O Input API to read the resource
 *
 * Returns the number of bytes read or -1 in case of error
 */
pub type xmlInputReadCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_char,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
pub type xmlParserInputState = std::os::raw::c_int;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
pub type xmlValidCtxt = _xmlValidCtxt;
/* *
 * XML_CTXT_FINISH_DTD_1:
 *
 * Special value for finishDtd field when embedded in an xmlParserCtxt
 */
/*
 * xmlValidCtxt:
 * An xmlValidCtxt is used for error reporting when validating.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlValidCtxt {
    pub userData: *mut std::os::raw::c_void,
    pub error: xmlValidityErrorFunc,
    pub warning: xmlValidityWarningFunc,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub finishDtd: std::os::raw::c_uint,
    pub doc: xmlDocPtr,
    pub valid: std::os::raw::c_int,
    pub vstate: *mut xmlValidState,
    pub vstateNr: std::os::raw::c_int,
    pub vstateMax: std::os::raw::c_int,
    pub vstateTab: *mut xmlValidState,
    pub am: xmlAutomataPtr,
    pub state: xmlAutomataStatePtr,
}
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataPtr = *mut xmlAutomata;
pub type xmlAutomata = _xmlAutomata;
pub type xmlValidState = _xmlValidState;
pub type xmlDocPtr = *mut xmlDoc;
pub type xmlDoc = _xmlDoc;
pub type xmlValidityWarningFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlValidityErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfoSeq {
    pub maximum: std::os::raw::c_ulong,
    pub length: std::os::raw::c_ulong,
    pub buffer: *mut xmlParserNodeInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandler {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: std::os::raw::c_uint,
    pub _private: *mut std::os::raw::c_void,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub serror: xmlStructuredErrorFunc,
}
pub type xmlStructuredErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlErrorPtr) -> ()>;
pub type xmlErrorPtr = *mut xmlError;
pub type endElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type startElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *mut *const xmlChar,
                                _: std::os::raw::c_int, _: std::os::raw::c_int,
                                _: *mut *const xmlChar) -> ()>;
pub type externalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type cdataBlockSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type getParameterEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type xmlEntityPtr = *mut xmlEntity;
pub type xmlEntity = _xmlEntity;
/*
 * An unit of storage for an entity, contains the string, the value
 * and the linkind data needed for the linking in the hash table.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEntity {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub orig: *mut xmlChar,
    pub content: *mut xmlChar,
    pub length: std::os::raw::c_int,
    pub etype: xmlEntityType,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub nexte: *mut _xmlEntity,
    pub URI: *const xmlChar,
    pub owner: std::os::raw::c_int,
    pub checked: std::os::raw::c_int,
}
/*
 * Summary: interface for the XML entities handling
 * Description: this module provides some of the entity API needed
 *              for the parser and applications.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * The different valid entity types.
 */
pub type xmlEntityType = std::os::raw::c_uint;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub type fatalErrorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type errorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type warningSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type commentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type processingInstructionSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type ignorableWhitespaceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type charactersSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type referenceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type endElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type startElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *mut *const xmlChar) -> ()>;
pub type endDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type startDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type setDocumentLocatorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlSAXLocatorPtr)
               -> ()>;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXLocator = _xmlSAXLocator;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXLocator {
    pub getPublicId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getSystemId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getLineNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                  -> std::os::raw::c_int>,
    pub getColumnNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                    -> std::os::raw::c_int>,
}
pub type unparsedEntityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type elementDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: xmlElementContentPtr)
               -> ()>;
pub type xmlElementContentPtr = *mut xmlElementContent;
pub type xmlElementContent = _xmlElementContent;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElementContent {
    pub type_0: xmlElementContentType,
    pub ocur: xmlElementContentOccur,
    pub name: *const xmlChar,
    pub c1: *mut _xmlElementContent,
    pub c2: *mut _xmlElementContent,
    pub parent: *mut _xmlElementContent,
    pub prefix: *const xmlChar,
}
pub type xmlElementContentOccur = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub type attributeDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: std::os::raw::c_int,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: xmlEnumerationPtr) -> ()>;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
pub type xmlEnumeration = _xmlEnumeration;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEnumeration {
    pub next: *mut _xmlEnumeration,
    pub name: *const xmlChar,
}
pub type notationDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type entityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: *const xmlChar, _: *mut xmlChar) -> ()>;
pub type getEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type resolveEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlParserInputPtr>;
pub type hasExternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type hasInternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type isStandaloneSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type internalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type xmlParserErrors = std::os::raw::c_uint;
pub const XML_BUF_OVERFLOW: xmlParserErrors = 7000;
pub const XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors =
    3007;
pub const XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors =
    3005;
pub const XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const XML_IO_EALREADY: xmlParserErrors = 1555;
pub const XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const XML_IO_EISCONN: xmlParserErrors = 1551;
pub const XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const XML_IO_WRITE: xmlParserErrors = 1546;
pub const XML_IO_FLUSH: xmlParserErrors = 1545;
pub const XML_IO_ENCODER: xmlParserErrors = 1544;
pub const XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const XML_IO_EXDEV: xmlParserErrors = 1542;
pub const XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const XML_IO_ESRCH: xmlParserErrors = 1540;
pub const XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const XML_IO_EROFS: xmlParserErrors = 1538;
pub const XML_IO_ERANGE: xmlParserErrors = 1537;
pub const XML_IO_EPIPE: xmlParserErrors = 1536;
pub const XML_IO_EPERM: xmlParserErrors = 1535;
pub const XML_IO_ENXIO: xmlParserErrors = 1534;
pub const XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const XML_IO_ENOENT: xmlParserErrors = 1524;
pub const XML_IO_ENODEV: xmlParserErrors = 1523;
pub const XML_IO_ENFILE: xmlParserErrors = 1522;
pub const XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const XML_IO_EMLINK: xmlParserErrors = 1519;
pub const XML_IO_EMFILE: xmlParserErrors = 1518;
pub const XML_IO_EISDIR: xmlParserErrors = 1517;
pub const XML_IO_EIO: xmlParserErrors = 1516;
pub const XML_IO_EINVAL: xmlParserErrors = 1515;
pub const XML_IO_EINTR: xmlParserErrors = 1514;
pub const XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const XML_IO_EFBIG: xmlParserErrors = 1512;
pub const XML_IO_EFAULT: xmlParserErrors = 1511;
pub const XML_IO_EEXIST: xmlParserErrors = 1510;
pub const XML_IO_EDOM: xmlParserErrors = 1509;
pub const XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const XML_IO_ECHILD: xmlParserErrors = 1507;
pub const XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const XML_IO_EBUSY: xmlParserErrors = 1505;
pub const XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const XML_IO_EBADF: xmlParserErrors = 1503;
pub const XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const XML_IO_EACCES: xmlParserErrors = 1501;
pub const XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const XML_WAR_NS_URI: xmlParserErrors = 99;
pub const XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const XML_ERR_OK: xmlParserErrors = 0;
pub const XML_FROM_HTML: C2RustUnnamed_0 = 5;
pub type xmlGenericErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub const XML_FROM_PARSER: C2RustUnnamed_0 = 1;
/* *
 * xmlReallocFunc:
 * @mem: an already allocated block of memory
 * @size:  the new size requested in bytes
 *
 * Signature for a realloc() implementation.
 *
 * Returns a pointer to the newly reallocated block or NULL in case of error.
 */
pub type xmlReallocFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: size_t)
               -> *mut std::os::raw::c_void>;
pub const HTML_PARSE_NOIMPLIED: C2RustUnnamed_2 = 8192;
pub type xmlDtdPtr = *mut xmlDtd;
pub type xmlDtd = _xmlDtd;
pub const XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
pub const XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
pub type xmlCharEncoding = std::os::raw::c_int;
pub const XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
pub const XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
pub const XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
pub const XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
pub const XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
pub const XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
pub const XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
pub const XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
pub const XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
pub const XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
pub const XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
pub const XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
pub const XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
pub const XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
pub const XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
pub const XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
pub const XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
pub const XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
pub const XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
pub const XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
pub const XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
/* Required attributes */
/*
 * Internal description of an HTML entity.
 */
pub type htmlEntityDesc = _htmlEntityDesc;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _htmlEntityDesc {
    pub value: std::os::raw::c_uint,
    pub name: *const std::os::raw::c_char,
    pub desc: *const std::os::raw::c_char,
}
pub type htmlEntityDescPtr = *mut htmlEntityDesc;
pub type xmlChRangeGroup = _xmlChRangeGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlChRangeGroup {
    pub nbShortRange: std::os::raw::c_int,
    pub nbLongRange: std::os::raw::c_int,
    pub shortRange: *const xmlChSRange,
    pub longRange: *const xmlChLRange,
}
pub type xmlChLRange = _xmlChLRange;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlChLRange {
    pub low: std::os::raw::c_uint,
    pub high: std::os::raw::c_uint,
}
pub type xmlChSRange = _xmlChSRange;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlChSRange {
    pub low: std::os::raw::c_ushort,
    pub high: std::os::raw::c_ushort,
}
pub type htmlParserNodeInfo = xmlParserNodeInfo;
/*
 * Internal description of an HTML element, representing HTML 4.01
 * and XHTML 1.0 (which share the same structure).
 */
pub type htmlElemDesc = _htmlElemDesc;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _htmlElemDesc {
    pub name: *const std::os::raw::c_char,
    pub startTag: std::os::raw::c_char,
    pub endTag: std::os::raw::c_char,
    pub saveEndTag: std::os::raw::c_char,
    pub empty: std::os::raw::c_char,
    pub depr: std::os::raw::c_char,
    pub dtd: std::os::raw::c_char,
    pub isinline: std::os::raw::c_char,
    pub desc: *const std::os::raw::c_char,
    pub subelts: *mut *const std::os::raw::c_char,
    pub defaultsubelt: *const std::os::raw::c_char,
    pub attrs_opt: *mut *const std::os::raw::c_char,
    pub attrs_depr: *mut *const std::os::raw::c_char,
    pub attrs_req: *mut *const std::os::raw::c_char,
}
pub type xmlParserNodeInfoPtr = *mut xmlParserNodeInfo;
pub type htmlElemDescPtr = *mut htmlElemDesc;
pub const HTML_PARSE_IGNORE_ENC: C2RustUnnamed_2 = 2097152;
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */
/* *
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/* *
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
/* *
 * xmlMallocFunc:
 * @size:  the size requested in bytes
 *
 * Signature for a malloc() implementation.
 *
 * Returns a pointer to the newly allocated block or NULL in case of error.
 */
pub type xmlMallocFunc
    =
    Option<unsafe extern "C" fn(_: size_t) -> *mut std::os::raw::c_void>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elementPriority {
    pub name: *const std::os::raw::c_char,
    pub priority: std::os::raw::c_int,
}
pub type xmlSAXHandler = _xmlSAXHandler;
pub type xmlSAXHandlerPtr = *mut xmlSAXHandler;
pub type C2RustUnnamed = std::os::raw::c_uint;
pub const XML_DOC_HTML: C2RustUnnamed = 128;
pub const XML_DOC_INTERNAL: C2RustUnnamed = 64;
pub const XML_DOC_USERBUILT: C2RustUnnamed = 32;
pub const XML_DOC_XINCLUDE: C2RustUnnamed = 16;
pub const XML_DOC_DTDVALID: C2RustUnnamed = 8;
pub const XML_DOC_OLD10: C2RustUnnamed = 4;
pub const XML_DOC_NSVALID: C2RustUnnamed = 2;
pub const XML_DOC_WELLFORMED: C2RustUnnamed = 1;
/*
 * Recent version of gcc produce a warning when a function pointer is assigned
 * to an object pointer, or vice versa.  The following macro is a dirty hack
 * to allow suppression of the warning.  If your architecture has function
 * pointers which are a different size than a void pointer, there may be some
 * serious trouble within the library.
 */
/* *
 * XML_CAST_FPTR:
 * @fptr:  pointer to a function
 *
 * Macro to do a casting from an object pointer to a
 * function pointer without encountering a warning from
 * gcc
 *
 * #define XML_CAST_FPTR(fptr) (*(void **)(&fptr))
 * This macro violated ISO C aliasing rules (gcc4 on s390 broke)
 * so it is disabled now
 */
/*
 * function types:
 */
/* *
 * xmlHashDeallocator:
 * @payload:  the data in the hash
 * @name:  the name associated
 *
 * Callback to free data from a hash.
 */
pub type xmlHashDeallocator
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type C2RustUnnamed_0 = std::os::raw::c_uint;
pub const XML_FROM_URI: C2RustUnnamed_0 = 30;
pub const XML_FROM_BUFFER: C2RustUnnamed_0 = 29;
pub const XML_FROM_SCHEMATRONV: C2RustUnnamed_0 = 28;
pub const XML_FROM_I18N: C2RustUnnamed_0 = 27;
pub const XML_FROM_MODULE: C2RustUnnamed_0 = 26;
pub const XML_FROM_WRITER: C2RustUnnamed_0 = 25;
pub const XML_FROM_CHECK: C2RustUnnamed_0 = 24;
pub const XML_FROM_VALID: C2RustUnnamed_0 = 23;
pub const XML_FROM_XSLT: C2RustUnnamed_0 = 22;
pub const XML_FROM_C14N: C2RustUnnamed_0 = 21;
pub const XML_FROM_CATALOG: C2RustUnnamed_0 = 20;
pub const XML_FROM_RELAXNGV: C2RustUnnamed_0 = 19;
pub const XML_FROM_RELAXNGP: C2RustUnnamed_0 = 18;
pub const XML_FROM_SCHEMASV: C2RustUnnamed_0 = 17;
pub const XML_FROM_SCHEMASP: C2RustUnnamed_0 = 16;
pub const XML_FROM_DATATYPE: C2RustUnnamed_0 = 15;
pub const XML_FROM_REGEXP: C2RustUnnamed_0 = 14;
pub const XML_FROM_XPOINTER: C2RustUnnamed_0 = 13;
pub const XML_FROM_XPATH: C2RustUnnamed_0 = 12;
pub const XML_FROM_XINCLUDE: C2RustUnnamed_0 = 11;
pub const XML_FROM_HTTP: C2RustUnnamed_0 = 10;
pub const XML_FROM_FTP: C2RustUnnamed_0 = 9;
pub const XML_FROM_IO: C2RustUnnamed_0 = 8;
pub const XML_FROM_OUTPUT: C2RustUnnamed_0 = 7;
pub const XML_FROM_MEMORY: C2RustUnnamed_0 = 6;
pub const XML_FROM_DTD: C2RustUnnamed_0 = 4;
pub const XML_FROM_NAMESPACE: C2RustUnnamed_0 = 3;
pub const XML_FROM_TREE: C2RustUnnamed_0 = 2;
pub const XML_FROM_NONE: C2RustUnnamed_0 = 0;
pub type xmlParserNodeInfoSeqPtr = *mut xmlParserNodeInfoSeq;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandlerV1 {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: std::os::raw::c_uint,
}
pub type xmlSAXHandlerV1 = _xmlSAXHandlerV1;
pub type C2RustUnnamed_1 = std::os::raw::c_uint;
pub const XML_PARSE_BIG_LINES: C2RustUnnamed_1 = 4194304;
pub const XML_PARSE_IGNORE_ENC: C2RustUnnamed_1 = 2097152;
pub const XML_PARSE_OLDSAX: C2RustUnnamed_1 = 1048576;
pub const XML_PARSE_HUGE: C2RustUnnamed_1 = 524288;
pub const XML_PARSE_NOBASEFIX: C2RustUnnamed_1 = 262144;
pub const XML_PARSE_OLD10: C2RustUnnamed_1 = 131072;
pub const XML_PARSE_COMPACT: C2RustUnnamed_1 = 65536;
pub const XML_PARSE_NOXINCNODE: C2RustUnnamed_1 = 32768;
pub const XML_PARSE_NOCDATA: C2RustUnnamed_1 = 16384;
pub const XML_PARSE_NSCLEAN: C2RustUnnamed_1 = 8192;
pub const XML_PARSE_NODICT: C2RustUnnamed_1 = 4096;
pub const XML_PARSE_NONET: C2RustUnnamed_1 = 2048;
pub const XML_PARSE_XINCLUDE: C2RustUnnamed_1 = 1024;
pub const XML_PARSE_SAX1: C2RustUnnamed_1 = 512;
pub const XML_PARSE_NOBLANKS: C2RustUnnamed_1 = 256;
pub const XML_PARSE_PEDANTIC: C2RustUnnamed_1 = 128;
pub const XML_PARSE_NOWARNING: C2RustUnnamed_1 = 64;
pub const XML_PARSE_NOERROR: C2RustUnnamed_1 = 32;
pub const XML_PARSE_DTDVALID: C2RustUnnamed_1 = 16;
pub const XML_PARSE_DTDATTR: C2RustUnnamed_1 = 8;
pub const XML_PARSE_DTDLOAD: C2RustUnnamed_1 = 4;
pub const XML_PARSE_NOENT: C2RustUnnamed_1 = 2;
pub const XML_PARSE_RECOVER: C2RustUnnamed_1 = 1;
/*
 * Summary: interface for an HTML 4.0 non-verifying parser
 * Description: this module implements an HTML 4.0 non-verifying parser
 *              with API compatible with the XML parser ones. It should
 *              be able to parse "real world" HTML, even if severely
 *              broken from a specification point of view.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Most of the back-end structures from XML and HTML are shared.
 */
pub type htmlParserCtxt = xmlParserCtxt;
pub type htmlSAXHandler = xmlSAXHandler;
pub type htmlSAXHandlerPtr = xmlSAXHandlerPtr;
pub type htmlParserInput = xmlParserInput;
pub type htmlParserInputPtr = xmlParserInputPtr;
pub type htmlDocPtr = xmlDocPtr;
pub type htmlNodePtr = xmlNodePtr;
pub const HTML_PARSE_NODEFDTD: C2RustUnnamed_2 = 4;
pub type C2RustUnnamed_2 = std::os::raw::c_uint;
pub const HTML_PARSE_COMPACT: C2RustUnnamed_2 = 65536;
pub const HTML_PARSE_NONET: C2RustUnnamed_2 = 2048;
pub const HTML_PARSE_NOBLANKS: C2RustUnnamed_2 = 256;
pub const HTML_PARSE_PEDANTIC: C2RustUnnamed_2 = 128;
pub const HTML_PARSE_NOWARNING: C2RustUnnamed_2 = 64;
pub const HTML_PARSE_NOERROR: C2RustUnnamed_2 = 32;
pub const HTML_PARSE_RECOVER: C2RustUnnamed_2 = 1;
pub type htmlStatus = std::os::raw::c_uint;
pub const HTML_REQUIRED: htmlStatus = 12;
pub const HTML_VALID: htmlStatus = 4;
pub const HTML_DEPRECATED: htmlStatus = 2;
pub const HTML_INVALID: htmlStatus = 1;
pub const HTML_NA: htmlStatus = 0;
#[inline]
unsafe extern "C" fn toupper(mut __c: std::os::raw::c_int) -> std::os::raw::c_int {
    return if __c >= -(128 as std::os::raw::c_int) && __c < 256 as std::os::raw::c_int {
               *(*__ctype_toupper_loc()).offset(__c as isize)
           } else { __c };
}
/* #define DEBUG */
/* #define DEBUG_PUSH */
static mut htmlOmittedDefaultValue: std::os::raw::c_int = 1 as std::os::raw::c_int;
/* ***********************************************************************
 *									*
 *		Some factorized error routines				*
 *									*
 ************************************************************************/
/* *
 * htmlErrMemory:
 * @ctxt:  an HTML parser context
 * @extra:  extra informations
 *
 * Handle a redefinition of attribute error
 */
unsafe extern "C" fn htmlErrMemory(mut ctxt: xmlParserCtxtPtr,
                                   mut extra: *const std::os::raw::c_char) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() {
        (*ctxt).errNo = XML_ERR_NO_MEMORY as std::os::raw::c_int;
        (*ctxt).instate = XML_PARSER_EOF;
        (*ctxt).disableSAX = 1 as std::os::raw::c_int
    }
    if !extra.is_null() {
        __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_PARSER as std::os::raw::c_int,
                        XML_ERR_NO_MEMORY as std::os::raw::c_int, XML_ERR_FATAL,
                        0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int, extra,
                        0 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, 0 as std::os::raw::c_int,
                        b"Memory allocation failed : %s\n\x00" as *const u8 as
                            *const std::os::raw::c_char, extra);
    } else {
        __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_PARSER as std::os::raw::c_int,
                        XML_ERR_NO_MEMORY as std::os::raw::c_int, XML_ERR_FATAL,
                        0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                        0 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                        0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                        0 as std::os::raw::c_int,
                        b"Memory allocation failed\n\x00" as *const u8 as
                            *const std::os::raw::c_char);
    };
}
/* *
 * htmlParseErr:
 * @ctxt:  an HTML parser context
 * @error:  the error number
 * @msg:  the error message
 * @str1:  string infor
 * @str2:  string infor
 *
 * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 */
unsafe extern "C" fn htmlParseErr(mut ctxt: xmlParserCtxtPtr,
                                  mut error: xmlParserErrors,
                                  mut msg: *const std::os::raw::c_char,
                                  mut str1: *const xmlChar,
                                  mut str2: *const xmlChar) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() { (*ctxt).errNo = error as std::os::raw::c_int }
    __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                    ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                    XML_FROM_HTML as std::os::raw::c_int, error as std::os::raw::c_int,
                    XML_ERR_ERROR, 0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    str1 as *const std::os::raw::c_char, str2 as *const std::os::raw::c_char,
                    0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as std::os::raw::c_int, msg, str1, str2);
    if !ctxt.is_null() { (*ctxt).wellFormed = 0 as std::os::raw::c_int };
}
/* *
 * htmlParseErrInt:
 * @ctxt:  an HTML parser context
 * @error:  the error number
 * @msg:  the error message
 * @val:  integer info
 *
 * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 */
unsafe extern "C" fn htmlParseErrInt(mut ctxt: xmlParserCtxtPtr,
                                     mut error: xmlParserErrors,
                                     mut msg: *const std::os::raw::c_char,
                                     mut val: std::os::raw::c_int) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() { (*ctxt).errNo = error as std::os::raw::c_int }
    __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                    ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                    XML_FROM_HTML as std::os::raw::c_int, error as std::os::raw::c_int,
                    XML_ERR_ERROR, 0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                    0 as *const std::os::raw::c_char, val, 0 as std::os::raw::c_int, msg,
                    val);
    if !ctxt.is_null() { (*ctxt).wellFormed = 0 as std::os::raw::c_int };
}
/* ***********************************************************************
 *									*
 *	Parser stacks related functions and macros		*
 *									*
 ************************************************************************/
/* *
 * htmlnamePush:
 * @ctxt:  an HTML parser context
 * @value:  the element name
 *
 * Pushes a new element name on top of the name stack
 *
 * Returns 0 in case of error, the index in the stack otherwise
 */
unsafe extern "C" fn htmlnamePush(mut ctxt: htmlParserCtxtPtr,
                                  mut value: *const xmlChar) -> std::os::raw::c_int {
    if (*ctxt).html < 3 as std::os::raw::c_int &&
           xmlStrEqual(value,
                       b"head\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
        (*ctxt).html = 3 as std::os::raw::c_int
    }
    if (*ctxt).html < 10 as std::os::raw::c_int &&
           xmlStrEqual(value,
                       b"body\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
        (*ctxt).html = 10 as std::os::raw::c_int
    }
    if (*ctxt).nameNr >= (*ctxt).nameMax {
        (*ctxt).nameMax *= 2 as std::os::raw::c_int;
        (*ctxt).nameTab =
            xmlRealloc.expect("non-null function pointer")((*ctxt).nameTab as
                                                               *mut *mut xmlChar
                                                               as
                                                               *mut std::os::raw::c_void,
                                                           ((*ctxt).nameMax as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut *const xmlChar;
        if (*ctxt).nameTab.is_null() {
            htmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return 0 as std::os::raw::c_int
        }
    }
    let ref mut fresh0 = *(*ctxt).nameTab.offset((*ctxt).nameNr as isize);
    *fresh0 = value;
    (*ctxt).name = value;
    let fresh1 = (*ctxt).nameNr;
    (*ctxt).nameNr = (*ctxt).nameNr + 1;
    return fresh1;
}
/* *
 * htmlnamePop:
 * @ctxt: an HTML parser context
 *
 * Pops the top element name from the name stack
 *
 * Returns the name just removed
 */
unsafe extern "C" fn htmlnamePop(mut ctxt: htmlParserCtxtPtr)
 -> *const xmlChar {
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    if (*ctxt).nameNr <= 0 as std::os::raw::c_int { return 0 as *const xmlChar }
    (*ctxt).nameNr -= 1;
    if (*ctxt).nameNr < 0 as std::os::raw::c_int { return 0 as *const xmlChar }
    if (*ctxt).nameNr > 0 as std::os::raw::c_int {
        (*ctxt).name =
            *(*ctxt).nameTab.offset(((*ctxt).nameNr - 1 as std::os::raw::c_int) as
                                        isize)
    } else { (*ctxt).name = 0 as *const xmlChar }
    ret = *(*ctxt).nameTab.offset((*ctxt).nameNr as isize);
    let ref mut fresh2 = *(*ctxt).nameTab.offset((*ctxt).nameNr as isize);
    *fresh2 = 0 as *const xmlChar;
    return ret;
}
/* *
 * htmlNodeInfoPush:
 * @ctxt:  an HTML parser context
 * @value:  the node info
 *
 * Pushes a new element name on top of the node info stack
 *
 * Returns 0 in case of error, the index in the stack otherwise
 */
unsafe extern "C" fn htmlNodeInfoPush(mut ctxt: htmlParserCtxtPtr,
                                      mut value: *mut htmlParserNodeInfo)
 -> std::os::raw::c_int {
    if (*ctxt).nodeInfoNr >= (*ctxt).nodeInfoMax {
        if (*ctxt).nodeInfoMax == 0 as std::os::raw::c_int {
            (*ctxt).nodeInfoMax = 5 as std::os::raw::c_int
        }
        (*ctxt).nodeInfoMax *= 2 as std::os::raw::c_int;
        (*ctxt).nodeInfoTab =
            xmlRealloc.expect("non-null function pointer")((*ctxt).nodeInfoTab
                                                               as
                                                               *mut htmlParserNodeInfo
                                                               as
                                                               *mut std::os::raw::c_void,
                                                           ((*ctxt).nodeInfoMax
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlParserNodeInfo>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut htmlParserNodeInfo;
        if (*ctxt).nodeInfoTab.is_null() {
            htmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return 0 as std::os::raw::c_int
        }
    }
    *(*ctxt).nodeInfoTab.offset((*ctxt).nodeInfoNr as isize) = *value;
    (*ctxt).nodeInfo =
        &mut *(*ctxt).nodeInfoTab.offset((*ctxt).nodeInfoNr as isize) as
            *mut xmlParserNodeInfo;
    let fresh3 = (*ctxt).nodeInfoNr;
    (*ctxt).nodeInfoNr = (*ctxt).nodeInfoNr + 1;
    return fresh3;
}
/* *
 * htmlNodeInfoPop:
 * @ctxt:  an HTML parser context
 *
 * Pops the top element name from the node info stack
 *
 * Returns 0 in case of error, the pointer to NodeInfo otherwise
 */
unsafe extern "C" fn htmlNodeInfoPop(mut ctxt: htmlParserCtxtPtr)
 -> *mut htmlParserNodeInfo {
    if (*ctxt).nodeInfoNr <= 0 as std::os::raw::c_int {
        return 0 as *mut htmlParserNodeInfo
    }
    (*ctxt).nodeInfoNr -= 1;
    if (*ctxt).nodeInfoNr < 0 as std::os::raw::c_int {
        return 0 as *mut htmlParserNodeInfo
    }
    if (*ctxt).nodeInfoNr > 0 as std::os::raw::c_int {
        (*ctxt).nodeInfo =
            &mut *(*ctxt).nodeInfoTab.offset(((*ctxt).nodeInfoNr -
                                                  1 as std::os::raw::c_int) as isize)
                as *mut xmlParserNodeInfo
    } else { (*ctxt).nodeInfo = 0 as *mut xmlParserNodeInfo }
    return &mut *(*ctxt).nodeInfoTab.offset((*ctxt).nodeInfoNr as isize) as
               *mut xmlParserNodeInfo;
}
/* *
 * htmlFindEncoding:
 * @the HTML parser context
 *
 * Ty to find and encoding in the current data available in the input
 * buffer this is needed to try to switch to the proper encoding when
 * one face a character error.
 * That's an heuristic, since it's operating outside of parsing it could
 * try to use a meta which had been commented out, that's the reason it
 * should only be used in case of error, not as a default.
 *
 * Returns an encoding string or NULL if not found, the string need to
 *   be freed
 */
unsafe extern "C" fn htmlFindEncoding(mut ctxt: xmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut start: *const xmlChar = 0 as *const xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut end: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || (*ctxt).input.is_null() ||
           !(*(*ctxt).input).encoding.is_null() ||
           (*(*ctxt).input).buf.is_null() ||
           !(*(*(*ctxt).input).buf).encoder.is_null() {
        return 0 as *mut xmlChar
    }
    if (*(*ctxt).input).cur.is_null() || (*(*ctxt).input).end.is_null() {
        return 0 as *mut xmlChar
    }
    start = (*(*ctxt).input).cur;
    end = (*(*ctxt).input).end;
    /* we also expect the input buffer to be zero terminated */
    if *end as std::os::raw::c_int != 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    cur =
        xmlStrcasestr(start,
                      b"HTTP-EQUIV\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
    if cur.is_null() { return 0 as *mut xmlChar }
    cur =
        xmlStrcasestr(cur,
                      b"CONTENT\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
    if cur.is_null() { return 0 as *mut xmlChar }
    cur =
        xmlStrcasestr(cur,
                      b"CHARSET=\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
    if cur.is_null() { return 0 as *mut xmlChar }
    cur = cur.offset(8 as std::os::raw::c_int as isize);
    start = cur;
    while *cur as std::os::raw::c_int >= 'A' as i32 &&
              *cur as std::os::raw::c_int <= 'Z' as i32 ||
              *cur as std::os::raw::c_int >= 'a' as i32 &&
                  *cur as std::os::raw::c_int <= 'z' as i32 ||
              *cur as std::os::raw::c_int >= '0' as i32 &&
                  *cur as std::os::raw::c_int <= '9' as i32 ||
              *cur as std::os::raw::c_int == '-' as i32 ||
              *cur as std::os::raw::c_int == '_' as i32 ||
              *cur as std::os::raw::c_int == ':' as i32 ||
              *cur as std::os::raw::c_int == '/' as i32 {
        cur = cur.offset(1)
    }
    if cur == start { return 0 as *mut xmlChar }
    return xmlStrndup(start,
                      cur.offset_from(start) as std::os::raw::c_long as
                          std::os::raw::c_int);
}
/* *
 * htmlCurrentChar:
 * @ctxt:  the HTML parser context
 * @len:  pointer to the length of the char read
 *
 * The current char value, if using UTF-8 this may actually span multiple
 * bytes in the input buffer. Implement the end of line normalization:
 * 2.11 End-of-Line Handling
 * If the encoding is unspecified, in the case we find an ISO-Latin-1
 * char, then the encoding converter is plugged in automatically.
 *
 * Returns the current char value and its length
 */
unsafe extern "C" fn htmlCurrentChar(mut ctxt: xmlParserCtxtPtr,
                                     mut len: *mut std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    if (*ctxt).token != 0 as std::os::raw::c_int {
        *len = 0 as std::os::raw::c_int;
        return (*ctxt).token
    }
    if (*ctxt).charset == XML_CHAR_ENCODING_UTF8 as std::os::raw::c_int {
        /*
	 * We are supposed to handle UTF8, check it's valid
	 * From rfc2044: encoding of the Unicode values on UTF-8:
	 *
	 * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
	 * 0000 0000-0000 007F   0xxxxxxx
	 * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
	 * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
	 *
	 * Check for the 0x110000 limit too
	 */
        let mut cur: *const std::os::raw::c_uchar = (*(*ctxt).input).cur;
        let mut c: std::os::raw::c_uchar = 0;
        let mut val: std::os::raw::c_uint = 0;
        c = *cur;
        if c as std::os::raw::c_int & 0x80 as std::os::raw::c_int != 0 {
            if *cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                cur = (*(*ctxt).input).cur
            }
            if !(*cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int &
                     0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int) {
                if c as std::os::raw::c_int & 0xe0 as std::os::raw::c_int ==
                       0xe0 as std::os::raw::c_int {
                    if *cur.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int
                           == 0 as std::os::raw::c_int {
                        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                        cur = (*(*ctxt).input).cur
                    }
                    if *cur.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int &
                           0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int {
                        current_block = 3145606906544522259;
                    } else if c as std::os::raw::c_int & 0xf0 as std::os::raw::c_int ==
                                  0xf0 as std::os::raw::c_int {
                        if *cur.offset(3 as std::os::raw::c_int as isize) as
                               std::os::raw::c_int == 0 as std::os::raw::c_int {
                            xmlParserInputGrow((*ctxt).input,
                                               250 as std::os::raw::c_int);
                            cur = (*(*ctxt).input).cur
                        }
                        if c as std::os::raw::c_int & 0xf8 as std::os::raw::c_int !=
                               0xf0 as std::os::raw::c_int ||
                               *cur.offset(3 as std::os::raw::c_int as isize) as
                                   std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                                   0x80 as std::os::raw::c_int {
                            current_block = 3145606906544522259;
                        } else {
                            /* 4-byte code */
                            *len = 4 as std::os::raw::c_int;
                            val =
                                ((*cur.offset(0 as std::os::raw::c_int as isize) as
                                      std::os::raw::c_int & 0x7 as std::os::raw::c_int) <<
                                     18 as std::os::raw::c_int) as std::os::raw::c_uint;
                            val |=
                                ((*cur.offset(1 as std::os::raw::c_int as isize) as
                                      std::os::raw::c_int & 0x3f as std::os::raw::c_int) <<
                                     12 as std::os::raw::c_int) as std::os::raw::c_uint;
                            val |=
                                ((*cur.offset(2 as std::os::raw::c_int as isize) as
                                      std::os::raw::c_int & 0x3f as std::os::raw::c_int) <<
                                     6 as std::os::raw::c_int) as std::os::raw::c_uint;
                            val |=
                                (*cur.offset(3 as std::os::raw::c_int as isize) as
                                     std::os::raw::c_int & 0x3f as std::os::raw::c_int) as
                                    std::os::raw::c_uint;
                            current_block = 5529461102203738653;
                        }
                    } else {
                        /* 3-byte code */
                        *len = 3 as std::os::raw::c_int;
                        val =
                            ((*cur.offset(0 as std::os::raw::c_int as isize) as
                                  std::os::raw::c_int & 0xf as std::os::raw::c_int) <<
                                 12 as std::os::raw::c_int) as std::os::raw::c_uint;
                        val |=
                            ((*cur.offset(1 as std::os::raw::c_int as isize) as
                                  std::os::raw::c_int & 0x3f as std::os::raw::c_int) <<
                                 6 as std::os::raw::c_int) as std::os::raw::c_uint;
                        val |=
                            (*cur.offset(2 as std::os::raw::c_int as isize) as
                                 std::os::raw::c_int & 0x3f as std::os::raw::c_int) as
                                std::os::raw::c_uint;
                        current_block = 5529461102203738653;
                    }
                } else {
                    /* 2-byte code */
                    *len = 2 as std::os::raw::c_int;
                    val =
                        ((*cur.offset(0 as std::os::raw::c_int as isize) as
                              std::os::raw::c_int & 0x1f as std::os::raw::c_int) <<
                             6 as std::os::raw::c_int) as std::os::raw::c_uint;
                    val |=
                        (*cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int
                             & 0x3f as std::os::raw::c_int) as std::os::raw::c_uint;
                    current_block = 5529461102203738653;
                }
                match current_block {
                    3145606906544522259 => { }
                    _ => {
                        if if val < 0x100 as std::os::raw::c_int as std::os::raw::c_uint {
                               (0x9 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                                    val <= 0xa as std::os::raw::c_int as std::os::raw::c_uint
                                    ||
                                    val == 0xd as std::os::raw::c_int as std::os::raw::c_uint
                                    ||
                                    0x20 as std::os::raw::c_int as std::os::raw::c_uint <=
                                        val) as std::os::raw::c_int
                           } else {
                               (0x100 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                                    val <=
                                        0xd7ff as std::os::raw::c_int as std::os::raw::c_uint
                                    ||
                                    0xe000 as std::os::raw::c_int as std::os::raw::c_uint <=
                                        val &&
                                        val <=
                                            0xfffd as std::os::raw::c_int as
                                                std::os::raw::c_uint ||
                                    0x10000 as std::os::raw::c_int as std::os::raw::c_uint <=
                                        val &&
                                        val <=
                                            0x10ffff as std::os::raw::c_int as
                                                std::os::raw::c_uint) as std::os::raw::c_int
                           } == 0 {
                            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                                            b"Char 0x%X out of allowed range\n\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char,
                                            val as std::os::raw::c_int);
                        }
                        return val as std::os::raw::c_int
                    }
                }
            }
            /*
     * If we detect an UTF8 error that probably mean that the
     * input encoding didn't get properly advertized in the
     * declaration header. Report the error and switch the encoding
     * to ISO-Latin-1 (if you don't like this policy, just declare the
     * encoding !)
     */
            let mut buffer: [std::os::raw::c_char; 150] = [0; 150];
            if (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                   as std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
                snprintf(buffer.as_mut_ptr(),
                         149 as std::os::raw::c_int as std::os::raw::c_ulong,
                         b"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n\x00" as
                             *const u8 as *const std::os::raw::c_char,
                         *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as
                                                          isize) as
                             std::os::raw::c_int,
                         *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                          isize) as
                             std::os::raw::c_int,
                         *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                          isize) as
                             std::os::raw::c_int,
                         *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                          isize) as
                             std::os::raw::c_int);
            } else {
                snprintf(buffer.as_mut_ptr(),
                         149 as std::os::raw::c_int as std::os::raw::c_ulong,
                         b"Bytes: 0x%02X\n\x00" as *const u8 as
                             *const std::os::raw::c_char,
                         *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as
                                                          isize) as
                             std::os::raw::c_int);
            }
            htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
                         b"Input is not proper UTF-8, indicate encoding !\n\x00"
                             as *const u8 as *const std::os::raw::c_char,
                         buffer.as_mut_ptr() as *mut xmlChar,
                         0 as *const xmlChar);
            (*ctxt).charset = XML_CHAR_ENCODING_8859_1 as std::os::raw::c_int;
            *len = 1 as std::os::raw::c_int;
            return *(*(*ctxt).input).cur as std::os::raw::c_int
        } else {
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int &&
                   (*(*ctxt).input).cur < (*(*ctxt).input).end {
                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                                b"Char 0x%X out of allowed range\n\x00" as
                                    *const u8 as *const std::os::raw::c_char,
                                0 as std::os::raw::c_int);
                *len = 1 as std::os::raw::c_int;
                return ' ' as i32
            }
            /* 1-byte code */
            *len = 1 as std::os::raw::c_int;
            return *(*(*ctxt).input).cur as std::os::raw::c_int
        }
    } else {
        /*
     * Assume it's a fixed length encoding (1) with
     * a compatible encoding for the ASCII set, since
     * XML constructs only use < 128 chars
     */
        *len = 1 as std::os::raw::c_int;
        if (*(*(*ctxt).input).cur as std::os::raw::c_int) < 0x80 as std::os::raw::c_int {
            return *(*(*ctxt).input).cur as std::os::raw::c_int
        }
        /*
     * Humm this is bad, do an automatic flow conversion
     */
        let mut guess: *mut xmlChar = 0 as *mut xmlChar;
        let mut handler: xmlCharEncodingHandlerPtr =
            0 as *mut xmlCharEncodingHandler;
        guess = htmlFindEncoding(ctxt);
        if guess.is_null() {
            xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);
        } else {
            if !(*(*ctxt).input).encoding.is_null() {
                xmlFree.expect("non-null function pointer")((*(*ctxt).input).encoding
                                                                as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            (*(*ctxt).input).encoding = guess;
            handler =
                xmlFindCharEncodingHandler(guess as *const std::os::raw::c_char);
            if !handler.is_null() {
                xmlSwitchToEncoding(ctxt, handler);
            } else {
                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
                             b"Unsupported encoding %s\x00" as *const u8 as
                                 *const std::os::raw::c_char, guess,
                             0 as *const xmlChar);
            }
        }
        (*ctxt).charset = XML_CHAR_ENCODING_UTF8 as std::os::raw::c_int;
        return xmlCurrentChar(ctxt, len)
    };
}
/* *
 * htmlSkipBlankChars:
 * @ctxt:  the HTML parser context
 *
 * skip all blanks character found at that point in the input streams.
 *
 * Returns the number of space chars skipped
 */
unsafe extern "C" fn htmlSkipBlankChars(mut ctxt: xmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut res: std::os::raw::c_int = 0 as std::os::raw::c_int;
    while *(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
              0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                  *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int
              || *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int &&
               xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int) <=
                   0 as std::os::raw::c_int {
            xmlPopInput(ctxt);
        } else {
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                (*(*ctxt).input).line += 1;
                (*(*ctxt).input).col = 1 as std::os::raw::c_int
            } else { (*(*ctxt).input).col += 1 }
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1);
            (*ctxt).nbChars += 1;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
        }
        res += 1
    }
    return res;
}
static mut html_flow: [*const std::os::raw::c_char; 64] =
    [b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"embed\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"basefont\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"input\x00" as *const u8 as *const std::os::raw::c_char,
     b"select\x00" as *const u8 as *const std::os::raw::c_char,
     b"textarea\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut html_inline: [*const std::os::raw::c_char; 40] =
    [b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"embed\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"basefont\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"input\x00" as *const u8 as *const std::os::raw::c_char,
     b"select\x00" as *const u8 as *const std::os::raw::c_char,
     b"textarea\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
/* placeholders: elts with content but no subelements */
static mut html_pcdata: [*const std::os::raw::c_char; 1] = [0 as *const std::os::raw::c_char];
static mut html_attrs: [*const std::os::raw::c_char; 16] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut core_i18n_attrs: [*const std::os::raw::c_char; 7] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut core_attrs: [*const std::os::raw::c_char; 5] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut i18n_attrs: [*const std::os::raw::c_char; 3] =
    [b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
/* Other declarations that should go inline ... */
static mut a_attrs: [*const std::os::raw::c_char; 29] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"charset\x00" as *const u8 as *const std::os::raw::c_char,
     b"type\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"href\x00" as *const u8 as *const std::os::raw::c_char,
     b"hreflang\x00" as *const u8 as *const std::os::raw::c_char,
     b"rel\x00" as *const u8 as *const std::os::raw::c_char,
     b"rev\x00" as *const u8 as *const std::os::raw::c_char,
     b"accesskey\x00" as *const u8 as *const std::os::raw::c_char,
     b"shape\x00" as *const u8 as *const std::os::raw::c_char,
     b"coords\x00" as *const u8 as *const std::os::raw::c_char,
     b"tabindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"onfocus\x00" as *const u8 as *const std::os::raw::c_char,
     b"onblur\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut target_attr: [*const std::os::raw::c_char; 2] =
    [b"target\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut rows_cols_attr: [*const std::os::raw::c_char; 3] =
    [b"rows\x00" as *const u8 as *const std::os::raw::c_char,
     b"cols\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut alt_attr: [*const std::os::raw::c_char; 2] =
    [b"alt\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut src_alt_attrs: [*const std::os::raw::c_char; 3] =
    [b"src\x00" as *const u8 as *const std::os::raw::c_char,
     b"alt\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut href_attrs: [*const std::os::raw::c_char; 2] =
    [b"href\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut clear_attrs: [*const std::os::raw::c_char; 2] =
    [b"clear\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut inline_p: [*const std::os::raw::c_char; 41] =
    [b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"embed\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"basefont\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"input\x00" as *const u8 as *const std::os::raw::c_char,
     b"select\x00" as *const u8 as *const std::os::raw::c_char,
     b"textarea\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char];
static mut flow_param: [*const std::os::raw::c_char; 65] =
    [b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"embed\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"basefont\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"input\x00" as *const u8 as *const std::os::raw::c_char,
     b"select\x00" as *const u8 as *const std::os::raw::c_char,
     b"textarea\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     b"param\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut applet_attrs: [*const std::os::raw::c_char; 14] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"codebase\x00" as *const u8 as *const std::os::raw::c_char,
     b"archive\x00" as *const u8 as *const std::os::raw::c_char,
     b"alt\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"height\x00" as *const u8 as *const std::os::raw::c_char,
     b"width\x00" as *const u8 as *const std::os::raw::c_char,
     b"align\x00" as *const u8 as *const std::os::raw::c_char,
     b"hspace\x00" as *const u8 as *const std::os::raw::c_char,
     b"vspace\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut area_attrs: [*const std::os::raw::c_char; 9] =
    [b"shape\x00" as *const u8 as *const std::os::raw::c_char,
     b"coords\x00" as *const u8 as *const std::os::raw::c_char,
     b"href\x00" as *const u8 as *const std::os::raw::c_char,
     b"nohref\x00" as *const u8 as *const std::os::raw::c_char,
     b"tabindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"accesskey\x00" as *const u8 as *const std::os::raw::c_char,
     b"onfocus\x00" as *const u8 as *const std::os::raw::c_char,
     b"onblur\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut basefont_attrs: [*const std::os::raw::c_char; 5] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"size\x00" as *const u8 as *const std::os::raw::c_char,
     b"color\x00" as *const u8 as *const std::os::raw::c_char,
     b"face\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut quote_attrs: [*const std::os::raw::c_char; 17] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut body_contents: [*const std::os::raw::c_char; 66] =
    [b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"embed\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"basefont\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"input\x00" as *const u8 as *const std::os::raw::c_char,
     b"select\x00" as *const u8 as *const std::os::raw::c_char,
     b"textarea\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     b"ins\x00" as *const u8 as *const std::os::raw::c_char,
     b"del\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut body_attrs: [*const std::os::raw::c_char; 18] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onload\x00" as *const u8 as *const std::os::raw::c_char,
     b"onunload\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut body_depr: [*const std::os::raw::c_char; 7] =
    [b"background\x00" as *const u8 as *const std::os::raw::c_char,
     b"bgcolor\x00" as *const u8 as *const std::os::raw::c_char,
     b"text\x00" as *const u8 as *const std::os::raw::c_char,
     b"link\x00" as *const u8 as *const std::os::raw::c_char,
     b"vlink\x00" as *const u8 as *const std::os::raw::c_char,
     b"alink\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut button_attrs: [*const std::os::raw::c_char; 24] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"value\x00" as *const u8 as *const std::os::raw::c_char,
     b"type\x00" as *const u8 as *const std::os::raw::c_char,
     b"disabled\x00" as *const u8 as *const std::os::raw::c_char,
     b"tabindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"accesskey\x00" as *const u8 as *const std::os::raw::c_char,
     b"onfocus\x00" as *const u8 as *const std::os::raw::c_char,
     b"onblur\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut col_attrs: [*const std::os::raw::c_char; 22] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"width\x00" as *const u8 as *const std::os::raw::c_char,
     b"align\x00" as *const u8 as *const std::os::raw::c_char,
     b"char\x00" as *const u8 as *const std::os::raw::c_char,
     b"charoff\x00" as *const u8 as *const std::os::raw::c_char,
     b"valign\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut col_elt: [*const std::os::raw::c_char; 2] =
    [b"col\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut edit_attrs: [*const std::os::raw::c_char; 18] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"datetime\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut compact_attrs: [*const std::os::raw::c_char; 17] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"compact\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut dl_contents: [*const std::os::raw::c_char; 3] =
    [b"dt\x00" as *const u8 as *const std::os::raw::c_char,
     b"dd\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char];
static mut compact_attr: [*const std::os::raw::c_char; 2] =
    [b"compact\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut label_attr: [*const std::os::raw::c_char; 2] =
    [b"label\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut fieldset_contents: [*const std::os::raw::c_char; 64] =
    [b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"embed\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"basefont\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"input\x00" as *const u8 as *const std::os::raw::c_char,
     b"select\x00" as *const u8 as *const std::os::raw::c_char,
     b"textarea\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     b"legend\x00" as *const u8 as *const std::os::raw::c_char];
static mut font_attrs: [*const std::os::raw::c_char; 10] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"size\x00" as *const u8 as *const std::os::raw::c_char,
     b"color\x00" as *const u8 as *const std::os::raw::c_char,
     b"face\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut form_contents: [*const std::os::raw::c_char; 62] =
    [b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"embed\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"basefont\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"input\x00" as *const u8 as *const std::os::raw::c_char,
     b"select\x00" as *const u8 as *const std::os::raw::c_char,
     b"textarea\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut form_attrs: [*const std::os::raw::c_char; 23] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"method\x00" as *const u8 as *const std::os::raw::c_char,
     b"enctype\x00" as *const u8 as *const std::os::raw::c_char,
     b"accept\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"onsubmit\x00" as *const u8 as *const std::os::raw::c_char,
     b"onreset\x00" as *const u8 as *const std::os::raw::c_char,
     b"accept-charset\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut frame_attrs: [*const std::os::raw::c_char; 13] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"longdesc\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"src\x00" as *const u8 as *const std::os::raw::c_char,
     b"frameborder\x00" as *const u8 as *const std::os::raw::c_char,
     b"marginwidth\x00" as *const u8 as *const std::os::raw::c_char,
     b"marginheight\x00" as *const u8 as *const std::os::raw::c_char,
     b"noresize\x00" as *const u8 as *const std::os::raw::c_char,
     b"scrolling\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut frameset_attrs: [*const std::os::raw::c_char; 9] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"rows\x00" as *const u8 as *const std::os::raw::c_char,
     b"cols\x00" as *const u8 as *const std::os::raw::c_char,
     b"onload\x00" as *const u8 as *const std::os::raw::c_char,
     b"onunload\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut frameset_contents: [*const std::os::raw::c_char; 4] =
    [b"frameset\x00" as *const u8 as *const std::os::raw::c_char,
     b"frame\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut head_attrs: [*const std::os::raw::c_char; 4] =
    [b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"profile\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut head_contents: [*const std::os::raw::c_char; 9] =
    [b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"base\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"meta\x00" as *const u8 as *const std::os::raw::c_char,
     b"link\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut hr_depr: [*const std::os::raw::c_char; 5] =
    [b"align\x00" as *const u8 as *const std::os::raw::c_char,
     b"noshade\x00" as *const u8 as *const std::os::raw::c_char,
     b"size\x00" as *const u8 as *const std::os::raw::c_char,
     b"width\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut version_attr: [*const std::os::raw::c_char; 2] =
    [b"version\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut html_content: [*const std::os::raw::c_char; 4] =
    [b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"body\x00" as *const u8 as *const std::os::raw::c_char,
     b"frameset\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut iframe_attrs: [*const std::os::raw::c_char; 15] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"longdesc\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"src\x00" as *const u8 as *const std::os::raw::c_char,
     b"frameborder\x00" as *const u8 as *const std::os::raw::c_char,
     b"marginwidth\x00" as *const u8 as *const std::os::raw::c_char,
     b"marginheight\x00" as *const u8 as *const std::os::raw::c_char,
     b"scrolling\x00" as *const u8 as *const std::os::raw::c_char,
     b"align\x00" as *const u8 as *const std::os::raw::c_char,
     b"height\x00" as *const u8 as *const std::os::raw::c_char,
     b"width\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut img_attrs: [*const std::os::raw::c_char; 22] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"longdesc\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"height\x00" as *const u8 as *const std::os::raw::c_char,
     b"width\x00" as *const u8 as *const std::os::raw::c_char,
     b"usemap\x00" as *const u8 as *const std::os::raw::c_char,
     b"ismap\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut embed_attrs: [*const std::os::raw::c_char; 23] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"align\x00" as *const u8 as *const std::os::raw::c_char,
     b"alt\x00" as *const u8 as *const std::os::raw::c_char,
     b"border\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"codebase\x00" as *const u8 as *const std::os::raw::c_char,
     b"frameborder\x00" as *const u8 as *const std::os::raw::c_char,
     b"height\x00" as *const u8 as *const std::os::raw::c_char,
     b"hidden\x00" as *const u8 as *const std::os::raw::c_char,
     b"hspace\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"palette\x00" as *const u8 as *const std::os::raw::c_char,
     b"pluginspace\x00" as *const u8 as *const std::os::raw::c_char,
     b"pluginurl\x00" as *const u8 as *const std::os::raw::c_char,
     b"src\x00" as *const u8 as *const std::os::raw::c_char,
     b"type\x00" as *const u8 as *const std::os::raw::c_char,
     b"units\x00" as *const u8 as *const std::os::raw::c_char,
     b"vspace\x00" as *const u8 as *const std::os::raw::c_char,
     b"width\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut input_attrs: [*const std::os::raw::c_char; 35] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"type\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"value\x00" as *const u8 as *const std::os::raw::c_char,
     b"checked\x00" as *const u8 as *const std::os::raw::c_char,
     b"disabled\x00" as *const u8 as *const std::os::raw::c_char,
     b"readonly\x00" as *const u8 as *const std::os::raw::c_char,
     b"size\x00" as *const u8 as *const std::os::raw::c_char,
     b"maxlength\x00" as *const u8 as *const std::os::raw::c_char,
     b"src\x00" as *const u8 as *const std::os::raw::c_char,
     b"alt\x00" as *const u8 as *const std::os::raw::c_char,
     b"usemap\x00" as *const u8 as *const std::os::raw::c_char,
     b"ismap\x00" as *const u8 as *const std::os::raw::c_char,
     b"tabindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"accesskey\x00" as *const u8 as *const std::os::raw::c_char,
     b"onfocus\x00" as *const u8 as *const std::os::raw::c_char,
     b"onblur\x00" as *const u8 as *const std::os::raw::c_char,
     b"onselect\x00" as *const u8 as *const std::os::raw::c_char,
     b"onchange\x00" as *const u8 as *const std::os::raw::c_char,
     b"accept\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut prompt_attrs: [*const std::os::raw::c_char; 8] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"prompt\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut label_attrs: [*const std::os::raw::c_char; 20] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"for\x00" as *const u8 as *const std::os::raw::c_char,
     b"accesskey\x00" as *const u8 as *const std::os::raw::c_char,
     b"onfocus\x00" as *const u8 as *const std::os::raw::c_char,
     b"onblur\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut legend_attrs: [*const std::os::raw::c_char; 17] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"accesskey\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut align_attr: [*const std::os::raw::c_char; 2] =
    [b"align\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut link_attrs: [*const std::os::raw::c_char; 23] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"charset\x00" as *const u8 as *const std::os::raw::c_char,
     b"href\x00" as *const u8 as *const std::os::raw::c_char,
     b"hreflang\x00" as *const u8 as *const std::os::raw::c_char,
     b"type\x00" as *const u8 as *const std::os::raw::c_char,
     b"rel\x00" as *const u8 as *const std::os::raw::c_char,
     b"rev\x00" as *const u8 as *const std::os::raw::c_char,
     b"media\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut map_contents: [*const std::os::raw::c_char; 26] =
    [b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"area\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut name_attr: [*const std::os::raw::c_char; 2] =
    [b"name\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut action_attr: [*const std::os::raw::c_char; 2] =
    [b"action\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut blockli_elt: [*const std::os::raw::c_char; 26] =
    [b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"li\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char];
static mut meta_attrs: [*const std::os::raw::c_char; 7] =
    [b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"http-equiv\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"scheme\x00" as *const u8 as *const std::os::raw::c_char,
     b"charset\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut content_attr: [*const std::os::raw::c_char; 2] =
    [b"content\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut type_attr: [*const std::os::raw::c_char; 2] =
    [b"type\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut noframes_content: [*const std::os::raw::c_char; 65] =
    [b"body\x00" as *const u8 as *const std::os::raw::c_char,
     b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"embed\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"basefont\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"input\x00" as *const u8 as *const std::os::raw::c_char,
     b"select\x00" as *const u8 as *const std::os::raw::c_char,
     b"textarea\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut object_contents: [*const std::os::raw::c_char; 65] =
    [b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"isindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"embed\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"basefont\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"input\x00" as *const u8 as *const std::os::raw::c_char,
     b"select\x00" as *const u8 as *const std::os::raw::c_char,
     b"textarea\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     b"param\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut object_attrs: [*const std::os::raw::c_char; 29] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"declare\x00" as *const u8 as *const std::os::raw::c_char,
     b"classid\x00" as *const u8 as *const std::os::raw::c_char,
     b"codebase\x00" as *const u8 as *const std::os::raw::c_char,
     b"data\x00" as *const u8 as *const std::os::raw::c_char,
     b"type\x00" as *const u8 as *const std::os::raw::c_char,
     b"codetype\x00" as *const u8 as *const std::os::raw::c_char,
     b"archive\x00" as *const u8 as *const std::os::raw::c_char,
     b"standby\x00" as *const u8 as *const std::os::raw::c_char,
     b"height\x00" as *const u8 as *const std::os::raw::c_char,
     b"width\x00" as *const u8 as *const std::os::raw::c_char,
     b"usemap\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"tabindex\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut object_depr: [*const std::os::raw::c_char; 5] =
    [b"align\x00" as *const u8 as *const std::os::raw::c_char,
     b"border\x00" as *const u8 as *const std::os::raw::c_char,
     b"hspace\x00" as *const u8 as *const std::os::raw::c_char,
     b"vspace\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut ol_attrs: [*const std::os::raw::c_char; 4] =
    [b"type\x00" as *const u8 as *const std::os::raw::c_char,
     b"compact\x00" as *const u8 as *const std::os::raw::c_char,
     b"start\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut option_elt: [*const std::os::raw::c_char; 2] =
    [b"option\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut optgroup_attrs: [*const std::os::raw::c_char; 17] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"disabled\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut option_attrs: [*const std::os::raw::c_char; 20] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"disabled\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"selected\x00" as *const u8 as *const std::os::raw::c_char,
     b"value\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut param_attrs: [*const std::os::raw::c_char; 5] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"value\x00" as *const u8 as *const std::os::raw::c_char,
     b"valuetype\x00" as *const u8 as *const std::os::raw::c_char,
     b"type\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut width_attr: [*const std::os::raw::c_char; 2] =
    [b"width\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut pre_content: [*const std::os::raw::c_char; 25] =
    [b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut script_attrs: [*const std::os::raw::c_char; 6] =
    [b"charset\x00" as *const u8 as *const std::os::raw::c_char,
     b"src\x00" as *const u8 as *const std::os::raw::c_char,
     b"defer\x00" as *const u8 as *const std::os::raw::c_char,
     b"event\x00" as *const u8 as *const std::os::raw::c_char,
     b"for\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut language_attr: [*const std::os::raw::c_char; 2] =
    [b"language\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut select_content: [*const std::os::raw::c_char; 3] =
    [b"optgroup\x00" as *const u8 as *const std::os::raw::c_char,
     b"option\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut select_attrs: [*const std::os::raw::c_char; 24] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"size\x00" as *const u8 as *const std::os::raw::c_char,
     b"multiple\x00" as *const u8 as *const std::os::raw::c_char,
     b"disabled\x00" as *const u8 as *const std::os::raw::c_char,
     b"tabindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"onfocus\x00" as *const u8 as *const std::os::raw::c_char,
     b"onblur\x00" as *const u8 as *const std::os::raw::c_char,
     b"onchange\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut style_attrs: [*const std::os::raw::c_char; 5] =
    [b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"media\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut table_attrs: [*const std::os::raw::c_char; 24] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"summary\x00" as *const u8 as *const std::os::raw::c_char,
     b"width\x00" as *const u8 as *const std::os::raw::c_char,
     b"border\x00" as *const u8 as *const std::os::raw::c_char,
     b"frame\x00" as *const u8 as *const std::os::raw::c_char,
     b"rules\x00" as *const u8 as *const std::os::raw::c_char,
     b"cellspacing\x00" as *const u8 as *const std::os::raw::c_char,
     b"cellpadding\x00" as *const u8 as *const std::os::raw::c_char,
     b"datapagesize\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut table_depr: [*const std::os::raw::c_char; 3] =
    [b"align\x00" as *const u8 as *const std::os::raw::c_char,
     b"bgcolor\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut table_contents: [*const std::os::raw::c_char; 8] =
    [b"caption\x00" as *const u8 as *const std::os::raw::c_char,
     b"col\x00" as *const u8 as *const std::os::raw::c_char,
     b"colgroup\x00" as *const u8 as *const std::os::raw::c_char,
     b"thead\x00" as *const u8 as *const std::os::raw::c_char,
     b"tfoot\x00" as *const u8 as *const std::os::raw::c_char,
     b"tbody\x00" as *const u8 as *const std::os::raw::c_char,
     b"tr\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char];
static mut tr_elt: [*const std::os::raw::c_char; 2] =
    [b"tr\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char];
static mut talign_attrs: [*const std::os::raw::c_char; 20] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"align\x00" as *const u8 as *const std::os::raw::c_char,
     b"char\x00" as *const u8 as *const std::os::raw::c_char,
     b"charoff\x00" as *const u8 as *const std::os::raw::c_char,
     b"valign\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut th_td_depr: [*const std::os::raw::c_char; 5] =
    [b"nowrap\x00" as *const u8 as *const std::os::raw::c_char,
     b"bgcolor\x00" as *const u8 as *const std::os::raw::c_char,
     b"width\x00" as *const u8 as *const std::os::raw::c_char,
     b"height\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut th_td_attr: [*const std::os::raw::c_char; 26] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"axis\x00" as *const u8 as *const std::os::raw::c_char,
     b"headers\x00" as *const u8 as *const std::os::raw::c_char,
     b"scope\x00" as *const u8 as *const std::os::raw::c_char,
     b"rowspan\x00" as *const u8 as *const std::os::raw::c_char,
     b"colspan\x00" as *const u8 as *const std::os::raw::c_char,
     b"align\x00" as *const u8 as *const std::os::raw::c_char,
     b"char\x00" as *const u8 as *const std::os::raw::c_char,
     b"charoff\x00" as *const u8 as *const std::os::raw::c_char,
     b"valign\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut textarea_attrs: [*const std::os::raw::c_char; 25] =
    [b"id\x00" as *const u8 as *const std::os::raw::c_char,
     b"class\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"lang\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"name\x00" as *const u8 as *const std::os::raw::c_char,
     b"disabled\x00" as *const u8 as *const std::os::raw::c_char,
     b"readonly\x00" as *const u8 as *const std::os::raw::c_char,
     b"tabindex\x00" as *const u8 as *const std::os::raw::c_char,
     b"accesskey\x00" as *const u8 as *const std::os::raw::c_char,
     b"onfocus\x00" as *const u8 as *const std::os::raw::c_char,
     b"onblur\x00" as *const u8 as *const std::os::raw::c_char,
     b"onselect\x00" as *const u8 as *const std::os::raw::c_char,
     b"onchange\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut tr_contents: [*const std::os::raw::c_char; 3] =
    [b"th\x00" as *const u8 as *const std::os::raw::c_char,
     b"td\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char];
static mut bgcolor_attr: [*const std::os::raw::c_char; 2] =
    [b"bgcolor\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut li_elt: [*const std::os::raw::c_char; 2] =
    [b"li\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char];
static mut ul_depr: [*const std::os::raw::c_char; 3] =
    [b"type\x00" as *const u8 as *const std::os::raw::c_char,
     b"compact\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut dir_attr: [*const std::os::raw::c_char; 2] =
    [b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
static mut html40ElementTable: [htmlElemDesc; 92] =
    unsafe {
        [{
             let mut init =
                 _htmlElemDesc{name:
                                   b"a\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"anchor \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   a_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   target_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"abbr\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"abbreviated form\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"acronym\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"address\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"information on author \x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   inline_p.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"applet\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"java applet \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   flow_param.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   applet_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"area\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"client-side image map area \x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   area_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   target_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   alt_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"b\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"bold text style\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"base\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"document base uri \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   target_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   href_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"basefont\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"base font size \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   basefont_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"bdo\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"i18n bidi over-ride \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   core_i18n_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   dir_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"big\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"large text style\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"blockquote\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"long quotation \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   quote_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"body\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"document body \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   body_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"div\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   body_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   body_depr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"br\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"forced line break \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   core_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   clear_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"button\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"push button \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   button_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"caption\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"table caption \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"center\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"shorthand for div align=center \x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"cite\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"citation\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"code\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"computer code fragment\x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"col\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"table column \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   col_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"colgroup\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"table column group \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   col_elt.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"col\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   col_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"dd\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"definition description \x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"del\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"deleted text \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   edit_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"dfn\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"instance definition\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"dir\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"directory list\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   blockli_elt.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"li\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   compact_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"div\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"generic language/style container\x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"dl\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"definition list \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   dl_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"dd\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   compact_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"dt\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"definition term \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"em\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"emphasis\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"embed\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"generic embedded object \x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   embed_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"fieldset\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"form control group \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   fieldset_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"font\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"local change to font \x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   font_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"form\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"interactive form \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   form_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"fieldset\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   form_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   target_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   action_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"frame\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"subwindow \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   frame_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"frameset\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"window subdivision\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   frameset_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"noframes\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   frameset_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"h1\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"heading \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"h2\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"heading \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"h3\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"heading \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"h4\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"heading \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"h5\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"heading \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"h6\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"heading \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"head\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"document head \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   head_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   head_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"hr\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"horizontal rule \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   hr_depr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"html\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"document root element \x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   html_content.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   i18n_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   version_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"i\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"italic text style\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"iframe\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"inline subwindow \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   iframe_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"img\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"embedded image \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   img_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   src_alt_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"input\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"form control \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   input_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"ins\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"inserted text\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   edit_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"isindex\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"single line prompt \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   prompt_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"kbd\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"text to be entered by the user\x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"label\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"form field label text \x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   label_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"legend\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"fieldset legend \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   legend_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"li\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"list item \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"link\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"a media-independent link \x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   link_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   target_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"map\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"client-side image map \x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   map_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   name_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"menu\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"menu list \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   blockli_elt.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   compact_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"meta\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"generic metainformation \x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   meta_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   content_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"noframes\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"alternate content container for non frame-based rendering \x00"
                                       as *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   noframes_content.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"body\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"noscript\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"alternate content container for non script-based rendering \x00"
                                       as *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"div\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"object\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"generic embedded object \x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   object_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"div\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   object_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   object_depr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"ol\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"ordered list \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   li_elt.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"li\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   ol_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"optgroup\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"option group \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   option_elt.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"option\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   optgroup_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   label_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"option\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"selectable choice \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_pcdata.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   option_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"p\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"paragraph \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   align_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"param\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"named property value \x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   param_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   name_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"pre\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"preformatted text \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   pre_content.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   width_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"q\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"short inline quotation \x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   quote_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"s\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"strike-through text style\x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"samp\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"sample program output, scripts, etc.\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"script\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 2 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"script statements \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_pcdata.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   script_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   language_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   type_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"select\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"option selector \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   select_content.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   select_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"small\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"small text style\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"span\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"generic language/style container \x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"strike\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"strike-through text\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"strong\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"strong emphasis\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"style\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"style info \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_pcdata.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   style_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   type_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"sub\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"subscript\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"sup\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"superscript \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"table\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   table_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"tr\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   table_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   table_depr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"tbody\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"table body \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   tr_elt.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"tr\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   talign_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"td\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"table data cell\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   th_td_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   th_td_depr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"textarea\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"multi-line text field \x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   html_pcdata.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   textarea_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   rows_cols_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"tfoot\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"table footer \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   tr_elt.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"tr\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   talign_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"th\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"table header cell\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_flow.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   th_td_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   th_td_depr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"thead\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"table header \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   tr_elt.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"tr\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   talign_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"title\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"document title \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   html_pcdata.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   i18n_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"tr\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"table row \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   tr_contents.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"td\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   talign_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   bgcolor_attr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"tt\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"teletype or monospaced text style\x00" as
                                       *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"u\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 3 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"underlined text style\x00" as *const u8
                                       as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"ul\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"unordered list \x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               subelts:
                                   li_elt.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt:
                                   b"li\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   ul_depr.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         },
         {
             let mut init =
                 _htmlElemDesc{name:
                                   b"var\x00" as *const u8 as
                                       *const std::os::raw::c_char,
                               startTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               endTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               saveEndTag: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               empty: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               depr: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               dtd: 0 as std::os::raw::c_int as std::os::raw::c_char,
                               isinline: 1 as std::os::raw::c_int as std::os::raw::c_char,
                               desc:
                                   b"instance of a variable or program argument\x00"
                                       as *const u8 as *const std::os::raw::c_char,
                               subelts:
                                   html_inline.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               defaultsubelt: 0 as *const std::os::raw::c_char,
                               attrs_opt:
                                   html_attrs.as_ptr() as
                                       *mut *const std::os::raw::c_char,
                               attrs_depr:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,
                               attrs_req:
                                   0 as *const *const std::os::raw::c_char as
                                       *mut *const std::os::raw::c_char,};
             init
         }]
    };
/*
 * start tags that imply the end of current element
 */
static mut htmlStartClose: [*const std::os::raw::c_char; 394] =
    [b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"listing\x00" as *const u8 as *const std::os::raw::c_char,
     b"xmp\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"body\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"link\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"frameset\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"style\x00" as *const u8 as *const std::os::raw::c_char,
     b"link\x00" as *const u8 as *const std::os::raw::c_char,
     b"title\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"li\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"listing\x00" as *const u8 as *const std::os::raw::c_char,
     b"xmp\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"li\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"hr\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"listing\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"xmp\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"dl\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"dt\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"listing\x00" as *const u8 as *const std::os::raw::c_char,
     b"xmp\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"dt\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"listing\x00" as *const u8 as *const std::os::raw::c_char,
     b"xmp\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"dd\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"dd\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"listing\x00" as *const u8 as *const std::os::raw::c_char,
     b"xmp\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"dt\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"dir\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"listing\x00" as *const u8 as *const std::os::raw::c_char,
     b"xmp\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"ol\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"menu\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"ul\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"script\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"caption\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"colgroup\x00" as *const u8 as *const std::os::raw::c_char,
     b"caption\x00" as *const u8 as *const std::os::raw::c_char,
     b"colgroup\x00" as *const u8 as *const std::os::raw::c_char,
     b"col\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"col\x00" as *const u8 as *const std::os::raw::c_char,
     b"caption\x00" as *const u8 as *const std::os::raw::c_char,
     b"col\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"table\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"listing\x00" as *const u8 as *const std::os::raw::c_char,
     b"xmp\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"th\x00" as *const u8 as *const std::os::raw::c_char,
     b"th\x00" as *const u8 as *const std::os::raw::c_char,
     b"td\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"td\x00" as *const u8 as *const std::os::raw::c_char,
     b"th\x00" as *const u8 as *const std::os::raw::c_char,
     b"td\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"tr\x00" as *const u8 as *const std::os::raw::c_char,
     b"th\x00" as *const u8 as *const std::os::raw::c_char,
     b"td\x00" as *const u8 as *const std::os::raw::c_char,
     b"tr\x00" as *const u8 as *const std::os::raw::c_char,
     b"caption\x00" as *const u8 as *const std::os::raw::c_char,
     b"col\x00" as *const u8 as *const std::os::raw::c_char,
     b"colgroup\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"thead\x00" as *const u8 as *const std::os::raw::c_char,
     b"caption\x00" as *const u8 as *const std::os::raw::c_char,
     b"col\x00" as *const u8 as *const std::os::raw::c_char,
     b"colgroup\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"tfoot\x00" as *const u8 as *const std::os::raw::c_char,
     b"th\x00" as *const u8 as *const std::os::raw::c_char,
     b"td\x00" as *const u8 as *const std::os::raw::c_char,
     b"tr\x00" as *const u8 as *const std::os::raw::c_char,
     b"caption\x00" as *const u8 as *const std::os::raw::c_char,
     b"col\x00" as *const u8 as *const std::os::raw::c_char,
     b"colgroup\x00" as *const u8 as *const std::os::raw::c_char,
     b"thead\x00" as *const u8 as *const std::os::raw::c_char,
     b"tbody\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"tbody\x00" as *const u8 as *const std::os::raw::c_char,
     b"th\x00" as *const u8 as *const std::os::raw::c_char,
     b"td\x00" as *const u8 as *const std::os::raw::c_char,
     b"tr\x00" as *const u8 as *const std::os::raw::c_char,
     b"caption\x00" as *const u8 as *const std::os::raw::c_char,
     b"col\x00" as *const u8 as *const std::os::raw::c_char,
     b"colgroup\x00" as *const u8 as *const std::os::raw::c_char,
     b"thead\x00" as *const u8 as *const std::os::raw::c_char,
     b"tfoot\x00" as *const u8 as *const std::os::raw::c_char,
     b"tbody\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"optgroup\x00" as *const u8 as *const std::os::raw::c_char,
     b"option\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"option\x00" as *const u8 as *const std::os::raw::c_char,
     b"option\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"fieldset\x00" as *const u8 as *const std::os::raw::c_char,
     b"legend\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"listing\x00" as *const u8 as *const std::os::raw::c_char,
     b"xmp\x00" as *const u8 as *const std::os::raw::c_char,
     b"a\x00" as *const u8 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"var\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"img\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"br\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"map\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"sub\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"sup\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char];
/*
 * The list of HTML elements which are supposed not to have
 * CDATA content and where a p element will be implied
 *
 * TODO: extend that list by reading the HTML SGML DTD on
 *       implied paragraph
 */
static mut htmlNoContentElements: [*const std::os::raw::c_char; 3] =
    [b"html\x00" as *const u8 as *const std::os::raw::c_char,
     b"head\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
/*
 * The list of HTML attributes which are of content %Script;
 * NOTE: when adding ones, check htmlIsScriptAttribute() since
 *       it assumes the name starts with 'on'
 */
static mut htmlScriptAttributes: [*const std::os::raw::c_char; 18] =
    [b"onclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"ondblclick\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousedown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseover\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmousemove\x00" as *const u8 as *const std::os::raw::c_char,
     b"onmouseout\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeypress\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeydown\x00" as *const u8 as *const std::os::raw::c_char,
     b"onkeyup\x00" as *const u8 as *const std::os::raw::c_char,
     b"onload\x00" as *const u8 as *const std::os::raw::c_char,
     b"onunload\x00" as *const u8 as *const std::os::raw::c_char,
     b"onfocus\x00" as *const u8 as *const std::os::raw::c_char,
     b"onblur\x00" as *const u8 as *const std::os::raw::c_char,
     b"onsubmit\x00" as *const u8 as *const std::os::raw::c_char,
     b"onreset\x00" as *const u8 as *const std::os::raw::c_char,
     b"onchange\x00" as *const u8 as *const std::os::raw::c_char,
     b"onselect\x00" as *const u8 as *const std::os::raw::c_char];
static mut htmlEndPriority: [elementPriority; 12] =
    [{
         let mut init =
             elementPriority{name:
                                 b"div\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 150 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"td\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 160 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"th\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 160 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"tr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 170 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"thead\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 180 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"tbody\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 180 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"tfoot\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 180 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"table\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 190 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"head\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 200 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"body\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 200 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name:
                                 b"html\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             priority: 220 as std::os::raw::c_int,};
         init
     },
     {
         let mut init =
             elementPriority{name: 0 as *const std::os::raw::c_char,
                             priority: 100 as std::os::raw::c_int,};
         init
     }];
static mut htmlStartCloseIndex: [*mut *const std::os::raw::c_char; 100] =
    [0 as *const *const std::os::raw::c_char as *mut *const std::os::raw::c_char; 100];
static mut htmlStartCloseIndexinitialized: std::os::raw::c_int = 0 as std::os::raw::c_int;
/* ***********************************************************************
 *									*
 *	functions to handle HTML specific data			*
 *									*
 ************************************************************************/
/* *
 * htmlInitAutoClose:
 *
 * Initialize the htmlStartCloseIndex for fast lookup of closing tags names.
 * This is not reentrant. Call xmlInitParser() once before processing in
 * case of use in multithreaded programs.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlInitAutoClose() {
    let mut indx: std::os::raw::c_int = 0;
    let mut i: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if htmlStartCloseIndexinitialized != 0 { return }
    indx = 0 as std::os::raw::c_int;
    while indx < 100 as std::os::raw::c_int {
        htmlStartCloseIndex[indx as usize] = 0 as *mut *const std::os::raw::c_char;
        indx += 1
    }
    indx = 0 as std::os::raw::c_int;
    while !htmlStartClose[i as usize].is_null() &&
              indx < 100 as std::os::raw::c_int - 1 as std::os::raw::c_int {
        let fresh4 = indx;
        indx = indx + 1;
        htmlStartCloseIndex[fresh4 as usize] =
            &*htmlStartClose.as_ptr().offset(i as isize) as
                *const *const std::os::raw::c_char as *mut *const std::os::raw::c_char;
        while !htmlStartClose[i as usize].is_null() { i += 1 }
        i += 1
    }
    htmlStartCloseIndexinitialized = 1 as std::os::raw::c_int;
}
/* the description */
/*
 * There is only few public functions.
 */
/* *
 * htmlTagLookup:
 * @tag:  The tag name in lowercase
 *
 * Lookup the HTML tag in the ElementTable
 *
 * Returns the related htmlElemDescPtr or NULL if not found.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlTagLookup(mut tag: *const xmlChar)
 -> *const htmlElemDesc {
    let mut i: std::os::raw::c_uint = 0;
    i = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    while (i as std::os::raw::c_ulong) <
              (::std::mem::size_of::<[htmlElemDesc; 92]>() as
                   std::os::raw::c_ulong).wrapping_div(::std::mem::size_of::<htmlElemDesc>()
                                                   as std::os::raw::c_ulong) {
        if xmlStrcasecmp(tag,
                         html40ElementTable[i as usize].name as *mut xmlChar)
               == 0 {
            return &*html40ElementTable.as_ptr().offset(i as isize) as
                       *const htmlElemDesc as htmlElemDescPtr as
                       *const htmlElemDesc
        }
        i = i.wrapping_add(1)
    }
    return 0 as *const htmlElemDesc;
}
/* *
 * htmlGetEndPriority:
 * @name: The name of the element to look up the priority for.
 *
 * Return value: The "endtag" priority.
 **/
unsafe extern "C" fn htmlGetEndPriority(mut name: *const xmlChar)
 -> std::os::raw::c_int {
    let mut i: std::os::raw::c_int = 0 as std::os::raw::c_int;
    while !htmlEndPriority[i as usize].name.is_null() &&
              xmlStrEqual(htmlEndPriority[i as usize].name as *const xmlChar,
                          name) == 0 {
        i += 1
    }
    return htmlEndPriority[i as usize].priority;
}
/* *
 * htmlCheckAutoClose:
 * @newtag:  The new tag name
 * @oldtag:  The old tag name
 *
 * Checks whether the new tag is one of the registered valid tags for
 * closing old.
 * Initialize the htmlStartCloseIndex for fast lookup of closing tags names.
 *
 * Returns 0 if no, 1 if yes.
 */
unsafe extern "C" fn htmlCheckAutoClose(mut newtag: *const xmlChar,
                                        mut oldtag: *const xmlChar)
 -> std::os::raw::c_int {
    let mut i: std::os::raw::c_int = 0;
    let mut indx: std::os::raw::c_int = 0;
    let mut closed: *mut *const std::os::raw::c_char = 0 as *mut *const std::os::raw::c_char;
    if htmlStartCloseIndexinitialized == 0 as std::os::raw::c_int {
        htmlInitAutoClose();
    }
    /* inefficient, but not a big deal */
    indx = 0 as std::os::raw::c_int;
    while indx < 100 as std::os::raw::c_int {
        closed = htmlStartCloseIndex[indx as usize];
        if closed.is_null() { return 0 as std::os::raw::c_int }
        if xmlStrEqual(*closed as *mut xmlChar, newtag) != 0 { break ; }
        indx += 1
    }
    i =
        closed.offset_from(htmlStartClose.as_ptr()) as std::os::raw::c_long
            as std::os::raw::c_int;
    i += 1;
    while !htmlStartClose[i as usize].is_null() {
        if xmlStrEqual(htmlStartClose[i as usize] as *mut xmlChar, oldtag) !=
               0 {
            return 1 as std::os::raw::c_int
        }
        i += 1
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * htmlAutoCloseOnClose:
 * @ctxt:  an HTML parser context
 * @newtag:  The new tag name
 * @force:  force the tag closure
 *
 * The HTML DTD allows an ending tag to implicitly close other tags.
 */
unsafe extern "C" fn htmlAutoCloseOnClose(mut ctxt: htmlParserCtxtPtr,
                                          mut newtag: *const xmlChar) {
    let mut info: *const htmlElemDesc = 0 as *const htmlElemDesc;
    let mut i: std::os::raw::c_int = 0;
    let mut priority: std::os::raw::c_int = 0;
    priority = htmlGetEndPriority(newtag);
    i = (*ctxt).nameNr - 1 as std::os::raw::c_int;
    while i >= 0 as std::os::raw::c_int {
        if xmlStrEqual(newtag, *(*ctxt).nameTab.offset(i as isize)) != 0 {
            break ;
        }
        /*
         * A missplaced endtag can only close elements with lower
         * or equal priority, so if we find an element with higher
         * priority before we find an element with
         * matching name, we just ignore this endtag
         */
        if htmlGetEndPriority(*(*ctxt).nameTab.offset(i as isize)) > priority
           {
            return
        }
        i -= 1
    }
    if i < 0 as std::os::raw::c_int { return }
    while xmlStrEqual(newtag, (*ctxt).name) == 0 {
        info = htmlTagLookup((*ctxt).name);
        if !info.is_null() &&
               (*info).endTag as std::os::raw::c_int == 3 as std::os::raw::c_int {
            htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
                         b"Opening and ending tag mismatch: %s and %s\n\x00"
                             as *const u8 as *const std::os::raw::c_char, newtag,
                         (*ctxt).name);
        }
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          (*ctxt).name);
        }
        htmlnamePop(ctxt);
    };
}
/* *
 * htmlAutoCloseOnEnd:
 * @ctxt:  an HTML parser context
 *
 * Close all remaining tags at the end of the stream
 */
unsafe extern "C" fn htmlAutoCloseOnEnd(mut ctxt: htmlParserCtxtPtr) {
    let mut i: std::os::raw::c_int = 0;
    if (*ctxt).nameNr == 0 as std::os::raw::c_int { return }
    i = (*ctxt).nameNr - 1 as std::os::raw::c_int;
    while i >= 0 as std::os::raw::c_int {
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          (*ctxt).name);
        }
        htmlnamePop(ctxt);
        i -= 1
    };
}
/* *
 * htmlAutoClose:
 * @ctxt:  an HTML parser context
 * @newtag:  The new tag name or NULL
 *
 * The HTML DTD allows a tag to implicitly close other tags.
 * The list is kept in htmlStartClose array. This function is
 * called when a new tag has been detected and generates the
 * appropriates closes if possible/needed.
 * If newtag is NULL this mean we are at the end of the resource
 * and we should check
 */
unsafe extern "C" fn htmlAutoClose(mut ctxt: htmlParserCtxtPtr,
                                   mut newtag: *const xmlChar) {
    while !newtag.is_null() && !(*ctxt).name.is_null() &&
              htmlCheckAutoClose(newtag, (*ctxt).name) != 0 {
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          (*ctxt).name);
        }
        htmlnamePop(ctxt);
    }
    if newtag.is_null() { htmlAutoCloseOnEnd(ctxt); return }
    while newtag.is_null() && !(*ctxt).name.is_null() &&
              (xmlStrEqual((*ctxt).name,
                           b"head\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) != 0 ||
                   xmlStrEqual((*ctxt).name,
                               b"body\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) != 0 ||
                   xmlStrEqual((*ctxt).name,
                               b"html\x00" as *const u8 as *const std::os::raw::c_char
                                   as *mut xmlChar) != 0) {
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          (*ctxt).name);
        }
        htmlnamePop(ctxt);
    };
}
/* *
 * htmlAutoCloseTag:
 * @doc:  the HTML document
 * @name:  The tag name
 * @elem:  the HTML element
 *
 * The HTML DTD allows a tag to implicitly close other tags.
 * The list is kept in htmlStartClose array. This function checks
 * if the element or one of it's children would autoclose the
 * given tag.
 *
 * Returns 1 if autoclose, 0 otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn htmlAutoCloseTag(mut doc: htmlDocPtr,
                                          mut name: *const xmlChar,
                                          mut elem: htmlNodePtr)
 -> std::os::raw::c_int {
    let mut child: htmlNodePtr = 0 as *mut xmlNode;
    if elem.is_null() { return 1 as std::os::raw::c_int }
    if xmlStrEqual(name, (*elem).name) != 0 { return 0 as std::os::raw::c_int }
    if htmlCheckAutoClose((*elem).name, name) != 0 { return 1 as std::os::raw::c_int }
    child = (*elem).children;
    while !child.is_null() {
        if htmlAutoCloseTag(doc, name, child) != 0 { return 1 as std::os::raw::c_int }
        child = (*child).next
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * htmlIsAutoClosed:
 * @doc:  the HTML document
 * @elem:  the HTML element
 *
 * The HTML DTD allows a tag to implicitly close other tags.
 * The list is kept in htmlStartClose array. This function checks
 * if a tag is autoclosed by one of it's child
 *
 * Returns 1 if autoclosed, 0 otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn htmlIsAutoClosed(mut doc: htmlDocPtr,
                                          mut elem: htmlNodePtr)
 -> std::os::raw::c_int {
    let mut child: htmlNodePtr = 0 as *mut xmlNode;
    if elem.is_null() { return 1 as std::os::raw::c_int }
    child = (*elem).children;
    while !child.is_null() {
        if htmlAutoCloseTag(doc, (*elem).name, child) != 0 {
            return 1 as std::os::raw::c_int
        }
        child = (*child).next
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * htmlCheckImplied:
 * @ctxt:  an HTML parser context
 * @newtag:  The new tag name
 *
 * The HTML DTD allows a tag to exists only implicitly
 * called when a new tag has been detected and generates the
 * appropriates implicit tags if missing
 */
unsafe extern "C" fn htmlCheckImplied(mut ctxt: htmlParserCtxtPtr,
                                      mut newtag: *const xmlChar) {
    let mut i: std::os::raw::c_int = 0;
    if (*ctxt).options & HTML_PARSE_NOIMPLIED as std::os::raw::c_int != 0 { return }
    if htmlOmittedDefaultValue == 0 { return }
    if xmlStrEqual(newtag,
                   b"html\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        return
    }
    if (*ctxt).nameNr <= 0 as std::os::raw::c_int {
        htmlnamePush(ctxt,
                     b"html\x00" as *const u8 as *const std::os::raw::c_char as
                         *mut xmlChar);
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startElement.is_some() {
            (*(*ctxt).sax).startElement.expect("non-null function pointer")((*ctxt).userData,
                                                                            b"html\x00"
                                                                                as
                                                                                *const u8
                                                                                as
                                                                                *const std::os::raw::c_char
                                                                                as
                                                                                *mut xmlChar,
                                                                            0
                                                                                as
                                                                                *mut *const xmlChar);
        }
    }
    if xmlStrEqual(newtag,
                   b"body\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 ||
           xmlStrEqual(newtag,
                       b"head\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
        return
    }
    if (*ctxt).nameNr <= 1 as std::os::raw::c_int &&
           (xmlStrEqual(newtag,
                        b"script\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar) != 0 ||
                xmlStrEqual(newtag,
                            b"style\x00" as *const u8 as *const std::os::raw::c_char
                                as *mut xmlChar) != 0 ||
                xmlStrEqual(newtag,
                            b"meta\x00" as *const u8 as *const std::os::raw::c_char as
                                *mut xmlChar) != 0 ||
                xmlStrEqual(newtag,
                            b"link\x00" as *const u8 as *const std::os::raw::c_char as
                                *mut xmlChar) != 0 ||
                xmlStrEqual(newtag,
                            b"title\x00" as *const u8 as *const std::os::raw::c_char
                                as *mut xmlChar) != 0 ||
                xmlStrEqual(newtag,
                            b"base\x00" as *const u8 as *const std::os::raw::c_char as
                                *mut xmlChar) != 0) {
        if (*ctxt).html >= 3 as std::os::raw::c_int {
            /* we already saw or generated an <head> before */
            return
        }
        /*
         * dropped OBJECT ... i you put it first BODY will be
         * assumed !
         */
        htmlnamePush(ctxt,
                     b"head\x00" as *const u8 as *const std::os::raw::c_char as
                         *mut xmlChar);
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startElement.is_some() {
            (*(*ctxt).sax).startElement.expect("non-null function pointer")((*ctxt).userData,
                                                                            b"head\x00"
                                                                                as
                                                                                *const u8
                                                                                as
                                                                                *const std::os::raw::c_char
                                                                                as
                                                                                *mut xmlChar,
                                                                            0
                                                                                as
                                                                                *mut *const xmlChar);
        }
    } else if xmlStrEqual(newtag,
                          b"noframes\x00" as *const u8 as *const std::os::raw::c_char
                              as *mut xmlChar) == 0 &&
                  xmlStrEqual(newtag,
                              b"frame\x00" as *const u8 as *const std::os::raw::c_char
                                  as *mut xmlChar) == 0 &&
                  xmlStrEqual(newtag,
                              b"frameset\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar) == 0 {
        if (*ctxt).html >= 10 as std::os::raw::c_int {
            /* we already saw or generated a <body> before */
            return
        }
        i = 0 as std::os::raw::c_int;
        while i < (*ctxt).nameNr {
            if xmlStrEqual(*(*ctxt).nameTab.offset(i as isize),
                           b"body\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) != 0 {
                return
            }
            if xmlStrEqual(*(*ctxt).nameTab.offset(i as isize),
                           b"head\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) != 0 {
                return
            }
            i += 1
        }
        htmlnamePush(ctxt,
                     b"body\x00" as *const u8 as *const std::os::raw::c_char as
                         *mut xmlChar);
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startElement.is_some() {
            (*(*ctxt).sax).startElement.expect("non-null function pointer")((*ctxt).userData,
                                                                            b"body\x00"
                                                                                as
                                                                                *const u8
                                                                                as
                                                                                *const std::os::raw::c_char
                                                                                as
                                                                                *mut xmlChar,
                                                                            0
                                                                                as
                                                                                *mut *const xmlChar);
        }
    };
}
/* *
 * htmlCheckParagraph
 * @ctxt:  an HTML parser context
 *
 * Check whether a p element need to be implied before inserting
 * characters in the current element.
 *
 * Returns 1 if a paragraph has been inserted, 0 if not and -1
 *         in case of error.
 */
unsafe extern "C" fn htmlCheckParagraph(mut ctxt: htmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut tag: *const xmlChar = 0 as *const xmlChar;
    let mut i: std::os::raw::c_int = 0;
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    tag = (*ctxt).name;
    if tag.is_null() {
        htmlAutoClose(ctxt,
                      b"p\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        htmlCheckImplied(ctxt,
                         b"p\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut xmlChar);
        htmlnamePush(ctxt,
                     b"p\x00" as *const u8 as *const std::os::raw::c_char as
                         *mut xmlChar);
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startElement.is_some() {
            (*(*ctxt).sax).startElement.expect("non-null function pointer")((*ctxt).userData,
                                                                            b"p\x00"
                                                                                as
                                                                                *const u8
                                                                                as
                                                                                *const std::os::raw::c_char
                                                                                as
                                                                                *mut xmlChar,
                                                                            0
                                                                                as
                                                                                *mut *const xmlChar);
        }
        return 1 as std::os::raw::c_int
    }
    if htmlOmittedDefaultValue == 0 { return 0 as std::os::raw::c_int }
    i = 0 as std::os::raw::c_int;
    while !htmlNoContentElements[i as usize].is_null() {
        if xmlStrEqual(tag, htmlNoContentElements[i as usize] as *mut xmlChar)
               != 0 {
            htmlAutoClose(ctxt,
                          b"p\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar);
            htmlCheckImplied(ctxt,
                             b"p\x00" as *const u8 as *const std::os::raw::c_char as
                                 *mut xmlChar);
            htmlnamePush(ctxt,
                         b"p\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut xmlChar);
            if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startElement.is_some()
               {
                (*(*ctxt).sax).startElement.expect("non-null function pointer")((*ctxt).userData,
                                                                                b"p\x00"
                                                                                    as
                                                                                    *const u8
                                                                                    as
                                                                                    *const std::os::raw::c_char
                                                                                    as
                                                                                    *mut xmlChar,
                                                                                0
                                                                                    as
                                                                                    *mut *const xmlChar);
            }
            return 1 as std::os::raw::c_int
        }
        i += 1
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * htmlIsScriptAttribute:
 * @name:  an attribute name
 *
 * Check if an attribute is of content type Script
 *
 * Returns 1 is the attribute is a script 0 otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn htmlIsScriptAttribute(mut name: *const xmlChar)
 -> std::os::raw::c_int {
    let mut i: std::os::raw::c_uint = 0;
    if name.is_null() { return 0 as std::os::raw::c_int }
    /*
     * all script attributes start with 'on'
     */
    if *name.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int != 'o' as i32 ||
           *name.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int !=
               'n' as i32 {
        return 0 as std::os::raw::c_int
    }
    i = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    while (i as std::os::raw::c_ulong) <
              (::std::mem::size_of::<[*const std::os::raw::c_char; 18]>() as
                   std::os::raw::c_ulong).wrapping_div(::std::mem::size_of::<*const std::os::raw::c_char>()
                                                   as std::os::raw::c_ulong) {
        if xmlStrEqual(name,
                       htmlScriptAttributes[i as usize] as *const xmlChar) !=
               0 {
            return 1 as std::os::raw::c_int
        }
        i = i.wrapping_add(1)
    }
    return 0 as std::os::raw::c_int;
}
/* ***********************************************************************
 *									*
 *	The list of HTML predefined entities			*
 *									*
 ************************************************************************/
static mut html40EntitiesTable: [htmlEntityDesc; 253] =
    [{
         let mut init =
             _htmlEntityDesc{value: 34 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"quot\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"quotation mark = APL quote, U+0022 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 38 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"amp\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"ampersand, U+0026 ISOnum\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 39 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"apos\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"single quote\x00" as *const u8 as
                                     *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 60 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lt\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"less-than sign, U+003C ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 62 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"gt\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greater-than sign, U+003E ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 160 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"nbsp\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"no-break space = non-breaking space, U+00A0 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 161 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"iexcl\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"inverted exclamation mark, U+00A1 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 162 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"cent\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"cent sign, U+00A2 ISOnum\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 163 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"pound\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"pound sign, U+00A3 ISOnum\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 164 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"curren\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"currency sign, U+00A4 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 165 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"yen\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"yen sign = yuan sign, U+00A5 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 166 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"brvbar\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"broken bar = broken vertical bar, U+00A6 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 167 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sect\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"section sign, U+00A7 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 168 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"uml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"diaeresis = spacing diaeresis, U+00A8 ISOdia\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 169 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"copy\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"copyright sign, U+00A9 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 170 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ordf\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"feminine ordinal indicator, U+00AA ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 171 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"laquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 172 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"not\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"not sign, U+00AC ISOnum\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 173 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"shy\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"soft hyphen = discretionary hyphen, U+00AD ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 174 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"reg\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"registered sign = registered trade mark sign, U+00AE ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 175 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"macr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"macron = spacing macron = overline = APL overbar, U+00AF ISOdia\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 176 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"deg\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"degree sign, U+00B0 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 177 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"plusmn\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"plus-minus sign = plus-or-minus sign, U+00B1 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 178 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sup2\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"superscript two = superscript digit two = squared, U+00B2 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 179 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sup3\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"superscript three = superscript digit three = cubed, U+00B3 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 180 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"acute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"acute accent = spacing acute, U+00B4 ISOdia\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 181 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"micro\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"micro sign, U+00B5 ISOnum\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 182 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"para\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"pilcrow sign = paragraph sign, U+00B6 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 183 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"middot\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"middle dot = Georgian comma Greek middle dot, U+00B7 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 184 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"cedil\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"cedilla = spacing cedilla, U+00B8 ISOdia\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 185 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sup1\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"superscript one = superscript digit one, U+00B9 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 186 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ordm\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"masculine ordinal indicator, U+00BA ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 187 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"raquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"right-pointing double angle quotation mark right pointing guillemet, U+00BB ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 188 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"frac14\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 189 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"frac12\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"vulgar fraction one half = fraction one half, U+00BD ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 190 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"frac34\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 191 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"iquest\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"inverted question mark = turned question mark, U+00BF ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 192 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Agrave\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 193 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Aacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter A with acute, U+00C1 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 194 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Acirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter A with circumflex, U+00C2 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 195 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Atilde\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter A with tilde, U+00C3 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 196 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Auml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter A with diaeresis, U+00C4 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 197 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Aring\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 198 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"AElig\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 199 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Ccedil\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter C with cedilla, U+00C7 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 200 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Egrave\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter E with grave, U+00C8 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 201 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Eacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter E with acute, U+00C9 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 202 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Ecirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter E with circumflex, U+00CA ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 203 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Euml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter E with diaeresis, U+00CB ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 204 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Igrave\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter I with grave, U+00CC ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 205 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Iacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter I with acute, U+00CD ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 206 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Icirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter I with circumflex, U+00CE ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 207 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Iuml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter I with diaeresis, U+00CF ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 208 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ETH\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter ETH, U+00D0 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 209 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Ntilde\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter N with tilde, U+00D1 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 210 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Ograve\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter O with grave, U+00D2 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 211 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Oacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter O with acute, U+00D3 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 212 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Ocirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter O with circumflex, U+00D4 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 213 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Otilde\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter O with tilde, U+00D5 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 214 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Ouml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter O with diaeresis, U+00D6 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 215 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"times\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"multiplication sign, U+00D7 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 216 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Oslash\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter O with stroke latin capital letter O slash, U+00D8 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 217 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Ugrave\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter U with grave, U+00D9 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 218 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Uacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter U with acute, U+00DA ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 219 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Ucirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter U with circumflex, U+00DB ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 220 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Uuml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter U with diaeresis, U+00DC ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 221 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Yacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter Y with acute, U+00DD ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 222 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"THORN\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter THORN, U+00DE ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 223 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"szlig\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter sharp s = ess-zed, U+00DF ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 224 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"agrave\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 225 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"aacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter a with acute, U+00E1 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 226 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"acirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter a with circumflex, U+00E2 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 227 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"atilde\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter a with tilde, U+00E3 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 228 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"auml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter a with diaeresis, U+00E4 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 229 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"aring\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 230 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"aelig\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter ae = latin small ligature ae, U+00E6 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 231 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ccedil\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter c with cedilla, U+00E7 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 232 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"egrave\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter e with grave, U+00E8 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 233 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"eacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter e with acute, U+00E9 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 234 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ecirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter e with circumflex, U+00EA ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 235 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"euml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter e with diaeresis, U+00EB ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 236 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"igrave\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter i with grave, U+00EC ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 237 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"iacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter i with acute, U+00ED ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 238 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"icirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter i with circumflex, U+00EE ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 239 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"iuml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter i with diaeresis, U+00EF ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 240 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"eth\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter eth, U+00F0 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 241 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ntilde\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter n with tilde, U+00F1 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 242 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ograve\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter o with grave, U+00F2 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 243 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"oacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter o with acute, U+00F3 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 244 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ocirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter o with circumflex, U+00F4 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 245 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"otilde\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter o with tilde, U+00F5 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 246 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ouml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter o with diaeresis, U+00F6 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 247 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"divide\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"division sign, U+00F7 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 248 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"oslash\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 249 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ugrave\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter u with grave, U+00F9 ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 250 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"uacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter u with acute, U+00FA ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 251 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ucirc\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter u with circumflex, U+00FB ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 252 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"uuml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter u with diaeresis, U+00FC ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 253 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"yacute\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter y with acute, U+00FD ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 254 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"thorn\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter thorn with, U+00FE ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 255 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"yuml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter y with diaeresis, U+00FF ISOlat1\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 338 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"OElig\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital ligature OE, U+0152 ISOlat2\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 339 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"oelig\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small ligature oe, U+0153 ISOlat2\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 352 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Scaron\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter S with caron, U+0160 ISOlat2\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 353 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"scaron\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small letter s with caron, U+0161 ISOlat2\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 376 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Yuml\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin capital letter Y with diaeresis, U+0178 ISOlat2\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 402 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"fnof\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"latin small f with hook = function = florin, U+0192 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 710 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"circ\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"modifier letter circumflex accent, U+02C6 ISOpub\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 732 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"tilde\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"small tilde, U+02DC ISOdia\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 913 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Alpha\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter alpha, U+0391\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 914 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Beta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter beta, U+0392\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 915 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Gamma\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter gamma, U+0393 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 916 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Delta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter delta, U+0394 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 917 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Epsilon\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter epsilon, U+0395\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 918 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Zeta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter zeta, U+0396\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 919 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Eta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter eta, U+0397\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 920 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Theta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter theta, U+0398 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 921 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Iota\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter iota, U+0399\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 922 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Kappa\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter kappa, U+039A\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 923 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Lambda\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter lambda, U+039B ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 924 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Mu\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter mu, U+039C\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 925 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Nu\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter nu, U+039D\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 926 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Xi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter xi, U+039E ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 927 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Omicron\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter omicron, U+039F\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 928 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Pi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter pi, U+03A0 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 929 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Rho\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter rho, U+03A1\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 931 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Sigma\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter sigma, U+03A3 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 932 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Tau\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter tau, U+03A4\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 933 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Upsilon\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter upsilon, U+03A5 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 934 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Phi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter phi, U+03A6 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 935 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Chi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter chi, U+03A7\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 936 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Psi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter psi, U+03A8 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 937 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Omega\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek capital letter omega, U+03A9 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 945 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"alpha\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter alpha, U+03B1 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 946 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"beta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter beta, U+03B2 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 947 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"gamma\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter gamma, U+03B3 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 948 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"delta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter delta, U+03B4 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 949 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"epsilon\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter epsilon, U+03B5 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 950 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"zeta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter zeta, U+03B6 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 951 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"eta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter eta, U+03B7 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 952 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"theta\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter theta, U+03B8 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 953 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"iota\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter iota, U+03B9 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 954 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"kappa\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter kappa, U+03BA ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 955 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lambda\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter lambda, U+03BB ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 956 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"mu\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter mu, U+03BC ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 957 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"nu\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter nu, U+03BD ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 958 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"xi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter xi, U+03BE ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 959 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"omicron\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter omicron, U+03BF NEW\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 960 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"pi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter pi, U+03C0 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 961 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rho\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter rho, U+03C1 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 962 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sigmaf\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter final sigma, U+03C2 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 963 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sigma\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter sigma, U+03C3 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 964 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"tau\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter tau, U+03C4 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 965 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"upsilon\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter upsilon, U+03C5 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 966 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"phi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter phi, U+03C6 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 967 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"chi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter chi, U+03C7 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 968 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"psi\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter psi, U+03C8 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 969 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"omega\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter omega, U+03C9 ISOgrk3\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 977 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"thetasym\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek small letter theta symbol, U+03D1 NEW\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 978 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"upsih\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek upsilon with hook symbol, U+03D2 NEW\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 982 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"piv\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greek pi symbol, U+03D6 ISOgrk3\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8194 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ensp\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"en space, U+2002 ISOpub\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8195 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"emsp\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"em space, U+2003 ISOpub\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8201 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"thinsp\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"thin space, U+2009 ISOpub\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8204 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"zwnj\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"zero width non-joiner, U+200C NEW RFC 2070\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8205 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"zwj\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"zero width joiner, U+200D NEW RFC 2070\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8206 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lrm\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"left-to-right mark, U+200E NEW RFC 2070\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8207 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rlm\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"right-to-left mark, U+200F NEW RFC 2070\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8211 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ndash\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"en dash, U+2013 ISOpub\x00" as *const u8 as
                                     *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8212 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"mdash\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"em dash, U+2014 ISOpub\x00" as *const u8 as
                                     *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8216 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lsquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"left single quotation mark, U+2018 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8217 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rsquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"right single quotation mark, U+2019 ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8218 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sbquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"single low-9 quotation mark, U+201A NEW\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8220 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ldquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"left double quotation mark, U+201C ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8221 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rdquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"right double quotation mark, U+201D ISOnum\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8222 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"bdquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"double low-9 quotation mark, U+201E NEW\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8224 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"dagger\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"dagger, U+2020 ISOpub\x00" as *const u8 as
                                     *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8225 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Dagger\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"double dagger, U+2021 ISOpub\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8226 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"bull\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"bullet = black small circle, U+2022 ISOpub\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8230 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"hellip\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"horizontal ellipsis = three dot leader, U+2026 ISOpub\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8240 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"permil\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"per mille sign, U+2030 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8242 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"prime\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"prime = minutes = feet, U+2032 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8243 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"Prime\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"double prime = seconds = inches, U+2033 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8249 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lsaquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"single left-pointing angle quotation mark, U+2039 ISO proposed\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8250 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rsaquo\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"single right-pointing angle quotation mark, U+203A ISO proposed\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8254 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"oline\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"overline = spacing overscore, U+203E NEW\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8260 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"frasl\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"fraction slash, U+2044 NEW\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8364 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"euro\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"euro sign, U+20AC NEW\x00" as *const u8 as
                                     *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8465 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"image\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"blackletter capital I = imaginary part, U+2111 ISOamso\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8472 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"weierp\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"script capital P = power set = Weierstrass p, U+2118 ISOamso\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8476 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"real\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"blackletter capital R = real part symbol, U+211C ISOamso\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8482 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"trade\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"trade mark sign, U+2122 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8501 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"alefsym\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"alef symbol = first transfinite cardinal, U+2135 NEW\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8592 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"larr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"leftwards arrow, U+2190 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8593 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"uarr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"upwards arrow, U+2191 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8594 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rarr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"rightwards arrow, U+2192 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8595 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"darr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"downwards arrow, U+2193 ISOnum\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8596 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"harr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"left right arrow, U+2194 ISOamsa\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8629 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"crarr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"downwards arrow with corner leftwards = carriage return, U+21B5 NEW\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8656 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lArr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"leftwards double arrow, U+21D0 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8657 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"uArr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"upwards double arrow, U+21D1 ISOamsa\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8658 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rArr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"rightwards double arrow, U+21D2 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8659 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"dArr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"downwards double arrow, U+21D3 ISOamsa\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8660 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"hArr\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"left right double arrow, U+21D4 ISOamsa\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8704 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"forall\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"for all, U+2200 ISOtech\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8706 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"part\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"partial differential, U+2202 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8707 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"exist\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"there exists, U+2203 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8709 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"empty\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"empty set = null set = diameter, U+2205 ISOamso\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8711 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"nabla\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"nabla = backward difference, U+2207 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8712 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"isin\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"element of, U+2208 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8713 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"notin\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"not an element of, U+2209 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8715 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ni\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"contains as member, U+220B ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8719 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"prod\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"n-ary product = product sign, U+220F ISOamsb\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8721 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sum\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"n-ary summation, U+2211 ISOamsb\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8722 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"minus\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"minus sign, U+2212 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8727 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lowast\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"asterisk operator, U+2217 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8730 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"radic\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"square root = radical sign, U+221A ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8733 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"prop\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"proportional to, U+221D ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8734 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"infin\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"infinity, U+221E ISOtech\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8736 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ang\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"angle, U+2220 ISOamso\x00" as *const u8 as
                                     *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8743 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"and\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"logical and = wedge, U+2227 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8744 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"or\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"logical or = vee, U+2228 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8745 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"cap\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"intersection = cap, U+2229 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8746 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"cup\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"union = cup, U+222A ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8747 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"int\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"integral, U+222B ISOtech\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8756 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"there4\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"therefore, U+2234 ISOtech\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8764 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sim\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"tilde operator = varies with = similar to, U+223C ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8773 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"cong\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"approximately equal to, U+2245 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8776 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"asymp\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"almost equal to = asymptotic to, U+2248 ISOamsr\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8800 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ne\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"not equal to, U+2260 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8801 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"equiv\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"identical to, U+2261 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8804 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"le\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"less-than or equal to, U+2264 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8805 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"ge\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"greater-than or equal to, U+2265 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8834 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sub\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"subset of, U+2282 ISOtech\x00" as *const u8
                                     as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8835 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sup\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"superset of, U+2283 ISOtech\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8836 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"nsub\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"not a subset of, U+2284 ISOamsn\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8838 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sube\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"subset of or equal to, U+2286 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8839 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"supe\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"superset of or equal to, U+2287 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8853 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"oplus\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"circled plus = direct sum, U+2295 ISOamsb\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8855 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"otimes\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"circled times = vector product, U+2297 ISOamsb\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8869 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"perp\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"up tack = orthogonal to = perpendicular, U+22A5 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8901 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"sdot\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"dot operator, U+22C5 ISOamsb\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8968 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lceil\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"left ceiling = apl upstile, U+2308 ISOamsc\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8969 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rceil\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"right ceiling, U+2309 ISOamsc\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8970 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lfloor\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"left floor = apl downstile, U+230A ISOamsc\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 8971 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rfloor\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"right floor, U+230B ISOamsc\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 9001 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"lang\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"left-pointing angle bracket = bra, U+2329 ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 9002 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"rang\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"right-pointing angle bracket = ket, U+232A ISOtech\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 9674 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"loz\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"lozenge, U+25CA ISOpub\x00" as *const u8 as
                                     *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 9824 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"spades\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"black spade suit, U+2660 ISOpub\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 9827 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"clubs\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"black club suit = shamrock, U+2663 ISOpub\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 9829 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"hearts\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"black heart suit = valentine, U+2665 ISOpub\x00"
                                     as *const u8 as *const std::os::raw::c_char,};
         init
     },
     {
         let mut init =
             _htmlEntityDesc{value: 9830 as std::os::raw::c_int as std::os::raw::c_uint,
                             name:
                                 b"diams\x00" as *const u8 as
                                     *const std::os::raw::c_char,
                             desc:
                                 b"black diamond suit, U+2666 ISOpub\x00" as
                                     *const u8 as *const std::os::raw::c_char,};
         init
     }];
/* ***********************************************************************
 *									*
 *		Commodity functions to handle entities			*
 *									*
 ************************************************************************/
/*
 * Macro used to grow the current buffer.
 */
/* *
 * htmlEntityLookup:
 * @name: the entity name
 *
 * Lookup the given entity in EntitiesTable
 *
 * TODO: the linear scan is really ugly, an hash table is really needed.
 *
 * Returns the associated htmlEntityDescPtr if found, NULL otherwise.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlEntityLookup(mut name: *const xmlChar)
 -> *const htmlEntityDesc {
    let mut i: std::os::raw::c_uint = 0;
    i = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    while (i as std::os::raw::c_ulong) <
              (::std::mem::size_of::<[htmlEntityDesc; 253]>() as
                   std::os::raw::c_ulong).wrapping_div(::std::mem::size_of::<htmlEntityDesc>()
                                                   as std::os::raw::c_ulong) {
        if xmlStrEqual(name,
                       html40EntitiesTable[i as usize].name as *mut xmlChar)
               != 0 {
            return &*html40EntitiesTable.as_ptr().offset(i as isize) as
                       *const htmlEntityDesc as htmlEntityDescPtr as
                       *const htmlEntityDesc
        }
        i = i.wrapping_add(1)
    }
    return 0 as *const htmlEntityDesc;
}
/* *
 * htmlEntityValueLookup:
 * @value: the entity's unicode value
 *
 * Lookup the given entity in EntitiesTable
 *
 * TODO: the linear scan is really ugly, an hash table is really needed.
 *
 * Returns the associated htmlEntityDescPtr if found, NULL otherwise.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlEntityValueLookup(mut value: std::os::raw::c_uint)
 -> *const htmlEntityDesc {
    let mut i: std::os::raw::c_uint = 0;
    i = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    while (i as std::os::raw::c_ulong) <
              (::std::mem::size_of::<[htmlEntityDesc; 253]>() as
                   std::os::raw::c_ulong).wrapping_div(::std::mem::size_of::<htmlEntityDesc>()
                                                   as std::os::raw::c_ulong) {
        if html40EntitiesTable[i as usize].value >= value {
            if html40EntitiesTable[i as usize].value > value { break ; }
            return &*html40EntitiesTable.as_ptr().offset(i as isize) as
                       *const htmlEntityDesc as htmlEntityDescPtr as
                       *const htmlEntityDesc
        } else { i = i.wrapping_add(1) }
    }
    return 0 as *const htmlEntityDesc;
}
/* *
 * UTF8ToHtml:
 * @out:  a pointer to an array of bytes to store the result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of UTF-8 chars
 * @inlen:  the length of @in
 *
 * Take a block of UTF-8 chars in and try to convert it to an ASCII
 * plus HTML entities block of chars out.
 *
 * Returns 0 if success, -2 if the transcoding fails, or -1 otherwise
 * The value of @inlen after return is the number of octets consumed
 *     as the return value is positive, else unpredictable.
 * The value of @outlen after return is the number of octets consumed.
 */
#[no_mangle]
pub unsafe extern "C" fn UTF8ToHtml(mut out: *mut std::os::raw::c_uchar,
                                    mut outlen: *mut std::os::raw::c_int,
                                    mut in_0: *const std::os::raw::c_uchar,
                                    mut inlen: *mut std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut processed: *const std::os::raw::c_uchar = in_0;
    let mut outend: *const std::os::raw::c_uchar = 0 as *const std::os::raw::c_uchar;
    let mut outstart: *const std::os::raw::c_uchar = out;
    let mut instart: *const std::os::raw::c_uchar = in_0;
    let mut inend: *const std::os::raw::c_uchar = 0 as *const std::os::raw::c_uchar;
    let mut c: std::os::raw::c_uint = 0;
    let mut d: std::os::raw::c_uint = 0;
    let mut trailing: std::os::raw::c_int = 0;
    if out.is_null() || outlen.is_null() || inlen.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    if in_0.is_null() {
        /*
	 * initialization nothing to do
	 */
        *outlen = 0 as std::os::raw::c_int;
        *inlen = 0 as std::os::raw::c_int;
        return 0 as std::os::raw::c_int
    }
    inend = in_0.offset(*inlen as isize);
    outend = out.offset(*outlen as isize);
    while in_0 < inend {
        let fresh5 = in_0;
        in_0 = in_0.offset(1);
        d = *fresh5 as std::os::raw::c_uint;
        if d < 0x80 as std::os::raw::c_int as std::os::raw::c_uint {
            c = d;
            trailing = 0 as std::os::raw::c_int
        } else if d < 0xc0 as std::os::raw::c_int as std::os::raw::c_uint {
            /* trailing byte in leading position */
            *outlen =
                out.offset_from(outstart) as std::os::raw::c_long as
                    std::os::raw::c_int;
            *inlen =
                processed.offset_from(instart) as std::os::raw::c_long as
                    std::os::raw::c_int;
            return -(2 as std::os::raw::c_int)
        } else {
            if d < 0xe0 as std::os::raw::c_int as std::os::raw::c_uint {
                c = d & 0x1f as std::os::raw::c_int as std::os::raw::c_uint;
                trailing = 1 as std::os::raw::c_int
            } else if d < 0xf0 as std::os::raw::c_int as std::os::raw::c_uint {
                c = d & 0xf as std::os::raw::c_int as std::os::raw::c_uint;
                trailing = 2 as std::os::raw::c_int
            } else if d < 0xf8 as std::os::raw::c_int as std::os::raw::c_uint {
                c = d & 0x7 as std::os::raw::c_int as std::os::raw::c_uint;
                trailing = 3 as std::os::raw::c_int
            } else {
                /* no chance for this in Ascii */
                *outlen =
                    out.offset_from(outstart) as std::os::raw::c_long as
                        std::os::raw::c_int;
                *inlen =
                    processed.offset_from(instart) as std::os::raw::c_long as
                        std::os::raw::c_int;
                return -(2 as std::os::raw::c_int)
            }
        }
        if (inend.offset_from(in_0) as std::os::raw::c_long) <
               trailing as std::os::raw::c_long {
            break ;
        }
        while trailing != 0 {
            if in_0 >= inend ||
                   {
                       let fresh6 = in_0;
                       in_0 = in_0.offset(1);
                       d = *fresh6 as std::os::raw::c_uint;
                       (d & 0xc0 as std::os::raw::c_int as std::os::raw::c_uint) !=
                           0x80 as std::os::raw::c_int as std::os::raw::c_uint
                   } {
                break ;
            }
            c <<= 6 as std::os::raw::c_int;
            c |= d & 0x3f as std::os::raw::c_int as std::os::raw::c_uint;
            trailing -= 1
        }
        /* assertion: c is a single UTF-4 value */
        if c < 0x80 as std::os::raw::c_int as std::os::raw::c_uint {
            if out.offset(1 as std::os::raw::c_int as isize) >=
                   outend as *mut std::os::raw::c_uchar {
                break ;
            }
            let fresh7 = out;
            out = out.offset(1);
            *fresh7 = c as std::os::raw::c_uchar
        } else {
            let mut len: std::os::raw::c_int = 0;
            let mut ent: *const htmlEntityDesc = 0 as *const htmlEntityDesc;
            let mut cp: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
            let mut nbuf: [std::os::raw::c_char; 16] = [0; 16];
            /*
	     * Try to lookup a predefined HTML entity for it
	     */
            ent = htmlEntityValueLookup(c);
            if ent.is_null() {
                snprintf(nbuf.as_mut_ptr(),
                         ::std::mem::size_of::<[std::os::raw::c_char; 16]>() as
                             std::os::raw::c_ulong,
                         b"#%u\x00" as *const u8 as *const std::os::raw::c_char, c);
                cp = nbuf.as_mut_ptr()
            } else { cp = (*ent).name }
            len = strlen(cp) as std::os::raw::c_int;
            if out.offset(2 as std::os::raw::c_int as isize).offset(len as isize) >=
                   outend as *mut std::os::raw::c_uchar {
                break ;
            }
            let fresh8 = out;
            out = out.offset(1);
            *fresh8 = '&' as i32 as std::os::raw::c_uchar;
            memcpy(out as *mut std::os::raw::c_void, cp as *const std::os::raw::c_void,
                   len as std::os::raw::c_ulong);
            out = out.offset(len as isize);
            let fresh9 = out;
            out = out.offset(1);
            *fresh9 = ';' as i32 as std::os::raw::c_uchar
        }
        processed = in_0
    }
    *outlen =
        out.offset_from(outstart) as std::os::raw::c_long as std::os::raw::c_int;
    *inlen =
        processed.offset_from(instart) as std::os::raw::c_long as
            std::os::raw::c_int;
    return 0 as std::os::raw::c_int;
}
/* *
 * htmlEncodeEntities:
 * @out:  a pointer to an array of bytes to store the result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of UTF-8 chars
 * @inlen:  the length of @in
 * @quoteChar: the quote character to escape (' or ") or zero.
 *
 * Take a block of UTF-8 chars in and try to convert it to an ASCII
 * plus HTML entities block of chars out.
 *
 * Returns 0 if success, -2 if the transcoding fails, or -1 otherwise
 * The value of @inlen after return is the number of octets consumed
 *     as the return value is positive, else unpredictable.
 * The value of @outlen after return is the number of octets consumed.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlEncodeEntities(mut out: *mut std::os::raw::c_uchar,
                                            mut outlen: *mut std::os::raw::c_int,
                                            mut in_0: *const std::os::raw::c_uchar,
                                            mut inlen: *mut std::os::raw::c_int,
                                            mut quoteChar: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut processed: *const std::os::raw::c_uchar = in_0;
    let mut outend: *const std::os::raw::c_uchar = 0 as *const std::os::raw::c_uchar;
    let mut outstart: *const std::os::raw::c_uchar = out;
    let mut instart: *const std::os::raw::c_uchar = in_0;
    let mut inend: *const std::os::raw::c_uchar = 0 as *const std::os::raw::c_uchar;
    let mut c: std::os::raw::c_uint = 0;
    let mut d: std::os::raw::c_uint = 0;
    let mut trailing: std::os::raw::c_int = 0;
    if out.is_null() || outlen.is_null() || inlen.is_null() || in_0.is_null()
       {
        return -(1 as std::os::raw::c_int)
    }
    outend = out.offset(*outlen as isize);
    inend = in_0.offset(*inlen as isize);
    while in_0 < inend {
        let fresh10 = in_0;
        in_0 = in_0.offset(1);
        d = *fresh10 as std::os::raw::c_uint;
        if d < 0x80 as std::os::raw::c_int as std::os::raw::c_uint {
            c = d;
            trailing = 0 as std::os::raw::c_int
        } else if d < 0xc0 as std::os::raw::c_int as std::os::raw::c_uint {
            /* trailing byte in leading position */
            *outlen =
                out.offset_from(outstart) as std::os::raw::c_long as
                    std::os::raw::c_int;
            *inlen =
                processed.offset_from(instart) as std::os::raw::c_long as
                    std::os::raw::c_int;
            return -(2 as std::os::raw::c_int)
        } else {
            if d < 0xe0 as std::os::raw::c_int as std::os::raw::c_uint {
                c = d & 0x1f as std::os::raw::c_int as std::os::raw::c_uint;
                trailing = 1 as std::os::raw::c_int
            } else if d < 0xf0 as std::os::raw::c_int as std::os::raw::c_uint {
                c = d & 0xf as std::os::raw::c_int as std::os::raw::c_uint;
                trailing = 2 as std::os::raw::c_int
            } else if d < 0xf8 as std::os::raw::c_int as std::os::raw::c_uint {
                c = d & 0x7 as std::os::raw::c_int as std::os::raw::c_uint;
                trailing = 3 as std::os::raw::c_int
            } else {
                /* no chance for this in Ascii */
                *outlen =
                    out.offset_from(outstart) as std::os::raw::c_long as
                        std::os::raw::c_int;
                *inlen =
                    processed.offset_from(instart) as std::os::raw::c_long as
                        std::os::raw::c_int;
                return -(2 as std::os::raw::c_int)
            }
        }
        if (inend.offset_from(in_0) as std::os::raw::c_long) <
               trailing as std::os::raw::c_long {
            break ;
        }
        loop  {
            let fresh11 = trailing;
            trailing = trailing - 1;
            if !(fresh11 != 0) { break ; }
            let fresh12 = in_0;
            in_0 = in_0.offset(1);
            d = *fresh12 as std::os::raw::c_uint;
            if d & 0xc0 as std::os::raw::c_int as std::os::raw::c_uint !=
                   0x80 as std::os::raw::c_int as std::os::raw::c_uint {
                *outlen =
                    out.offset_from(outstart) as std::os::raw::c_long as
                        std::os::raw::c_int;
                *inlen =
                    processed.offset_from(instart) as std::os::raw::c_long as
                        std::os::raw::c_int;
                return -(2 as std::os::raw::c_int)
            }
            c <<= 6 as std::os::raw::c_int;
            c |= d & 0x3f as std::os::raw::c_int as std::os::raw::c_uint
        }
        /* assertion: c is a single UTF-4 value */
        if c < 0x80 as std::os::raw::c_int as std::os::raw::c_uint &&
               c != quoteChar as std::os::raw::c_uint &&
               c != '&' as i32 as std::os::raw::c_uint &&
               c != '<' as i32 as std::os::raw::c_uint &&
               c != '>' as i32 as std::os::raw::c_uint {
            if out >= outend as *mut std::os::raw::c_uchar { break ; }
            let fresh13 = out;
            out = out.offset(1);
            *fresh13 = c as std::os::raw::c_uchar
        } else {
            let mut ent: *const htmlEntityDesc = 0 as *const htmlEntityDesc;
            let mut cp: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
            let mut nbuf: [std::os::raw::c_char; 16] = [0; 16];
            let mut len: std::os::raw::c_int = 0;
            /*
	     * Try to lookup a predefined HTML entity for it
	     */
            ent = htmlEntityValueLookup(c);
            if ent.is_null() {
                snprintf(nbuf.as_mut_ptr(),
                         ::std::mem::size_of::<[std::os::raw::c_char; 16]>() as
                             std::os::raw::c_ulong,
                         b"#%u\x00" as *const u8 as *const std::os::raw::c_char, c);
                cp = nbuf.as_mut_ptr()
            } else { cp = (*ent).name }
            len = strlen(cp) as std::os::raw::c_int;
            if out.offset(2 as std::os::raw::c_int as isize).offset(len as isize) >
                   outend as *mut std::os::raw::c_uchar {
                break ;
            }
            let fresh14 = out;
            out = out.offset(1);
            *fresh14 = '&' as i32 as std::os::raw::c_uchar;
            memcpy(out as *mut std::os::raw::c_void, cp as *const std::os::raw::c_void,
                   len as std::os::raw::c_ulong);
            out = out.offset(len as isize);
            let fresh15 = out;
            out = out.offset(1);
            *fresh15 = ';' as i32 as std::os::raw::c_uchar
        }
        processed = in_0
    }
    *outlen =
        out.offset_from(outstart) as std::os::raw::c_long as std::os::raw::c_int;
    *inlen =
        processed.offset_from(instart) as std::os::raw::c_long as
            std::os::raw::c_int;
    return 0 as std::os::raw::c_int;
}
/* ***********************************************************************
 *									*
 *		Commodity functions to handle streams			*
 *									*
 ************************************************************************/
/* *
 * htmlNewInputStream:
 * @ctxt:  an HTML parser context
 *
 * Create a new input stream structure
 * Returns the new input stream or NULL
 */
unsafe extern "C" fn htmlNewInputStream(mut ctxt: htmlParserCtxtPtr)
 -> htmlParserInputPtr {
    let mut input: htmlParserInputPtr = 0 as *mut xmlParserInput;
    input =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<htmlParserInput>()
                                                          as std::os::raw::c_ulong) as
            xmlParserInputPtr;
    if input.is_null() {
        htmlErrMemory(ctxt,
                      b"couldn\'t allocate a new input stream\n\x00" as
                          *const u8 as *const std::os::raw::c_char);
        return 0 as htmlParserInputPtr
    }
    memset(input as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<htmlParserInput>() as std::os::raw::c_ulong);
    (*input).filename = 0 as *const std::os::raw::c_char;
    (*input).directory = 0 as *const std::os::raw::c_char;
    (*input).base = 0 as *const xmlChar;
    (*input).cur = 0 as *const xmlChar;
    (*input).buf = 0 as xmlParserInputBufferPtr;
    (*input).line = 1 as std::os::raw::c_int;
    (*input).col = 1 as std::os::raw::c_int;
    (*input).buf = 0 as xmlParserInputBufferPtr;
    (*input).free = None;
    (*input).version = 0 as *const xmlChar;
    (*input).consumed = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    (*input).length = 0 as std::os::raw::c_int;
    return input;
}
/* ***********************************************************************
 *									*
 *		Commodity functions, cleanup needed ?			*
 *									*
 ************************************************************************/
/*
 * all tags allowing pc data from the html 4.01 loose dtd
 * NOTE: it might be more apropriate to integrate this information
 * into the html40ElementTable array but I don't want to risk any
 * binary incomptibility
 */
static mut allowPCData: [*const std::os::raw::c_char; 53] =
    [b"a\x00" as *const u8 as *const std::os::raw::c_char,
     b"abbr\x00" as *const u8 as *const std::os::raw::c_char,
     b"acronym\x00" as *const u8 as *const std::os::raw::c_char,
     b"address\x00" as *const u8 as *const std::os::raw::c_char,
     b"applet\x00" as *const u8 as *const std::os::raw::c_char,
     b"b\x00" as *const u8 as *const std::os::raw::c_char,
     b"bdo\x00" as *const u8 as *const std::os::raw::c_char,
     b"big\x00" as *const u8 as *const std::os::raw::c_char,
     b"blockquote\x00" as *const u8 as *const std::os::raw::c_char,
     b"body\x00" as *const u8 as *const std::os::raw::c_char,
     b"button\x00" as *const u8 as *const std::os::raw::c_char,
     b"caption\x00" as *const u8 as *const std::os::raw::c_char,
     b"center\x00" as *const u8 as *const std::os::raw::c_char,
     b"cite\x00" as *const u8 as *const std::os::raw::c_char,
     b"code\x00" as *const u8 as *const std::os::raw::c_char,
     b"dd\x00" as *const u8 as *const std::os::raw::c_char,
     b"del\x00" as *const u8 as *const std::os::raw::c_char,
     b"dfn\x00" as *const u8 as *const std::os::raw::c_char,
     b"div\x00" as *const u8 as *const std::os::raw::c_char,
     b"dt\x00" as *const u8 as *const std::os::raw::c_char,
     b"em\x00" as *const u8 as *const std::os::raw::c_char,
     b"font\x00" as *const u8 as *const std::os::raw::c_char,
     b"form\x00" as *const u8 as *const std::os::raw::c_char,
     b"h1\x00" as *const u8 as *const std::os::raw::c_char,
     b"h2\x00" as *const u8 as *const std::os::raw::c_char,
     b"h3\x00" as *const u8 as *const std::os::raw::c_char,
     b"h4\x00" as *const u8 as *const std::os::raw::c_char,
     b"h5\x00" as *const u8 as *const std::os::raw::c_char,
     b"h6\x00" as *const u8 as *const std::os::raw::c_char,
     b"i\x00" as *const u8 as *const std::os::raw::c_char,
     b"iframe\x00" as *const u8 as *const std::os::raw::c_char,
     b"ins\x00" as *const u8 as *const std::os::raw::c_char,
     b"kbd\x00" as *const u8 as *const std::os::raw::c_char,
     b"label\x00" as *const u8 as *const std::os::raw::c_char,
     b"legend\x00" as *const u8 as *const std::os::raw::c_char,
     b"li\x00" as *const u8 as *const std::os::raw::c_char,
     b"noframes\x00" as *const u8 as *const std::os::raw::c_char,
     b"noscript\x00" as *const u8 as *const std::os::raw::c_char,
     b"object\x00" as *const u8 as *const std::os::raw::c_char,
     b"p\x00" as *const u8 as *const std::os::raw::c_char,
     b"pre\x00" as *const u8 as *const std::os::raw::c_char,
     b"q\x00" as *const u8 as *const std::os::raw::c_char,
     b"s\x00" as *const u8 as *const std::os::raw::c_char,
     b"samp\x00" as *const u8 as *const std::os::raw::c_char,
     b"small\x00" as *const u8 as *const std::os::raw::c_char,
     b"span\x00" as *const u8 as *const std::os::raw::c_char,
     b"strike\x00" as *const u8 as *const std::os::raw::c_char,
     b"strong\x00" as *const u8 as *const std::os::raw::c_char,
     b"td\x00" as *const u8 as *const std::os::raw::c_char,
     b"th\x00" as *const u8 as *const std::os::raw::c_char,
     b"tt\x00" as *const u8 as *const std::os::raw::c_char,
     b"u\x00" as *const u8 as *const std::os::raw::c_char,
     b"var\x00" as *const u8 as *const std::os::raw::c_char];
/* *
 * areBlanks:
 * @ctxt:  an HTML parser context
 * @str:  a xmlChar *
 * @len:  the size of @str
 *
 * Is this a sequence of blank chars that one can ignore ?
 *
 * Returns 1 if ignorable 0 otherwise.
 */
unsafe extern "C" fn areBlanks(mut ctxt: htmlParserCtxtPtr,
                               mut str: *const xmlChar, mut len: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut i: std::os::raw::c_uint = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut lastChild: xmlNodePtr = 0 as *mut xmlNode;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    j = 0 as std::os::raw::c_int;
    while j < len {
        if !(*str.offset(j as isize) as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                 0x9 as std::os::raw::c_int <= *str.offset(j as isize) as std::os::raw::c_int
                     &&
                     *str.offset(j as isize) as std::os::raw::c_int <=
                         0xa as std::os::raw::c_int ||
                 *str.offset(j as isize) as std::os::raw::c_int == 0xd as std::os::raw::c_int)
           {
            return 0 as std::os::raw::c_int
        }
        j += 1
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        return 1 as std::os::raw::c_int
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 {
        return 0 as std::os::raw::c_int
    }
    if (*ctxt).name.is_null() { return 1 as std::os::raw::c_int }
    if xmlStrEqual((*ctxt).name,
                   b"html\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        return 1 as std::os::raw::c_int
    }
    if xmlStrEqual((*ctxt).name,
                   b"head\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        return 1 as std::os::raw::c_int
    }
    /* Only strip CDATA children of the body tag for strict HTML DTDs */
    if xmlStrEqual((*ctxt).name,
                   b"body\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 && !(*ctxt).myDoc.is_null() {
        dtd = xmlGetIntSubset((*ctxt).myDoc as *const xmlDoc);
        if !dtd.is_null() && !(*dtd).ExternalID.is_null() {
            if xmlStrcasecmp((*dtd).ExternalID,
                             b"-//W3C//DTD HTML 4.01//EN\x00" as *const u8 as
                                 *const std::os::raw::c_char as *mut xmlChar) == 0 ||
                   xmlStrcasecmp((*dtd).ExternalID,
                                 b"-//W3C//DTD HTML 4//EN\x00" as *const u8 as
                                     *const std::os::raw::c_char as *mut xmlChar) == 0
               {
                return 1 as std::os::raw::c_int
            }
        }
    }
    if (*ctxt).node.is_null() { return 0 as std::os::raw::c_int }
    lastChild = xmlGetLastChild((*ctxt).node as *const xmlNode);
    while !lastChild.is_null() &&
              (*lastChild).type_0 as std::os::raw::c_uint ==
                  XML_COMMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        lastChild = (*lastChild).prev
    }
    if lastChild.is_null() {
        if (*(*ctxt).node).type_0 as std::os::raw::c_uint !=
               XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint &&
               !(*(*ctxt).node).content.is_null() {
            return 0 as std::os::raw::c_int
        }
        /* keep ws in constructs like ...<b> </b>...
	   for all tags "b" allowing PCDATA */
        i = 0 as std::os::raw::c_int as std::os::raw::c_uint;
        while (i as std::os::raw::c_ulong) <
                  (::std::mem::size_of::<[*const std::os::raw::c_char; 53]>() as
                       std::os::raw::c_ulong).wrapping_div(::std::mem::size_of::<*const std::os::raw::c_char>()
                                                       as std::os::raw::c_ulong) {
            if xmlStrEqual((*ctxt).name,
                           allowPCData[i as usize] as *mut xmlChar) != 0 {
                return 0 as std::os::raw::c_int
            }
            i = i.wrapping_add(1)
        }
    } else if xmlNodeIsText(lastChild as *const xmlNode) != 0 {
        return 0 as std::os::raw::c_int
    } else {
        /* keep ws in constructs like <p><b>xy</b> <i>z</i><p>
	   for all tags "p" allowing PCDATA */
        i = 0 as std::os::raw::c_int as std::os::raw::c_uint;
        while (i as std::os::raw::c_ulong) <
                  (::std::mem::size_of::<[*const std::os::raw::c_char; 53]>() as
                       std::os::raw::c_ulong).wrapping_div(::std::mem::size_of::<*const std::os::raw::c_char>()
                                                       as std::os::raw::c_ulong) {
            if xmlStrEqual((*lastChild).name,
                           allowPCData[i as usize] as *mut xmlChar) != 0 {
                return 0 as std::os::raw::c_int
            }
            i = i.wrapping_add(1)
        }
    }
    return 1 as std::os::raw::c_int;
}
/* *
 * htmlNewDocNoDtD:
 * @URI:  URI for the dtd, or NULL
 * @ExternalID:  the external ID of the DTD, or NULL
 *
 * Creates a new HTML document without a DTD node if @URI and @ExternalID
 * are NULL
 *
 * Returns a new document, do not initialize the DTD if not provided
 */
#[no_mangle]
pub unsafe extern "C" fn htmlNewDocNoDtD(mut URI: *const xmlChar,
                                         mut ExternalID: *const xmlChar)
 -> htmlDocPtr {
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    /*
     * Allocate a new document and fill the fields.
     */
    cur =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlDoc>()
                                                          as std::os::raw::c_ulong) as
            xmlDocPtr;
    if cur.is_null() {
        htmlErrMemory(0 as xmlParserCtxtPtr,
                      b"HTML document creation failed\n\x00" as *const u8 as
                          *const std::os::raw::c_char);
        return 0 as htmlDocPtr
    }
    memset(cur as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlDoc>() as std::os::raw::c_ulong);
    (*cur).type_0 = XML_HTML_DOCUMENT_NODE;
    (*cur).version = 0 as *const xmlChar;
    (*cur).intSubset = 0 as *mut _xmlDtd;
    (*cur).doc = cur;
    (*cur).name = 0 as *mut std::os::raw::c_char;
    (*cur).children = 0 as *mut _xmlNode;
    (*cur).extSubset = 0 as *mut _xmlDtd;
    (*cur).oldNs = 0 as *mut _xmlNs;
    (*cur).encoding = 0 as *const xmlChar;
    (*cur).standalone = 1 as std::os::raw::c_int;
    (*cur).compression = 0 as std::os::raw::c_int;
    (*cur).ids = 0 as *mut std::os::raw::c_void;
    (*cur).refs = 0 as *mut std::os::raw::c_void;
    (*cur)._private = 0 as *mut std::os::raw::c_void;
    (*cur).charset = XML_CHAR_ENCODING_UTF8 as std::os::raw::c_int;
    (*cur).properties =
        XML_DOC_HTML as std::os::raw::c_int | XML_DOC_USERBUILT as std::os::raw::c_int;
    if !ExternalID.is_null() || !URI.is_null() {
        xmlCreateIntSubset(cur,
                           b"html\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar, ExternalID, URI);
    }
    return cur;
}
/*
 * Summary: specific APIs to process HTML tree, especially serialization
 * Description: this module implements a few function needed to process
 *              tree in an HTML specific way.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * HTML_TEXT_NODE:
 *
 * Macro. A text node in a HTML document is really implemented
 * the same way as a text node in an XML document.
 */
/* *
 * HTML_ENTITY_REF_NODE:
 *
 * Macro. An entity reference in a HTML document is really implemented
 * the same way as an entity reference in an XML document.
 */
/* *
 * HTML_COMMENT_NODE:
 *
 * Macro. A comment in a HTML document is really implemented
 * the same way as a comment in an XML document.
 */
/* *
 * HTML_PRESERVE_NODE:
 *
 * Macro. A preserved node in a HTML document is really implemented
 * the same way as a CDATA section in an XML document.
 */
/* *
 * HTML_PI_NODE:
 *
 * Macro. A processing instruction in a HTML document is really implemented
 * the same way as a processing instruction in an XML document.
 */
/* *
 * htmlNewDoc:
 * @URI:  URI for the dtd, or NULL
 * @ExternalID:  the external ID of the DTD, or NULL
 *
 * Creates a new HTML document
 *
 * Returns a new document
 */
#[no_mangle]
pub unsafe extern "C" fn htmlNewDoc(mut URI: *const xmlChar,
                                    mut ExternalID: *const xmlChar)
 -> htmlDocPtr {
    if URI.is_null() && ExternalID.is_null() {
        return htmlNewDocNoDtD(b"http://www.w3.org/TR/REC-html40/loose.dtd\x00"
                                   as *const u8 as *const std::os::raw::c_char as
                                   *mut xmlChar,
                               b"-//W3C//DTD HTML 4.0 Transitional//EN\x00" as
                                   *const u8 as *const std::os::raw::c_char as
                                   *mut xmlChar)
    }
    return htmlNewDocNoDtD(URI, ExternalID);
}
/* *
 * htmlParseHTMLName:
 * @ctxt:  an HTML parser context
 *
 * parse an HTML tag or attribute name, note that we convert it to lowercase
 * since HTML names are not case-sensitive.
 *
 * Returns the Tag Name parsed or NULL
 */
unsafe extern "C" fn htmlParseHTMLName(mut ctxt: htmlParserCtxtPtr)
 -> *const xmlChar {
    let mut i: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut loc: [xmlChar; 100] = [0; 100];
    if !(0x41 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
             *(*(*ctxt).input).cur as std::os::raw::c_int <= 0x5a as std::os::raw::c_int ||
             0x61 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                 *(*(*ctxt).input).cur as std::os::raw::c_int <= 0x7a as std::os::raw::c_int)
           && *(*(*ctxt).input).cur as std::os::raw::c_int != '_' as i32 &&
           *(*(*ctxt).input).cur as std::os::raw::c_int != ':' as i32 &&
           *(*(*ctxt).input).cur as std::os::raw::c_int != '.' as i32 {
        return 0 as *const xmlChar
    }
    while i < 100 as std::os::raw::c_int &&
              (0x41 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= 0x5a as std::os::raw::c_int
                   ||
                   0x61 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int
                       &&
                       *(*(*ctxt).input).cur as std::os::raw::c_int <=
                           0x7a as std::os::raw::c_int ||
                   0x30 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int
                       &&
                       *(*(*ctxt).input).cur as std::os::raw::c_int <=
                           0x39 as std::os::raw::c_int ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == ':' as i32 ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == '-' as i32 ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == '_' as i32 ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == '.' as i32) {
        if *(*(*ctxt).input).cur as std::os::raw::c_int >= 'A' as i32 &&
               *(*(*ctxt).input).cur as std::os::raw::c_int <= 'Z' as i32 {
            loc[i as usize] =
                (*(*(*ctxt).input).cur as std::os::raw::c_int + 0x20 as std::os::raw::c_int)
                    as xmlChar
        } else {
            loc[i as usize] = *(*(*ctxt).input).cur as std::os::raw::c_int as xmlChar
        }
        i += 1;
        xmlNextChar(ctxt);
    }
    return xmlDictLookup((*ctxt).dict, loc.as_mut_ptr(), i);
}
/* *
 * htmlParseHTMLName_nonInvasive:
 * @ctxt:  an HTML parser context
 *
 * parse an HTML tag or attribute name, note that we convert it to lowercase
 * since HTML names are not case-sensitive, this doesn't consume the data
 * from the stream, it's a look-ahead
 *
 * Returns the Tag Name parsed or NULL
 */
unsafe extern "C" fn htmlParseHTMLName_nonInvasive(mut ctxt:
                                                       htmlParserCtxtPtr)
 -> *const xmlChar {
    let mut i: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut loc: [xmlChar; 100] = [0; 100];
    if !(0x41 as std::os::raw::c_int <=
             *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                 std::os::raw::c_int &&
             *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                 std::os::raw::c_int <= 0x5a as std::os::raw::c_int ||
             0x61 as std::os::raw::c_int <=
                 *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                     std::os::raw::c_int &&
                 *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                     std::os::raw::c_int <= 0x7a as std::os::raw::c_int) &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '_' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != ':' as i32 {
        return 0 as *const xmlChar
    }
    while i < 100 as std::os::raw::c_int &&
              (0x41 as std::os::raw::c_int <=
                   *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as
                                                    isize) as std::os::raw::c_int &&
                   *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as
                                                    isize) as std::os::raw::c_int <=
                       0x5a as std::os::raw::c_int ||
                   0x61 as std::os::raw::c_int <=
                       *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as
                                                        isize) as std::os::raw::c_int
                       &&
                       *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as
                                                        isize) as std::os::raw::c_int
                           <= 0x7a as std::os::raw::c_int ||
                   0x30 as std::os::raw::c_int <=
                       *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as
                                                        isize) as std::os::raw::c_int
                       &&
                       *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as
                                                        isize) as std::os::raw::c_int
                           <= 0x39 as std::os::raw::c_int ||
                   *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as
                                                    isize) as std::os::raw::c_int ==
                       ':' as i32 ||
                   *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as
                                                    isize) as std::os::raw::c_int ==
                       '-' as i32 ||
                   *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as
                                                    isize) as std::os::raw::c_int ==
                       '_' as i32) {
        if *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as isize) as
               std::os::raw::c_int >= 'A' as i32 &&
               *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as isize)
                   as std::os::raw::c_int <= 'Z' as i32 {
            loc[i as usize] =
                (*(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as isize)
                     as std::os::raw::c_int + 0x20 as std::os::raw::c_int) as xmlChar
        } else {
            loc[i as usize] =
                *(*(*ctxt).input).cur.offset((1 as std::os::raw::c_int + i) as isize)
        }
        i += 1
    }
    return xmlDictLookup((*ctxt).dict, loc.as_mut_ptr(), i);
}
/* *
 * htmlParseName:
 * @ctxt:  an HTML parser context
 *
 * parse an HTML name, this routine is case sensitive.
 *
 * Returns the Name parsed or NULL
 */
unsafe extern "C" fn htmlParseName(mut ctxt: htmlParserCtxtPtr)
 -> *const xmlChar {
    let mut in_0: *const xmlChar = 0 as *const xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    /*
     * Accelerator for simple ASCII names
     */
    in_0 = (*(*ctxt).input).cur;
    if *in_0 as std::os::raw::c_int >= 0x61 as std::os::raw::c_int &&
           *in_0 as std::os::raw::c_int <= 0x7a as std::os::raw::c_int ||
           *in_0 as std::os::raw::c_int >= 0x41 as std::os::raw::c_int &&
               *in_0 as std::os::raw::c_int <= 0x5a as std::os::raw::c_int ||
           *in_0 as std::os::raw::c_int == '_' as i32 ||
           *in_0 as std::os::raw::c_int == ':' as i32 {
        in_0 = in_0.offset(1);
        while *in_0 as std::os::raw::c_int >= 0x61 as std::os::raw::c_int &&
                  *in_0 as std::os::raw::c_int <= 0x7a as std::os::raw::c_int ||
                  *in_0 as std::os::raw::c_int >= 0x41 as std::os::raw::c_int &&
                      *in_0 as std::os::raw::c_int <= 0x5a as std::os::raw::c_int ||
                  *in_0 as std::os::raw::c_int >= 0x30 as std::os::raw::c_int &&
                      *in_0 as std::os::raw::c_int <= 0x39 as std::os::raw::c_int ||
                  *in_0 as std::os::raw::c_int == '_' as i32 ||
                  *in_0 as std::os::raw::c_int == '-' as i32 ||
                  *in_0 as std::os::raw::c_int == ':' as i32 ||
                  *in_0 as std::os::raw::c_int == '.' as i32 {
            in_0 = in_0.offset(1)
        }
        if in_0 == (*(*ctxt).input).end { return 0 as *const xmlChar }
        if *in_0 as std::os::raw::c_int > 0 as std::os::raw::c_int &&
               (*in_0 as std::os::raw::c_int) < 0x80 as std::os::raw::c_int {
            count =
                in_0.offset_from((*(*ctxt).input).cur) as
                    std::os::raw::c_long as std::os::raw::c_int;
            ret = xmlDictLookup((*ctxt).dict, (*(*ctxt).input).cur, count);
            (*(*ctxt).input).cur = in_0;
            (*ctxt).nbChars += count as std::os::raw::c_long;
            (*(*ctxt).input).col += count;
            return ret
        }
    }
    return htmlParseNameComplex(ctxt);
}
/* ***********************************************************************
 *									*
 *			The parser itself				*
 *	Relates to http://www.w3.org/TR/html40				*
 *									*
 ************************************************************************/
/* ***********************************************************************
 *									*
 *			The parser itself				*
 *									*
 ************************************************************************/
unsafe extern "C" fn htmlParseNameComplex(mut ctxt: xmlParserCtxtPtr)
 -> *const xmlChar {
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut l: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_int = 0;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut base: *const xmlChar = (*(*ctxt).input).base;
    /*
     * Handler for more complex cases
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    c = htmlCurrentChar(ctxt, &mut l);
    if c == ' ' as i32 || c == '>' as i32 || c == '/' as i32 ||
           !((if c < 0x100 as std::os::raw::c_int {
                  (0x41 as std::os::raw::c_int <= c && c <= 0x5a as std::os::raw::c_int ||
                       0x61 as std::os::raw::c_int <= c && c <= 0x7a as std::os::raw::c_int ||
                       0xc0 as std::os::raw::c_int <= c && c <= 0xd6 as std::os::raw::c_int ||
                       0xd8 as std::os::raw::c_int <= c && c <= 0xf6 as std::os::raw::c_int ||
                       0xf8 as std::os::raw::c_int <= c) as std::os::raw::c_int
              } else {
                  xmlCharInRange(c as std::os::raw::c_uint, &xmlIsBaseCharGroup)
              }) != 0 ||
                 (if c < 0x100 as std::os::raw::c_int {
                      0 as std::os::raw::c_int
                  } else {
                      (0x4e00 as std::os::raw::c_int <= c &&
                           c <= 0x9fa5 as std::os::raw::c_int ||
                           c == 0x3007 as std::os::raw::c_int ||
                           0x3021 as std::os::raw::c_int <= c &&
                               c <= 0x3029 as std::os::raw::c_int) as std::os::raw::c_int
                  }) != 0) && c != '_' as i32 && c != ':' as i32 {
        return 0 as *const xmlChar
    }
    while c != ' ' as i32 && c != '>' as i32 && c != '/' as i32 &&
              ((if c < 0x100 as std::os::raw::c_int {
                    (0x41 as std::os::raw::c_int <= c && c <= 0x5a as std::os::raw::c_int ||
                         0x61 as std::os::raw::c_int <= c && c <= 0x7a as std::os::raw::c_int
                         ||
                         0xc0 as std::os::raw::c_int <= c && c <= 0xd6 as std::os::raw::c_int
                         ||
                         0xd8 as std::os::raw::c_int <= c && c <= 0xf6 as std::os::raw::c_int
                         || 0xf8 as std::os::raw::c_int <= c) as std::os::raw::c_int
                } else {
                    xmlCharInRange(c as std::os::raw::c_uint, &xmlIsBaseCharGroup)
                }) != 0 ||
                   (if c < 0x100 as std::os::raw::c_int {
                        0 as std::os::raw::c_int
                    } else {
                        (0x4e00 as std::os::raw::c_int <= c &&
                             c <= 0x9fa5 as std::os::raw::c_int ||
                             c == 0x3007 as std::os::raw::c_int ||
                             0x3021 as std::os::raw::c_int <= c &&
                                 c <= 0x3029 as std::os::raw::c_int) as std::os::raw::c_int
                    }) != 0 ||
                   (if c < 0x100 as std::os::raw::c_int {
                        (0x30 as std::os::raw::c_int <= c && c <= 0x39 as std::os::raw::c_int)
                            as std::os::raw::c_int
                    } else {
                        xmlCharInRange(c as std::os::raw::c_uint, &xmlIsDigitGroup)
                    }) != 0 || c == '.' as i32 || c == '-' as i32 ||
                   c == '_' as i32 || c == ':' as i32 ||
                   (if c < 0x100 as std::os::raw::c_int {
                        0 as std::os::raw::c_int
                    } else {
                        xmlCharInRange(c as std::os::raw::c_uint,
                                       &xmlIsCombiningGroup)
                    }) != 0 ||
                   (if c < 0x100 as std::os::raw::c_int {
                        (c == 0xb7 as std::os::raw::c_int) as std::os::raw::c_int
                    } else {
                        xmlCharInRange(c as std::os::raw::c_uint, &xmlIsExtenderGroup)
                    }) != 0) {
        let fresh16 = count;
        count = count + 1;
        if fresh16 > 100 as std::os::raw::c_int {
            count = 0 as std::os::raw::c_int;
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
        }
        len += l;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*ctxt).token = 0 as std::os::raw::c_int;
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        (*ctxt).nbChars += 1;
        c = htmlCurrentChar(ctxt, &mut l);
        if (*(*ctxt).input).base != base {
            /*
	     * We changed encoding from an unknown encoding
	     * Input buffer changed location, so we better start again
	     */
            return htmlParseNameComplex(ctxt)
        }
    }
    if ((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
            std::os::raw::c_long) < len as std::os::raw::c_long {
        /* Sanity check */
        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                     b"unexpected change of input buffer\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        return 0 as *const xmlChar
    }
    return xmlDictLookup((*ctxt).dict,
                         (*(*ctxt).input).cur.offset(-(len as isize)), len);
}
/* *
 * htmlParseHTMLAttribute:
 * @ctxt:  an HTML parser context
 * @stop:  a char stop value
 *
 * parse an HTML attribute value till the stop (quote), if
 * stop is 0 then it stops at the first space
 *
 * Returns the attribute parsed or NULL
 */
unsafe extern "C" fn htmlParseHTMLAttribute(mut ctxt: htmlParserCtxtPtr,
                                            stop: xmlChar) -> *mut xmlChar {
    let mut buffer: *mut xmlChar = 0 as *mut xmlChar;
    let mut buffer_size: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut out: *mut xmlChar = 0 as *mut xmlChar;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut ent: *const htmlEntityDesc = 0 as *const htmlEntityDesc;
    /*
     * allocate a translation buffer.
     */
    buffer_size = 100 as std::os::raw::c_int;
    buffer =
        xmlMallocAtomic.expect("non-null function pointer")((buffer_size as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if buffer.is_null() {
        htmlErrMemory(ctxt,
                      b"buffer allocation failed\n\x00" as *const u8 as
                          *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    out = buffer;
    /*
     * Ok loop until we reach one of the ending chars
     */
    while *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int &&
              *(*(*ctxt).input).cur as std::os::raw::c_int != stop as std::os::raw::c_int {
        if stop as std::os::raw::c_int == 0 as std::os::raw::c_int &&
               *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
            break ;
        }
        if stop as std::os::raw::c_int == 0 as std::os::raw::c_int &&
               (*(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                    0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int
                        &&
                        *(*(*ctxt).input).cur as std::os::raw::c_int <=
                            0xa as std::os::raw::c_int ||
                    *(*(*ctxt).input).cur as std::os::raw::c_int ==
                        0xd as std::os::raw::c_int) {
            break ;
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '&' as i32 {
            if *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '#' as i32 {
                let mut c: std::os::raw::c_uint = 0;
                let mut bits: std::os::raw::c_int = 0;
                c = htmlParseCharRef(ctxt) as std::os::raw::c_uint;
                if c < 0x80 as std::os::raw::c_int as std::os::raw::c_uint {
                    let fresh17 = out;
                    out = out.offset(1);
                    *fresh17 = c as xmlChar;
                    bits = -(6 as std::os::raw::c_int)
                } else if c < 0x800 as std::os::raw::c_int as std::os::raw::c_uint {
                    let fresh18 = out;
                    out = out.offset(1);
                    *fresh18 =
                        (c >> 6 as std::os::raw::c_int &
                             0x1f as std::os::raw::c_int as std::os::raw::c_uint |
                             0xc0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                    bits = 0 as std::os::raw::c_int
                } else if c < 0x10000 as std::os::raw::c_int as std::os::raw::c_uint {
                    let fresh19 = out;
                    out = out.offset(1);
                    *fresh19 =
                        (c >> 12 as std::os::raw::c_int &
                             0xf as std::os::raw::c_int as std::os::raw::c_uint |
                             0xe0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                    bits = 6 as std::os::raw::c_int
                } else {
                    let fresh20 = out;
                    out = out.offset(1);
                    *fresh20 =
                        (c >> 18 as std::os::raw::c_int &
                             0x7 as std::os::raw::c_int as std::os::raw::c_uint |
                             0xf0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                    bits = 12 as std::os::raw::c_int
                }
                while bits >= 0 as std::os::raw::c_int {
                    let fresh21 = out;
                    out = out.offset(1);
                    *fresh21 =
                        (c >> bits & 0x3f as std::os::raw::c_int as std::os::raw::c_uint |
                             0x80 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                    bits -= 6 as std::os::raw::c_int
                }
                if out.offset_from(buffer) as std::os::raw::c_long >
                       (buffer_size - 100 as std::os::raw::c_int) as std::os::raw::c_long {
                    let mut indx: std::os::raw::c_int =
                        out.offset_from(buffer) as std::os::raw::c_long as
                            std::os::raw::c_int;
                    let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                    buffer_size *= 2 as std::os::raw::c_int;
                    tmp =
                        xmlRealloc.expect("non-null function pointer")(buffer
                                                                           as
                                                                           *mut std::os::raw::c_void,
                                                                       (buffer_size
                                                                            as
                                                                            std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                            as
                                                                                                            std::os::raw::c_ulong))
                            as *mut xmlChar;
                    if tmp.is_null() {
                        htmlErrMemory(ctxt,
                                      b"growing buffer\n\x00" as *const u8 as
                                          *const std::os::raw::c_char);
                        xmlFree.expect("non-null function pointer")(buffer as
                                                                        *mut std::os::raw::c_void);
                        return 0 as *mut xmlChar
                    }
                    buffer = tmp;
                    out = &mut *buffer.offset(indx as isize) as *mut xmlChar
                }
            } else {
                ent = htmlParseEntityRef(ctxt, &mut name);
                if name.is_null() {
                    let fresh22 = out;
                    out = out.offset(1);
                    *fresh22 = '&' as i32 as xmlChar;
                    if out.offset_from(buffer) as std::os::raw::c_long >
                           (buffer_size - 100 as std::os::raw::c_int) as std::os::raw::c_long
                       {
                        let mut indx_0: std::os::raw::c_int =
                            out.offset_from(buffer) as std::os::raw::c_long
                                as std::os::raw::c_int;
                        let mut tmp_0: *mut xmlChar = 0 as *mut xmlChar;
                        buffer_size *= 2 as std::os::raw::c_int;
                        tmp_0 =
                            xmlRealloc.expect("non-null function pointer")(buffer
                                                                               as
                                                                               *mut std::os::raw::c_void,
                                                                           (buffer_size
                                                                                as
                                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                                as
                                                                                                                std::os::raw::c_ulong))
                                as *mut xmlChar;
                        if tmp_0.is_null() {
                            htmlErrMemory(ctxt,
                                          b"growing buffer\n\x00" as *const u8
                                              as *const std::os::raw::c_char);
                            xmlFree.expect("non-null function pointer")(buffer
                                                                            as
                                                                            *mut std::os::raw::c_void);
                            return 0 as *mut xmlChar
                        }
                        buffer = tmp_0;
                        out =
                            &mut *buffer.offset(indx_0 as isize) as
                                *mut xmlChar
                    }
                } else if ent.is_null() {
                    let fresh23 = out;
                    out = out.offset(1);
                    *fresh23 = '&' as i32 as xmlChar;
                    cur = name;
                    while *cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
                        if out.offset_from(buffer) as std::os::raw::c_long >
                               (buffer_size - 100 as std::os::raw::c_int) as
                                   std::os::raw::c_long {
                            let mut indx_1: std::os::raw::c_int =
                                out.offset_from(buffer) as
                                    std::os::raw::c_long as std::os::raw::c_int;
                            let mut tmp_1: *mut xmlChar = 0 as *mut xmlChar;
                            buffer_size *= 2 as std::os::raw::c_int;
                            tmp_1 =
                                xmlRealloc.expect("non-null function pointer")(buffer
                                                                                   as
                                                                                   *mut std::os::raw::c_void,
                                                                               (buffer_size
                                                                                    as
                                                                                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                                    as
                                                                                                                    std::os::raw::c_ulong))
                                    as *mut xmlChar;
                            if tmp_1.is_null() {
                                htmlErrMemory(ctxt,
                                              b"growing buffer\n\x00" as
                                                  *const u8 as
                                                  *const std::os::raw::c_char);
                                xmlFree.expect("non-null function pointer")(buffer
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                return 0 as *mut xmlChar
                            }
                            buffer = tmp_1;
                            out =
                                &mut *buffer.offset(indx_1 as isize) as
                                    *mut xmlChar
                        }
                        let fresh24 = cur;
                        cur = cur.offset(1);
                        let fresh25 = out;
                        out = out.offset(1);
                        *fresh25 = *fresh24
                    }
                } else {
                    let mut c_0: std::os::raw::c_uint = 0;
                    let mut bits_0: std::os::raw::c_int = 0;
                    if out.offset_from(buffer) as std::os::raw::c_long >
                           (buffer_size - 100 as std::os::raw::c_int) as std::os::raw::c_long
                       {
                        let mut indx_2: std::os::raw::c_int =
                            out.offset_from(buffer) as std::os::raw::c_long
                                as std::os::raw::c_int;
                        let mut tmp_2: *mut xmlChar = 0 as *mut xmlChar;
                        buffer_size *= 2 as std::os::raw::c_int;
                        tmp_2 =
                            xmlRealloc.expect("non-null function pointer")(buffer
                                                                               as
                                                                               *mut std::os::raw::c_void,
                                                                           (buffer_size
                                                                                as
                                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                                as
                                                                                                                std::os::raw::c_ulong))
                                as *mut xmlChar;
                        if tmp_2.is_null() {
                            htmlErrMemory(ctxt,
                                          b"growing buffer\n\x00" as *const u8
                                              as *const std::os::raw::c_char);
                            xmlFree.expect("non-null function pointer")(buffer
                                                                            as
                                                                            *mut std::os::raw::c_void);
                            return 0 as *mut xmlChar
                        }
                        buffer = tmp_2;
                        out =
                            &mut *buffer.offset(indx_2 as isize) as
                                *mut xmlChar
                    }
                    c_0 = (*ent).value;
                    if c_0 < 0x80 as std::os::raw::c_int as std::os::raw::c_uint {
                        let fresh26 = out;
                        out = out.offset(1);
                        *fresh26 = c_0 as xmlChar;
                        bits_0 = -(6 as std::os::raw::c_int)
                    } else if c_0 < 0x800 as std::os::raw::c_int as std::os::raw::c_uint {
                        let fresh27 = out;
                        out = out.offset(1);
                        *fresh27 =
                            (c_0 >> 6 as std::os::raw::c_int &
                                 0x1f as std::os::raw::c_int as std::os::raw::c_uint |
                                 0xc0 as std::os::raw::c_int as std::os::raw::c_uint) as
                                xmlChar;
                        bits_0 = 0 as std::os::raw::c_int
                    } else if c_0 < 0x10000 as std::os::raw::c_int as std::os::raw::c_uint {
                        let fresh28 = out;
                        out = out.offset(1);
                        *fresh28 =
                            (c_0 >> 12 as std::os::raw::c_int &
                                 0xf as std::os::raw::c_int as std::os::raw::c_uint |
                                 0xe0 as std::os::raw::c_int as std::os::raw::c_uint) as
                                xmlChar;
                        bits_0 = 6 as std::os::raw::c_int
                    } else {
                        let fresh29 = out;
                        out = out.offset(1);
                        *fresh29 =
                            (c_0 >> 18 as std::os::raw::c_int &
                                 0x7 as std::os::raw::c_int as std::os::raw::c_uint |
                                 0xf0 as std::os::raw::c_int as std::os::raw::c_uint) as
                                xmlChar;
                        bits_0 = 12 as std::os::raw::c_int
                    }
                    while bits_0 >= 0 as std::os::raw::c_int {
                        let fresh30 = out;
                        out = out.offset(1);
                        *fresh30 =
                            (c_0 >> bits_0 &
                                 0x3f as std::os::raw::c_int as std::os::raw::c_uint |
                                 0x80 as std::os::raw::c_int as std::os::raw::c_uint) as
                                xmlChar;
                        bits_0 -= 6 as std::os::raw::c_int
                    }
                }
            }
        } else {
            let mut c_1: std::os::raw::c_uint = 0;
            let mut bits_1: std::os::raw::c_int = 0;
            let mut l: std::os::raw::c_int = 0;
            if out.offset_from(buffer) as std::os::raw::c_long >
                   (buffer_size - 100 as std::os::raw::c_int) as std::os::raw::c_long {
                let mut indx_3: std::os::raw::c_int =
                    out.offset_from(buffer) as std::os::raw::c_long as
                        std::os::raw::c_int;
                let mut tmp_3: *mut xmlChar = 0 as *mut xmlChar;
                buffer_size *= 2 as std::os::raw::c_int;
                tmp_3 =
                    xmlRealloc.expect("non-null function pointer")(buffer as
                                                                       *mut std::os::raw::c_void,
                                                                   (buffer_size
                                                                        as
                                                                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                        as
                                                                                                        std::os::raw::c_ulong))
                        as *mut xmlChar;
                if tmp_3.is_null() {
                    htmlErrMemory(ctxt,
                                  b"growing buffer\n\x00" as *const u8 as
                                      *const std::os::raw::c_char);
                    xmlFree.expect("non-null function pointer")(buffer as
                                                                    *mut std::os::raw::c_void);
                    return 0 as *mut xmlChar
                }
                buffer = tmp_3;
                out = &mut *buffer.offset(indx_3 as isize) as *mut xmlChar
            }
            c_1 = htmlCurrentChar(ctxt, &mut l) as std::os::raw::c_uint;
            if c_1 < 0x80 as std::os::raw::c_int as std::os::raw::c_uint {
                let fresh31 = out;
                out = out.offset(1);
                *fresh31 = c_1 as xmlChar;
                bits_1 = -(6 as std::os::raw::c_int)
            } else if c_1 < 0x800 as std::os::raw::c_int as std::os::raw::c_uint {
                let fresh32 = out;
                out = out.offset(1);
                *fresh32 =
                    (c_1 >> 6 as std::os::raw::c_int &
                         0x1f as std::os::raw::c_int as std::os::raw::c_uint |
                         0xc0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                bits_1 = 0 as std::os::raw::c_int
            } else if c_1 < 0x10000 as std::os::raw::c_int as std::os::raw::c_uint {
                let fresh33 = out;
                out = out.offset(1);
                *fresh33 =
                    (c_1 >> 12 as std::os::raw::c_int &
                         0xf as std::os::raw::c_int as std::os::raw::c_uint |
                         0xe0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                bits_1 = 6 as std::os::raw::c_int
            } else {
                let fresh34 = out;
                out = out.offset(1);
                *fresh34 =
                    (c_1 >> 18 as std::os::raw::c_int &
                         0x7 as std::os::raw::c_int as std::os::raw::c_uint |
                         0xf0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                bits_1 = 12 as std::os::raw::c_int
            }
            while bits_1 >= 0 as std::os::raw::c_int {
                let fresh35 = out;
                out = out.offset(1);
                *fresh35 =
                    (c_1 >> bits_1 & 0x3f as std::os::raw::c_int as std::os::raw::c_uint |
                         0x80 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                bits_1 -= 6 as std::os::raw::c_int
            }
            xmlNextChar(ctxt);
        }
    }
    *out = 0 as std::os::raw::c_int as xmlChar;
    return buffer;
}
/* *
 * htmlParseEntityRef:
 * @ctxt:  an HTML parser context
 * @str:  location to store the entity name
 *
 * parse an HTML ENTITY references
 *
 * [68] EntityRef ::= '&' Name ';'
 *
 * Returns the associated htmlEntityDescPtr if found, or NULL otherwise,
 *         if non-NULL *str will have to be freed by the caller.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlParseEntityRef(mut ctxt: htmlParserCtxtPtr,
                                            mut str: *mut *const xmlChar)
 -> *const htmlEntityDesc {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ent: *const htmlEntityDesc = 0 as *const htmlEntityDesc;
    if !str.is_null() { *str = 0 as *const xmlChar }
    if ctxt.is_null() || (*ctxt).input.is_null() {
        return 0 as *const htmlEntityDesc
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '&' as i32 {
        xmlNextChar(ctxt);
        name = htmlParseName(ctxt);
        if name.is_null() {
            htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
                         b"htmlParseEntityRef: no name\n\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        } else {
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int == ';' as i32 {
                if !str.is_null() { *str = name }
                /*
		 * Lookup the entity in the table.
		 */
                ent = htmlEntityLookup(name);
                if !ent.is_null() {
                    /* OK that's ugly !!! */
                    xmlNextChar(ctxt);
                }
            } else {
                htmlParseErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING,
                             b"htmlParseEntityRef: expecting \';\'\n\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             0 as *const xmlChar, 0 as *const xmlChar);
                if !str.is_null() { *str = name }
            }
        }
    }
    return ent;
}
/* *
 * htmlParseAttValue:
 * @ctxt:  an HTML parser context
 *
 * parse a value for an attribute
 * Note: the parser won't do substitution of entities here, this
 * will be handled later in xmlStringGetNodeList, unless it was
 * asked for ctxt->replaceEntities != 0
 *
 * Returns the AttValue parsed or NULL.
 */
unsafe extern "C" fn htmlParseAttValue(mut ctxt: htmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 {
        xmlNextChar(ctxt);
        ret = htmlParseHTMLAttribute(ctxt, '\"' as i32 as xmlChar);
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '\"' as i32 {
            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                         b"AttValue: \" expected\n\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        } else { xmlNextChar(ctxt); }
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
        xmlNextChar(ctxt);
        ret = htmlParseHTMLAttribute(ctxt, '\'' as i32 as xmlChar);
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '\'' as i32 {
            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                         b"AttValue: \' expected\n\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        } else { xmlNextChar(ctxt); }
    } else {
        /*
	 * That's an HTMLism, the attribute value may not be quoted
	 */
        ret = htmlParseHTMLAttribute(ctxt, 0 as std::os::raw::c_int as xmlChar);
        if ret.is_null() {
            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
                         b"AttValue: no value found\n\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        }
    }
    return ret;
}
/* *
 * htmlParseSystemLiteral:
 * @ctxt:  an HTML parser context
 *
 * parse an HTML Literal
 *
 * [11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'")
 *
 * Returns the SystemLiteral parsed or NULL
 */
unsafe extern "C" fn htmlParseSystemLiteral(mut ctxt: htmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut len: size_t = 0 as std::os::raw::c_int as size_t;
    let mut startPosition: size_t = 0 as std::os::raw::c_int as size_t;
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 {
        xmlNextChar(ctxt);
        if (*(*ctxt).input).cur < (*(*ctxt).input).base { return ret }
        startPosition =
            (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                as std::os::raw::c_long as size_t;
        while (0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int
                   ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int
                   ||
                   0x20 as std::os::raw::c_int <=
                       *(*(*ctxt).input).cur as std::os::raw::c_int) &&
                  *(*(*ctxt).input).cur as std::os::raw::c_int != '\"' as i32 {
            xmlNextChar(ctxt);
            len = len.wrapping_add(1)
        }
        if !(0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                 *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                 *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
                 0x20 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int)
           {
            htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
                         b"Unfinished SystemLiteral\n\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        } else {
            ret =
                xmlStrndup((*(*ctxt).input).base.offset(startPosition as
                                                            isize),
                           len as std::os::raw::c_int);
            xmlNextChar(ctxt);
        }
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
        xmlNextChar(ctxt);
        if (*(*ctxt).input).cur < (*(*ctxt).input).base { return ret }
        startPosition =
            (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                as std::os::raw::c_long as size_t;
        while (0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int
                   ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int
                   ||
                   0x20 as std::os::raw::c_int <=
                       *(*(*ctxt).input).cur as std::os::raw::c_int) &&
                  *(*(*ctxt).input).cur as std::os::raw::c_int != '\'' as i32 {
            xmlNextChar(ctxt);
            len = len.wrapping_add(1)
        }
        if !(0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                 *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                 *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
                 0x20 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int)
           {
            htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
                         b"Unfinished SystemLiteral\n\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        } else {
            ret =
                xmlStrndup((*(*ctxt).input).base.offset(startPosition as
                                                            isize),
                           len as std::os::raw::c_int);
            xmlNextChar(ctxt);
        }
    } else {
        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
                     b" or \' expected\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
    }
    return ret;
}
/* *
 * htmlParsePubidLiteral:
 * @ctxt:  an HTML parser context
 *
 * parse an HTML public literal
 *
 * [12] PubidLiteral ::= '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
 *
 * Returns the PubidLiteral parsed or NULL.
 */
unsafe extern "C" fn htmlParsePubidLiteral(mut ctxt: htmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut len: size_t = 0 as std::os::raw::c_int as size_t;
    let mut startPosition: size_t = 0 as std::os::raw::c_int as size_t;
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    /*
     * Name ::= (Letter | '_') (NameChar)*
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 {
        xmlNextChar(ctxt);
        if (*(*ctxt).input).cur < (*(*ctxt).input).base { return ret }
        startPosition =
            (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                as std::os::raw::c_long as size_t;
        while xmlIsPubidChar_tab[*(*(*ctxt).input).cur as std::os::raw::c_int as
                                     usize] != 0 {
            len = len.wrapping_add(1);
            xmlNextChar(ctxt);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '\"' as i32 {
            htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
                         b"Unfinished PubidLiteral\n\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        } else {
            ret =
                xmlStrndup((*(*ctxt).input).base.offset(startPosition as
                                                            isize),
                           len as std::os::raw::c_int);
            xmlNextChar(ctxt);
        }
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
        xmlNextChar(ctxt);
        if (*(*ctxt).input).cur < (*(*ctxt).input).base { return ret }
        startPosition =
            (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                as std::os::raw::c_long as size_t;
        while xmlIsPubidChar_tab[*(*(*ctxt).input).cur as std::os::raw::c_int as
                                     usize] as std::os::raw::c_int != 0 &&
                  *(*(*ctxt).input).cur as std::os::raw::c_int != '\'' as i32 {
            len = len.wrapping_add(1);
            xmlNextChar(ctxt);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '\'' as i32 {
            htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
                         b"Unfinished PubidLiteral\n\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        } else {
            ret =
                xmlStrndup((*(*ctxt).input).base.offset(startPosition as
                                                            isize),
                           len as std::os::raw::c_int);
            xmlNextChar(ctxt);
        }
    } else {
        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
                     b"PubidLiteral \" or \' expected\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
    }
    return ret;
}
/* *
 * htmlParseScript:
 * @ctxt:  an HTML parser context
 *
 * parse the content of an HTML SCRIPT or STYLE element
 * http://www.w3.org/TR/html4/sgml/dtd.html#Script
 * http://www.w3.org/TR/html4/sgml/dtd.html#StyleSheet
 * http://www.w3.org/TR/html4/types.html#type-script
 * http://www.w3.org/TR/html4/types.html#h-6.15
 * http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.2.1
 *
 * Script data ( %Script; in the DTD) can be the content of the SCRIPT
 * element and the value of intrinsic event attributes. User agents must
 * not evaluate script data as HTML markup but instead must pass it on as
 * data to a script engine.
 * NOTES:
 * - The content is passed like CDATA
 * - the attributes for style and scripting "onXXX" are also described
 *   as CDATA but SGML allows entities references in attributes so their
 *   processing is identical as other attributes
 */
unsafe extern "C" fn htmlParseScript(mut ctxt: htmlParserCtxtPtr) {
    let mut buf: [xmlChar; 1005] = [0; 1005];
    let mut nbchar: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut cur: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    if (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
           std::os::raw::c_long >
           (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlParserInputShrink((*ctxt).input);
    }
    cur = htmlCurrentChar(ctxt, &mut l);
    while 0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int ||
              cur == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= cur {
        if cur == '<' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '/' as i32 {
            /*
             * One should break here, the specification is clear:
             * Authors should therefore escape "</" within the content.
             * Escape mechanisms are specific to each scripting or
             * style sheet language.
             *
             * In recovery mode, only break if end tag match the
             * current tag, effectively ignoring all tags inside the
             * script/style block and treating the entire block as
             * CDATA.
             */
            if (*ctxt).recovery != 0 {
                if xmlStrncasecmp((*ctxt).name,
                                  (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int
                                                                  as isize),
                                  xmlStrlen((*ctxt).name)) == 0 as std::os::raw::c_int
                   {
                    break ;
                    /* while */
                } else {
                    htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
                                 b"Element %s embeds close tag\n\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 (*ctxt).name, 0 as *const xmlChar);
                }
            } else if *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize)
                          as std::os::raw::c_int >= 'A' as i32 &&
                          *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                           isize) as
                              std::os::raw::c_int <= 'Z' as i32 ||
                          *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                           isize) as
                              std::os::raw::c_int >= 'a' as i32 &&
                              *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int <= 'z' as i32 {
                break ;
            }
        }
        if l == 1 as std::os::raw::c_int {
            let fresh36 = nbchar;
            nbchar = nbchar + 1;
            buf[fresh36 as usize] = cur as xmlChar
        } else {
            nbchar +=
                xmlCopyChar(l, &mut *buf.as_mut_ptr().offset(nbchar as isize),
                            cur)
        }
        if nbchar >= 1000 as std::os::raw::c_int {
            if (*(*ctxt).sax).cdataBlock.is_some() {
                /*
		 * Insert as CDATA, which is the same as HTML_PRESERVE_NODE
		 */
                (*(*ctxt).sax).cdataBlock.expect("non-null function pointer")((*ctxt).userData,
                                                                              buf.as_mut_ptr(),
                                                                              nbchar);
            } else if (*(*ctxt).sax).characters.is_some() {
                (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                              buf.as_mut_ptr(),
                                                                              nbchar);
            }
            nbchar = 0 as std::os::raw::c_int
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*ctxt).token = 0 as std::os::raw::c_int;
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        (*ctxt).nbChars += 1;
        cur = htmlCurrentChar(ctxt, &mut l)
    }
    if !(0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int ||
             cur == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= cur) &&
           !(cur == 0 as std::os::raw::c_int && (*ctxt).progressive != 0) {
        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                        b"Invalid char in CDATA 0x%X\n\x00" as *const u8 as
                            *const std::os::raw::c_char, cur);
        if (*(*ctxt).input).cur < (*(*ctxt).input).end { xmlNextChar(ctxt); }
    }
    if nbchar != 0 as std::os::raw::c_int && !(*ctxt).sax.is_null() &&
           (*ctxt).disableSAX == 0 {
        if (*(*ctxt).sax).cdataBlock.is_some() {
            /*
	     * Insert as CDATA, which is the same as HTML_PRESERVE_NODE
	     */
            (*(*ctxt).sax).cdataBlock.expect("non-null function pointer")((*ctxt).userData,
                                                                          buf.as_mut_ptr(),
                                                                          nbchar);
        } else if (*(*ctxt).sax).characters.is_some() {
            (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                          buf.as_mut_ptr(),
                                                                          nbchar);
        }
    };
}
/* *
 * htmlParseCharDataInternal:
 * @ctxt:  an HTML parser context
 * @readahead: optional read ahead character in ascii range
 *
 * parse a CharData section.
 * if we are within a CDATA section ']]>' marks an end of section.
 *
 * [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
 */
unsafe extern "C" fn htmlParseCharDataInternal(mut ctxt: htmlParserCtxtPtr,
                                               mut readahead: std::os::raw::c_int) {
    let mut buf: [xmlChar; 1006] = [0; 1006];
    let mut nbchar: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut cur: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut chunk: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if readahead != 0 {
        let fresh37 = nbchar;
        nbchar = nbchar + 1;
        buf[fresh37 as usize] = readahead as xmlChar
    }
    if (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
           std::os::raw::c_long >
           (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlParserInputShrink((*ctxt).input);
    }
    cur = htmlCurrentChar(ctxt, &mut l);
    while (cur != '<' as i32 || (*ctxt).token == '<' as i32) &&
              (cur != '&' as i32 || (*ctxt).token == '&' as i32) &&
              cur != 0 as std::os::raw::c_int {
        if if cur < 0x100 as std::os::raw::c_int {
               (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int ||
                    cur == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= cur)
                   as std::os::raw::c_int
           } else {
               (0x100 as std::os::raw::c_int <= cur && cur <= 0xd7ff as std::os::raw::c_int ||
                    0xe000 as std::os::raw::c_int <= cur &&
                        cur <= 0xfffd as std::os::raw::c_int ||
                    0x10000 as std::os::raw::c_int <= cur &&
                        cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
           } == 0 {
            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                            b"Invalid char in CDATA 0x%X\n\x00" as *const u8
                                as *const std::os::raw::c_char, cur);
        } else if l == 1 as std::os::raw::c_int {
            let fresh38 = nbchar;
            nbchar = nbchar + 1;
            buf[fresh38 as usize] = cur as xmlChar
        } else {
            nbchar +=
                xmlCopyChar(l, &mut *buf.as_mut_ptr().offset(nbchar as isize),
                            cur)
        }
        if nbchar >= 1000 as std::os::raw::c_int {
            /*
	     * Ok the segment is to be consumed as chars.
	     */
            if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 {
                if areBlanks(ctxt, buf.as_mut_ptr(), nbchar) != 0 {
                    if (*ctxt).keepBlanks != 0 {
                        if (*(*ctxt).sax).characters.is_some() {
                            (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                          buf.as_mut_ptr(),
                                                                                          nbchar);
                        }
                    } else if (*(*ctxt).sax).ignorableWhitespace.is_some() {
                        (*(*ctxt).sax).ignorableWhitespace.expect("non-null function pointer")((*ctxt).userData,
                                                                                               buf.as_mut_ptr(),
                                                                                               nbchar);
                    }
                } else {
                    htmlCheckParagraph(ctxt);
                    if (*(*ctxt).sax).characters.is_some() {
                        (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                      buf.as_mut_ptr(),
                                                                                      nbchar);
                    }
                }
            }
            nbchar = 0 as std::os::raw::c_int
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*ctxt).token = 0 as std::os::raw::c_int;
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        (*ctxt).nbChars += 1;
        chunk += 1;
        if chunk > 100 as std::os::raw::c_int {
            chunk = 0 as std::os::raw::c_int;
            if (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                   as std::os::raw::c_long >
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) <
                       (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long
               {
                xmlParserInputShrink((*ctxt).input);
            }
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
        }
        cur = htmlCurrentChar(ctxt, &mut l);
        if cur == 0 as std::os::raw::c_int {
            if (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                   as std::os::raw::c_long >
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) <
                       (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long
               {
                xmlParserInputShrink((*ctxt).input);
            }
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
            cur = htmlCurrentChar(ctxt, &mut l)
        }
    }
    if nbchar != 0 as std::os::raw::c_int {
        buf[nbchar as usize] = 0 as std::os::raw::c_int as xmlChar;
        /*
	 * Ok the segment is to be consumed as chars.
	 */
        if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 {
            if areBlanks(ctxt, buf.as_mut_ptr(), nbchar) != 0 {
                if (*ctxt).keepBlanks != 0 {
                    if (*(*ctxt).sax).characters.is_some() {
                        (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                      buf.as_mut_ptr(),
                                                                                      nbchar);
                    }
                } else if (*(*ctxt).sax).ignorableWhitespace.is_some() {
                    (*(*ctxt).sax).ignorableWhitespace.expect("non-null function pointer")((*ctxt).userData,
                                                                                           buf.as_mut_ptr(),
                                                                                           nbchar);
                }
            } else {
                htmlCheckParagraph(ctxt);
                if (*(*ctxt).sax).characters.is_some() {
                    (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                  buf.as_mut_ptr(),
                                                                                  nbchar);
                }
            }
        }
    } else if cur == 0 as std::os::raw::c_int { (*ctxt).instate = XML_PARSER_EOF };
}
/*
	 * Loop detection
	 */
/* *
 * htmlParseCharData:
 * @ctxt:  an HTML parser context
 *
 * parse a CharData section.
 * if we are within a CDATA section ']]>' marks an end of section.
 *
 * [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
 */
unsafe extern "C" fn htmlParseCharData(mut ctxt: htmlParserCtxtPtr) {
    htmlParseCharDataInternal(ctxt, 0 as std::os::raw::c_int);
}
/* *
 * htmlParseExternalID:
 * @ctxt:  an HTML parser context
 * @publicID:  a xmlChar** receiving PubidLiteral
 *
 * Parse an External ID or a Public ID
 *
 * [75] ExternalID ::= 'SYSTEM' S SystemLiteral
 *                   | 'PUBLIC' S PubidLiteral S SystemLiteral
 *
 * [83] PublicID ::= 'PUBLIC' S PubidLiteral
 *
 * Returns the function returns SystemLiteral and in the second
 *                case publicID receives PubidLiteral, is strict is off
 *                it is possible to return NULL and have publicID set.
 */
unsafe extern "C" fn htmlParseExternalID(mut ctxt: htmlParserCtxtPtr,
                                         mut publicID: *mut *mut xmlChar)
 -> *mut xmlChar {
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    if ({
            let mut __res: std::os::raw::c_int = 0;
            if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                   1 as std::os::raw::c_int as std::os::raw::c_ulong {
                if 0 != 0 {
                    let mut __c: std::os::raw::c_int =
                        *(*(*ctxt).input).cur as std::os::raw::c_int;
                    __res =
                        (if __c < -(128 as std::os::raw::c_int) ||
                                __c > 255 as std::os::raw::c_int {
                             __c
                         } else {
                             *(*__ctype_toupper_loc()).offset(__c as isize)
                         })
                } else {
                    __res = toupper(*(*(*ctxt).input).cur as std::os::raw::c_int)
                }
            } else {
                __res =
                    *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur as
                                                         std::os::raw::c_int as isize)
            }
            __res
        }) == 'S' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(1 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(1
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'Y' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(2 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(2
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'S' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(3 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(3
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'T' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(4 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(4 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(4
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'E' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(5 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(5
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'M' as i32 {
        (*ctxt).nbChars += 6 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 6 as std::os::raw::c_int;
        if !(*(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                 0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                     *(*(*ctxt).input).cur as std::os::raw::c_int <=
                         0xa as std::os::raw::c_int ||
                 *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
            htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
                         b"Space required after \'SYSTEM\'\n\x00" as *const u8
                             as *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        }
        htmlSkipBlankChars(ctxt);
        URI = htmlParseSystemLiteral(ctxt);
        if URI.is_null() {
            htmlParseErr(ctxt, XML_ERR_URI_REQUIRED,
                         b"htmlParseExternalID: SYSTEM, no URI\n\x00" as
                             *const u8 as *const std::os::raw::c_char,
                         0 as *const xmlChar, 0 as *const xmlChar);
        }
    } else if ({
                   let mut __res: std::os::raw::c_int = 0;
                   if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                          1 as std::os::raw::c_int as std::os::raw::c_ulong {
                       if 0 != 0 {
                           let mut __c: std::os::raw::c_int =
                               *(*(*ctxt).input).cur as std::os::raw::c_int;
                           __res =
                               (if __c < -(128 as std::os::raw::c_int) ||
                                       __c > 255 as std::os::raw::c_int {
                                    __c
                                } else {
                                    *(*__ctype_toupper_loc()).offset(__c as
                                                                         isize)
                                })
                       } else {
                           __res =
                               toupper(*(*(*ctxt).input).cur as std::os::raw::c_int)
                       }
                   } else {
                       __res =
                           *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur
                                                                as std::os::raw::c_int
                                                                as isize)
                   }
                   __res
               }) == 'P' as i32 &&
                  ({
                       let mut __res: std::os::raw::c_int = 0;
                       if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                              1 as std::os::raw::c_int as std::os::raw::c_ulong {
                           if 0 != 0 {
                               let mut __c: std::os::raw::c_int =
                                   *(*(*ctxt).input).cur.offset(1 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                       as std::os::raw::c_int;
                               __res =
                                   (if __c < -(128 as std::os::raw::c_int) ||
                                           __c > 255 as std::os::raw::c_int {
                                        __c
                                    } else {
                                        *(*__ctype_toupper_loc()).offset(__c
                                                                             as
                                                                             isize)
                                    })
                           } else {
                               __res =
                                   toupper(*(*(*ctxt).input).cur.offset(1 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                               as std::os::raw::c_int)
                           }
                       } else {
                           __res =
                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(1
                                                                                                 as
                                                                                                 std::os::raw::c_int
                                                                                                 as
                                                                                                 isize)
                                                                    as
                                                                    std::os::raw::c_int
                                                                    as isize)
                       }
                       __res
                   }) == 'U' as i32 &&
                  ({
                       let mut __res: std::os::raw::c_int = 0;
                       if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                              1 as std::os::raw::c_int as std::os::raw::c_ulong {
                           if 0 != 0 {
                               let mut __c: std::os::raw::c_int =
                                   *(*(*ctxt).input).cur.offset(2 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                       as std::os::raw::c_int;
                               __res =
                                   (if __c < -(128 as std::os::raw::c_int) ||
                                           __c > 255 as std::os::raw::c_int {
                                        __c
                                    } else {
                                        *(*__ctype_toupper_loc()).offset(__c
                                                                             as
                                                                             isize)
                                    })
                           } else {
                               __res =
                                   toupper(*(*(*ctxt).input).cur.offset(2 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                               as std::os::raw::c_int)
                           }
                       } else {
                           __res =
                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(2
                                                                                                 as
                                                                                                 std::os::raw::c_int
                                                                                                 as
                                                                                                 isize)
                                                                    as
                                                                    std::os::raw::c_int
                                                                    as isize)
                       }
                       __res
                   }) == 'B' as i32 &&
                  ({
                       let mut __res: std::os::raw::c_int = 0;
                       if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                              1 as std::os::raw::c_int as std::os::raw::c_ulong {
                           if 0 != 0 {
                               let mut __c: std::os::raw::c_int =
                                   *(*(*ctxt).input).cur.offset(3 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                       as std::os::raw::c_int;
                               __res =
                                   (if __c < -(128 as std::os::raw::c_int) ||
                                           __c > 255 as std::os::raw::c_int {
                                        __c
                                    } else {
                                        *(*__ctype_toupper_loc()).offset(__c
                                                                             as
                                                                             isize)
                                    })
                           } else {
                               __res =
                                   toupper(*(*(*ctxt).input).cur.offset(3 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                               as std::os::raw::c_int)
                           }
                       } else {
                           __res =
                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(3
                                                                                                 as
                                                                                                 std::os::raw::c_int
                                                                                                 as
                                                                                                 isize)
                                                                    as
                                                                    std::os::raw::c_int
                                                                    as isize)
                       }
                       __res
                   }) == 'L' as i32 &&
                  ({
                       let mut __res: std::os::raw::c_int = 0;
                       if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                              1 as std::os::raw::c_int as std::os::raw::c_ulong {
                           if 0 != 0 {
                               let mut __c: std::os::raw::c_int =
                                   *(*(*ctxt).input).cur.offset(4 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                       as std::os::raw::c_int;
                               __res =
                                   (if __c < -(128 as std::os::raw::c_int) ||
                                           __c > 255 as std::os::raw::c_int {
                                        __c
                                    } else {
                                        *(*__ctype_toupper_loc()).offset(__c
                                                                             as
                                                                             isize)
                                    })
                           } else {
                               __res =
                                   toupper(*(*(*ctxt).input).cur.offset(4 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                               as std::os::raw::c_int)
                           }
                       } else {
                           __res =
                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(4
                                                                                                 as
                                                                                                 std::os::raw::c_int
                                                                                                 as
                                                                                                 isize)
                                                                    as
                                                                    std::os::raw::c_int
                                                                    as isize)
                       }
                       __res
                   }) == 'I' as i32 &&
                  ({
                       let mut __res: std::os::raw::c_int = 0;
                       if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                              1 as std::os::raw::c_int as std::os::raw::c_ulong {
                           if 0 != 0 {
                               let mut __c: std::os::raw::c_int =
                                   *(*(*ctxt).input).cur.offset(5 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                       as std::os::raw::c_int;
                               __res =
                                   (if __c < -(128 as std::os::raw::c_int) ||
                                           __c > 255 as std::os::raw::c_int {
                                        __c
                                    } else {
                                        *(*__ctype_toupper_loc()).offset(__c
                                                                             as
                                                                             isize)
                                    })
                           } else {
                               __res =
                                   toupper(*(*(*ctxt).input).cur.offset(5 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                               as std::os::raw::c_int)
                           }
                       } else {
                           __res =
                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(5
                                                                                                 as
                                                                                                 std::os::raw::c_int
                                                                                                 as
                                                                                                 isize)
                                                                    as
                                                                    std::os::raw::c_int
                                                                    as isize)
                       }
                       __res
                   }) == 'C' as i32 {
        (*ctxt).nbChars += 6 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 6 as std::os::raw::c_int;
        if !(*(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                 0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                     *(*(*ctxt).input).cur as std::os::raw::c_int <=
                         0xa as std::os::raw::c_int ||
                 *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
            htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
                         b"Space required after \'PUBLIC\'\n\x00" as *const u8
                             as *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        }
        htmlSkipBlankChars(ctxt);
        *publicID = htmlParsePubidLiteral(ctxt);
        if (*publicID).is_null() {
            htmlParseErr(ctxt, XML_ERR_PUBID_REQUIRED,
                         b"htmlParseExternalID: PUBLIC, no Public Identifier\n\x00"
                             as *const u8 as *const std::os::raw::c_char,
                         0 as *const xmlChar, 0 as *const xmlChar);
        }
        htmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 ||
               *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
            URI = htmlParseSystemLiteral(ctxt)
        }
    }
    return URI;
}
/* *
 * xmlParsePI:
 * @ctxt:  an XML parser context
 *
 * parse an XML Processing Instruction.
 *
 * [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
 */
unsafe extern "C" fn htmlParsePI(mut ctxt: htmlParserCtxtPtr) {
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut size: std::os::raw::c_int = 100 as std::os::raw::c_int;
    let mut cur: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut target: *const xmlChar = 0 as *const xmlChar;
    let mut state: xmlParserInputState = XML_PARSER_START;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if (if (*ctxt).token != 0 {
            -(1 as std::os::raw::c_int)
        } else { *(*(*ctxt).input).cur as std::os::raw::c_int }) == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '?' as i32 {
        state = (*ctxt).instate;
        (*ctxt).instate = XML_PARSER_PI;
        /*
	 * this is a Processing Instruction.
	 */
        (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 2 as std::os::raw::c_int;
        if (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) <
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
            xmlParserInputShrink((*ctxt).input);
        }
        /*
	 * Parse the target name and check for special support like
	 * namespace.
	 */
        target = htmlParseName(ctxt);
        if !target.is_null() {
            if (if (*ctxt).token != 0 {
                    -(1 as std::os::raw::c_int)
                } else { *(*(*ctxt).input).cur as std::os::raw::c_int }) == '>' as i32
               {
                (*ctxt).nbChars += 1 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 1 as std::os::raw::c_int;
                /*
		 * SAX: PI detected.
		 */
                if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                       (*(*ctxt).sax).processingInstruction.is_some() {
                    (*(*ctxt).sax).processingInstruction.expect("non-null function pointer")((*ctxt).userData,
                                                                                             target,
                                                                                             0
                                                                                                 as
                                                                                                 *const xmlChar);
                }
                (*ctxt).instate = state;
                return
            }
            buf =
                xmlMallocAtomic.expect("non-null function pointer")((size as
                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                         as
                                                                                                         std::os::raw::c_ulong))
                    as *mut xmlChar;
            if buf.is_null() {
                htmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                (*ctxt).instate = state;
                return
            }
            cur = *(*(*ctxt).input).cur as std::os::raw::c_int;
            if if cur < 0x100 as std::os::raw::c_int {
                   (cur == 0x20 as std::os::raw::c_int ||
                        0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int
                        || cur == 0xd as std::os::raw::c_int) as std::os::raw::c_int
               } else { 0 as std::os::raw::c_int } == 0 {
                htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
                             b"ParsePI: PI %s space expected\n\x00" as
                                 *const u8 as *const std::os::raw::c_char, target,
                             0 as *const xmlChar);
            }
            htmlSkipBlankChars(ctxt);
            cur = htmlCurrentChar(ctxt, &mut l);
            while (if cur < 0x100 as std::os::raw::c_int {
                       (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int
                            || cur == 0xd as std::os::raw::c_int ||
                            0x20 as std::os::raw::c_int <= cur) as std::os::raw::c_int
                   } else {
                       (0x100 as std::os::raw::c_int <= cur &&
                            cur <= 0xd7ff as std::os::raw::c_int ||
                            0xe000 as std::os::raw::c_int <= cur &&
                                cur <= 0xfffd as std::os::raw::c_int ||
                            0x10000 as std::os::raw::c_int <= cur &&
                                cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
                   }) != 0 && cur != '>' as i32 {
                if len + 5 as std::os::raw::c_int >= size {
                    let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                    size *= 2 as std::os::raw::c_int;
                    tmp =
                        xmlRealloc.expect("non-null function pointer")(buf as
                                                                           *mut std::os::raw::c_void,
                                                                       (size
                                                                            as
                                                                            std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                            as
                                                                                                            std::os::raw::c_ulong))
                            as *mut xmlChar;
                    if tmp.is_null() {
                        htmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                        xmlFree.expect("non-null function pointer")(buf as
                                                                        *mut std::os::raw::c_void);
                        (*ctxt).instate = state;
                        return
                    }
                    buf = tmp
                }
                count += 1;
                if count > 50 as std::os::raw::c_int {
                    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               250 as std::os::raw::c_int as std::os::raw::c_long {
                        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                    }
                    count = 0 as std::os::raw::c_int
                }
                if l == 1 as std::os::raw::c_int {
                    let fresh39 = len;
                    len = len + 1;
                    *buf.offset(fresh39 as isize) = cur as xmlChar
                } else {
                    len += xmlCopyChar(l, &mut *buf.offset(len as isize), cur)
                }
                if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                    (*(*ctxt).input).line += 1;
                    (*(*ctxt).input).col = 1 as std::os::raw::c_int
                } else { (*(*ctxt).input).col += 1 }
                (*ctxt).token = 0 as std::os::raw::c_int;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(l as isize);
                (*ctxt).nbChars += 1;
                cur = htmlCurrentChar(ctxt, &mut l);
                if cur == 0 as std::os::raw::c_int {
                    if (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                           as std::os::raw::c_long >
                           (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                               std::os::raw::c_long &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                                   std::os::raw::c_long {
                        xmlParserInputShrink((*ctxt).input);
                    }
                    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               250 as std::os::raw::c_int as std::os::raw::c_long {
                        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                    }
                    cur = htmlCurrentChar(ctxt, &mut l)
                }
            }
            *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
            if cur != '>' as i32 {
                htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,
                             b"ParsePI: PI %s never end ...\n\x00" as
                                 *const u8 as *const std::os::raw::c_char, target,
                             0 as *const xmlChar);
            } else {
                (*ctxt).nbChars += 1 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 1 as std::os::raw::c_int;
                /*
		 * SAX: PI detected.
		 */
                if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                       (*(*ctxt).sax).processingInstruction.is_some() {
                    (*(*ctxt).sax).processingInstruction.expect("non-null function pointer")((*ctxt).userData,
                                                                                             target,
                                                                                             buf);
                }
            }
            xmlFree.expect("non-null function pointer")(buf as
                                                            *mut std::os::raw::c_void);
        } else {
            htmlParseErr(ctxt, XML_ERR_PI_NOT_STARTED,
                         b"PI is not started correctly\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar,
                         0 as *const xmlChar);
        }
        (*ctxt).instate = state
    };
}
/* *
 * htmlParseComment:
 * @ctxt:  an HTML parser context
 *
 * Parse an XML (SGML) comment <!-- .... -->
 *
 * [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
 */
unsafe extern "C" fn htmlParseComment(mut ctxt: htmlParserCtxtPtr) {
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 100 as std::os::raw::c_int;
    let mut q: std::os::raw::c_int = 0;
    let mut ql: std::os::raw::c_int = 0;
    let mut r: std::os::raw::c_int = 0;
    let mut rl: std::os::raw::c_int = 0;
    let mut cur: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut state: xmlParserInputState = XML_PARSER_START;
    /*
     * Check that there is a comment right here.
     */
    if (if (*ctxt).token != 0 {
            -(1 as std::os::raw::c_int)
        } else { *(*(*ctxt).input).cur as std::os::raw::c_int }) != '<' as i32 ||
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '!' as i32 ||
           *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '-' as i32 ||
           *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '-' as i32 {
        return
    }
    state = (*ctxt).instate;
    (*ctxt).instate = XML_PARSER_COMMENT;
    if (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
           std::os::raw::c_long >
           (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlParserInputShrink((*ctxt).input);
    }
    (*ctxt).nbChars += 4 as std::os::raw::c_int as std::os::raw::c_long;
    (*(*ctxt).input).cur =
        (*(*ctxt).input).cur.offset(4 as std::os::raw::c_int as isize);
    (*(*ctxt).input).col += 4 as std::os::raw::c_int;
    buf =
        xmlMallocAtomic.expect("non-null function pointer")((size as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if buf.is_null() {
        htmlErrMemory(ctxt,
                      b"buffer allocation failed\n\x00" as *const u8 as
                          *const std::os::raw::c_char);
        (*ctxt).instate = state;
        return
    }
    len = 0 as std::os::raw::c_int;
    *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
    q = htmlCurrentChar(ctxt, &mut ql);
    if !(if q < 0x100 as std::os::raw::c_int {
             (0x9 as std::os::raw::c_int <= q && q <= 0xa as std::os::raw::c_int ||
                  q == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= q) as
                 std::os::raw::c_int
         } else {
             (0x100 as std::os::raw::c_int <= q && q <= 0xd7ff as std::os::raw::c_int ||
                  0xe000 as std::os::raw::c_int <= q && q <= 0xfffd as std::os::raw::c_int ||
                  0x10000 as std::os::raw::c_int <= q && q <= 0x10ffff as std::os::raw::c_int)
                 as std::os::raw::c_int
         } == 0) {
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*ctxt).token = 0 as std::os::raw::c_int;
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(ql as isize);
        (*ctxt).nbChars += 1;
        r = htmlCurrentChar(ctxt, &mut rl);
        if !(if r < 0x100 as std::os::raw::c_int {
                 (0x9 as std::os::raw::c_int <= r && r <= 0xa as std::os::raw::c_int ||
                      r == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= r) as
                     std::os::raw::c_int
             } else {
                 (0x100 as std::os::raw::c_int <= r && r <= 0xd7ff as std::os::raw::c_int ||
                      0xe000 as std::os::raw::c_int <= r && r <= 0xfffd as std::os::raw::c_int
                      ||
                      0x10000 as std::os::raw::c_int <= r &&
                          r <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
             } == 0) {
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                (*(*ctxt).input).line += 1;
                (*(*ctxt).input).col = 1 as std::os::raw::c_int
            } else { (*(*ctxt).input).col += 1 }
            (*ctxt).token = 0 as std::os::raw::c_int;
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(rl as isize);
            (*ctxt).nbChars += 1;
            cur = htmlCurrentChar(ctxt, &mut l);
            while (if cur < 0x100 as std::os::raw::c_int {
                       (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int
                            || cur == 0xd as std::os::raw::c_int ||
                            0x20 as std::os::raw::c_int <= cur) as std::os::raw::c_int
                   } else {
                       (0x100 as std::os::raw::c_int <= cur &&
                            cur <= 0xd7ff as std::os::raw::c_int ||
                            0xe000 as std::os::raw::c_int <= cur &&
                                cur <= 0xfffd as std::os::raw::c_int ||
                            0x10000 as std::os::raw::c_int <= cur &&
                                cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
                   }) != 0 &&
                      (cur != '>' as i32 || r != '-' as i32 ||
                           q != '-' as i32) {
                if len + 5 as std::os::raw::c_int >= size {
                    let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                    size *= 2 as std::os::raw::c_int;
                    tmp =
                        xmlRealloc.expect("non-null function pointer")(buf as
                                                                           *mut std::os::raw::c_void,
                                                                       (size
                                                                            as
                                                                            std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                            as
                                                                                                            std::os::raw::c_ulong))
                            as *mut xmlChar;
                    if tmp.is_null() {
                        xmlFree.expect("non-null function pointer")(buf as
                                                                        *mut std::os::raw::c_void);
                        htmlErrMemory(ctxt,
                                      b"growing buffer failed\n\x00" as
                                          *const u8 as *const std::os::raw::c_char);
                        (*ctxt).instate = state;
                        return
                    }
                    buf = tmp
                }
                if ql == 1 as std::os::raw::c_int {
                    let fresh40 = len;
                    len = len + 1;
                    *buf.offset(fresh40 as isize) = q as xmlChar
                } else {
                    len += xmlCopyChar(ql, &mut *buf.offset(len as isize), q)
                }
                q = r;
                ql = rl;
                r = cur;
                rl = l;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                    (*(*ctxt).input).line += 1;
                    (*(*ctxt).input).col = 1 as std::os::raw::c_int
                } else { (*(*ctxt).input).col += 1 }
                (*ctxt).token = 0 as std::os::raw::c_int;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(l as isize);
                (*ctxt).nbChars += 1;
                cur = htmlCurrentChar(ctxt, &mut l);
                if cur == 0 as std::os::raw::c_int {
                    if (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                           as std::os::raw::c_long >
                           (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                               std::os::raw::c_long &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                                   std::os::raw::c_long {
                        xmlParserInputShrink((*ctxt).input);
                    }
                    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               250 as std::os::raw::c_int as std::os::raw::c_long {
                        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                    }
                    cur = htmlCurrentChar(ctxt, &mut l)
                }
            }
            *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
            if if cur < 0x100 as std::os::raw::c_int {
                   (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int ||
                        cur == 0xd as std::os::raw::c_int ||
                        0x20 as std::os::raw::c_int <= cur) as std::os::raw::c_int
               } else {
                   (0x100 as std::os::raw::c_int <= cur &&
                        cur <= 0xd7ff as std::os::raw::c_int ||
                        0xe000 as std::os::raw::c_int <= cur &&
                            cur <= 0xfffd as std::os::raw::c_int ||
                        0x10000 as std::os::raw::c_int <= cur &&
                            cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
               } != 0 {
                xmlNextChar(ctxt);
                if !(*ctxt).sax.is_null() && (*(*ctxt).sax).comment.is_some()
                       && (*ctxt).disableSAX == 0 {
                    (*(*ctxt).sax).comment.expect("non-null function pointer")((*ctxt).userData,
                                                                               buf);
                }
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                (*ctxt).instate = state;
                return
            }
        }
    }
    htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
                 b"Comment not terminated \n<!--%.50s\n\x00" as *const u8 as
                     *const std::os::raw::c_char, buf, 0 as *const xmlChar);
    xmlFree.expect("non-null function pointer")(buf as *mut std::os::raw::c_void);
}
/* *
 * htmlParseCharRef:
 * @ctxt:  an HTML parser context
 *
 * parse Reference declarations
 *
 * [66] CharRef ::= '&#' [0-9]+ ';' |
 *                  '&#x' [0-9a-fA-F]+ ';'
 *
 * Returns the value parsed (as an int)
 */
#[no_mangle]
pub unsafe extern "C" fn htmlParseCharRef(mut ctxt: htmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut val: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if ctxt.is_null() || (*ctxt).input.is_null() {
        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                     b"htmlParseCharRef: context error\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        return 0 as std::os::raw::c_int
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '&' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '#' as i32 &&
           (*(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                std::os::raw::c_int == 'x' as i32 ||
                *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                    std::os::raw::c_int == 'X' as i32) {
        (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 3 as std::os::raw::c_int;
        while *(*(*ctxt).input).cur as std::os::raw::c_int != ';' as i32 {
            if *(*(*ctxt).input).cur as std::os::raw::c_int >= '0' as i32 &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= '9' as i32 {
                val =
                    val * 16 as std::os::raw::c_int +
                        (*(*(*ctxt).input).cur as std::os::raw::c_int - '0' as i32)
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int >= 'a' as i32 &&
                          *(*(*ctxt).input).cur as std::os::raw::c_int <= 'f' as i32 {
                val =
                    val * 16 as std::os::raw::c_int +
                        (*(*(*ctxt).input).cur as std::os::raw::c_int - 'a' as i32) +
                        10 as std::os::raw::c_int
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int >= 'A' as i32 &&
                          *(*(*ctxt).input).cur as std::os::raw::c_int <= 'F' as i32 {
                val =
                    val * 16 as std::os::raw::c_int +
                        (*(*(*ctxt).input).cur as std::os::raw::c_int - 'A' as i32) +
                        10 as std::os::raw::c_int
            } else {
                htmlParseErr(ctxt, XML_ERR_INVALID_HEX_CHARREF,
                             b"htmlParseCharRef: missing semicolon\n\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             0 as *const xmlChar, 0 as *const xmlChar);
                break ;
            }
            xmlNextChar(ctxt);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ';' as i32 {
            xmlNextChar(ctxt);
        }
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '&' as i32 &&
                  *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                      std::os::raw::c_int == '#' as i32 {
        (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 2 as std::os::raw::c_int;
        while *(*(*ctxt).input).cur as std::os::raw::c_int != ';' as i32 {
            if *(*(*ctxt).input).cur as std::os::raw::c_int >= '0' as i32 &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= '9' as i32 {
                val =
                    val * 10 as std::os::raw::c_int +
                        (*(*(*ctxt).input).cur as std::os::raw::c_int - '0' as i32);
                xmlNextChar(ctxt);
            } else {
                htmlParseErr(ctxt, XML_ERR_INVALID_DEC_CHARREF,
                             b"htmlParseCharRef: missing semicolon\n\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             0 as *const xmlChar, 0 as *const xmlChar);
                break ;
            }
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ';' as i32 {
            xmlNextChar(ctxt);
        }
    } else {
        htmlParseErr(ctxt, XML_ERR_INVALID_CHARREF,
                     b"htmlParseCharRef: invalid value\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
    }
    /*
     * Check the value IS_CHAR ...
     */
    if if val < 0x100 as std::os::raw::c_int {
           (0x9 as std::os::raw::c_int <= val && val <= 0xa as std::os::raw::c_int ||
                val == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= val) as
               std::os::raw::c_int
       } else {
           (0x100 as std::os::raw::c_int <= val && val <= 0xd7ff as std::os::raw::c_int ||
                0xe000 as std::os::raw::c_int <= val && val <= 0xfffd as std::os::raw::c_int
                ||
                0x10000 as std::os::raw::c_int <= val &&
                    val <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
       } != 0 {
        return val
    } else {
        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                        b"htmlParseCharRef: invalid xmlChar value %d\n\x00" as
                            *const u8 as *const std::os::raw::c_char, val);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * htmlParseDocTypeDecl:
 * @ctxt:  an HTML parser context
 *
 * parse a DOCTYPE declaration
 *
 * [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S?
 *                      ('[' (markupdecl | PEReference | S)* ']' S?)? '>'
 */
unsafe extern "C" fn htmlParseDocTypeDecl(mut ctxt: htmlParserCtxtPtr) {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    /*
     * We know that '<!DOCTYPE' has been detected.
     */
    (*ctxt).nbChars += 9 as std::os::raw::c_int as std::os::raw::c_long;
    (*(*ctxt).input).cur =
        (*(*ctxt).input).cur.offset(9 as std::os::raw::c_int as isize);
    (*(*ctxt).input).col += 9 as std::os::raw::c_int;
    htmlSkipBlankChars(ctxt);
    /*
     * Parse the DOCTYPE name.
     */
    name = htmlParseName(ctxt);
    if name.is_null() {
        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
                     b"htmlParseDocTypeDecl : no DOCTYPE name !\n\x00" as
                         *const u8 as *const std::os::raw::c_char,
                     0 as *const xmlChar, 0 as *const xmlChar);
    }
    /*
     * Check that upper(name) == "HTML" !!!!!!!!!!!!!
     */
    htmlSkipBlankChars(ctxt);
    /*
     * Check for SystemID and ExternalID
     */
    URI = htmlParseExternalID(ctxt, &mut ExternalID);
    htmlSkipBlankChars(ctxt);
    /*
     * We should be at the end of the DOCTYPE declaration.
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
        htmlParseErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED,
                     b"DOCTYPE improperly terminated\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        /* We shouldn't try to resynchronize ... */
    }
    xmlNextChar(ctxt);
    /*
     * Create or update the document accordingly to the DOCTYPE
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).internalSubset.is_some() &&
           (*ctxt).disableSAX == 0 {
        (*(*ctxt).sax).internalSubset.expect("non-null function pointer")((*ctxt).userData,
                                                                          name,
                                                                          ExternalID,
                                                                          URI);
    }
    /*
     * Cleanup, since we don't use all those identifiers
     */
    if !URI.is_null() {
        xmlFree.expect("non-null function pointer")(URI as *mut std::os::raw::c_void);
    }
    if !ExternalID.is_null() {
        xmlFree.expect("non-null function pointer")(ExternalID as
                                                        *mut std::os::raw::c_void);
    };
}
/* *
 * htmlParseAttribute:
 * @ctxt:  an HTML parser context
 * @value:  a xmlChar ** used to store the value of the attribute
 *
 * parse an attribute
 *
 * [41] Attribute ::= Name Eq AttValue
 *
 * [25] Eq ::= S? '=' S?
 *
 * With namespace:
 *
 * [NS 11] Attribute ::= QName Eq AttValue
 *
 * Also the case QName == xmlns:??? is handled independently as a namespace
 * definition.
 *
 * Returns the attribute name, and the value in *value.
 */
unsafe extern "C" fn htmlParseAttribute(mut ctxt: htmlParserCtxtPtr,
                                        mut value: *mut *mut xmlChar)
 -> *const xmlChar {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    *value = 0 as *mut xmlChar;
    name = htmlParseHTMLName(ctxt);
    if name.is_null() {
        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
                     b"error parsing attribute name\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        return 0 as *const xmlChar
    }
    /*
     * read the value
     */
    htmlSkipBlankChars(ctxt);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '=' as i32 {
        xmlNextChar(ctxt);
        htmlSkipBlankChars(ctxt);
        val = htmlParseAttValue(ctxt)
    }
    *value = val;
    return name;
}
/* *
 * htmlCheckEncodingDirect:
 * @ctxt:  an HTML parser context
 * @attvalue: the attribute value
 *
 * Checks an attribute value to detect
 * the encoding
 * If a new encoding is detected the parser is switched to decode
 * it and pass UTF8
 */
unsafe extern "C" fn htmlCheckEncodingDirect(mut ctxt: htmlParserCtxtPtr,
                                             mut encoding: *const xmlChar) {
    if ctxt.is_null() || encoding.is_null() ||
           (*ctxt).options & HTML_PARSE_IGNORE_ENC as std::os::raw::c_int != 0 {
        return
    }
    /* do not change encoding */
    if !(*(*ctxt).input).encoding.is_null() { return }
    if !encoding.is_null() {
        let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
        let mut handler: xmlCharEncodingHandlerPtr =
            0 as *mut xmlCharEncodingHandler;
        while *encoding as std::os::raw::c_int == ' ' as i32 ||
                  *encoding as std::os::raw::c_int == '\t' as i32 {
            encoding = encoding.offset(1)
        }
        if !(*(*ctxt).input).encoding.is_null() {
            xmlFree.expect("non-null function pointer")((*(*ctxt).input).encoding
                                                            as *mut xmlChar as
                                                            *mut std::os::raw::c_void);
        }
        (*(*ctxt).input).encoding = xmlStrdup(encoding);
        enc = xmlParseCharEncoding(encoding as *const std::os::raw::c_char);
        /*
	 * registered set of known encodings
	 */
        if enc as std::os::raw::c_int != XML_CHAR_ENCODING_ERROR as std::os::raw::c_int {
            if (enc as std::os::raw::c_int == XML_CHAR_ENCODING_UTF16LE as std::os::raw::c_int
                    ||
                    enc as std::os::raw::c_int ==
                        XML_CHAR_ENCODING_UTF16BE as std::os::raw::c_int ||
                    enc as std::os::raw::c_int ==
                        XML_CHAR_ENCODING_UCS4LE as std::os::raw::c_int ||
                    enc as std::os::raw::c_int ==
                        XML_CHAR_ENCODING_UCS4BE as std::os::raw::c_int) &&
                   !(*(*ctxt).input).buf.is_null() &&
                   (*(*(*ctxt).input).buf).encoder.is_null() {
                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
                             b"htmlCheckEncoding: wrong encoding meta\n\x00"
                                 as *const u8 as *const std::os::raw::c_char,
                             0 as *const xmlChar, 0 as *const xmlChar);
            } else { xmlSwitchEncoding(ctxt, enc); }
            (*ctxt).charset = XML_CHAR_ENCODING_UTF8 as std::os::raw::c_int
        } else {
            /*
	     * fallback for unknown encodings
	     */
            handler =
                xmlFindCharEncodingHandler(encoding as *const std::os::raw::c_char);
            if !handler.is_null() {
                xmlSwitchToEncoding(ctxt, handler);
                (*ctxt).charset = XML_CHAR_ENCODING_UTF8 as std::os::raw::c_int
            } else {
                htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
                             b"htmlCheckEncoding: unknown encoding %s\n\x00"
                                 as *const u8 as *const std::os::raw::c_char,
                             encoding, 0 as *const xmlChar);
            }
        }
        if !(*(*ctxt).input).buf.is_null() &&
               !(*(*(*ctxt).input).buf).encoder.is_null() &&
               !(*(*(*ctxt).input).buf).raw.is_null() &&
               !(*(*(*ctxt).input).buf).buffer.is_null() {
            let mut nbchars: std::os::raw::c_int = 0;
            let mut processed: std::os::raw::c_int = 0;
            /*
	     * convert as much as possible to the parser reading buffer.
	     */
            processed =
                (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                    as std::os::raw::c_long as std::os::raw::c_int;
            xmlBufShrink((*(*(*ctxt).input).buf).buffer, processed as size_t);
            nbchars = xmlCharEncInput((*(*ctxt).input).buf, 1 as std::os::raw::c_int);
            if nbchars < 0 as std::os::raw::c_int {
                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
                             b"htmlCheckEncoding: encoder error\n\x00" as
                                 *const u8 as *const std::os::raw::c_char,
                             0 as *const xmlChar, 0 as *const xmlChar);
            }
            xmlBufResetInput((*(*(*ctxt).input).buf).buffer, (*ctxt).input);
        }
    };
}
/* *
 * htmlCheckEncoding:
 * @ctxt:  an HTML parser context
 * @attvalue: the attribute value
 *
 * Checks an http-equiv attribute from a Meta tag to detect
 * the encoding
 * If a new encoding is detected the parser is switched to decode
 * it and pass UTF8
 */
unsafe extern "C" fn htmlCheckEncoding(mut ctxt: htmlParserCtxtPtr,
                                       mut attvalue: *const xmlChar) {
    let mut encoding: *const xmlChar = 0 as *const xmlChar;
    if attvalue.is_null() { return }
    encoding =
        xmlStrcasestr(attvalue,
                      b"charset\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
    if !encoding.is_null() {
        encoding = encoding.offset(7 as std::os::raw::c_int as isize)
    }
    /*
     * skip blank
     */
    if !encoding.is_null() &&
           (*encoding as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                0x9 as std::os::raw::c_int <= *encoding as std::os::raw::c_int &&
                    *encoding as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                *encoding as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
        encoding =
            xmlStrcasestr(attvalue,
                          b"=\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar)
    }
    if !encoding.is_null() && *encoding as std::os::raw::c_int == '=' as i32 {
        encoding = encoding.offset(1);
        htmlCheckEncodingDirect(ctxt, encoding);
    };
}
/* *
 * htmlCheckMeta:
 * @ctxt:  an HTML parser context
 * @atts:  the attributes values
 *
 * Checks an attributes from a Meta tag
 */
unsafe extern "C" fn htmlCheckMeta(mut ctxt: htmlParserCtxtPtr,
                                   mut atts: *mut *const xmlChar) {
    let mut i: std::os::raw::c_int = 0;
    let mut att: *const xmlChar = 0 as *const xmlChar;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    let mut http: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut content: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || atts.is_null() { return }
    i = 0 as std::os::raw::c_int;
    let fresh41 = i;
    i = i + 1;
    att = *atts.offset(fresh41 as isize);
    while !att.is_null() {
        let fresh42 = i;
        i = i + 1;
        value = *atts.offset(fresh42 as isize);
        if !value.is_null() &&
               xmlStrcasecmp(att,
                             b"http-equiv\x00" as *const u8 as
                                 *const std::os::raw::c_char as *mut xmlChar) == 0 &&
               xmlStrcasecmp(value,
                             b"Content-Type\x00" as *const u8 as
                                 *const std::os::raw::c_char as *mut xmlChar) == 0 {
            http = 1 as std::os::raw::c_int
        } else if !value.is_null() &&
                      xmlStrcasecmp(att,
                                    b"charset\x00" as *const u8 as
                                        *const std::os::raw::c_char as *mut xmlChar)
                          == 0 {
            htmlCheckEncodingDirect(ctxt, value);
        } else if !value.is_null() &&
                      xmlStrcasecmp(att,
                                    b"content\x00" as *const u8 as
                                        *const std::os::raw::c_char as *mut xmlChar)
                          == 0 {
            content = value
        }
        let fresh43 = i;
        i = i + 1;
        att = *atts.offset(fresh43 as isize)
    }
    if http != 0 && !content.is_null() { htmlCheckEncoding(ctxt, content); };
}
/* *
 * htmlParseStartTag:
 * @ctxt:  an HTML parser context
 *
 * parse a start of tag either for rule element or
 * EmptyElement. In both case we don't parse the tag closing chars.
 *
 * [40] STag ::= '<' Name (S Attribute)* S? '>'
 *
 * [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'
 *
 * With namespace:
 *
 * [NS 8] STag ::= '<' QName (S Attribute)* S? '>'
 *
 * [NS 10] EmptyElement ::= '<' QName (S Attribute)* S? '/>'
 *
 * Returns 0 in case of success, -1 in case of error and 1 if discarded
 */
unsafe extern "C" fn htmlParseStartTag(mut ctxt: htmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut attname: *const xmlChar = 0 as *const xmlChar;
    let mut attvalue: *mut xmlChar = 0 as *mut xmlChar;
    let mut atts: *mut *const xmlChar = 0 as *mut *const xmlChar;
    let mut nbatts: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut maxatts: std::os::raw::c_int = 0;
    let mut meta: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut i: std::os::raw::c_int = 0;
    let mut discardtag: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if ctxt.is_null() || (*ctxt).input.is_null() {
        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                     b"htmlParseStartTag: context error\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        return -(1 as std::os::raw::c_int)
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 {
        return -(1 as std::os::raw::c_int)
    }
    xmlNextChar(ctxt);
    atts = (*ctxt).atts;
    maxatts = (*ctxt).maxatts;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    name = htmlParseHTMLName(ctxt);
    if name.is_null() {
        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
                     b"htmlParseStartTag: invalid element name\n\x00" as
                         *const u8 as *const std::os::raw::c_char,
                     0 as *const xmlChar, 0 as *const xmlChar);
        /* if recover preserve text on classic misconstructs */
        if (*ctxt).recovery != 0 &&
               (*(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                    0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int
                        &&
                        *(*(*ctxt).input).cur as std::os::raw::c_int <=
                            0xa as std::os::raw::c_int ||
                    *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int
                    || *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 ||
                    *(*(*ctxt).input).cur as std::os::raw::c_int == '=' as i32 ||
                    *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 ||
                    *(*(*ctxt).input).cur as std::os::raw::c_int >= '0' as i32 &&
                        *(*(*ctxt).input).cur as std::os::raw::c_int <= '9' as i32) {
            htmlParseCharDataInternal(ctxt, '<' as i32);
            return -(1 as std::os::raw::c_int)
        }
        /* Dump the bogus tag like browsers do */
        while (0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int
                   ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int
                   ||
                   0x20 as std::os::raw::c_int <=
                       *(*(*ctxt).input).cur as std::os::raw::c_int) &&
                  *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 &&
                  (*ctxt).instate as std::os::raw::c_int !=
                      XML_PARSER_EOF as std::os::raw::c_int {
            xmlNextChar(ctxt);
        }
        return -(1 as std::os::raw::c_int)
    }
    if xmlStrEqual(name,
                   b"meta\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        meta = 1 as std::os::raw::c_int
    }
    /*
     * Check for auto-closure of HTML elements.
     */
    htmlAutoClose(ctxt, name);
    /*
     * Check for implied HTML elements.
     */
    htmlCheckImplied(ctxt, name);
    /*
     * Avoid html at any level > 0, head at any level != 1
     * or any attempt to recurse body
     */
    if (*ctxt).nameNr > 0 as std::os::raw::c_int &&
           xmlStrEqual(name,
                       b"html\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
                     b"htmlParseStartTag: misplaced <html> tag\n\x00" as
                         *const u8 as *const std::os::raw::c_char, name,
                     0 as *const xmlChar);
        discardtag = 1 as std::os::raw::c_int;
        (*ctxt).depth += 1
    }
    if (*ctxt).nameNr != 1 as std::os::raw::c_int &&
           xmlStrEqual(name,
                       b"head\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
                     b"htmlParseStartTag: misplaced <head> tag\n\x00" as
                         *const u8 as *const std::os::raw::c_char, name,
                     0 as *const xmlChar);
        discardtag = 1 as std::os::raw::c_int;
        (*ctxt).depth += 1
    }
    if xmlStrEqual(name,
                   b"body\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        let mut indx: std::os::raw::c_int = 0;
        indx = 0 as std::os::raw::c_int;
        while indx < (*ctxt).nameNr {
            if xmlStrEqual(*(*ctxt).nameTab.offset(indx as isize),
                           b"body\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) != 0 {
                htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
                             b"htmlParseStartTag: misplaced <body> tag\n\x00"
                                 as *const u8 as *const std::os::raw::c_char, name,
                             0 as *const xmlChar);
                discardtag = 1 as std::os::raw::c_int;
                (*ctxt).depth += 1
            }
            indx += 1
        }
    }
    /*
     * Now parse the attributes, it ends up with the ending
     *
     * (S Attribute)* S?
     */
    htmlSkipBlankChars(ctxt);
    while (0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
               *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
               *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
               0x20 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int) &&
              *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 &&
              (*(*(*ctxt).input).cur as std::os::raw::c_int != '/' as i32 ||
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int != '>' as i32) {
        let mut cons: std::os::raw::c_long = (*ctxt).nbChars;
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        attname = htmlParseAttribute(ctxt, &mut attvalue);
        if !attname.is_null() {
            /*
	     * Well formedness requires at most one declaration of an attribute
	     */
            i = 0 as std::os::raw::c_int;
            loop  {
                if !(i < nbatts) {
                    current_block = 17836213544692497527;
                    break ;
                }
                if xmlStrEqual(*atts.offset(i as isize), attname) != 0 {
                    htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,
                                 b"Attribute %s redefined\n\x00" as *const u8
                                     as *const std::os::raw::c_char, attname,
                                 0 as *const xmlChar);
                    if !attvalue.is_null() {
                        xmlFree.expect("non-null function pointer")(attvalue
                                                                        as
                                                                        *mut std::os::raw::c_void);
                    }
                    current_block = 17760383854396240069;
                    break ;
                } else { i += 2 as std::os::raw::c_int }
            }
            match current_block {
                17760383854396240069 => { }
                _ =>
                /*
	     * Add the pair to atts
	     */
                {
                    if atts.is_null() {
                        maxatts =
                            22 as
                                std::os::raw::c_int; /* allow for 10 attrs by default */
                        atts =
                            xmlMalloc.expect("non-null function pointer")((maxatts
                                                                               as
                                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlChar>()
                                                                                                               as
                                                                                                               std::os::raw::c_ulong))
                                as *mut *const xmlChar;
                        if atts.is_null() {
                            htmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                            if !attvalue.is_null() {
                                xmlFree.expect("non-null function pointer")(attvalue
                                                                                as
                                                                                *mut std::os::raw::c_void);
                            }
                            current_block = 17760383854396240069;
                        } else {
                            (*ctxt).atts = atts;
                            (*ctxt).maxatts = maxatts;
                            current_block = 17787701279558130514;
                        }
                    } else if nbatts + 4 as std::os::raw::c_int > maxatts {
                        let mut n: *mut *const xmlChar =
                            0 as *mut *const xmlChar;
                        maxatts *= 2 as std::os::raw::c_int;
                        n =
                            xmlRealloc.expect("non-null function pointer")(atts
                                                                               as
                                                                               *mut std::os::raw::c_void,
                                                                           (maxatts
                                                                                as
                                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                                as
                                                                                                                std::os::raw::c_ulong))
                                as *mut *const xmlChar;
                        if n.is_null() {
                            htmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                            if !attvalue.is_null() {
                                xmlFree.expect("non-null function pointer")(attvalue
                                                                                as
                                                                                *mut std::os::raw::c_void);
                            }
                            current_block = 17760383854396240069;
                        } else {
                            atts = n;
                            (*ctxt).atts = atts;
                            (*ctxt).maxatts = maxatts;
                            current_block = 17787701279558130514;
                        }
                    } else { current_block = 17787701279558130514; }
                    match current_block {
                        17760383854396240069 => { }
                        _ => {
                            let fresh44 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh45 =
                                *atts.offset(fresh44 as isize);
                            *fresh45 = attname;
                            let fresh46 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh47 =
                                *atts.offset(fresh46 as isize);
                            *fresh47 = attvalue;
                            let ref mut fresh48 =
                                *atts.offset(nbatts as isize);
                            *fresh48 = 0 as *const xmlChar;
                            let ref mut fresh49 =
                                *atts.offset((nbatts + 1 as std::os::raw::c_int) as
                                                 isize);
                            *fresh49 = 0 as *const xmlChar
                        }
                    }
                }
            }
        } else {
            if !attvalue.is_null() {
                xmlFree.expect("non-null function pointer")(attvalue as
                                                                *mut std::os::raw::c_void);
            }
            /* Dump the bogus attribute string up to the next blank or
	     * the end of the tag. */
            while (0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int
                       &&
                       *(*(*ctxt).input).cur as std::os::raw::c_int <=
                           0xa as std::os::raw::c_int ||
                       *(*(*ctxt).input).cur as std::os::raw::c_int ==
                           0xd as std::os::raw::c_int ||
                       0x20 as std::os::raw::c_int <=
                           *(*(*ctxt).input).cur as std::os::raw::c_int) &&
                      !(*(*(*ctxt).input).cur as std::os::raw::c_int ==
                            0x20 as std::os::raw::c_int ||
                            0x9 as std::os::raw::c_int <=
                                *(*(*ctxt).input).cur as std::os::raw::c_int &&
                                *(*(*ctxt).input).cur as std::os::raw::c_int <=
                                    0xa as std::os::raw::c_int ||
                            *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                0xd as std::os::raw::c_int) &&
                      *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 &&
                      (*(*(*ctxt).input).cur as std::os::raw::c_int != '/' as i32 ||
                           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                            isize) as
                               std::os::raw::c_int != '>' as i32) {
                xmlNextChar(ctxt);
            }
        }
        htmlSkipBlankChars(ctxt);
        if !(cons == (*ctxt).nbChars) { continue ; }
        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                     b"htmlParseStartTag: problem parsing attributes\n\x00" as
                         *const u8 as *const std::os::raw::c_char,
                     0 as *const xmlChar, 0 as *const xmlChar);
        break ;
    }
    /*
     * Handle specific association to the META tag
     */
    if meta != 0 && nbatts != 0 as std::os::raw::c_int { htmlCheckMeta(ctxt, atts); }
    /*
     * SAX: Start of Element !
     */
    if discardtag == 0 {
        htmlnamePush(ctxt, name);
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startElement.is_some() {
            if nbatts != 0 as std::os::raw::c_int {
                (*(*ctxt).sax).startElement.expect("non-null function pointer")((*ctxt).userData,
                                                                                name,
                                                                                atts);
            } else {
                (*(*ctxt).sax).startElement.expect("non-null function pointer")((*ctxt).userData,
                                                                                name,
                                                                                0
                                                                                    as
                                                                                    *mut *const xmlChar);
            }
        }
    }
    if !atts.is_null() {
        i = 1 as std::os::raw::c_int;
        while i < nbatts {
            if !(*atts.offset(i as isize)).is_null() {
                xmlFree.expect("non-null function pointer")(*atts.offset(i as
                                                                             isize)
                                                                as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            i += 2 as std::os::raw::c_int
        }
    }
    return discardtag;
}
/* *
 * htmlParseEndTag:
 * @ctxt:  an HTML parser context
 *
 * parse an end of tag
 *
 * [42] ETag ::= '</' Name S? '>'
 *
 * With namespace
 *
 * [NS 9] ETag ::= '</' QName S? '>'
 *
 * Returns 1 if the current level should be closed.
 */
unsafe extern "C" fn htmlParseEndTag(mut ctxt: htmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut oldname: *const xmlChar = 0 as *const xmlChar;
    let mut i: std::os::raw::c_int = 0;
    let mut ret: std::os::raw::c_int = 0;
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 ||
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '/' as i32 {
        htmlParseErr(ctxt, XML_ERR_LTSLASH_REQUIRED,
                     b"htmlParseEndTag: \'</\' not found\n\x00" as *const u8
                         as *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        return 0 as std::os::raw::c_int
    }
    (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
    (*(*ctxt).input).cur =
        (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
    (*(*ctxt).input).col += 2 as std::os::raw::c_int;
    name = htmlParseHTMLName(ctxt);
    if name.is_null() { return 0 as std::os::raw::c_int }
    /*
     * We should definitely be at the ending "S? '>'" part
     */
    htmlSkipBlankChars(ctxt);
    if !(0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
             *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
             *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
             0x20 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int) ||
           *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
        htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
                     b"End tag : expected \'>\'\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        if (*ctxt).recovery != 0 {
            /*
	     * We're not at the ending > !!
	     * Error, unless in recover mode where we search forwards
	     * until we find a >
	     */
            while *(*(*ctxt).input).cur as std::os::raw::c_int != '\u{0}' as i32 &&
                      *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
                xmlNextChar(ctxt);
            }
            xmlNextChar(ctxt);
        }
    } else { xmlNextChar(ctxt); }
    /*
     * if we ignored misplaced tags in htmlParseStartTag don't pop them
     * out now.
     */
    if (*ctxt).depth > 0 as std::os::raw::c_int &&
           (xmlStrEqual(name,
                        b"html\x00" as *const u8 as *const std::os::raw::c_char as
                            *mut xmlChar) != 0 ||
                xmlStrEqual(name,
                            b"body\x00" as *const u8 as *const std::os::raw::c_char as
                                *mut xmlChar) != 0 ||
                xmlStrEqual(name,
                            b"head\x00" as *const u8 as *const std::os::raw::c_char as
                                *mut xmlChar) != 0) {
        (*ctxt).depth -= 1;
        return 0 as std::os::raw::c_int
    }
    /*
     * If the name read is not one of the element in the parsing stack
     * then return, it's just an error.
     */
    i = (*ctxt).nameNr - 1 as std::os::raw::c_int;
    while i >= 0 as std::os::raw::c_int {
        if xmlStrEqual(name, *(*ctxt).nameTab.offset(i as isize)) != 0 {
            break ;
        }
        i -= 1
    }
    if i < 0 as std::os::raw::c_int {
        htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
                     b"Unexpected end tag : %s\n\x00" as *const u8 as
                         *const std::os::raw::c_char, name, 0 as *const xmlChar);
        return 0 as std::os::raw::c_int
    }
    /*
     * Check for auto-closure of HTML elements.
     */
    htmlAutoCloseOnClose(ctxt, name);
    /*
     * Well formedness constraints, opening and closing must match.
     * With the exception that the autoclose may have popped stuff out
     * of the stack.
     */
    if xmlStrEqual(name, (*ctxt).name) == 0 {
        if !(*ctxt).name.is_null() && xmlStrEqual((*ctxt).name, name) == 0 {
            htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
                         b"Opening and ending tag mismatch: %s and %s\n\x00"
                             as *const u8 as *const std::os::raw::c_char, name,
                         (*ctxt).name);
        }
    }
    /*
     * SAX: End of Tag
     */
    oldname = (*ctxt).name;
    if !oldname.is_null() && xmlStrEqual(oldname, name) != 0 {
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          name);
        }
        htmlNodeInfoPop(ctxt);
        htmlnamePop(ctxt);
        ret = 1 as std::os::raw::c_int
    } else { ret = 0 as std::os::raw::c_int }
    return ret;
}
/* *
 * htmlParseReference:
 * @ctxt:  an HTML parser context
 *
 * parse and handle entity references in content,
 * this will end-up in a call to character() since this is either a
 * CharRef, or a predefined entity.
 */
unsafe extern "C" fn htmlParseReference(mut ctxt: htmlParserCtxtPtr) {
    let mut ent: *const htmlEntityDesc = 0 as *const htmlEntityDesc;
    let mut out: [xmlChar; 6] = [0; 6];
    let mut name: *const xmlChar = 0 as *const xmlChar;
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '&' as i32 { return }
    if *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int
           == '#' as i32 {
        let mut c: std::os::raw::c_uint = 0;
        let mut bits: std::os::raw::c_int = 0;
        let mut i: std::os::raw::c_int = 0 as std::os::raw::c_int;
        c = htmlParseCharRef(ctxt) as std::os::raw::c_uint;
        if c == 0 as std::os::raw::c_int as std::os::raw::c_uint { return }
        if c < 0x80 as std::os::raw::c_int as std::os::raw::c_uint {
            let fresh50 = i;
            i = i + 1;
            out[fresh50 as usize] = c as xmlChar;
            bits = -(6 as std::os::raw::c_int)
        } else if c < 0x800 as std::os::raw::c_int as std::os::raw::c_uint {
            let fresh51 = i;
            i = i + 1;
            out[fresh51 as usize] =
                (c >> 6 as std::os::raw::c_int & 0x1f as std::os::raw::c_int as std::os::raw::c_uint |
                     0xc0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
            bits = 0 as std::os::raw::c_int
        } else if c < 0x10000 as std::os::raw::c_int as std::os::raw::c_uint {
            let fresh52 = i;
            i = i + 1;
            out[fresh52 as usize] =
                (c >> 12 as std::os::raw::c_int & 0xf as std::os::raw::c_int as std::os::raw::c_uint |
                     0xe0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
            bits = 6 as std::os::raw::c_int
        } else {
            let fresh53 = i;
            i = i + 1;
            out[fresh53 as usize] =
                (c >> 18 as std::os::raw::c_int & 0x7 as std::os::raw::c_int as std::os::raw::c_uint |
                     0xf0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
            bits = 12 as std::os::raw::c_int
        }
        while bits >= 0 as std::os::raw::c_int {
            let fresh54 = i;
            i = i + 1;
            out[fresh54 as usize] =
                (c >> bits & 0x3f as std::os::raw::c_int as std::os::raw::c_uint |
                     0x80 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
            bits -= 6 as std::os::raw::c_int
        }
        out[i as usize] = 0 as std::os::raw::c_int as xmlChar;
        htmlCheckParagraph(ctxt);
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).characters.is_some() {
            (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                          out.as_mut_ptr(),
                                                                          i);
        }
    } else {
        ent = htmlParseEntityRef(ctxt, &mut name);
        if name.is_null() {
            htmlCheckParagraph(ctxt);
            if !(*ctxt).sax.is_null() && (*(*ctxt).sax).characters.is_some() {
                (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                              b"&\x00"
                                                                                  as
                                                                                  *const u8
                                                                                  as
                                                                                  *const std::os::raw::c_char
                                                                                  as
                                                                                  *mut xmlChar,
                                                                              1
                                                                                  as
                                                                                  std::os::raw::c_int);
            }
            return
        }
        if ent.is_null() || !((*ent).value > 0 as std::os::raw::c_int as std::os::raw::c_uint)
           {
            htmlCheckParagraph(ctxt);
            if !(*ctxt).sax.is_null() && (*(*ctxt).sax).characters.is_some() {
                (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                              b"&\x00"
                                                                                  as
                                                                                  *const u8
                                                                                  as
                                                                                  *const std::os::raw::c_char
                                                                                  as
                                                                                  *mut xmlChar,
                                                                              1
                                                                                  as
                                                                                  std::os::raw::c_int);
                (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                              name,
                                                                              xmlStrlen(name));
                /* ctxt->sax->characters(ctxt->userData, BAD_CAST ";", 1); */
            }
        } else {
            let mut c_0: std::os::raw::c_uint = 0;
            let mut bits_0: std::os::raw::c_int = 0;
            let mut i_0: std::os::raw::c_int = 0 as std::os::raw::c_int;
            c_0 = (*ent).value;
            if c_0 < 0x80 as std::os::raw::c_int as std::os::raw::c_uint {
                let fresh55 = i_0;
                i_0 = i_0 + 1;
                out[fresh55 as usize] = c_0 as xmlChar;
                bits_0 = -(6 as std::os::raw::c_int)
            } else if c_0 < 0x800 as std::os::raw::c_int as std::os::raw::c_uint {
                let fresh56 = i_0;
                i_0 = i_0 + 1;
                out[fresh56 as usize] =
                    (c_0 >> 6 as std::os::raw::c_int &
                         0x1f as std::os::raw::c_int as std::os::raw::c_uint |
                         0xc0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                bits_0 = 0 as std::os::raw::c_int
            } else if c_0 < 0x10000 as std::os::raw::c_int as std::os::raw::c_uint {
                let fresh57 = i_0;
                i_0 = i_0 + 1;
                out[fresh57 as usize] =
                    (c_0 >> 12 as std::os::raw::c_int &
                         0xf as std::os::raw::c_int as std::os::raw::c_uint |
                         0xe0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                bits_0 = 6 as std::os::raw::c_int
            } else {
                let fresh58 = i_0;
                i_0 = i_0 + 1;
                out[fresh58 as usize] =
                    (c_0 >> 18 as std::os::raw::c_int &
                         0x7 as std::os::raw::c_int as std::os::raw::c_uint |
                         0xf0 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                bits_0 = 12 as std::os::raw::c_int
            }
            while bits_0 >= 0 as std::os::raw::c_int {
                let fresh59 = i_0;
                i_0 = i_0 + 1;
                out[fresh59 as usize] =
                    (c_0 >> bits_0 & 0x3f as std::os::raw::c_int as std::os::raw::c_uint |
                         0x80 as std::os::raw::c_int as std::os::raw::c_uint) as xmlChar;
                bits_0 -= 6 as std::os::raw::c_int
            }
            out[i_0 as usize] = 0 as std::os::raw::c_int as xmlChar;
            htmlCheckParagraph(ctxt);
            if !(*ctxt).sax.is_null() && (*(*ctxt).sax).characters.is_some() {
                (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                              out.as_mut_ptr(),
                                                                              i_0);
            }
        }
    };
}
/* *
 * htmlParseContent:
 * @ctxt:  an HTML parser context
 *
 * Parse a content: comment, sub-element, reference or text.
 * Kept for compatibility with old code
 */
unsafe extern "C" fn htmlParseContent(mut ctxt: htmlParserCtxtPtr) {
    let mut currentNode: *mut xmlChar = 0 as *mut xmlChar;
    let mut depth: std::os::raw::c_int = 0;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    currentNode = xmlStrdup((*ctxt).name);
    depth = (*ctxt).nameNr;
    loop  {
        let mut cons: std::os::raw::c_long = (*ctxt).nbChars;
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
            break ;
        }
        /*
	 * Our tag or one of it's parent or children is ending.
	 */
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '/' as i32 {
            if htmlParseEndTag(ctxt) != 0 &&
                   (!currentNode.is_null() ||
                        (*ctxt).nameNr == 0 as std::os::raw::c_int) {
                if !currentNode.is_null() {
                    xmlFree.expect("non-null function pointer")(currentNode as
                                                                    *mut std::os::raw::c_void);
                }
                return
            }
            /* while */
        } else {
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                   (0x41 as std::os::raw::c_int <=
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                        &&
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                            <= 0x5a as std::os::raw::c_int ||
                        0x61 as std::os::raw::c_int <=
                            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int &&
                            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int <= 0x7a as std::os::raw::c_int ||
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                            == '_' as i32 ||
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                            == ':' as i32) {
                name = htmlParseHTMLName_nonInvasive(ctxt);
                if name.is_null() {
                    htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
                                 b"htmlParseStartTag: invalid element name\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    /* Dump the bogus tag like browsers do */
                    while (0x9 as std::os::raw::c_int <=
                               *(*(*ctxt).input).cur as std::os::raw::c_int &&
                               *(*(*ctxt).input).cur as std::os::raw::c_int <=
                                   0xa as std::os::raw::c_int ||
                               *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                   0xd as std::os::raw::c_int ||
                               0x20 as std::os::raw::c_int <=
                                   *(*(*ctxt).input).cur as std::os::raw::c_int) &&
                              *(*(*ctxt).input).cur as std::os::raw::c_int !=
                                  '>' as i32 {
                        xmlNextChar(ctxt);
                    }
                    if !currentNode.is_null() {
                        xmlFree.expect("non-null function pointer")(currentNode
                                                                        as
                                                                        *mut std::os::raw::c_void);
                    }
                    return
                }
                if !(*ctxt).name.is_null() {
                    if htmlCheckAutoClose(name, (*ctxt).name) ==
                           1 as std::os::raw::c_int {
                        htmlAutoClose(ctxt, name);
                        continue ;
                    }
                }
            }
            /*
	 * Has this node been popped out during parsing of
	 * the next element
	 */
            if (*ctxt).nameNr > 0 as std::os::raw::c_int && depth >= (*ctxt).nameNr &&
                   xmlStrEqual(currentNode, (*ctxt).name) == 0 {
                if !currentNode.is_null() {
                    xmlFree.expect("non-null function pointer")(currentNode as
                                                                    *mut std::os::raw::c_void);
                }
                return
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                   (xmlStrEqual(currentNode,
                                b"script\x00" as *const u8 as
                                    *const std::os::raw::c_char as *mut xmlChar) != 0
                        ||
                        xmlStrEqual(currentNode,
                                    b"style\x00" as *const u8 as
                                        *const std::os::raw::c_char as *mut xmlChar)
                            != 0) {
                /*
	     * Handle SCRIPT/STYLE separately
	     */
                htmlParseScript(ctxt);
            } else {
                /*
	     * Sometimes DOCTYPE arrives in the middle of the document
	     */
                if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                       *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int == '!' as i32 &&
                       ({
                            let mut __res: std::os::raw::c_int = 0;
                            if ::std::mem::size_of::<xmlChar>() as
                                   std::os::raw::c_ulong >
                                   1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                if 0 != 0 {
                                    let mut __c: std::os::raw::c_int =
                                        *(*(*ctxt).input).cur.offset(2 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                                            as std::os::raw::c_int;
                                    __res =
                                        (if __c < -(128 as std::os::raw::c_int) ||
                                                __c > 255 as std::os::raw::c_int {
                                             __c
                                         } else {
                                             *(*__ctype_toupper_loc()).offset(__c
                                                                                  as
                                                                                  isize)
                                         })
                                } else {
                                    __res =
                                        toupper(*(*(*ctxt).input).cur.offset(2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 isize)
                                                    as std::os::raw::c_int)
                                }
                            } else {
                                __res =
                                    *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(2
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      isize)
                                                                         as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                            }
                            __res
                        }) == 'D' as i32 &&
                       ({
                            let mut __res: std::os::raw::c_int = 0;
                            if ::std::mem::size_of::<xmlChar>() as
                                   std::os::raw::c_ulong >
                                   1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                if 0 != 0 {
                                    let mut __c: std::os::raw::c_int =
                                        *(*(*ctxt).input).cur.offset(3 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                                            as std::os::raw::c_int;
                                    __res =
                                        (if __c < -(128 as std::os::raw::c_int) ||
                                                __c > 255 as std::os::raw::c_int {
                                             __c
                                         } else {
                                             *(*__ctype_toupper_loc()).offset(__c
                                                                                  as
                                                                                  isize)
                                         })
                                } else {
                                    __res =
                                        toupper(*(*(*ctxt).input).cur.offset(3
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 isize)
                                                    as std::os::raw::c_int)
                                }
                            } else {
                                __res =
                                    *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(3
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      isize)
                                                                         as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                            }
                            __res
                        }) == 'O' as i32 &&
                       ({
                            let mut __res: std::os::raw::c_int = 0;
                            if ::std::mem::size_of::<xmlChar>() as
                                   std::os::raw::c_ulong >
                                   1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                if 0 != 0 {
                                    let mut __c: std::os::raw::c_int =
                                        *(*(*ctxt).input).cur.offset(4 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                                            as std::os::raw::c_int;
                                    __res =
                                        (if __c < -(128 as std::os::raw::c_int) ||
                                                __c > 255 as std::os::raw::c_int {
                                             __c
                                         } else {
                                             *(*__ctype_toupper_loc()).offset(__c
                                                                                  as
                                                                                  isize)
                                         })
                                } else {
                                    __res =
                                        toupper(*(*(*ctxt).input).cur.offset(4
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 isize)
                                                    as std::os::raw::c_int)
                                }
                            } else {
                                __res =
                                    *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(4
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      isize)
                                                                         as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                            }
                            __res
                        }) == 'C' as i32 &&
                       ({
                            let mut __res: std::os::raw::c_int = 0;
                            if ::std::mem::size_of::<xmlChar>() as
                                   std::os::raw::c_ulong >
                                   1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                if 0 != 0 {
                                    let mut __c: std::os::raw::c_int =
                                        *(*(*ctxt).input).cur.offset(5 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                                            as std::os::raw::c_int;
                                    __res =
                                        (if __c < -(128 as std::os::raw::c_int) ||
                                                __c > 255 as std::os::raw::c_int {
                                             __c
                                         } else {
                                             *(*__ctype_toupper_loc()).offset(__c
                                                                                  as
                                                                                  isize)
                                         })
                                } else {
                                    __res =
                                        toupper(*(*(*ctxt).input).cur.offset(5
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 isize)
                                                    as std::os::raw::c_int)
                                }
                            } else {
                                __res =
                                    *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(5
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      isize)
                                                                         as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                            }
                            __res
                        }) == 'T' as i32 &&
                       ({
                            let mut __res: std::os::raw::c_int = 0;
                            if ::std::mem::size_of::<xmlChar>() as
                                   std::os::raw::c_ulong >
                                   1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                if 0 != 0 {
                                    let mut __c: std::os::raw::c_int =
                                        *(*(*ctxt).input).cur.offset(6 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                                            as std::os::raw::c_int;
                                    __res =
                                        (if __c < -(128 as std::os::raw::c_int) ||
                                                __c > 255 as std::os::raw::c_int {
                                             __c
                                         } else {
                                             *(*__ctype_toupper_loc()).offset(__c
                                                                                  as
                                                                                  isize)
                                         })
                                } else {
                                    __res =
                                        toupper(*(*(*ctxt).input).cur.offset(6
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 isize)
                                                    as std::os::raw::c_int)
                                }
                            } else {
                                __res =
                                    *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(6
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      isize)
                                                                         as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                            }
                            __res
                        }) == 'Y' as i32 &&
                       ({
                            let mut __res: std::os::raw::c_int = 0;
                            if ::std::mem::size_of::<xmlChar>() as
                                   std::os::raw::c_ulong >
                                   1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                if 0 != 0 {
                                    let mut __c: std::os::raw::c_int =
                                        *(*(*ctxt).input).cur.offset(7 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                                            as std::os::raw::c_int;
                                    __res =
                                        (if __c < -(128 as std::os::raw::c_int) ||
                                                __c > 255 as std::os::raw::c_int {
                                             __c
                                         } else {
                                             *(*__ctype_toupper_loc()).offset(__c
                                                                                  as
                                                                                  isize)
                                         })
                                } else {
                                    __res =
                                        toupper(*(*(*ctxt).input).cur.offset(7
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 isize)
                                                    as std::os::raw::c_int)
                                }
                            } else {
                                __res =
                                    *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(7
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      isize)
                                                                         as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                            }
                            __res
                        }) == 'P' as i32 &&
                       ({
                            let mut __res: std::os::raw::c_int = 0;
                            if ::std::mem::size_of::<xmlChar>() as
                                   std::os::raw::c_ulong >
                                   1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                if 0 != 0 {
                                    let mut __c: std::os::raw::c_int =
                                        *(*(*ctxt).input).cur.offset(8 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                                            as std::os::raw::c_int;
                                    __res =
                                        (if __c < -(128 as std::os::raw::c_int) ||
                                                __c > 255 as std::os::raw::c_int {
                                             __c
                                         } else {
                                             *(*__ctype_toupper_loc()).offset(__c
                                                                                  as
                                                                                  isize)
                                         })
                                } else {
                                    __res =
                                        toupper(*(*(*ctxt).input).cur.offset(8
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 isize)
                                                    as std::os::raw::c_int)
                                }
                            } else {
                                __res =
                                    *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(8
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      isize)
                                                                         as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                            }
                            __res
                        }) == 'E' as i32 {
                    htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
                                 b"Misplaced DOCTYPE declaration\n\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 b"DOCTYPE\x00" as *const u8 as
                                     *const std::os::raw::c_char as *mut xmlChar,
                                 0 as *const xmlChar);
                    htmlParseDocTypeDecl(ctxt);
                }
                /*
	     * First case :  a comment
	     */
                if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                       *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int == '!' as i32 &&
                       *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int == '-' as i32 &&
                       *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int == '-' as i32 {
                    htmlParseComment(ctxt);
                } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32
                              &&
                              *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == '?' as i32 {
                    htmlParsePI(ctxt);
                } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 {
                    htmlParseElement(ctxt);
                } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '&' as i32 {
                    htmlParseReference(ctxt);
                } else if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                              0 as std::os::raw::c_int {
                    htmlAutoCloseOnEnd(ctxt);
                    break ;
                } else {
                    /*
	     * Second case : a Processing Instruction.
	     */
                    /*
	     * Third case :  a sub-element.
	     */
                    /*
	     * Fourth case : a reference. If if has not been resolved,
	     *    parsing returns it's Name, create the node
	     */
                    /*
	     * Fifth case : end of the resource
	     */
                    /*
	     * Last case, text. Note that References are handled directly.
	     */
                    htmlParseCharData(ctxt);
                }
                if cons == (*ctxt).nbChars {
                    if !(*ctxt).node.is_null() {
                        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                     b"detected an error in element content\n\x00"
                                         as *const u8 as *const std::os::raw::c_char,
                                     0 as *const xmlChar,
                                     0 as *const xmlChar);
                    }
                    break ;
                }
            }
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
        }
    }
    if !currentNode.is_null() {
        xmlFree.expect("non-null function pointer")(currentNode as
                                                        *mut std::os::raw::c_void);
    };
}
/* *
 * htmlParseElement:
 * @ctxt:  an HTML parser context
 *
 * parse an HTML element, this is highly recursive
 * this is kept for compatibility with previous code versions
 *
 * [39] element ::= EmptyElemTag | STag content ETag
 *
 * [41] Attribute ::= Name Eq AttValue
 */
#[no_mangle]
pub unsafe extern "C" fn htmlParseElement(mut ctxt: htmlParserCtxtPtr) {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut currentNode: *mut xmlChar = 0 as *mut xmlChar;
    let mut info: *const htmlElemDesc = 0 as *const htmlElemDesc;
    let mut node_info: htmlParserNodeInfo =
        htmlParserNodeInfo{node: 0 as *const _xmlNode,
                           begin_pos: 0,
                           begin_line: 0,
                           end_pos: 0,
                           end_line: 0,};
    let mut failed: std::os::raw::c_int = 0;
    let mut depth: std::os::raw::c_int = 0;
    let mut oldptr: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || (*ctxt).input.is_null() {
        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                     b"htmlParseElement: context error\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        return
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    /* Capture start position */
    if (*ctxt).record_info != 0 {
        node_info.begin_pos =
            (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                       as std::os::raw::c_long as
                                                       std::os::raw::c_ulong);
        node_info.begin_line = (*(*ctxt).input).line as std::os::raw::c_ulong
    }
    failed = htmlParseStartTag(ctxt);
    name = (*ctxt).name;
    if failed == -(1 as std::os::raw::c_int) || name.is_null() {
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
            xmlNextChar(ctxt);
        }
        return
    }
    /*
     * Lookup the info for that element.
     */
    info = htmlTagLookup(name);
    if info.is_null() {
        htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
                     b"Tag %s invalid\n\x00" as *const u8 as
                         *const std::os::raw::c_char, name, 0 as *const xmlChar);
    }
    /*
     * Check for an Empty Element labeled the XML/SGML way
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '/' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '>' as i32 {
        (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 2 as std::os::raw::c_int;
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          name);
        }
        htmlnamePop(ctxt);
        return
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
        xmlNextChar(ctxt);
    } else {
        htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
                     b"Couldn\'t find end of Start Tag %s\n\x00" as *const u8
                         as *const std::os::raw::c_char, name, 0 as *const xmlChar);
        /*
	 * end of parsing of this node.
	 */
        if xmlStrEqual(name, (*ctxt).name) != 0 {
            nodePop(ctxt);
            htmlnamePop(ctxt);
        }
        /*
	 * Capture end position and add node
	 */
        if (*ctxt).record_info != 0 {
            node_info.end_pos =
                (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                           as std::os::raw::c_long as
                                                           std::os::raw::c_ulong);
            node_info.end_line = (*(*ctxt).input).line as std::os::raw::c_ulong;
            node_info.node = (*ctxt).node as *const _xmlNode;
            xmlParserAddNodeInfo(ctxt, &mut node_info);
        }
        return
    }
    /*
     * Check for an Empty Element from DTD definition
     */
    if !info.is_null() && (*info).empty as std::os::raw::c_int != 0 {
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          name);
        }
        htmlnamePop(ctxt);
        return
    }
    /*
     * Parse the content of the element:
     */
    currentNode = xmlStrdup((*ctxt).name);
    depth = (*ctxt).nameNr;
    while 0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
              *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
              *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
              0x20 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int {
        oldptr = (*(*ctxt).input).cur;
        htmlParseContent(ctxt);
        if oldptr == (*(*ctxt).input).cur { break ; }
        if (*ctxt).nameNr < depth { break ; }
    }
    /*
     * Capture end position and add node
     */
    if !currentNode.is_null() && (*ctxt).record_info != 0 {
        node_info.end_pos =
            (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                       as std::os::raw::c_long as
                                                       std::os::raw::c_ulong);
        node_info.end_line = (*(*ctxt).input).line as std::os::raw::c_ulong;
        node_info.node = (*ctxt).node as *const _xmlNode;
        xmlParserAddNodeInfo(ctxt, &mut node_info);
    }
    if !(0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
             *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
             *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
             0x20 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int) {
        htmlAutoCloseOnEnd(ctxt);
    }
    if !currentNode.is_null() {
        xmlFree.expect("non-null function pointer")(currentNode as
                                                        *mut std::os::raw::c_void);
    };
}
unsafe extern "C" fn htmlParserFinishElementParsing(mut ctxt:
                                                        htmlParserCtxtPtr) {
    /*
     * Capture end position and add node
     */
    if !(*ctxt).node.is_null() && (*ctxt).record_info != 0 {
        (*(*ctxt).nodeInfo).end_pos =
            (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                       as std::os::raw::c_long as
                                                       std::os::raw::c_ulong);
        (*(*ctxt).nodeInfo).end_line = (*(*ctxt).input).line as std::os::raw::c_ulong;
        (*(*ctxt).nodeInfo).node = (*ctxt).node as *const _xmlNode;
        xmlParserAddNodeInfo(ctxt, (*ctxt).nodeInfo);
        htmlNodeInfoPop(ctxt);
    }
    if !(0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
             *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
             *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
             0x20 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int) {
        htmlAutoCloseOnEnd(ctxt);
    };
}
/* *
 * htmlParseElementInternal:
 * @ctxt:  an HTML parser context
 *
 * parse an HTML element, new version, non recursive
 *
 * [39] element ::= EmptyElemTag | STag content ETag
 *
 * [41] Attribute ::= Name Eq AttValue
 */
unsafe extern "C" fn htmlParseElementInternal(mut ctxt: htmlParserCtxtPtr) {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut info: *const htmlElemDesc = 0 as *const htmlElemDesc;
    let mut node_info: htmlParserNodeInfo =
        {
            let mut init =
                _xmlParserNodeInfo{node: 0 as *const _xmlNode,
                                   begin_pos:
                                       0 as std::os::raw::c_int as std::os::raw::c_ulong,
                                   begin_line:
                                       0 as std::os::raw::c_int as std::os::raw::c_ulong,
                                   end_pos: 0 as std::os::raw::c_int as std::os::raw::c_ulong,
                                   end_line:
                                       0 as std::os::raw::c_int as std::os::raw::c_ulong,};
            init
        };
    let mut failed: std::os::raw::c_int = 0;
    if ctxt.is_null() || (*ctxt).input.is_null() {
        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                     b"htmlParseElementInternal: context error\n\x00" as
                         *const u8 as *const std::os::raw::c_char,
                     0 as *const xmlChar, 0 as *const xmlChar);
        return
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    /* Capture start position */
    if (*ctxt).record_info != 0 {
        node_info.begin_pos =
            (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                       as std::os::raw::c_long as
                                                       std::os::raw::c_ulong);
        node_info.begin_line = (*(*ctxt).input).line as std::os::raw::c_ulong
    }
    failed = htmlParseStartTag(ctxt);
    name = (*ctxt).name;
    if failed == -(1 as std::os::raw::c_int) || name.is_null() {
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
            xmlNextChar(ctxt);
        }
        return
    }
    /*
     * Lookup the info for that element.
     */
    info = htmlTagLookup(name);
    if info.is_null() {
        htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
                     b"Tag %s invalid\n\x00" as *const u8 as
                         *const std::os::raw::c_char, name, 0 as *const xmlChar);
    }
    /*
     * Check for an Empty Element labeled the XML/SGML way
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '/' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '>' as i32 {
        (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 2 as std::os::raw::c_int;
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          name);
        }
        htmlnamePop(ctxt);
        return
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
        xmlNextChar(ctxt);
    } else {
        htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
                     b"Couldn\'t find end of Start Tag %s\n\x00" as *const u8
                         as *const std::os::raw::c_char, name, 0 as *const xmlChar);
        /*
	 * end of parsing of this node.
	 */
        if xmlStrEqual(name, (*ctxt).name) != 0 {
            nodePop(ctxt);
            htmlnamePop(ctxt);
        }
        if (*ctxt).record_info != 0 {
            htmlNodeInfoPush(ctxt, &mut node_info);
        }
        htmlParserFinishElementParsing(ctxt);
        return
    }
    /*
     * Check for an Empty Element from DTD definition
     */
    if !info.is_null() && (*info).empty as std::os::raw::c_int != 0 {
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          name);
        }
        htmlnamePop(ctxt);
        return
    }
    if (*ctxt).record_info != 0 { htmlNodeInfoPush(ctxt, &mut node_info); };
}
/* *
 * htmlParseContentInternal:
 * @ctxt:  an HTML parser context
 *
 * Parse a content: comment, sub-element, reference or text.
 * New version for non recursive htmlParseElementInternal
 */
unsafe extern "C" fn htmlParseContentInternal(mut ctxt: htmlParserCtxtPtr) {
    let mut currentNode: *mut xmlChar = 0 as *mut xmlChar;
    let mut depth: std::os::raw::c_int = 0;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    currentNode = xmlStrdup((*ctxt).name);
    depth = (*ctxt).nameNr;
    loop  {
        let mut cons: std::os::raw::c_long = (*ctxt).nbChars;
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
            break ;
        }
        /*
	 * Our tag or one of it's parent or children is ending.
	 */
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '/' as i32 {
            if htmlParseEndTag(ctxt) != 0 &&
                   (!currentNode.is_null() ||
                        (*ctxt).nameNr == 0 as std::os::raw::c_int) {
                if !currentNode.is_null() {
                    xmlFree.expect("non-null function pointer")(currentNode as
                                                                    *mut std::os::raw::c_void);
                }
                currentNode = xmlStrdup((*ctxt).name);
                depth = (*ctxt).nameNr
            }
            /* while */
        } else {
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                   (0x41 as std::os::raw::c_int <=
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                        &&
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                            <= 0x5a as std::os::raw::c_int ||
                        0x61 as std::os::raw::c_int <=
                            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int &&
                            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int <= 0x7a as std::os::raw::c_int ||
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                            == '_' as i32 ||
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                            == ':' as i32) {
                name = htmlParseHTMLName_nonInvasive(ctxt);
                if name.is_null() {
                    htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
                                 b"htmlParseStartTag: invalid element name\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    /* Dump the bogus tag like browsers do */
                    while (0x9 as std::os::raw::c_int <=
                               *(*(*ctxt).input).cur as std::os::raw::c_int &&
                               *(*(*ctxt).input).cur as std::os::raw::c_int <=
                                   0xa as std::os::raw::c_int ||
                               *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                   0xd as std::os::raw::c_int ||
                               0x20 as std::os::raw::c_int <=
                                   *(*(*ctxt).input).cur as std::os::raw::c_int) &&
                              *(*(*ctxt).input).cur as std::os::raw::c_int !=
                                  '>' as i32 {
                        xmlNextChar(ctxt);
                    }
                    htmlParserFinishElementParsing(ctxt);
                    if !currentNode.is_null() {
                        xmlFree.expect("non-null function pointer")(currentNode
                                                                        as
                                                                        *mut std::os::raw::c_void);
                    }
                    currentNode = xmlStrdup((*ctxt).name);
                    depth = (*ctxt).nameNr;
                    continue ;
                } else if !(*ctxt).name.is_null() {
                    if htmlCheckAutoClose(name, (*ctxt).name) ==
                           1 as std::os::raw::c_int {
                        htmlAutoClose(ctxt, name);
                        continue ;
                    }
                }
            }
            /*
	 * Has this node been popped out during parsing of
	 * the next element
	 */
            if (*ctxt).nameNr > 0 as std::os::raw::c_int && depth >= (*ctxt).nameNr &&
                   xmlStrEqual(currentNode, (*ctxt).name) == 0 {
                htmlParserFinishElementParsing(ctxt);
                if !currentNode.is_null() {
                    xmlFree.expect("non-null function pointer")(currentNode as
                                                                    *mut std::os::raw::c_void);
                }
                currentNode = xmlStrdup((*ctxt).name);
                depth = (*ctxt).nameNr
            } else {
                if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                       (xmlStrEqual(currentNode,
                                    b"script\x00" as *const u8 as
                                        *const std::os::raw::c_char as *mut xmlChar)
                            != 0 ||
                            xmlStrEqual(currentNode,
                                        b"style\x00" as *const u8 as
                                            *const std::os::raw::c_char as
                                            *mut xmlChar) != 0) {
                    /*
	     * Handle SCRIPT/STYLE separately
	     */
                    htmlParseScript(ctxt);
                } else {
                    /*
	     * Sometimes DOCTYPE arrives in the middle of the document
	     */
                    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                            isize) as
                               std::os::raw::c_int == '!' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(2 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(2
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(2
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'D' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(3 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(3
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(3
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'O' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(4 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(4
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(4
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'C' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(5 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(5
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(5
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'T' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(6 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(6
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(6
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'Y' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(7 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(7
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(7
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'P' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(8 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(8
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(8
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'E' as i32 {
                        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
                                     b"Misplaced DOCTYPE declaration\n\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"DOCTYPE\x00" as *const u8 as
                                         *const std::os::raw::c_char as *mut xmlChar,
                                     0 as *const xmlChar);
                        htmlParseDocTypeDecl(ctxt);
                    }
                    /*
	     * First case :  a comment
	     */
                    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                            isize) as
                               std::os::raw::c_int == '!' as i32 &&
                           *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                            isize) as
                               std::os::raw::c_int == '-' as i32 &&
                           *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                            isize) as
                               std::os::raw::c_int == '-' as i32 {
                        htmlParseComment(ctxt);
                    } else if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                  '<' as i32 &&
                                  *(*(*ctxt).input).cur.offset(1 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == '?' as i32 {
                        htmlParsePI(ctxt);
                    } else if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                  '<' as i32 {
                        htmlParseElementInternal(ctxt);
                        if !currentNode.is_null() {
                            xmlFree.expect("non-null function pointer")(currentNode
                                                                            as
                                                                            *mut std::os::raw::c_void);
                        }
                        currentNode = xmlStrdup((*ctxt).name);
                        depth = (*ctxt).nameNr
                    } else if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                  '&' as i32 {
                        htmlParseReference(ctxt);
                    } else if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                  0 as std::os::raw::c_int {
                        htmlAutoCloseOnEnd(ctxt);
                        break ;
                    } else {
                        /*
	     * Second case : a Processing Instruction.
	     */
                        /*
	     * Third case :  a sub-element.
	     */
                        /*
	     * Fourth case : a reference. If if has not been resolved,
	     *    parsing returns it's Name, create the node
	     */
                        /*
	     * Fifth case : end of the resource
	     */
                        /*
	     * Last case, text. Note that References are handled directly.
	     */
                        htmlParseCharData(ctxt);
                    }
                    if cons == (*ctxt).nbChars {
                        if !(*ctxt).node.is_null() {
                            htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                         b"detected an error in element content\n\x00"
                                             as *const u8 as
                                             *const std::os::raw::c_char,
                                         0 as *const xmlChar,
                                         0 as *const xmlChar);
                        }
                        break ;
                    }
                }
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
            }
        }
    }
    if !currentNode.is_null() {
        xmlFree.expect("non-null function pointer")(currentNode as
                                                        *mut std::os::raw::c_void);
    };
}
/* *
 * htmlParseContent:
 * @ctxt:  an HTML parser context
 *
 * Parse a content: comment, sub-element, reference or text.
 * This is the entry point when called from parser.c
 */
#[no_mangle]
pub unsafe extern "C" fn __htmlParseContent(mut ctxt: *mut std::os::raw::c_void) {
    if !ctxt.is_null() {
        htmlParseContentInternal(ctxt as htmlParserCtxtPtr);
    };
}
/* *
 * htmlParseDocument:
 * @ctxt:  an HTML parser context
 *
 * parse an HTML document (and build a tree if using the standard SAX
 * interface).
 *
 * Returns 0, -1 in case of error. the parser context is augmented
 *                as a result of the parsing.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlParseDocument(mut ctxt: htmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut start: [xmlChar; 4] = [0; 4];
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    xmlInitParser();
    htmlDefaultSAXHandlerInit();
    if ctxt.is_null() || (*ctxt).input.is_null() {
        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                     b"htmlParseDocument: context error\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        return XML_ERR_INTERNAL_ERROR as std::os::raw::c_int
    }
    (*ctxt).html = 1 as std::os::raw::c_int;
    (*ctxt).linenumbers = 1 as std::os::raw::c_int;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    /*
     * SAX: beginning of the document processing.
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).setDocumentLocator.is_some() {
        (*(*ctxt).sax).setDocumentLocator.expect("non-null function pointer")((*ctxt).userData,
                                                                              __xmlDefaultSAXLocator());
    }
    if (*ctxt).encoding.is_null() &&
           (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
               std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
        /*
	 * Get the 4 first bytes and decode the charset
	 * if enc != XML_CHAR_ENCODING_NONE
	 * plug some encoding conversion routines.
	 */
        start[0 as std::os::raw::c_int as usize] =
            if (*ctxt).token != 0 {
                -(1 as std::os::raw::c_int)
            } else { *(*(*ctxt).input).cur as std::os::raw::c_int } as xmlChar;
        start[1 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
        start[2 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        start[3 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
        enc =
            xmlDetectCharEncoding(&mut *start.as_mut_ptr().offset(0 as
                                                                      std::os::raw::c_int
                                                                      as
                                                                      isize),
                                  4 as std::os::raw::c_int);
        if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
            xmlSwitchEncoding(ctxt, enc);
        }
    }
    /*
     * Wipe out everything which is before the first '<'
     */
    htmlSkipBlankChars(ctxt);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        htmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,
                     b"Document is empty\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
    }
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startDocument.is_some() &&
           (*ctxt).disableSAX == 0 {
        (*(*ctxt).sax).startDocument.expect("non-null function pointer")((*ctxt).userData);
    }
    /*
     * Parse possible comments and PIs before any content
     */
    while *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
              *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == '!' as i32 &&
              *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == '-' as i32 &&
              *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == '-' as i32 ||
              *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                  *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                      std::os::raw::c_int == '?' as i32 {
        htmlParseComment(ctxt);
        htmlParsePI(ctxt);
        htmlSkipBlankChars(ctxt);
    }
    /*
     * Then possibly doc type declaration(s) and more Misc
     * (doctypedecl Misc*)?
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '!' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(2 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(2
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'D' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(3 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(3
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'O' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(4 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(4 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(4
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'C' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(5 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(5
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'T' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(6 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(6
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'Y' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(7 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(7 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(7
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'P' as i32 &&
           ({
                let mut __res: std::os::raw::c_int = 0;
                if ::std::mem::size_of::<xmlChar>() as std::os::raw::c_ulong >
                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if 0 != 0 {
                        let mut __c: std::os::raw::c_int =
                            *(*(*ctxt).input).cur.offset(8 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int;
                        __res =
                            (if __c < -(128 as std::os::raw::c_int) ||
                                    __c > 255 as std::os::raw::c_int {
                                 __c
                             } else {
                                 *(*__ctype_toupper_loc()).offset(__c as
                                                                      isize)
                             })
                    } else {
                        __res =
                            toupper(*(*(*ctxt).input).cur.offset(8 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int)
                    }
                } else {
                    __res =
                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(8
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                                                             as std::os::raw::c_int as
                                                             isize)
                }
                __res
            }) == 'E' as i32 {
        htmlParseDocTypeDecl(ctxt);
    }
    htmlSkipBlankChars(ctxt);
    /*
     * Parse possible comments and PIs before any content
     */
    while *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
              *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == '!' as i32 &&
              *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == '-' as i32 &&
              *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == '-' as i32 ||
              *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                  *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                      std::os::raw::c_int == '?' as i32 {
        htmlParseComment(ctxt);
        htmlParsePI(ctxt);
        htmlSkipBlankChars(ctxt);
    }
    /*
     * Time to start parsing the tree itself
     */
    htmlParseContentInternal(ctxt);
    /*
     * autoclose
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        htmlAutoCloseOnEnd(ctxt);
    }
    /*
     * SAX: end of the document processing.
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endDocument.is_some() {
        (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
    }
    if (*ctxt).options & HTML_PARSE_NODEFDTD as std::os::raw::c_int == 0 &&
           !(*ctxt).myDoc.is_null() {
        dtd = xmlGetIntSubset((*ctxt).myDoc as *const xmlDoc);
        if dtd.is_null() {
            (*(*ctxt).myDoc).intSubset =
                xmlCreateIntSubset((*ctxt).myDoc,
                                   b"html\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar,
                                   b"-//W3C//DTD HTML 4.0 Transitional//EN\x00"
                                       as *const u8 as *const std::os::raw::c_char as
                                       *mut xmlChar,
                                   b"http://www.w3.org/TR/REC-html40/loose.dtd\x00"
                                       as *const u8 as *const std::os::raw::c_char as
                                       *mut xmlChar)
        }
    }
    if (*ctxt).wellFormed == 0 { return -(1 as std::os::raw::c_int) }
    return 0 as std::os::raw::c_int;
}
/* ***********************************************************************
 *									*
 *			Parser contexts handling			*
 *									*
 ************************************************************************/
/* *
 * htmlInitParserCtxt:
 * @ctxt:  an HTML parser context
 *
 * Initialize a parser context
 *
 * Returns 0 in case of success and -1 in case of error
 */
unsafe extern "C" fn htmlInitParserCtxt(mut ctxt: htmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut sax: *mut htmlSAXHandler = 0 as *mut htmlSAXHandler;
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    memset(ctxt as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<htmlParserCtxt>() as std::os::raw::c_ulong);
    (*ctxt).dict = xmlDictCreate();
    if (*ctxt).dict.is_null() {
        htmlErrMemory(0 as xmlParserCtxtPtr,
                      b"htmlInitParserCtxt: out of memory\n\x00" as *const u8
                          as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    sax =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<htmlSAXHandler>()
                                                          as std::os::raw::c_ulong) as
            *mut htmlSAXHandler;
    if sax.is_null() {
        htmlErrMemory(0 as xmlParserCtxtPtr,
                      b"htmlInitParserCtxt: out of memory\n\x00" as *const u8
                          as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    } else {
        memset(sax as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
               ::std::mem::size_of::<htmlSAXHandler>() as std::os::raw::c_ulong);
    }
    /* Allocate the Input stack */
    (*ctxt).inputTab =
        xmlMalloc.expect("non-null function pointer")((5 as std::os::raw::c_int as
                                                           std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<htmlParserInputPtr>()
                                                                                           as
                                                                                           std::os::raw::c_ulong))
            as *mut htmlParserInputPtr;
    if (*ctxt).inputTab.is_null() {
        htmlErrMemory(0 as xmlParserCtxtPtr,
                      b"htmlInitParserCtxt: out of memory\n\x00" as *const u8
                          as *const std::os::raw::c_char);
        (*ctxt).inputNr = 0 as std::os::raw::c_int;
        (*ctxt).inputMax = 0 as std::os::raw::c_int;
        (*ctxt).input = 0 as xmlParserInputPtr;
        return -(1 as std::os::raw::c_int)
    }
    (*ctxt).inputNr = 0 as std::os::raw::c_int;
    (*ctxt).inputMax = 5 as std::os::raw::c_int;
    (*ctxt).input = 0 as xmlParserInputPtr;
    (*ctxt).version = 0 as *const xmlChar;
    (*ctxt).encoding = 0 as *const xmlChar;
    (*ctxt).standalone = -(1 as std::os::raw::c_int);
    (*ctxt).instate = XML_PARSER_START;
    /* Allocate the Node stack */
    (*ctxt).nodeTab =
        xmlMalloc.expect("non-null function pointer")((10 as std::os::raw::c_int as
                                                           std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<htmlNodePtr>()
                                                                                           as
                                                                                           std::os::raw::c_ulong))
            as *mut htmlNodePtr;
    if (*ctxt).nodeTab.is_null() {
        htmlErrMemory(0 as xmlParserCtxtPtr,
                      b"htmlInitParserCtxt: out of memory\n\x00" as *const u8
                          as *const std::os::raw::c_char);
        (*ctxt).nodeNr = 0 as std::os::raw::c_int;
        (*ctxt).nodeMax = 0 as std::os::raw::c_int;
        (*ctxt).node = 0 as xmlNodePtr;
        (*ctxt).inputNr = 0 as std::os::raw::c_int;
        (*ctxt).inputMax = 0 as std::os::raw::c_int;
        (*ctxt).input = 0 as xmlParserInputPtr;
        return -(1 as std::os::raw::c_int)
    }
    (*ctxt).nodeNr = 0 as std::os::raw::c_int;
    (*ctxt).nodeMax = 10 as std::os::raw::c_int;
    (*ctxt).node = 0 as xmlNodePtr;
    /* Allocate the Name stack */
    (*ctxt).nameTab =
        xmlMalloc.expect("non-null function pointer")((10 as std::os::raw::c_int as
                                                           std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlChar>()
                                                                                           as
                                                                                           std::os::raw::c_ulong))
            as *mut *const xmlChar;
    if (*ctxt).nameTab.is_null() {
        htmlErrMemory(0 as xmlParserCtxtPtr,
                      b"htmlInitParserCtxt: out of memory\n\x00" as *const u8
                          as *const std::os::raw::c_char);
        (*ctxt).nameNr = 0 as std::os::raw::c_int;
        (*ctxt).nameMax = 0 as std::os::raw::c_int;
        (*ctxt).name = 0 as *const xmlChar;
        (*ctxt).nodeNr = 0 as std::os::raw::c_int;
        (*ctxt).nodeMax = 0 as std::os::raw::c_int;
        (*ctxt).node = 0 as xmlNodePtr;
        (*ctxt).inputNr = 0 as std::os::raw::c_int;
        (*ctxt).inputMax = 0 as std::os::raw::c_int;
        (*ctxt).input = 0 as xmlParserInputPtr;
        return -(1 as std::os::raw::c_int)
    }
    (*ctxt).nameNr = 0 as std::os::raw::c_int;
    (*ctxt).nameMax = 10 as std::os::raw::c_int;
    (*ctxt).name = 0 as *const xmlChar;
    (*ctxt).nodeInfoTab = 0 as *mut xmlParserNodeInfo;
    (*ctxt).nodeInfoNr = 0 as std::os::raw::c_int;
    (*ctxt).nodeInfoMax = 0 as std::os::raw::c_int;
    if sax.is_null() {
        (*ctxt).sax = __htmlDefaultSAXHandler() as xmlSAXHandlerPtr
    } else {
        (*ctxt).sax = sax;
        memcpy(sax as *mut std::os::raw::c_void,
               __htmlDefaultSAXHandler() as *const std::os::raw::c_void,
               ::std::mem::size_of::<xmlSAXHandlerV1>() as std::os::raw::c_ulong);
    }
    (*ctxt).userData = ctxt as *mut std::os::raw::c_void;
    (*ctxt).myDoc = 0 as xmlDocPtr;
    (*ctxt).wellFormed = 1 as std::os::raw::c_int;
    (*ctxt).replaceEntities = 0 as std::os::raw::c_int;
    (*ctxt).linenumbers = *__xmlLineNumbersDefaultValue();
    (*ctxt).keepBlanks = *__xmlKeepBlanksDefaultValue();
    (*ctxt).html = 1 as std::os::raw::c_int;
    (*ctxt).vctxt.finishDtd = 0xabcd1234 as std::os::raw::c_uint;
    (*ctxt).vctxt.userData = ctxt as *mut std::os::raw::c_void;
    (*ctxt).vctxt.error =
        Some(xmlParserValidityError as
                 unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                      _: *const std::os::raw::c_char, _: ...) -> ());
    (*ctxt).vctxt.warning =
        Some(xmlParserValidityWarning as
                 unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                      _: *const std::os::raw::c_char, _: ...) -> ());
    (*ctxt).record_info = 0 as std::os::raw::c_int;
    (*ctxt).validate = 0 as std::os::raw::c_int;
    (*ctxt).nbChars = 0 as std::os::raw::c_int as std::os::raw::c_long;
    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long;
    (*ctxt).catalogs = 0 as *mut std::os::raw::c_void;
    xmlInitNodeInfoSeq(&mut (*ctxt).node_seq);
    return 0 as std::os::raw::c_int;
}
/* LIBXML_PUSH_ENABLED */
/* *
 * htmlFreeParserCtxt:
 * @ctxt:  an HTML parser context
 *
 * Free all the memory used by a parser context. However the parsed
 * document in ctxt->myDoc is not freed.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlFreeParserCtxt(mut ctxt: htmlParserCtxtPtr) {
    xmlFreeParserCtxt(ctxt);
}
/* *
 * htmlNewParserCtxt:
 *
 * Allocate and initialize a new parser context.
 *
 * Returns the htmlParserCtxtPtr or NULL in case of allocation error
 */
#[no_mangle]
pub unsafe extern "C" fn htmlNewParserCtxt() -> htmlParserCtxtPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    ctxt =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlParserCtxt>()
                                                          as std::os::raw::c_ulong) as
            xmlParserCtxtPtr;
    if ctxt.is_null() {
        htmlErrMemory(0 as xmlParserCtxtPtr,
                      b"NewParserCtxt: out of memory\n\x00" as *const u8 as
                          *const std::os::raw::c_char);
        return 0 as htmlParserCtxtPtr
    }
    memset(ctxt as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlParserCtxt>() as std::os::raw::c_ulong);
    if htmlInitParserCtxt(ctxt) < 0 as std::os::raw::c_int {
        htmlFreeParserCtxt(ctxt);
        return 0 as htmlParserCtxtPtr
    }
    return ctxt;
}
/* *
 * htmlCreateMemoryParserCtxt:
 * @buffer:  a pointer to a char array
 * @size:  the size of the array
 *
 * Create a parser context for an HTML in-memory document.
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCreateMemoryParserCtxt(mut buffer:
                                                        *const std::os::raw::c_char,
                                                    mut size: std::os::raw::c_int)
 -> htmlParserCtxtPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    if buffer.is_null() { return 0 as htmlParserCtxtPtr }
    if size <= 0 as std::os::raw::c_int { return 0 as htmlParserCtxtPtr }
    ctxt = htmlNewParserCtxt();
    if ctxt.is_null() { return 0 as htmlParserCtxtPtr }
    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
    if buf.is_null() { return 0 as htmlParserCtxtPtr }
    input = xmlNewInputStream(ctxt);
    if input.is_null() {
        xmlFreeParserCtxt(ctxt);
        return 0 as htmlParserCtxtPtr
    }
    (*input).filename = 0 as *const std::os::raw::c_char;
    (*input).buf = buf;
    xmlBufResetInput((*buf).buffer, input);
    inputPush(ctxt, input);
    return ctxt;
}
/* *
 * htmlCreateDocParserCtxt:
 * @cur:  a pointer to an array of xmlChar
 * @encoding:  a free form C string describing the HTML document encoding, or NULL
 *
 * Create a parser context for an HTML document.
 *
 * TODO: check the need to add encoding handling there
 *
 * Returns the new parser context or NULL
 */
unsafe extern "C" fn htmlCreateDocParserCtxt(mut cur: *const xmlChar,
                                             mut encoding:
                                                 *const std::os::raw::c_char)
 -> htmlParserCtxtPtr {
    let mut len: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    if cur.is_null() { return 0 as htmlParserCtxtPtr }
    len = xmlStrlen(cur);
    ctxt = htmlCreateMemoryParserCtxt(cur as *mut std::os::raw::c_char, len);
    if ctxt.is_null() { return 0 as htmlParserCtxtPtr }
    if !encoding.is_null() {
        let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
        let mut handler: xmlCharEncodingHandlerPtr =
            0 as *mut xmlCharEncodingHandler;
        if !(*(*ctxt).input).encoding.is_null() {
            xmlFree.expect("non-null function pointer")((*(*ctxt).input).encoding
                                                            as *mut xmlChar as
                                                            *mut std::os::raw::c_void);
        }
        (*(*ctxt).input).encoding = xmlStrdup(encoding as *const xmlChar);
        enc = xmlParseCharEncoding(encoding);
        /*
	 * registered set of known encodings
	 */
        if enc as std::os::raw::c_int != XML_CHAR_ENCODING_ERROR as std::os::raw::c_int {
            xmlSwitchEncoding(ctxt, enc);
            if (*ctxt).errNo == XML_ERR_UNSUPPORTED_ENCODING as std::os::raw::c_int {
                htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
                             b"Unsupported encoding %s\n\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             encoding as *const xmlChar, 0 as *const xmlChar);
            }
        } else {
            /*
	     * fallback for unknown encodings
	     */
            handler = xmlFindCharEncodingHandler(encoding);
            if !handler.is_null() {
                xmlSwitchToEncoding(ctxt, handler);
            } else {
                htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
                             b"Unsupported encoding %s\n\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             encoding as *const xmlChar, 0 as *const xmlChar);
            }
        }
    }
    return ctxt;
}
/* ***********************************************************************
 *									*
 *	Progressive parsing interfaces				*
 *									*
 ************************************************************************/
/* *
 * htmlParseLookupSequence:
 * @ctxt:  an HTML parser context
 * @first:  the first char to lookup
 * @next:  the next char to lookup or zero
 * @third:  the next char to lookup or zero
 * @comment: flag to force checking inside comments
 *
 * Try to find if a sequence (first, next, third) or  just (first next) or
 * (first) is available in the input stream.
 * This function has a side effect of (possibly) incrementing ctxt->checkIndex
 * to avoid rescanning sequences of bytes, it DOES change the state of the
 * parser, do not use liberally.
 * This is basically similar to xmlParseLookupSequence()
 *
 * Returns the index to the current parsing point if the full sequence
 *      is available, -1 otherwise.
 */
unsafe extern "C" fn htmlParseLookupSequence(mut ctxt: htmlParserCtxtPtr,
                                             mut first: xmlChar,
                                             mut next: xmlChar,
                                             mut third: xmlChar,
                                             mut iscomment: std::os::raw::c_int,
                                             mut ignoreattrval: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut base: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut in_0: htmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: *const xmlChar = 0 as *const xmlChar;
    let mut incomment: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut invalue: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut valdellim: std::os::raw::c_char = 0 as std::os::raw::c_int as std::os::raw::c_char;
    in_0 = (*ctxt).input;
    if in_0.is_null() { return -(1 as std::os::raw::c_int) }
    base =
        (*in_0).cur.offset_from((*in_0).base) as std::os::raw::c_long as
            std::os::raw::c_int;
    if base < 0 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
    if (*ctxt).checkIndex > base as std::os::raw::c_long {
        base = (*ctxt).checkIndex as std::os::raw::c_int
    }
    if (*in_0).buf.is_null() {
        buf = (*in_0).base;
        len = (*in_0).length
    } else {
        buf = xmlBufContent((*(*in_0).buf).buffer as *const xmlBuf);
        len = xmlBufUse((*(*in_0).buf).buffer) as std::os::raw::c_int
    }
    /* take into account the sequence length */
    if third != 0 { len -= 2 as std::os::raw::c_int } else if next != 0 { len -= 1 }
    let mut current_block_35: u64;
    while base < len {
        if incomment == 0 && (base + 4 as std::os::raw::c_int) < len && iscomment == 0
           {
            if *buf.offset(base as isize) as std::os::raw::c_int == '<' as i32 &&
                   *buf.offset((base + 1 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int == '!' as i32 &&
                   *buf.offset((base + 2 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int == '-' as i32 &&
                   *buf.offset((base + 3 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int == '-' as i32 {
                incomment = 1 as std::os::raw::c_int;
                /* do not increment past <! - some people use <!--> */
                base += 2 as std::os::raw::c_int
            }
        }
        if ignoreattrval != 0 {
            if *buf.offset(base as isize) as std::os::raw::c_int == '\"' as i32 ||
                   *buf.offset(base as isize) as std::os::raw::c_int == '\'' as i32 {
                if invalue != 0 {
                    if *buf.offset(base as isize) as std::os::raw::c_int ==
                           valdellim as std::os::raw::c_int {
                        invalue = 0 as std::os::raw::c_int;
                        current_block_35 = 12147880666119273379;
                    } else { current_block_35 = 3123434771885419771; }
                } else {
                    valdellim = *buf.offset(base as isize) as std::os::raw::c_char;
                    invalue = 1 as std::os::raw::c_int;
                    current_block_35 = 12147880666119273379;
                }
            } else if invalue != 0 {
                current_block_35 = 12147880666119273379;
            } else { current_block_35 = 3123434771885419771; }
        } else { current_block_35 = 3123434771885419771; }
        match current_block_35 {
            3123434771885419771 => {
                if incomment != 0 {
                    if base + 3 as std::os::raw::c_int > len {
                        return -(1 as std::os::raw::c_int)
                    }
                    if *buf.offset(base as isize) as std::os::raw::c_int == '-' as i32
                           &&
                           *buf.offset((base + 1 as std::os::raw::c_int) as isize) as
                               std::os::raw::c_int == '-' as i32 &&
                           *buf.offset((base + 2 as std::os::raw::c_int) as isize) as
                               std::os::raw::c_int == '>' as i32 {
                        incomment = 0 as std::os::raw::c_int;
                        base += 2 as std::os::raw::c_int
                    }
                } else if *buf.offset(base as isize) as std::os::raw::c_int ==
                              first as std::os::raw::c_int {
                    if third as std::os::raw::c_int != 0 as std::os::raw::c_int {
                        if *buf.offset((base + 1 as std::os::raw::c_int) as isize) as
                               std::os::raw::c_int != next as std::os::raw::c_int ||
                               *buf.offset((base + 2 as std::os::raw::c_int) as isize)
                                   as std::os::raw::c_int != third as std::os::raw::c_int {
                            current_block_35 = 12147880666119273379;
                        } else { current_block_35 = 12556861819962772176; }
                    } else if next as std::os::raw::c_int != 0 as std::os::raw::c_int {
                        if *buf.offset((base + 1 as std::os::raw::c_int) as isize) as
                               std::os::raw::c_int != next as std::os::raw::c_int {
                            current_block_35 = 12147880666119273379;
                        } else { current_block_35 = 12556861819962772176; }
                    } else { current_block_35 = 12556861819962772176; }
                    match current_block_35 {
                        12147880666119273379 => { }
                        _ => {
                            (*ctxt).checkIndex =
                                0 as std::os::raw::c_int as std::os::raw::c_long;
                            return (base as std::os::raw::c_long -
                                        (*in_0).cur.offset_from((*in_0).base)
                                            as std::os::raw::c_long) as std::os::raw::c_int
                        }
                    }
                }
            }
            _ => { }
        }
        base += 1
    }
    if incomment == 0 && invalue == 0 {
        (*ctxt).checkIndex = base as std::os::raw::c_long
    }
    return -(1 as std::os::raw::c_int);
}
/* *
 * htmlParseLookupChars:
 * @ctxt: an HTML parser context
 * @stop: Array of chars, which stop the lookup.
 * @stopLen: Length of stop-Array
 *
 * Try to find if any char of the stop-Array is available in the input
 * stream.
 * This function has a side effect of (possibly) incrementing ctxt->checkIndex
 * to avoid rescanning sequences of bytes, it DOES change the state of the
 * parser, do not use liberally.
 *
 * Returns the index to the current parsing point if a stopChar
 *      is available, -1 otherwise.
 */
unsafe extern "C" fn htmlParseLookupChars(mut ctxt: htmlParserCtxtPtr,
                                          mut stop: *const xmlChar,
                                          mut stopLen: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut base: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut in_0: htmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: *const xmlChar = 0 as *const xmlChar;
    let mut incomment: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut i: std::os::raw::c_int = 0;
    in_0 = (*ctxt).input;
    if in_0.is_null() { return -(1 as std::os::raw::c_int) }
    base =
        (*in_0).cur.offset_from((*in_0).base) as std::os::raw::c_long as
            std::os::raw::c_int;
    if base < 0 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
    if (*ctxt).checkIndex > base as std::os::raw::c_long {
        base = (*ctxt).checkIndex as std::os::raw::c_int
    }
    if (*in_0).buf.is_null() {
        buf = (*in_0).base;
        len = (*in_0).length
    } else {
        buf = xmlBufContent((*(*in_0).buf).buffer as *const xmlBuf);
        len = xmlBufUse((*(*in_0).buf).buffer) as std::os::raw::c_int
    }
    while base < len {
        if incomment == 0 && (base + 4 as std::os::raw::c_int) < len {
            if *buf.offset(base as isize) as std::os::raw::c_int == '<' as i32 &&
                   *buf.offset((base + 1 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int == '!' as i32 &&
                   *buf.offset((base + 2 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int == '-' as i32 &&
                   *buf.offset((base + 3 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int == '-' as i32 {
                incomment = 1 as std::os::raw::c_int;
                /* do not increment past <! - some people use <!--> */
                base += 2 as std::os::raw::c_int
            }
        }
        if incomment != 0 {
            if base + 3 as std::os::raw::c_int > len { return -(1 as std::os::raw::c_int) }
            if *buf.offset(base as isize) as std::os::raw::c_int == '-' as i32 &&
                   *buf.offset((base + 1 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int == '-' as i32 &&
                   *buf.offset((base + 2 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int == '>' as i32 {
                incomment = 0 as std::os::raw::c_int;
                base += 2 as std::os::raw::c_int
            }
        } else {
            i = 0 as std::os::raw::c_int;
            while i < stopLen {
                if *buf.offset(base as isize) as std::os::raw::c_int ==
                       *stop.offset(i as isize) as std::os::raw::c_int {
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long;
                    return (base as std::os::raw::c_long -
                                (*in_0).cur.offset_from((*in_0).base)
                                    as std::os::raw::c_long) as std::os::raw::c_int
                }
                i += 1
            }
        }
        base += 1
    }
    (*ctxt).checkIndex = base as std::os::raw::c_long;
    return -(1 as std::os::raw::c_int);
}
/* *
 * htmlParseTryOrFinish:
 * @ctxt:  an HTML parser context
 * @terminate:  last chunk indicator
 *
 * Try to progress on parsing
 *
 * Returns zero if no parsing was possible
 */
unsafe extern "C" fn htmlParseTryOrFinish(mut ctxt: htmlParserCtxtPtr,
                                          mut terminate: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut in_0: htmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut avail: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut cur: xmlChar = 0;
    let mut next: xmlChar = 0;
    let mut node_info: htmlParserNodeInfo =
        htmlParserNodeInfo{node: 0 as *const _xmlNode,
                           begin_pos: 0,
                           begin_line: 0,
                           end_pos: 0,
                           end_line: 0,};
    loop  {
        in_0 = (*ctxt).input;
        if in_0.is_null() { break ; }
        if (*in_0).buf.is_null() {
            avail =
                ((*in_0).length as std::os::raw::c_long -
                     (*in_0).cur.offset_from((*in_0).base) as
                         std::os::raw::c_long) as std::os::raw::c_int
        } else {
            avail =
                xmlBufUse((*(*in_0).buf).buffer).wrapping_sub((*in_0).cur.offset_from((*in_0).base)
                                                                  as
                                                                  std::os::raw::c_long
                                                                  as
                                                                  std::os::raw::c_ulong)
                    as std::os::raw::c_int
        }
        if avail == 0 as std::os::raw::c_int && terminate != 0 {
            htmlAutoCloseOnEnd(ctxt);
            if (*ctxt).nameNr == 0 as std::os::raw::c_int &&
                   (*ctxt).instate as std::os::raw::c_int !=
                       XML_PARSER_EOF as std::os::raw::c_int {
                /*
		 * SAX: end of the document processing.
		 */
                (*ctxt).instate = XML_PARSER_EOF;
                if !(*ctxt).sax.is_null() &&
                       (*(*ctxt).sax).endDocument.is_some() {
                    (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
                }
            }
        }
        if avail < 1 as std::os::raw::c_int { break ; }
        cur = *(*in_0).cur.offset(0 as std::os::raw::c_int as isize);
        if cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            (*ctxt).nbChars += 1 as std::os::raw::c_int as std::os::raw::c_long;
            (*(*ctxt).input).cur =
                (*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
            (*(*ctxt).input).col += 1 as std::os::raw::c_int
        } else {
            match (*ctxt).instate as std::os::raw::c_int {
                -1 => {
                    /*
		 * Document parsing is done !
		 */
                    break ;
                }
                0 => {
                    /*
		 * Very first chars read from the document flow.
		 */
                    cur = *(*in_0).cur.offset(0 as std::os::raw::c_int as isize);
                    if cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                           0x9 as std::os::raw::c_int <= cur as std::os::raw::c_int &&
                               cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                           cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                        htmlSkipBlankChars(ctxt);
                        if (*in_0).buf.is_null() {
                            avail =
                                ((*in_0).length as std::os::raw::c_long -
                                     (*in_0).cur.offset_from((*in_0).base)
                                         as std::os::raw::c_long) as std::os::raw::c_int
                        } else {
                            avail =
                                xmlBufUse((*(*in_0).buf).buffer).wrapping_sub((*in_0).cur.offset_from((*in_0).base)
                                                                                  as
                                                                                  std::os::raw::c_long
                                                                                  as
                                                                                  std::os::raw::c_ulong)
                                    as std::os::raw::c_int
                        }
                    }
                    if !(*ctxt).sax.is_null() &&
                           (*(*ctxt).sax).setDocumentLocator.is_some() {
                        (*(*ctxt).sax).setDocumentLocator.expect("non-null function pointer")((*ctxt).userData,
                                                                                              __xmlDefaultSAXLocator());
                    }
                    if !(*ctxt).sax.is_null() &&
                           (*(*ctxt).sax).startDocument.is_some() &&
                           (*ctxt).disableSAX == 0 {
                        (*(*ctxt).sax).startDocument.expect("non-null function pointer")((*ctxt).userData);
                    }
                    cur = *(*in_0).cur.offset(0 as std::os::raw::c_int as isize);
                    next = *(*in_0).cur.offset(1 as std::os::raw::c_int as isize);
                    if cur as std::os::raw::c_int == '<' as i32 &&
                           next as std::os::raw::c_int == '!' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(2 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(2
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(2
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'D' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(3 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(3
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(3
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'O' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(4 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(4
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(4
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'C' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(5 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(5
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(5
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'T' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(6 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(6
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(6
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'Y' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(7 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(7
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(7
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'P' as i32 &&
                           ({
                                let mut __res: std::os::raw::c_int = 0;
                                if ::std::mem::size_of::<xmlChar>() as
                                       std::os::raw::c_ulong >
                                       1 as std::os::raw::c_int as std::os::raw::c_ulong {
                                    if 0 != 0 {
                                        let mut __c: std::os::raw::c_int =
                                            *(*(*ctxt).input).cur.offset(8 as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                                as std::os::raw::c_int;
                                        __res =
                                            (if __c < -(128 as std::os::raw::c_int) ||
                                                    __c > 255 as std::os::raw::c_int {
                                                 __c
                                             } else {
                                                 *(*__ctype_toupper_loc()).offset(__c
                                                                                      as
                                                                                      isize)
                                             })
                                    } else {
                                        __res =
                                            toupper(*(*(*ctxt).input).cur.offset(8
                                                                                     as
                                                                                     std::os::raw::c_int
                                                                                     as
                                                                                     isize)
                                                        as std::os::raw::c_int)
                                    }
                                } else {
                                    __res =
                                        *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(8
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                                                             as
                                                                             std::os::raw::c_int
                                                                             as
                                                                             isize)
                                }
                                __res
                            }) == 'E' as i32 {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '>' as i32 as xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        htmlParseDocTypeDecl(ctxt);
                        (*ctxt).instate = XML_PARSER_PROLOG
                    } else { (*ctxt).instate = XML_PARSER_MISC }
                }
                1 => {
                    htmlSkipBlankChars(ctxt);
                    if (*in_0).buf.is_null() {
                        avail =
                            ((*in_0).length as std::os::raw::c_long -
                                 (*in_0).cur.offset_from((*in_0).base)
                                     as std::os::raw::c_long) as std::os::raw::c_int
                    } else {
                        avail =
                            xmlBufUse((*(*in_0).buf).buffer).wrapping_sub((*in_0).cur.offset_from((*in_0).base)
                                                                              as
                                                                              std::os::raw::c_long
                                                                              as
                                                                              std::os::raw::c_ulong)
                                as std::os::raw::c_int
                    }
                    /*
		 * no chars in buffer
		 */
                    if avail < 1 as std::os::raw::c_int { break ; }
                    /*
		 * not enouth chars in buffer
		 */
                    if avail < 2 as std::os::raw::c_int {
                        if terminate == 0 { break ; }
                        next = ' ' as i32 as xmlChar
                    } else {
                        next = *(*in_0).cur.offset(1 as std::os::raw::c_int as isize)
                    }
                    cur = *(*in_0).cur.offset(0 as std::os::raw::c_int as isize);
                    if cur as std::os::raw::c_int == '<' as i32 &&
                           next as std::os::raw::c_int == '!' as i32 &&
                           *(*in_0).cur.offset(2 as std::os::raw::c_int as isize) as
                               std::os::raw::c_int == '-' as i32 &&
                           *(*in_0).cur.offset(3 as std::os::raw::c_int as isize) as
                               std::os::raw::c_int == '-' as i32 {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '-' as i32 as xmlChar,
                                                       '-' as i32 as xmlChar,
                                                       '>' as i32 as xmlChar,
                                                       1 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        htmlParseComment(ctxt);
                        (*ctxt).instate = XML_PARSER_MISC
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  next as std::os::raw::c_int == '?' as i32 {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '>' as i32 as xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        htmlParsePI(ctxt);
                        (*ctxt).instate = XML_PARSER_MISC
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  next as std::os::raw::c_int == '!' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(2
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(2
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(2
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'D' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(3
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(3
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(3
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'O' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(4
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(4
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(4
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'C' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(5
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(5
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(5
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'T' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(6
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(6
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(6
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'Y' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(7
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(7
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(7
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'P' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(8
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(8
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(8
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'E' as i32 {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '>' as i32 as xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        htmlParseDocTypeDecl(ctxt);
                        (*ctxt).instate = XML_PARSER_PROLOG
                    } else {
                        if cur as std::os::raw::c_int == '<' as i32 &&
                               next as std::os::raw::c_int == '!' as i32 &&
                               avail < 9 as std::os::raw::c_int {
                            break ;
                        }
                        (*ctxt).instate = XML_PARSER_START_TAG
                    }
                }
                4 => {
                    htmlSkipBlankChars(ctxt);
                    if (*in_0).buf.is_null() {
                        avail =
                            ((*in_0).length as std::os::raw::c_long -
                                 (*in_0).cur.offset_from((*in_0).base)
                                     as std::os::raw::c_long) as std::os::raw::c_int
                    } else {
                        avail =
                            xmlBufUse((*(*in_0).buf).buffer).wrapping_sub((*in_0).cur.offset_from((*in_0).base)
                                                                              as
                                                                              std::os::raw::c_long
                                                                              as
                                                                              std::os::raw::c_ulong)
                                as std::os::raw::c_int
                    }
                    if avail < 2 as std::os::raw::c_int { break ; }
                    cur = *(*in_0).cur.offset(0 as std::os::raw::c_int as isize);
                    next = *(*in_0).cur.offset(1 as std::os::raw::c_int as isize);
                    if cur as std::os::raw::c_int == '<' as i32 &&
                           next as std::os::raw::c_int == '!' as i32 &&
                           *(*in_0).cur.offset(2 as std::os::raw::c_int as isize) as
                               std::os::raw::c_int == '-' as i32 &&
                           *(*in_0).cur.offset(3 as std::os::raw::c_int as isize) as
                               std::os::raw::c_int == '-' as i32 {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '-' as i32 as xmlChar,
                                                       '-' as i32 as xmlChar,
                                                       '>' as i32 as xmlChar,
                                                       1 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        htmlParseComment(ctxt);
                        (*ctxt).instate = XML_PARSER_PROLOG
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  next as std::os::raw::c_int == '?' as i32 {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '>' as i32 as xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        htmlParsePI(ctxt);
                        (*ctxt).instate = XML_PARSER_PROLOG
                    } else {
                        if cur as std::os::raw::c_int == '<' as i32 &&
                               next as std::os::raw::c_int == '!' as i32 &&
                               avail < 4 as std::os::raw::c_int {
                            break ;
                        }
                        (*ctxt).instate = XML_PARSER_START_TAG
                    }
                }
                14 => {
                    if (*in_0).buf.is_null() {
                        avail =
                            ((*in_0).length as std::os::raw::c_long -
                                 (*in_0).cur.offset_from((*in_0).base)
                                     as std::os::raw::c_long) as std::os::raw::c_int
                    } else {
                        avail =
                            xmlBufUse((*(*in_0).buf).buffer).wrapping_sub((*in_0).cur.offset_from((*in_0).base)
                                                                              as
                                                                              std::os::raw::c_long
                                                                              as
                                                                              std::os::raw::c_ulong)
                                as std::os::raw::c_int
                    }
                    if avail < 1 as std::os::raw::c_int { break ; }
                    cur = *(*in_0).cur.offset(0 as std::os::raw::c_int as isize);
                    if cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                           0x9 as std::os::raw::c_int <= cur as std::os::raw::c_int &&
                               cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                           cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                        htmlParseCharData(ctxt);
                        break ;
                    } else {
                        if avail < 2 as std::os::raw::c_int { break ; }
                        next = *(*in_0).cur.offset(1 as std::os::raw::c_int as isize);
                        if cur as std::os::raw::c_int == '<' as i32 &&
                               next as std::os::raw::c_int == '!' as i32 &&
                               *(*in_0).cur.offset(2 as std::os::raw::c_int as isize)
                                   as std::os::raw::c_int == '-' as i32 &&
                               *(*in_0).cur.offset(3 as std::os::raw::c_int as isize)
                                   as std::os::raw::c_int == '-' as i32 {
                            if terminate == 0 &&
                                   htmlParseLookupSequence(ctxt,
                                                           '-' as i32 as
                                                               xmlChar,
                                                           '-' as i32 as
                                                               xmlChar,
                                                           '>' as i32 as
                                                               xmlChar,
                                                           1 as std::os::raw::c_int,
                                                           1 as std::os::raw::c_int) <
                                       0 as std::os::raw::c_int {
                                break ;
                            }
                            htmlParseComment(ctxt);
                            (*ctxt).instate = XML_PARSER_EPILOG
                        } else if cur as std::os::raw::c_int == '<' as i32 &&
                                      next as std::os::raw::c_int == '?' as i32 {
                            if terminate == 0 &&
                                   htmlParseLookupSequence(ctxt,
                                                           '>' as i32 as
                                                               xmlChar,
                                                           0 as std::os::raw::c_int as
                                                               xmlChar,
                                                           0 as std::os::raw::c_int as
                                                               xmlChar,
                                                           0 as std::os::raw::c_int,
                                                           1 as std::os::raw::c_int) <
                                       0 as std::os::raw::c_int {
                                break ;
                            }
                            htmlParsePI(ctxt);
                            (*ctxt).instate = XML_PARSER_EPILOG
                        } else {
                            if cur as std::os::raw::c_int == '<' as i32 &&
                                   next as std::os::raw::c_int == '!' as i32 &&
                                   avail < 4 as std::os::raw::c_int {
                                break ;
                            }
                            (*ctxt).errNo =
                                XML_ERR_DOCUMENT_END as std::os::raw::c_int;
                            (*ctxt).wellFormed = 0 as std::os::raw::c_int;
                            (*ctxt).instate = XML_PARSER_EOF;
                            if !(*ctxt).sax.is_null() &&
                                   (*(*ctxt).sax).endDocument.is_some() {
                                (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
                            }
                            break ;
                        }
                    }
                }
                6 => {
                    let mut name: *const xmlChar = 0 as *const xmlChar;
                    let mut failed: std::os::raw::c_int = 0;
                    let mut info: *const htmlElemDesc =
                        0 as *const htmlElemDesc;
                    /*
		 * no chars in buffer
		 */
                    if avail < 1 as std::os::raw::c_int { break ; }
                    /*
		 * not enouth chars in buffer
		 */
                    if avail < 2 as std::os::raw::c_int {
                        if terminate == 0 { break ; }
                        next = ' ' as i32 as xmlChar
                    } else {
                        next = *(*in_0).cur.offset(1 as std::os::raw::c_int as isize)
                    }
                    cur = *(*in_0).cur.offset(0 as std::os::raw::c_int as isize);
                    if cur as std::os::raw::c_int != '<' as i32 {
                        (*ctxt).instate = XML_PARSER_CONTENT
                    } else if next as std::os::raw::c_int == '/' as i32 {
                        (*ctxt).instate = XML_PARSER_END_TAG;
                        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                    } else {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '>' as i32 as xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        /* Capture start position */
                        if (*ctxt).record_info != 0 {
                            node_info.begin_pos =
                                (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                                           as
                                                                           std::os::raw::c_long
                                                                           as
                                                                           std::os::raw::c_ulong);
                            node_info.begin_line =
                                (*(*ctxt).input).line as std::os::raw::c_ulong
                        }
                        failed = htmlParseStartTag(ctxt);
                        name = (*ctxt).name;
                        if failed == -(1 as std::os::raw::c_int) || name.is_null() {
                            if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                   '>' as i32 {
                                xmlNextChar(ctxt);
                            }
                        } else {
                            /*
		 * Lookup the info for that element.
		 */
                            info = htmlTagLookup(name);
                            if info.is_null() {
                                htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
                                             b"Tag %s invalid\n\x00" as
                                                 *const u8 as
                                                 *const std::os::raw::c_char, name,
                                             0 as *const xmlChar);
                            }
                            /*
		 * Check for an Empty Element labeled the XML/SGML way
		 */
                            if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                   '/' as i32 &&
                                   *(*(*ctxt).input).cur.offset(1 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                       as std::os::raw::c_int == '>' as i32 {
                                (*ctxt).nbChars +=
                                    2 as std::os::raw::c_int as std::os::raw::c_long;
                                (*(*ctxt).input).cur =
                                    (*(*ctxt).input).cur.offset(2 as
                                                                    std::os::raw::c_int
                                                                    as isize);
                                (*(*ctxt).input).col += 2 as std::os::raw::c_int;
                                if !(*ctxt).sax.is_null() &&
                                       (*(*ctxt).sax).endElement.is_some() {
                                    (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                                                  name);
                                }
                                htmlnamePop(ctxt);
                                (*ctxt).instate = XML_PARSER_CONTENT
                            } else if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                          '>' as i32 {
                                xmlNextChar(ctxt);
                                /*
		 * Check for an Empty Element from DTD definition
		 */
                                if !info.is_null() &&
                                       (*info).empty as std::os::raw::c_int != 0 {
                                    if !(*ctxt).sax.is_null() &&
                                           (*(*ctxt).sax).endElement.is_some()
                                       {
                                        (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                                                      name);
                                    }
                                    htmlnamePop(ctxt);
                                }
                                if (*ctxt).record_info != 0 {
                                    htmlNodeInfoPush(ctxt, &mut node_info);
                                }
                                (*ctxt).instate = XML_PARSER_CONTENT
                            } else {
                                htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
                                             b"Couldn\'t find end of Start Tag %s\n\x00"
                                                 as *const u8 as
                                                 *const std::os::raw::c_char, name,
                                             0 as *const xmlChar);
                                /*
		     * end of parsing of this node.
		     */
                                if xmlStrEqual(name, (*ctxt).name) != 0 {
                                    nodePop(ctxt);
                                    htmlnamePop(ctxt);
                                }
                                if (*ctxt).record_info != 0 {
                                    htmlNodeInfoPush(ctxt, &mut node_info);
                                }
                                (*ctxt).instate = XML_PARSER_CONTENT
                            }
                        }
                    }
                }
                7 => {
                    let mut cons: std::os::raw::c_long = 0;
                    /*
		 * Handle preparsed entities and charRef
		 */
                    if (*ctxt).token != 0 as std::os::raw::c_int {
                        let mut chr: [xmlChar; 2] =
                            [0 as std::os::raw::c_int as xmlChar,
                             0 as std::os::raw::c_int as xmlChar];
                        chr[0 as std::os::raw::c_int as usize] =
                            (*ctxt).token as xmlChar;
                        htmlCheckParagraph(ctxt);
                        if !(*ctxt).sax.is_null() &&
                               (*(*ctxt).sax).characters.is_some() {
                            (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                          chr.as_mut_ptr(),
                                                                                          1
                                                                                              as
                                                                                              std::os::raw::c_int);
                        }
                        (*ctxt).token = 0 as std::os::raw::c_int;
                        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                    }
                    if avail == 1 as std::os::raw::c_int && terminate != 0 {
                        cur = *(*in_0).cur.offset(0 as std::os::raw::c_int as isize);
                        if cur as std::os::raw::c_int != '<' as i32 &&
                               cur as std::os::raw::c_int != '&' as i32 {
                            if !(*ctxt).sax.is_null() {
                                if cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int
                                       ||
                                       0x9 as std::os::raw::c_int <=
                                           cur as std::os::raw::c_int &&
                                           cur as std::os::raw::c_int <=
                                               0xa as std::os::raw::c_int ||
                                       cur as std::os::raw::c_int ==
                                           0xd as std::os::raw::c_int {
                                    if (*ctxt).keepBlanks != 0 {
                                        if (*(*ctxt).sax).characters.is_some()
                                           {
                                            (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                                          &*(*in_0).cur.offset(0
                                                                                                                                   as
                                                                                                                                   std::os::raw::c_int
                                                                                                                                   as
                                                                                                                                   isize),
                                                                                                          1
                                                                                                              as
                                                                                                              std::os::raw::c_int);
                                        }
                                    } else if (*(*ctxt).sax).ignorableWhitespace.is_some()
                                     {
                                        (*(*ctxt).sax).ignorableWhitespace.expect("non-null function pointer")((*ctxt).userData,
                                                                                                               &*(*in_0).cur.offset(0
                                                                                                                                        as
                                                                                                                                        std::os::raw::c_int
                                                                                                                                        as
                                                                                                                                        isize),
                                                                                                               1
                                                                                                                   as
                                                                                                                   std::os::raw::c_int);
                                    }
                                } else {
                                    htmlCheckParagraph(ctxt);
                                    if (*(*ctxt).sax).characters.is_some() {
                                        (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                                      &*(*in_0).cur.offset(0
                                                                                                                               as
                                                                                                                               std::os::raw::c_int
                                                                                                                               as
                                                                                                                               isize),
                                                                                                      1
                                                                                                          as
                                                                                                          std::os::raw::c_int);
                                    }
                                }
                            }
                            (*ctxt).token = 0 as std::os::raw::c_int;
                            (*ctxt).checkIndex =
                                0 as std::os::raw::c_int as std::os::raw::c_long;
                            (*in_0).cur = (*in_0).cur.offset(1);
                            continue ;
                        }
                    }
                    if avail < 2 as std::os::raw::c_int { break ; }
                    cur = *(*in_0).cur.offset(0 as std::os::raw::c_int as isize);
                    next = *(*in_0).cur.offset(1 as std::os::raw::c_int as isize);
                    cons = (*ctxt).nbChars;
                    if xmlStrEqual((*ctxt).name,
                                   b"script\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar) !=
                           0 ||
                           xmlStrEqual((*ctxt).name,
                                       b"style\x00" as *const u8 as
                                           *const std::os::raw::c_char as
                                           *mut xmlChar) != 0 {
                        /*
		     * Handle SCRIPT/STYLE separately
		     */
                        if terminate == 0 {
                            let mut idx: std::os::raw::c_int = 0;
                            let mut val: xmlChar = 0;
                            idx =
                                htmlParseLookupSequence(ctxt,
                                                        '<' as i32 as xmlChar,
                                                        '/' as i32 as xmlChar,
                                                        0 as std::os::raw::c_int as
                                                            xmlChar,
                                                        0 as std::os::raw::c_int,
                                                        0 as std::os::raw::c_int);
                            if idx < 0 as std::os::raw::c_int { break ; }
                            val =
                                *(*in_0).cur.offset((idx + 2 as std::os::raw::c_int)
                                                        as isize);
                            if val as std::os::raw::c_int == 0 as std::os::raw::c_int {
                                break ;
                            }
                        }
                        htmlParseScript(ctxt);
                        if cur as std::os::raw::c_int == '<' as i32 &&
                               next as std::os::raw::c_int == '/' as i32 {
                            (*ctxt).instate = XML_PARSER_END_TAG;
                            (*ctxt).checkIndex =
                                0 as std::os::raw::c_int as std::os::raw::c_long;
                            continue ;
                        }
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  next as std::os::raw::c_int == '!' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(2
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(2
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(2
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'D' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(3
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(3
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(3
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'O' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(4
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(4
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(4
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'C' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(5
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(5
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(5
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'T' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(6
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(6
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(6
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'Y' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(7
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(7
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(7
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'P' as i32 &&
                                  ({
                                       let mut __res: std::os::raw::c_int = 0;
                                       if ::std::mem::size_of::<xmlChar>() as
                                              std::os::raw::c_ulong >
                                              1 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong {
                                           if 0 != 0 {
                                               let mut __c: std::os::raw::c_int =
                                                   *(*(*ctxt).input).cur.offset(8
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                                       as std::os::raw::c_int;
                                               __res =
                                                   (if __c <
                                                           -(128 as
                                                                 std::os::raw::c_int)
                                                           ||
                                                           __c >
                                                               255 as
                                                                   std::os::raw::c_int
                                                       {
                                                        __c
                                                    } else {
                                                        *(*__ctype_toupper_loc()).offset(__c
                                                                                             as
                                                                                             isize)
                                                    })
                                           } else {
                                               __res =
                                                   toupper(*(*(*ctxt).input).cur.offset(8
                                                                                            as
                                                                                            std::os::raw::c_int
                                                                                            as
                                                                                            isize)
                                                               as std::os::raw::c_int)
                                           }
                                       } else {
                                           __res =
                                               *(*__ctype_toupper_loc()).offset(*(*(*ctxt).input).cur.offset(8
                                                                                                                 as
                                                                                                                 std::os::raw::c_int
                                                                                                                 as
                                                                                                                 isize)
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    isize)
                                       }
                                       __res
                                   }) == 'E' as i32 {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '>' as i32 as xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
                                     b"Misplaced DOCTYPE declaration\n\x00" as
                                         *const u8 as *const std::os::raw::c_char,
                                     b"DOCTYPE\x00" as *const u8 as
                                         *const std::os::raw::c_char as *mut xmlChar,
                                     0 as *const xmlChar);
                        htmlParseDocTypeDecl(ctxt);
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  next as std::os::raw::c_int == '!' as i32 &&
                                  *(*in_0).cur.offset(2 as std::os::raw::c_int as
                                                          isize) as
                                      std::os::raw::c_int == '-' as i32 &&
                                  *(*in_0).cur.offset(3 as std::os::raw::c_int as
                                                          isize) as
                                      std::os::raw::c_int == '-' as i32 {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '-' as i32 as xmlChar,
                                                       '-' as i32 as xmlChar,
                                                       '>' as i32 as xmlChar,
                                                       1 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        htmlParseComment(ctxt);
                        (*ctxt).instate = XML_PARSER_CONTENT
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  next as std::os::raw::c_int == '?' as i32 {
                        if terminate == 0 &&
                               htmlParseLookupSequence(ctxt,
                                                       '>' as i32 as xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int as
                                                           xmlChar,
                                                       0 as std::os::raw::c_int,
                                                       1 as std::os::raw::c_int) <
                                   0 as std::os::raw::c_int {
                            break ;
                        }
                        htmlParsePI(ctxt);
                        (*ctxt).instate = XML_PARSER_CONTENT
                    } else {
                        if cur as std::os::raw::c_int == '<' as i32 &&
                               next as std::os::raw::c_int == '!' as i32 &&
                               avail < 4 as std::os::raw::c_int {
                            break ;
                        }
                        if cur as std::os::raw::c_int == '<' as i32 &&
                               next as std::os::raw::c_int == '/' as i32 {
                            (*ctxt).instate = XML_PARSER_END_TAG;
                            (*ctxt).checkIndex =
                                0 as std::os::raw::c_int as std::os::raw::c_long;
                            continue ;
                        } else if cur as std::os::raw::c_int == '<' as i32 {
                            (*ctxt).instate = XML_PARSER_START_TAG;
                            (*ctxt).checkIndex =
                                0 as std::os::raw::c_int as std::os::raw::c_long;
                            continue ;
                        } else if cur as std::os::raw::c_int == '&' as i32 {
                            if terminate == 0 &&
                                   htmlParseLookupChars(ctxt,
                                                        b"; >/\x00" as
                                                            *const u8 as
                                                            *const std::os::raw::c_char
                                                            as *mut xmlChar,
                                                        4 as std::os::raw::c_int) <
                                       0 as std::os::raw::c_int {
                                break ;
                            }
                            /*
		     * Sometimes DOCTYPE arrives in the middle of the document
		     */
                            /* TODO: check generation of subtrees if noent !!! */
                            htmlParseReference(ctxt);
                        } else {
                            /*
			 * check that the text sequence is complete
			 * before handing out the data to the parser
			 * to avoid problems with erroneous end of
			 * data detection.
			 */
                            if terminate == 0 &&
                                   htmlParseLookupChars(ctxt,
                                                        b"<&\x00" as *const u8
                                                            as
                                                            *const std::os::raw::c_char
                                                            as *mut xmlChar,
                                                        2 as std::os::raw::c_int) <
                                       0 as std::os::raw::c_int {
                                break ;
                            }
                            (*ctxt).checkIndex =
                                0 as std::os::raw::c_int as std::os::raw::c_long;
                            htmlParseCharData(ctxt);
                        }
                    }
                    if !(cons == (*ctxt).nbChars) { continue ; }
                    if !(*ctxt).node.is_null() {
                        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                     b"detected an error in element content\n\x00"
                                         as *const u8 as *const std::os::raw::c_char,
                                     0 as *const xmlChar,
                                     0 as *const xmlChar);
                    }
                    xmlNextChar(ctxt);
                }
                9 => {
                    if avail < 2 as std::os::raw::c_int { break ; }
                    if terminate == 0 &&
                           htmlParseLookupSequence(ctxt,
                                                   '>' as i32 as xmlChar,
                                                   0 as std::os::raw::c_int as
                                                       xmlChar,
                                                   0 as std::os::raw::c_int as
                                                       xmlChar,
                                                   0 as std::os::raw::c_int,
                                                   1 as std::os::raw::c_int) <
                               0 as std::os::raw::c_int {
                        break ;
                    }
                    htmlParseEndTag(ctxt);
                    if (*ctxt).nameNr == 0 as std::os::raw::c_int {
                        (*ctxt).instate = XML_PARSER_EPILOG
                    } else { (*ctxt).instate = XML_PARSER_CONTENT }
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                8 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == CDATA\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_CONTENT;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                3 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == DTD\n\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_CONTENT;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                5 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == COMMENT\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_CONTENT;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                2 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == PI\n\x00" as
                                     *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_CONTENT;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                10 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == ENTITY_DECL\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_CONTENT;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                11 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == ENTITY_VALUE\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_CONTENT;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                12 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == ATTRIBUTE_VALUE\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_START_TAG;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                13 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_CONTENT;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                15 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == XML_PARSER_IGNORE\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_CONTENT;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                16 => {
                    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                 b"HPP: internal error, state == XML_PARSER_LITERAL\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    (*ctxt).instate = XML_PARSER_CONTENT;
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                }
                _ => { }
            }
        }
    }
    /* bad cut of input */
    if avail == 0 as std::os::raw::c_int && terminate != 0 {
        htmlAutoCloseOnEnd(ctxt);
        if (*ctxt).nameNr == 0 as std::os::raw::c_int &&
               (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int
           {
            /*
	     * SAX: end of the document processing.
	     */
            (*ctxt).instate = XML_PARSER_EOF;
            if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endDocument.is_some()
               {
                (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
            }
        }
    }
    if (*ctxt).options & HTML_PARSE_NODEFDTD as std::os::raw::c_int == 0 &&
           !(*ctxt).myDoc.is_null() &&
           (terminate != 0 ||
                (*ctxt).instate as std::os::raw::c_int ==
                    XML_PARSER_EOF as std::os::raw::c_int ||
                (*ctxt).instate as std::os::raw::c_int ==
                    XML_PARSER_EPILOG as std::os::raw::c_int) {
        let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
        dtd = xmlGetIntSubset((*ctxt).myDoc as *const xmlDoc);
        if dtd.is_null() {
            (*(*ctxt).myDoc).intSubset =
                xmlCreateIntSubset((*ctxt).myDoc,
                                   b"html\x00" as *const u8 as
                                       *const std::os::raw::c_char as *mut xmlChar,
                                   b"-//W3C//DTD HTML 4.0 Transitional//EN\x00"
                                       as *const u8 as *const std::os::raw::c_char as
                                       *mut xmlChar,
                                   b"http://www.w3.org/TR/REC-html40/loose.dtd\x00"
                                       as *const u8 as *const std::os::raw::c_char as
                                       *mut xmlChar)
        }
    }
    return ret;
}
/* *
 * htmlParseChunk:
 * @ctxt:  an HTML parser context
 * @chunk:  an char array
 * @size:  the size in byte of the chunk
 * @terminate:  last chunk indicator
 *
 * Parse a Chunk of memory
 *
 * Returns zero if no error, the xmlParserErrors otherwise.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlParseChunk(mut ctxt: htmlParserCtxtPtr,
                                        mut chunk: *const std::os::raw::c_char,
                                        mut size: std::os::raw::c_int,
                                        mut terminate: std::os::raw::c_int)
 -> std::os::raw::c_int {
    if ctxt.is_null() || (*ctxt).input.is_null() {
        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
                     b"htmlParseChunk: context error\n\x00" as *const u8 as
                         *const std::os::raw::c_char, 0 as *const xmlChar,
                     0 as *const xmlChar);
        return XML_ERR_INTERNAL_ERROR as std::os::raw::c_int
    }
    if size > 0 as std::os::raw::c_int && !chunk.is_null() && !(*ctxt).input.is_null()
           && !(*(*ctxt).input).buf.is_null() &&
           (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int {
        let mut base: size_t =
            xmlBufGetInputBase((*(*(*ctxt).input).buf).buffer, (*ctxt).input);
        let mut cur: size_t =
            (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                as std::os::raw::c_long as size_t;
        let mut res: std::os::raw::c_int = 0;
        res = xmlParserInputBufferPush((*(*ctxt).input).buf, size, chunk);
        if res < 0 as std::os::raw::c_int {
            (*ctxt).errNo = XML_PARSER_EOF as std::os::raw::c_int;
            (*ctxt).disableSAX = 1 as std::os::raw::c_int;
            return XML_PARSER_EOF as std::os::raw::c_int
        }
        xmlBufSetInputBaseCur((*(*(*ctxt).input).buf).buffer, (*ctxt).input,
                              base, cur);
    } else if (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int
     {
        if !(*ctxt).input.is_null() && !(*(*ctxt).input).buf.is_null() {
            let mut in_0: xmlParserInputBufferPtr = (*(*ctxt).input).buf;
            if !(*in_0).encoder.is_null() && !(*in_0).buffer.is_null() &&
                   !(*in_0).raw.is_null() {
                let mut nbchars: std::os::raw::c_int = 0;
                let mut base_0: size_t =
                    xmlBufGetInputBase((*in_0).buffer, (*ctxt).input);
                let mut current: size_t =
                    (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                        as std::os::raw::c_long as size_t;
                nbchars = xmlCharEncInput(in_0, terminate);
                if nbchars < 0 as std::os::raw::c_int {
                    htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
                                 b"encoder error\n\x00" as *const u8 as
                                     *const std::os::raw::c_char, 0 as *const xmlChar,
                                 0 as *const xmlChar);
                    return XML_ERR_INVALID_ENCODING as std::os::raw::c_int
                }
                xmlBufSetInputBaseCur((*in_0).buffer, (*ctxt).input, base_0,
                                      current);
            }
        }
    }
    htmlParseTryOrFinish(ctxt, terminate);
    if terminate != 0 {
        if (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int &&
               (*ctxt).instate as std::os::raw::c_int !=
                   XML_PARSER_EPILOG as std::os::raw::c_int &&
               (*ctxt).instate as std::os::raw::c_int !=
                   XML_PARSER_MISC as std::os::raw::c_int {
            (*ctxt).errNo = XML_ERR_DOCUMENT_END as std::os::raw::c_int;
            (*ctxt).wellFormed = 0 as std::os::raw::c_int
        }
        if (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int {
            if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endDocument.is_some()
               {
                (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
            }
        }
        (*ctxt).instate = XML_PARSER_EOF
    }
    return (*ctxt).errNo as xmlParserErrors as std::os::raw::c_int;
}
/* *
 * Interfaces for the Push mode.
 */
/* ***********************************************************************
 *									*
 *			User entry points				*
 *									*
 ************************************************************************/
/* *
 * htmlCreatePushParserCtxt:
 * @sax:  a SAX handler
 * @user_data:  The user data returned on SAX callbacks
 * @chunk:  a pointer to an array of chars
 * @size:  number of chars in the array
 * @filename:  an optional file name or URI
 * @enc:  an optional encoding
 *
 * Create a parser context for using the HTML parser in push mode
 * The value of @filename is used for fetching external entities
 * and error/warning reports.
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCreatePushParserCtxt(mut sax: htmlSAXHandlerPtr,
                                                  mut user_data:
                                                      *mut std::os::raw::c_void,
                                                  mut chunk:
                                                      *const std::os::raw::c_char,
                                                  mut size: std::os::raw::c_int,
                                                  mut filename:
                                                      *const std::os::raw::c_char,
                                                  mut enc: xmlCharEncoding)
 -> htmlParserCtxtPtr {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut inputStream: htmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    xmlInitParser();
    buf = xmlAllocParserInputBuffer(enc);
    if buf.is_null() { return 0 as htmlParserCtxtPtr }
    ctxt = htmlNewParserCtxt();
    if ctxt.is_null() {
        xmlFreeParserInputBuffer(buf);
        return 0 as htmlParserCtxtPtr
    }
    if enc as std::os::raw::c_int == XML_CHAR_ENCODING_UTF8 as std::os::raw::c_int ||
           !(*buf).encoder.is_null() {
        (*ctxt).charset = XML_CHAR_ENCODING_UTF8 as std::os::raw::c_int
    }
    if !sax.is_null() {
        if (*ctxt).sax != __htmlDefaultSAXHandler() as xmlSAXHandlerPtr {
            xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).sax =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<htmlSAXHandler>()
                                                              as
                                                              std::os::raw::c_ulong)
                as htmlSAXHandlerPtr;
        if (*ctxt).sax.is_null() {
            xmlFree.expect("non-null function pointer")(buf as
                                                            *mut std::os::raw::c_void);
            xmlFree.expect("non-null function pointer")(ctxt as
                                                            *mut std::os::raw::c_void);
            return 0 as htmlParserCtxtPtr
        }
        memcpy((*ctxt).sax as *mut std::os::raw::c_void, sax as *const std::os::raw::c_void,
               ::std::mem::size_of::<htmlSAXHandler>() as std::os::raw::c_ulong);
        if !user_data.is_null() { (*ctxt).userData = user_data }
    }
    if filename.is_null() {
        (*ctxt).directory = 0 as *mut std::os::raw::c_char
    } else { (*ctxt).directory = xmlParserGetDirectory(filename) }
    inputStream = htmlNewInputStream(ctxt);
    if inputStream.is_null() {
        xmlFreeParserCtxt(ctxt);
        xmlFree.expect("non-null function pointer")(buf as *mut std::os::raw::c_void);
        return 0 as htmlParserCtxtPtr
    }
    if filename.is_null() {
        (*inputStream).filename = 0 as *const std::os::raw::c_char
    } else {
        (*inputStream).filename =
            xmlCanonicPath(filename as *const xmlChar) as *mut std::os::raw::c_char
    }
    (*inputStream).buf = buf;
    xmlBufResetInput((*buf).buffer, inputStream);
    inputPush(ctxt, inputStream);
    if size > 0 as std::os::raw::c_int && !chunk.is_null() && !(*ctxt).input.is_null()
           && !(*(*ctxt).input).buf.is_null() {
        let mut base: size_t =
            xmlBufGetInputBase((*(*(*ctxt).input).buf).buffer, (*ctxt).input);
        let mut cur: size_t =
            (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                as std::os::raw::c_long as size_t;
        xmlParserInputBufferPush((*(*ctxt).input).buf, size, chunk);
        xmlBufSetInputBaseCur((*(*(*ctxt).input).buf).buffer, (*ctxt).input,
                              base, cur);
    }
    (*ctxt).progressive = 1 as std::os::raw::c_int;
    return ctxt;
}
/* LIBXML_PUSH_ENABLED */
/* *
 * htmlSAXParseDoc:
 * @cur:  a pointer to an array of xmlChar
 * @encoding:  a free form C string describing the HTML document encoding, or NULL
 * @sax:  the SAX handler block
 * @userData: if using SAX, this pointer will be provided on callbacks.
 *
 * Parse an HTML in-memory document. If sax is not NULL, use the SAX callbacks
 * to handle parse events. If sax is NULL, fallback to the default DOM
 * behavior and return a tree.
 *
 * Returns the resulting document tree unless SAX is NULL or the document is
 *     not well formed.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlSAXParseDoc(mut cur: *const xmlChar,
                                         mut encoding: *const std::os::raw::c_char,
                                         mut sax: htmlSAXHandlerPtr,
                                         mut userData: *mut std::os::raw::c_void)
 -> htmlDocPtr {
    let mut ret: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    xmlInitParser();
    if cur.is_null() { return 0 as htmlDocPtr }
    ctxt = htmlCreateDocParserCtxt(cur, encoding);
    if ctxt.is_null() { return 0 as htmlDocPtr }
    if !sax.is_null() {
        if !(*ctxt).sax.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).sax = sax;
        (*ctxt).userData = userData
    }
    htmlParseDocument(ctxt);
    ret = (*ctxt).myDoc;
    if !sax.is_null() {
        (*ctxt).sax = 0 as *mut _xmlSAXHandler;
        (*ctxt).userData = 0 as *mut std::os::raw::c_void
    }
    htmlFreeParserCtxt(ctxt);
    return ret;
}
/* *
 * htmlParseDoc:
 * @cur:  a pointer to an array of xmlChar
 * @encoding:  a free form C string describing the HTML document encoding, or NULL
 *
 * parse an HTML in-memory document and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlParseDoc(mut cur: *const xmlChar,
                                      mut encoding: *const std::os::raw::c_char)
 -> htmlDocPtr {
    return htmlSAXParseDoc(cur, encoding, 0 as htmlSAXHandlerPtr,
                           0 as *mut std::os::raw::c_void);
}
/* *
 * htmlCreateFileParserCtxt:
 * @filename:  the filename
 * @encoding:  a free form C string describing the HTML document encoding, or NULL
 *
 * Create a parser context for a file content.
 * Automatic support for ZLIB/Compress compressed document is provided
 * by default if found at compile-time.
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCreateFileParserCtxt(mut filename:
                                                      *const std::os::raw::c_char,
                                                  mut encoding:
                                                      *const std::os::raw::c_char)
 -> htmlParserCtxtPtr {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut inputStream: htmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut canonicFilename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    /* htmlCharEncoding enc; */
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut content_line: *mut xmlChar =
        b"charset=\x00" as *const u8 as *const std::os::raw::c_char as *mut xmlChar;
    if filename.is_null() { return 0 as htmlParserCtxtPtr }
    ctxt = htmlNewParserCtxt();
    if ctxt.is_null() { return 0 as htmlParserCtxtPtr }
    canonicFilename =
        xmlCanonicPath(filename as *const xmlChar) as *mut std::os::raw::c_char;
    if canonicFilename.is_null() {
        if (*__xmlDefaultSAXHandler()).error.is_some() {
            (*__xmlDefaultSAXHandler()).error.expect("non-null function pointer")(0
                                                                                      as
                                                                                      *mut std::os::raw::c_void,
                                                                                  b"out of memory\n\x00"
                                                                                      as
                                                                                      *const u8
                                                                                      as
                                                                                      *const std::os::raw::c_char);
        }
        xmlFreeParserCtxt(ctxt);
        return 0 as htmlParserCtxtPtr
    }
    inputStream =
        xmlLoadExternalEntity(canonicFilename, 0 as *const std::os::raw::c_char,
                              ctxt);
    xmlFree.expect("non-null function pointer")(canonicFilename as
                                                    *mut std::os::raw::c_void);
    if inputStream.is_null() {
        xmlFreeParserCtxt(ctxt);
        return 0 as htmlParserCtxtPtr
    }
    inputPush(ctxt, inputStream);
    /* set encoding */
    if !encoding.is_null() {
        let mut l: size_t = strlen(encoding);
        if l < 1000 as std::os::raw::c_int as std::os::raw::c_ulong {
            content =
                xmlMallocAtomic.expect("non-null function pointer")((xmlStrlen(content_line)
                                                                         as
                                                                         std::os::raw::c_ulong).wrapping_add(l).wrapping_add(1
                                                                                                                         as
                                                                                                                         std::os::raw::c_int
                                                                                                                         as
                                                                                                                         std::os::raw::c_ulong))
                    as *mut xmlChar;
            if !content.is_null() {
                strcpy(content as *mut std::os::raw::c_char,
                       content_line as *mut std::os::raw::c_char);
                strcat(content as *mut std::os::raw::c_char,
                       encoding as *mut std::os::raw::c_char);
                htmlCheckEncoding(ctxt, content);
                xmlFree.expect("non-null function pointer")(content as
                                                                *mut std::os::raw::c_void);
            }
        }
    }
    return ctxt;
}
/* *
 * htmlSAXParseFile:
 * @filename:  the filename
 * @encoding:  a free form C string describing the HTML document encoding, or NULL
 * @sax:  the SAX handler block
 * @userData: if using SAX, this pointer will be provided on callbacks.
 *
 * parse an HTML file and build a tree. Automatic support for ZLIB/Compress
 * compressed document is provided by default if found at compile-time.
 * It use the given SAX function block to handle the parsing callback.
 * If sax is NULL, fallback to the default DOM tree building routines.
 *
 * Returns the resulting document tree unless SAX is NULL or the document is
 *     not well formed.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlSAXParseFile(mut filename: *const std::os::raw::c_char,
                                          mut encoding: *const std::os::raw::c_char,
                                          mut sax: htmlSAXHandlerPtr,
                                          mut userData: *mut std::os::raw::c_void)
 -> htmlDocPtr {
    let mut ret: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut oldsax: htmlSAXHandlerPtr = 0 as htmlSAXHandlerPtr;
    xmlInitParser();
    ctxt = htmlCreateFileParserCtxt(filename, encoding);
    if ctxt.is_null() { return 0 as htmlDocPtr }
    if !sax.is_null() {
        oldsax = (*ctxt).sax;
        (*ctxt).sax = sax;
        (*ctxt).userData = userData
    }
    htmlParseDocument(ctxt);
    ret = (*ctxt).myDoc;
    if !sax.is_null() {
        (*ctxt).sax = oldsax;
        (*ctxt).userData = 0 as *mut std::os::raw::c_void
    }
    htmlFreeParserCtxt(ctxt);
    return ret;
}
/* *
 * htmlParseFile:
 * @filename:  the filename
 * @encoding:  a free form C string describing the HTML document encoding, or NULL
 *
 * parse an HTML file and build a tree. Automatic support for ZLIB/Compress
 * compressed document is provided by default if found at compile-time.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlParseFile(mut filename: *const std::os::raw::c_char,
                                       mut encoding: *const std::os::raw::c_char)
 -> htmlDocPtr {
    return htmlSAXParseFile(filename, encoding, 0 as htmlSAXHandlerPtr,
                            0 as *mut std::os::raw::c_void);
}
/* *
 * htmlHandleOmittedElem:
 * @val:  int 0 or 1
 *
 * Set and return the previous value for handling HTML omitted tags.
 *
 * Returns the last value for 0 for no handling, 1 for auto insertion.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlHandleOmittedElem(mut val: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut old: std::os::raw::c_int = htmlOmittedDefaultValue;
    htmlOmittedDefaultValue = val;
    return old;
}
/* *
 * htmlElementAllowedHere:
 * @parent: HTML parent element
 * @elt: HTML element
 *
 * Checks whether an HTML element may be a direct child of a parent element.
 * Note - doesn't check for deprecated elements
 *
 * Returns 1 if allowed; 0 otherwise.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlElementAllowedHere(mut parent:
                                                    *const htmlElemDesc,
                                                mut elt: *const xmlChar)
 -> std::os::raw::c_int {
    let mut p: *mut *const std::os::raw::c_char = 0 as *mut *const std::os::raw::c_char;
    if elt.is_null() || parent.is_null() || (*parent).subelts.is_null() {
        return 0 as std::os::raw::c_int
    }
    p = (*parent).subelts;
    while !(*p).is_null() {
        if xmlStrcmp(*p as *const xmlChar, elt) == 0 {
            return 1 as std::os::raw::c_int
        }
        p = p.offset(1)
    }
    return 0 as std::os::raw::c_int;
}
/* Using htmlElemDesc rather than name here, to emphasise the fact
   that otherwise there's a lookup overhead
*/
/* *
 * htmlElementStatusHere:
 * @parent: HTML parent element
 * @elt: HTML element
 *
 * Checks whether an HTML element may be a direct child of a parent element.
 * and if so whether it is valid or deprecated.
 *
 * Returns one of HTML_VALID, HTML_DEPRECATED, HTML_INVALID
 */
#[no_mangle]
pub unsafe extern "C" fn htmlElementStatusHere(mut parent:
                                                   *const htmlElemDesc,
                                               mut elt: *const htmlElemDesc)
 -> htmlStatus {
    if parent.is_null() || elt.is_null() { return HTML_INVALID }
    if htmlElementAllowedHere(parent, (*elt).name as *const xmlChar) == 0 {
        return HTML_INVALID
    }
    return if (*elt).dtd as std::os::raw::c_int == 0 as std::os::raw::c_int {
               HTML_VALID as std::os::raw::c_int
           } else { HTML_DEPRECATED as std::os::raw::c_int } as htmlStatus;
}
/* *
 * htmlAttrAllowed:
 * @elt: HTML element
 * @attr: HTML attribute
 * @legacy: whether to allow deprecated attributes
 *
 * Checks whether an attribute is valid for an element
 * Has full knowledge of Required and Deprecated attributes
 *
 * Returns one of HTML_REQUIRED, HTML_VALID, HTML_DEPRECATED, HTML_INVALID
 */
#[no_mangle]
pub unsafe extern "C" fn htmlAttrAllowed(mut elt: *const htmlElemDesc,
                                         mut attr: *const xmlChar,
                                         mut legacy: std::os::raw::c_int)
 -> htmlStatus {
    let mut p: *mut *const std::os::raw::c_char = 0 as *mut *const std::os::raw::c_char;
    if elt.is_null() || attr.is_null() { return HTML_INVALID }
    if !(*elt).attrs_req.is_null() {
        p = (*elt).attrs_req;
        while !(*p).is_null() {
            if xmlStrcmp(*p as *const xmlChar, attr) == 0 {
                return HTML_REQUIRED
            }
            p = p.offset(1)
        }
    }
    if !(*elt).attrs_opt.is_null() {
        p = (*elt).attrs_opt;
        while !(*p).is_null() {
            if xmlStrcmp(*p as *const xmlChar, attr) == 0 {
                return HTML_VALID
            }
            p = p.offset(1)
        }
    }
    if legacy != 0 && !(*elt).attrs_depr.is_null() {
        p = (*elt).attrs_depr;
        while !(*p).is_null() {
            if xmlStrcmp(*p as *const xmlChar, attr) == 0 {
                return HTML_DEPRECATED
            }
            p = p.offset(1)
        }
    }
    return HTML_INVALID;
}
/* *
 * htmlNodeStatus:
 * @node: an htmlNodePtr in a tree
 * @legacy: whether to allow deprecated elements (YES is faster here
 *	for Element nodes)
 *
 * Checks whether the tree node is valid.  Experimental (the author
 *     only uses the HTML enhancements in a SAX parser)
 *
 * Return: for Element nodes, a return from htmlElementAllowedHere (if
 *	legacy allowed) or htmlElementStatusHere (otherwise).
 *	for Attribute nodes, a return from htmlAttrAllowed
 *	for other nodes, HTML_NA (no checks performed)
 */
#[no_mangle]
pub unsafe extern "C" fn htmlNodeStatus(node: htmlNodePtr,
                                        mut legacy: std::os::raw::c_int)
 -> htmlStatus {
    if node.is_null() { return HTML_INVALID }
    match (*node).type_0 as std::os::raw::c_uint {
        1 => {
            return if legacy != 0 {
                       (if htmlElementAllowedHere(htmlTagLookup((*(*node).parent).name),
                                                  (*node).name) != 0 {
                            HTML_VALID as std::os::raw::c_int
                        } else { HTML_INVALID as std::os::raw::c_int }) as
                           std::os::raw::c_uint
                   } else {
                       htmlElementStatusHere(htmlTagLookup((*(*node).parent).name),
                                             htmlTagLookup((*node).name)) as
                           std::os::raw::c_uint
                   } as htmlStatus
        }
        2 => {
            return htmlAttrAllowed(htmlTagLookup((*(*node).parent).name),
                                   (*node).name, legacy)
        }
        _ => { return HTML_NA }
    };
}
/* ***********************************************************************
 *									*
 *	New set (2.6.0) of simpler and more flexible APIs		*
 *									*
 ************************************************************************/
/* *
 * DICT_FREE:
 * @str:  a string
 *
 * Free a string if it is not owned by the "dict" dictionary in the
 * current scope
 */
/* *
 * htmlCtxtReset:
 * @ctxt: an HTML parser context
 *
 * Reset a parser context
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCtxtReset(mut ctxt: htmlParserCtxtPtr) {
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut dict: xmlDictPtr = 0 as *mut xmlDict;
    if ctxt.is_null() { return }
    xmlInitParser();
    dict = (*ctxt).dict;
    loop  {
        input = inputPop(ctxt);
        if input.is_null() { break ; }
        /* Non consuming */
        xmlFreeInputStream(input);
    }
    (*ctxt).inputNr = 0 as std::os::raw::c_int;
    (*ctxt).input = 0 as xmlParserInputPtr;
    (*ctxt).spaceNr = 0 as std::os::raw::c_int;
    if !(*ctxt).spaceTab.is_null() {
        *(*ctxt).spaceTab.offset(0 as std::os::raw::c_int as isize) =
            -(1 as std::os::raw::c_int);
        (*ctxt).space =
            &mut *(*ctxt).spaceTab.offset(0 as std::os::raw::c_int as isize) as
                *mut std::os::raw::c_int
    } else { (*ctxt).space = 0 as *mut std::os::raw::c_int }
    (*ctxt).nodeNr = 0 as std::os::raw::c_int;
    (*ctxt).node = 0 as xmlNodePtr;
    (*ctxt).nameNr = 0 as std::os::raw::c_int;
    (*ctxt).name = 0 as *const xmlChar;
    if !(*ctxt).version.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).version) == 0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).version as
                                                        *mut std::os::raw::c_char as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).version = 0 as *const xmlChar;
    if !(*ctxt).encoding.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).encoding) == 0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).encoding as
                                                        *mut std::os::raw::c_char as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).encoding = 0 as *const xmlChar;
    if !(*ctxt).directory.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).directory as *const xmlChar) ==
                    0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).directory as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).directory = 0 as *mut std::os::raw::c_char;
    if !(*ctxt).extSubURI.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).extSubURI as *const xmlChar) ==
                    0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).extSubURI as
                                                        *mut std::os::raw::c_char as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).extSubURI = 0 as *mut xmlChar;
    if !(*ctxt).extSubSystem.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).extSubSystem as *const xmlChar) ==
                    0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).extSubSystem as
                                                        *mut std::os::raw::c_char as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).extSubSystem = 0 as *mut xmlChar;
    if !(*ctxt).myDoc.is_null() { xmlFreeDoc((*ctxt).myDoc); }
    (*ctxt).myDoc = 0 as xmlDocPtr;
    (*ctxt).standalone = -(1 as std::os::raw::c_int);
    (*ctxt).hasExternalSubset = 0 as std::os::raw::c_int;
    (*ctxt).hasPErefs = 0 as std::os::raw::c_int;
    (*ctxt).html = 1 as std::os::raw::c_int;
    (*ctxt).external = 0 as std::os::raw::c_int;
    (*ctxt).instate = XML_PARSER_START;
    (*ctxt).token = 0 as std::os::raw::c_int;
    (*ctxt).wellFormed = 1 as std::os::raw::c_int;
    (*ctxt).nsWellFormed = 1 as std::os::raw::c_int;
    (*ctxt).disableSAX = 0 as std::os::raw::c_int;
    (*ctxt).valid = 1 as std::os::raw::c_int;
    (*ctxt).vctxt.userData = ctxt as *mut std::os::raw::c_void;
    (*ctxt).vctxt.error =
        Some(xmlParserValidityError as
                 unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                      _: *const std::os::raw::c_char, _: ...) -> ());
    (*ctxt).vctxt.warning =
        Some(xmlParserValidityWarning as
                 unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                      _: *const std::os::raw::c_char, _: ...) -> ());
    (*ctxt).record_info = 0 as std::os::raw::c_int;
    (*ctxt).nbChars = 0 as std::os::raw::c_int as std::os::raw::c_long;
    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long;
    (*ctxt).inSubset = 0 as std::os::raw::c_int;
    (*ctxt).errNo = XML_ERR_OK as std::os::raw::c_int;
    (*ctxt).depth = 0 as std::os::raw::c_int;
    (*ctxt).charset = XML_CHAR_ENCODING_NONE as std::os::raw::c_int;
    (*ctxt).catalogs = 0 as *mut std::os::raw::c_void;
    xmlInitNodeInfoSeq(&mut (*ctxt).node_seq);
    if !(*ctxt).attsDefault.is_null() {
        xmlHashFree((*ctxt).attsDefault,
                    Some(xmlHashDefaultDeallocator as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *const xmlChar) -> ()));
        (*ctxt).attsDefault = 0 as xmlHashTablePtr
    }
    if !(*ctxt).attsSpecial.is_null() {
        xmlHashFree((*ctxt).attsSpecial, None);
        (*ctxt).attsSpecial = 0 as xmlHashTablePtr
    };
}
/* *
 * htmlCtxtUseOptions:
 * @ctxt: an HTML parser context
 * @options:  a combination of htmlParserOption(s)
 *
 * Applies the options to the parser context
 *
 * Returns 0 in case of success, the set of unknown or unimplemented options
 *         in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCtxtUseOptions(mut ctxt: htmlParserCtxtPtr,
                                            mut options: std::os::raw::c_int)
 -> std::os::raw::c_int {
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    if options & HTML_PARSE_NOWARNING as std::os::raw::c_int != 0 {
        (*(*ctxt).sax).warning = None;
        (*ctxt).vctxt.warning = None;
        options -= XML_PARSE_NOWARNING as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_NOWARNING as std::os::raw::c_int
    }
    if options & HTML_PARSE_NOERROR as std::os::raw::c_int != 0 {
        (*(*ctxt).sax).error = None;
        (*ctxt).vctxt.error = None;
        (*(*ctxt).sax).fatalError = None;
        options -= XML_PARSE_NOERROR as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_NOERROR as std::os::raw::c_int
    }
    if options & HTML_PARSE_PEDANTIC as std::os::raw::c_int != 0 {
        (*ctxt).pedantic = 1 as std::os::raw::c_int;
        options -= XML_PARSE_PEDANTIC as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_PEDANTIC as std::os::raw::c_int
    } else { (*ctxt).pedantic = 0 as std::os::raw::c_int }
    if options & XML_PARSE_NOBLANKS as std::os::raw::c_int != 0 {
        (*ctxt).keepBlanks = 0 as std::os::raw::c_int;
        (*(*ctxt).sax).ignorableWhitespace =
            Some(xmlSAX2IgnorableWhitespace as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar, _: std::os::raw::c_int)
                         -> ());
        options -= XML_PARSE_NOBLANKS as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_NOBLANKS as std::os::raw::c_int
    } else { (*ctxt).keepBlanks = 1 as std::os::raw::c_int }
    if options & HTML_PARSE_RECOVER as std::os::raw::c_int != 0 {
        (*ctxt).recovery = 1 as std::os::raw::c_int;
        options -= HTML_PARSE_RECOVER as std::os::raw::c_int
    } else { (*ctxt).recovery = 0 as std::os::raw::c_int }
    if options & HTML_PARSE_COMPACT as std::os::raw::c_int != 0 {
        (*ctxt).options |= HTML_PARSE_COMPACT as std::os::raw::c_int;
        options -= HTML_PARSE_COMPACT as std::os::raw::c_int
    }
    if options & XML_PARSE_HUGE as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_HUGE as std::os::raw::c_int;
        options -= XML_PARSE_HUGE as std::os::raw::c_int
    }
    if options & HTML_PARSE_NODEFDTD as std::os::raw::c_int != 0 {
        (*ctxt).options |= HTML_PARSE_NODEFDTD as std::os::raw::c_int;
        options -= HTML_PARSE_NODEFDTD as std::os::raw::c_int
    }
    if options & HTML_PARSE_IGNORE_ENC as std::os::raw::c_int != 0 {
        (*ctxt).options |= HTML_PARSE_IGNORE_ENC as std::os::raw::c_int;
        options -= HTML_PARSE_IGNORE_ENC as std::os::raw::c_int
    }
    if options & HTML_PARSE_NOIMPLIED as std::os::raw::c_int != 0 {
        (*ctxt).options |= HTML_PARSE_NOIMPLIED as std::os::raw::c_int;
        options -= HTML_PARSE_NOIMPLIED as std::os::raw::c_int
    }
    (*ctxt).dictNames = 0 as std::os::raw::c_int;
    return options;
}
/* *
 * htmlDoRead:
 * @ctxt:  an HTML parser context
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 * @reuse:  keep the context for reuse
 *
 * Common front-end for the htmlRead functions
 *
 * Returns the resulting document tree or NULL
 */
unsafe extern "C" fn htmlDoRead(mut ctxt: htmlParserCtxtPtr,
                                mut URL: *const std::os::raw::c_char,
                                mut encoding: *const std::os::raw::c_char,
                                mut options: std::os::raw::c_int,
                                mut reuse: std::os::raw::c_int) -> htmlDocPtr {
    let mut ret: htmlDocPtr = 0 as *mut xmlDoc;
    htmlCtxtUseOptions(ctxt, options);
    (*ctxt).html = 1 as std::os::raw::c_int;
    if !encoding.is_null() {
        let mut hdlr: xmlCharEncodingHandlerPtr =
            0 as *mut xmlCharEncodingHandler;
        hdlr = xmlFindCharEncodingHandler(encoding);
        if !hdlr.is_null() {
            xmlSwitchToEncoding(ctxt, hdlr);
            if !(*(*ctxt).input).encoding.is_null() {
                xmlFree.expect("non-null function pointer")((*(*ctxt).input).encoding
                                                                as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            (*(*ctxt).input).encoding = xmlStrdup(encoding as *mut xmlChar)
        }
    }
    if !URL.is_null() && !(*ctxt).input.is_null() &&
           (*(*ctxt).input).filename.is_null() {
        (*(*ctxt).input).filename =
            xmlStrdup(URL as *const xmlChar) as *mut std::os::raw::c_char
    }
    htmlParseDocument(ctxt);
    ret = (*ctxt).myDoc;
    (*ctxt).myDoc = 0 as xmlDocPtr;
    if reuse == 0 {
        if (*ctxt).dictNames != 0 && !ret.is_null() &&
               (*ret).dict == (*ctxt).dict {
            (*ctxt).dict = 0 as xmlDictPtr
        }
        xmlFreeParserCtxt(ctxt);
    }
    return ret;
}
/* *
 * htmlReadDoc:
 * @cur:  a pointer to a zero terminated string
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an XML in-memory document and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlReadDoc(mut cur: *const xmlChar,
                                     mut URL: *const std::os::raw::c_char,
                                     mut encoding: *const std::os::raw::c_char,
                                     mut options: std::os::raw::c_int) -> htmlDocPtr {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    if cur.is_null() { return 0 as htmlDocPtr }
    xmlInitParser();
    ctxt = htmlCreateDocParserCtxt(cur, 0 as *const std::os::raw::c_char);
    if ctxt.is_null() { return 0 as htmlDocPtr }
    return htmlDoRead(ctxt, URL, encoding, options, 0 as std::os::raw::c_int);
}
/* *
 * htmlReadFile:
 * @filename:  a file or URL
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an XML file from the filesystem or the network.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlReadFile(mut filename: *const std::os::raw::c_char,
                                      mut encoding: *const std::os::raw::c_char,
                                      mut options: std::os::raw::c_int)
 -> htmlDocPtr {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    xmlInitParser();
    ctxt = htmlCreateFileParserCtxt(filename, encoding);
    if ctxt.is_null() { return 0 as htmlDocPtr }
    return htmlDoRead(ctxt, 0 as *const std::os::raw::c_char,
                      0 as *const std::os::raw::c_char, options, 0 as std::os::raw::c_int);
}
/* *
 * htmlReadMemory:
 * @buffer:  a pointer to a char array
 * @size:  the size of the array
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an XML in-memory document and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlReadMemory(mut buffer: *const std::os::raw::c_char,
                                        mut size: std::os::raw::c_int,
                                        mut URL: *const std::os::raw::c_char,
                                        mut encoding: *const std::os::raw::c_char,
                                        mut options: std::os::raw::c_int)
 -> htmlDocPtr {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    xmlInitParser();
    ctxt = xmlCreateMemoryParserCtxt(buffer, size);
    if ctxt.is_null() { return 0 as htmlDocPtr }
    htmlDefaultSAXHandlerInit();
    if !(*ctxt).sax.is_null() {
        memcpy((*ctxt).sax as *mut std::os::raw::c_void,
               __htmlDefaultSAXHandler() as *const std::os::raw::c_void,
               ::std::mem::size_of::<xmlSAXHandlerV1>() as std::os::raw::c_ulong);
    }
    return htmlDoRead(ctxt, URL, encoding, options, 0 as std::os::raw::c_int);
}
/* *
 * htmlReadFd:
 * @fd:  an open file descriptor
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an XML from a file descriptor and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlReadFd(mut fd: std::os::raw::c_int,
                                    mut URL: *const std::os::raw::c_char,
                                    mut encoding: *const std::os::raw::c_char,
                                    mut options: std::os::raw::c_int) -> htmlDocPtr {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if fd < 0 as std::os::raw::c_int { return 0 as htmlDocPtr }
    xmlInitParser();
    xmlInitParser();
    input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
    if input.is_null() { return 0 as htmlDocPtr }
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as htmlDocPtr
    }
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        xmlFreeParserCtxt(ctxt);
        return 0 as htmlDocPtr
    }
    inputPush(ctxt, stream);
    return htmlDoRead(ctxt, URL, encoding, options, 0 as std::os::raw::c_int);
}
/* *
 * htmlReadIO:
 * @ioread:  an I/O read function
 * @ioclose:  an I/O close function
 * @ioctx:  an I/O handler
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an HTML document from I/O functions and source and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlReadIO(mut ioread: xmlInputReadCallback,
                                    mut ioclose: xmlInputCloseCallback,
                                    mut ioctx: *mut std::os::raw::c_void,
                                    mut URL: *const std::os::raw::c_char,
                                    mut encoding: *const std::os::raw::c_char,
                                    mut options: std::os::raw::c_int) -> htmlDocPtr {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if ioread.is_none() { return 0 as htmlDocPtr }
    xmlInitParser();
    input =
        xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
                                     XML_CHAR_ENCODING_NONE);
    if input.is_null() {
        if ioclose.is_some() {
            ioclose.expect("non-null function pointer")(ioctx);
        }
        return 0 as htmlDocPtr
    }
    ctxt = htmlNewParserCtxt();
    if ctxt.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as htmlDocPtr
    }
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        xmlFreeParserCtxt(ctxt);
        return 0 as htmlDocPtr
    }
    inputPush(ctxt, stream);
    return htmlDoRead(ctxt, URL, encoding, options, 0 as std::os::raw::c_int);
}
/* *
 * htmlCtxtReadDoc:
 * @ctxt:  an HTML parser context
 * @cur:  a pointer to a zero terminated string
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an XML in-memory document and build a tree.
 * This reuses the existing @ctxt parser context
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCtxtReadDoc(mut ctxt: htmlParserCtxtPtr,
                                         mut cur: *const xmlChar,
                                         mut URL: *const std::os::raw::c_char,
                                         mut encoding: *const std::os::raw::c_char,
                                         mut options: std::os::raw::c_int)
 -> htmlDocPtr {
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if cur.is_null() { return 0 as htmlDocPtr }
    if ctxt.is_null() { return 0 as htmlDocPtr }
    xmlInitParser();
    htmlCtxtReset(ctxt);
    stream = xmlNewStringInputStream(ctxt, cur);
    if stream.is_null() { return 0 as htmlDocPtr }
    inputPush(ctxt, stream);
    return htmlDoRead(ctxt, URL, encoding, options, 1 as std::os::raw::c_int);
}
/* *
 * htmlCtxtReadFile:
 * @ctxt:  an HTML parser context
 * @filename:  a file or URL
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an XML file from the filesystem or the network.
 * This reuses the existing @ctxt parser context
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCtxtReadFile(mut ctxt: htmlParserCtxtPtr,
                                          mut filename: *const std::os::raw::c_char,
                                          mut encoding: *const std::os::raw::c_char,
                                          mut options: std::os::raw::c_int)
 -> htmlDocPtr {
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if filename.is_null() { return 0 as htmlDocPtr }
    if ctxt.is_null() { return 0 as htmlDocPtr }
    xmlInitParser();
    htmlCtxtReset(ctxt);
    stream = xmlLoadExternalEntity(filename, 0 as *const std::os::raw::c_char, ctxt);
    if stream.is_null() { return 0 as htmlDocPtr }
    inputPush(ctxt, stream);
    return htmlDoRead(ctxt, 0 as *const std::os::raw::c_char, encoding, options,
                      1 as std::os::raw::c_int);
}
/* *
 * htmlCtxtReadMemory:
 * @ctxt:  an HTML parser context
 * @buffer:  a pointer to a char array
 * @size:  the size of the array
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an XML in-memory document and build a tree.
 * This reuses the existing @ctxt parser context
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCtxtReadMemory(mut ctxt: htmlParserCtxtPtr,
                                            mut buffer: *const std::os::raw::c_char,
                                            mut size: std::os::raw::c_int,
                                            mut URL: *const std::os::raw::c_char,
                                            mut encoding: *const std::os::raw::c_char,
                                            mut options: std::os::raw::c_int)
 -> htmlDocPtr {
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if ctxt.is_null() { return 0 as htmlDocPtr }
    if buffer.is_null() { return 0 as htmlDocPtr }
    xmlInitParser();
    htmlCtxtReset(ctxt);
    input =
        xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
    if input.is_null() { return 0 as htmlDocPtr }
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as htmlDocPtr
    }
    inputPush(ctxt, stream);
    return htmlDoRead(ctxt, URL, encoding, options, 1 as std::os::raw::c_int);
}
/* *
 * htmlCtxtReadFd:
 * @ctxt:  an HTML parser context
 * @fd:  an open file descriptor
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an XML from a file descriptor and build a tree.
 * This reuses the existing @ctxt parser context
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCtxtReadFd(mut ctxt: htmlParserCtxtPtr,
                                        mut fd: std::os::raw::c_int,
                                        mut URL: *const std::os::raw::c_char,
                                        mut encoding: *const std::os::raw::c_char,
                                        mut options: std::os::raw::c_int)
 -> htmlDocPtr {
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if fd < 0 as std::os::raw::c_int { return 0 as htmlDocPtr }
    if ctxt.is_null() { return 0 as htmlDocPtr }
    xmlInitParser();
    htmlCtxtReset(ctxt);
    input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
    if input.is_null() { return 0 as htmlDocPtr }
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as htmlDocPtr
    }
    inputPush(ctxt, stream);
    return htmlDoRead(ctxt, URL, encoding, options, 1 as std::os::raw::c_int);
}
/* *
 * htmlCtxtReadIO:
 * @ctxt:  an HTML parser context
 * @ioread:  an I/O read function
 * @ioclose:  an I/O close function
 * @ioctx:  an I/O handler
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of htmlParserOption(s)
 *
 * parse an HTML document from I/O functions and source and build a tree.
 * This reuses the existing @ctxt parser context
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn htmlCtxtReadIO(mut ctxt: htmlParserCtxtPtr,
                                        mut ioread: xmlInputReadCallback,
                                        mut ioclose: xmlInputCloseCallback,
                                        mut ioctx: *mut std::os::raw::c_void,
                                        mut URL: *const std::os::raw::c_char,
                                        mut encoding: *const std::os::raw::c_char,
                                        mut options: std::os::raw::c_int)
 -> htmlDocPtr {
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if ioread.is_none() { return 0 as htmlDocPtr }
    if ctxt.is_null() { return 0 as htmlDocPtr }
    xmlInitParser();
    htmlCtxtReset(ctxt);
    input =
        xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
                                     XML_CHAR_ENCODING_NONE);
    if input.is_null() {
        if ioclose.is_some() {
            ioclose.expect("non-null function pointer")(ioctx);
        }
        return 0 as htmlDocPtr
    }
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as htmlDocPtr
    }
    inputPush(ctxt, stream);
    return htmlDoRead(ctxt, URL, encoding, options, 1 as std::os::raw::c_int);
}
/* LIBXML_HTML_ENABLED */
/* __INCLUDE_ELFGCCHACK */
