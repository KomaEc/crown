
extern "C" {
    pub type _xmlDict;
    /*
 * Summary: set of routines to process strings
 * Description: type and interfaces needed for the internal string handling
 *              of the library, especially UTF8 processing.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlChar:
 *
 * This is a basic byte in an UTF-8 encoded string.
 * It's unsigned allowing to pinpoint case where char * are assigned
 * to xmlChar * (possibly making serialization back impossible).
 */
    /* *
 * BAD_CAST:
 *
 * Macro to cast a string to an xmlChar * when one know its safe.
 */
    /*
 * xmlChar handling
 */
    #[no_mangle]
    fn xmlStrQEqual(pref: *const xmlChar, name: *const xmlChar,
                    str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> std::os::raw::c_int;
    /*
 * internal thread safe random function
 */
    #[no_mangle]
    fn __xmlRandom() -> std::os::raw::c_int;
    #[no_mangle]
    fn memset(_: *mut std::os::raw::c_void, _: std::os::raw::c_int, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn memcpy(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_void, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlDictReference(dict: xmlDictPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDictFree(dict: xmlDictPtr);
    /*
 * Lookup of entry in the dictionary.
 */
    #[no_mangle]
    fn xmlDictLookup(dict: xmlDictPtr, name: *const xmlChar, len: std::os::raw::c_int)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlDictOwns(dict: xmlDictPtr, str: *const xmlChar) -> std::os::raw::c_int;
    /*
 * Summary: interface for all global variables of the library
 * Description: all the global variables and thread handling for
 *              those variables is handled by this module.
 *
 * The bottom of this file is automatically generated by build_glob.py
 * based on the description file global.data
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
 */
    /* *
 * xmlParserInputBufferCreateFilenameFunc:
 * @URI: the URI to read from
 * @enc: the requested source encoding
 *
 * Signature for the function doing the lookup for a suitable input method
 * corresponding to an URI.
 *
 * Returns the new xmlParserInputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /* *
 * xmlOutputBufferCreateFilenameFunc:
 * @URI: the URI to write to
 * @enc: the requested target encoding
 *
 * Signature for the function doing the lookup for a suitable output method
 * corresponding to an URI.
 *
 * Returns the new xmlOutputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /*
 * Externally global symbols which need to be protected for backwards
 * compatibility support.
 */
    /* *
 * xmlRegisterNodeFunc:
 * @node: the current node
 *
 * Signature for the registration callback of a created node
 */
    /* *
 * xmlDeregisterNodeFunc:
 * @node: the current node
 *
 * Signature for the deregistration callback of a discarded node
 */
    /* * DOC_DISABLE */
/*
 * In general the memory allocation entry points are not kept
 * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED
 *    - xmlMalloc
 *    - xmlMallocAtomic
 *    - xmlRealloc
 *    - xmlMemStrdup
 *    - xmlFree
 */
    /* !LIBXML_THREAD_ALLOC_ENABLED */
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    #[no_mangle]
    static mut xmlMalloc: xmlMallocFunc;
}
pub type xmlChar = std::os::raw::c_uchar;
pub type size_t = std::os::raw::c_ulong;
pub type xmlHashTablePtr = *mut xmlHashTable;
pub type xmlHashTable = _xmlHashTable;
/*
 * The entire hash table
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlHashTable {
    pub table: *mut _xmlHashEntry,
    pub size: std::os::raw::c_int,
    pub nbElems: std::os::raw::c_int,
    pub dict: xmlDictPtr,
    pub random_seed: std::os::raw::c_int,
}
pub type xmlDictPtr = *mut xmlDict;
/*
 * Summary: string dictionary
 * Description: dictionary of reusable strings, just used to avoid allocation
 *         and freeing operations.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * The dictionary.
 */
pub type xmlDict = _xmlDict;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlHashEntry {
    pub next: *mut _xmlHashEntry,
    pub name: *mut xmlChar,
    pub name2: *mut xmlChar,
    pub name3: *mut xmlChar,
    pub payload: *mut std::os::raw::c_void,
    pub valid: std::os::raw::c_int,
}
pub type xmlHashDeallocator
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type xmlHashCopier
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> *mut std::os::raw::c_void>;
pub type xmlHashScanner
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_void,
                                _: *const xmlChar) -> ()>;
pub type xmlHashScannerFull
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_void,
                                _: *const xmlChar, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */
/* *
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/* *
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
/* #define DEBUG_GROW */
/*
 * A single entry in the hash table
 */
pub type xmlHashEntry = _xmlHashEntry;
/* *
 * xmlMallocFunc:
 * @size:  the size requested in bytes
 *
 * Signature for a malloc() implementation.
 *
 * Returns a pointer to the newly allocated block or NULL in case of error.
 */
pub type xmlMallocFunc
    =
    Option<unsafe extern "C" fn(_: size_t) -> *mut std::os::raw::c_void>;
pub type xmlHashEntryPtr = *mut xmlHashEntry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stubData {
    pub hashscanner: xmlHashScanner,
    pub data: *mut std::os::raw::c_void,
}
/*
 * xmlHashComputeKey:
 * Calculate the hash key
 */
unsafe extern "C" fn xmlHashComputeKey(mut table: xmlHashTablePtr,
                                       mut name: *const xmlChar,
                                       mut name2: *const xmlChar,
                                       mut name3: *const xmlChar)
 -> std::os::raw::c_ulong {
    let mut value: std::os::raw::c_ulong = 0 as std::os::raw::c_long as std::os::raw::c_ulong;
    let mut ch: std::os::raw::c_char = 0;
    value = (*table).random_seed as std::os::raw::c_ulong;
    if !name.is_null() {
        value =
            value.wrapping_add((30 as std::os::raw::c_int * *name as std::os::raw::c_int) as
                                   std::os::raw::c_ulong);
        loop  {
            let fresh0 = name;
            name = name.offset(1);
            ch = *fresh0 as std::os::raw::c_char;
            if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
            value =
                value ^
                    (value <<
                         5 as
                             std::os::raw::c_int).wrapping_add(value >>
                                                           3 as
                                                               std::os::raw::c_int).wrapping_add(ch
                                                                                             as
                                                                                             std::os::raw::c_ulong)
        }
    }
    value =
        value ^
            (value <<
                 5 as std::os::raw::c_int).wrapping_add(value >> 3 as std::os::raw::c_int);
    if !name2.is_null() {
        loop  {
            let fresh1 = name2;
            name2 = name2.offset(1);
            ch = *fresh1 as std::os::raw::c_char;
            if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
            value =
                value ^
                    (value <<
                         5 as
                             std::os::raw::c_int).wrapping_add(value >>
                                                           3 as
                                                               std::os::raw::c_int).wrapping_add(ch
                                                                                             as
                                                                                             std::os::raw::c_ulong)
        }
    }
    value =
        value ^
            (value <<
                 5 as std::os::raw::c_int).wrapping_add(value >> 3 as std::os::raw::c_int);
    if !name3.is_null() {
        loop  {
            let fresh2 = name3;
            name3 = name3.offset(1);
            ch = *fresh2 as std::os::raw::c_char;
            if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
            value =
                value ^
                    (value <<
                         5 as
                             std::os::raw::c_int).wrapping_add(value >>
                                                           3 as
                                                               std::os::raw::c_int).wrapping_add(ch
                                                                                             as
                                                                                             std::os::raw::c_ulong)
        }
    }
    return value.wrapping_rem((*table).size as std::os::raw::c_ulong);
}
unsafe extern "C" fn xmlHashComputeQKey(mut table: xmlHashTablePtr,
                                        mut prefix: *const xmlChar,
                                        mut name: *const xmlChar,
                                        mut prefix2: *const xmlChar,
                                        mut name2: *const xmlChar,
                                        mut prefix3: *const xmlChar,
                                        mut name3: *const xmlChar)
 -> std::os::raw::c_ulong {
    let mut value: std::os::raw::c_ulong = 0 as std::os::raw::c_long as std::os::raw::c_ulong;
    let mut ch: std::os::raw::c_char = 0;
    value = (*table).random_seed as std::os::raw::c_ulong;
    if !prefix.is_null() {
        value =
            value.wrapping_add((30 as std::os::raw::c_int * *prefix as std::os::raw::c_int) as
                                   std::os::raw::c_ulong)
    } else {
        value =
            value.wrapping_add((30 as std::os::raw::c_int * *name as std::os::raw::c_int) as
                                   std::os::raw::c_ulong)
    }
    if !prefix.is_null() {
        loop  {
            let fresh3 = prefix;
            prefix = prefix.offset(1);
            ch = *fresh3 as std::os::raw::c_char;
            if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
            value =
                value ^
                    (value <<
                         5 as
                             std::os::raw::c_int).wrapping_add(value >>
                                                           3 as
                                                               std::os::raw::c_int).wrapping_add(ch
                                                                                             as
                                                                                             std::os::raw::c_ulong)
        }
        value =
            value ^
                (value <<
                     5 as
                         std::os::raw::c_int).wrapping_add(value >>
                                                       3 as
                                                           std::os::raw::c_int).wrapping_add(':'
                                                                                         as
                                                                                         i32
                                                                                         as
                                                                                         std::os::raw::c_ulong)
    }
    if !name.is_null() {
        loop  {
            let fresh4 = name;
            name = name.offset(1);
            ch = *fresh4 as std::os::raw::c_char;
            if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
            value =
                value ^
                    (value <<
                         5 as
                             std::os::raw::c_int).wrapping_add(value >>
                                                           3 as
                                                               std::os::raw::c_int).wrapping_add(ch
                                                                                             as
                                                                                             std::os::raw::c_ulong)
        }
    }
    value =
        value ^
            (value <<
                 5 as std::os::raw::c_int).wrapping_add(value >> 3 as std::os::raw::c_int);
    if !prefix2.is_null() {
        loop  {
            let fresh5 = prefix2;
            prefix2 = prefix2.offset(1);
            ch = *fresh5 as std::os::raw::c_char;
            if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
            value =
                value ^
                    (value <<
                         5 as
                             std::os::raw::c_int).wrapping_add(value >>
                                                           3 as
                                                               std::os::raw::c_int).wrapping_add(ch
                                                                                             as
                                                                                             std::os::raw::c_ulong)
        }
        value =
            value ^
                (value <<
                     5 as
                         std::os::raw::c_int).wrapping_add(value >>
                                                       3 as
                                                           std::os::raw::c_int).wrapping_add(':'
                                                                                         as
                                                                                         i32
                                                                                         as
                                                                                         std::os::raw::c_ulong)
    }
    if !name2.is_null() {
        loop  {
            let fresh6 = name2;
            name2 = name2.offset(1);
            ch = *fresh6 as std::os::raw::c_char;
            if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
            value =
                value ^
                    (value <<
                         5 as
                             std::os::raw::c_int).wrapping_add(value >>
                                                           3 as
                                                               std::os::raw::c_int).wrapping_add(ch
                                                                                             as
                                                                                             std::os::raw::c_ulong)
        }
    }
    value =
        value ^
            (value <<
                 5 as std::os::raw::c_int).wrapping_add(value >> 3 as std::os::raw::c_int);
    if !prefix3.is_null() {
        loop  {
            let fresh7 = prefix3;
            prefix3 = prefix3.offset(1);
            ch = *fresh7 as std::os::raw::c_char;
            if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
            value =
                value ^
                    (value <<
                         5 as
                             std::os::raw::c_int).wrapping_add(value >>
                                                           3 as
                                                               std::os::raw::c_int).wrapping_add(ch
                                                                                             as
                                                                                             std::os::raw::c_ulong)
        }
        value =
            value ^
                (value <<
                     5 as
                         std::os::raw::c_int).wrapping_add(value >>
                                                       3 as
                                                           std::os::raw::c_int).wrapping_add(':'
                                                                                         as
                                                                                         i32
                                                                                         as
                                                                                         std::os::raw::c_ulong)
    }
    if !name3.is_null() {
        loop  {
            let fresh8 = name3;
            name3 = name3.offset(1);
            ch = *fresh8 as std::os::raw::c_char;
            if !(ch as std::os::raw::c_int != 0 as std::os::raw::c_int) { break ; }
            value =
                value ^
                    (value <<
                         5 as
                             std::os::raw::c_int).wrapping_add(value >>
                                                           3 as
                                                               std::os::raw::c_int).wrapping_add(ch
                                                                                             as
                                                                                             std::os::raw::c_ulong)
        }
    }
    return value.wrapping_rem((*table).size as std::os::raw::c_ulong);
}
/* *
 * xmlHashCreate:
 * @size: the size of the hash table
 *
 * Create a new xmlHashTablePtr.
 *
 * Returns the newly created object, or NULL if an error occurred.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashCreate(mut size: std::os::raw::c_int)
 -> xmlHashTablePtr {
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    if size <= 0 as std::os::raw::c_int { size = 256 as std::os::raw::c_int }
    table =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlHashTable>()
                                                          as std::os::raw::c_ulong) as
            xmlHashTablePtr;
    if !table.is_null() {
        (*table).dict = 0 as xmlDictPtr;
        (*table).size = size;
        (*table).nbElems = 0 as std::os::raw::c_int;
        (*table).table =
            xmlMalloc.expect("non-null function pointer")((size as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlHashEntry>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut _xmlHashEntry;
        if !(*table).table.is_null() {
            memset((*table).table as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
                   (size as
                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlHashEntry>()
                                                        as std::os::raw::c_ulong));
            (*table).random_seed = __xmlRandom();
            return table
        }
        xmlFree.expect("non-null function pointer")(table as
                                                        *mut std::os::raw::c_void);
    }
    return 0 as xmlHashTablePtr;
}
/* *
 * xmlHashCreateDict:
 * @size: the size of the hash table
 * @dict: a dictionary to use for the hash
 *
 * Create a new xmlHashTablePtr which will use @dict as the internal dictionary
 *
 * Returns the newly created object, or NULL if an error occurred.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashCreateDict(mut size: std::os::raw::c_int,
                                           mut dict: xmlDictPtr)
 -> xmlHashTablePtr {
    let mut table: xmlHashTablePtr = 0 as *mut xmlHashTable;
    table = xmlHashCreate(size);
    if !table.is_null() { (*table).dict = dict; xmlDictReference(dict); }
    return table;
}
/* *
 * xmlHashGrow:
 * @table: the hash table
 * @size: the new size of the hash table
 *
 * resize the hash table
 *
 * Returns 0 in case of success, -1 in case of failure
 */
unsafe extern "C" fn xmlHashGrow(mut table: xmlHashTablePtr,
                                 mut size: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut key: std::os::raw::c_ulong = 0;
    let mut oldsize: std::os::raw::c_int = 0;
    let mut i: std::os::raw::c_int = 0;
    let mut iter: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut next: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut oldtable: *mut _xmlHashEntry = 0 as *mut _xmlHashEntry;
    if table.is_null() { return -(1 as std::os::raw::c_int) }
    if size < 8 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
    if size > 8 as std::os::raw::c_int * 2048 as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    oldsize = (*table).size;
    oldtable = (*table).table;
    if oldtable.is_null() { return -(1 as std::os::raw::c_int) }
    (*table).table =
        xmlMalloc.expect("non-null function pointer")((size as
                                                           std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlHashEntry>()
                                                                                           as
                                                                                           std::os::raw::c_ulong))
            as *mut _xmlHashEntry;
    if (*table).table.is_null() {
        (*table).table = oldtable;
        return -(1 as std::os::raw::c_int)
    }
    memset((*table).table as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           (size as
                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlHashEntry>()
                                                as std::os::raw::c_ulong));
    (*table).size = size;
    /*	If the two loops are merged, there would be situations where
	a new entry needs to allocated and data copied into it from
	the main table. So instead, we run through the array twice, first
	copying all the elements in the main array (where we can't get
	conflicts) and then the rest, so we only free (and don't allocate)
    */
    i = 0 as std::os::raw::c_int;
    while i < oldsize {
        if !((*oldtable.offset(i as isize)).valid == 0 as std::os::raw::c_int) {
            key =
                xmlHashComputeKey(table, (*oldtable.offset(i as isize)).name,
                                  (*oldtable.offset(i as isize)).name2,
                                  (*oldtable.offset(i as isize)).name3);
            memcpy(&mut *(*table).table.offset(key as isize) as
                       *mut _xmlHashEntry as *mut std::os::raw::c_void,
                   &mut *oldtable.offset(i as isize) as *mut _xmlHashEntry as
                       *const std::os::raw::c_void,
                   ::std::mem::size_of::<xmlHashEntry>() as std::os::raw::c_ulong);
            let ref mut fresh9 = (*(*table).table.offset(key as isize)).next;
            *fresh9 = 0 as *mut _xmlHashEntry
        }
        i += 1
    }
    i = 0 as std::os::raw::c_int;
    while i < oldsize {
        iter = (*oldtable.offset(i as isize)).next;
        while !iter.is_null() {
            next = (*iter).next;
            /*
	     * put back the entry in the new table
	     */
            key =
                xmlHashComputeKey(table, (*iter).name, (*iter).name2,
                                  (*iter).name3);
            if (*(*table).table.offset(key as isize)).valid ==
                   0 as std::os::raw::c_int {
                memcpy(&mut *(*table).table.offset(key as isize) as
                           *mut _xmlHashEntry as *mut std::os::raw::c_void,
                       iter as *const std::os::raw::c_void,
                       ::std::mem::size_of::<xmlHashEntry>() as
                           std::os::raw::c_ulong);
                let ref mut fresh10 =
                    (*(*table).table.offset(key as isize)).next;
                *fresh10 = 0 as *mut _xmlHashEntry;
                xmlFree.expect("non-null function pointer")(iter as
                                                                *mut std::os::raw::c_void);
            } else {
                (*iter).next = (*(*table).table.offset(key as isize)).next;
                let ref mut fresh11 =
                    (*(*table).table.offset(key as isize)).next;
                *fresh11 = iter
            }
            iter = next
        }
        i += 1
    }
    xmlFree.expect("non-null function pointer")(oldtable as
                                                    *mut std::os::raw::c_void);
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlHashFree:
 * @table: the hash table
 * @f:  the deallocator function for items in the hash
 *
 * Free the hash @table and its contents. The userdata is
 * deallocated with @f if provided.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashFree(mut table: xmlHashTablePtr,
                                     mut f: xmlHashDeallocator) {
    let mut i: std::os::raw::c_int = 0;
    let mut iter: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut next: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut inside_table: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut nbElems: std::os::raw::c_int = 0;
    if table.is_null() { return }
    if !(*table).table.is_null() {
        nbElems = (*table).nbElems;
        i = 0 as std::os::raw::c_int;
        while i < (*table).size && nbElems > 0 as std::os::raw::c_int {
            iter =
                &mut *(*table).table.offset(i as isize) as *mut _xmlHashEntry;
            if !((*iter).valid == 0 as std::os::raw::c_int) {
                inside_table = 1 as std::os::raw::c_int;
                while !iter.is_null() {
                    next = (*iter).next;
                    if f.is_some() && !(*iter).payload.is_null() {
                        f.expect("non-null function pointer")((*iter).payload,
                                                              (*iter).name);
                    }
                    if (*table).dict.is_null() {
                        if !(*iter).name.is_null() {
                            xmlFree.expect("non-null function pointer")((*iter).name
                                                                            as
                                                                            *mut std::os::raw::c_void);
                        }
                        if !(*iter).name2.is_null() {
                            xmlFree.expect("non-null function pointer")((*iter).name2
                                                                            as
                                                                            *mut std::os::raw::c_void);
                        }
                        if !(*iter).name3.is_null() {
                            xmlFree.expect("non-null function pointer")((*iter).name3
                                                                            as
                                                                            *mut std::os::raw::c_void);
                        }
                    }
                    (*iter).payload = 0 as *mut std::os::raw::c_void;
                    if inside_table == 0 {
                        xmlFree.expect("non-null function pointer")(iter as
                                                                        *mut std::os::raw::c_void);
                    }
                    nbElems -= 1;
                    inside_table = 0 as std::os::raw::c_int;
                    iter = next
                }
            }
            i += 1
        }
        xmlFree.expect("non-null function pointer")((*table).table as
                                                        *mut std::os::raw::c_void);
    }
    if !(*table).dict.is_null() { xmlDictFree((*table).dict); }
    xmlFree.expect("non-null function pointer")(table as *mut std::os::raw::c_void);
}
/* *
 * xmlHashDefaultDeallocator:
 * @entry: the hash table entry
 * @name: the entry's name
 *
 * Free a hash table entry with xmlFree.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashDefaultDeallocator(mut entry:
                                                       *mut std::os::raw::c_void,
                                                   mut name: *const xmlChar) {
    xmlFree.expect("non-null function pointer")(entry);
}
/* *
 * xmlHashAddEntry:
 * @table: the hash table
 * @name: the name of the userdata
 * @userdata: a pointer to the userdata
 *
 * Add the @userdata to the hash @table. This can later be retrieved
 * by using the @name. Duplicate names generate errors.
 *
 * Returns 0 the addition succeeded and -1 in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashAddEntry(mut table: xmlHashTablePtr,
                                         mut name: *const xmlChar,
                                         mut userdata: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    return xmlHashAddEntry3(table, name, 0 as *const xmlChar,
                            0 as *const xmlChar, userdata);
}
/* *
 * xmlHashAddEntry2:
 * @table: the hash table
 * @name: the name of the userdata
 * @name2: a second name of the userdata
 * @userdata: a pointer to the userdata
 *
 * Add the @userdata to the hash @table. This can later be retrieved
 * by using the (@name, @name2) tuple. Duplicate tuples generate errors.
 *
 * Returns 0 the addition succeeded and -1 in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashAddEntry2(mut table: xmlHashTablePtr,
                                          mut name: *const xmlChar,
                                          mut name2: *const xmlChar,
                                          mut userdata: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    return xmlHashAddEntry3(table, name, name2, 0 as *const xmlChar,
                            userdata);
}
/* *
 * xmlHashUpdateEntry:
 * @table: the hash table
 * @name: the name of the userdata
 * @userdata: a pointer to the userdata
 * @f: the deallocator function for replaced item (if any)
 *
 * Add the @userdata to the hash @table. This can later be retrieved
 * by using the @name. Existing entry for this @name will be removed
 * and freed with @f if found.
 *
 * Returns 0 the addition succeeded and -1 in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashUpdateEntry(mut table: xmlHashTablePtr,
                                            mut name: *const xmlChar,
                                            mut userdata: *mut std::os::raw::c_void,
                                            mut f: xmlHashDeallocator)
 -> std::os::raw::c_int {
    return xmlHashUpdateEntry3(table, name, 0 as *const xmlChar,
                               0 as *const xmlChar, userdata, f);
}
/* *
 * xmlHashUpdateEntry2:
 * @table: the hash table
 * @name: the name of the userdata
 * @name2: a second name of the userdata
 * @userdata: a pointer to the userdata
 * @f: the deallocator function for replaced item (if any)
 *
 * Add the @userdata to the hash @table. This can later be retrieved
 * by using the (@name, @name2) tuple. Existing entry for this tuple will
 * be removed and freed with @f if found.
 *
 * Returns 0 the addition succeeded and -1 in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashUpdateEntry2(mut table: xmlHashTablePtr,
                                             mut name: *const xmlChar,
                                             mut name2: *const xmlChar,
                                             mut userdata: *mut std::os::raw::c_void,
                                             mut f: xmlHashDeallocator)
 -> std::os::raw::c_int {
    return xmlHashUpdateEntry3(table, name, name2, 0 as *const xmlChar,
                               userdata, f);
}
/* *
 * xmlHashLookup:
 * @table: the hash table
 * @name: the name of the userdata
 *
 * Find the userdata specified by the @name.
 *
 * Returns the pointer to the userdata
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashLookup(mut table: xmlHashTablePtr,
                                       mut name: *const xmlChar)
 -> *mut std::os::raw::c_void {
    return xmlHashLookup3(table, name, 0 as *const xmlChar,
                          0 as *const xmlChar);
}
/* *
 * xmlHashLookup2:
 * @table: the hash table
 * @name: the name of the userdata
 * @name2: a second name of the userdata
 *
 * Find the userdata specified by the (@name, @name2) tuple.
 *
 * Returns the pointer to the userdata
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashLookup2(mut table: xmlHashTablePtr,
                                        mut name: *const xmlChar,
                                        mut name2: *const xmlChar)
 -> *mut std::os::raw::c_void {
    return xmlHashLookup3(table, name, name2, 0 as *const xmlChar);
}
/* *
 * xmlHashQLookup:
 * @table: the hash table
 * @prefix: the prefix of the userdata
 * @name: the name of the userdata
 *
 * Find the userdata specified by the QName @prefix:@name/@name.
 *
 * Returns the pointer to the userdata
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashQLookup(mut table: xmlHashTablePtr,
                                        mut prefix: *const xmlChar,
                                        mut name: *const xmlChar)
 -> *mut std::os::raw::c_void {
    return xmlHashQLookup3(table, prefix, name, 0 as *const xmlChar,
                           0 as *const xmlChar, 0 as *const xmlChar,
                           0 as *const xmlChar);
}
/* *
 * xmlHashQLookup2:
 * @table: the hash table
 * @prefix: the prefix of the userdata
 * @name: the name of the userdata
 * @prefix2: the second prefix of the userdata
 * @name2: a second name of the userdata
 *
 * Find the userdata specified by the QNames tuple
 *
 * Returns the pointer to the userdata
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashQLookup2(mut table: xmlHashTablePtr,
                                         mut prefix: *const xmlChar,
                                         mut name: *const xmlChar,
                                         mut prefix2: *const xmlChar,
                                         mut name2: *const xmlChar)
 -> *mut std::os::raw::c_void {
    return xmlHashQLookup3(table, prefix, name, prefix2, name2,
                           0 as *const xmlChar, 0 as *const xmlChar);
}
/* *
 * xmlHashAddEntry3:
 * @table: the hash table
 * @name: the name of the userdata
 * @name2: a second name of the userdata
 * @name3: a third name of the userdata
 * @userdata: a pointer to the userdata
 *
 * Add the @userdata to the hash @table. This can later be retrieved
 * by using the tuple (@name, @name2, @name3). Duplicate entries generate
 * errors.
 *
 * Returns 0 the addition succeeded and -1 in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashAddEntry3(mut table: xmlHashTablePtr,
                                          mut name: *const xmlChar,
                                          mut name2: *const xmlChar,
                                          mut name3: *const xmlChar,
                                          mut userdata: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut key: std::os::raw::c_ulong = 0;
    let mut len: std::os::raw::c_ulong = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    let mut entry: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut insert: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    if table.is_null() || name.is_null() { return -(1 as std::os::raw::c_int) }
    /*
     * If using a dict internalize if needed
     */
    if !(*table).dict.is_null() {
        if xmlDictOwns((*table).dict, name) == 0 {
            name = xmlDictLookup((*table).dict, name, -(1 as std::os::raw::c_int));
            if name.is_null() { return -(1 as std::os::raw::c_int) }
        }
        if !name2.is_null() && xmlDictOwns((*table).dict, name2) == 0 {
            name2 = xmlDictLookup((*table).dict, name2, -(1 as std::os::raw::c_int));
            if name2.is_null() { return -(1 as std::os::raw::c_int) }
        }
        if !name3.is_null() && xmlDictOwns((*table).dict, name3) == 0 {
            name3 = xmlDictLookup((*table).dict, name3, -(1 as std::os::raw::c_int));
            if name3.is_null() { return -(1 as std::os::raw::c_int) }
        }
    }
    /*
     * Check for duplicate and insertion location.
     */
    key = xmlHashComputeKey(table, name, name2, name3);
    if (*(*table).table.offset(key as isize)).valid == 0 as std::os::raw::c_int {
        insert = 0 as xmlHashEntryPtr
    } else if !(*table).dict.is_null() {
        insert =
            &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry;
        while !(*insert).next.is_null() {
            if (*insert).name == name as *mut xmlChar &&
                   (*insert).name2 == name2 as *mut xmlChar &&
                   (*insert).name3 == name3 as *mut xmlChar {
                return -(1 as std::os::raw::c_int)
            }
            len = len.wrapping_add(1);
            insert = (*insert).next
        }
        if (*insert).name == name as *mut xmlChar &&
               (*insert).name2 == name2 as *mut xmlChar &&
               (*insert).name3 == name3 as *mut xmlChar {
            return -(1 as std::os::raw::c_int)
        }
    } else {
        insert =
            &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry;
        while !(*insert).next.is_null() {
            if xmlStrEqual((*insert).name, name) != 0 &&
                   xmlStrEqual((*insert).name2, name2) != 0 &&
                   xmlStrEqual((*insert).name3, name3) != 0 {
                return -(1 as std::os::raw::c_int)
            }
            len = len.wrapping_add(1);
            insert = (*insert).next
        }
        if xmlStrEqual((*insert).name, name) != 0 &&
               xmlStrEqual((*insert).name2, name2) != 0 &&
               xmlStrEqual((*insert).name3, name3) != 0 {
            return -(1 as std::os::raw::c_int)
        }
    }
    if insert.is_null() {
        entry =
            &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry
    } else {
        entry =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlHashEntry>()
                                                              as
                                                              std::os::raw::c_ulong)
                as xmlHashEntryPtr;
        if entry.is_null() { return -(1 as std::os::raw::c_int) }
    }
    if !(*table).dict.is_null() {
        (*entry).name = name as *mut xmlChar;
        (*entry).name2 = name2 as *mut xmlChar;
        (*entry).name3 = name3 as *mut xmlChar
    } else {
        (*entry).name = xmlStrdup(name);
        (*entry).name2 = xmlStrdup(name2);
        (*entry).name3 = xmlStrdup(name3)
    }
    (*entry).payload = userdata;
    (*entry).next = 0 as *mut _xmlHashEntry;
    (*entry).valid = 1 as std::os::raw::c_int;
    if !insert.is_null() { (*insert).next = entry }
    (*table).nbElems += 1;
    if len > 8 as std::os::raw::c_int as std::os::raw::c_ulong {
        xmlHashGrow(table, 8 as std::os::raw::c_int * (*table).size);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlHashUpdateEntry3:
 * @table: the hash table
 * @name: the name of the userdata
 * @name2: a second name of the userdata
 * @name3: a third name of the userdata
 * @userdata: a pointer to the userdata
 * @f: the deallocator function for replaced item (if any)
 *
 * Add the @userdata to the hash @table. This can later be retrieved
 * by using the tuple (@name, @name2, @name3). Existing entry for this tuple
 * will be removed and freed with @f if found.
 *
 * Returns 0 the addition succeeded and -1 in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashUpdateEntry3(mut table: xmlHashTablePtr,
                                             mut name: *const xmlChar,
                                             mut name2: *const xmlChar,
                                             mut name3: *const xmlChar,
                                             mut userdata: *mut std::os::raw::c_void,
                                             mut f: xmlHashDeallocator)
 -> std::os::raw::c_int {
    let mut key: std::os::raw::c_ulong = 0;
    let mut entry: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut insert: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    if table.is_null() || name.is_null() { return -(1 as std::os::raw::c_int) }
    /*
     * If using a dict internalize if needed
     */
    if !(*table).dict.is_null() {
        if xmlDictOwns((*table).dict, name) == 0 {
            name = xmlDictLookup((*table).dict, name, -(1 as std::os::raw::c_int));
            if name.is_null() { return -(1 as std::os::raw::c_int) }
        }
        if !name2.is_null() && xmlDictOwns((*table).dict, name2) == 0 {
            name2 = xmlDictLookup((*table).dict, name2, -(1 as std::os::raw::c_int));
            if name2.is_null() { return -(1 as std::os::raw::c_int) }
        }
        if !name3.is_null() && xmlDictOwns((*table).dict, name3) == 0 {
            name3 = xmlDictLookup((*table).dict, name3, -(1 as std::os::raw::c_int));
            if name3.is_null() { return -(1 as std::os::raw::c_int) }
        }
    }
    /*
     * Check for duplicate and insertion location.
     */
    key = xmlHashComputeKey(table, name, name2, name3);
    if (*(*table).table.offset(key as isize)).valid == 0 as std::os::raw::c_int {
        insert = 0 as xmlHashEntryPtr
    } else if !(*table).dict.is_null() {
        insert =
            &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry;
        while !(*insert).next.is_null() {
            if (*insert).name == name as *mut xmlChar &&
                   (*insert).name2 == name2 as *mut xmlChar &&
                   (*insert).name3 == name3 as *mut xmlChar {
                if f.is_some() {
                    f.expect("non-null function pointer")((*insert).payload,
                                                          (*insert).name);
                }
                (*insert).payload = userdata;
                return 0 as std::os::raw::c_int
            }
            insert = (*insert).next
        }
        if (*insert).name == name as *mut xmlChar &&
               (*insert).name2 == name2 as *mut xmlChar &&
               (*insert).name3 == name3 as *mut xmlChar {
            if f.is_some() {
                f.expect("non-null function pointer")((*insert).payload,
                                                      (*insert).name);
            }
            (*insert).payload = userdata;
            return 0 as std::os::raw::c_int
        }
    } else {
        insert =
            &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry;
        while !(*insert).next.is_null() {
            if xmlStrEqual((*insert).name, name) != 0 &&
                   xmlStrEqual((*insert).name2, name2) != 0 &&
                   xmlStrEqual((*insert).name3, name3) != 0 {
                if f.is_some() {
                    f.expect("non-null function pointer")((*insert).payload,
                                                          (*insert).name);
                }
                (*insert).payload = userdata;
                return 0 as std::os::raw::c_int
            }
            insert = (*insert).next
        }
        if xmlStrEqual((*insert).name, name) != 0 &&
               xmlStrEqual((*insert).name2, name2) != 0 &&
               xmlStrEqual((*insert).name3, name3) != 0 {
            if f.is_some() {
                f.expect("non-null function pointer")((*insert).payload,
                                                      (*insert).name);
            }
            (*insert).payload = userdata;
            return 0 as std::os::raw::c_int
        }
    }
    if insert.is_null() {
        entry =
            &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry
    } else {
        entry =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlHashEntry>()
                                                              as
                                                              std::os::raw::c_ulong)
                as xmlHashEntryPtr;
        if entry.is_null() { return -(1 as std::os::raw::c_int) }
    }
    if !(*table).dict.is_null() {
        (*entry).name = name as *mut xmlChar;
        (*entry).name2 = name2 as *mut xmlChar;
        (*entry).name3 = name3 as *mut xmlChar
    } else {
        (*entry).name = xmlStrdup(name);
        (*entry).name2 = xmlStrdup(name2);
        (*entry).name3 = xmlStrdup(name3)
    }
    (*entry).payload = userdata;
    (*entry).next = 0 as *mut _xmlHashEntry;
    (*entry).valid = 1 as std::os::raw::c_int;
    (*table).nbElems += 1;
    if !insert.is_null() { (*insert).next = entry }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlHashLookup3:
 * @table: the hash table
 * @name: the name of the userdata
 * @name2: a second name of the userdata
 * @name3: a third name of the userdata
 *
 * Find the userdata specified by the (@name, @name2, @name3) tuple.
 *
 * Returns the a pointer to the userdata
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashLookup3(mut table: xmlHashTablePtr,
                                        mut name: *const xmlChar,
                                        mut name2: *const xmlChar,
                                        mut name3: *const xmlChar)
 -> *mut std::os::raw::c_void {
    let mut key: std::os::raw::c_ulong = 0;
    let mut entry: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    if table.is_null() { return 0 as *mut std::os::raw::c_void }
    if name.is_null() { return 0 as *mut std::os::raw::c_void }
    key = xmlHashComputeKey(table, name, name2, name3);
    if (*(*table).table.offset(key as isize)).valid == 0 as std::os::raw::c_int {
        return 0 as *mut std::os::raw::c_void
    }
    if !(*table).dict.is_null() {
        entry =
            &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry;
        while !entry.is_null() {
            if (*entry).name == name as *mut xmlChar &&
                   (*entry).name2 == name2 as *mut xmlChar &&
                   (*entry).name3 == name3 as *mut xmlChar {
                return (*entry).payload
            }
            entry = (*entry).next
        }
    }
    entry = &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry;
    while !entry.is_null() {
        if xmlStrEqual((*entry).name, name) != 0 &&
               xmlStrEqual((*entry).name2, name2) != 0 &&
               xmlStrEqual((*entry).name3, name3) != 0 {
            return (*entry).payload
        }
        entry = (*entry).next
    }
    return 0 as *mut std::os::raw::c_void;
}
/* *
 * xmlHashQLookup3:
 * @table: the hash table
 * @prefix: the prefix of the userdata
 * @name: the name of the userdata
 * @prefix2: the second prefix of the userdata
 * @name2: a second name of the userdata
 * @prefix3: the third prefix of the userdata
 * @name3: a third name of the userdata
 *
 * Find the userdata specified by the (@name, @name2, @name3) tuple.
 *
 * Returns the a pointer to the userdata
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashQLookup3(mut table: xmlHashTablePtr,
                                         mut prefix: *const xmlChar,
                                         mut name: *const xmlChar,
                                         mut prefix2: *const xmlChar,
                                         mut name2: *const xmlChar,
                                         mut prefix3: *const xmlChar,
                                         mut name3: *const xmlChar)
 -> *mut std::os::raw::c_void {
    let mut key: std::os::raw::c_ulong = 0;
    let mut entry: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    if table.is_null() { return 0 as *mut std::os::raw::c_void }
    if name.is_null() { return 0 as *mut std::os::raw::c_void }
    key =
        xmlHashComputeQKey(table, prefix, name, prefix2, name2, prefix3,
                           name3);
    if (*(*table).table.offset(key as isize)).valid == 0 as std::os::raw::c_int {
        return 0 as *mut std::os::raw::c_void
    }
    entry = &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry;
    while !entry.is_null() {
        if xmlStrQEqual(prefix, name, (*entry).name) != 0 &&
               xmlStrQEqual(prefix2, name2, (*entry).name2) != 0 &&
               xmlStrQEqual(prefix3, name3, (*entry).name3) != 0 {
            return (*entry).payload
        }
        entry = (*entry).next
    }
    return 0 as *mut std::os::raw::c_void;
}
unsafe extern "C" fn stubHashScannerFull(mut payload: *mut std::os::raw::c_void,
                                         mut data: *mut std::os::raw::c_void,
                                         mut name: *const xmlChar,
                                         mut name2: *const xmlChar,
                                         mut name3: *const xmlChar) {
    let mut stubdata: *mut stubData = data as *mut stubData;
    (*stubdata).hashscanner.expect("non-null function pointer")(payload,
                                                                (*stubdata).data,
                                                                name as
                                                                    *mut xmlChar);
}
/* *
 * xmlHashScan:
 * @table: the hash table
 * @f:  the scanner function for items in the hash
 * @data:  extra data passed to f
 *
 * Scan the hash @table and applied @f to each value.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashScan(mut table: xmlHashTablePtr,
                                     mut f: xmlHashScanner,
                                     mut data: *mut std::os::raw::c_void) {
    let mut stubdata: stubData =
        stubData{hashscanner: None, data: 0 as *mut std::os::raw::c_void,};
    stubdata.data = data;
    stubdata.hashscanner = f;
    xmlHashScanFull(table,
                    Some(stubHashScannerFull as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *mut std::os::raw::c_void,
                                                  _: *const xmlChar,
                                                  _: *const xmlChar,
                                                  _: *const xmlChar) -> ()),
                    &mut stubdata as *mut stubData as *mut std::os::raw::c_void);
}
/* *
 * xmlHashScanFull:
 * @table: the hash table
 * @f:  the scanner function for items in the hash
 * @data:  extra data passed to f
 *
 * Scan the hash @table and applied @f to each value.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashScanFull(mut table: xmlHashTablePtr,
                                         mut f: xmlHashScannerFull,
                                         mut data: *mut std::os::raw::c_void) {
    let mut i: std::os::raw::c_int = 0;
    let mut nb: std::os::raw::c_int = 0;
    let mut iter: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut next: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    if table.is_null() { return }
    if f.is_none() { return }
    if !(*table).table.is_null() {
        i = 0 as std::os::raw::c_int;
        while i < (*table).size {
            if !((*(*table).table.offset(i as isize)).valid ==
                     0 as std::os::raw::c_int) {
                iter =
                    &mut *(*table).table.offset(i as isize) as
                        *mut _xmlHashEntry;
                while !iter.is_null() {
                    next = (*iter).next;
                    nb = (*table).nbElems;
                    if f.is_some() && !(*iter).payload.is_null() {
                        f.expect("non-null function pointer")((*iter).payload,
                                                              data,
                                                              (*iter).name,
                                                              (*iter).name2,
                                                              (*iter).name3);
                    }
                    if nb != (*table).nbElems {
                        /* table was modified by the callback, be careful */
                        if iter ==
                               &mut *(*table).table.offset(i as isize) as
                                   *mut _xmlHashEntry {
                            if (*(*table).table.offset(i as isize)).valid ==
                                   0 as std::os::raw::c_int {
                                iter = 0 as xmlHashEntryPtr
                            }
                            if (*(*table).table.offset(i as isize)).next !=
                                   next {
                                iter =
                                    &mut *(*table).table.offset(i as isize) as
                                        *mut _xmlHashEntry
                            }
                        } else { iter = next }
                    } else { iter = next }
                }
            }
            i += 1
        }
    };
}
/* *
 * xmlHashScan3:
 * @table: the hash table
 * @name: the name of the userdata or NULL
 * @name2: a second name of the userdata or NULL
 * @name3: a third name of the userdata or NULL
 * @f:  the scanner function for items in the hash
 * @data:  extra data passed to f
 *
 * Scan the hash @table and applied @f to each value matching
 * (@name, @name2, @name3) tuple. If one of the names is null,
 * the comparison is considered to match.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashScan3(mut table: xmlHashTablePtr,
                                      mut name: *const xmlChar,
                                      mut name2: *const xmlChar,
                                      mut name3: *const xmlChar,
                                      mut f: xmlHashScanner,
                                      mut data: *mut std::os::raw::c_void) {
    let mut stubdata: stubData =
        stubData{hashscanner: None, data: 0 as *mut std::os::raw::c_void,};
    stubdata.data = data;
    stubdata.hashscanner = f;
    xmlHashScanFull3(table, name, name2, name3,
                     Some(stubHashScannerFull as
                              unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                   _: *mut std::os::raw::c_void,
                                                   _: *const xmlChar,
                                                   _: *const xmlChar,
                                                   _: *const xmlChar) -> ()),
                     &mut stubdata as *mut stubData as *mut std::os::raw::c_void);
}
/* *
 * xmlHashScanFull3:
 * @table: the hash table
 * @name: the name of the userdata or NULL
 * @name2: a second name of the userdata or NULL
 * @name3: a third name of the userdata or NULL
 * @f:  the scanner function for items in the hash
 * @data:  extra data passed to f
 *
 * Scan the hash @table and applied @f to each value matching
 * (@name, @name2, @name3) tuple. If one of the names is null,
 * the comparison is considered to match.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashScanFull3(mut table: xmlHashTablePtr,
                                          mut name: *const xmlChar,
                                          mut name2: *const xmlChar,
                                          mut name3: *const xmlChar,
                                          mut f: xmlHashScannerFull,
                                          mut data: *mut std::os::raw::c_void) {
    let mut i: std::os::raw::c_int = 0;
    let mut iter: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut next: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    if table.is_null() { return }
    if f.is_none() { return }
    if !(*table).table.is_null() {
        i = 0 as std::os::raw::c_int;
        while i < (*table).size {
            if !((*(*table).table.offset(i as isize)).valid ==
                     0 as std::os::raw::c_int) {
                iter =
                    &mut *(*table).table.offset(i as isize) as
                        *mut _xmlHashEntry;
                while !iter.is_null() {
                    next = (*iter).next;
                    if (name.is_null() ||
                            xmlStrEqual(name, (*iter).name) != 0) &&
                           (name2.is_null() ||
                                xmlStrEqual(name2, (*iter).name2) != 0) &&
                           (name3.is_null() ||
                                xmlStrEqual(name3, (*iter).name3) != 0) &&
                           !(*iter).payload.is_null() {
                        f.expect("non-null function pointer")((*iter).payload,
                                                              data,
                                                              (*iter).name,
                                                              (*iter).name2,
                                                              (*iter).name3);
                    }
                    iter = next
                }
            }
            i += 1
        }
    };
}
/* *
 * xmlHashCopy:
 * @table: the hash table
 * @f:  the copier function for items in the hash
 *
 * Scan the hash @table and applied @f to each value.
 *
 * Returns the new table or NULL in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashCopy(mut table: xmlHashTablePtr,
                                     mut f: xmlHashCopier)
 -> xmlHashTablePtr {
    let mut i: std::os::raw::c_int = 0;
    let mut iter: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut next: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut ret: xmlHashTablePtr = 0 as *mut xmlHashTable;
    if table.is_null() { return 0 as xmlHashTablePtr }
    if f.is_none() { return 0 as xmlHashTablePtr }
    ret = xmlHashCreate((*table).size);
    if ret.is_null() { return 0 as xmlHashTablePtr }
    if !(*table).table.is_null() {
        i = 0 as std::os::raw::c_int;
        while i < (*table).size {
            if !((*(*table).table.offset(i as isize)).valid ==
                     0 as std::os::raw::c_int) {
                iter =
                    &mut *(*table).table.offset(i as isize) as
                        *mut _xmlHashEntry;
                while !iter.is_null() {
                    next = (*iter).next;
                    xmlHashAddEntry3(ret, (*iter).name, (*iter).name2,
                                     (*iter).name3,
                                     f.expect("non-null function pointer")((*iter).payload,
                                                                           (*iter).name));
                    iter = next
                }
            }
            i += 1
        }
    }
    (*ret).nbElems = (*table).nbElems;
    return ret;
}
/*
 * Retrieve the userdata.
 */
/*
 * Helpers.
 */
/* *
 * xmlHashSize:
 * @table: the hash table
 *
 * Query the number of elements installed in the hash @table.
 *
 * Returns the number of elements in the hash table or
 * -1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashSize(mut table: xmlHashTablePtr)
 -> std::os::raw::c_int {
    if table.is_null() { return -(1 as std::os::raw::c_int) }
    return (*table).nbElems;
}
/* *
 * xmlHashRemoveEntry:
 * @table: the hash table
 * @name: the name of the userdata
 * @f: the deallocator function for removed item (if any)
 *
 * Find the userdata specified by the @name and remove
 * it from the hash @table. Existing userdata for this tuple will be removed
 * and freed with @f.
 *
 * Returns 0 if the removal succeeded and -1 in case of error or not found.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashRemoveEntry(mut table: xmlHashTablePtr,
                                            mut name: *const xmlChar,
                                            mut f: xmlHashDeallocator)
 -> std::os::raw::c_int {
    return xmlHashRemoveEntry3(table, name, 0 as *const xmlChar,
                               0 as *const xmlChar, f);
}
/* *
 * xmlHashRemoveEntry2:
 * @table: the hash table
 * @name: the name of the userdata
 * @name2: a second name of the userdata
 * @f: the deallocator function for removed item (if any)
 *
 * Find the userdata specified by the (@name, @name2) tuple and remove
 * it from the hash @table. Existing userdata for this tuple will be removed
 * and freed with @f.
 *
 * Returns 0 if the removal succeeded and -1 in case of error or not found.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashRemoveEntry2(mut table: xmlHashTablePtr,
                                             mut name: *const xmlChar,
                                             mut name2: *const xmlChar,
                                             mut f: xmlHashDeallocator)
 -> std::os::raw::c_int {
    return xmlHashRemoveEntry3(table, name, name2, 0 as *const xmlChar, f);
}
/*
 * Summary: Chained hash tables
 * Description: This module implements the hash table support used in
 *		various places in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Bjorn Reese <bjorn.reese@systematic.dk>
 */
/*
 * The hash table.
 */
/*
 * Recent version of gcc produce a warning when a function pointer is assigned
 * to an object pointer, or vice versa.  The following macro is a dirty hack
 * to allow suppression of the warning.  If your architecture has function
 * pointers which are a different size than a void pointer, there may be some
 * serious trouble within the library.
 */
/* *
 * XML_CAST_FPTR:
 * @fptr:  pointer to a function
 *
 * Macro to do a casting from an object pointer to a
 * function pointer without encountering a warning from
 * gcc
 *
 * #define XML_CAST_FPTR(fptr) (*(void **)(&fptr))
 * This macro violated ISO C aliasing rules (gcc4 on s390 broke)
 * so it is disabled now
 */
/*
 * function types:
 */
/* *
 * xmlHashDeallocator:
 * @payload:  the data in the hash
 * @name:  the name associated
 *
 * Callback to free data from a hash.
 */
/* *
 * xmlHashCopier:
 * @payload:  the data in the hash
 * @name:  the name associated
 *
 * Callback to copy data from a hash.
 *
 * Returns a copy of the data or NULL in case of error.
 */
/* *
 * xmlHashScanner:
 * @payload:  the data in the hash
 * @data:  extra scannner data
 * @name:  the name associated
 *
 * Callback when scanning data in a hash with the simple scanner.
 */
/* *
 * xmlHashScannerFull:
 * @payload:  the data in the hash
 * @data:  extra scannner data
 * @name:  the name associated
 * @name2:  the second name associated
 * @name3:  the third name associated
 *
 * Callback when scanning data in a hash with the full scanner.
 */
/*
 * Constructor and destructor.
 */
/*
 * Add a new entry to the hash table.
 */
/*
 * Remove an entry from the hash table.
 */
/* *
 * xmlHashRemoveEntry3:
 * @table: the hash table
 * @name: the name of the userdata
 * @name2: a second name of the userdata
 * @name3: a third name of the userdata
 * @f: the deallocator function for removed item (if any)
 *
 * Find the userdata specified by the (@name, @name2, @name3) tuple and remove
 * it from the hash @table. Existing userdata for this tuple will be removed
 * and freed with @f.
 *
 * Returns 0 if the removal succeeded and -1 in case of error or not found.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlHashRemoveEntry3(mut table: xmlHashTablePtr,
                                             mut name: *const xmlChar,
                                             mut name2: *const xmlChar,
                                             mut name3: *const xmlChar,
                                             mut f: xmlHashDeallocator)
 -> std::os::raw::c_int {
    let mut key: std::os::raw::c_ulong = 0;
    let mut entry: xmlHashEntryPtr = 0 as *mut xmlHashEntry;
    let mut prev: xmlHashEntryPtr = 0 as xmlHashEntryPtr;
    if table.is_null() || name.is_null() { return -(1 as std::os::raw::c_int) }
    key = xmlHashComputeKey(table, name, name2, name3);
    if (*(*table).table.offset(key as isize)).valid == 0 as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    } else {
        entry =
            &mut *(*table).table.offset(key as isize) as *mut _xmlHashEntry;
        while !entry.is_null() {
            if xmlStrEqual((*entry).name, name) != 0 &&
                   xmlStrEqual((*entry).name2, name2) != 0 &&
                   xmlStrEqual((*entry).name3, name3) != 0 {
                if f.is_some() && !(*entry).payload.is_null() {
                    f.expect("non-null function pointer")((*entry).payload,
                                                          (*entry).name);
                }
                (*entry).payload = 0 as *mut std::os::raw::c_void;
                if (*table).dict.is_null() {
                    if !(*entry).name.is_null() {
                        xmlFree.expect("non-null function pointer")((*entry).name
                                                                        as
                                                                        *mut std::os::raw::c_void);
                    }
                    if !(*entry).name2.is_null() {
                        xmlFree.expect("non-null function pointer")((*entry).name2
                                                                        as
                                                                        *mut std::os::raw::c_void);
                    }
                    if !(*entry).name3.is_null() {
                        xmlFree.expect("non-null function pointer")((*entry).name3
                                                                        as
                                                                        *mut std::os::raw::c_void);
                    }
                }
                if !prev.is_null() {
                    (*prev).next = (*entry).next;
                    xmlFree.expect("non-null function pointer")(entry as
                                                                    *mut std::os::raw::c_void);
                } else if (*entry).next.is_null() {
                    (*entry).valid = 0 as std::os::raw::c_int
                } else {
                    entry = (*entry).next;
                    memcpy(&mut *(*table).table.offset(key as isize) as
                               *mut _xmlHashEntry as *mut std::os::raw::c_void,
                           entry as *const std::os::raw::c_void,
                           ::std::mem::size_of::<xmlHashEntry>() as
                               std::os::raw::c_ulong);
                    xmlFree.expect("non-null function pointer")(entry as
                                                                    *mut std::os::raw::c_void);
                }
                (*table).nbElems -= 1;
                return 0 as std::os::raw::c_int
            }
            prev = entry;
            entry = (*entry).next
        }
        return -(1 as std::os::raw::c_int)
    };
}
/* __INCLUDE_ELFGCCHACK */
