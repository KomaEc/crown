
extern "C" {
    pub type _xmlBuf;
    /*
 * Summary: string dictionary
 * Description: dictionary of reusable strings, just used to avoid allocation
 *         and freeing operations.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * The dictionary.
 */
    pub type _xmlDict;
    pub type _xmlHashTable;
    pub type _xmlAutomataState;
    pub type _xmlAutomata;
    pub type _xmlValidState;
    #[no_mangle]
    fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrlen(str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn snprintf(_: *mut std::os::raw::c_char, _: std::os::raw::c_ulong,
                _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    /*
 * libxml.h: internal header only used during the compilation of libxml
 *
 * See COPYRIGHT for the status of this software
 *
 * Author: breese@users.sourceforge.net
 */
    /*
 * Currently supported platforms use either autoconf or
 * copy to config.h own "preset" configuration file.
 * As result ifdef HAVE_CONFIG_H is omited here.
 */
    /*
 * Internal variable indicating if a callback has been registered for
 * node creation/destruction. It avoids spending a lot of time in locking
 * function while checking if the callback exists.
 */
    /*
 * internal error reporting routines, shared but not partof the API.
 */
    /*
 * internal function of HTML parser needed for xmlParseInNodeContext
 * but not part of the API
 */
    /*
 * internal global initialization critical section routines.
 */
    /*
 * internal thread safe random function
 */
    #[no_mangle]
    fn xmlInputReadCallbackNop(context: *mut std::os::raw::c_void,
                               buffer: *mut std::os::raw::c_char, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcasecmp(str1: *const xmlChar, str2: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrncmp(str1: *const xmlChar, str2: *const xmlChar,
                  len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcasestr(str: *const xmlChar, val: *const xmlChar)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlStrchr(str: *const xmlChar, val: xmlChar) -> *const xmlChar;
    #[no_mangle]
    fn xmlCharStrdup(cur: *const std::os::raw::c_char) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrndup(cur: *const xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn __htmlParseContent(ctx: *mut std::os::raw::c_void);
    #[no_mangle]
    fn __xmlGlobalInitMutexLock();
    #[no_mangle]
    fn __xmlGlobalInitMutexUnlock();
    #[no_mangle]
    fn memcpy(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_void, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn memmove(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_void, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn memset(_: *mut std::os::raw::c_void, _: std::os::raw::c_int, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn memchr(_: *const std::os::raw::c_void, _: std::os::raw::c_int, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn strncmp(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char,
               _: std::os::raw::c_ulong) -> std::os::raw::c_int;
    #[no_mangle]
    fn strlen(_: *const std::os::raw::c_char) -> std::os::raw::c_ulong;
    /* LIBXML_OUTPUT_ENABLED */
    /*
 * Interfaces for input
 */
    #[no_mangle]
    fn xmlCleanupInputCallbacks();
    #[no_mangle]
    fn xmlRegisterDefaultInputCallbacks();
    #[no_mangle]
    fn xmlAllocParserInputBuffer(enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateFd(fd: std::os::raw::c_int, enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateMem(mem: *const std::os::raw::c_char,
                                     size: std::os::raw::c_int, enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferCreateIO(ioread: xmlInputReadCallback,
                                    ioclose: xmlInputCloseCallback,
                                    ioctx: *mut std::os::raw::c_void,
                                    enc: xmlCharEncoding)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlParserInputBufferPush(in_0: xmlParserInputBufferPtr,
                                len: std::os::raw::c_int, buf: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlFreeParserInputBuffer(in_0: xmlParserInputBufferPtr);
    #[no_mangle]
    fn xmlParserGetDirectory(filename: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    /*
 * Interfaces for output
 */
    #[no_mangle]
    fn xmlCleanupOutputCallbacks();
    #[no_mangle]
    fn xmlRegisterDefaultOutputCallbacks();
    /*
 * Summary: SAX2 parser interface used to build the DOM tree
 * Description: those are the default SAX2 interfaces used by
 *              the library when building DOM tree.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* LIBXML_SAX1_ENABLED or LIBXML_HTML_ENABLED or LIBXML_LEGACY_ENABLED */
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlDefaultSAXHandlerInit();
    #[no_mangle]
    fn xmlBufContent(buf: *const xmlBuf) -> *mut xmlChar;
    #[no_mangle]
    fn xmlBufUse(buf: xmlBufPtr) -> size_t;
    /*
 * Initializer
 */
    #[no_mangle]
    fn xmlInitializeDict() -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDictSetLimit(dict: xmlDictPtr, limit: size_t) -> size_t;
    #[no_mangle]
    fn xmlDictReference(dict: xmlDictPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDictFree(dict: xmlDictPtr);
    /*
 * Lookup of entry in the dictionary.
 */
    #[no_mangle]
    fn xmlDictLookup(dict: xmlDictPtr, name: *const xmlChar, len: std::os::raw::c_int)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlDictOwns(dict: xmlDictPtr, str: *const xmlChar) -> std::os::raw::c_int;
    /*
 * Cleanup function
 */
    #[no_mangle]
    fn xmlDictCleanup();
    #[no_mangle]
    fn xmlBuildQName(ncname: *const xmlChar, prefix: *const xmlChar,
                     memory: *mut xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlSplitQName3(name: *const xmlChar, len: *mut std::os::raw::c_int)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlBufferCreate() -> xmlBufferPtr;
    #[no_mangle]
    fn xmlBufferFree(buf: xmlBufferPtr);
    #[no_mangle]
    fn xmlBufferAdd(buf: xmlBufferPtr, str: *const xmlChar, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    /*
 * Creating/freeing new structures.
 */
    #[no_mangle]
    fn xmlCreateIntSubset(doc: xmlDocPtr, name: *const xmlChar,
                          ExternalID: *const xmlChar,
                          SystemID: *const xmlChar) -> xmlDtdPtr;
    #[no_mangle]
    fn xmlNewDtd(doc: xmlDocPtr, name: *const xmlChar,
                 ExternalID: *const xmlChar, SystemID: *const xmlChar)
     -> xmlDtdPtr;
    #[no_mangle]
    fn xmlNewDoc(version: *const xmlChar) -> xmlDocPtr;
    #[no_mangle]
    fn xmlFreeDoc(cur: xmlDocPtr);
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
    /*
 * Creating new nodes.
 */
    #[no_mangle]
    fn xmlNewDocNode(doc: xmlDocPtr, ns: xmlNsPtr, name: *const xmlChar,
                     content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewComment(content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlDocCopyNode(node: xmlNodePtr, doc: xmlDocPtr,
                      recursive: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlGetLastChild(parent: *const xmlNode) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNodeIsText(node: *const xmlNode) -> std::os::raw::c_int;
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlAddChild(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlAddChildList(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlUnlinkNode(cur: xmlNodePtr);
    #[no_mangle]
    fn xmlFreeNodeList(cur: xmlNodePtr);
    #[no_mangle]
    fn xmlFreeNode(cur: xmlNodePtr);
    #[no_mangle]
    fn xmlSetTreeDoc(tree: xmlNodePtr, doc: xmlDocPtr);
    #[no_mangle]
    fn xmlSearchNsByHref(doc: xmlDocPtr, node: xmlNodePtr,
                         href: *const xmlChar) -> xmlNsPtr;
    #[no_mangle]
    fn xmlHashCreateDict(size: std::os::raw::c_int, dict: xmlDictPtr)
     -> xmlHashTablePtr;
    #[no_mangle]
    fn xmlHashFree(table: xmlHashTablePtr, f: xmlHashDeallocator);
    #[no_mangle]
    fn xmlHashDefaultDeallocator(entry: *mut std::os::raw::c_void,
                                 name: *const xmlChar);
    #[no_mangle]
    fn xmlHashAddEntry2(table: xmlHashTablePtr, name: *const xmlChar,
                        name2: *const xmlChar, userdata: *mut std::os::raw::c_void)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashUpdateEntry2(table: xmlHashTablePtr, name: *const xmlChar,
                           name2: *const xmlChar, userdata: *mut std::os::raw::c_void,
                           f: xmlHashDeallocator) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashRemoveEntry2(table: xmlHashTablePtr, name: *const xmlChar,
                           name2: *const xmlChar, f: xmlHashDeallocator)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashLookup2(table: xmlHashTablePtr, name: *const xmlChar,
                      name2: *const xmlChar) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashQLookup2(table: xmlHashTablePtr, name: *const xmlChar,
                       prefix: *const xmlChar, name2: *const xmlChar,
                       prefix2: *const xmlChar) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlHashSize(table: xmlHashTablePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlHashScanFull(table: xmlHashTablePtr, f: xmlHashScannerFull,
                       data: *mut std::os::raw::c_void);
    #[no_mangle]
    fn initGenericErrorDefaultFunc(handler: *mut xmlGenericErrorFunc);
    #[no_mangle]
    fn xmlResetLastError();
    #[no_mangle]
    fn xmlResetError(err: xmlErrorPtr);
    #[no_mangle]
    fn xmlCopyError(from: xmlErrorPtr, to: xmlErrorPtr) -> std::os::raw::c_int;
    /*
 * Internal callback reporting routine
 */
    #[no_mangle]
    fn __xmlRaiseError(schannel: xmlStructuredErrorFunc,
                       channel: xmlGenericErrorFunc, data: *mut std::os::raw::c_void,
                       ctx: *mut std::os::raw::c_void, node: *mut std::os::raw::c_void,
                       domain: std::os::raw::c_int, code: std::os::raw::c_int,
                       level: xmlErrorLevel, file: *const std::os::raw::c_char,
                       line: std::os::raw::c_int, str1: *const std::os::raw::c_char,
                       str2: *const std::os::raw::c_char, str3: *const std::os::raw::c_char,
                       int1: std::os::raw::c_int, col: std::os::raw::c_int,
                       msg: *const std::os::raw::c_char, _: ...);
    /* the new versions with doc argument */
    #[no_mangle]
    fn xmlNewDocElementContent(doc: xmlDocPtr, name: *const xmlChar,
                               type_0: xmlElementContentType)
     -> xmlElementContentPtr;
    #[no_mangle]
    fn xmlFreeDocElementContent(doc: xmlDocPtr, cur: xmlElementContentPtr);
    /* LIBXML_OUTPUT_ENABLED */
    /* Enumeration */
    #[no_mangle]
    fn xmlCreateEnumeration(name: *const xmlChar) -> xmlEnumerationPtr;
    #[no_mangle]
    fn xmlFreeEnumeration(cur: xmlEnumerationPtr);
    #[no_mangle]
    fn xmlValidateRoot(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateElement(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                          elem: xmlNodePtr) -> std::os::raw::c_int;
    /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */
    #[no_mangle]
    fn xmlIsMixedElement(doc: xmlDocPtr, name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlGetPredefinedEntity(name: *const xmlChar) -> xmlEntityPtr;
    /* LIBXML_ICONV_ENABLED */
    /* LIBXML_ICU_ENABLED */
    /*
 * Interfaces for encoding handlers.
 */
    #[no_mangle]
    fn xmlInitCharEncodingHandlers();
    #[no_mangle]
    fn xmlCleanupCharEncodingHandlers();
    #[no_mangle]
    fn xmlFindCharEncodingHandler(name: *const std::os::raw::c_char)
     -> xmlCharEncodingHandlerPtr;
    /*
 * Interfaces directly used by the parsers.
 */
    #[no_mangle]
    fn xmlDetectCharEncoding(in_0: *const std::os::raw::c_uchar, len: std::os::raw::c_int)
     -> xmlCharEncoding;
    #[no_mangle]
    fn xmlCleanupMemory();
    #[no_mangle]
    fn xmlInitMemory() -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlDefaultSAXHandlerInit();
    /*
 * Summary: interface for all global variables of the library
 * Description: all the global variables and thread handling for
 *              those variables is handled by this module.
 *
 * The bottom of this file is automatically generated by build_glob.py
 * based on the description file global.data
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
 */
    /* *
 * xmlParserInputBufferCreateFilenameFunc:
 * @URI: the URI to read from
 * @enc: the requested source encoding
 *
 * Signature for the function doing the lookup for a suitable input method
 * corresponding to an URI.
 *
 * Returns the new xmlParserInputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /* *
 * xmlOutputBufferCreateFilenameFunc:
 * @URI: the URI to write to
 * @enc: the requested target encoding
 *
 * Signature for the function doing the lookup for a suitable output method
 * corresponding to an URI.
 *
 * Returns the new xmlOutputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /*
 * Externally global symbols which need to be protected for backwards
 * compatibility support.
 */
    /* *
 * xmlRegisterNodeFunc:
 * @node: the current node
 *
 * Signature for the registration callback of a created node
 */
    /* *
 * xmlDeregisterNodeFunc:
 * @node: the current node
 *
 * Signature for the deregistration callback of a discarded node
 */
    /* * DOC_DISABLE */
/*
 * In general the memory allocation entry points are not kept
 * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED
 *    - xmlMalloc
 *    - xmlMallocAtomic
 *    - xmlRealloc
 *    - xmlMemStrdup
 *    - xmlFree
 */
    /* !LIBXML_THREAD_ALLOC_ENABLED */
    /* LIBXML_THREAD_ALLOC_ENABLED */
    /*
 * Everything starting from the line below is
 * Automatically generated by build_glob.py.
 * Do not modify the previous line.
 */
    #[no_mangle]
    fn __xmlGenericError() -> *mut xmlGenericErrorFunc;
    #[no_mangle]
    fn xmlInitGlobals();
    #[no_mangle]
    fn xmlInitThreads();
    #[no_mangle]
    fn xmlCleanupThreads();
    #[no_mangle]
    fn xmlCleanupGlobals();
    #[no_mangle]
    fn xmlParserInputGrow(in_0: xmlParserInputPtr, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlFreeParserCtxt(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    #[no_mangle]
    static mut xmlRealloc: xmlReallocFunc;
    #[no_mangle]
    static mut xmlMallocAtomic: xmlMallocFunc;
    #[no_mangle]
    fn __xmlGenericErrorContext() -> *mut *mut std::os::raw::c_void;
    #[no_mangle]
    fn __xmlParserDebugEntities() -> *mut std::os::raw::c_int;
    #[no_mangle]
    fn xmlSAX2GetEntity(ctx: *mut std::os::raw::c_void, name: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlParserAddNodeInfo(ctxt: xmlParserCtxtPtr,
                            info: xmlParserNodeInfoPtr);
    #[no_mangle]
    fn xmlLoadExternalEntity(URL: *const std::os::raw::c_char,
                             ID: *const std::os::raw::c_char, ctxt: xmlParserCtxtPtr)
     -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
    #[no_mangle]
    static mut xmlMalloc: xmlMallocFunc;
    #[no_mangle]
    fn xmlSAX2EntityDecl(ctx: *mut std::os::raw::c_void, name: *const xmlChar,
                         type_0: std::os::raw::c_int, publicId: *const xmlChar,
                         systemId: *const xmlChar, content: *mut xmlChar);
    #[no_mangle]
    fn xmlInitNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
    #[no_mangle]
    fn __xmlDefaultSAXLocator() -> *mut xmlSAXLocator;
    #[no_mangle]
    fn xmlClearParserCtxt(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlNewIOInputStream(ctxt: xmlParserCtxtPtr,
                           input: xmlParserInputBufferPtr,
                           enc: xmlCharEncoding) -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlSAX2EndElement(ctx: *mut std::os::raw::c_void, name: *const xmlChar);
    #[no_mangle]
    fn xmlSAX2StartElement(ctx: *mut std::os::raw::c_void, fullname: *const xmlChar,
                           atts: *mut *const xmlChar);
    #[no_mangle]
    fn xmlSAX2IgnorableWhitespace(ctx: *mut std::os::raw::c_void, ch: *const xmlChar,
                                  len: std::os::raw::c_int);
    #[no_mangle]
    fn __xmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
    #[no_mangle]
    fn xmlSwitchEncoding(ctxt: xmlParserCtxtPtr, enc: xmlCharEncoding)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSwitchToEncoding(ctxt: xmlParserCtxtPtr,
                           handler: xmlCharEncodingHandlerPtr) -> std::os::raw::c_int;
    /* internal error reporting */
    #[no_mangle]
    fn __xmlErrEncoding(ctxt: xmlParserCtxtPtr, xmlerr: xmlParserErrors,
                        msg: *const std::os::raw::c_char, str1: *const xmlChar,
                        str2: *const xmlChar);
    /* *
 * Input Streams.
 */
    #[no_mangle]
    fn xmlNewStringInputStream(ctxt: xmlParserCtxtPtr, buffer: *const xmlChar)
     -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlNewEntityInputStream(ctxt: xmlParserCtxtPtr, entity: xmlEntityPtr)
     -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlFreeInputStream(input: xmlParserInputPtr);
    #[no_mangle]
    fn xmlNewInputStream(ctxt: xmlParserCtxtPtr) -> xmlParserInputPtr;
    #[no_mangle]
    fn xmlStringCurrentChar(ctxt: xmlParserCtxtPtr, cur: *const xmlChar,
                            len: *mut std::os::raw::c_int) -> std::os::raw::c_int;
    /*
 * Really core function shared with HTML parser.
 */
    #[no_mangle]
    fn xmlCurrentChar(ctxt: xmlParserCtxtPtr, len: *mut std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCopyCharMultiByte(out: *mut xmlChar, val: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCopyChar(len: std::os::raw::c_int, out: *mut xmlChar, val: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNextChar(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParserInputShrink(in_0: xmlParserInputPtr);
    /*
 * Actually comes from the HTML parser but launched from the init stuff.
 */
    #[no_mangle]
    fn htmlInitAutoClose();
    #[no_mangle]
    static xmlIsPubidChar_tab: [std::os::raw::c_uchar; 256];
    /* LIBXML_LEGACY_ENABLED */
    /*
 * internal only
 */
    #[no_mangle]
    fn xmlErrMemory(ctxt: xmlParserCtxtPtr, extra: *const std::os::raw::c_char);
    #[no_mangle]
    static xmlIsExtenderGroup: xmlChRangeGroup;
    #[no_mangle]
    fn xmlCharInRange(val: std::os::raw::c_uint, group: *const xmlChRangeGroup)
     -> std::os::raw::c_int;
    #[no_mangle]
    static xmlIsCombiningGroup: xmlChRangeGroup;
    #[no_mangle]
    static xmlIsBaseCharGroup: xmlChRangeGroup;
    #[no_mangle]
    static xmlIsDigitGroup: xmlChRangeGroup;
    #[no_mangle]
    fn htmlCreateMemoryParserCtxt(buffer: *const std::os::raw::c_char,
                                  size: std::os::raw::c_int) -> htmlParserCtxtPtr;
    #[no_mangle]
    fn xmlBuildURI(URI: *const xmlChar, base: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseURI(str: *const std::os::raw::c_char) -> xmlURIPtr;
    #[no_mangle]
    fn xmlFreeURI(uri: xmlURIPtr);
    #[no_mangle]
    fn xmlCanonicPath(path: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogCleanup();
    /*
 * Strictly minimal interfaces for per-document catalogs used
 * by the parser.
 */
    #[no_mangle]
    fn xmlCatalogFreeLocal(catalogs: *mut std::os::raw::c_void);
    #[no_mangle]
    fn xmlCatalogAddLocal(catalogs: *mut std::os::raw::c_void, URL: *const xmlChar)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn xmlCatalogGetDefaults() -> xmlCatalogAllow;
    #[no_mangle]
    fn xmlSchemaCleanupTypes();
    #[no_mangle]
    fn xmlRelaxNGCleanupTypes();
    /* size_t xmlBufUse(const xmlBufPtr buf); */
    #[no_mangle]
    fn xmlBufIsEmpty(buf: xmlBufPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufResetInput(buf: xmlBufPtr, input: xmlParserInputPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBufGetInputBase(buf: xmlBufPtr, input: xmlParserInputPtr) -> size_t;
    #[no_mangle]
    fn xmlBufSetInputBaseCur(buf: xmlBufPtr, input: xmlParserInputPtr,
                             base: size_t, cur: size_t) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCharEncInput(input: xmlParserInputBufferPtr, flush: std::os::raw::c_int)
     -> std::os::raw::c_int;
    /* LIBXML_XPATH_ENABLED */
    #[no_mangle]
    fn xmlXPathInit();
    /* LIBXML_LEGACY_ENABLED */
    /* ***********************************************************************
 *									*
 *				Miscellaneous				*
 *									*
 ************************************************************************/
    #[no_mangle]
    fn xmlGenericErrorDefaultFunc(ctx: *mut std::os::raw::c_void,
                                  msg: *const std::os::raw::c_char, _: ...);
}
pub type xmlChar = std::os::raw::c_uchar;
pub type size_t = std::os::raw::c_ulong;
pub type ptrdiff_t = std::os::raw::c_long;
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type xmlMallocFunc
    =
    Option<unsafe extern "C" fn(_: size_t) -> *mut std::os::raw::c_void>;
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */
/* *
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/* *
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
/* *
 * xmlMallocFunc:
 * @size:  the size requested in bytes
 *
 * Signature for a malloc() implementation.
 *
 * Returns a pointer to the newly allocated block or NULL in case of error.
 */
/* *
 * xmlReallocFunc:
 * @mem: an already allocated block of memory
 * @size:  the new size requested in bytes
 *
 * Signature for a realloc() implementation.
 *
 * Returns a pointer to the newly reallocated block or NULL in case of error.
 */
pub type xmlReallocFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: size_t)
               -> *mut std::os::raw::c_void>;
/* LIBXML_OUTPUT_ENABLED */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInputBuffer {
    pub context: *mut std::os::raw::c_void,
    pub readcallback: xmlInputReadCallback,
    pub closecallback: xmlInputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub raw: xmlBufPtr,
    pub compressed: std::os::raw::c_int,
    pub error: std::os::raw::c_int,
    pub rawconsumed: std::os::raw::c_ulong,
}
pub type xmlBufPtr = *mut xmlBuf;
pub type xmlBuf = _xmlBuf;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
/* *
 * xmlCharEncodingInputFunc:
 * @out:  a pointer to an array of bytes to store the UTF-8 result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of chars in the original encoding
 * @inlen:  the length of @in
 *
 * Take a block of chars in the original encoding and try to convert
 * it to an UTF-8 block of chars out.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets consumed.
 */
/* *
 * xmlCharEncodingOutputFunc:
 * @out:  a pointer to an array of bytes to store the result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of UTF-8 chars
 * @inlen:  the length of @in
 *
 * Take a block of UTF-8 chars in and try to convert it to another
 * encoding.
 * Note: a first call designed to produce heading info is called with
 * in = NULL. If stateful this should also initialize the encoder state.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets produced.
 */
/*
 * Block defining the handlers for non UTF-8 encodings.
 * If iconv is supported, there are two extra fields.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlCharEncodingHandler {
    pub name: *mut std::os::raw::c_char,
    pub input: xmlCharEncodingInputFunc,
    pub output: xmlCharEncodingOutputFunc,
    pub iconv_in: iconv_t,
    pub iconv_out: iconv_t,
}
pub type iconv_t = *mut std::os::raw::c_void;
pub type xmlCharEncodingOutputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
pub type xmlCharEncodingInputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
/* *
 * xmlInputCloseCallback:
 * @context:  an Input context
 *
 * Callback used in the I/O Input API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
pub type xmlInputCloseCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
/* *
 * xmlInputReadCallback:
 * @context:  an Input context
 * @buffer:  the buffer to store data read
 * @len:  the length of the buffer in bytes
 *
 * Callback used in the I/O Input API to read the resource
 *
 * Returns the number of bytes read or -1 in case of error
 */
pub type xmlInputReadCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_char,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInput {
    pub buf: xmlParserInputBufferPtr,
    pub filename: *const std::os::raw::c_char,
    pub directory: *const std::os::raw::c_char,
    pub base: *const xmlChar,
    pub cur: *const xmlChar,
    pub end: *const xmlChar,
    pub length: std::os::raw::c_int,
    pub line: std::os::raw::c_int,
    pub col: std::os::raw::c_int,
    pub consumed: std::os::raw::c_ulong,
    pub free: xmlParserInputDeallocate,
    pub encoding: *const xmlChar,
    pub version: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub id: std::os::raw::c_int,
}
pub type xmlParserInputDeallocate
    =
    Option<unsafe extern "C" fn(_: *mut xmlChar) -> ()>;
pub type xmlParserInput = _xmlParserInput;
pub type xmlParserInputPtr = *mut xmlParserInput;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserCtxt {
    pub sax: *mut _xmlSAXHandler,
    pub userData: *mut std::os::raw::c_void,
    pub myDoc: xmlDocPtr,
    pub wellFormed: std::os::raw::c_int,
    pub replaceEntities: std::os::raw::c_int,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub html: std::os::raw::c_int,
    pub input: xmlParserInputPtr,
    pub inputNr: std::os::raw::c_int,
    pub inputMax: std::os::raw::c_int,
    pub inputTab: *mut xmlParserInputPtr,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub record_info: std::os::raw::c_int,
    pub node_seq: xmlParserNodeInfoSeq,
    pub errNo: std::os::raw::c_int,
    pub hasExternalSubset: std::os::raw::c_int,
    pub hasPErefs: std::os::raw::c_int,
    pub external: std::os::raw::c_int,
    pub valid: std::os::raw::c_int,
    pub validate: std::os::raw::c_int,
    pub vctxt: xmlValidCtxt,
    pub instate: xmlParserInputState,
    pub token: std::os::raw::c_int,
    pub directory: *mut std::os::raw::c_char,
    pub name: *const xmlChar,
    pub nameNr: std::os::raw::c_int,
    pub nameMax: std::os::raw::c_int,
    pub nameTab: *mut *const xmlChar,
    pub nbChars: std::os::raw::c_long,
    pub checkIndex: std::os::raw::c_long,
    pub keepBlanks: std::os::raw::c_int,
    pub disableSAX: std::os::raw::c_int,
    pub inSubset: std::os::raw::c_int,
    pub intSubName: *const xmlChar,
    pub extSubURI: *mut xmlChar,
    pub extSubSystem: *mut xmlChar,
    pub space: *mut std::os::raw::c_int,
    pub spaceNr: std::os::raw::c_int,
    pub spaceMax: std::os::raw::c_int,
    pub spaceTab: *mut std::os::raw::c_int,
    pub depth: std::os::raw::c_int,
    pub entity: xmlParserInputPtr,
    pub charset: std::os::raw::c_int,
    pub nodelen: std::os::raw::c_int,
    pub nodemem: std::os::raw::c_int,
    pub pedantic: std::os::raw::c_int,
    pub _private: *mut std::os::raw::c_void,
    pub loadsubset: std::os::raw::c_int,
    pub linenumbers: std::os::raw::c_int,
    pub catalogs: *mut std::os::raw::c_void,
    pub recovery: std::os::raw::c_int,
    pub progressive: std::os::raw::c_int,
    pub dict: xmlDictPtr,
    pub atts: *mut *const xmlChar,
    pub maxatts: std::os::raw::c_int,
    pub docdict: std::os::raw::c_int,
    pub str_xml: *const xmlChar,
    pub str_xmlns: *const xmlChar,
    pub str_xml_ns: *const xmlChar,
    pub sax2: std::os::raw::c_int,
    pub nsNr: std::os::raw::c_int,
    pub nsMax: std::os::raw::c_int,
    pub nsTab: *mut *const xmlChar,
    pub attallocs: *mut std::os::raw::c_int,
    pub pushTab: *mut *mut std::os::raw::c_void,
    pub attsDefault: xmlHashTablePtr,
    pub attsSpecial: xmlHashTablePtr,
    pub nsWellFormed: std::os::raw::c_int,
    pub options: std::os::raw::c_int,
    pub dictNames: std::os::raw::c_int,
    pub freeElemsNr: std::os::raw::c_int,
    pub freeElems: xmlNodePtr,
    pub freeAttrsNr: std::os::raw::c_int,
    pub freeAttrs: xmlAttrPtr,
    pub lastError: xmlError,
    pub parseMode: xmlParserMode,
    pub nbentities: std::os::raw::c_ulong,
    pub sizeentities: std::os::raw::c_ulong,
    pub nodeInfo: *mut xmlParserNodeInfo,
    pub nodeInfoNr: std::os::raw::c_int,
    pub nodeInfoMax: std::os::raw::c_int,
    pub nodeInfoTab: *mut xmlParserNodeInfo,
    pub input_id: std::os::raw::c_int,
    pub sizeentcopy: std::os::raw::c_ulong,
}
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfo {
    pub node: *const _xmlNode,
    pub begin_pos: std::os::raw::c_ulong,
    pub begin_line: std::os::raw::c_ulong,
    pub end_pos: std::os::raw::c_ulong,
    pub end_line: std::os::raw::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNode {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub content: *mut xmlChar,
    pub properties: *mut _xmlAttr,
    pub nsDef: *mut xmlNs,
    pub psvi: *mut std::os::raw::c_void,
    pub line: std::os::raw::c_ushort,
    pub extra: std::os::raw::c_ushort,
}
/*
 * Summary: interfaces for tree manipulation
 * Description: this module describes the structures found in an tree resulting
 *              from an XML or HTML parsing, as well as the API provided for
 *              various processing on that tree
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Some of the basic types pointer to structures:
 */
/* xmlIO.h */
/* parser.h */
/* entities.h */
/* *
 * BASE_BUFFER_SIZE:
 *
 * default buffer size 4000.
 */
/* *
 * LIBXML_NAMESPACE_DICT:
 *
 * Defines experimental behaviour:
 * 1) xmlNs gets an additional field @context (a xmlDoc)
 * 2) when creating a tree, xmlNs->href is stored in the dict of xmlDoc.
 */
/* #define LIBXML_NAMESPACE_DICT */
/* *
 * xmlBufferAllocationScheme:
 *
 * A buffer allocation scheme can be defined to either match exactly the
 * need or double it's allocated size each time it is found too small.
 */
/* double each time one need to grow */
/* grow only to the minimal size */
/* immutable buffer */
/* special allocation scheme used for I/O */
/* exact up to a threshold, and doubleit thereafter */
/* limit the upper size of the buffer */
/* *
 * xmlBuffer:
 *
 * A buffer structure, this old construct is limited to 2GB and
 * is being deprecated, use API with xmlBuf instead
 */
/* The buffer content UTF8 */
/* The buffer size used */
/* The buffer size */
/* The realloc method */
/* in IO mode we may have a different base */
/* *
 * xmlBuf:
 *
 * A buffer structure, new one, the actual structure internals are not public
 */
/* *
 * xmlBufPtr:
 *
 * A pointer to a buffer structure, the actual structure internals are not
 * public
 */
/*
 * A few public routines for xmlBuf. As those are expected to be used
 * mostly internally the bulk of the routines are internal in buf.h
 */
/*
 * LIBXML2_NEW_BUFFER:
 *
 * Macro used to express that the API use the new buffers for
 * xmlParserInputBuffer and xmlOutputBuffer. The change was
 * introduced in 2.9.0.
 */
/* *
 * XML_XML_NAMESPACE:
 *
 * This is the namespace for the special xml: prefix predefined in the
 * XML Namespace specification.
 */
/* *
 * XML_XML_ID:
 *
 * This is the name for the special xml:id attribute
 */
/*
 * The different element types carried by an XML tree.
 *
 * NOTE: This is synchronized with DOM Level1 values
 *       See http://www.w3.org/TR/REC-DOM-Level-1/
 *
 * Actually this had diverged a bit, and now XML_DOCUMENT_TYPE_NODE should
 * be deprecated to use an XML_DTD_NODE.
 */
/* *
 * xmlNotation:
 *
 * A DTD Notation definition.
 */
/* Notation name */
/* Public identifier, if any */
/* System identifier, if any */
/* *
 * xmlAttributeType:
 *
 * A DTD Attribute type definition.
 */
/* *
 * xmlAttributeDefault:
 *
 * A DTD Attribute default definition.
 */
/* *
 * xmlEnumeration:
 *
 * List structure used when there is an enumeration in DTDs.
 */
/* next one */
/* Enumeration name */
/* *
 * xmlAttribute:
 *
 * An Attribute declaration in a DTD.
 */
/* application data */
/* XML_ATTRIBUTE_DECL, must be second ! */
/* Attribute name */
/* NULL */
/* NULL */
/* -> DTD */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* next in hash table */
/* The attribute type */
/* the default */
/* or the default value */
/* or the enumeration tree if any */
/* the namespace prefix if any */
/* Element holding the attribute */
/* *
 * xmlElementContentType:
 *
 * Possible definitions of element content types.
 */
/* *
 * xmlElementContentOccur:
 *
 * Possible definitions of element content occurrences.
 */
/* *
 * xmlElementContent:
 *
 * An XML Element content as stored after parsing an element definition
 * in a DTD.
 */
/* PCDATA, ELEMENT, SEQ or OR */
/* ONCE, OPT, MULT or PLUS */
/* Element name */
/* first child */
/* second child */
/* parent */
/* Namespace prefix */
/* *
 * xmlElementTypeVal:
 *
 * The different possibilities for an element content type.
 */
/* *
 * xmlElement:
 *
 * An XML Element declaration from a DTD.
 */
/* application data */
/* XML_ELEMENT_DECL, must be second ! */
/* Element name */
/* NULL */
/* NULL */
/* -> DTD */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* The type */
/* the allowed element content */
/* List of the declared attributes */
/* the namespace prefix if any */
/* the validating regexp */
/* *
 * XML_LOCAL_NAMESPACE:
 *
 * A namespace declaration node.
 */
/* *
 * xmlNs:
 *
 * An XML namespace.
 * Note that prefix == NULL is valid, it defines the default namespace
 * within the subtree (until overridden).
 *
 * xmlNsType is unified with xmlElementType.
 */
pub type xmlNs = _xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNs {
    pub next: *mut _xmlNs,
    pub type_0: xmlNsType,
    pub href: *const xmlChar,
    pub prefix: *const xmlChar,
    pub _private: *mut std::os::raw::c_void,
    pub context: *mut _xmlDoc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDoc {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *mut std::os::raw::c_char,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub compression: std::os::raw::c_int,
    pub standalone: std::os::raw::c_int,
    pub intSubset: *mut _xmlDtd,
    pub extSubset: *mut _xmlDtd,
    pub oldNs: *mut _xmlNs,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub ids: *mut std::os::raw::c_void,
    pub refs: *mut std::os::raw::c_void,
    pub URL: *const xmlChar,
    pub charset: std::os::raw::c_int,
    pub dict: *mut _xmlDict,
    pub psvi: *mut std::os::raw::c_void,
    pub parseFlags: std::os::raw::c_int,
    pub properties: std::os::raw::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDtd {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDoc,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub notations: *mut std::os::raw::c_void,
    pub elements: *mut std::os::raw::c_void,
    pub attributes: *mut std::os::raw::c_void,
    pub entities: *mut std::os::raw::c_void,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub pentities: *mut std::os::raw::c_void,
}
pub type xmlElementType = std::os::raw::c_uint;
pub const XML_DOCB_DOCUMENT_NODE: xmlElementType = 21;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
pub type xmlNsType = xmlElementType;
/* normally an xmlDoc */
/* *
 * xmlDtd:
 *
 * An XML DTD, as defined by <!DOCTYPE ... There is actually one for
 * the internal subset and for the external subset.
 */
/* application data */
/* XML_DTD_NODE, must be second ! */
/* Name of the DTD */
/* the value of the property link */
/* last child link */
/* child->parent link */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* End of common part */
/* Hash table for notations if any */
/* Hash table for elements if any */
/* Hash table for attributes if any */
/* Hash table for entities if any */
/* External identifier for PUBLIC DTD */
/* URI for a SYSTEM or PUBLIC DTD */
/* Hash table for param entities if any */
/* *
 * xmlAttr:
 *
 * An attribute on an XML node.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttr {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlAttr,
    pub prev: *mut _xmlAttr,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub atype: xmlAttributeType,
    pub psvi: *mut std::os::raw::c_void,
}
pub type xmlAttributeType = std::os::raw::c_uint;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = std::os::raw::c_uint;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
/*
 * Summary: error handling
 * Description: the API used to report errors
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlErrorLevel:
 *
 * Indicates the level of an error
 */
/* A simple warning */
/* A recoverable error */
/* A fatal error */
/* *
 * xmlErrorDomain:
 *
 * Indicates where an error may have come from
 */
/* The XML parser */
/* The tree module */
/* The XML Namespace module */
/* The XML DTD validation with parser context*/
/* The HTML parser */
/* The memory allocator */
/* The serialization code */
/* The Input/Output stack */
/* The FTP module */
/* The HTTP module */
/* The XInclude processing */
/* The XPath module */
/* The XPointer module */
/* The regular expressions module */
/* The W3C XML Schemas Datatype module */
/* The W3C XML Schemas parser module */
/* The W3C XML Schemas validation module */
/* The Relax-NG parser module */
/* The Relax-NG validator module */
/* The Catalog module */
/* The Canonicalization module */
/* The XSLT engine from libxslt */
/* The XML DTD validation with valid context */
/* The error checking module */
/* The xmlwriter module */
/* The dynamically loaded module module*/
/* The module handling character conversion */
/* The Schematron validator module */
/* The buffers module */
/* The URI module */
/* *
 * xmlError:
 *
 * An XML Error instance.
 */
pub type xmlError = _xmlError;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlError {
    pub domain: std::os::raw::c_int,
    pub code: std::os::raw::c_int,
    pub message: *mut std::os::raw::c_char,
    pub level: xmlErrorLevel,
    pub file: *mut std::os::raw::c_char,
    pub line: std::os::raw::c_int,
    pub str1: *mut std::os::raw::c_char,
    pub str2: *mut std::os::raw::c_char,
    pub str3: *mut std::os::raw::c_char,
    pub int1: std::os::raw::c_int,
    pub int2: std::os::raw::c_int,
    pub ctxt: *mut std::os::raw::c_void,
    pub node: *mut std::os::raw::c_void,
}
pub type xmlErrorLevel = std::os::raw::c_uint;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
pub type xmlAttrPtr = *mut xmlAttr;
pub type xmlAttr = _xmlAttr;
/* for type/PSVI informations */
/* *
 * xmlID:
 *
 * An XML ID instance.
 */
/* next ID */
/* The ID name */
/* The attribute holding it */
/* The attribute if attr is not available */
/* The line number if attr is not available */
/* The document holding the ID */
/* *
 * xmlRef:
 *
 * An XML IDREF instance.
 */
/* next Ref */
/* The Ref name */
/* The attribute holding it */
/* The attribute if attr is not available */
/* The line number if attr is not available */
/* *
 * xmlNode:
 *
 * A node in an XML tree.
 */
pub type xmlNodePtr = *mut xmlNode;
pub type xmlNode = _xmlNode;
/*
 * Summary: Chained hash tables
 * Description: This module implements the hash table support used in
 *		various places in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Bjorn Reese <bjorn.reese@systematic.dk>
 */
/*
 * The hash table.
 */
pub type xmlHashTablePtr = *mut xmlHashTable;
pub type xmlHashTable = _xmlHashTable;
pub type xmlDictPtr = *mut xmlDict;
pub type xmlDict = _xmlDict;
pub type xmlParserInputState = std::os::raw::c_int;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
/*
 * Summary: The DTD validation
 * Description: API for the DTD handling and the validity checking
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Validation state added for non-determinist content model.
 */
/* *
 * xmlValidityErrorFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity error is found. This is a message
 * oriented function similar to an *printf function.
 */
/* *
 * xmlValidityWarningFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity warning is found. This is a message
 * oriented function similar to an *printf function.
 */
/* *
 * XML_CTXT_FINISH_DTD_0:
 *
 * Special value for finishDtd field when embedded in an xmlParserCtxt
 */
/* *
 * XML_CTXT_FINISH_DTD_1:
 *
 * Special value for finishDtd field when embedded in an xmlParserCtxt
 */
/*
 * xmlValidCtxt:
 * An xmlValidCtxt is used for error reporting when validating.
 */
pub type xmlValidCtxt = _xmlValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlValidCtxt {
    pub userData: *mut std::os::raw::c_void,
    pub error: xmlValidityErrorFunc,
    pub warning: xmlValidityWarningFunc,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub finishDtd: std::os::raw::c_uint,
    pub doc: xmlDocPtr,
    pub valid: std::os::raw::c_int,
    pub vstate: *mut xmlValidState,
    pub vstateNr: std::os::raw::c_int,
    pub vstateMax: std::os::raw::c_int,
    pub vstateTab: *mut xmlValidState,
    pub am: xmlAutomataPtr,
    pub state: xmlAutomataStatePtr,
}
/*
 * Summary: API to build regexp automata
 * Description: the API to build regexp automata
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlAutomataPtr:
 *
 * A libxml automata description, It can be compiled into a regexp
 */
/* *
 * xmlAutomataStatePtr:
 *
 * A state int the automata description,
 */
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataPtr = *mut xmlAutomata;
pub type xmlAutomata = _xmlAutomata;
pub type xmlValidState = _xmlValidState;
/* application data */
/* type number, must be second ! */
/* the name of the node, or the entity */
/* parent->childs link */
/* last child link */
/* child->parent link */
/* next sibling link  */
/* previous sibling link  */
/* the containing document */
/* End of common part */
/* pointer to the associated namespace */
/* the content */
/* properties list */
/* namespace definitions on this node */
/* for type/PSVI informations */
/* line number */
/* extra data for XPath/XSLT */
/* *
 * XML_GET_CONTENT:
 *
 * Macro to extract the content pointer of a node.
 */
/* *
 * XML_GET_LINE:
 *
 * Macro to extract the line number of an element node.
 */
/* *
 * xmlDocProperty
 *
 * Set of properties of the document as found by the parser
 * Some of them are linked to similary named xmlParserOption
 */
/* document is XML well formed */
/* document is Namespace valid */
/* parsed with old XML-1.0 parser */
/* DTD validation was successful */
/* XInclude substitution was done */
/* Document was built using the API
                                           and not by parsing an instance */
/* built for internal processing */
/* parsed or built HTML document */
/* *
 * xmlDoc:
 *
 * An XML document.
 */
pub type xmlDocPtr = *mut xmlDoc;
pub type xmlDoc = _xmlDoc;
pub type xmlValidityWarningFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlValidityErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfoSeq {
    pub maximum: std::os::raw::c_ulong,
    pub length: std::os::raw::c_ulong,
    pub buffer: *mut xmlParserNodeInfo,
}
/* *
 * xmlParserCtxt:
 *
 * The parser context.
 * NOTE This doesn't completely define the parser state, the (current ?)
 *      design of the parser uses recursive function calls since this allow
 *      and easy mapping from the production rules of the specification
 *      to the actual code. The drawback is that the actual function call
 *      also reflect the parser state. However most of the parsing routines
 *      takes as the only argument the parser context pointer, so migrating
 *      to a state based parser for progressive parsing shouldn't be too hard.
 */
/* The SAX handler */
/* For SAX interface only, used by DOM build */
/* the document being built */
/* is the document well formed */
/* shall we replace entities ? */
/* the XML version string */
/* the declared encoding, if any */
/* standalone document */
/* an HTML(1)/Docbook(2) document
                                       * 3 is HTML after <head>
                                       * 10 is HTML after <body>
                                       */
/* Input stream stack */
/* Current input stream */
/* Number of current input streams */
/* Max number of input streams */
/* stack of inputs */
/* Node analysis stack only used for DOM building */
/* Current parsed Node */
/* Depth of the parsing stack */
/* Max depth of the parsing stack */
/* array of nodes */
/* Whether node info should be kept */
/* info about each node parsed */
/* error code */
/* reference and external subset */
/* the internal subset has PE refs */
/* are we parsing an external entity */
/* is the document valid */
/* shall we try to validate ? */
/* The validity context */
/* current type of input */
/* next char look-ahead */
/* the data directory */
/* Node name stack */
/* Current parsed Node */
/* Depth of the parsing stack */
/* Max depth of the parsing stack */
/* array of nodes */
/* number of xmlChar processed */
/* used by progressive parsing lookup */
/* ugly but ... */
/* SAX callbacks are disabled */
/* Parsing is in int 1/ext 2 subset */
/* name of subset */
/* URI of external subset */
/* SYSTEM ID of external subset */
/* xml:space values */
/* Should the parser preserve spaces */
/* Depth of the parsing stack */
/* Max depth of the parsing stack */
/* array of space infos */
/* to prevent entity substitution loops */
/* used to check entities boundaries */
/* encoding of the in-memory content
				         actually an xmlCharEncoding */
/* Those two fields are there to */
/* Speed up large node parsing */
/* signal pedantic warnings */
/* For user data, libxml won't touch it */
/* should the external subset be loaded */
/* set line number in element content */
/* document's own catalog */
/* run in recovery mode */
/* is this a progressive parsing */
/* dictionary for the parser */
/* array for the attributes callbacks */
/* the size of the array */
/* use strings from dict to build tree */
/*
     * pre-interned strings
     */
/*
     * Everything below is used only by the new SAX mode
     */
/* operating in the new SAX mode */
/* the number of inherited namespaces */
/* the size of the arrays */
/* the array of prefix/namespace name */
/* which attribute were allocated */
/* array of data for push */
/* defaulted attributes if any */
/* non-CDATA attributes if any */
/* is the document XML Nanespace okay */
/* Extra options */
/*
     * Those fields are needed only for treaming parsing so far
     */
/* Use dictionary names for the tree */
/* number of freed element nodes */
/* List of freed element nodes */
/* number of freed attributes nodes */
/* List of freed attributes nodes */
/*
     * the complete error informations for the last error.
     */
/* the parser mode */
/* number of entities references */
/* size of parsed entities */
/* for use by HTML non-recursive parser */
/* Current NodeInfo */
/* Depth of the parsing stack */
/* Max depth of the parsing stack */
/* array of nodeInfos */
/* we need to label inputs */
/* volume of entity copy */
/* *
 * xmlSAXLocator:
 *
 * A SAX Locator.
 */
/* *
 * xmlSAXHandler:
 *
 * A SAX handler is bunch of callbacks called by the parser when processing
 * of the input generate data or structure informations.
 */
/* *
 * resolveEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * Callback:
 * The entity loader, to control the loading of external entities,
 * the application can either:
 *    - override this resolveEntity() callback in the SAX block
 *    - or better use the xmlSetExternalEntityLoader() function to
 *      set up it's own entity resolution routine
 *
 * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
 */
/* *
 * internalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on internal subset declaration.
 */
/* *
 * externalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on external subset declaration.
 */
/* *
 * getEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get an entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
/* *
 * getParameterEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get a parameter entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
/* *
 * entityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the entity name
 * @type:  the entity type
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @content: the entity value (without processing).
 *
 * An entity definition has been parsed.
 */
/* *
 * notationDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the notation
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * What to do when a notation declaration has been parsed.
 */
/* *
 * attributeDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @elem:  the name of the element
 * @fullname:  the attribute name
 * @type:  the attribute type
 * @def:  the type of default value
 * @defaultValue: the attribute default value
 * @tree:  the tree of enumerated value set
 *
 * An attribute definition has been parsed.
 */
/* *
 * elementDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the element name
 * @type:  the element type
 * @content: the element value tree
 *
 * An element definition has been parsed.
 */
/* *
 * unparsedEntityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the entity
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @notationName: the name of the notation
 *
 * What to do when an unparsed entity declaration is parsed.
 */
/* *
 * setDocumentLocatorSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @loc: A SAX Locator
 *
 * Receive the document locator at startup, actually xmlDefaultSAXLocator.
 * Everything is available on the context, so this is useless in our case.
 */
/* *
 * startDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document start being processed.
 */
/* *
 * endDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document end has been detected.
 */
/* *
 * startElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name, including namespace prefix
 * @atts:  An array of name/value attributes pairs, NULL terminated
 *
 * Called when an opening tag has been processed.
 */
/* *
 * endElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name
 *
 * Called when the end of an element has been detected.
 */
/* *
 * attributeSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The attribute name, including namespace prefix
 * @value:  The attribute value
 *
 * Handle an attribute that has been read by the parser.
 * The default handling is to convert the attribute into an
 * DOM subtree and past it in a new xmlAttr element added to
 * the element.
 */
/* *
 * referenceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The entity name
 *
 * Called when an entity reference is detected.
 */
/* *
 * charactersSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some chars from the parser.
 */
/* *
 * ignorableWhitespaceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some ignorable whitespaces from the parser.
 * UNUSED: by default the DOM building will use characters.
 */
/* *
 * processingInstructionSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @target:  the target name
 * @data: the PI data's
 *
 * A processing instruction has been parsed.
 */
/* *
 * commentSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  the comment content
 *
 * A comment has been parsed.
 */
/* *
 * cdataBlockSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  The pcdata content
 * @len:  the block length
 *
 * Called when a pcdata block has been parsed.
 */
/* *
 * warningSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format a warning messages, callback.
 */
/* *
 * errorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format an error messages, callback.
 */
/* *
 * fatalErrorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format fatal error messages, callback.
 * Note: so far fatalError() SAX callbacks are not used, error()
 *       get all the callbacks for errors.
 */
/* *
 * isStandaloneSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Is this document tagged standalone?
 *
 * Returns 1 if true
 */
/* *
 * hasInternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an internal subset.
 *
 * Returns 1 if true
 */
/* *
 * hasExternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an external subset?
 *
 * Returns 1 if true
 */
/* ***********************************************************************
 *									*
 *			The SAX version 2 API extensions		*
 *									*
 ************************************************************************/
/* *
 * XML_SAX2_MAGIC:
 *
 * Special constant found in SAX2 blocks initialized fields
 */
/* *
 * startElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 * @nb_namespaces:  number of namespace definitions on that node
 * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
 * @nb_attributes:  the number of attributes on that node
 * @nb_defaulted:  the number of defaulted attributes. The defaulted
 *                  ones are at the end of the array
 * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
 *               attribute values.
 *
 * SAX2 callback when an element start has been detected by the parser.
 * It provides the namespace informations for the element, as well as
 * the new namespace declarations on the element.
 */
/* *
 * endElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 *
 * SAX2 callback when an element end has been detected by the parser.
 * It provides the namespace informations for the element.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandler {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: std::os::raw::c_uint,
    pub _private: *mut std::os::raw::c_void,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub serror: xmlStructuredErrorFunc,
}
/* the node in the tree */
/* *
 * xmlParserError:
 *
 * This is an error that the XML (or HTML) parser can generate
 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* 11 */
/* 12 */
/* 13 */
/* 14 */
/* 15 */
/* 16 */
/* 17 */
/* 18 */
/* 19 */
/* 20 */
/* 21 */
/* 22 */
/* 23 */
/* 24 */
/* 25 */
/* 26 */
/* 27 */
/* 28 */
/* 29 */
/* 30 */
/* 31 */
/* 32 */
/* 33 */
/* 34 */
/* 35 */
/* 36 */
/* 37 */
/* 38 */
/* 39 */
/* 40 */
/* 41 */
/* 42 */
/* 43 */
/* 44 */
/* 45 */
/* 46 */
/* 47 */
/* 48 */
/* 49 */
/* 50 */
/* 51 */
/* 52 */
/* 53 */
/* 54 */
/* 55 */
/* 56 */
/* 57 */
/* 58 */
/* 59 */
/* 60 */
/* 61 */
/* 62 */
/* 63 */
/* 64 */
/* 65 */
/* 66 */
/* 67 */
/* 68 */
/* 69 */
/* 70 */
/* 71 */
/* 72 */
/* 73 */
/* 74 */
/* 75 */
/* 76 */
/* 77 */
/* 78 */
/* 79 */
/* 80 */
/* 81 */
/* 82 */
/* 83 */
/* 84 */
/* 85 */
/* 86 */
/* 87 */
/* 88 */
/* 89 */
/* 90 */
/* 91 */
/* 92 */
/* 93 */
/* 94 */
/* 95 */
/* 96 */
/* 97 */
/* 98 */
/* 99 */
/* 100 */
/* 101 */
/* 102 */
/* 103 */
/* 104 */
/* 105 */
/* 106 */
/* 107 */
/* 108 */
/* 109 */
/* 110 */
/* 111 */
/* 201 */
/* 202 */
/* 203 */
/* 204 */
/* 205 */
/* 501 */
/* 502 */
/* 503 */
/* 504 */
/* 505 */
/* 506 */
/* 507 */
/* 508 */
/* 509 */
/* 510 */
/* 511 */
/* 512 */
/* 513 */
/* 514 */
/* 515 */
/* 516 */
/* 517 */
/* 518 */
/* 519 */
/* 520 */
/* 521 */
/* 522 */
/* 523 */
/* 524 */
/* 525 */
/* 526 */
/* 527 */
/* 528 */
/* 529 */
/* 530 */
/* 531 */
/* 532 */
/* 533 */
/* 534 */
/* 535 */
/* 536 */
/* 537 */
/* 538 */
/* 539 */
/* 540 */
/* 541 */
/* 801 */
/* 1001 */
/* 1002 */
/* 1003 */
/* 1004 */
/* 1005 */
/* 1006 */
/* 1007 */
/* 1008 */
/* 1009 */
/* 1010 */
/* 1011 */
/* 1012 */
/* 1013 */
/* 1014 */
/* 1015 */
/* 1016 */
/* 1017 */
/* 1018 */
/* 1019 */
/* 1020 */
/* 1021 */
/* 1022 */
/* 1023 */
/* 1024 */
/* 1025 */
/* 1026 */
/* 1027 */
/* 1028 */
/* 1029 */
/* 1030 */
/* 1031 */
/* 1032 */
/* 1033 */
/* 1034 */
/* 1035 */
/* 1036 */
/* 1037 */
/* 1038 */
/* 1039 */
/* 1040 */
/* 1041 */
/* 1042 */
/* 1043 */
/* 1044 */
/* 1045 */
/* 1046 */
/* 1047 */
/* 1048 */
/* 1049 */
/* 1050 */
/* 1051 */
/* 1052 */
/* 1053 */
/* 1054 */
/* 1055 */
/* 1056 */
/* 1057 */
/* 1058 */
/* 1059 */
/* 1060 */
/* 1061 */
/* 1062 */
/* 1063 */
/* 1064 */
/* 1065 */
/* 1066 */
/* 1067 */
/* 1068 */
/* 1069 */
/* 1070 */
/* 1071 */
/* 1072 */
/* 1073 */
/* 1074 */
/* 1075 */
/* 1076 */
/* 1077 */
/* 1078 */
/* 1079 */
/* 1080 */
/* 1081 */
/* 1082 */
/* 1083 */
/* 1084 */
/* 1085 */
/* 1086 */
/* 1087 */
/* 1088 */
/* 1089 */
/* 1090 */
/* 1091 */
/* 1092 */
/* 1093 */
/* 1094 */
/* 1095 */
/* 1096 */
/* 1097 */
/* 1098 */
/* 1099 */
/* 1100 */
/* 1101 */
/* 1102 */
/* 1103 */
/* 1104 */
/* 1105 */
/* 1106 */
/* 1107 */
/* 1108 */
/* 1109 */
/* 1110 */
/* 1111 */
/* 1112 */
/* 1113 */
/* 1114 */
/* 1115 */
/* 1116 */
/* 1117 */
/* 1118 */
/* 1119 */
/* 1120 */
/* 1121 */
/* 1122 */
/* 1201 */
/* 1202 */
/* 1203 */
/* 1204 */
/* 1205 */
/* 1206 */
/* 1207 */
/* 1208 */
/* 1209 */
/* 1210 */
/* 1211 */
/* 1212 */
/* 1213 */
/* 1214 */
/* 1215 */
/* 1216 */
/* 1217 */
/* 1218 */
/* 1219 */
/* 1220 */
/* 1221 */
/* 1301 */
/* 1302 */
/* 1303 */
/* 1401 */
/* 1402 */
/* 1403 */
/* 1501 */
/* 1502 */
/* 1503 */
/* 1504 */
/* 1505 */
/* 1506 */
/* 1507 */
/* 1508 */
/* 1509 */
/* 1510 */
/* 1511 */
/* 1512 */
/* 1513 */
/* 1514 */
/* 1515 */
/* 1516 */
/* 1517 */
/* 1518 */
/* 1519 */
/* 1520 */
/* 1521 */
/* 1522 */
/* 1523 */
/* 1524 */
/* 1525 */
/* 1526 */
/* 1527 */
/* 1528 */
/* 1529 */
/* 1530 */
/* 1531 */
/* 1532 */
/* 1533 */
/* 1534 */
/* 1535 */
/* 1536 */
/* 1537 */
/* 1538 */
/* 1539 */
/* 1540 */
/* 1541 */
/* 1542 */
/* 1543 */
/* 1544 */
/* 1545 */
/* 1546 */
/* 1547 */
/* 1548 */
/* 1549 */
/* 1550 */
/* 1551 */
/* 1552 */
/* 1553 */
/* 1554 */
/* 1555 */
/* 1556 */
/* 1601 */
/* 1602 */
/* 1603 */
/* 1604 */
/* 1605 */
/* 1606 */
/* 1607 */
/* 1608 */
/* 1609 */
/* 1610 */
/* 1611 */
/* 1612 */
/* 1613 */
/* 1614 */
/* 1615 */
/* 1616 */
/* 1617 */
/* 1618 */
/* 1651 */
/* 1652 */
/* 1653 */
/* 1654 */
/* 1701 */
/* 1702 */
/* 1703 */
/* 1704 */
/* 1705 */
/* 1706 */
/* 1707 */
/* 1708 */
/* 1709 */
/* 1710 */
/* 1711 */
/* 1712 */
/* 1713 */
/* 1714 */
/* 1715 */
/* 1716 */
/* 1717 */
/* 1718 */
/* 1719 */
/* 1720 */
/* 1721 */
/* 1722 */
/* 1723 */
/* 1724 */
/* 1725 */
/* 1726 */
/* 1727 */
/* 1728 */
/* 1729 */
/* 1730 */
/* 1731 */
/* 1732 */
/* 1733 */
/* 1734 */
/* 1735 */
/* 1736 */
/* 1737 */
/* 1738 */
/* 1739 */
/* 1740 */
/* 1741 */
/* 1742 */
/* 1743 */
/* 1744 */
/* 1745 */
/* 1746 */
/* 1747 */
/* 1748 */
/* 1749 */
/* 1750 */
/* 1751 */
/* 1752 */
/* 1753 */
/* 1754 */
/* 1755 */
/* 1756 */
/* 1757 */
/* 1758 */
/* 1759 */
/* 1760 */
/* 1761 */
/* 1762 */
/* 1763 */
/* 1764 */
/* 1765 */
/* 1766 */
/* 1767 */
/* 1768 */
/* 1769 */
/* 1770 */
/* 1771 */
/* 1772 */
/* 1773 */
/* 1774 */
/* 1775 */
/* 1776 */
/* 1777 */
/* 1778 */
/* 1779 */
/* 1780 */
/* 1781 */
/* 1782 */
/* 1783 */
/* 1784 */
/* 1785 */
/* 1786 */
/* 1787 */
/* 1788 */
/* 1789 */
/* 1790 */
/* 1791 */
/* 1792 */
/* 1793 */
/* 1794 */
/* 1795 */
/* 1796 */
/* 1797 */
/* 1798 */
/* 1799 */
/* 1800 */
/* 1802 */
/* 1803 */
/* 1804 */
/* 1805 */
/* 1806 */
/* 1807 */
/* 1808 */
/* 1809 */
/* 1810 */
/* 1811 */
/* 1812 */
/* 1813 */
/* 1814 */
/* 1815 */
/* 1816 */
/* 1817 */
/* 1818 */
/* 1819 */
/* 1820 */
/* 1821 */
/* 1822 */
/* 1823 */
/* 1824 */
/* 1825 */
/* 1826 */
/* 1827 */
/* 1828 */
/* 1829 */
/* 1830 */
/* 1831 */
/* 1832 */
/* 1833 */
/* 1834 */
/* 1835 */
/* 1836 */
/* 1837 */
/* 1838 */
/* 1839 */
/* 1840 */
/* 1841 */
/* 1842 */
/* 1843 */
/* 1844 */
/* 1845 */
/* 1846 */
/* 1847 */
/* 1848 */
/* 1849 */
/* 1850 */
/* 1851 */
/* 1852 */
/* 1853 */
/* 1854 */
/* 1855 */
/* 1856 */
/* 1857 */
/* 1858 */
/* 1859 */
/* 1860 */
/* 1861 */
/* 1862 */
/* 1863 */
/* 1864 */
/* 1865 */
/* 1866 */
/* 1867 */
/* 1868 */
/* 1869 */
/* 1870 */
/* 1871 */
/* 1872 */
/* 1873 */
/* 1874 */
/* 1875 */
/* 1876 */
/* 1877 */
/* 1878 */
/* 1879 */
/* 1901 */
/* 1902 */
/* 1903 */
/* 1951 */
/* 1952 */
/* 1953 */
/* 1954 */
/* 1955 */
/* 2001 */
/* 2002 */
/* 2003 */
/* 2021 */
/* 2022 */
/* 3001 */
/* 3002 */
/* 3003 */
/* 3004 */
/* 3005 */
/* 3006 */
/* 3007 */
/* 3008 */
/* 3009 */
/* 3010 */
/* 3011 */
/* 3012 */
/* 3013 */
/* 3014 */
/* 3015 */
/* 3016 */
/* 3017 */
/* 3018 */
/* 3019 */
/* 3020 */
/* 3021 */
/* 3022 */
/* 3023 */
/* 3024 */
/* 3025 */
/* 3026 */
/* 3027 */
/* 3028 */
/* 3029 */
/* 3030 */
/* 3031 */
/* 3032 */
/* 3033 */
/* 3034 */
/* 3035 */
/* 3036 */
/* 3037 */
/* 3038 */
/* 3039 */
/* 3040 */
/* 3041 */
/* 3042 */
/* 3043 */
/* 3044 */
/* 3045 */
/* 3046 */
/* 3047 */
/* 3048 */
/* 3049 */
/* 3050 */
/* 3051 */
/* 3052 */
/* 3053 */
/* 3054 */
/* 3055 */
/* 3056 */
/* 3057 */
/* 3058 */
/* 3059 */
/* 3060 */
/* 3061 */
/* 3062 */
/* 3063 */
/* 3064 */
/* 3065 */
/* 3066 */
/* 3067 */
/* 3068 */
/* 3069 non-W3C */
/* 3070 non-W3C */
/* 3071 */
/* 3072 */
/* 3073 */
/* 3074 */
/* 3075 */
/* 3076 */
/* 3077 */
/* 3078 */
/* 3079 */
/* 3080 */
/* 3081 */
/* 3082 */
/* 3083 */
/* 3084 */
/* 3085 */
/* 3085 */
/* 3086 */
/* 3087 */
/* 3088 */
/* 3089 */
/* 3090 */
/* 4000 */
/* 4900 */
/* 4901 */
/* 5001 */
/* 5002 */
/* 5003 */
/* 5004 */
/* 5005 */
/* 5006 */
/* 5007 */
/* 5008 */
/* 5009 */
/* 5010 */
/* 5011 */
/* 5012 */
/* 5013 */
/* 5014 */
/* 5015 */
/* 5016 */
/* 5017 */
/* 5018 */
/* 5019 */
/* 5020 */
/* 5021 */
/* 5022 */
/* 5023 */
/* 5024 */
/* 5025 */
/* 5026 */
/* 5027 */
/* 5028 */
/* 5029 */
/* 5030 */
/* 5031 */
/* 5032 */
/* 5033 */
/* 5034 */
/* 5035 */
/* 5036 */
/* 5037 */
/* 6001 */
/* 6002 */
/* 6003 */
/* 6004 */
/* *
 * xmlGenericErrorFunc:
 * @ctx:  a parsing context
 * @msg:  the message
 * @...:  the extra arguments of the varags to format the message
 *
 * Signature of the function to use when there is an error and
 * no parsing or validity context available .
 */
/* *
 * xmlStructuredErrorFunc:
 * @userData:  user provided data for the error callback
 * @error:  the error being raised.
 *
 * Signature of the function to use when there is an error and
 * the module handles the new error reporting mechanism.
 */
pub type xmlStructuredErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlErrorPtr) -> ()>;
pub type xmlErrorPtr = *mut xmlError;
pub type endElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type startElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *mut *const xmlChar,
                                _: std::os::raw::c_int, _: std::os::raw::c_int,
                                _: *mut *const xmlChar) -> ()>;
pub type externalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type cdataBlockSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type getParameterEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type xmlEntityPtr = *mut xmlEntity;
pub type xmlEntity = _xmlEntity;
/*
 * Summary: interface for the XML entities handling
 * Description: this module provides some of the entity API needed
 *              for the parser and applications.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * The different valid entity types.
 */
/*
 * An unit of storage for an entity, contains the string, the value
 * and the linkind data needed for the linking in the hash table.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEntity {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub orig: *mut xmlChar,
    pub content: *mut xmlChar,
    pub length: std::os::raw::c_int,
    pub etype: xmlEntityType,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub nexte: *mut _xmlEntity,
    pub URI: *const xmlChar,
    pub owner: std::os::raw::c_int,
    pub checked: std::os::raw::c_int,
}
pub type xmlEntityType = std::os::raw::c_uint;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub type fatalErrorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type errorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type warningSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type commentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type processingInstructionSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type ignorableWhitespaceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type charactersSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type referenceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type endElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type startElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *mut *const xmlChar) -> ()>;
pub type endDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type startDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type setDocumentLocatorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlSAXLocatorPtr)
               -> ()>;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXLocator = _xmlSAXLocator;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXLocator {
    pub getPublicId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getSystemId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getLineNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                  -> std::os::raw::c_int>,
    pub getColumnNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                    -> std::os::raw::c_int>,
}
pub type unparsedEntityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type elementDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: xmlElementContentPtr)
               -> ()>;
pub type xmlElementContentPtr = *mut xmlElementContent;
pub type xmlElementContent = _xmlElementContent;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElementContent {
    pub type_0: xmlElementContentType,
    pub ocur: xmlElementContentOccur,
    pub name: *const xmlChar,
    pub c1: *mut _xmlElementContent,
    pub c2: *mut _xmlElementContent,
    pub parent: *mut _xmlElementContent,
    pub prefix: *const xmlChar,
}
pub type xmlElementContentOccur = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub type attributeDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: std::os::raw::c_int,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: xmlEnumerationPtr) -> ()>;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
pub type xmlEnumeration = _xmlEnumeration;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEnumeration {
    pub next: *mut _xmlEnumeration,
    pub name: *const xmlChar,
}
pub type notationDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type entityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: *const xmlChar, _: *mut xmlChar) -> ()>;
pub type getEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type resolveEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlParserInputPtr>;
pub type hasExternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type hasInternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type isStandaloneSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type internalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type xmlParserCtxt = _xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
pub type xmlSAXHandler = _xmlSAXHandler;
pub type xmlSAXHandlerPtr = *mut xmlSAXHandler;
pub type xmlBufferAllocationScheme = std::os::raw::c_uint;
pub const XML_BUFFER_ALLOC_BOUNDED: xmlBufferAllocationScheme = 5;
pub const XML_BUFFER_ALLOC_HYBRID: xmlBufferAllocationScheme = 4;
pub const XML_BUFFER_ALLOC_IO: xmlBufferAllocationScheme = 3;
pub const XML_BUFFER_ALLOC_IMMUTABLE: xmlBufferAllocationScheme = 2;
pub const XML_BUFFER_ALLOC_EXACT: xmlBufferAllocationScheme = 1;
pub const XML_BUFFER_ALLOC_DOUBLEIT: xmlBufferAllocationScheme = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlBuffer {
    pub content: *mut xmlChar,
    pub use_0: std::os::raw::c_uint,
    pub size: std::os::raw::c_uint,
    pub alloc: xmlBufferAllocationScheme,
    pub contentIO: *mut xmlChar,
}
pub type xmlBuffer = _xmlBuffer;
pub type xmlBufferPtr = *mut xmlBuffer;
pub type C2RustUnnamed = std::os::raw::c_uint;
pub const XML_ATTRIBUTE_FIXED: C2RustUnnamed = 4;
pub const XML_ATTRIBUTE_IMPLIED: C2RustUnnamed = 3;
pub const XML_ATTRIBUTE_REQUIRED: C2RustUnnamed = 2;
pub const XML_ATTRIBUTE_NONE: C2RustUnnamed = 1;
pub type C2RustUnnamed_0 = std::os::raw::c_uint;
pub const XML_ELEMENT_TYPE_ELEMENT: C2RustUnnamed_0 = 4;
pub const XML_ELEMENT_TYPE_MIXED: C2RustUnnamed_0 = 3;
pub const XML_ELEMENT_TYPE_ANY: C2RustUnnamed_0 = 2;
pub const XML_ELEMENT_TYPE_EMPTY: C2RustUnnamed_0 = 1;
pub const XML_ELEMENT_TYPE_UNDEFINED: C2RustUnnamed_0 = 0;
pub type xmlNsPtr = *mut xmlNs;
pub type xmlDtd = _xmlDtd;
pub type xmlDtdPtr = *mut xmlDtd;
pub type C2RustUnnamed_1 = std::os::raw::c_uint;
pub const XML_DOC_HTML: C2RustUnnamed_1 = 128;
pub const XML_DOC_INTERNAL: C2RustUnnamed_1 = 64;
pub const XML_DOC_USERBUILT: C2RustUnnamed_1 = 32;
pub const XML_DOC_XINCLUDE: C2RustUnnamed_1 = 16;
pub const XML_DOC_DTDVALID: C2RustUnnamed_1 = 8;
pub const XML_DOC_OLD10: C2RustUnnamed_1 = 4;
pub const XML_DOC_NSVALID: C2RustUnnamed_1 = 2;
pub const XML_DOC_WELLFORMED: C2RustUnnamed_1 = 1;
/*
 * Recent version of gcc produce a warning when a function pointer is assigned
 * to an object pointer, or vice versa.  The following macro is a dirty hack
 * to allow suppression of the warning.  If your architecture has function
 * pointers which are a different size than a void pointer, there may be some
 * serious trouble within the library.
 */
/* *
 * XML_CAST_FPTR:
 * @fptr:  pointer to a function
 *
 * Macro to do a casting from an object pointer to a
 * function pointer without encountering a warning from
 * gcc
 *
 * #define XML_CAST_FPTR(fptr) (*(void **)(&fptr))
 * This macro violated ISO C aliasing rules (gcc4 on s390 broke)
 * so it is disabled now
 */
/*
 * function types:
 */
/* *
 * xmlHashDeallocator:
 * @payload:  the data in the hash
 * @name:  the name associated
 *
 * Callback to free data from a hash.
 */
pub type xmlHashDeallocator
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
/* *
 * xmlHashScannerFull:
 * @payload:  the data in the hash
 * @data:  extra scannner data
 * @name:  the name associated
 * @name2:  the second name associated
 * @name3:  the third name associated
 *
 * Callback when scanning data in a hash with the full scanner.
 */
pub type xmlHashScannerFull
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_void,
                                _: *const xmlChar, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type C2RustUnnamed_2 = std::os::raw::c_uint;
pub const XML_FROM_URI: C2RustUnnamed_2 = 30;
pub const XML_FROM_BUFFER: C2RustUnnamed_2 = 29;
pub const XML_FROM_SCHEMATRONV: C2RustUnnamed_2 = 28;
pub const XML_FROM_I18N: C2RustUnnamed_2 = 27;
pub const XML_FROM_MODULE: C2RustUnnamed_2 = 26;
pub const XML_FROM_WRITER: C2RustUnnamed_2 = 25;
pub const XML_FROM_CHECK: C2RustUnnamed_2 = 24;
pub const XML_FROM_VALID: C2RustUnnamed_2 = 23;
pub const XML_FROM_XSLT: C2RustUnnamed_2 = 22;
pub const XML_FROM_C14N: C2RustUnnamed_2 = 21;
pub const XML_FROM_CATALOG: C2RustUnnamed_2 = 20;
pub const XML_FROM_RELAXNGV: C2RustUnnamed_2 = 19;
pub const XML_FROM_RELAXNGP: C2RustUnnamed_2 = 18;
pub const XML_FROM_SCHEMASV: C2RustUnnamed_2 = 17;
pub const XML_FROM_SCHEMASP: C2RustUnnamed_2 = 16;
pub const XML_FROM_DATATYPE: C2RustUnnamed_2 = 15;
pub const XML_FROM_REGEXP: C2RustUnnamed_2 = 14;
pub const XML_FROM_XPOINTER: C2RustUnnamed_2 = 13;
pub const XML_FROM_XPATH: C2RustUnnamed_2 = 12;
pub const XML_FROM_XINCLUDE: C2RustUnnamed_2 = 11;
pub const XML_FROM_HTTP: C2RustUnnamed_2 = 10;
pub const XML_FROM_FTP: C2RustUnnamed_2 = 9;
pub const XML_FROM_IO: C2RustUnnamed_2 = 8;
pub const XML_FROM_OUTPUT: C2RustUnnamed_2 = 7;
pub const XML_FROM_MEMORY: C2RustUnnamed_2 = 6;
pub const XML_FROM_HTML: C2RustUnnamed_2 = 5;
pub const XML_FROM_DTD: C2RustUnnamed_2 = 4;
pub const XML_FROM_NAMESPACE: C2RustUnnamed_2 = 3;
pub const XML_FROM_TREE: C2RustUnnamed_2 = 2;
pub const XML_FROM_PARSER: C2RustUnnamed_2 = 1;
pub const XML_FROM_NONE: C2RustUnnamed_2 = 0;
pub type xmlParserErrors = std::os::raw::c_uint;
pub const XML_BUF_OVERFLOW: xmlParserErrors = 7000;
pub const XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors =
    3007;
pub const XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors =
    3005;
pub const XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const XML_IO_EALREADY: xmlParserErrors = 1555;
pub const XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const XML_IO_EISCONN: xmlParserErrors = 1551;
pub const XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const XML_IO_WRITE: xmlParserErrors = 1546;
pub const XML_IO_FLUSH: xmlParserErrors = 1545;
pub const XML_IO_ENCODER: xmlParserErrors = 1544;
pub const XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const XML_IO_EXDEV: xmlParserErrors = 1542;
pub const XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const XML_IO_ESRCH: xmlParserErrors = 1540;
pub const XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const XML_IO_EROFS: xmlParserErrors = 1538;
pub const XML_IO_ERANGE: xmlParserErrors = 1537;
pub const XML_IO_EPIPE: xmlParserErrors = 1536;
pub const XML_IO_EPERM: xmlParserErrors = 1535;
pub const XML_IO_ENXIO: xmlParserErrors = 1534;
pub const XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const XML_IO_ENOENT: xmlParserErrors = 1524;
pub const XML_IO_ENODEV: xmlParserErrors = 1523;
pub const XML_IO_ENFILE: xmlParserErrors = 1522;
pub const XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const XML_IO_EMLINK: xmlParserErrors = 1519;
pub const XML_IO_EMFILE: xmlParserErrors = 1518;
pub const XML_IO_EISDIR: xmlParserErrors = 1517;
pub const XML_IO_EIO: xmlParserErrors = 1516;
pub const XML_IO_EINVAL: xmlParserErrors = 1515;
pub const XML_IO_EINTR: xmlParserErrors = 1514;
pub const XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const XML_IO_EFBIG: xmlParserErrors = 1512;
pub const XML_IO_EFAULT: xmlParserErrors = 1511;
pub const XML_IO_EEXIST: xmlParserErrors = 1510;
pub const XML_IO_EDOM: xmlParserErrors = 1509;
pub const XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const XML_IO_ECHILD: xmlParserErrors = 1507;
pub const XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const XML_IO_EBUSY: xmlParserErrors = 1505;
pub const XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const XML_IO_EBADF: xmlParserErrors = 1503;
pub const XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const XML_IO_EACCES: xmlParserErrors = 1501;
pub const XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const XML_WAR_NS_URI: xmlParserErrors = 99;
pub const XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const XML_ERR_OK: xmlParserErrors = 0;
pub type xmlGenericErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlValidCtxtPtr = *mut xmlValidCtxt;
pub type xmlParserNodeInfoPtr = *mut xmlParserNodeInfo;
pub type xmlParserNodeInfoSeqPtr = *mut xmlParserNodeInfoSeq;
/*
 * SAX Version 1
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandlerV1 {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: std::os::raw::c_uint,
}
pub type xmlSAXHandlerV1 = _xmlSAXHandlerV1;
/*
 * Summary: interface for the encoding conversion functions
 * Description: interface for the encoding conversion functions needed for
 *              XML basic encoding and iconv() support.
 *
 * Related specs are
 * rfc2044        (UTF-8 and UTF-16) F. Yergeau Alis Technologies
 * [ISO-10646]    UTF-8 and UTF-16 in Annexes
 * [ISO-8859-1]   ISO Latin-1 characters codes.
 * [UNICODE]      The Unicode Consortium, "The Unicode Standard --
 *                Worldwide Character Encoding -- Version 1.0", Addison-
 *                Wesley, Volume 1, 1991, Volume 2, 1992.  UTF-8 is
 *                described in Unicode Technical Report #4.
 * [US-ASCII]     Coded Character Set--7-bit American Standard Code for
 *                Information Interchange, ANSI X3.4-1986.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * xmlCharEncoding:
 *
 * Predefined values for some standard encodings.
 * Libxml does not do beforehand translation on UTF8 and ISOLatinX.
 * It also supports ASCII, ISO-8859-1, and UTF16 (LE and BE) by default.
 *
 * Anything else would have to be translated to UTF8 before being
 * given to the parser itself. The BOM for UTF16 and the encoding
 * declaration are looked at and a converter is looked for at that
 * point. If not found the parser stops here as asked by the XML REC. A
 * converter can be registered by the user using xmlRegisterCharEncodingHandler
 * but the current form doesn't allow stateful transcoding (a serious
 * problem agreed !). If iconv has been found it will be used
 * automatically and allow stateful transcoding, the simplest is then
 * to be sure to enable iconv and to provide iconv libs for the encoding
 * support needed.
 *
 * Note that the generic "UTF-16" is not a predefined value.  Instead, only
 * the specific UTF-16LE and UTF-16BE are present.
 */
pub type xmlCharEncoding = std::os::raw::c_int;
/* pure ASCII */
/* EUC-JP */
pub const XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
/* Shift_JIS */
pub const XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
/* ISO-2022-JP */
pub const XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
/* ISO-8859-9 */
pub const XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
/* ISO-8859-8 */
pub const XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
/* ISO-8859-7 */
pub const XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
/* ISO-8859-6 */
pub const XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
/* ISO-8859-5 */
pub const XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
/* ISO-8859-4 */
pub const XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
/* ISO-8859-3 */
pub const XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
/* ISO-8859-2 ISO Latin 2 */
pub const XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
/* ISO-8859-1 ISO Latin 1 */
pub const XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
/* UCS-2 */
pub const XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
/* UCS-4 unusual ordering */
pub const XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
/* UCS-4 unusual ordering */
pub const XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
/* EBCDIC uh! */
pub const XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
/* UCS-4 big endian */
pub const XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
/* UCS-4 little endian */
pub const XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
/* UTF-16 big endian */
pub const XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
/* UTF-16 little endian */
pub const XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
/* UTF-8 */
pub const XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
/* No char encoding detected */
pub const XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
/* No char encoding detected */
pub const XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
pub const XML_PARSE_OLD10: C2RustUnnamed_3 = 131072;
pub const XML_PARSE_HUGE: C2RustUnnamed_3 = 524288;
pub const XML_CATA_ALLOW_ALL: xmlCatalogAllow = 3;
pub type xmlCatalogAllow = std::os::raw::c_uint;
pub const XML_CATA_ALLOW_DOCUMENT: xmlCatalogAllow = 2;
pub const XML_CATA_ALLOW_GLOBAL: xmlCatalogAllow = 1;
pub const XML_CATA_ALLOW_NONE: xmlCatalogAllow = 0;
pub const XML_PARSE_IGNORE_ENC: C2RustUnnamed_3 = 2097152;
pub const XML_PARSE_DTDATTR: C2RustUnnamed_3 = 8;
pub const XML_PARSE_DTDLOAD: C2RustUnnamed_3 = 4;
pub const XML_PARSE_DTDVALID: C2RustUnnamed_3 = 16;
pub const XML_PARSE_NOENT: C2RustUnnamed_3 = 2;
pub type xmlChRangeGroup = _xmlChRangeGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlChRangeGroup {
    pub nbShortRange: std::os::raw::c_int,
    pub nbLongRange: std::os::raw::c_int,
    pub shortRange: *const xmlChSRange,
    pub longRange: *const xmlChLRange,
}
pub type xmlChLRange = _xmlChLRange;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlChLRange {
    pub low: std::os::raw::c_uint,
    pub high: std::os::raw::c_uint,
}
pub type xmlChSRange = _xmlChSRange;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlChSRange {
    pub low: std::os::raw::c_ushort,
    pub high: std::os::raw::c_ushort,
}
pub const XML_PARSE_OLDSAX: C2RustUnnamed_3 = 1048576;
/*
 * Specific function to keep track of entities references
 * and used by the XSLT debugger.
 */
/* *
 * xmlEntityReferenceFunc:
 * @ent: the entity
 * @firstNode:  the fist node in the chunk
 * @lastNode:  the last nod in the chunk
 *
 * Callback function used when one needs to be able to track back the
 * provenance of a chunk of nodes inherited from an entity replacement.
 */
pub type xmlEntityReferenceFunc
    =
    Option<unsafe extern "C" fn(_: xmlEntityPtr, _: xmlNodePtr, _: xmlNodePtr)
               -> ()>;
pub const XML_PARSE_NSCLEAN: C2RustUnnamed_3 = 8192;
pub type xmlDefAttrsPtr = *mut xmlDefAttrs;
pub type xmlDefAttrs = _xmlDefAttrs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDefAttrs {
    pub nbAttrs: std::os::raw::c_int,
    pub maxAttrs: std::os::raw::c_int,
    pub values: [*const xmlChar; 0],
}
pub type xmlURIPtr = *mut xmlURI;
/* *
 * Summary: library of generic URI related routines
 * Description: library of generic URI related routines
 *              Implements RFC 2396
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlURI:
 *
 * A parsed URI reference. This is a struct containing the various fields
 * as described in RFC 2396 but separated for further processing.
 *
 * Note: query is a deprecated field which is incorrectly unescaped.
 * query_raw takes precedence over query if the former is set.
 * See: http://mail.gnome.org/archives/xml/2007-April/thread.html#00127
 */
pub type xmlURI = _xmlURI;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlURI {
    pub scheme: *mut std::os::raw::c_char,
    pub opaque: *mut std::os::raw::c_char,
    pub authority: *mut std::os::raw::c_char,
    pub server: *mut std::os::raw::c_char,
    pub user: *mut std::os::raw::c_char,
    pub port: std::os::raw::c_int,
    pub path: *mut std::os::raw::c_char,
    pub query: *mut std::os::raw::c_char,
    pub fragment: *mut std::os::raw::c_char,
    pub cleanup: std::os::raw::c_int,
    pub query_raw: *mut std::os::raw::c_char,
}
pub const XML_PARSE_BIG_LINES: C2RustUnnamed_3 = 4194304;
pub const XML_PARSE_NOBASEFIX: C2RustUnnamed_3 = 262144;
pub const XML_PARSE_COMPACT: C2RustUnnamed_3 = 65536;
pub const XML_PARSE_NONET: C2RustUnnamed_3 = 2048;
pub const XML_PARSE_NOCDATA: C2RustUnnamed_3 = 16384;
pub const XML_PARSE_NODICT: C2RustUnnamed_3 = 4096;
pub const XML_PARSE_SAX1: C2RustUnnamed_3 = 512;
pub const XML_PARSE_NOERROR: C2RustUnnamed_3 = 32;
pub const XML_PARSE_NOWARNING: C2RustUnnamed_3 = 64;
pub const XML_PARSE_NOBLANKS: C2RustUnnamed_3 = 256;
pub const XML_PARSE_PEDANTIC: C2RustUnnamed_3 = 128;
pub const XML_PARSE_RECOVER: C2RustUnnamed_3 = 1;
pub const HTML_PARSE_NOIMPLIED: C2RustUnnamed_4 = 8192;
pub type htmlParserCtxtPtr = xmlParserCtxtPtr;
pub type C2RustUnnamed_3 = std::os::raw::c_uint;
pub const XML_PARSE_NOXINCNODE: C2RustUnnamed_3 = 32768;
pub const XML_PARSE_XINCLUDE: C2RustUnnamed_3 = 1024;
pub type xmlFeature = std::os::raw::c_uint;
pub const XML_WITH_NONE: xmlFeature = 99999;
pub const XML_WITH_LZMA: xmlFeature = 33;
pub const XML_WITH_ICU: xmlFeature = 32;
pub const XML_WITH_ZLIB: xmlFeature = 31;
pub const XML_WITH_DEBUG_RUN: xmlFeature = 30;
pub const XML_WITH_DEBUG_MEM: xmlFeature = 29;
pub const XML_WITH_DEBUG: xmlFeature = 28;
pub const XML_WITH_MODULES: xmlFeature = 27;
pub const XML_WITH_SCHEMATRON: xmlFeature = 26;
pub const XML_WITH_SCHEMAS: xmlFeature = 25;
pub const XML_WITH_EXPR: xmlFeature = 24;
pub const XML_WITH_AUTOMATA: xmlFeature = 23;
pub const XML_WITH_REGEXP: xmlFeature = 22;
pub const XML_WITH_UNICODE: xmlFeature = 21;
pub const XML_WITH_ISO8859X: xmlFeature = 20;
pub const XML_WITH_ICONV: xmlFeature = 19;
pub const XML_WITH_XINCLUDE: xmlFeature = 18;
pub const XML_WITH_XPTR: xmlFeature = 17;
pub const XML_WITH_XPATH: xmlFeature = 16;
pub const XML_WITH_CATALOG: xmlFeature = 15;
pub const XML_WITH_C14N: xmlFeature = 14;
pub const XML_WITH_LEGACY: xmlFeature = 13;
pub const XML_WITH_HTML: xmlFeature = 12;
pub const XML_WITH_VALID: xmlFeature = 11;
pub const XML_WITH_HTTP: xmlFeature = 10;
pub const XML_WITH_FTP: xmlFeature = 9;
pub const XML_WITH_SAX1: xmlFeature = 8;
pub const XML_WITH_WRITER: xmlFeature = 7;
pub const XML_WITH_PATTERN: xmlFeature = 6;
pub const XML_WITH_READER: xmlFeature = 5;
pub const XML_WITH_PUSH: xmlFeature = 4;
pub const XML_WITH_OUTPUT: xmlFeature = 3;
pub const XML_WITH_TREE: xmlFeature = 2;
pub const XML_WITH_THREAD: xmlFeature = 1;
pub type C2RustUnnamed_4 = std::os::raw::c_uint;
pub const HTML_PARSE_IGNORE_ENC: C2RustUnnamed_4 = 2097152;
pub const HTML_PARSE_COMPACT: C2RustUnnamed_4 = 65536;
pub const HTML_PARSE_NONET: C2RustUnnamed_4 = 2048;
pub const HTML_PARSE_NOBLANKS: C2RustUnnamed_4 = 256;
pub const HTML_PARSE_PEDANTIC: C2RustUnnamed_4 = 128;
pub const HTML_PARSE_NOWARNING: C2RustUnnamed_4 = 64;
pub const HTML_PARSE_NOERROR: C2RustUnnamed_4 = 32;
pub const HTML_PARSE_NODEFDTD: C2RustUnnamed_4 = 4;
pub const HTML_PARSE_RECOVER: C2RustUnnamed_4 = 1;
/*
 * xmlParserEntityCheck
 *
 * Function to check non-linear entity expansion behaviour
 * This is here to detect and stop exponential linear entity expansion
 * This is not a limitation of the parser but a safety
 * boundary feature. It can be disabled with the XML_PARSE_HUGE
 * parser option.
 */
unsafe extern "C" fn xmlParserEntityCheck(mut ctxt: xmlParserCtxtPtr,
                                          mut size: size_t,
                                          mut ent: xmlEntityPtr,
                                          mut replacement: size_t)
 -> std::os::raw::c_int {
    let mut consumed: size_t = 0 as std::os::raw::c_int as size_t;
    if ctxt.is_null() || (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int != 0
       {
        return 0 as std::os::raw::c_int
    }
    if (*ctxt).lastError.code == XML_ERR_ENTITY_LOOP as std::os::raw::c_int {
        return 1 as std::os::raw::c_int
    }
    /*
     * This may look absurd but is needed to detect
     * entities problems
     */
    if !ent.is_null() &&
           (*ent).etype as std::os::raw::c_uint !=
               XML_INTERNAL_PREDEFINED_ENTITY as std::os::raw::c_int as std::os::raw::c_uint
           && !(*ent).content.is_null() && (*ent).checked == 0 as std::os::raw::c_int
           && (*ctxt).errNo != XML_ERR_ENTITY_LOOP as std::os::raw::c_int {
        let mut oldnbent: std::os::raw::c_ulong = (*ctxt).nbentities;
        let mut rep: *mut xmlChar = 0 as *mut xmlChar;
        (*ent).checked = 1 as std::os::raw::c_int;
        (*ctxt).depth += 1;
        rep =
            xmlStringDecodeEntities(ctxt, (*ent).content, 1 as std::os::raw::c_int,
                                    0 as std::os::raw::c_int as xmlChar,
                                    0 as std::os::raw::c_int as xmlChar,
                                    0 as std::os::raw::c_int as xmlChar);
        (*ctxt).depth -= 1;
        if rep.is_null() ||
               (*ctxt).errNo == XML_ERR_ENTITY_LOOP as std::os::raw::c_int {
            *(*ent).content.offset(0 as std::os::raw::c_int as isize) =
                0 as std::os::raw::c_int as xmlChar
        }
        (*ent).checked =
            (*ctxt).nbentities.wrapping_sub(oldnbent).wrapping_add(1 as
                                                                       std::os::raw::c_int
                                                                       as
                                                                       std::os::raw::c_ulong).wrapping_mul(2
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                                       as
                                                                                                       std::os::raw::c_ulong)
                as std::os::raw::c_int;
        if !rep.is_null() {
            if !xmlStrchr(rep, '<' as i32 as xmlChar).is_null() {
                (*ent).checked |= 1 as std::os::raw::c_int
            }
            xmlFree.expect("non-null function pointer")(rep as
                                                            *mut std::os::raw::c_void);
            rep = 0 as *mut xmlChar
        }
    }
    if replacement != 0 as std::os::raw::c_int as std::os::raw::c_ulong {
        if replacement < 10000000 as std::os::raw::c_int as std::os::raw::c_ulong {
            return 0 as std::os::raw::c_int
        }
        /*
	 * If the volume of entity copy reaches 10 times the
	 * amount of parsed data and over the large text threshold
	 * then that's very likely to be an abuse.
	 */
        if !(*ctxt).input.is_null() {
            consumed =
                (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                           as std::os::raw::c_long as
                                                           std::os::raw::c_ulong)
        }
        consumed =
            (consumed as std::os::raw::c_ulong).wrapping_add((*ctxt).sizeentities) as
                size_t as size_t;
        if replacement <
               (10 as std::os::raw::c_int as std::os::raw::c_ulong).wrapping_mul(consumed) {
            return 0 as std::os::raw::c_int
        }
    } else if size != 0 as std::os::raw::c_int as std::os::raw::c_ulong {
        /*
         * Do the check based on the replacement size of the entity
         */
        if size < 1000 as std::os::raw::c_int as std::os::raw::c_ulong {
            return 0 as std::os::raw::c_int
        }
        /*
         * A limit on the amount of text data reasonably used
         */
        if !(*ctxt).input.is_null() {
            consumed =
                (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                           as std::os::raw::c_long as
                                                           std::os::raw::c_ulong)
        }
        consumed =
            (consumed as std::os::raw::c_ulong).wrapping_add((*ctxt).sizeentities) as
                size_t as size_t;
        if size < (10 as std::os::raw::c_int as std::os::raw::c_ulong).wrapping_mul(consumed)
               &&
               (*ctxt).nbentities.wrapping_mul(3 as std::os::raw::c_int as
                                                   std::os::raw::c_ulong) <
                   (10 as std::os::raw::c_int as std::os::raw::c_ulong).wrapping_mul(consumed)
           {
            return 0 as std::os::raw::c_int
        }
    } else if !ent.is_null() {
        /*
         * use the number of parsed entities in the replacement
         */
        size = ((*ent).checked / 2 as std::os::raw::c_int) as size_t;
        /*
         * The amount of data parsed counting entities size only once
         */
        if !(*ctxt).input.is_null() {
            consumed =
                (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                           as std::os::raw::c_long as
                                                           std::os::raw::c_ulong)
        }
        consumed =
            (consumed as std::os::raw::c_ulong).wrapping_add((*ctxt).sizeentities) as
                size_t as size_t;
        /*
         * Check the density of entities for the amount of data
	 * knowing an entity reference will take at least 3 bytes
         */
        if size.wrapping_mul(3 as std::os::raw::c_int as std::os::raw::c_ulong) <
               consumed.wrapping_mul(10 as std::os::raw::c_int as std::os::raw::c_ulong) {
            return 0 as std::os::raw::c_int
        }
    } else if (*ctxt).lastError.code !=
                  XML_ERR_UNDECLARED_ENTITY as std::os::raw::c_int &&
                  (*ctxt).lastError.code !=
                      XML_WAR_UNDECLARED_ENTITY as std::os::raw::c_int ||
                  (*ctxt).nbentities <= 10000 as std::os::raw::c_int as std::os::raw::c_ulong
     {
        return 0 as std::os::raw::c_int
    }
    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, 0 as *const std::os::raw::c_char);
    return 1 as std::os::raw::c_int;
}
/*
         * strange we got no data for checking
         */
/* *
 * xmlParserMaxDepth:
 *
 * arbitrary depth limit for the XML documents that we allow to
 * process. This is not a limitation of the parser but a safety
 * boundary feature. It can be disabled with the XML_PARSE_HUGE
 * parser option.
 */
#[no_mangle]
pub static mut xmlParserMaxDepth: std::os::raw::c_uint =
    256 as std::os::raw::c_int as std::os::raw::c_uint;
/*
 * List of XML prefixed PI allowed by W3C specs
 */
static mut xmlW3CPIs: [*const std::os::raw::c_char; 3] =
    [b"xml-stylesheet\x00" as *const u8 as *const std::os::raw::c_char,
     b"xml-model\x00" as *const u8 as *const std::os::raw::c_char,
     0 as *const std::os::raw::c_char];
/* ***********************************************************************
 *									*
 *		Some factorized error routines				*
 *									*
 ************************************************************************/
/* *
 * xmlErrAttributeDup:
 * @ctxt:  an XML parser context
 * @prefix:  the attribute prefix
 * @localname:  the attribute localname
 *
 * Handle a redefinition of attribute error
 */
unsafe extern "C" fn xmlErrAttributeDup(mut ctxt: xmlParserCtxtPtr,
                                        mut prefix: *const xmlChar,
                                        mut localname: *const xmlChar) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() {
        (*ctxt).errNo = XML_ERR_ATTRIBUTE_REDEFINED as std::os::raw::c_int
    }
    if prefix.is_null() {
        __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_PARSER as std::os::raw::c_int,
                        XML_ERR_ATTRIBUTE_REDEFINED as std::os::raw::c_int,
                        XML_ERR_FATAL, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, localname as *const std::os::raw::c_char,
                        0 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, 0 as std::os::raw::c_int,
                        b"Attribute %s redefined\n\x00" as *const u8 as
                            *const std::os::raw::c_char, localname);
    } else {
        __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_PARSER as std::os::raw::c_int,
                        XML_ERR_ATTRIBUTE_REDEFINED as std::os::raw::c_int,
                        XML_ERR_FATAL, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, prefix as *const std::os::raw::c_char,
                        localname as *const std::os::raw::c_char,
                        0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                        0 as std::os::raw::c_int,
                        b"Attribute %s:%s redefined\n\x00" as *const u8 as
                            *const std::os::raw::c_char, prefix, localname);
    }
    if !ctxt.is_null() {
        (*ctxt).wellFormed = 0 as std::os::raw::c_int;
        if (*ctxt).recovery == 0 as std::os::raw::c_int {
            (*ctxt).disableSAX = 1 as std::os::raw::c_int
        }
    };
}
/*
 * parser.c : an XML 1.0 parser, namespaces and validity support are mostly
 *            implemented on top of the SAX interfaces
 *
 * References:
 *   The XML specification:
 *     http://www.w3.org/TR/REC-xml
 *   Original 1.0 version:
 *     http://www.w3.org/TR/1998/REC-xml-19980210
 *   XML second edition working draft
 *     http://www.w3.org/TR/2000/WD-xml-2e-20000814
 *
 * Okay this is a big file, the parser core is around 7000 lines, then it
 * is followed by the progressive parser top routines, then the various
 * high level APIs to call the parser and a few miscellaneous functions.
 * A number of helper functions and deprecated ones have been moved to
 * parserInternals.c to reduce this file size.
 * As much as possible the functions are associated with their relative
 * production in the XML specification. A few productions defining the
 * different ranges of character are actually implanted either in
 * parserInternals.h or parserInternals.c
 * The DOM tree build is realized from the default SAX callbacks in
 * the module SAX.c.
 * The routines doing the validation checks are in valid.c and called either
 * from the SAX callbacks or as standalone functions using a preparsed
 * document.
 *
 * See Copyright for the status of this software.
 *
 * daniel@veillard.com
 */
/* To avoid EBCDIC trouble when parsing on zOS */
/* *
 * xmlFatalErr:
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @extra:  extra information string
 *
 * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 */
unsafe extern "C" fn xmlFatalErr(mut ctxt: xmlParserCtxtPtr,
                                 mut error: xmlParserErrors,
                                 mut info: *const std::os::raw::c_char) {
    let mut errmsg: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    match error as std::os::raw::c_uint {
        6 => {
            errmsg =
                b"CharRef: invalid hexadecimal value\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        7 => {
            errmsg =
                b"CharRef: invalid decimal value\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        8 => {
            errmsg =
                b"CharRef: invalid value\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        1 => {
            errmsg = b"internal error\x00" as *const u8 as *const std::os::raw::c_char
        }
        18 => {
            errmsg =
                b"PEReference at end of document\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        19 => {
            errmsg =
                b"PEReference in prolog\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        20 => {
            errmsg =
                b"PEReference in epilog\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        24 => {
            errmsg =
                b"PEReference: no name\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        25 => {
            errmsg =
                b"PEReference: expecting \';\'\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        89 => {
            errmsg =
                b"Detected an entity reference loop\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        36 => {
            errmsg =
                b"EntityValue: \" or \' expected\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        88 => {
            errmsg =
                b"PEReferences forbidden in internal subset\x00" as *const u8
                    as *const std::os::raw::c_char
        }
        37 => {
            errmsg =
                b"EntityValue: \" or \' expected\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        39 => {
            errmsg =
                b"AttValue: \" or \' expected\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        38 => {
            errmsg =
                b"Unescaped \'<\' not allowed in attributes values\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        43 => {
            errmsg =
                b"SystemLiteral \" or \' expected\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        44 => {
            errmsg =
                b"Unfinished System or Public ID \" or \' expected\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        62 => {
            errmsg =
                b"Sequence \']]>\' not allowed in content\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        70 => {
            errmsg =
                b"SYSTEM or PUBLIC, the URI is missing\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        71 => {
            errmsg =
                b"PUBLIC, the Public Identifier is missing\x00" as *const u8
                    as *const std::os::raw::c_char
        }
        80 => {
            errmsg =
                b"Comment must not contain \'--\' (double-hyphen)\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        46 => {
            errmsg =
                b"xmlParsePI : no target name\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        64 => {
            errmsg =
                b"Invalid PI name\x00" as *const u8 as *const std::os::raw::c_char
        }
        48 => {
            errmsg =
                b"NOTATION: Name expected here\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        49 => {
            errmsg =
                b"\'>\' required to close NOTATION declaration\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        84 => {
            errmsg =
                b"Entity value required\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        92 => {
            errmsg =
                b"Fragment not allowed\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        50 => {
            errmsg =
                b"\'(\' required to start ATTLIST enumeration\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        67 => {
            errmsg =
                b"NmToken expected in ATTLIST enumeration\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        51 => {
            errmsg =
                b"\')\' required to finish ATTLIST enumeration\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        52 => {
            errmsg =
                b"MixedContentDecl : \'|\' or \')*\' expected\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        69 => {
            errmsg =
                b"MixedContentDecl : \'#PCDATA\' expected\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        54 => {
            errmsg =
                b"ContentDecl : Name or \'(\' expected\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        55 => {
            errmsg =
                b"ContentDecl : \',\' \'|\' or \')\' expected\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        21 => {
            errmsg =
                b"PEReference: forbidden within markup decl in internal subset\x00"
                    as *const u8 as *const std::os::raw::c_char
        }
        73 => {
            errmsg = b"expected \'>\'\x00" as *const u8 as *const std::os::raw::c_char
        }
        83 => {
            errmsg =
                b"XML conditional section \'[\' expected\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        60 => {
            errmsg =
                b"Content error in the external subset\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        95 => {
            errmsg =
                b"conditional section INCLUDE or IGNORE keyword expected\x00"
                    as *const u8 as *const std::os::raw::c_char
        }
        59 => {
            errmsg =
                b"XML conditional section not closed\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        56 => {
            errmsg =
                b"Text declaration \'<?xml\' required\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        57 => {
            errmsg =
                b"parsing XML declaration: \'?>\' expected\x00" as *const u8
                    as *const std::os::raw::c_char
        }
        82 => {
            errmsg =
                b"external parsed entities cannot be standalone\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        23 => {
            errmsg =
                b"EntityRef: expecting \';\'\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        61 => {
            errmsg =
                b"DOCTYPE improperly terminated\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        74 => {
            errmsg =
                b"EndTag: \'</\' not found\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        75 => {
            errmsg = b"expected \'=\'\x00" as *const u8 as *const std::os::raw::c_char
        }
        34 => {
            errmsg =
                b"String not closed expecting \" or \'\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        33 => {
            errmsg =
                b"String not started expecting \' or \"\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        79 => {
            errmsg =
                b"Invalid XML encoding name\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        78 => {
            errmsg =
                b"standalone accepts only \'yes\' or \'no\'\x00" as *const u8
                    as *const std::os::raw::c_char
        }
        4 => {
            errmsg =
                b"Document is empty\x00" as *const u8 as *const std::os::raw::c_char
        }
        5 => {
            errmsg =
                b"Extra content at the end of the document\x00" as *const u8
                    as *const std::os::raw::c_char
        }
        85 => {
            errmsg =
                b"chunk is not well balanced\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        86 => {
            errmsg =
                b"extra content at the end of well balanced chunk\x00" as
                    *const u8 as *const std::os::raw::c_char
        }
        96 => {
            errmsg =
                b"Malformed declaration expecting version\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        110 => {
            errmsg =
                b"Name too long use XML_PARSE_HUGE option\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
        _ => {
            errmsg =
                b"Unregistered error message\x00" as *const u8 as
                    *const std::os::raw::c_char
        }
    }
    if !ctxt.is_null() { (*ctxt).errNo = error as std::os::raw::c_int }
    if info.is_null() {
        __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_PARSER as std::os::raw::c_int, error as std::os::raw::c_int,
                        XML_ERR_FATAL, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, info, 0 as *const std::os::raw::c_char,
                        0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                        0 as std::os::raw::c_int,
                        b"%s\n\x00" as *const u8 as *const std::os::raw::c_char,
                        errmsg);
    } else {
        __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_PARSER as std::os::raw::c_int, error as std::os::raw::c_int,
                        XML_ERR_FATAL, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, info, 0 as *const std::os::raw::c_char,
                        0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                        0 as std::os::raw::c_int,
                        b"%s: %s\n\x00" as *const u8 as *const std::os::raw::c_char,
                        errmsg, info);
    }
    if !ctxt.is_null() {
        (*ctxt).wellFormed = 0 as std::os::raw::c_int;
        if (*ctxt).recovery == 0 as std::os::raw::c_int {
            (*ctxt).disableSAX = 1 as std::os::raw::c_int
        }
    };
}
/* *
 * xmlFatalErrMsg:
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @msg:  the error message
 *
 * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 */
unsafe extern "C" fn xmlFatalErrMsg(mut ctxt: xmlParserCtxtPtr,
                                    mut error: xmlParserErrors,
                                    mut msg: *const std::os::raw::c_char) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() { (*ctxt).errNo = error as std::os::raw::c_int }
    __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                    ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                    XML_FROM_PARSER as std::os::raw::c_int, error as std::os::raw::c_int,
                    XML_ERR_FATAL, 0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                    0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as std::os::raw::c_int,
                    b"%s\x00" as *const u8 as *const std::os::raw::c_char, msg);
    if !ctxt.is_null() {
        (*ctxt).wellFormed = 0 as std::os::raw::c_int;
        if (*ctxt).recovery == 0 as std::os::raw::c_int {
            (*ctxt).disableSAX = 1 as std::os::raw::c_int
        }
    };
}
/* *
 * xmlWarningMsg:
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @msg:  the error message
 * @str1:  extra data
 * @str2:  extra data
 *
 * Handle a warning.
 */
unsafe extern "C" fn xmlWarningMsg(mut ctxt: xmlParserCtxtPtr,
                                   mut error: xmlParserErrors,
                                   mut msg: *const std::os::raw::c_char,
                                   mut str1: *const xmlChar,
                                   mut str2: *const xmlChar) {
    let mut schannel: xmlStructuredErrorFunc = None;
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() && !(*ctxt).sax.is_null() &&
           (*(*ctxt).sax).initialized == 0xdeedbeaf as std::os::raw::c_uint {
        schannel = (*(*ctxt).sax).serror
    }
    if !ctxt.is_null() {
        __xmlRaiseError(schannel,
                        if !(*ctxt).sax.is_null() {
                            (*(*ctxt).sax).warning
                        } else { None }, (*ctxt).userData,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_PARSER as std::os::raw::c_int, error as std::os::raw::c_int,
                        XML_ERR_WARNING, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, str1 as *const std::os::raw::c_char,
                        str2 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, 0 as std::os::raw::c_int, msg,
                        str1 as *const std::os::raw::c_char,
                        str2 as *const std::os::raw::c_char);
    } else {
        __xmlRaiseError(schannel, None, 0 as *mut std::os::raw::c_void,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_PARSER as std::os::raw::c_int, error as std::os::raw::c_int,
                        XML_ERR_WARNING, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, str1 as *const std::os::raw::c_char,
                        str2 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, 0 as std::os::raw::c_int, msg,
                        str1 as *const std::os::raw::c_char,
                        str2 as *const std::os::raw::c_char);
    };
}
/* *
 * xmlValidityError:
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @msg:  the error message
 * @str1:  extra data
 *
 * Handle a validity error.
 */
unsafe extern "C" fn xmlValidityError(mut ctxt: xmlParserCtxtPtr,
                                      mut error: xmlParserErrors,
                                      mut msg: *const std::os::raw::c_char,
                                      mut str1: *const xmlChar,
                                      mut str2: *const xmlChar) {
    let mut schannel: xmlStructuredErrorFunc = None;
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() {
        (*ctxt).errNo = error as std::os::raw::c_int;
        if !(*ctxt).sax.is_null() &&
               (*(*ctxt).sax).initialized == 0xdeedbeaf as std::os::raw::c_uint {
            schannel = (*(*ctxt).sax).serror
        }
    }
    if !ctxt.is_null() {
        __xmlRaiseError(schannel, (*ctxt).vctxt.error, (*ctxt).vctxt.userData,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_DTD as std::os::raw::c_int, error as std::os::raw::c_int,
                        XML_ERR_ERROR, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, str1 as *const std::os::raw::c_char,
                        str2 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, 0 as std::os::raw::c_int, msg,
                        str1 as *const std::os::raw::c_char,
                        str2 as *const std::os::raw::c_char);
        (*ctxt).valid = 0 as std::os::raw::c_int
    } else {
        __xmlRaiseError(schannel, None, 0 as *mut std::os::raw::c_void,
                        ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                        XML_FROM_DTD as std::os::raw::c_int, error as std::os::raw::c_int,
                        XML_ERR_ERROR, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, str1 as *const std::os::raw::c_char,
                        str2 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                        0 as std::os::raw::c_int, 0 as std::os::raw::c_int, msg,
                        str1 as *const std::os::raw::c_char,
                        str2 as *const std::os::raw::c_char);
    };
}
/* *
 * xmlFatalErrMsgInt:
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @msg:  the error message
 * @val:  an integer value
 *
 * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 */
unsafe extern "C" fn xmlFatalErrMsgInt(mut ctxt: xmlParserCtxtPtr,
                                       mut error: xmlParserErrors,
                                       mut msg: *const std::os::raw::c_char,
                                       mut val: std::os::raw::c_int) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() { (*ctxt).errNo = error as std::os::raw::c_int }
    __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                    ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                    XML_FROM_PARSER as std::os::raw::c_int, error as std::os::raw::c_int,
                    XML_ERR_FATAL, 0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                    0 as *const std::os::raw::c_char, val, 0 as std::os::raw::c_int, msg,
                    val);
    if !ctxt.is_null() {
        (*ctxt).wellFormed = 0 as std::os::raw::c_int;
        if (*ctxt).recovery == 0 as std::os::raw::c_int {
            (*ctxt).disableSAX = 1 as std::os::raw::c_int
        }
    };
}
/* *
 * xmlFatalErrMsgStrIntStr:
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @msg:  the error message
 * @str1:  an string info
 * @val:  an integer value
 * @str2:  an string info
 *
 * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 */
unsafe extern "C" fn xmlFatalErrMsgStrIntStr(mut ctxt: xmlParserCtxtPtr,
                                             mut error: xmlParserErrors,
                                             mut msg: *const std::os::raw::c_char,
                                             mut str1: *const xmlChar,
                                             mut val: std::os::raw::c_int,
                                             mut str2: *const xmlChar) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() { (*ctxt).errNo = error as std::os::raw::c_int }
    __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                    ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                    XML_FROM_PARSER as std::os::raw::c_int, error as std::os::raw::c_int,
                    XML_ERR_FATAL, 0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    str1 as *const std::os::raw::c_char, str2 as *const std::os::raw::c_char,
                    0 as *const std::os::raw::c_char, val, 0 as std::os::raw::c_int, msg,
                    str1, val, str2);
    if !ctxt.is_null() {
        (*ctxt).wellFormed = 0 as std::os::raw::c_int;
        if (*ctxt).recovery == 0 as std::os::raw::c_int {
            (*ctxt).disableSAX = 1 as std::os::raw::c_int
        }
    };
}
/* *
 * xmlFatalErrMsgStr:
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @msg:  the error message
 * @val:  a string value
 *
 * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 */
unsafe extern "C" fn xmlFatalErrMsgStr(mut ctxt: xmlParserCtxtPtr,
                                       mut error: xmlParserErrors,
                                       mut msg: *const std::os::raw::c_char,
                                       mut val: *const xmlChar) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() { (*ctxt).errNo = error as std::os::raw::c_int }
    __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                    ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                    XML_FROM_PARSER as std::os::raw::c_int, error as std::os::raw::c_int,
                    XML_ERR_FATAL, 0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    val as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                    0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as std::os::raw::c_int, msg, val);
    if !ctxt.is_null() {
        (*ctxt).wellFormed = 0 as std::os::raw::c_int;
        if (*ctxt).recovery == 0 as std::os::raw::c_int {
            (*ctxt).disableSAX = 1 as std::os::raw::c_int
        }
    };
}
/* *
 * xmlErrMsgStr:
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @msg:  the error message
 * @val:  a string value
 *
 * Handle a non fatal parser error
 */
unsafe extern "C" fn xmlErrMsgStr(mut ctxt: xmlParserCtxtPtr,
                                  mut error: xmlParserErrors,
                                  mut msg: *const std::os::raw::c_char,
                                  mut val: *const xmlChar) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() { (*ctxt).errNo = error as std::os::raw::c_int }
    __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                    ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                    XML_FROM_PARSER as std::os::raw::c_int, error as std::os::raw::c_int,
                    XML_ERR_ERROR, 0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    val as *const std::os::raw::c_char, 0 as *const std::os::raw::c_char,
                    0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as std::os::raw::c_int, msg, val);
}
/* *
 * xmlNsErr:
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @msg:  the message
 * @info1:  extra information string
 * @info2:  extra information string
 *
 * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 */
unsafe extern "C" fn xmlNsErr(mut ctxt: xmlParserCtxtPtr,
                              mut error: xmlParserErrors,
                              mut msg: *const std::os::raw::c_char,
                              mut info1: *const xmlChar,
                              mut info2: *const xmlChar,
                              mut info3: *const xmlChar) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !ctxt.is_null() { (*ctxt).errNo = error as std::os::raw::c_int }
    __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                    ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                    XML_FROM_NAMESPACE as std::os::raw::c_int, error as std::os::raw::c_int,
                    XML_ERR_ERROR, 0 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    info1 as *const std::os::raw::c_char,
                    info2 as *const std::os::raw::c_char,
                    info3 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as std::os::raw::c_int, msg, info1, info2, info3);
    if !ctxt.is_null() { (*ctxt).nsWellFormed = 0 as std::os::raw::c_int };
}
/* *
 * xmlNsWarn
 * @ctxt:  an XML parser context
 * @error:  the error number
 * @msg:  the message
 * @info1:  extra information string
 * @info2:  extra information string
 *
 * Handle a namespace warning error
 */
unsafe extern "C" fn xmlNsWarn(mut ctxt: xmlParserCtxtPtr,
                               mut error: xmlParserErrors,
                               mut msg: *const std::os::raw::c_char,
                               mut info1: *const xmlChar,
                               mut info2: *const xmlChar,
                               mut info3: *const xmlChar) {
    if !ctxt.is_null() && (*ctxt).disableSAX != 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    __xmlRaiseError(None, None, 0 as *mut std::os::raw::c_void,
                    ctxt as *mut std::os::raw::c_void, 0 as *mut std::os::raw::c_void,
                    XML_FROM_NAMESPACE as std::os::raw::c_int, error as std::os::raw::c_int,
                    XML_ERR_WARNING, 0 as *const std::os::raw::c_char,
                    0 as std::os::raw::c_int, info1 as *const std::os::raw::c_char,
                    info2 as *const std::os::raw::c_char,
                    info3 as *const std::os::raw::c_char, 0 as std::os::raw::c_int,
                    0 as std::os::raw::c_int, msg, info1, info2, info3);
}
/*
 * Library wide options
 */
/* *
 * xmlFeature:
 *
 * Used to examine the existance of features that can be enabled
 * or disabled at compile-time.
 * They used to be called XML_FEATURE_xxx but this clashed with Expat
 */
/* just to be sure of allocation size */
/* ***********************************************************************
 *									*
 *		Library wide options					*
 *									*
 ************************************************************************/
/* *
  * xmlHasFeature:
  * @feature: the feature to be examined
  *
  * Examines if the library has been compiled with a given feature.
  *
  * Returns a non-zero value if the feature exist, otherwise zero.
  * Returns zero (0) if the feature does not exist or an unknown
  * unknown feature is requested, non-zero otherwise.
  */
#[no_mangle]
pub unsafe extern "C" fn xmlHasFeature(mut feature: xmlFeature)
 -> std::os::raw::c_int {
    match feature as std::os::raw::c_uint {
        1 => { return 1 as std::os::raw::c_int }
        2 => { return 1 as std::os::raw::c_int }
        3 => { return 1 as std::os::raw::c_int }
        4 => { return 1 as std::os::raw::c_int }
        5 => { return 1 as std::os::raw::c_int }
        6 => { return 1 as std::os::raw::c_int }
        7 => { return 1 as std::os::raw::c_int }
        8 => { return 1 as std::os::raw::c_int }
        9 => { return 1 as std::os::raw::c_int }
        10 => { return 1 as std::os::raw::c_int }
        11 => { return 1 as std::os::raw::c_int }
        12 => { return 1 as std::os::raw::c_int }
        13 => { return 1 as std::os::raw::c_int }
        14 => { return 1 as std::os::raw::c_int }
        15 => { return 1 as std::os::raw::c_int }
        16 => { return 1 as std::os::raw::c_int }
        17 => { return 1 as std::os::raw::c_int }
        18 => { return 1 as std::os::raw::c_int }
        19 => { return 1 as std::os::raw::c_int }
        20 => { return 1 as std::os::raw::c_int }
        21 => { return 1 as std::os::raw::c_int }
        22 => { return 1 as std::os::raw::c_int }
        23 => { return 1 as std::os::raw::c_int }
        24 => { return 1 as std::os::raw::c_int }
        25 => { return 1 as std::os::raw::c_int }
        26 => { return 1 as std::os::raw::c_int }
        27 => { return 1 as std::os::raw::c_int }
        28 => { return 1 as std::os::raw::c_int }
        29 => { return 0 as std::os::raw::c_int }
        30 => { return 0 as std::os::raw::c_int }
        31 => { return 1 as std::os::raw::c_int }
        33 => { return 1 as std::os::raw::c_int }
        32 => { return 0 as std::os::raw::c_int }
        _ => { }
    }
    return 0 as std::os::raw::c_int;
}
/* ***********************************************************************
 *									*
 *		SAX2 defaulted attributes handling			*
 *									*
 ************************************************************************/
/* *
 * xmlDetectSAX2:
 * @ctxt:  an XML parser context
 *
 * Do the SAX2 detection and specific intialization
 */
unsafe extern "C" fn xmlDetectSAX2(mut ctxt: xmlParserCtxtPtr) {
    if ctxt.is_null() { return }
    if !(*ctxt).sax.is_null() &&
           (*(*ctxt).sax).initialized == 0xdeedbeaf as std::os::raw::c_uint &&
           ((*(*ctxt).sax).startElementNs.is_some() ||
                (*(*ctxt).sax).endElementNs.is_some()) {
        (*ctxt).sax2 = 1 as std::os::raw::c_int
    }
    /* LIBXML_SAX1_ENABLED */
    (*ctxt).str_xml =
        xmlDictLookup((*ctxt).dict,
                      b"xml\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 3 as std::os::raw::c_int);
    (*ctxt).str_xmlns =
        xmlDictLookup((*ctxt).dict,
                      b"xmlns\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 5 as std::os::raw::c_int);
    (*ctxt).str_xml_ns =
        xmlDictLookup((*ctxt).dict,
                      b"http://www.w3.org/XML/1998/namespace\x00" as *const u8
                          as *const std::os::raw::c_char as *const xmlChar,
                      36 as std::os::raw::c_int);
    if (*ctxt).str_xml.is_null() || (*ctxt).str_xmlns.is_null() ||
           (*ctxt).str_xml_ns.is_null() {
        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
    };
}
/* array of localname/prefix/values/external */
/* *
 * xmlAttrNormalizeSpace:
 * @src: the source string
 * @dst: the target string
 *
 * Normalize the space in non CDATA attribute values:
 * If the attribute type is not CDATA, then the XML processor MUST further
 * process the normalized attribute value by discarding any leading and
 * trailing space (#x20) characters, and by replacing sequences of space
 * (#x20) characters by a single space (#x20) character.
 * Note that the size of dst need to be at least src, and if one doesn't need
 * to preserve dst (and it doesn't come from a dictionary or read-only) then
 * passing src as dst is just fine.
 *
 * Returns a pointer to the normalized value (dst) or NULL if no conversion
 *         is needed.
 */
unsafe extern "C" fn xmlAttrNormalizeSpace(mut src: *const xmlChar,
                                           mut dst: *mut xmlChar)
 -> *mut xmlChar {
    if src.is_null() || dst.is_null() { return 0 as *mut xmlChar }
    while *src as std::os::raw::c_int == 0x20 as std::os::raw::c_int { src = src.offset(1) }
    while *src as std::os::raw::c_int != 0 as std::os::raw::c_int {
        if *src as std::os::raw::c_int == 0x20 as std::os::raw::c_int {
            while *src as std::os::raw::c_int == 0x20 as std::os::raw::c_int {
                src = src.offset(1)
            }
            if *src as std::os::raw::c_int != 0 as std::os::raw::c_int {
                let fresh0 = dst;
                dst = dst.offset(1);
                *fresh0 = 0x20 as std::os::raw::c_int as xmlChar
            }
        } else {
            let fresh1 = src;
            src = src.offset(1);
            let fresh2 = dst;
            dst = dst.offset(1);
            *fresh2 = *fresh1
        }
    }
    *dst = 0 as std::os::raw::c_int as xmlChar;
    if dst == src as *mut xmlChar { return 0 as *mut xmlChar }
    return dst;
}
/* *
 * xmlAttrNormalizeSpace2:
 * @src: the source string
 *
 * Normalize the space in non CDATA attribute values, a slightly more complex
 * front end to avoid allocation problems when running on attribute values
 * coming from the input.
 *
 * Returns a pointer to the normalized value (dst) or NULL if no conversion
 *         is needed.
 */
unsafe extern "C" fn xmlAttrNormalizeSpace2(mut ctxt: xmlParserCtxtPtr,
                                            mut src: *mut xmlChar,
                                            mut len: *mut std::os::raw::c_int)
 -> *const xmlChar {
    let mut i: std::os::raw::c_int = 0;
    let mut remove_head: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut need_realloc: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || src.is_null() || len.is_null() {
        return 0 as *const xmlChar
    }
    i = *len;
    if i <= 0 as std::os::raw::c_int { return 0 as *const xmlChar }
    cur = src;
    while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int {
        cur = cur.offset(1);
        remove_head += 1
    }
    while *cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
        if *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int {
            cur = cur.offset(1);
            if !(*cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                     *cur as std::os::raw::c_int == 0 as std::os::raw::c_int) {
                continue ;
            }
            need_realloc = 1 as std::os::raw::c_int;
            break ;
        } else { cur = cur.offset(1) }
    }
    if need_realloc != 0 {
        let mut ret: *mut xmlChar = 0 as *mut xmlChar;
        ret =
            xmlStrndup(src.offset(remove_head as isize),
                       i - remove_head + 1 as std::os::raw::c_int);
        if ret.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return 0 as *const xmlChar
        }
        xmlAttrNormalizeSpace(ret, ret);
        *len = strlen(ret as *const std::os::raw::c_char) as std::os::raw::c_int;
        return ret
    } else {
        if remove_head != 0 {
            *len -= remove_head;
            memmove(src as *mut std::os::raw::c_void,
                    src.offset(remove_head as isize) as *const std::os::raw::c_void,
                    (1 as std::os::raw::c_int + *len) as std::os::raw::c_ulong);
            return src
        }
    }
    return 0 as *const xmlChar;
}
/* *
 * xmlAddDefAttrs:
 * @ctxt:  an XML parser context
 * @fullname:  the element fullname
 * @fullattr:  the attribute fullname
 * @value:  the attribute value
 *
 * Add a defaulted attribute for an element
 */
unsafe extern "C" fn xmlAddDefAttrs(mut ctxt: xmlParserCtxtPtr,
                                    mut fullname: *const xmlChar,
                                    mut fullattr: *const xmlChar,
                                    mut value: *const xmlChar) {
    let mut current_block: u64;
    let mut defaults: xmlDefAttrsPtr = 0 as *mut xmlDefAttrs;
    let mut len: std::os::raw::c_int = 0;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut prefix: *const xmlChar = 0 as *const xmlChar;
    /*
     * Allows to detect attribute redefinitions
     */
    if !(*ctxt).attsSpecial.is_null() {
        if !xmlHashLookup2((*ctxt).attsSpecial, fullname, fullattr).is_null()
           {
            return
        }
    }
    if (*ctxt).attsDefault.is_null() {
        (*ctxt).attsDefault =
            xmlHashCreateDict(10 as std::os::raw::c_int, (*ctxt).dict);
        if (*ctxt).attsDefault.is_null() {
            current_block = 8913170727056527099;
        } else { current_block = 13183875560443969876; }
    } else { current_block = 13183875560443969876; }
    match current_block {
        13183875560443969876 => {
            /*
     * split the element name into prefix:localname , the string found
     * are within the DTD and then not associated to namespace names.
     */
            name = xmlSplitQName3(fullname, &mut len);
            if name.is_null() {
                name =
                    xmlDictLookup((*ctxt).dict, fullname,
                                  -(1 as std::os::raw::c_int));
                prefix = 0 as *const xmlChar
            } else {
                name = xmlDictLookup((*ctxt).dict, name, -(1 as std::os::raw::c_int));
                prefix = xmlDictLookup((*ctxt).dict, fullname, len)
            }
            /*
     * make sure there is some storage
     */
            defaults =
                xmlHashLookup2((*ctxt).attsDefault, name, prefix) as
                    xmlDefAttrsPtr;
            if defaults.is_null() {
                defaults =
                    xmlMalloc.expect("non-null function pointer")((::std::mem::size_of::<xmlDefAttrs>()
                                                                       as
                                                                       std::os::raw::c_ulong).wrapping_add(((4
                                                                                                         as
                                                                                                         std::os::raw::c_int
                                                                                                         *
                                                                                                         5
                                                                                                             as
                                                                                                             std::os::raw::c_int)
                                                                                                        as
                                                                                                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                                                        as
                                                                                                                                        std::os::raw::c_ulong)))
                        as xmlDefAttrsPtr;
                if defaults.is_null() {
                    current_block = 8913170727056527099;
                } else {
                    (*defaults).nbAttrs = 0 as std::os::raw::c_int;
                    (*defaults).maxAttrs = 4 as std::os::raw::c_int;
                    if xmlHashUpdateEntry2((*ctxt).attsDefault, name, prefix,
                                           defaults as *mut std::os::raw::c_void,
                                           None) < 0 as std::os::raw::c_int {
                        xmlFree.expect("non-null function pointer")(defaults
                                                                        as
                                                                        *mut std::os::raw::c_void);
                        current_block = 8913170727056527099;
                    } else { current_block = 8704759739624374314; }
                }
            } else if (*defaults).nbAttrs >= (*defaults).maxAttrs {
                let mut temp: xmlDefAttrsPtr = 0 as *mut xmlDefAttrs;
                temp =
                    xmlRealloc.expect("non-null function pointer")(defaults as
                                                                       *mut std::os::raw::c_void,
                                                                   (::std::mem::size_of::<xmlDefAttrs>()
                                                                        as
                                                                        std::os::raw::c_ulong).wrapping_add(((2
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          *
                                                                                                          (*defaults).maxAttrs
                                                                                                          *
                                                                                                          5
                                                                                                              as
                                                                                                              std::os::raw::c_int)
                                                                                                         as
                                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                                                         as
                                                                                                                                         std::os::raw::c_ulong)))
                        as xmlDefAttrsPtr;
                if temp.is_null() {
                    current_block = 8913170727056527099;
                } else {
                    defaults = temp;
                    (*defaults).maxAttrs *= 2 as std::os::raw::c_int;
                    if xmlHashUpdateEntry2((*ctxt).attsDefault, name, prefix,
                                           defaults as *mut std::os::raw::c_void,
                                           None) < 0 as std::os::raw::c_int {
                        xmlFree.expect("non-null function pointer")(defaults
                                                                        as
                                                                        *mut std::os::raw::c_void);
                        current_block = 8913170727056527099;
                    } else { current_block = 8704759739624374314; }
                }
            } else { current_block = 8704759739624374314; }
            match current_block {
                8913170727056527099 => { }
                _ => {
                    /*
     * Split the element name into prefix:localname , the string found
     * are within the DTD and hen not associated to namespace names.
     */
                    name = xmlSplitQName3(fullattr, &mut len);
                    if name.is_null() {
                        name =
                            xmlDictLookup((*ctxt).dict, fullattr,
                                          -(1 as std::os::raw::c_int));
                        prefix = 0 as *const xmlChar
                    } else {
                        name =
                            xmlDictLookup((*ctxt).dict, name,
                                          -(1 as std::os::raw::c_int));
                        prefix = xmlDictLookup((*ctxt).dict, fullattr, len)
                    }
                    let ref mut fresh3 =
                        *(*defaults).values.as_mut_ptr().offset((5 as
                                                                     std::os::raw::c_int
                                                                     *
                                                                     (*defaults).nbAttrs)
                                                                    as isize);
                    *fresh3 = name;
                    let ref mut fresh4 =
                        *(*defaults).values.as_mut_ptr().offset((5 as
                                                                     std::os::raw::c_int
                                                                     *
                                                                     (*defaults).nbAttrs
                                                                     +
                                                                     1 as
                                                                         std::os::raw::c_int)
                                                                    as isize);
                    *fresh4 = prefix;
                    /* intern the string and precompute the end */
                    len = xmlStrlen(value);
                    value = xmlDictLookup((*ctxt).dict, value, len);
                    let ref mut fresh5 =
                        *(*defaults).values.as_mut_ptr().offset((5 as
                                                                     std::os::raw::c_int
                                                                     *
                                                                     (*defaults).nbAttrs
                                                                     +
                                                                     2 as
                                                                         std::os::raw::c_int)
                                                                    as isize);
                    *fresh5 = value;
                    let ref mut fresh6 =
                        *(*defaults).values.as_mut_ptr().offset((5 as
                                                                     std::os::raw::c_int
                                                                     *
                                                                     (*defaults).nbAttrs
                                                                     +
                                                                     3 as
                                                                         std::os::raw::c_int)
                                                                    as isize);
                    *fresh6 = value.offset(len as isize);
                    if (*ctxt).external != 0 {
                        let ref mut fresh7 =
                            *(*defaults).values.as_mut_ptr().offset((5 as
                                                                         std::os::raw::c_int
                                                                         *
                                                                         (*defaults).nbAttrs
                                                                         +
                                                                         4 as
                                                                             std::os::raw::c_int)
                                                                        as
                                                                        isize);
                        *fresh7 =
                            b"external\x00" as *const u8 as
                                *const std::os::raw::c_char as *mut xmlChar
                    } else {
                        let ref mut fresh8 =
                            *(*defaults).values.as_mut_ptr().offset((5 as
                                                                         std::os::raw::c_int
                                                                         *
                                                                         (*defaults).nbAttrs
                                                                         +
                                                                         4 as
                                                                             std::os::raw::c_int)
                                                                        as
                                                                        isize);
                        *fresh8 = 0 as *const xmlChar
                    }
                    (*defaults).nbAttrs += 1;
                    return
                }
            }
        }
        _ => { }
    }
    xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
}
/* *
 * xmlAddSpecialAttr:
 * @ctxt:  an XML parser context
 * @fullname:  the element fullname
 * @fullattr:  the attribute fullname
 * @type:  the attribute type
 *
 * Register this attribute type
 */
unsafe extern "C" fn xmlAddSpecialAttr(mut ctxt: xmlParserCtxtPtr,
                                       mut fullname: *const xmlChar,
                                       mut fullattr: *const xmlChar,
                                       mut type_0: std::os::raw::c_int) {
    if (*ctxt).attsSpecial.is_null() {
        (*ctxt).attsSpecial =
            xmlHashCreateDict(10 as std::os::raw::c_int, (*ctxt).dict);
        if (*ctxt).attsSpecial.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return
        }
    }
    if !xmlHashLookup2((*ctxt).attsSpecial, fullname, fullattr).is_null() {
        return
    }
    xmlHashAddEntry2((*ctxt).attsSpecial, fullname, fullattr,
                     type_0 as ptrdiff_t as *mut std::os::raw::c_void);
}
/* *
 * xmlCleanSpecialAttrCallback:
 *
 * Removes CDATA attributes from the special attribute table
 */
unsafe extern "C" fn xmlCleanSpecialAttrCallback(mut payload:
                                                     *mut std::os::raw::c_void,
                                                 mut data: *mut std::os::raw::c_void,
                                                 mut fullname: *const xmlChar,
                                                 mut fullattr: *const xmlChar,
                                                 mut unused: *const xmlChar) {
    let mut ctxt: xmlParserCtxtPtr = data as xmlParserCtxtPtr;
    if payload as ptrdiff_t ==
           XML_ATTRIBUTE_CDATA as std::os::raw::c_int as std::os::raw::c_long {
        xmlHashRemoveEntry2((*ctxt).attsSpecial, fullname, fullattr, None);
    };
}
/* *
 * xmlCleanSpecialAttr:
 * @ctxt:  an XML parser context
 *
 * Trim the list of attributes defined to remove all those of type
 * CDATA as they are not special. This call should be done when finishing
 * to parse the DTD and before starting to parse the document root.
 */
unsafe extern "C" fn xmlCleanSpecialAttr(mut ctxt: xmlParserCtxtPtr) {
    if (*ctxt).attsSpecial.is_null() { return }
    xmlHashScanFull((*ctxt).attsSpecial,
                    Some(xmlCleanSpecialAttrCallback as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *mut std::os::raw::c_void,
                                                  _: *const xmlChar,
                                                  _: *const xmlChar,
                                                  _: *const xmlChar) -> ()),
                    ctxt as *mut std::os::raw::c_void);
    if xmlHashSize((*ctxt).attsSpecial) == 0 as std::os::raw::c_int {
        xmlHashFree((*ctxt).attsSpecial, None);
        (*ctxt).attsSpecial = 0 as xmlHashTablePtr
    };
}
/* *
 * xmlCheckLanguageID:
 * @lang:  pointer to the string value
 *
 * Checks that the value conforms to the LanguageID production:
 *
 * NOTE: this is somewhat deprecated, those productions were removed from
 *       the XML Second edition.
 *
 * [33] LanguageID ::= Langcode ('-' Subcode)*
 * [34] Langcode ::= ISO639Code |  IanaCode |  UserCode
 * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
 * [36] IanaCode ::= ('i' | 'I') '-' ([a-z] | [A-Z])+
 * [37] UserCode ::= ('x' | 'X') '-' ([a-z] | [A-Z])+
 * [38] Subcode ::= ([a-z] | [A-Z])+
 *
 * The current REC reference the sucessors of RFC 1766, currently 5646
 *
 * http://www.rfc-editor.org/rfc/rfc5646.txt
 * langtag       = language
 *                 ["-" script]
 *                 ["-" region]
 *                 *("-" variant)
 *                 *("-" extension)
 *                 ["-" privateuse]
 * language      = 2*3ALPHA            ; shortest ISO 639 code
 *                 ["-" extlang]       ; sometimes followed by
 *                                     ; extended language subtags
 *               / 4ALPHA              ; or reserved for future use
 *               / 5*8ALPHA            ; or registered language subtag
 *
 * extlang       = 3ALPHA              ; selected ISO 639 codes
 *                 *2("-" 3ALPHA)      ; permanently reserved
 *
 * script        = 4ALPHA              ; ISO 15924 code
 *
 * region        = 2ALPHA              ; ISO 3166-1 code
 *               / 3DIGIT              ; UN M.49 code
 *
 * variant       = 5*8alphanum         ; registered variants
 *               / (DIGIT 3alphanum)
 *
 * extension     = singleton 1*("-" (2*8alphanum))
 *
 *                                     ; Single alphanumerics
 *                                     ; "x" reserved for private use
 * singleton     = DIGIT               ; 0 - 9
 *               / %x41-57             ; A - W
 *               / %x59-5A             ; Y - Z
 *               / %x61-77             ; a - w
 *               / %x79-7A             ; y - z
 *
 * it sounds right to still allow Irregular i-xxx IANA and user codes too
 * The parser below doesn't try to cope with extension or privateuse
 * that could be added but that's not interoperable anyway
 *
 * Returns 1 if correct 0 otherwise
 **/
#[no_mangle]
pub unsafe extern "C" fn xmlCheckLanguageID(mut lang: *const xmlChar)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut cur: *const xmlChar = lang;
    let mut nxt: *const xmlChar = 0 as *const xmlChar;
    if cur.is_null() { return 0 as std::os::raw::c_int }
    if *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int == 'i' as i32 &&
           *cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int == '-' as i32
           ||
           *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int == 'I' as i32
               &&
               *cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   '-' as i32 ||
           *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int == 'x' as i32
               &&
               *cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   '-' as i32 ||
           *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int == 'X' as i32
               &&
               *cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   '-' as i32 {
        /*
         * Still allow IANA code and user code which were coming
         * from the previous version of the XML-1.0 specification
         * it's deprecated but we should not fail
         */
        cur = cur.offset(2 as std::os::raw::c_int as isize);
        while *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                  'A' as i32 &&
                  *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int <=
                      'Z' as i32 ||
                  *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                      'a' as i32 &&
                      *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int <=
                          'z' as i32 {
            cur = cur.offset(1)
        }
        return (*cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                    0 as std::os::raw::c_int) as std::os::raw::c_int
    }
    nxt = cur;
    while *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >= 'A' as i32
              &&
              *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int <=
                  'Z' as i32 ||
              *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                  'a' as i32 &&
                  *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int <=
                      'z' as i32 {
        nxt = nxt.offset(1)
    }
    if nxt.offset_from(cur) as std::os::raw::c_long >=
           4 as std::os::raw::c_int as std::os::raw::c_long {
        /*
         * Reserved
         */
        if nxt.offset_from(cur) as std::os::raw::c_long >
               8 as std::os::raw::c_int as std::os::raw::c_long ||
               *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int !=
                   0 as std::os::raw::c_int {
            return 0 as std::os::raw::c_int
        }
        return 1 as std::os::raw::c_int
    }
    if (nxt.offset_from(cur) as std::os::raw::c_long) <
           2 as std::os::raw::c_int as std::os::raw::c_long {
        return 0 as std::os::raw::c_int
    }
    /* we got an ISO 639 code */
    if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
           0 as std::os::raw::c_int {
        return 1 as std::os::raw::c_int
    }
    if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int != '-' as i32 {
        return 0 as std::os::raw::c_int
    }
    nxt = nxt.offset(1);
    cur = nxt;
    /* now we can have extlang or script or region or variant */
    if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >= '0' as i32 &&
           *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int <= '9' as i32
       {
        current_block = 16545350769449265140;
    } else {
        while *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                  'A' as i32 &&
                  *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int <=
                      'Z' as i32 ||
                  *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                      'a' as i32 &&
                      *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int <=
                          'z' as i32 {
            nxt = nxt.offset(1)
        }
        if nxt.offset_from(cur) as std::os::raw::c_long ==
               4 as std::os::raw::c_int as std::os::raw::c_long {
            current_block = 9637529796965098983;
        } else if nxt.offset_from(cur) as std::os::raw::c_long ==
                      2 as std::os::raw::c_int as std::os::raw::c_long {
            current_block = 8199875053829678852;
        } else if nxt.offset_from(cur) as std::os::raw::c_long >=
                      5 as std::os::raw::c_int as std::os::raw::c_long &&
                      nxt.offset_from(cur) as std::os::raw::c_long <=
                          8 as std::os::raw::c_int as std::os::raw::c_long {
            current_block = 1501332398718169482;
        } else {
            if nxt.offset_from(cur) as std::os::raw::c_long !=
                   3 as std::os::raw::c_int as std::os::raw::c_long {
                return 0 as std::os::raw::c_int
            }
            /* we parsed an extlang */
            if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
                return 1 as std::os::raw::c_int
            }
            if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int !=
                   '-' as i32 {
                return 0 as std::os::raw::c_int
            }
            nxt = nxt.offset(1);
            cur = nxt;
            /* now we can have script or region or variant */
            if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                   '0' as i32 &&
                   *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int <=
                       '9' as i32 {
                current_block = 16545350769449265140;
            } else {
                while *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                          'A' as i32 &&
                          *nxt.offset(0 as std::os::raw::c_int as isize) as
                              std::os::raw::c_int <= 'Z' as i32 ||
                          *nxt.offset(0 as std::os::raw::c_int as isize) as
                              std::os::raw::c_int >= 'a' as i32 &&
                              *nxt.offset(0 as std::os::raw::c_int as isize) as
                                  std::os::raw::c_int <= 'z' as i32 {
                    nxt = nxt.offset(1)
                }
                if nxt.offset_from(cur) as std::os::raw::c_long ==
                       2 as std::os::raw::c_int as std::os::raw::c_long {
                    current_block = 8199875053829678852;
                } else if nxt.offset_from(cur) as std::os::raw::c_long >=
                              5 as std::os::raw::c_int as std::os::raw::c_long &&
                              nxt.offset_from(cur) as std::os::raw::c_long <=
                                  8 as std::os::raw::c_int as std::os::raw::c_long {
                    current_block = 1501332398718169482;
                } else {
                    if nxt.offset_from(cur) as std::os::raw::c_long !=
                           4 as std::os::raw::c_int as std::os::raw::c_long {
                        return 0 as std::os::raw::c_int
                    }
                    current_block = 9637529796965098983;
                }
            }
        }
        match current_block {
            8199875053829678852 => { }
            1501332398718169482 => { }
            16545350769449265140 => { }
            _ =>
            /* we parsed a script */
            {
                if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                    return 1 as std::os::raw::c_int
                }
                if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int !=
                       '-' as i32 {
                    return 0 as std::os::raw::c_int
                }
                nxt = nxt.offset(1);
                cur = nxt;
                /* now we can have region or variant */
                if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                       '0' as i32 &&
                       *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int
                           <= '9' as i32 {
                    current_block = 16545350769449265140;
                } else {
                    while *nxt.offset(0 as std::os::raw::c_int as isize) as
                              std::os::raw::c_int >= 'A' as i32 &&
                              *nxt.offset(0 as std::os::raw::c_int as isize) as
                                  std::os::raw::c_int <= 'Z' as i32 ||
                              *nxt.offset(0 as std::os::raw::c_int as isize) as
                                  std::os::raw::c_int >= 'a' as i32 &&
                                  *nxt.offset(0 as std::os::raw::c_int as isize) as
                                      std::os::raw::c_int <= 'z' as i32 {
                        nxt = nxt.offset(1)
                    }
                    if nxt.offset_from(cur) as std::os::raw::c_long >=
                           5 as std::os::raw::c_int as std::os::raw::c_long &&
                           nxt.offset_from(cur) as std::os::raw::c_long <=
                               8 as std::os::raw::c_int as std::os::raw::c_long {
                        current_block = 1501332398718169482;
                    } else {
                        if nxt.offset_from(cur) as std::os::raw::c_long !=
                               2 as std::os::raw::c_int as std::os::raw::c_long {
                            return 0 as std::os::raw::c_int
                        }
                        current_block = 8199875053829678852;
                    }
                }
            }
        }
    }
    match current_block {
        16545350769449265140 => {
            if *nxt.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                   '0' as i32 &&
                   *nxt.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int <=
                       '9' as i32 &&
                   (*nxt.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                        '0' as i32 &&
                        *nxt.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int
                            <= '9' as i32) {
                nxt = nxt.offset(3 as std::os::raw::c_int as isize)
            } else { return 0 as std::os::raw::c_int }
            current_block = 8199875053829678852;
        }
        _ => { }
    }
    match current_block {
        8199875053829678852 =>
        /* we parsed a region */
        {
            if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
                return 1 as std::os::raw::c_int
            }
            if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int !=
                   '-' as i32 {
                return 0 as std::os::raw::c_int
            }
            nxt = nxt.offset(1);
            cur = nxt;
            /* now we can just have a variant */
            while *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                      'A' as i32 &&
                      *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int <=
                          'Z' as i32 ||
                      *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int >=
                          'a' as i32 &&
                          *nxt.offset(0 as std::os::raw::c_int as isize) as
                              std::os::raw::c_int <= 'z' as i32 {
                nxt = nxt.offset(1)
            }
            if (nxt.offset_from(cur) as std::os::raw::c_long) <
                   5 as std::os::raw::c_int as std::os::raw::c_long ||
                   nxt.offset_from(cur) as std::os::raw::c_long >
                       8 as std::os::raw::c_int as std::os::raw::c_long {
                return 0 as std::os::raw::c_int
            }
        }
        _ => { }
    }
    /* we parsed a variant */
    if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
           0 as std::os::raw::c_int {
        return 1 as std::os::raw::c_int
    }
    if *nxt.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int != '-' as i32 {
        return 0 as std::os::raw::c_int
    }
    /* extensions and private use subtags not checked */
    return 1 as std::os::raw::c_int;
}
/* *
 * nsPush:
 * @ctxt:  an XML parser context
 * @prefix:  the namespace prefix or NULL
 * @URL:  the namespace name
 *
 * Pushes a new parser namespace on top of the ns stack
 *
 * Returns -1 in case of error, -2 if the namespace should be discarded
 *	   and the index in the stack otherwise.
 */
unsafe extern "C" fn nsPush(mut ctxt: xmlParserCtxtPtr,
                            mut prefix: *const xmlChar,
                            mut URL: *const xmlChar) -> std::os::raw::c_int {
    if (*ctxt).options & XML_PARSE_NSCLEAN as std::os::raw::c_int != 0 {
        let mut i: std::os::raw::c_int = 0;
        i = (*ctxt).nsNr - 2 as std::os::raw::c_int;
        while i >= 0 as std::os::raw::c_int {
            if *(*ctxt).nsTab.offset(i as isize) == prefix {
                /* in scope */
                if *(*ctxt).nsTab.offset((i + 1 as std::os::raw::c_int) as isize) ==
                       URL {
                    return -(2 as std::os::raw::c_int)
                }
                break ;
            } else { i -= 2 as std::os::raw::c_int }
        }
    }
    if (*ctxt).nsMax == 0 as std::os::raw::c_int || (*ctxt).nsTab.is_null() {
        (*ctxt).nsMax = 10 as std::os::raw::c_int;
        (*ctxt).nsNr = 0 as std::os::raw::c_int;
        (*ctxt).nsTab =
            xmlMalloc.expect("non-null function pointer")(((*ctxt).nsMax as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlChar>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut *const xmlChar;
        if (*ctxt).nsTab.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            (*ctxt).nsMax = 0 as std::os::raw::c_int;
            return -(1 as std::os::raw::c_int)
        }
    } else if (*ctxt).nsNr >= (*ctxt).nsMax {
        let mut tmp: *mut *const xmlChar = 0 as *mut *const xmlChar;
        (*ctxt).nsMax *= 2 as std::os::raw::c_int;
        tmp =
            xmlRealloc.expect("non-null function pointer")((*ctxt).nsTab as
                                                               *mut std::os::raw::c_char
                                                               as
                                                               *mut std::os::raw::c_void,
                                                           ((*ctxt).nsMax as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut *const xmlChar;
        if tmp.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            (*ctxt).nsMax /= 2 as std::os::raw::c_int;
            return -(1 as std::os::raw::c_int)
        }
        (*ctxt).nsTab = tmp
    }
    let fresh9 = (*ctxt).nsNr;
    (*ctxt).nsNr = (*ctxt).nsNr + 1;
    let ref mut fresh10 = *(*ctxt).nsTab.offset(fresh9 as isize);
    *fresh10 = prefix;
    let fresh11 = (*ctxt).nsNr;
    (*ctxt).nsNr = (*ctxt).nsNr + 1;
    let ref mut fresh12 = *(*ctxt).nsTab.offset(fresh11 as isize);
    *fresh12 = URL;
    return (*ctxt).nsNr;
}
/* *
 * nsPop:
 * @ctxt: an XML parser context
 * @nr:  the number to pop
 *
 * Pops the top @nr parser prefix/namespace from the ns stack
 *
 * Returns the number of namespaces removed
 */
unsafe extern "C" fn nsPop(mut ctxt: xmlParserCtxtPtr, mut nr: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut i: std::os::raw::c_int = 0; /* allow for 10 attrs by default */
    if (*ctxt).nsTab.is_null() { return 0 as std::os::raw::c_int }
    if (*ctxt).nsNr < nr {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Pbm popping %d NS\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   nr);
        nr = (*ctxt).nsNr
    }
    if (*ctxt).nsNr <= 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    i = 0 as std::os::raw::c_int;
    while i < nr {
        (*ctxt).nsNr -= 1;
        let ref mut fresh13 = *(*ctxt).nsTab.offset((*ctxt).nsNr as isize);
        *fresh13 = 0 as *const xmlChar;
        i += 1
    }
    return nr;
}
unsafe extern "C" fn xmlCtxtGrowAttrs(mut ctxt: xmlParserCtxtPtr,
                                      mut nr: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut atts: *mut *const xmlChar = 0 as *mut *const xmlChar;
    let mut attallocs: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
    let mut maxatts: std::os::raw::c_int = 0;
    if (*ctxt).atts.is_null() {
        maxatts = 55 as std::os::raw::c_int;
        atts =
            xmlMalloc.expect("non-null function pointer")((maxatts as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlChar>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut *const xmlChar;
        if atts.is_null() {
            current_block = 4877220181156914653;
        } else {
            (*ctxt).atts = atts;
            attallocs =
                xmlMalloc.expect("non-null function pointer")(((maxatts /
                                                                    5 as
                                                                        std::os::raw::c_int)
                                                                   as
                                                                   std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_int>()
                                                                                                   as
                                                                                                   std::os::raw::c_ulong))
                    as *mut std::os::raw::c_int;
            if attallocs.is_null() {
                current_block = 4877220181156914653;
            } else {
                (*ctxt).attallocs = attallocs;
                (*ctxt).maxatts = maxatts;
                current_block = 13242334135786603907;
            }
        }
    } else if nr + 5 as std::os::raw::c_int > (*ctxt).maxatts {
        maxatts = (nr + 5 as std::os::raw::c_int) * 2 as std::os::raw::c_int;
        atts =
            xmlRealloc.expect("non-null function pointer")((*ctxt).atts as
                                                               *mut std::os::raw::c_void,
                                                           (maxatts as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut *const xmlChar;
        if atts.is_null() {
            current_block = 4877220181156914653;
        } else {
            (*ctxt).atts = atts;
            attallocs =
                xmlRealloc.expect("non-null function pointer")((*ctxt).attallocs
                                                                   as
                                                                   *mut std::os::raw::c_void,
                                                               ((maxatts /
                                                                     5 as
                                                                         std::os::raw::c_int)
                                                                    as
                                                                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_int>()
                                                                                                    as
                                                                                                    std::os::raw::c_ulong))
                    as *mut std::os::raw::c_int;
            if attallocs.is_null() {
                current_block = 4877220181156914653;
            } else {
                (*ctxt).attallocs = attallocs;
                (*ctxt).maxatts = maxatts;
                current_block = 13242334135786603907;
            }
        }
    } else { current_block = 13242334135786603907; }
    match current_block {
        13242334135786603907 => { return (*ctxt).maxatts }
        _ => {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
    };
}
/* *
 * inputPush:
 * @ctxt:  an XML parser context
 * @value:  the parser input
 *
 * Pushes a new parser input on top of the input stack
 *
 * Returns -1 in case of error, the index in the stack otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn inputPush(mut ctxt: xmlParserCtxtPtr,
                                   mut value: xmlParserInputPtr)
 -> std::os::raw::c_int {
    if ctxt.is_null() || value.is_null() { return -(1 as std::os::raw::c_int) }
    if (*ctxt).inputNr >= (*ctxt).inputMax {
        (*ctxt).inputMax *= 2 as std::os::raw::c_int;
        (*ctxt).inputTab =
            xmlRealloc.expect("non-null function pointer")((*ctxt).inputTab as
                                                               *mut std::os::raw::c_void,
                                                           ((*ctxt).inputMax
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlParserInputPtr>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut xmlParserInputPtr;
        if (*ctxt).inputTab.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            xmlFreeInputStream(value);
            (*ctxt).inputMax /= 2 as std::os::raw::c_int;
            value = 0 as xmlParserInputPtr;
            return -(1 as std::os::raw::c_int)
        }
    }
    let ref mut fresh14 = *(*ctxt).inputTab.offset((*ctxt).inputNr as isize);
    *fresh14 = value;
    (*ctxt).input = value;
    let fresh15 = (*ctxt).inputNr;
    (*ctxt).inputNr = (*ctxt).inputNr + 1;
    return fresh15;
}
/* *
 * inputPop:
 * @ctxt: an XML parser context
 *
 * Pops the top parser input from the input stack
 *
 * Returns the input just removed
 */
#[no_mangle]
pub unsafe extern "C" fn inputPop(mut ctxt: xmlParserCtxtPtr)
 -> xmlParserInputPtr {
    let mut ret: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if ctxt.is_null() { return 0 as xmlParserInputPtr }
    if (*ctxt).inputNr <= 0 as std::os::raw::c_int { return 0 as xmlParserInputPtr }
    (*ctxt).inputNr -= 1;
    if (*ctxt).inputNr > 0 as std::os::raw::c_int {
        (*ctxt).input =
            *(*ctxt).inputTab.offset(((*ctxt).inputNr - 1 as std::os::raw::c_int) as
                                         isize)
    } else { (*ctxt).input = 0 as xmlParserInputPtr }
    ret = *(*ctxt).inputTab.offset((*ctxt).inputNr as isize);
    let ref mut fresh16 = *(*ctxt).inputTab.offset((*ctxt).inputNr as isize);
    *fresh16 = 0 as xmlParserInputPtr;
    return ret;
}
/*
 * Generated by MACROS on top of parser.c c.f. PUSH_AND_POP.
 */
/* *
 * nodePush:
 * @ctxt:  an XML parser context
 * @value:  the element node
 *
 * Pushes a new element node on top of the node stack
 *
 * Returns -1 in case of error, the index in the stack otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn nodePush(mut ctxt: xmlParserCtxtPtr,
                                  mut value: xmlNodePtr) -> std::os::raw::c_int {
    if ctxt.is_null() { return 0 as std::os::raw::c_int }
    if (*ctxt).nodeNr >= (*ctxt).nodeMax {
        let mut tmp: *mut xmlNodePtr = 0 as *mut xmlNodePtr;
        tmp =
            xmlRealloc.expect("non-null function pointer")((*ctxt).nodeTab as
                                                               *mut std::os::raw::c_void,
                                                           (((*ctxt).nodeMax *
                                                                 2 as
                                                                     std::os::raw::c_int)
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlNodePtr>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut xmlNodePtr;
        if tmp.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        (*ctxt).nodeTab = tmp;
        (*ctxt).nodeMax *= 2 as std::os::raw::c_int
    }
    if (*ctxt).nodeNr as std::os::raw::c_uint > xmlParserMaxDepth &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
       {
        xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
                          b"Excessive depth in document: %d use XML_PARSE_HUGE option\n\x00"
                              as *const u8 as *const std::os::raw::c_char,
                          xmlParserMaxDepth as std::os::raw::c_int);
        xmlHaltParser(ctxt);
        return -(1 as std::os::raw::c_int)
    }
    let ref mut fresh17 = *(*ctxt).nodeTab.offset((*ctxt).nodeNr as isize);
    *fresh17 = value;
    (*ctxt).node = value;
    let fresh18 = (*ctxt).nodeNr;
    (*ctxt).nodeNr = (*ctxt).nodeNr + 1;
    return fresh18;
}
/* *
 * nodePop:
 * @ctxt: an XML parser context
 *
 * Pops the top element node from the node stack
 *
 * Returns the node just removed
 */
#[no_mangle]
pub unsafe extern "C" fn nodePop(mut ctxt: xmlParserCtxtPtr) -> xmlNodePtr {
    let mut ret: xmlNodePtr = 0 as *mut xmlNode;
    if ctxt.is_null() { return 0 as xmlNodePtr }
    if (*ctxt).nodeNr <= 0 as std::os::raw::c_int { return 0 as xmlNodePtr }
    (*ctxt).nodeNr -= 1;
    if (*ctxt).nodeNr > 0 as std::os::raw::c_int {
        (*ctxt).node =
            *(*ctxt).nodeTab.offset(((*ctxt).nodeNr - 1 as std::os::raw::c_int) as
                                        isize)
    } else { (*ctxt).node = 0 as xmlNodePtr }
    ret = *(*ctxt).nodeTab.offset((*ctxt).nodeNr as isize);
    let ref mut fresh19 = *(*ctxt).nodeTab.offset((*ctxt).nodeNr as isize);
    *fresh19 = 0 as xmlNodePtr;
    return ret;
}
/* *
 * nameNsPush:
 * @ctxt:  an XML parser context
 * @value:  the element name
 * @prefix:  the element prefix
 * @URI:  the element namespace name
 *
 * Pushes a new element name/prefix/URL on top of the name stack
 *
 * Returns -1 in case of error, the index in the stack otherwise
 */
unsafe extern "C" fn nameNsPush(mut ctxt: xmlParserCtxtPtr,
                                mut value: *const xmlChar,
                                mut prefix: *const xmlChar,
                                mut URI: *const xmlChar,
                                mut nsNr: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut current_block: u64;
    if (*ctxt).nameNr >= (*ctxt).nameMax {
        let mut tmp: *mut *const xmlChar = 0 as *mut *const xmlChar;
        let mut tmp2: *mut *mut std::os::raw::c_void = 0 as *mut *mut std::os::raw::c_void;
        (*ctxt).nameMax *= 2 as std::os::raw::c_int;
        tmp =
            xmlRealloc.expect("non-null function pointer")((*ctxt).nameTab as
                                                               *mut *mut xmlChar
                                                               as
                                                               *mut std::os::raw::c_void,
                                                           ((*ctxt).nameMax as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut *const xmlChar;
        if tmp.is_null() {
            (*ctxt).nameMax /= 2 as std::os::raw::c_int;
            current_block = 4925888600138969731;
        } else {
            (*ctxt).nameTab = tmp;
            tmp2 =
                xmlRealloc.expect("non-null function pointer")((*ctxt).pushTab
                                                                   as
                                                                   *mut std::os::raw::c_void,
                                                               (((*ctxt).nameMax
                                                                     *
                                                                     3 as
                                                                         std::os::raw::c_int)
                                                                    as
                                                                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut std::os::raw::c_void>()
                                                                                                    as
                                                                                                    std::os::raw::c_ulong))
                    as *mut *mut std::os::raw::c_void;
            if tmp2.is_null() {
                (*ctxt).nameMax /= 2 as std::os::raw::c_int;
                current_block = 4925888600138969731;
            } else {
                (*ctxt).pushTab = tmp2;
                current_block = 12209867499936983673;
            }
        }
        match current_block {
            12209867499936983673 => { }
            _ => {
                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
        }
    }
    let ref mut fresh20 = *(*ctxt).nameTab.offset((*ctxt).nameNr as isize);
    *fresh20 = value;
    (*ctxt).name = value;
    let ref mut fresh21 =
        *(*ctxt).pushTab.offset(((*ctxt).nameNr * 3 as std::os::raw::c_int) as isize);
    *fresh21 = prefix as *mut std::os::raw::c_void;
    let ref mut fresh22 =
        *(*ctxt).pushTab.offset(((*ctxt).nameNr * 3 as std::os::raw::c_int +
                                     1 as std::os::raw::c_int) as isize);
    *fresh22 = URI as *mut std::os::raw::c_void;
    let ref mut fresh23 =
        *(*ctxt).pushTab.offset(((*ctxt).nameNr * 3 as std::os::raw::c_int +
                                     2 as std::os::raw::c_int) as isize);
    *fresh23 = nsNr as ptrdiff_t as *mut std::os::raw::c_void;
    let fresh24 = (*ctxt).nameNr;
    (*ctxt).nameNr = (*ctxt).nameNr + 1;
    return fresh24;
}
/* *
 * nameNsPop:
 * @ctxt: an XML parser context
 *
 * Pops the top element/prefix/URI name from the name stack
 *
 * Returns the name just removed
 */
unsafe extern "C" fn nameNsPop(mut ctxt: xmlParserCtxtPtr) -> *const xmlChar {
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    if (*ctxt).nameNr <= 0 as std::os::raw::c_int { return 0 as *const xmlChar }
    (*ctxt).nameNr -= 1;
    if (*ctxt).nameNr > 0 as std::os::raw::c_int {
        (*ctxt).name =
            *(*ctxt).nameTab.offset(((*ctxt).nameNr - 1 as std::os::raw::c_int) as
                                        isize)
    } else { (*ctxt).name = 0 as *const xmlChar }
    ret = *(*ctxt).nameTab.offset((*ctxt).nameNr as isize);
    let ref mut fresh25 = *(*ctxt).nameTab.offset((*ctxt).nameNr as isize);
    *fresh25 = 0 as *const xmlChar;
    return ret;
}
/* LIBXML_PUSH_ENABLED */
/* *
 * namePush:
 * @ctxt:  an XML parser context
 * @value:  the element name
 *
 * Pushes a new element name on top of the name stack
 *
 * Returns -1 in case of error, the index in the stack otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn namePush(mut ctxt: xmlParserCtxtPtr,
                                  mut value: *const xmlChar) -> std::os::raw::c_int {
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    if (*ctxt).nameNr >= (*ctxt).nameMax {
        let mut tmp: *mut *const xmlChar = 0 as *mut *const xmlChar;
        tmp =
            xmlRealloc.expect("non-null function pointer")((*ctxt).nameTab as
                                                               *mut *mut xmlChar
                                                               as
                                                               *mut std::os::raw::c_void,
                                                           (((*ctxt).nameMax *
                                                                 2 as
                                                                     std::os::raw::c_int)
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut *const xmlChar;
        if tmp.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        } else { (*ctxt).nameTab = tmp; (*ctxt).nameMax *= 2 as std::os::raw::c_int }
    }
    let ref mut fresh26 = *(*ctxt).nameTab.offset((*ctxt).nameNr as isize);
    *fresh26 = value;
    (*ctxt).name = value;
    let fresh27 = (*ctxt).nameNr;
    (*ctxt).nameNr = (*ctxt).nameNr + 1;
    return fresh27;
}
/* *
 * namePop:
 * @ctxt: an XML parser context
 *
 * Pops the top element name from the name stack
 *
 * Returns the name just removed
 */
#[no_mangle]
pub unsafe extern "C" fn namePop(mut ctxt: xmlParserCtxtPtr)
 -> *const xmlChar {
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || (*ctxt).nameNr <= 0 as std::os::raw::c_int {
        return 0 as *const xmlChar
    }
    (*ctxt).nameNr -= 1;
    if (*ctxt).nameNr > 0 as std::os::raw::c_int {
        (*ctxt).name =
            *(*ctxt).nameTab.offset(((*ctxt).nameNr - 1 as std::os::raw::c_int) as
                                        isize)
    } else { (*ctxt).name = 0 as *const xmlChar }
    ret = *(*ctxt).nameTab.offset((*ctxt).nameNr as isize);
    let ref mut fresh28 = *(*ctxt).nameTab.offset((*ctxt).nameNr as isize);
    *fresh28 = 0 as *const xmlChar;
    return ret;
}
unsafe extern "C" fn spacePush(mut ctxt: xmlParserCtxtPtr,
                               mut val: std::os::raw::c_int) -> std::os::raw::c_int {
    if (*ctxt).spaceNr >= (*ctxt).spaceMax {
        let mut tmp: *mut std::os::raw::c_int = 0 as *mut std::os::raw::c_int;
        (*ctxt).spaceMax *= 2 as std::os::raw::c_int;
        tmp =
            xmlRealloc.expect("non-null function pointer")((*ctxt).spaceTab as
                                                               *mut std::os::raw::c_void,
                                                           ((*ctxt).spaceMax
                                                                as
                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_int>()
                                                                                                as
                                                                                                std::os::raw::c_ulong))
                as *mut std::os::raw::c_int;
        if tmp.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            (*ctxt).spaceMax /= 2 as std::os::raw::c_int;
            return -(1 as std::os::raw::c_int)
        }
        (*ctxt).spaceTab = tmp
    }
    *(*ctxt).spaceTab.offset((*ctxt).spaceNr as isize) = val;
    (*ctxt).space =
        &mut *(*ctxt).spaceTab.offset((*ctxt).spaceNr as isize) as
            *mut std::os::raw::c_int;
    let fresh29 = (*ctxt).spaceNr;
    (*ctxt).spaceNr = (*ctxt).spaceNr + 1;
    return fresh29;
}
unsafe extern "C" fn spacePop(mut ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    if (*ctxt).spaceNr <= 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    (*ctxt).spaceNr -= 1;
    if (*ctxt).spaceNr > 0 as std::os::raw::c_int {
        (*ctxt).space =
            &mut *(*ctxt).spaceTab.offset(((*ctxt).spaceNr - 1 as std::os::raw::c_int)
                                              as isize) as *mut std::os::raw::c_int
    } else {
        (*ctxt).space =
            &mut *(*ctxt).spaceTab.offset(0 as std::os::raw::c_int as isize) as
                *mut std::os::raw::c_int
    }
    ret = *(*ctxt).spaceTab.offset((*ctxt).spaceNr as isize);
    *(*ctxt).spaceTab.offset((*ctxt).spaceNr as isize) = -(1 as std::os::raw::c_int);
    return ret;
}
unsafe extern "C" fn xmlSHRINK(mut ctxt: xmlParserCtxtPtr) {
    xmlParserInputShrink((*ctxt).input);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    };
}
unsafe extern "C" fn xmlGROW(mut ctxt: xmlParserCtxtPtr) {
    let mut curEnd: std::os::raw::c_ulong =
        (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
            std::os::raw::c_long as std::os::raw::c_ulong;
    let mut curBase: std::os::raw::c_ulong =
        (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
            std::os::raw::c_long as std::os::raw::c_ulong;
    if (curEnd > 10000000 as std::os::raw::c_int as std::os::raw::c_ulong ||
            curBase > 10000000 as std::os::raw::c_int as std::os::raw::c_ulong) &&
           (!(*(*ctxt).input).buf.is_null() &&
                (*(*(*ctxt).input).buf).readcallback !=
                    Some(xmlInputReadCallbackNop as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *mut std::os::raw::c_char,
                                                  _: std::os::raw::c_int)
                                 -> std::os::raw::c_int)) &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
       {
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    b"Huge input lookup\x00" as *const u8 as
                        *const std::os::raw::c_char);
        xmlHaltParser(ctxt);
        return
    }
    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    if (*(*ctxt).input).cur > (*(*ctxt).input).end ||
           (*(*ctxt).input).cur < (*(*ctxt).input).base {
        xmlHaltParser(ctxt);
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    b"cur index out of bound\x00" as *const u8 as
                        *const std::os::raw::c_char);
        return
    }
    if !(*(*ctxt).input).cur.is_null() &&
           *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    };
}
/*
 * other commodities shared between parser.c and parserInternals.
 */
/* *
 * xmlSkipBlankChars:
 * @ctxt:  the XML parser context
 *
 * skip all blanks character found at that point in the input streams.
 * It pops up finished entities in the process if allowable at that point.
 *
 * Returns the number of space chars skipped
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSkipBlankChars(mut ctxt: xmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut res: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
     * It's Okay to use CUR/NEXT here since all the blanks are on
     * the ASCII range.
     */
    if (*ctxt).inputNr == 1 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int != XML_PARSER_DTD as std::os::raw::c_int {
        let mut cur: *const xmlChar = 0 as *const xmlChar;
        /*
	 * if we are in the document content, go really fast
	 */
        cur = (*(*ctxt).input).cur;
        while *cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                  0x9 as std::os::raw::c_int <= *cur as std::os::raw::c_int &&
                      *cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                  *cur as std::os::raw::c_int == 0xd as std::os::raw::c_int {
            if *cur as std::os::raw::c_int == '\n' as i32 {
                (*(*ctxt).input).line += 1;
                (*(*ctxt).input).col = 1 as std::os::raw::c_int
            } else { (*(*ctxt).input).col += 1 }
            cur = cur.offset(1);
            res += 1;
            if *cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                (*(*ctxt).input).cur = cur;
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                cur = (*(*ctxt).input).cur
            }
        }
        (*(*ctxt).input).cur = cur
    } else {
        let mut expandPE: std::os::raw::c_int =
            ((*ctxt).external != 0 as std::os::raw::c_int ||
                 (*ctxt).inputNr != 1 as std::os::raw::c_int) as std::os::raw::c_int;
        loop  {
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                   0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int
                       &&
                       *(*(*ctxt).input).cur as std::os::raw::c_int <=
                           0xa as std::os::raw::c_int ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int
               {
                /* CHECKED tstblanks.xml */
                xmlNextChar(ctxt);
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '%' as i32 {
                /*
                 * Need to handle support of entities branching here
                 */
                if expandPE == 0 as std::os::raw::c_int ||
                       (*(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                            == 0x20 as std::os::raw::c_int ||
                            0x9 as std::os::raw::c_int <=
                                *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int
                                                                 as isize) as
                                    std::os::raw::c_int &&
                                *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int
                                                                 as isize) as
                                    std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int == 0xd as std::os::raw::c_int) ||
                       *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    break ;
                }
                xmlParsePEReference(ctxt);
            } else {
                if !(*(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int)
                   {
                    break ;
                }
                if (*ctxt).inputNr <= 1 as std::os::raw::c_int { break ; }
                xmlPopInput(ctxt);
            }
            /*
             * Also increase the counter when entering or exiting a PERef.
             * The spec says: "When a parameter-entity reference is recognized
             * in the DTD and included, its replacement text MUST be enlarged
             * by the attachment of one leading and one following space (#x20)
             * character."
             */
            res += 1
        }
    }
    return res;
}
/* ***********************************************************************
 *									*
 *		Commodity functions to handle entities			*
 *									*
 ************************************************************************/
/* *
 * xmlPopInput:
 * @ctxt:  an XML parser context
 *
 * xmlPopInput: the current input pointed by ctxt->input came to an end
 *          pop it and return the next char.
 *
 * Returns the current xmlChar in the parser context
 */
#[no_mangle]
pub unsafe extern "C" fn xmlPopInput(mut ctxt: xmlParserCtxtPtr) -> xmlChar {
    if ctxt.is_null() || (*ctxt).inputNr <= 1 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int as xmlChar
    }
    if *__xmlParserDebugEntities() != 0 {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Popping input %d\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   (*ctxt).inputNr);
    }
    if (*ctxt).inputNr > 1 as std::os::raw::c_int &&
           (*ctxt).inSubset == 0 as std::os::raw::c_int &&
           (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    b"Unfinished entity outside the DTD\x00" as *const u8 as
                        *const std::os::raw::c_char);
    }
    xmlFreeInputStream(inputPop(ctxt));
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    return *(*(*ctxt).input).cur;
}
/* *
 * xmlPushInput:
 * @ctxt:  an XML parser context
 * @input:  an XML parser input fragment (entity, XML fragment ...).
 *
 * xmlPushInput: switch to a new input stream which is stacked on top
 *               of the previous one(s).
 * Returns -1 in case of error or the index in the input stack
 */
#[no_mangle]
pub unsafe extern "C" fn xmlPushInput(mut ctxt: xmlParserCtxtPtr,
                                      mut input: xmlParserInputPtr)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    if input.is_null() { return -(1 as std::os::raw::c_int) }
    if *__xmlParserDebugEntities() != 0 {
        if !(*ctxt).input.is_null() && !(*(*ctxt).input).filename.is_null() {
            (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                       b"%s(%d): \x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const std::os::raw::c_char,
                                                                       (*(*ctxt).input).filename,
                                                                       (*(*ctxt).input).line);
        }
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Pushing input %d : %.30s\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   (*ctxt).inputNr
                                                                       +
                                                                       1 as
                                                                           std::os::raw::c_int,
                                                                   (*input).cur);
    }
    if (*ctxt).inputNr > 40 as std::os::raw::c_int &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
           || (*ctxt).inputNr > 1024 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, 0 as *const std::os::raw::c_char);
        while (*ctxt).inputNr > 1 as std::os::raw::c_int {
            xmlFreeInputStream(inputPop(ctxt));
        }
        return -(1 as std::os::raw::c_int)
    }
    ret = inputPush(ctxt, input);
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    return ret;
}
/* *
 * xmlParseCharRef:
 * @ctxt:  an XML parser context
 *
 * parse Reference declarations
 *
 * [66] CharRef ::= '&#' [0-9]+ ';' |
 *                  '&#x' [0-9a-fA-F]+ ';'
 *
 * [ WFC: Legal Character ]
 * Characters referred to using character references must match the
 * production for Char.
 *
 * Returns the value parsed (as an int), 0 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseCharRef(mut ctxt: xmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut val: std::os::raw::c_uint = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut outofrange: std::os::raw::c_uint = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    /*
     * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '&' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '#' as i32 &&
           *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'x' as i32 {
        (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 3 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        while *(*(*ctxt).input).cur as std::os::raw::c_int != ';' as i32 {
            /* loop blocked by count */
            let fresh30 = count;
            count = count + 1;
            if fresh30 > 20 as std::os::raw::c_int {
                count = 0 as std::os::raw::c_int;
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    return 0 as std::os::raw::c_int
                }
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int >= '0' as i32 &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= '9' as i32 {
                val =
                    val.wrapping_mul(16 as std::os::raw::c_int as
                                         std::os::raw::c_uint).wrapping_add((*(*(*ctxt).input).cur
                                                                         as
                                                                         std::os::raw::c_int
                                                                         -
                                                                         '0'
                                                                             as
                                                                             i32)
                                                                        as
                                                                        std::os::raw::c_uint)
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int >= 'a' as i32 &&
                          *(*(*ctxt).input).cur as std::os::raw::c_int <= 'f' as i32
                          && count < 20 as std::os::raw::c_int {
                val =
                    val.wrapping_mul(16 as std::os::raw::c_int as
                                         std::os::raw::c_uint).wrapping_add((*(*(*ctxt).input).cur
                                                                         as
                                                                         std::os::raw::c_int
                                                                         -
                                                                         'a'
                                                                             as
                                                                             i32)
                                                                        as
                                                                        std::os::raw::c_uint).wrapping_add(10
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                                       as
                                                                                                       std::os::raw::c_uint)
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int >= 'A' as i32 &&
                          *(*(*ctxt).input).cur as std::os::raw::c_int <= 'F' as i32
                          && count < 20 as std::os::raw::c_int {
                val =
                    val.wrapping_mul(16 as std::os::raw::c_int as
                                         std::os::raw::c_uint).wrapping_add((*(*(*ctxt).input).cur
                                                                         as
                                                                         std::os::raw::c_int
                                                                         -
                                                                         'A'
                                                                             as
                                                                             i32)
                                                                        as
                                                                        std::os::raw::c_uint).wrapping_add(10
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                                       as
                                                                                                       std::os::raw::c_uint)
            } else {
                xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF,
                            0 as *const std::os::raw::c_char);
                val = 0 as std::os::raw::c_int as std::os::raw::c_uint;
                break ;
            }
            if val > 0x10ffff as std::os::raw::c_int as std::os::raw::c_uint {
                outofrange = val
            }
            xmlNextChar(ctxt);
            count += 1
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ';' as i32 {
            /* on purpose to avoid reentrancy problems with NEXT and SKIP */
            (*(*ctxt).input).col += 1;
            (*ctxt).nbChars += 1;
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1)
        }
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '&' as i32 &&
                  *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                      std::os::raw::c_int == '#' as i32 {
        (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 2 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        while *(*(*ctxt).input).cur as std::os::raw::c_int != ';' as i32 {
            /* loop blocked by count */
            let fresh31 = count;
            count = count + 1;
            if fresh31 > 20 as std::os::raw::c_int {
                count = 0 as std::os::raw::c_int;
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    return 0 as std::os::raw::c_int
                }
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int >= '0' as i32 &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= '9' as i32 {
                val =
                    val.wrapping_mul(10 as std::os::raw::c_int as
                                         std::os::raw::c_uint).wrapping_add((*(*(*ctxt).input).cur
                                                                         as
                                                                         std::os::raw::c_int
                                                                         -
                                                                         '0'
                                                                             as
                                                                             i32)
                                                                        as
                                                                        std::os::raw::c_uint);
                if val > 0x10ffff as std::os::raw::c_int as std::os::raw::c_uint {
                    outofrange = val
                }
                xmlNextChar(ctxt);
                count += 1
            } else {
                xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF,
                            0 as *const std::os::raw::c_char);
                val = 0 as std::os::raw::c_int as std::os::raw::c_uint;
                break ;
            }
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ';' as i32 {
            /* on purpose to avoid reentrancy problems with NEXT and SKIP */
            (*(*ctxt).input).col += 1;
            (*ctxt).nbChars += 1;
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1)
        }
    } else {
        xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, 0 as *const std::os::raw::c_char);
    }
    /*
     * [ WFC: Legal Character ]
     * Characters referred to using character references must match the
     * production for Char.
     */
    if (if val < 0x100 as std::os::raw::c_int as std::os::raw::c_uint {
            (0x9 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                 val <= 0xa as std::os::raw::c_int as std::os::raw::c_uint ||
                 val == 0xd as std::os::raw::c_int as std::os::raw::c_uint ||
                 0x20 as std::os::raw::c_int as std::os::raw::c_uint <= val) as std::os::raw::c_int
        } else {
            (0x100 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                 val <= 0xd7ff as std::os::raw::c_int as std::os::raw::c_uint ||
                 0xe000 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                     val <= 0xfffd as std::os::raw::c_int as std::os::raw::c_uint ||
                 0x10000 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                     val <= 0x10ffff as std::os::raw::c_int as std::os::raw::c_uint) as
                std::os::raw::c_int
        }) != 0 && outofrange == 0 as std::os::raw::c_int as std::os::raw::c_uint {
        return val as std::os::raw::c_int
    } else {
        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                          b"xmlParseCharRef: invalid xmlChar value %d\n\x00"
                              as *const u8 as *const std::os::raw::c_char,
                          val as std::os::raw::c_int);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlParseStringCharRef:
 * @ctxt:  an XML parser context
 * @str:  a pointer to an index in the string
 *
 * parse Reference declarations, variant parsing from a string rather
 * than an an input flow.
 *
 * [66] CharRef ::= '&#' [0-9]+ ';' |
 *                  '&#x' [0-9a-fA-F]+ ';'
 *
 * [ WFC: Legal Character ]
 * Characters referred to using character references must match the
 * production for Char.
 *
 * Returns the value parsed (as an int), 0 in case of error, str will be
 *         updated to the current value of the index
 */
unsafe extern "C" fn xmlParseStringCharRef(mut ctxt: xmlParserCtxtPtr,
                                           mut str: *mut *const xmlChar)
 -> std::os::raw::c_int {
    let mut ptr: *const xmlChar = 0 as *const xmlChar;
    let mut cur: xmlChar = 0;
    let mut val: std::os::raw::c_uint = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    let mut outofrange: std::os::raw::c_uint = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    if str.is_null() || (*str).is_null() { return 0 as std::os::raw::c_int }
    ptr = *str;
    cur = *ptr;
    if cur as std::os::raw::c_int == '&' as i32 &&
           *ptr.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int == '#' as i32
           &&
           *ptr.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int == 'x' as i32
       {
        ptr = ptr.offset(3 as std::os::raw::c_int as isize);
        cur = *ptr;
        while cur as std::os::raw::c_int != ';' as i32 {
            /* Non input consuming loop */
            if cur as std::os::raw::c_int >= '0' as i32 &&
                   cur as std::os::raw::c_int <= '9' as i32 {
                val =
                    val.wrapping_mul(16 as std::os::raw::c_int as
                                         std::os::raw::c_uint).wrapping_add((cur as
                                                                         std::os::raw::c_int
                                                                         -
                                                                         '0'
                                                                             as
                                                                             i32)
                                                                        as
                                                                        std::os::raw::c_uint)
            } else if cur as std::os::raw::c_int >= 'a' as i32 &&
                          cur as std::os::raw::c_int <= 'f' as i32 {
                val =
                    val.wrapping_mul(16 as std::os::raw::c_int as
                                         std::os::raw::c_uint).wrapping_add((cur as
                                                                         std::os::raw::c_int
                                                                         -
                                                                         'a'
                                                                             as
                                                                             i32)
                                                                        as
                                                                        std::os::raw::c_uint).wrapping_add(10
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                                       as
                                                                                                       std::os::raw::c_uint)
            } else if cur as std::os::raw::c_int >= 'A' as i32 &&
                          cur as std::os::raw::c_int <= 'F' as i32 {
                val =
                    val.wrapping_mul(16 as std::os::raw::c_int as
                                         std::os::raw::c_uint).wrapping_add((cur as
                                                                         std::os::raw::c_int
                                                                         -
                                                                         'A'
                                                                             as
                                                                             i32)
                                                                        as
                                                                        std::os::raw::c_uint).wrapping_add(10
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                                       as
                                                                                                       std::os::raw::c_uint)
            } else {
                xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF,
                            0 as *const std::os::raw::c_char);
                val = 0 as std::os::raw::c_int as std::os::raw::c_uint;
                break ;
            }
            if val > 0x10ffff as std::os::raw::c_int as std::os::raw::c_uint {
                outofrange = val
            }
            ptr = ptr.offset(1);
            cur = *ptr
        }
        if cur as std::os::raw::c_int == ';' as i32 { ptr = ptr.offset(1) }
    } else if cur as std::os::raw::c_int == '&' as i32 &&
                  *ptr.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                      '#' as i32 {
        ptr = ptr.offset(2 as std::os::raw::c_int as isize);
        cur = *ptr;
        while cur as std::os::raw::c_int != ';' as i32 {
            /* Non input consuming loops */
            if cur as std::os::raw::c_int >= '0' as i32 &&
                   cur as std::os::raw::c_int <= '9' as i32 {
                val =
                    val.wrapping_mul(10 as std::os::raw::c_int as
                                         std::os::raw::c_uint).wrapping_add((cur as
                                                                         std::os::raw::c_int
                                                                         -
                                                                         '0'
                                                                             as
                                                                             i32)
                                                                        as
                                                                        std::os::raw::c_uint);
                if val > 0x10ffff as std::os::raw::c_int as std::os::raw::c_uint {
                    outofrange = val
                }
                ptr = ptr.offset(1);
                cur = *ptr
            } else {
                xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF,
                            0 as *const std::os::raw::c_char);
                val = 0 as std::os::raw::c_int as std::os::raw::c_uint;
                break ;
            }
        }
        if cur as std::os::raw::c_int == ';' as i32 { ptr = ptr.offset(1) }
    } else {
        xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, 0 as *const std::os::raw::c_char);
        return 0 as std::os::raw::c_int
    }
    *str = ptr;
    /*
     * [ WFC: Legal Character ]
     * Characters referred to using character references must match the
     * production for Char.
     */
    if (if val < 0x100 as std::os::raw::c_int as std::os::raw::c_uint {
            (0x9 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                 val <= 0xa as std::os::raw::c_int as std::os::raw::c_uint ||
                 val == 0xd as std::os::raw::c_int as std::os::raw::c_uint ||
                 0x20 as std::os::raw::c_int as std::os::raw::c_uint <= val) as std::os::raw::c_int
        } else {
            (0x100 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                 val <= 0xd7ff as std::os::raw::c_int as std::os::raw::c_uint ||
                 0xe000 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                     val <= 0xfffd as std::os::raw::c_int as std::os::raw::c_uint ||
                 0x10000 as std::os::raw::c_int as std::os::raw::c_uint <= val &&
                     val <= 0x10ffff as std::os::raw::c_int as std::os::raw::c_uint) as
                std::os::raw::c_int
        }) != 0 && outofrange == 0 as std::os::raw::c_int as std::os::raw::c_uint {
        return val as std::os::raw::c_int
    } else {
        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                          b"xmlParseStringCharRef: invalid xmlChar value %d\n\x00"
                              as *const u8 as *const std::os::raw::c_char,
                          val as std::os::raw::c_int);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlParserHandlePEReference:
 * @ctxt:  the parser context
 *
 * [69] PEReference ::= '%' Name ';'
 *
 * [ WFC: No Recursion ]
 * A parsed entity must not contain a recursive
 * reference to itself, either directly or indirectly.
 *
 * [ WFC: Entity Declared ]
 * In a document without any DTD, a document with only an internal DTD
 * subset which contains no parameter entity references, or a document
 * with "standalone='yes'", ...  ... The declaration of a parameter
 * entity must precede any reference to it...
 *
 * [ VC: Entity Declared ]
 * In a document with an external subset or external parameter entities
 * with "standalone='no'", ...  ... The declaration of a parameter entity
 * must precede any reference to it...
 *
 * [ WFC: In DTD ]
 * Parameter-entity references may only appear in the DTD.
 * NOTE: misleading but this is handled.
 *
 * A PEReference may have been detected in the current input stream
 * the handling is done accordingly to
 *      http://www.w3.org/TR/REC-xml#entproc
 * i.e.
 *   - Included in literal in entity values
 *   - Included as Parameter Entity reference within DTDs
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParserHandlePEReference(mut ctxt:
                                                        xmlParserCtxtPtr) {
    match (*ctxt).instate as std::os::raw::c_int {
        8 => { return }
        5 => { return }
        6 => { return }
        9 => { return }
        -1 => {
            xmlFatalErr(ctxt, XML_ERR_PEREF_AT_EOF, 0 as *const std::os::raw::c_char);
            return
        }
        4 | 0 | 1 => {
            xmlFatalErr(ctxt, XML_ERR_PEREF_IN_PROLOG,
                        0 as *const std::os::raw::c_char);
            return
        }
        10 | 7 | 12 | 2 | 13 | 16 => {
            /* we just ignore it there */
            return
        }
        14 => {
            xmlFatalErr(ctxt, XML_ERR_PEREF_IN_EPILOG,
                        0 as *const std::os::raw::c_char);
            return
        }
        11 => {
            /*
	     * NOTE: in the case of entity values, we don't do the
	     *       substitution here since we need the literal
	     *       entity value to be able to save the internal
	     *       subset of the document.
	     *       This will be handled by xmlStringDecodeEntities
	     */
            return
        }
        3 => {
            /*
	     * [WFC: Well-Formedness Constraint: PEs in Internal Subset]
	     * In the internal DTD subset, parameter-entity references
	     * can occur only where markup declarations can occur, not
	     * within markup declarations.
	     * In that case this is handled in xmlParseMarkupDecl
	     */
            if (*ctxt).external == 0 as std::os::raw::c_int &&
                   (*ctxt).inputNr == 1 as std::os::raw::c_int {
                return
            }
            if *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                   0x9 as std::os::raw::c_int <=
                       *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int &&
                       *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == 0xd as std::os::raw::c_int ||
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == 0 as std::os::raw::c_int {
                return
            }
        }
        15 => { return }
        _ => { }
    }
    xmlParsePEReference(ctxt);
}
/*
 * Macro used to grow the current buffer.
 * buffer##_size is expected to be a size_t
 * mem_error: is expected to handle memory allocation failures
 */
/* *
 * xmlStringLenDecodeEntities:
 * @ctxt:  the parser context
 * @str:  the input string
 * @len: the string length
 * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF
 * @end:  an end marker xmlChar, 0 if none
 * @end2:  an end marker xmlChar, 0 if none
 * @end3:  an end marker xmlChar, 0 if none
 *
 * Takes a entity string content and process to do the adequate substitutions.
 *
 * [67] Reference ::= EntityRef | CharRef
 *
 * [69] PEReference ::= '%' Name ';'
 *
 * Returns A newly allocated string with the substitution done. The caller
 *      must deallocate it !
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStringLenDecodeEntities(mut ctxt:
                                                        xmlParserCtxtPtr,
                                                    mut str: *const xmlChar,
                                                    mut len: std::os::raw::c_int,
                                                    mut what: std::os::raw::c_int,
                                                    mut end: xmlChar,
                                                    mut end2: xmlChar,
                                                    mut end3: xmlChar)
 -> *mut xmlChar {
    let mut current_block: u64;
    let mut buffer: *mut xmlChar = 0 as *mut xmlChar;
    let mut buffer_size: size_t = 0 as std::os::raw::c_int as size_t;
    let mut nbchars: size_t = 0 as std::os::raw::c_int as size_t;
    let mut current: *mut xmlChar = 0 as *mut xmlChar;
    let mut rep: *mut xmlChar = 0 as *mut xmlChar;
    let mut last: *const xmlChar = 0 as *const xmlChar;
    let mut ent: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut c: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    if ctxt.is_null() || str.is_null() || len < 0 as std::os::raw::c_int {
        return 0 as *mut xmlChar
    }
    last = str.offset(len as isize);
    if (*ctxt).depth > 40 as std::os::raw::c_int &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
           || (*ctxt).depth > 1024 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, 0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    /*
     * allocate a translation buffer.
     */
    buffer_size = 300 as std::os::raw::c_int as size_t;
    buffer =
        xmlMallocAtomic.expect("non-null function pointer")(buffer_size) as
            *mut xmlChar;
    if buffer.is_null() {
        current_block = 14999101667945498129;
    } else {
        /*
     * OK loop until we reach one of the ending char or a size limit.
     * we are operating on already parsed values.
     */
        if str < last {
            c = xmlStringCurrentChar(ctxt, str, &mut l)
        } else { c = 0 as std::os::raw::c_int }
        's_81:
            loop  {
                if !(c != 0 as std::os::raw::c_int && c != end as std::os::raw::c_int &&
                         c != end2 as std::os::raw::c_int && c != end3 as std::os::raw::c_int)
                   {
                    current_block = 1915186496383530739;
                    break ;
                }
                if c == 0 as std::os::raw::c_int {
                    current_block = 1915186496383530739;
                    break ;
                }
                if c == '&' as i32 &&
                       *str.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int
                           == '#' as i32 {
                    let mut val: std::os::raw::c_int =
                        xmlParseStringCharRef(ctxt, &mut str);
                    if val == 0 as std::os::raw::c_int {
                        current_block = 17123717463628944782;
                        break ;
                    }
                    if 0 as std::os::raw::c_int == 1 as std::os::raw::c_int {
                        let fresh32 = nbchars;
                        nbchars = nbchars.wrapping_add(1);
                        *buffer.offset(fresh32 as isize) = val as xmlChar
                    } else {
                        nbchars =
                            (nbchars as
                                 std::os::raw::c_ulong).wrapping_add(xmlCopyCharMultiByte(&mut *buffer.offset(nbchars
                                                                                                          as
                                                                                                          isize),
                                                                                  val)
                                                                 as
                                                                 std::os::raw::c_ulong)
                                as size_t as size_t
                    }
                    if nbchars.wrapping_add(100 as std::os::raw::c_int as
                                                std::os::raw::c_ulong) > buffer_size {
                        let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                        let mut new_size: size_t =
                            buffer_size.wrapping_mul(2 as std::os::raw::c_int as
                                                         std::os::raw::c_ulong).wrapping_add(100
                                                                                         as
                                                                                         std::os::raw::c_int
                                                                                         as
                                                                                         std::os::raw::c_ulong);
                        if new_size < buffer_size {
                            current_block = 14999101667945498129;
                            break ;
                        }
                        tmp =
                            xmlRealloc.expect("non-null function pointer")(buffer
                                                                               as
                                                                               *mut std::os::raw::c_void,
                                                                           new_size)
                                as *mut xmlChar;
                        if tmp.is_null() {
                            current_block = 14999101667945498129;
                            break ;
                        }
                        buffer = tmp;
                        buffer_size = new_size
                    }
                } else if c == '&' as i32 && what & 1 as std::os::raw::c_int != 0 {
                    if *__xmlParserDebugEntities() != 0 {
                        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                                   b"String decoding Entity Reference: %.30s\n\x00"
                                                                                       as
                                                                                       *const u8
                                                                                       as
                                                                                       *const std::os::raw::c_char,
                                                                                   str);
                    }
                    ent = xmlParseStringEntityRef(ctxt, &mut str);
                    xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t,
                                         ent, 0 as std::os::raw::c_int as size_t);
                    if !ent.is_null() {
                        (*ctxt).nbentities =
                            (*ctxt).nbentities.wrapping_add(((*ent).checked /
                                                                 2 as
                                                                     std::os::raw::c_int)
                                                                as
                                                                std::os::raw::c_ulong)
                    }
                    if !ent.is_null() &&
                           (*ent).etype as std::os::raw::c_uint ==
                               XML_INTERNAL_PREDEFINED_ENTITY as std::os::raw::c_int
                                   as std::os::raw::c_uint {
                        if !(*ent).content.is_null() {
                            if 0 as std::os::raw::c_int == 1 as std::os::raw::c_int {
                                let fresh33 = nbchars;
                                nbchars = nbchars.wrapping_add(1);
                                *buffer.offset(fresh33 as isize) =
                                    *(*ent).content.offset(0 as std::os::raw::c_int as
                                                               isize)
                            } else {
                                nbchars =
                                    (nbchars as
                                         std::os::raw::c_ulong).wrapping_add(xmlCopyCharMultiByte(&mut *buffer.offset(nbchars
                                                                                                                  as
                                                                                                                  isize),
                                                                                          *(*ent).content.offset(0
                                                                                                                     as
                                                                                                                     std::os::raw::c_int
                                                                                                                     as
                                                                                                                     isize)
                                                                                              as
                                                                                              std::os::raw::c_int)
                                                                         as
                                                                         std::os::raw::c_ulong)
                                        as size_t as size_t
                            }
                            if nbchars.wrapping_add(100 as std::os::raw::c_int as
                                                        std::os::raw::c_ulong) >
                                   buffer_size {
                                let mut tmp_0: *mut xmlChar =
                                    0 as *mut xmlChar;
                                let mut new_size_0: size_t =
                                    buffer_size.wrapping_mul(2 as std::os::raw::c_int
                                                                 as
                                                                 std::os::raw::c_ulong).wrapping_add(100
                                                                                                 as
                                                                                                 std::os::raw::c_int
                                                                                                 as
                                                                                                 std::os::raw::c_ulong);
                                if new_size_0 < buffer_size {
                                    current_block = 14999101667945498129;
                                    break ;
                                }
                                tmp_0 =
                                    xmlRealloc.expect("non-null function pointer")(buffer
                                                                                       as
                                                                                       *mut std::os::raw::c_void,
                                                                                   new_size_0)
                                        as *mut xmlChar;
                                if tmp_0.is_null() {
                                    current_block = 14999101667945498129;
                                    break ;
                                }
                                buffer = tmp_0;
                                buffer_size = new_size_0
                            }
                        } else {
                            xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
                                           b"predefined entity has no content\n\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char);
                            current_block = 17123717463628944782;
                            break ;
                        }
                    } else if !ent.is_null() && !(*ent).content.is_null() {
                        (*ctxt).depth += 1;
                        rep =
                            xmlStringDecodeEntities(ctxt, (*ent).content,
                                                    what,
                                                    0 as std::os::raw::c_int as
                                                        xmlChar,
                                                    0 as std::os::raw::c_int as
                                                        xmlChar,
                                                    0 as std::os::raw::c_int as
                                                        xmlChar);
                        (*ctxt).depth -= 1;
                        if rep.is_null() {
                            current_block = 17123717463628944782;
                            break ;
                        }
                        current = rep;
                        while *current as std::os::raw::c_int != 0 as std::os::raw::c_int {
                            /* non input consuming loop */
                            let fresh34 = current;
                            current = current.offset(1);
                            let fresh35 = nbchars;
                            nbchars = nbchars.wrapping_add(1);
                            *buffer.offset(fresh35 as isize) = *fresh34;
                            if !(nbchars.wrapping_add(100 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong) >
                                     buffer_size) {
                                continue ;
                            }
                            if xmlParserEntityCheck(ctxt, nbchars, ent,
                                                    0 as std::os::raw::c_int as
                                                        size_t) != 0 {
                                current_block = 17123717463628944782;
                                break 's_81 ;
                            }
                            let mut tmp_1: *mut xmlChar = 0 as *mut xmlChar;
                            let mut new_size_1: size_t =
                                buffer_size.wrapping_mul(2 as std::os::raw::c_int as
                                                             std::os::raw::c_ulong).wrapping_add(100
                                                                                             as
                                                                                             std::os::raw::c_int
                                                                                             as
                                                                                             std::os::raw::c_ulong);
                            if new_size_1 < buffer_size {
                                current_block = 14999101667945498129;
                                break 's_81 ;
                            }
                            tmp_1 =
                                xmlRealloc.expect("non-null function pointer")(buffer
                                                                                   as
                                                                                   *mut std::os::raw::c_void,
                                                                               new_size_1)
                                    as *mut xmlChar;
                            if tmp_1.is_null() {
                                current_block = 14999101667945498129;
                                break 's_81 ;
                            }
                            buffer = tmp_1;
                            buffer_size = new_size_1
                        }
                        xmlFree.expect("non-null function pointer")(rep as
                                                                        *mut std::os::raw::c_void);
                        rep = 0 as *mut xmlChar
                    } else if !ent.is_null() {
                        let mut i: std::os::raw::c_int = xmlStrlen((*ent).name);
                        let mut cur: *const xmlChar = (*ent).name;
                        let fresh36 = nbchars;
                        nbchars = nbchars.wrapping_add(1);
                        *buffer.offset(fresh36 as isize) =
                            '&' as i32 as xmlChar;
                        if nbchars.wrapping_add(i as
                                                    std::os::raw::c_ulong).wrapping_add(100
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    std::os::raw::c_ulong)
                               > buffer_size {
                            let mut tmp_2: *mut xmlChar = 0 as *mut xmlChar;
                            let mut new_size_2: size_t =
                                buffer_size.wrapping_mul(2 as std::os::raw::c_int as
                                                             std::os::raw::c_ulong).wrapping_add(i
                                                                                             as
                                                                                             std::os::raw::c_ulong).wrapping_add(100
                                                                                                                             as
                                                                                                                             std::os::raw::c_int
                                                                                                                             as
                                                                                                                             std::os::raw::c_ulong);
                            if new_size_2 < buffer_size {
                                current_block = 14999101667945498129;
                                break ;
                            }
                            tmp_2 =
                                xmlRealloc.expect("non-null function pointer")(buffer
                                                                                   as
                                                                                   *mut std::os::raw::c_void,
                                                                               new_size_2)
                                    as *mut xmlChar;
                            if tmp_2.is_null() {
                                current_block = 14999101667945498129;
                                break ;
                            }
                            buffer = tmp_2;
                            buffer_size = new_size_2
                        }
                        while i > 0 as std::os::raw::c_int {
                            let fresh37 = cur;
                            cur = cur.offset(1);
                            let fresh38 = nbchars;
                            nbchars = nbchars.wrapping_add(1);
                            *buffer.offset(fresh38 as isize) = *fresh37;
                            i -= 1
                        }
                        let fresh39 = nbchars;
                        nbchars = nbchars.wrapping_add(1);
                        *buffer.offset(fresh39 as isize) =
                            ';' as i32 as xmlChar
                    }
                } else if c == '%' as i32 && what & 2 as std::os::raw::c_int != 0 {
                    if *__xmlParserDebugEntities() != 0 {
                        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                                   b"String decoding PE Reference: %.30s\n\x00"
                                                                                       as
                                                                                       *const u8
                                                                                       as
                                                                                       *const std::os::raw::c_char,
                                                                                   str);
                    }
                    ent = xmlParseStringPEReference(ctxt, &mut str);
                    xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t,
                                         ent, 0 as std::os::raw::c_int as size_t);
                    if !ent.is_null() {
                        (*ctxt).nbentities =
                            (*ctxt).nbentities.wrapping_add(((*ent).checked /
                                                                 2 as
                                                                     std::os::raw::c_int)
                                                                as
                                                                std::os::raw::c_ulong)
                    }
                    if !ent.is_null() {
                        if (*ent).content.is_null() {
                            /*
		     * Note: external parsed entities will not be loaded,
		     * it is not required for a non-validating parser to
		     * complete external PEreferences coming from the
		     * internal subset
		     */
                            if (*ctxt).options &
                                   XML_PARSE_NOENT as std::os::raw::c_int !=
                                   0 as std::os::raw::c_int ||
                                   (*ctxt).options &
                                       XML_PARSE_DTDVALID as std::os::raw::c_int !=
                                       0 as std::os::raw::c_int ||
                                   (*ctxt).validate != 0 as std::os::raw::c_int {
                                xmlLoadEntityContent(ctxt, ent);
                            } else {
                                xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
                                              b"not validating will not read content for PE entity %s\n\x00"
                                                  as *const u8 as
                                                  *const std::os::raw::c_char,
                                              (*ent).name,
                                              0 as *const xmlChar);
                            }
                        }
                        (*ctxt).depth += 1;
                        rep =
                            xmlStringDecodeEntities(ctxt, (*ent).content,
                                                    what,
                                                    0 as std::os::raw::c_int as
                                                        xmlChar,
                                                    0 as std::os::raw::c_int as
                                                        xmlChar,
                                                    0 as std::os::raw::c_int as
                                                        xmlChar);
                        (*ctxt).depth -= 1;
                        if rep.is_null() {
                            current_block = 17123717463628944782;
                            break ;
                        }
                        current = rep;
                        while *current as std::os::raw::c_int != 0 as std::os::raw::c_int {
                            /* non input consuming loop */
                            let fresh40 = current;
                            current = current.offset(1);
                            let fresh41 = nbchars;
                            nbchars = nbchars.wrapping_add(1);
                            *buffer.offset(fresh41 as isize) = *fresh40;
                            if !(nbchars.wrapping_add(100 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong) >
                                     buffer_size) {
                                continue ;
                            }
                            if xmlParserEntityCheck(ctxt, nbchars, ent,
                                                    0 as std::os::raw::c_int as
                                                        size_t) != 0 {
                                current_block = 17123717463628944782;
                                break 's_81 ;
                            }
                            let mut tmp_3: *mut xmlChar = 0 as *mut xmlChar;
                            let mut new_size_3: size_t =
                                buffer_size.wrapping_mul(2 as std::os::raw::c_int as
                                                             std::os::raw::c_ulong).wrapping_add(100
                                                                                             as
                                                                                             std::os::raw::c_int
                                                                                             as
                                                                                             std::os::raw::c_ulong);
                            if new_size_3 < buffer_size {
                                current_block = 14999101667945498129;
                                break 's_81 ;
                            }
                            tmp_3 =
                                xmlRealloc.expect("non-null function pointer")(buffer
                                                                                   as
                                                                                   *mut std::os::raw::c_void,
                                                                               new_size_3)
                                    as *mut xmlChar;
                            if tmp_3.is_null() {
                                current_block = 14999101667945498129;
                                break 's_81 ;
                            }
                            buffer = tmp_3;
                            buffer_size = new_size_3
                        }
                        xmlFree.expect("non-null function pointer")(rep as
                                                                        *mut std::os::raw::c_void);
                        rep = 0 as *mut xmlChar
                    }
                } else {
                    if l == 1 as std::os::raw::c_int {
                        let fresh42 = nbchars;
                        nbchars = nbchars.wrapping_add(1);
                        *buffer.offset(fresh42 as isize) = c as xmlChar
                    } else {
                        nbchars =
                            (nbchars as
                                 std::os::raw::c_ulong).wrapping_add(xmlCopyCharMultiByte(&mut *buffer.offset(nbchars
                                                                                                          as
                                                                                                          isize),
                                                                                  c)
                                                                 as
                                                                 std::os::raw::c_ulong)
                                as size_t as size_t
                    }
                    str = str.offset(l as isize);
                    if nbchars.wrapping_add(100 as std::os::raw::c_int as
                                                std::os::raw::c_ulong) > buffer_size {
                        let mut tmp_4: *mut xmlChar = 0 as *mut xmlChar;
                        let mut new_size_4: size_t =
                            buffer_size.wrapping_mul(2 as std::os::raw::c_int as
                                                         std::os::raw::c_ulong).wrapping_add(100
                                                                                         as
                                                                                         std::os::raw::c_int
                                                                                         as
                                                                                         std::os::raw::c_ulong);
                        if new_size_4 < buffer_size {
                            current_block = 14999101667945498129;
                            break ;
                        }
                        tmp_4 =
                            xmlRealloc.expect("non-null function pointer")(buffer
                                                                               as
                                                                               *mut std::os::raw::c_void,
                                                                           new_size_4)
                                as *mut xmlChar;
                        if tmp_4.is_null() {
                            current_block = 14999101667945498129;
                            break ;
                        }
                        buffer = tmp_4;
                        buffer_size = new_size_4
                    }
                }
                if str < last {
                    c = xmlStringCurrentChar(ctxt, str, &mut l)
                } else { c = 0 as std::os::raw::c_int }
            }
        match current_block {
            14999101667945498129 => { }
            17123717463628944782 => { }
            _ => {
                *buffer.offset(nbchars as isize) =
                    0 as std::os::raw::c_int as xmlChar;
                return buffer
            }
        }
    }
    match current_block {
        14999101667945498129 => {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
        }
        _ => { }
    }
    if !rep.is_null() {
        xmlFree.expect("non-null function pointer")(rep as *mut std::os::raw::c_void);
    }
    if !buffer.is_null() {
        xmlFree.expect("non-null function pointer")(buffer as
                                                        *mut std::os::raw::c_void);
    }
    return 0 as *mut xmlChar;
}
/* *
 * XML_SUBSTITUTE_BOTH:
 *
 * Both general and parameter entities need to be substituted.
 */
/* *
 * xmlStringDecodeEntities:
 * @ctxt:  the parser context
 * @str:  the input string
 * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF
 * @end:  an end marker xmlChar, 0 if none
 * @end2:  an end marker xmlChar, 0 if none
 * @end3:  an end marker xmlChar, 0 if none
 *
 * Takes a entity string content and process to do the adequate substitutions.
 *
 * [67] Reference ::= EntityRef | CharRef
 *
 * [69] PEReference ::= '%' Name ';'
 *
 * Returns A newly allocated string with the substitution done. The caller
 *      must deallocate it !
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStringDecodeEntities(mut ctxt: xmlParserCtxtPtr,
                                                 mut str: *const xmlChar,
                                                 mut what: std::os::raw::c_int,
                                                 mut end: xmlChar,
                                                 mut end2: xmlChar,
                                                 mut end3: xmlChar)
 -> *mut xmlChar {
    if ctxt.is_null() || str.is_null() { return 0 as *mut xmlChar }
    return xmlStringLenDecodeEntities(ctxt, str, xmlStrlen(str), what, end,
                                      end2, end3);
}
/* ***********************************************************************
 *									*
 *		Commodity functions, cleanup needed ?			*
 *									*
 ************************************************************************/
/* *
 * areBlanks:
 * @ctxt:  an XML parser context
 * @str:  a xmlChar *
 * @len:  the size of @str
 * @blank_chars: we know the chars are blanks
 *
 * Is this a sequence of blank chars that one can ignore ?
 *
 * Returns 1 if ignorable 0 otherwise.
 */
unsafe extern "C" fn areBlanks(mut ctxt: xmlParserCtxtPtr,
                               mut str: *const xmlChar, mut len: std::os::raw::c_int,
                               mut blank_chars: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut i: std::os::raw::c_int = 0;
    let mut ret: std::os::raw::c_int = 0;
    let mut lastChild: xmlNodePtr = 0 as *mut xmlNode;
    /*
     * Don't spend time trying to differentiate them, the same callback is
     * used !
     */
    if (*(*ctxt).sax).ignorableWhitespace == (*(*ctxt).sax).characters {
        return 0 as std::os::raw::c_int
    }
    /*
     * Check for xml:space value.
     */
    if (*ctxt).space.is_null() || *(*ctxt).space == 1 as std::os::raw::c_int ||
           *(*ctxt).space == -(2 as std::os::raw::c_int) {
        return 0 as std::os::raw::c_int
    }
    /*
     * Check that the string is made of blanks
     */
    if blank_chars == 0 as std::os::raw::c_int {
        i = 0 as std::os::raw::c_int;
        while i < len {
            if !(*str.offset(i as isize) as std::os::raw::c_int == 0x20 as std::os::raw::c_int
                     ||
                     0x9 as std::os::raw::c_int <=
                         *str.offset(i as isize) as std::os::raw::c_int &&
                         *str.offset(i as isize) as std::os::raw::c_int <=
                             0xa as std::os::raw::c_int ||
                     *str.offset(i as isize) as std::os::raw::c_int ==
                         0xd as std::os::raw::c_int) {
                return 0 as std::os::raw::c_int
            }
            i += 1
        }
    }
    /*
     * Look if the element is mixed content in the DTD if available
     */
    if (*ctxt).node.is_null() { return 0 as std::os::raw::c_int }
    if !(*ctxt).myDoc.is_null() {
        ret = xmlIsMixedElement((*ctxt).myDoc, (*(*ctxt).node).name);
        if ret == 0 as std::os::raw::c_int { return 1 as std::os::raw::c_int }
        if ret == 1 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    }
    /*
     * Otherwise, heuristic :-\
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 &&
           *(*(*ctxt).input).cur as std::os::raw::c_int != 0xd as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    if (*(*ctxt).node).children.is_null() &&
           *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '/' as i32 {
        return 0 as std::os::raw::c_int
    }
    lastChild = xmlGetLastChild((*ctxt).node as *const xmlNode);
    if lastChild.is_null() {
        if (*(*ctxt).node).type_0 as std::os::raw::c_uint !=
               XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint &&
               !(*(*ctxt).node).content.is_null() {
            return 0 as std::os::raw::c_int
        }
    } else if xmlNodeIsText(lastChild as *const xmlNode) != 0 {
        return 0 as std::os::raw::c_int
    } else {
        if !(*(*ctxt).node).children.is_null() &&
               xmlNodeIsText((*(*ctxt).node).children) != 0 {
            return 0 as std::os::raw::c_int
        }
    }
    return 1 as std::os::raw::c_int;
}
/* *
 * Namespaces.
 */
/* ***********************************************************************
 *									*
 *		Extra stuff for namespace support			*
 *	Relates to http://www.w3.org/TR/WD-xml-names			*
 *									*
 ************************************************************************/
/* *
 * xmlSplitQName:
 * @ctxt:  an XML parser context
 * @name:  an XML parser context
 * @prefix:  a xmlChar **
 *
 * parse an UTF8 encoded XML qualified name string
 *
 * [NS 5] QName ::= (Prefix ':')? LocalPart
 *
 * [NS 6] Prefix ::= NCName
 *
 * [NS 7] LocalPart ::= NCName
 *
 * Returns the local part, and prefix is updated
 *   to get the Prefix if any.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSplitQName(mut ctxt: xmlParserCtxtPtr,
                                       mut name: *const xmlChar,
                                       mut prefix: *mut *mut xmlChar)
 -> *mut xmlChar {
    let mut buf: [xmlChar; 105] = [0; 105];
    let mut buffer: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut max: std::os::raw::c_int = 100 as std::os::raw::c_int;
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *const xmlChar = name;
    let mut c: std::os::raw::c_int = 0;
    if prefix.is_null() { return 0 as *mut xmlChar }
    *prefix = 0 as *mut xmlChar;
    if cur.is_null() { return 0 as *mut xmlChar }
    /* nasty but well=formed */
    if *cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int == ':' as i32 {
        return xmlStrdup(name)
    }
    let fresh43 = cur;
    cur = cur.offset(1);
    c = *fresh43 as std::os::raw::c_int;
    while c != 0 as std::os::raw::c_int && c != ':' as i32 && len < max {
        /* tested bigname.xml */
        let fresh44 = len;
        len = len + 1;
        buf[fresh44 as usize] = c as xmlChar;
        let fresh45 = cur;
        cur = cur.offset(1);
        c = *fresh45 as std::os::raw::c_int
    }
    if len >= max {
        /*
	 * Okay someone managed to make a huge name, so he's ready to pay
	 * for the processing speed.
	 */
        max = len * 2 as std::os::raw::c_int;
        buffer =
            xmlMallocAtomic.expect("non-null function pointer")((max as
                                                                     std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                     as
                                                                                                     std::os::raw::c_ulong))
                as *mut xmlChar;
        if buffer.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return 0 as *mut xmlChar
        }
        memcpy(buffer as *mut std::os::raw::c_void,
               buf.as_mut_ptr() as *const std::os::raw::c_void, len as std::os::raw::c_ulong);
        while c != 0 as std::os::raw::c_int && c != ':' as i32 {
            /* tested bigname.xml */
            if len + 10 as std::os::raw::c_int > max {
                let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                max *= 2 as std::os::raw::c_int;
                tmp =
                    xmlRealloc.expect("non-null function pointer")(buffer as
                                                                       *mut std::os::raw::c_void,
                                                                   (max as
                                                                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                        as
                                                                                                        std::os::raw::c_ulong))
                        as *mut xmlChar;
                if tmp.is_null() {
                    xmlFree.expect("non-null function pointer")(buffer as
                                                                    *mut std::os::raw::c_void);
                    xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                    return 0 as *mut xmlChar
                }
                buffer = tmp
            }
            let fresh46 = len;
            len = len + 1;
            *buffer.offset(fresh46 as isize) = c as xmlChar;
            let fresh47 = cur;
            cur = cur.offset(1);
            c = *fresh47 as std::os::raw::c_int
        }
        *buffer.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar
    }
    if c == ':' as i32 && *cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        if !buffer.is_null() {
            xmlFree.expect("non-null function pointer")(buffer as
                                                            *mut std::os::raw::c_void);
        }
        *prefix = 0 as *mut xmlChar;
        return xmlStrdup(name)
    }
    if buffer.is_null() {
        ret = xmlStrndup(buf.as_mut_ptr(), len)
    } else {
        ret = buffer;
        buffer = 0 as *mut xmlChar;
        max = 100 as std::os::raw::c_int
    }
    if c == ':' as i32 {
        c = *cur as std::os::raw::c_int;
        *prefix = ret;
        if c == 0 as std::os::raw::c_int {
            return xmlStrndup(b"\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar, 0 as std::os::raw::c_int)
        }
        len = 0 as std::os::raw::c_int;
        /*
	 * Check that the first character is proper to start
	 * a new name
	 */
        if !(c >= 0x61 as std::os::raw::c_int && c <= 0x7a as std::os::raw::c_int ||
                 c >= 0x41 as std::os::raw::c_int && c <= 0x5a as std::os::raw::c_int ||
                 c == '_' as i32 || c == ':' as i32) {
            let mut l: std::os::raw::c_int = 0;
            let mut first: std::os::raw::c_int =
                xmlStringCurrentChar(ctxt, cur, &mut l);
            if !((if first < 0x100 as std::os::raw::c_int {
                      (0x41 as std::os::raw::c_int <= first &&
                           first <= 0x5a as std::os::raw::c_int ||
                           0x61 as std::os::raw::c_int <= first &&
                               first <= 0x7a as std::os::raw::c_int ||
                           0xc0 as std::os::raw::c_int <= first &&
                               first <= 0xd6 as std::os::raw::c_int ||
                           0xd8 as std::os::raw::c_int <= first &&
                               first <= 0xf6 as std::os::raw::c_int ||
                           0xf8 as std::os::raw::c_int <= first) as std::os::raw::c_int
                  } else {
                      xmlCharInRange(first as std::os::raw::c_uint,
                                     &xmlIsBaseCharGroup)
                  }) != 0 ||
                     (if first < 0x100 as std::os::raw::c_int {
                          0 as std::os::raw::c_int
                      } else {
                          (0x4e00 as std::os::raw::c_int <= first &&
                               first <= 0x9fa5 as std::os::raw::c_int ||
                               first == 0x3007 as std::os::raw::c_int ||
                               0x3021 as std::os::raw::c_int <= first &&
                                   first <= 0x3029 as std::os::raw::c_int) as
                              std::os::raw::c_int
                      }) != 0) && first != '_' as i32 {
                xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,
                                  b"Name %s is not XML Namespace compliant\n\x00"
                                      as *const u8 as *const std::os::raw::c_char,
                                  name);
            }
        }
        cur = cur.offset(1);
        while c != 0 as std::os::raw::c_int && len < max {
            /* tested bigname2.xml */
            let fresh48 = len;
            len = len + 1;
            buf[fresh48 as usize] = c as xmlChar;
            let fresh49 = cur;
            cur = cur.offset(1);
            c = *fresh49 as std::os::raw::c_int
        }
        if len >= max {
            /*
	     * Okay someone managed to make a huge name, so he's ready to pay
	     * for the processing speed.
	     */
            max = len * 2 as std::os::raw::c_int;
            buffer =
                xmlMallocAtomic.expect("non-null function pointer")((max as
                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                         as
                                                                                                         std::os::raw::c_ulong))
                    as *mut xmlChar;
            if buffer.is_null() {
                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                return 0 as *mut xmlChar
            }
            memcpy(buffer as *mut std::os::raw::c_void,
                   buf.as_mut_ptr() as *const std::os::raw::c_void,
                   len as std::os::raw::c_ulong);
            while c != 0 as std::os::raw::c_int {
                /* tested bigname2.xml */
                if len + 10 as std::os::raw::c_int > max {
                    let mut tmp_0: *mut xmlChar = 0 as *mut xmlChar;
                    max *= 2 as std::os::raw::c_int;
                    tmp_0 =
                        xmlRealloc.expect("non-null function pointer")(buffer
                                                                           as
                                                                           *mut std::os::raw::c_void,
                                                                       (max as
                                                                            std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                            as
                                                                                                            std::os::raw::c_ulong))
                            as *mut xmlChar;
                    if tmp_0.is_null() {
                        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                        xmlFree.expect("non-null function pointer")(buffer as
                                                                        *mut std::os::raw::c_void);
                        return 0 as *mut xmlChar
                    }
                    buffer = tmp_0
                }
                let fresh50 = len;
                len = len + 1;
                *buffer.offset(fresh50 as isize) = c as xmlChar;
                let fresh51 = cur;
                cur = cur.offset(1);
                c = *fresh51 as std::os::raw::c_int
            }
            *buffer.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar
        }
        if buffer.is_null() {
            ret = xmlStrndup(buf.as_mut_ptr(), len)
        } else { ret = buffer }
    }
    return ret;
}
/* ***********************************************************************
 *									*
 *			The parser itself				*
 *	Relates to http://www.w3.org/TR/REC-xml				*
 *									*
 ************************************************************************/
/* ***********************************************************************
 *									*
 *	Routines to parse Name, NCName and NmToken			*
 *									*
 ************************************************************************/
/*
 * The two following functions are related to the change of accepted
 * characters for Name and NmToken in the Revision 5 of XML-1.0
 * They correspond to the modified production [4] and the new production [4a]
 * changes in that revision. Also note that the macros used for the
 * productions Letter, Digit, CombiningChar and Extender are not needed
 * anymore.
 * We still keep compatibility to pre-revision5 parsing semantic if the
 * new XML_PARSE_OLD10 option is given to the parser.
 */
unsafe extern "C" fn xmlIsNameStartChar(mut ctxt: xmlParserCtxtPtr,
                                        mut c: std::os::raw::c_int) -> std::os::raw::c_int {
    if (*ctxt).options & XML_PARSE_OLD10 as std::os::raw::c_int == 0 as std::os::raw::c_int {
        /*
	 * Use the new checks of production [4] [4a] amd [5] of the
	 * Update 5 of XML-1.0
	 */
        if c != ' ' as i32 && c != '>' as i32 && c != '/' as i32 &&
               (c >= 'a' as i32 && c <= 'z' as i32 ||
                    c >= 'A' as i32 && c <= 'Z' as i32 || c == '_' as i32 ||
                    c == ':' as i32 ||
                    c >= 0xc0 as std::os::raw::c_int && c <= 0xd6 as std::os::raw::c_int ||
                    c >= 0xd8 as std::os::raw::c_int && c <= 0xf6 as std::os::raw::c_int ||
                    c >= 0xf8 as std::os::raw::c_int && c <= 0x2ff as std::os::raw::c_int ||
                    c >= 0x370 as std::os::raw::c_int && c <= 0x37d as std::os::raw::c_int ||
                    c >= 0x37f as std::os::raw::c_int && c <= 0x1fff as std::os::raw::c_int ||
                    c >= 0x200c as std::os::raw::c_int && c <= 0x200d as std::os::raw::c_int
                    ||
                    c >= 0x2070 as std::os::raw::c_int && c <= 0x218f as std::os::raw::c_int
                    ||
                    c >= 0x2c00 as std::os::raw::c_int && c <= 0x2fef as std::os::raw::c_int
                    ||
                    c >= 0x3001 as std::os::raw::c_int && c <= 0xd7ff as std::os::raw::c_int
                    ||
                    c >= 0xf900 as std::os::raw::c_int && c <= 0xfdcf as std::os::raw::c_int
                    ||
                    c >= 0xfdf0 as std::os::raw::c_int && c <= 0xfffd as std::os::raw::c_int
                    ||
                    c >= 0x10000 as std::os::raw::c_int &&
                        c <= 0xeffff as std::os::raw::c_int) {
            return 1 as std::os::raw::c_int
        }
    } else if (if c < 0x100 as std::os::raw::c_int {
                   (0x41 as std::os::raw::c_int <= c && c <= 0x5a as std::os::raw::c_int ||
                        0x61 as std::os::raw::c_int <= c && c <= 0x7a as std::os::raw::c_int
                        ||
                        0xc0 as std::os::raw::c_int <= c && c <= 0xd6 as std::os::raw::c_int
                        ||
                        0xd8 as std::os::raw::c_int <= c && c <= 0xf6 as std::os::raw::c_int
                        || 0xf8 as std::os::raw::c_int <= c) as std::os::raw::c_int
               } else {
                   xmlCharInRange(c as std::os::raw::c_uint, &xmlIsBaseCharGroup)
               }) != 0 ||
                  (if c < 0x100 as std::os::raw::c_int {
                       0 as std::os::raw::c_int
                   } else {
                       (0x4e00 as std::os::raw::c_int <= c &&
                            c <= 0x9fa5 as std::os::raw::c_int ||
                            c == 0x3007 as std::os::raw::c_int ||
                            0x3021 as std::os::raw::c_int <= c &&
                                c <= 0x3029 as std::os::raw::c_int) as std::os::raw::c_int
                   }) != 0 || c == '_' as i32 || c == ':' as i32 {
        return 1 as std::os::raw::c_int
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlIsNameChar(mut ctxt: xmlParserCtxtPtr,
                                   mut c: std::os::raw::c_int) -> std::os::raw::c_int {
    if (*ctxt).options & XML_PARSE_OLD10 as std::os::raw::c_int == 0 as std::os::raw::c_int {
        /*
	 * Use the new checks of production [4] [4a] amd [5] of the
	 * Update 5 of XML-1.0
	 */
        if c != ' ' as i32 && c != '>' as i32 && c != '/' as i32 &&
               (c >= 'a' as i32 && c <= 'z' as i32 ||
                    c >= 'A' as i32 && c <= 'Z' as i32 ||
                    c >= '0' as i32 && c <= '9' as i32 || c == '_' as i32 ||
                    c == ':' as i32 || c == '-' as i32 || c == '.' as i32 ||
                    c == 0xb7 as std::os::raw::c_int ||
                    c >= 0xc0 as std::os::raw::c_int && c <= 0xd6 as std::os::raw::c_int ||
                    c >= 0xd8 as std::os::raw::c_int && c <= 0xf6 as std::os::raw::c_int ||
                    c >= 0xf8 as std::os::raw::c_int && c <= 0x2ff as std::os::raw::c_int ||
                    c >= 0x300 as std::os::raw::c_int && c <= 0x36f as std::os::raw::c_int ||
                    c >= 0x370 as std::os::raw::c_int && c <= 0x37d as std::os::raw::c_int ||
                    c >= 0x37f as std::os::raw::c_int && c <= 0x1fff as std::os::raw::c_int ||
                    c >= 0x200c as std::os::raw::c_int && c <= 0x200d as std::os::raw::c_int
                    ||
                    c >= 0x203f as std::os::raw::c_int && c <= 0x2040 as std::os::raw::c_int
                    ||
                    c >= 0x2070 as std::os::raw::c_int && c <= 0x218f as std::os::raw::c_int
                    ||
                    c >= 0x2c00 as std::os::raw::c_int && c <= 0x2fef as std::os::raw::c_int
                    ||
                    c >= 0x3001 as std::os::raw::c_int && c <= 0xd7ff as std::os::raw::c_int
                    ||
                    c >= 0xf900 as std::os::raw::c_int && c <= 0xfdcf as std::os::raw::c_int
                    ||
                    c >= 0xfdf0 as std::os::raw::c_int && c <= 0xfffd as std::os::raw::c_int
                    ||
                    c >= 0x10000 as std::os::raw::c_int &&
                        c <= 0xeffff as std::os::raw::c_int) {
            return 1 as std::os::raw::c_int
        }
    } else if (if c < 0x100 as std::os::raw::c_int {
                   (0x41 as std::os::raw::c_int <= c && c <= 0x5a as std::os::raw::c_int ||
                        0x61 as std::os::raw::c_int <= c && c <= 0x7a as std::os::raw::c_int
                        ||
                        0xc0 as std::os::raw::c_int <= c && c <= 0xd6 as std::os::raw::c_int
                        ||
                        0xd8 as std::os::raw::c_int <= c && c <= 0xf6 as std::os::raw::c_int
                        || 0xf8 as std::os::raw::c_int <= c) as std::os::raw::c_int
               } else {
                   xmlCharInRange(c as std::os::raw::c_uint, &xmlIsBaseCharGroup)
               }) != 0 ||
                  (if c < 0x100 as std::os::raw::c_int {
                       0 as std::os::raw::c_int
                   } else {
                       (0x4e00 as std::os::raw::c_int <= c &&
                            c <= 0x9fa5 as std::os::raw::c_int ||
                            c == 0x3007 as std::os::raw::c_int ||
                            0x3021 as std::os::raw::c_int <= c &&
                                c <= 0x3029 as std::os::raw::c_int) as std::os::raw::c_int
                   }) != 0 ||
                  (if c < 0x100 as std::os::raw::c_int {
                       (0x30 as std::os::raw::c_int <= c && c <= 0x39 as std::os::raw::c_int)
                           as std::os::raw::c_int
                   } else {
                       xmlCharInRange(c as std::os::raw::c_uint, &xmlIsDigitGroup)
                   }) != 0 || c == '.' as i32 || c == '-' as i32 ||
                  c == '_' as i32 || c == ':' as i32 ||
                  (if c < 0x100 as std::os::raw::c_int {
                       0 as std::os::raw::c_int
                   } else {
                       xmlCharInRange(c as std::os::raw::c_uint, &xmlIsCombiningGroup)
                   }) != 0 ||
                  (if c < 0x100 as std::os::raw::c_int {
                       (c == 0xb7 as std::os::raw::c_int) as std::os::raw::c_int
                   } else {
                       xmlCharInRange(c as std::os::raw::c_uint, &xmlIsExtenderGroup)
                   }) != 0 {
        return 1 as std::os::raw::c_int
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xmlParseNameComplex(mut ctxt: xmlParserCtxtPtr)
 -> *const xmlChar {
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut l: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_int = 0;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
     * Handler for more complex cases
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return 0 as *const xmlChar
    }
    c = xmlCurrentChar(ctxt, &mut l);
    if (*ctxt).options & XML_PARSE_OLD10 as std::os::raw::c_int == 0 as std::os::raw::c_int {
        /*
	 * Use the new checks of production [4] [4a] amd [5] of the
	 * Update 5 of XML-1.0
	 */
        if c == ' ' as i32 || c == '>' as i32 || c == '/' as i32 ||
               !(c >= 'a' as i32 && c <= 'z' as i32 ||
                     c >= 'A' as i32 && c <= 'Z' as i32 || c == '_' as i32 ||
                     c == ':' as i32 ||
                     c >= 0xc0 as std::os::raw::c_int && c <= 0xd6 as std::os::raw::c_int ||
                     c >= 0xd8 as std::os::raw::c_int && c <= 0xf6 as std::os::raw::c_int ||
                     c >= 0xf8 as std::os::raw::c_int && c <= 0x2ff as std::os::raw::c_int ||
                     c >= 0x370 as std::os::raw::c_int && c <= 0x37d as std::os::raw::c_int ||
                     c >= 0x37f as std::os::raw::c_int && c <= 0x1fff as std::os::raw::c_int
                     ||
                     c >= 0x200c as std::os::raw::c_int && c <= 0x200d as std::os::raw::c_int
                     ||
                     c >= 0x2070 as std::os::raw::c_int && c <= 0x218f as std::os::raw::c_int
                     ||
                     c >= 0x2c00 as std::os::raw::c_int && c <= 0x2fef as std::os::raw::c_int
                     ||
                     c >= 0x3001 as std::os::raw::c_int && c <= 0xd7ff as std::os::raw::c_int
                     ||
                     c >= 0xf900 as std::os::raw::c_int && c <= 0xfdcf as std::os::raw::c_int
                     ||
                     c >= 0xfdf0 as std::os::raw::c_int && c <= 0xfffd as std::os::raw::c_int
                     ||
                     c >= 0x10000 as std::os::raw::c_int &&
                         c <= 0xeffff as std::os::raw::c_int) {
            return 0 as *const xmlChar
        }
        len += l;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        c = xmlCurrentChar(ctxt, &mut l);
        while c != ' ' as i32 && c != '>' as i32 && c != '/' as i32 &&
                  (c >= 'a' as i32 && c <= 'z' as i32 ||
                       c >= 'A' as i32 && c <= 'Z' as i32 ||
                       c >= '0' as i32 && c <= '9' as i32 || c == '_' as i32
                       || c == ':' as i32 || c == '-' as i32 ||
                       c == '.' as i32 || c == 0xb7 as std::os::raw::c_int ||
                       c >= 0xc0 as std::os::raw::c_int && c <= 0xd6 as std::os::raw::c_int ||
                       c >= 0xd8 as std::os::raw::c_int && c <= 0xf6 as std::os::raw::c_int ||
                       c >= 0xf8 as std::os::raw::c_int && c <= 0x2ff as std::os::raw::c_int
                       ||
                       c >= 0x300 as std::os::raw::c_int && c <= 0x36f as std::os::raw::c_int
                       ||
                       c >= 0x370 as std::os::raw::c_int && c <= 0x37d as std::os::raw::c_int
                       ||
                       c >= 0x37f as std::os::raw::c_int && c <= 0x1fff as std::os::raw::c_int
                       ||
                       c >= 0x200c as std::os::raw::c_int &&
                           c <= 0x200d as std::os::raw::c_int ||
                       c >= 0x203f as std::os::raw::c_int &&
                           c <= 0x2040 as std::os::raw::c_int ||
                       c >= 0x2070 as std::os::raw::c_int &&
                           c <= 0x218f as std::os::raw::c_int ||
                       c >= 0x2c00 as std::os::raw::c_int &&
                           c <= 0x2fef as std::os::raw::c_int ||
                       c >= 0x3001 as std::os::raw::c_int &&
                           c <= 0xd7ff as std::os::raw::c_int ||
                       c >= 0xf900 as std::os::raw::c_int &&
                           c <= 0xfdcf as std::os::raw::c_int ||
                       c >= 0xfdf0 as std::os::raw::c_int &&
                           c <= 0xfffd as std::os::raw::c_int ||
                       c >= 0x10000 as std::os::raw::c_int &&
                           c <= 0xeffff as std::os::raw::c_int) {
            let fresh52 = count;
            count = count + 1;
            if fresh52 > 100 as std::os::raw::c_int {
                count = 0 as std::os::raw::c_int;
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    return 0 as *const xmlChar
                }
            }
            len += l;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                (*(*ctxt).input).line += 1;
                (*(*ctxt).input).col = 1 as std::os::raw::c_int
            } else { (*(*ctxt).input).col += 1 }
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
            c = xmlCurrentChar(ctxt, &mut l)
        }
    } else {
        if c == ' ' as i32 || c == '>' as i32 || c == '/' as i32 ||
               !((if c < 0x100 as std::os::raw::c_int {
                      (0x41 as std::os::raw::c_int <= c && c <= 0x5a as std::os::raw::c_int ||
                           0x61 as std::os::raw::c_int <= c &&
                               c <= 0x7a as std::os::raw::c_int ||
                           0xc0 as std::os::raw::c_int <= c &&
                               c <= 0xd6 as std::os::raw::c_int ||
                           0xd8 as std::os::raw::c_int <= c &&
                               c <= 0xf6 as std::os::raw::c_int ||
                           0xf8 as std::os::raw::c_int <= c) as std::os::raw::c_int
                  } else {
                      xmlCharInRange(c as std::os::raw::c_uint, &xmlIsBaseCharGroup)
                  }) != 0 ||
                     (if c < 0x100 as std::os::raw::c_int {
                          0 as std::os::raw::c_int
                      } else {
                          (0x4e00 as std::os::raw::c_int <= c &&
                               c <= 0x9fa5 as std::os::raw::c_int ||
                               c == 0x3007 as std::os::raw::c_int ||
                               0x3021 as std::os::raw::c_int <= c &&
                                   c <= 0x3029 as std::os::raw::c_int) as std::os::raw::c_int
                      }) != 0) && c != '_' as i32 && c != ':' as i32 {
            return 0 as *const xmlChar
        }
        len += l;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        c = xmlCurrentChar(ctxt, &mut l);
        while c != ' ' as i32 && c != '>' as i32 && c != '/' as i32 &&
                  ((if c < 0x100 as std::os::raw::c_int {
                        (0x41 as std::os::raw::c_int <= c && c <= 0x5a as std::os::raw::c_int
                             ||
                             0x61 as std::os::raw::c_int <= c &&
                                 c <= 0x7a as std::os::raw::c_int ||
                             0xc0 as std::os::raw::c_int <= c &&
                                 c <= 0xd6 as std::os::raw::c_int ||
                             0xd8 as std::os::raw::c_int <= c &&
                                 c <= 0xf6 as std::os::raw::c_int ||
                             0xf8 as std::os::raw::c_int <= c) as std::os::raw::c_int
                    } else {
                        xmlCharInRange(c as std::os::raw::c_uint, &xmlIsBaseCharGroup)
                    }) != 0 ||
                       (if c < 0x100 as std::os::raw::c_int {
                            0 as std::os::raw::c_int
                        } else {
                            (0x4e00 as std::os::raw::c_int <= c &&
                                 c <= 0x9fa5 as std::os::raw::c_int ||
                                 c == 0x3007 as std::os::raw::c_int ||
                                 0x3021 as std::os::raw::c_int <= c &&
                                     c <= 0x3029 as std::os::raw::c_int) as
                                std::os::raw::c_int
                        }) != 0 ||
                       (if c < 0x100 as std::os::raw::c_int {
                            (0x30 as std::os::raw::c_int <= c &&
                                 c <= 0x39 as std::os::raw::c_int) as std::os::raw::c_int
                        } else {
                            xmlCharInRange(c as std::os::raw::c_uint,
                                           &xmlIsDigitGroup)
                        }) != 0 || c == '.' as i32 || c == '-' as i32 ||
                       c == '_' as i32 || c == ':' as i32 ||
                       (if c < 0x100 as std::os::raw::c_int {
                            0 as std::os::raw::c_int
                        } else {
                            xmlCharInRange(c as std::os::raw::c_uint,
                                           &xmlIsCombiningGroup)
                        }) != 0 ||
                       (if c < 0x100 as std::os::raw::c_int {
                            (c == 0xb7 as std::os::raw::c_int) as std::os::raw::c_int
                        } else {
                            xmlCharInRange(c as std::os::raw::c_uint,
                                           &xmlIsExtenderGroup)
                        }) != 0) {
            let fresh53 = count;
            count = count + 1;
            if fresh53 > 100 as std::os::raw::c_int {
                count = 0 as std::os::raw::c_int;
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    return 0 as *const xmlChar
                }
            }
            len += l;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                (*(*ctxt).input).line += 1;
                (*(*ctxt).input).col = 1 as std::os::raw::c_int
            } else { (*(*ctxt).input).col += 1 }
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
            c = xmlCurrentChar(ctxt, &mut l)
        }
    }
    if len > 50000 as std::os::raw::c_int &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
       {
        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                    b"Name\x00" as *const u8 as *const std::os::raw::c_char);
        return 0 as *const xmlChar
    }
    if ((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
            std::os::raw::c_long) < len as std::os::raw::c_long {
        /*
         * There were a couple of bugs where PERefs lead to to a change
         * of the buffer. Check the buffer size to avoid passing an invalid
         * pointer to xmlDictLookup.
         */
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    b"unexpected change of input buffer\x00" as *const u8 as
                        *const std::os::raw::c_char);
        return 0 as *const xmlChar
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 &&
           *(*(*ctxt).input).cur.offset(-(1 as std::os::raw::c_int) as isize) as
               std::os::raw::c_int == '\r' as i32 {
        return xmlDictLookup((*ctxt).dict,
                             (*(*ctxt).input).cur.offset(-((len +
                                                                1 as
                                                                    std::os::raw::c_int)
                                                               as isize)),
                             len)
    }
    return xmlDictLookup((*ctxt).dict,
                         (*(*ctxt).input).cur.offset(-(len as isize)), len);
}
/* *
 * Generic production rules.
 */
/* *
 * xmlParseName:
 * @ctxt:  an XML parser context
 *
 * parse an XML name.
 *
 * [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' |
 *                  CombiningChar | Extender
 *
 * [5] Name ::= (Letter | '_' | ':') (NameChar)*
 *
 * [6] Names ::= Name (#x20 Name)*
 *
 * Returns the Name parsed or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseName(mut ctxt: xmlParserCtxtPtr)
 -> *const xmlChar {
    let mut in_0: *const xmlChar = 0 as *const xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    /*
     * Accelerator for simple ASCII names
     */
    in_0 = (*(*ctxt).input).cur;
    if *in_0 as std::os::raw::c_int >= 0x61 as std::os::raw::c_int &&
           *in_0 as std::os::raw::c_int <= 0x7a as std::os::raw::c_int ||
           *in_0 as std::os::raw::c_int >= 0x41 as std::os::raw::c_int &&
               *in_0 as std::os::raw::c_int <= 0x5a as std::os::raw::c_int ||
           *in_0 as std::os::raw::c_int == '_' as i32 ||
           *in_0 as std::os::raw::c_int == ':' as i32 {
        in_0 = in_0.offset(1);
        while *in_0 as std::os::raw::c_int >= 0x61 as std::os::raw::c_int &&
                  *in_0 as std::os::raw::c_int <= 0x7a as std::os::raw::c_int ||
                  *in_0 as std::os::raw::c_int >= 0x41 as std::os::raw::c_int &&
                      *in_0 as std::os::raw::c_int <= 0x5a as std::os::raw::c_int ||
                  *in_0 as std::os::raw::c_int >= 0x30 as std::os::raw::c_int &&
                      *in_0 as std::os::raw::c_int <= 0x39 as std::os::raw::c_int ||
                  *in_0 as std::os::raw::c_int == '_' as i32 ||
                  *in_0 as std::os::raw::c_int == '-' as i32 ||
                  *in_0 as std::os::raw::c_int == ':' as i32 ||
                  *in_0 as std::os::raw::c_int == '.' as i32 {
            in_0 = in_0.offset(1)
        }
        if *in_0 as std::os::raw::c_int > 0 as std::os::raw::c_int &&
               (*in_0 as std::os::raw::c_int) < 0x80 as std::os::raw::c_int {
            count =
                in_0.offset_from((*(*ctxt).input).cur) as
                    std::os::raw::c_long as std::os::raw::c_int;
            if count > 50000 as std::os::raw::c_int &&
                   (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                            b"Name\x00" as *const u8 as *const std::os::raw::c_char);
                return 0 as *const xmlChar
            }
            ret = xmlDictLookup((*ctxt).dict, (*(*ctxt).input).cur, count);
            (*(*ctxt).input).cur = in_0;
            (*ctxt).nbChars += count as std::os::raw::c_long;
            (*(*ctxt).input).col += count;
            if ret.is_null() { xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char); }
            return ret
        }
    }
    /* accelerator for special cases */
    return xmlParseNameComplex(ctxt);
}
unsafe extern "C" fn xmlParseNCNameComplex(mut ctxt: xmlParserCtxtPtr)
 -> *const xmlChar {
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut l: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_int = 0;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut startPosition: size_t = 0 as std::os::raw::c_int as size_t;
    /*
     * Handler for more complex cases
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    startPosition =
        (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
            std::os::raw::c_long as size_t;
    c = xmlCurrentChar(ctxt, &mut l);
    if c == ' ' as i32 || c == '>' as i32 || c == '/' as i32 ||
           (xmlIsNameStartChar(ctxt, c) == 0 || c == ':' as i32) {
        return 0 as *const xmlChar
    }
    while c != ' ' as i32 && c != '>' as i32 && c != '/' as i32 &&
              (xmlIsNameChar(ctxt, c) != 0 && c != ':' as i32) {
        let fresh54 = count;
        count = count + 1;
        if fresh54 > 100 as std::os::raw::c_int {
            if len > 50000 as std::os::raw::c_int &&
                   (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                            b"NCName\x00" as *const u8 as
                                *const std::os::raw::c_char);
                return 0 as *const xmlChar
            }
            count = 0 as std::os::raw::c_int;
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                return 0 as *const xmlChar
            }
        }
        len += l;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        c = xmlCurrentChar(ctxt, &mut l);
        if c == 0 as std::os::raw::c_int {
            count = 0 as std::os::raw::c_int;
            /*
	     * when shrinking to extend the buffer we really need to preserve
	     * the part of the name we already parsed. Hence rolling back
	     * by current lenght.
	     */
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(-(l as isize));
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                return 0 as *const xmlChar
            }
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
            c = xmlCurrentChar(ctxt, &mut l)
        }
    }
    if len > 50000 as std::os::raw::c_int &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
       {
        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                    b"NCName\x00" as *const u8 as *const std::os::raw::c_char);
        return 0 as *const xmlChar
    }
    return xmlDictLookup((*ctxt).dict,
                         (*(*ctxt).input).base.offset(startPosition as isize),
                         len);
}
/* *
 * xmlParseNCName:
 * @ctxt:  an XML parser context
 * @len:  length of the string parsed
 *
 * parse an XML name.
 *
 * [4NS] NCNameChar ::= Letter | Digit | '.' | '-' | '_' |
 *                      CombiningChar | Extender
 *
 * [5NS] NCName ::= (Letter | '_') (NCNameChar)*
 *
 * Returns the Name parsed or NULL
 */
unsafe extern "C" fn xmlParseNCName(mut ctxt: xmlParserCtxtPtr)
 -> *const xmlChar {
    let mut in_0: *const xmlChar = 0 as *const xmlChar;
    let mut e: *const xmlChar = 0 as *const xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /*
     * Accelerator for simple ASCII names
     */
    in_0 = (*(*ctxt).input).cur;
    e = (*(*ctxt).input).end;
    if (*in_0 as std::os::raw::c_int >= 0x61 as std::os::raw::c_int &&
            *in_0 as std::os::raw::c_int <= 0x7a as std::os::raw::c_int ||
            *in_0 as std::os::raw::c_int >= 0x41 as std::os::raw::c_int &&
                *in_0 as std::os::raw::c_int <= 0x5a as std::os::raw::c_int ||
            *in_0 as std::os::raw::c_int == '_' as i32) && in_0 < e {
        in_0 = in_0.offset(1);
        while (*in_0 as std::os::raw::c_int >= 0x61 as std::os::raw::c_int &&
                   *in_0 as std::os::raw::c_int <= 0x7a as std::os::raw::c_int ||
                   *in_0 as std::os::raw::c_int >= 0x41 as std::os::raw::c_int &&
                       *in_0 as std::os::raw::c_int <= 0x5a as std::os::raw::c_int ||
                   *in_0 as std::os::raw::c_int >= 0x30 as std::os::raw::c_int &&
                       *in_0 as std::os::raw::c_int <= 0x39 as std::os::raw::c_int ||
                   *in_0 as std::os::raw::c_int == '_' as i32 ||
                   *in_0 as std::os::raw::c_int == '-' as i32 ||
                   *in_0 as std::os::raw::c_int == '.' as i32) && in_0 < e {
            in_0 = in_0.offset(1)
        }
        if !(in_0 >= e) {
            if *in_0 as std::os::raw::c_int > 0 as std::os::raw::c_int &&
                   (*in_0 as std::os::raw::c_int) < 0x80 as std::os::raw::c_int {
                count =
                    in_0.offset_from((*(*ctxt).input).cur) as
                        std::os::raw::c_long as std::os::raw::c_int;
                if count > 50000 as std::os::raw::c_int &&
                       (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                    xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                                b"NCName\x00" as *const u8 as
                                    *const std::os::raw::c_char);
                    return 0 as *const xmlChar
                }
                ret =
                    xmlDictLookup((*ctxt).dict, (*(*ctxt).input).cur, count);
                (*(*ctxt).input).cur = in_0;
                (*ctxt).nbChars += count as std::os::raw::c_long;
                (*(*ctxt).input).col += count;
                if ret.is_null() {
                    xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                }
                return ret
            }
        }
    }
    return xmlParseNCNameComplex(ctxt);
}
/* *
 * xmlParseNameAndCompare:
 * @ctxt:  an XML parser context
 *
 * parse an XML name and compares for match
 * (specialized for endtag parsing)
 *
 * Returns NULL for an illegal name, (xmlChar*) 1 for success
 * and the name for mismatch
 */
unsafe extern "C" fn xmlParseNameAndCompare(mut ctxt: xmlParserCtxtPtr,
                                            mut other: *const xmlChar)
 -> *const xmlChar {
    let mut cmp: *const xmlChar = other;
    let mut in_0: *const xmlChar = 0 as *const xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return 0 as *const xmlChar
    }
    in_0 = (*(*ctxt).input).cur;
    while *in_0 as std::os::raw::c_int != 0 as std::os::raw::c_int &&
              *in_0 as std::os::raw::c_int == *cmp as std::os::raw::c_int {
        in_0 = in_0.offset(1);
        cmp = cmp.offset(1);
        (*(*ctxt).input).col += 1
    }
    if *cmp as std::os::raw::c_int == 0 as std::os::raw::c_int &&
           (*in_0 as std::os::raw::c_int == '>' as i32 ||
                (*in_0 as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                     0x9 as std::os::raw::c_int <= *in_0 as std::os::raw::c_int &&
                         *in_0 as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                     *in_0 as std::os::raw::c_int == 0xd as std::os::raw::c_int)) {
        /* success */
        (*(*ctxt).input).cur = in_0;
        return 1 as std::os::raw::c_int as *const xmlChar
    }
    /* failure (or end of input buffer), check with full function */
    ret = xmlParseName(ctxt);
    /* strings coming from the dictionary direct compare possible */
    if ret == other { return 1 as std::os::raw::c_int as *const xmlChar }
    return ret;
}
/* *
 * xmlParseStringName:
 * @ctxt:  an XML parser context
 * @str:  a pointer to the string pointer (IN/OUT)
 *
 * parse an XML name.
 *
 * [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' |
 *                  CombiningChar | Extender
 *
 * [5] Name ::= (Letter | '_' | ':') (NameChar)*
 *
 * [6] Names ::= Name (#x20 Name)*
 *
 * Returns the Name parsed or NULL. The @str pointer
 * is updated to the current location in the string.
 */
unsafe extern "C" fn xmlParseStringName(mut ctxt: xmlParserCtxtPtr,
                                        mut str: *mut *const xmlChar)
 -> *mut xmlChar {
    let mut buf: [xmlChar; 105] = [0; 105];
    let mut cur: *const xmlChar = *str;
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut l: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_int = 0;
    c = xmlStringCurrentChar(ctxt, cur, &mut l);
    if xmlIsNameStartChar(ctxt, c) == 0 { return 0 as *mut xmlChar }
    if l == 1 as std::os::raw::c_int {
        let fresh55 = len;
        len = len + 1;
        buf[fresh55 as usize] = c as xmlChar
    } else {
        len +=
            xmlCopyCharMultiByte(&mut *buf.as_mut_ptr().offset(len as isize),
                                 c)
    }
    cur = cur.offset(l as isize);
    c = xmlStringCurrentChar(ctxt, cur, &mut l);
    while xmlIsNameChar(ctxt, c) != 0 {
        if l == 1 as std::os::raw::c_int {
            let fresh56 = len;
            len = len + 1;
            buf[fresh56 as usize] = c as xmlChar
        } else {
            len +=
                xmlCopyCharMultiByte(&mut *buf.as_mut_ptr().offset(len as
                                                                       isize),
                                     c)
        }
        cur = cur.offset(l as isize);
        c = xmlStringCurrentChar(ctxt, cur, &mut l);
        if len >= 100 as std::os::raw::c_int {
            /* test bigentname.xml */
            /*
	     * Okay someone managed to make a huge name, so he's ready to pay
	     * for the processing speed.
	     */
            let mut buffer: *mut xmlChar = 0 as *mut xmlChar;
            let mut max: std::os::raw::c_int = len * 2 as std::os::raw::c_int;
            buffer =
                xmlMallocAtomic.expect("non-null function pointer")((max as
                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                         as
                                                                                                         std::os::raw::c_ulong))
                    as *mut xmlChar;
            if buffer.is_null() {
                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                return 0 as *mut xmlChar
            }
            memcpy(buffer as *mut std::os::raw::c_void,
                   buf.as_mut_ptr() as *const std::os::raw::c_void,
                   len as std::os::raw::c_ulong);
            while xmlIsNameChar(ctxt, c) != 0 {
                if len + 10 as std::os::raw::c_int > max {
                    let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                    if len > 50000 as std::os::raw::c_int &&
                           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                                    b"NCName\x00" as *const u8 as
                                        *const std::os::raw::c_char);
                        xmlFree.expect("non-null function pointer")(buffer as
                                                                        *mut std::os::raw::c_void);
                        return 0 as *mut xmlChar
                    }
                    max *= 2 as std::os::raw::c_int;
                    tmp =
                        xmlRealloc.expect("non-null function pointer")(buffer
                                                                           as
                                                                           *mut std::os::raw::c_void,
                                                                       (max as
                                                                            std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                            as
                                                                                                            std::os::raw::c_ulong))
                            as *mut xmlChar;
                    if tmp.is_null() {
                        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                        xmlFree.expect("non-null function pointer")(buffer as
                                                                        *mut std::os::raw::c_void);
                        return 0 as *mut xmlChar
                    }
                    buffer = tmp
                }
                if l == 1 as std::os::raw::c_int {
                    let fresh57 = len;
                    len = len + 1;
                    *buffer.offset(fresh57 as isize) = c as xmlChar
                } else {
                    len +=
                        xmlCopyCharMultiByte(&mut *buffer.offset(len as
                                                                     isize),
                                             c)
                }
                cur = cur.offset(l as isize);
                c = xmlStringCurrentChar(ctxt, cur, &mut l)
            }
            *buffer.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
            *str = cur;
            return buffer
        }
    }
    if len > 50000 as std::os::raw::c_int &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
       {
        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                    b"NCName\x00" as *const u8 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    *str = cur;
    return xmlStrndup(buf.as_mut_ptr(), len);
}
/* *
 * xmlParseNmtoken:
 * @ctxt:  an XML parser context
 *
 * parse an XML Nmtoken.
 *
 * [7] Nmtoken ::= (NameChar)+
 *
 * [8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*
 *
 * Returns the Nmtoken parsed or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseNmtoken(mut ctxt: xmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut buf: [xmlChar; 105] = [0; 105];
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut l: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_int = 0;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return 0 as *mut xmlChar
    }
    c = xmlCurrentChar(ctxt, &mut l);
    while xmlIsNameChar(ctxt, c) != 0 {
        let fresh58 = count;
        count = count + 1;
        if fresh58 > 100 as std::os::raw::c_int {
            count = 0 as std::os::raw::c_int;
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
        }
        if l == 1 as std::os::raw::c_int {
            let fresh59 = len;
            len = len + 1;
            buf[fresh59 as usize] = c as xmlChar
        } else {
            len +=
                xmlCopyCharMultiByte(&mut *buf.as_mut_ptr().offset(len as
                                                                       isize),
                                     c)
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        c = xmlCurrentChar(ctxt, &mut l);
        if c == 0 as std::os::raw::c_int {
            count = 0 as std::os::raw::c_int;
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                return 0 as *mut xmlChar
            }
            c = xmlCurrentChar(ctxt, &mut l)
        }
        if len >= 100 as std::os::raw::c_int {
            /*
	     * Okay someone managed to make a huge token, so he's ready to pay
	     * for the processing speed.
	     */
            let mut buffer: *mut xmlChar = 0 as *mut xmlChar;
            let mut max: std::os::raw::c_int = len * 2 as std::os::raw::c_int;
            buffer =
                xmlMallocAtomic.expect("non-null function pointer")((max as
                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                         as
                                                                                                         std::os::raw::c_ulong))
                    as *mut xmlChar;
            if buffer.is_null() {
                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                return 0 as *mut xmlChar
            }
            memcpy(buffer as *mut std::os::raw::c_void,
                   buf.as_mut_ptr() as *const std::os::raw::c_void,
                   len as std::os::raw::c_ulong);
            while xmlIsNameChar(ctxt, c) != 0 {
                let fresh60 = count;
                count = count + 1;
                if fresh60 > 100 as std::os::raw::c_int {
                    count = 0 as std::os::raw::c_int;
                    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               250 as std::os::raw::c_int as std::os::raw::c_long {
                        xmlGROW(ctxt);
                    }
                    if (*ctxt).instate as std::os::raw::c_int ==
                           XML_PARSER_EOF as std::os::raw::c_int {
                        xmlFree.expect("non-null function pointer")(buffer as
                                                                        *mut std::os::raw::c_void);
                        return 0 as *mut xmlChar
                    }
                }
                if len + 10 as std::os::raw::c_int > max {
                    let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                    if max > 50000 as std::os::raw::c_int &&
                           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                                    b"NmToken\x00" as *const u8 as
                                        *const std::os::raw::c_char);
                        xmlFree.expect("non-null function pointer")(buffer as
                                                                        *mut std::os::raw::c_void);
                        return 0 as *mut xmlChar
                    }
                    max *= 2 as std::os::raw::c_int;
                    tmp =
                        xmlRealloc.expect("non-null function pointer")(buffer
                                                                           as
                                                                           *mut std::os::raw::c_void,
                                                                       (max as
                                                                            std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                            as
                                                                                                            std::os::raw::c_ulong))
                            as *mut xmlChar;
                    if tmp.is_null() {
                        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                        xmlFree.expect("non-null function pointer")(buffer as
                                                                        *mut std::os::raw::c_void);
                        return 0 as *mut xmlChar
                    }
                    buffer = tmp
                }
                if l == 1 as std::os::raw::c_int {
                    let fresh61 = len;
                    len = len + 1;
                    *buffer.offset(fresh61 as isize) = c as xmlChar
                } else {
                    len +=
                        xmlCopyCharMultiByte(&mut *buffer.offset(len as
                                                                     isize),
                                             c)
                }
                if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                    (*(*ctxt).input).line += 1;
                    (*(*ctxt).input).col = 1 as std::os::raw::c_int
                } else { (*(*ctxt).input).col += 1 }
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(l as isize);
                c = xmlCurrentChar(ctxt, &mut l)
            }
            *buffer.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
            return buffer
        }
    }
    if len == 0 as std::os::raw::c_int { return 0 as *mut xmlChar }
    if len > 50000 as std::os::raw::c_int &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
       {
        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                    b"NmToken\x00" as *const u8 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    return xmlStrndup(buf.as_mut_ptr(), len);
}
/* *
 * xmlParseEntityValue:
 * @ctxt:  an XML parser context
 * @orig:  if non-NULL store a copy of the original entity value
 *
 * parse a value for ENTITY declarations
 *
 * [9] EntityValue ::= '"' ([^%&"] | PEReference | Reference)* '"' |
 *	               "'" ([^%&'] | PEReference | Reference)* "'"
 *
 * Returns the EntityValue parsed with reference substituted or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseEntityValue(mut ctxt: xmlParserCtxtPtr,
                                             mut orig: *mut *mut xmlChar)
 -> *mut xmlChar {
    let mut current_block: u64;
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut size: std::os::raw::c_int = 100 as std::os::raw::c_int;
    let mut c: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut stop: xmlChar = 0;
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 {
        stop = '\"' as i32 as xmlChar
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
        stop = '\'' as i32 as xmlChar
    } else {
        xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_STARTED,
                    0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    buf =
        xmlMallocAtomic.expect("non-null function pointer")((size as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if buf.is_null() {
        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    /*
     * The content of the entity definition is copied in a buffer.
     */
    (*ctxt).instate = XML_PARSER_ENTITY_VALUE;
    input = (*ctxt).input;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if !((*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int) {
        xmlNextChar(ctxt);
        c = xmlCurrentChar(ctxt, &mut l);
        loop 
             /*
     * NOTE: 4.4.5 Included in Literal
     * When a parameter entity reference appears in a literal entity
     * value, ... a single or double quote character in the replacement
     * text is always treated as a normal data character and will not
     * terminate the literal.
     * In practice it means we stop the loop only when back at parsing
     * the initial entity and the quote is found
     */
             {
            if !((if c < 0x100 as std::os::raw::c_int {
                      (0x9 as std::os::raw::c_int <= c && c <= 0xa as std::os::raw::c_int ||
                           c == 0xd as std::os::raw::c_int ||
                           0x20 as std::os::raw::c_int <= c) as std::os::raw::c_int
                  } else {
                      (0x100 as std::os::raw::c_int <= c && c <= 0xd7ff as std::os::raw::c_int
                           ||
                           0xe000 as std::os::raw::c_int <= c &&
                               c <= 0xfffd as std::os::raw::c_int ||
                           0x10000 as std::os::raw::c_int <= c &&
                               c <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
                  }) != 0 &&
                     (c != stop as std::os::raw::c_int || (*ctxt).input != input) &&
                     (*ctxt).instate as std::os::raw::c_int !=
                         XML_PARSER_EOF as std::os::raw::c_int) {
                current_block = 13460095289871124136;
                break ;
            }
            if len + 5 as std::os::raw::c_int >= size {
                let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                size *= 2 as std::os::raw::c_int;
                tmp =
                    xmlRealloc.expect("non-null function pointer")(buf as
                                                                       *mut std::os::raw::c_void,
                                                                   (size as
                                                                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                        as
                                                                                                        std::os::raw::c_ulong))
                        as *mut xmlChar;
                if tmp.is_null() {
                    xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                    current_block = 11865487451399355971;
                    break ;
                } else { buf = tmp }
            }
            if l == 1 as std::os::raw::c_int {
                let fresh62 = len;
                len = len + 1;
                *buf.offset(fresh62 as isize) = c as xmlChar
            } else {
                len += xmlCopyCharMultiByte(&mut *buf.offset(len as isize), c)
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                (*(*ctxt).input).line += 1;
                (*(*ctxt).input).col = 1 as std::os::raw::c_int
            } else { (*(*ctxt).input).col += 1 }
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            c = xmlCurrentChar(ctxt, &mut l);
            if c == 0 as std::os::raw::c_int {
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                c = xmlCurrentChar(ctxt, &mut l)
            }
        }
        match current_block {
            11865487451399355971 => { }
            _ => {
                *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
                if !((*ctxt).instate as std::os::raw::c_int ==
                         XML_PARSER_EOF as std::os::raw::c_int) {
                    if c != stop as std::os::raw::c_int {
                        xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
                                    0 as *const std::os::raw::c_char);
                    } else {
                        xmlNextChar(ctxt);
                        /*
     * Raise problem w.r.t. '&' and '%' being used in non-entities
     * reference constructs. Note Charref will be handled in
     * xmlStringDecodeEntities()
     */
                        cur = buf;
                        loop  {
                            if !(*cur as std::os::raw::c_int != 0 as std::os::raw::c_int) {
                                current_block = 7158658067966855297;
                                break ;
                            }
                            /* non input consuming */
                            if *cur as std::os::raw::c_int == '%' as i32 ||
                                   *cur as std::os::raw::c_int == '&' as i32 &&
                                       *cur.offset(1 as std::os::raw::c_int as isize)
                                           as std::os::raw::c_int != '#' as i32 {
                                let mut name: *mut xmlChar =
                                    0 as *mut xmlChar;
                                let mut tmp_0: xmlChar = *cur;
                                let mut nameOk: std::os::raw::c_int =
                                    0 as std::os::raw::c_int;
                                cur = cur.offset(1);
                                name = xmlParseStringName(ctxt, &mut cur);
                                if !name.is_null() {
                                    nameOk = 1 as std::os::raw::c_int;
                                    xmlFree.expect("non-null function pointer")(name
                                                                                    as
                                                                                    *mut std::os::raw::c_void);
                                }
                                if nameOk == 0 as std::os::raw::c_int ||
                                       *cur as std::os::raw::c_int != ';' as i32 {
                                    xmlFatalErrMsgInt(ctxt,
                                                      XML_ERR_ENTITY_CHAR_ERROR,
                                                      b"EntityValue: \'%c\' forbidden except for entities references\n\x00"
                                                          as *const u8 as
                                                          *const std::os::raw::c_char,
                                                      tmp_0 as std::os::raw::c_int);
                                    current_block = 11865487451399355971;
                                    break ;
                                } else if tmp_0 as std::os::raw::c_int == '%' as i32
                                              &&
                                              (*ctxt).inSubset ==
                                                  1 as std::os::raw::c_int &&
                                              (*ctxt).inputNr ==
                                                  1 as std::os::raw::c_int {
                                    xmlFatalErr(ctxt,
                                                XML_ERR_ENTITY_PE_INTERNAL,
                                                0 as *const std::os::raw::c_char);
                                    current_block = 11865487451399355971;
                                    break ;
                                } else if *cur as std::os::raw::c_int ==
                                              0 as std::os::raw::c_int {
                                    current_block = 7158658067966855297;
                                    break ;
                                }
                            }
                            cur = cur.offset(1)
                        }
                        match current_block {
                            11865487451399355971 => { }
                            _ => {
                                /*
     * Then PEReference entities are substituted.
     *
     * NOTE: 4.4.7 Bypassed
     * When a general entity reference appears in the EntityValue in
     * an entity declaration, it is bypassed and left as is.
     * so XML_SUBSTITUTE_REF is not set here.
     */
                                (*ctxt).depth += 1;
                                ret =
                                    xmlStringDecodeEntities(ctxt, buf,
                                                            2 as std::os::raw::c_int,
                                                            0 as std::os::raw::c_int
                                                                as xmlChar,
                                                            0 as std::os::raw::c_int
                                                                as xmlChar,
                                                            0 as std::os::raw::c_int
                                                                as xmlChar);
                                (*ctxt).depth -= 1;
                                if !orig.is_null() {
                                    *orig = buf;
                                    buf = 0 as *mut xmlChar
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if !buf.is_null() {
        xmlFree.expect("non-null function pointer")(buf as *mut std::os::raw::c_void);
    }
    return ret;
}
/* *
 * xmlParseAttValueComplex:
 * @ctxt:  an XML parser context
 * @len:   the resulting attribute len
 * @normalize:  wether to apply the inner normalization
 *
 * parse a value for an attribute, this is the fallback function
 * of xmlParseAttValue() when the attribute parsing requires handling
 * of non-ASCII characters, or normalization compaction.
 *
 * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 */
unsafe extern "C" fn xmlParseAttValueComplex(mut ctxt: xmlParserCtxtPtr,
                                             mut attlen: *mut std::os::raw::c_int,
                                             mut normalize: std::os::raw::c_int)
 -> *mut xmlChar {
    let mut current_block: u64;
    let mut limit: xmlChar = 0 as std::os::raw::c_int as xmlChar;
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut rep: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: size_t = 0 as std::os::raw::c_int as size_t;
    let mut buf_size: size_t = 0 as std::os::raw::c_int as size_t;
    let mut c: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut in_space: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut current: *mut xmlChar = 0 as *mut xmlChar;
    let mut ent: xmlEntityPtr = 0 as *mut xmlEntity;
    if *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int
           == '\"' as i32 {
        (*ctxt).instate = XML_PARSER_ATTRIBUTE_VALUE;
        limit = '\"' as i32 as xmlChar;
        xmlNextChar(ctxt);
    } else if *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == '\'' as i32 {
        limit = '\'' as i32 as xmlChar;
        (*ctxt).instate = XML_PARSER_ATTRIBUTE_VALUE;
        xmlNextChar(ctxt);
    } else {
        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED,
                    0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    /*
     * allocate a translation buffer.
     */
    buf_size = 100 as std::os::raw::c_int as size_t;
    buf =
        xmlMallocAtomic.expect("non-null function pointer")(buf_size) as
            *mut xmlChar;
    if buf.is_null() {
        current_block = 6634944920567295698;
    } else {
        /*
     * OK loop until we reach one of the ending char or a size limit.
     */
        c = xmlCurrentChar(ctxt, &mut l);
        's_99:
            loop  {
                if !(*(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as isize)
                         as std::os::raw::c_int != limit as std::os::raw::c_int &&
                         (if c < 0x100 as std::os::raw::c_int {
                              (0x9 as std::os::raw::c_int <= c &&
                                   c <= 0xa as std::os::raw::c_int ||
                                   c == 0xd as std::os::raw::c_int ||
                                   0x20 as std::os::raw::c_int <= c) as std::os::raw::c_int
                          } else {
                              (0x100 as std::os::raw::c_int <= c &&
                                   c <= 0xd7ff as std::os::raw::c_int ||
                                   0xe000 as std::os::raw::c_int <= c &&
                                       c <= 0xfffd as std::os::raw::c_int ||
                                   0x10000 as std::os::raw::c_int <= c &&
                                       c <= 0x10ffff as std::os::raw::c_int) as
                                  std::os::raw::c_int
                          }) != 0 && c != '<' as i32 &&
                         (*ctxt).instate as std::os::raw::c_int !=
                             XML_PARSER_EOF as std::os::raw::c_int) {
                    current_block = 11577926782275222206;
                    break ;
                }
                /*
         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE
         * special option is given
         */
                if len > 10000000 as std::os::raw::c_int as std::os::raw::c_ulong &&
                       (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                   b"AttValue length too long\n\x00" as
                                       *const u8 as *const std::os::raw::c_char);
                    current_block = 6634944920567295698;
                    break ;
                } else {
                    if c == 0 as std::os::raw::c_int {
                        current_block = 11577926782275222206;
                        break ;
                    }
                    if c == '&' as i32 {
                        in_space = 0 as std::os::raw::c_int;
                        if *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                            isize) as
                               std::os::raw::c_int == '#' as i32 {
                            let mut val: std::os::raw::c_int = xmlParseCharRef(ctxt);
                            if val == '&' as i32 {
                                if (*ctxt).replaceEntities != 0 {
                                    if len.wrapping_add(10 as std::os::raw::c_int as
                                                            std::os::raw::c_ulong) >
                                           buf_size {
                                        let mut tmp: *mut xmlChar =
                                            0 as *mut xmlChar;
                                        let mut new_size: size_t =
                                            buf_size.wrapping_mul(2 as
                                                                      std::os::raw::c_int
                                                                      as
                                                                      std::os::raw::c_ulong).wrapping_add(10
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      std::os::raw::c_ulong);
                                        if new_size < buf_size {
                                            current_block =
                                                6634944920567295698;
                                            break ;
                                        }
                                        tmp =
                                            xmlRealloc.expect("non-null function pointer")(buf
                                                                                               as
                                                                                               *mut std::os::raw::c_void,
                                                                                           new_size)
                                                as *mut xmlChar;
                                        if tmp.is_null() {
                                            current_block =
                                                6634944920567295698;
                                            break ;
                                        }
                                        buf = tmp;
                                        buf_size = new_size
                                    }
                                    let fresh63 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh63 as isize) =
                                        '&' as i32 as xmlChar
                                } else {
                                    /*
			 * The reparsing will be done in xmlStringGetNodeList()
			 * called by the attribute() function in SAX.c
			 */
                                    if len.wrapping_add(10 as std::os::raw::c_int as
                                                            std::os::raw::c_ulong) >
                                           buf_size {
                                        let mut tmp_0: *mut xmlChar =
                                            0 as *mut xmlChar;
                                        let mut new_size_0: size_t =
                                            buf_size.wrapping_mul(2 as
                                                                      std::os::raw::c_int
                                                                      as
                                                                      std::os::raw::c_ulong).wrapping_add(10
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      std::os::raw::c_ulong);
                                        if new_size_0 < buf_size {
                                            current_block =
                                                6634944920567295698;
                                            break ;
                                        }
                                        tmp_0 =
                                            xmlRealloc.expect("non-null function pointer")(buf
                                                                                               as
                                                                                               *mut std::os::raw::c_void,
                                                                                           new_size_0)
                                                as *mut xmlChar;
                                        if tmp_0.is_null() {
                                            current_block =
                                                6634944920567295698;
                                            break ;
                                        }
                                        buf = tmp_0;
                                        buf_size = new_size_0
                                    }
                                    let fresh64 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh64 as isize) =
                                        '&' as i32 as xmlChar;
                                    let fresh65 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh65 as isize) =
                                        '#' as i32 as xmlChar;
                                    let fresh66 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh66 as isize) =
                                        '3' as i32 as xmlChar;
                                    let fresh67 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh67 as isize) =
                                        '8' as i32 as xmlChar;
                                    let fresh68 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh68 as isize) =
                                        ';' as i32 as xmlChar
                                }
                            } else if val != 0 as std::os::raw::c_int {
                                if len.wrapping_add(10 as std::os::raw::c_int as
                                                        std::os::raw::c_ulong) >
                                       buf_size {
                                    let mut tmp_1: *mut xmlChar =
                                        0 as *mut xmlChar;
                                    let mut new_size_1: size_t =
                                        buf_size.wrapping_mul(2 as std::os::raw::c_int
                                                                  as
                                                                  std::os::raw::c_ulong).wrapping_add(10
                                                                                                  as
                                                                                                  std::os::raw::c_int
                                                                                                  as
                                                                                                  std::os::raw::c_ulong);
                                    if new_size_1 < buf_size {
                                        current_block = 6634944920567295698;
                                        break ;
                                    }
                                    tmp_1 =
                                        xmlRealloc.expect("non-null function pointer")(buf
                                                                                           as
                                                                                           *mut std::os::raw::c_void,
                                                                                       new_size_1)
                                            as *mut xmlChar;
                                    if tmp_1.is_null() {
                                        current_block = 6634944920567295698;
                                        break ;
                                    }
                                    buf = tmp_1;
                                    buf_size = new_size_1
                                }
                                len =
                                    (len as
                                         std::os::raw::c_ulong).wrapping_add(xmlCopyChar(0
                                                                                     as
                                                                                     std::os::raw::c_int,
                                                                                 &mut *buf.offset(len
                                                                                                      as
                                                                                                      isize),
                                                                                 val)
                                                                         as
                                                                         std::os::raw::c_ulong)
                                        as size_t as size_t
                            }
                        } else {
                            ent = xmlParseEntityRef(ctxt);
                            (*ctxt).nbentities =
                                (*ctxt).nbentities.wrapping_add(1);
                            if !ent.is_null() {
                                (*ctxt).nbentities =
                                    (*ctxt).nbentities.wrapping_add((*ent).owner
                                                                        as
                                                                        std::os::raw::c_ulong)
                            }
                            if !ent.is_null() &&
                                   (*ent).etype as std::os::raw::c_uint ==
                                       XML_INTERNAL_PREDEFINED_ENTITY as
                                           std::os::raw::c_int as std::os::raw::c_uint {
                                if len.wrapping_add(10 as std::os::raw::c_int as
                                                        std::os::raw::c_ulong) >
                                       buf_size {
                                    let mut tmp_2: *mut xmlChar =
                                        0 as *mut xmlChar;
                                    let mut new_size_2: size_t =
                                        buf_size.wrapping_mul(2 as std::os::raw::c_int
                                                                  as
                                                                  std::os::raw::c_ulong).wrapping_add(10
                                                                                                  as
                                                                                                  std::os::raw::c_int
                                                                                                  as
                                                                                                  std::os::raw::c_ulong);
                                    if new_size_2 < buf_size {
                                        current_block = 6634944920567295698;
                                        break ;
                                    }
                                    tmp_2 =
                                        xmlRealloc.expect("non-null function pointer")(buf
                                                                                           as
                                                                                           *mut std::os::raw::c_void,
                                                                                       new_size_2)
                                            as *mut xmlChar;
                                    if tmp_2.is_null() {
                                        current_block = 6634944920567295698;
                                        break ;
                                    }
                                    buf = tmp_2;
                                    buf_size = new_size_2
                                }
                                if (*ctxt).replaceEntities == 0 as std::os::raw::c_int
                                       &&
                                       *(*ent).content.offset(0 as std::os::raw::c_int
                                                                  as isize) as
                                           std::os::raw::c_int == '&' as i32 {
                                    let fresh69 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh69 as isize) =
                                        '&' as i32 as xmlChar;
                                    let fresh70 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh70 as isize) =
                                        '#' as i32 as xmlChar;
                                    let fresh71 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh71 as isize) =
                                        '3' as i32 as xmlChar;
                                    let fresh72 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh72 as isize) =
                                        '8' as i32 as xmlChar;
                                    let fresh73 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh73 as isize) =
                                        ';' as i32 as xmlChar
                                } else {
                                    let fresh74 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh74 as isize) =
                                        *(*ent).content.offset(0 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                }
                            } else if !ent.is_null() &&
                                          (*ctxt).replaceEntities !=
                                              0 as std::os::raw::c_int {
                                if (*ent).etype as std::os::raw::c_uint !=
                                       XML_INTERNAL_PREDEFINED_ENTITY as
                                           std::os::raw::c_int as std::os::raw::c_uint {
                                    (*ctxt).depth += 1;
                                    rep =
                                        xmlStringDecodeEntities(ctxt,
                                                                (*ent).content,
                                                                1 as
                                                                    std::os::raw::c_int,
                                                                0 as
                                                                    std::os::raw::c_int
                                                                    as
                                                                    xmlChar,
                                                                0 as
                                                                    std::os::raw::c_int
                                                                    as
                                                                    xmlChar,
                                                                0 as
                                                                    std::os::raw::c_int
                                                                    as
                                                                    xmlChar);
                                    (*ctxt).depth -= 1;
                                    if !rep.is_null() {
                                        current = rep;
                                        while *current as std::os::raw::c_int !=
                                                  0 as std::os::raw::c_int {
                                            /* non input consuming */
                                            if *current as std::os::raw::c_int ==
                                                   0xd as std::os::raw::c_int ||
                                                   *current as std::os::raw::c_int ==
                                                       0xa as std::os::raw::c_int ||
                                                   *current as std::os::raw::c_int ==
                                                       0x9 as std::os::raw::c_int {
                                                let fresh75 = len;
                                                len = len.wrapping_add(1);
                                                *buf.offset(fresh75 as isize)
                                                    =
                                                    0x20 as std::os::raw::c_int as
                                                        xmlChar;
                                                current = current.offset(1)
                                            } else {
                                                let fresh76 = current;
                                                current = current.offset(1);
                                                let fresh77 = len;
                                                len = len.wrapping_add(1);
                                                *buf.offset(fresh77 as isize)
                                                    = *fresh76
                                            }
                                            if !(len.wrapping_add(10 as
                                                                      std::os::raw::c_int
                                                                      as
                                                                      std::os::raw::c_ulong)
                                                     > buf_size) {
                                                continue ;
                                            }
                                            let mut tmp_3: *mut xmlChar =
                                                0 as *mut xmlChar;
                                            let mut new_size_3: size_t =
                                                buf_size.wrapping_mul(2 as
                                                                          std::os::raw::c_int
                                                                          as
                                                                          std::os::raw::c_ulong).wrapping_add(10
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          std::os::raw::c_ulong);
                                            if new_size_3 < buf_size {
                                                current_block =
                                                    6634944920567295698;
                                                break 's_99 ;
                                            }
                                            tmp_3 =
                                                xmlRealloc.expect("non-null function pointer")(buf
                                                                                                   as
                                                                                                   *mut std::os::raw::c_void,
                                                                                               new_size_3)
                                                    as *mut xmlChar;
                                            if tmp_3.is_null() {
                                                current_block =
                                                    6634944920567295698;
                                                break 's_99 ;
                                            }
                                            buf = tmp_3;
                                            buf_size = new_size_3
                                        }
                                        xmlFree.expect("non-null function pointer")(rep
                                                                                        as
                                                                                        *mut std::os::raw::c_void);
                                        rep = 0 as *mut xmlChar
                                    }
                                } else {
                                    if len.wrapping_add(10 as std::os::raw::c_int as
                                                            std::os::raw::c_ulong) >
                                           buf_size {
                                        let mut tmp_4: *mut xmlChar =
                                            0 as *mut xmlChar;
                                        let mut new_size_4: size_t =
                                            buf_size.wrapping_mul(2 as
                                                                      std::os::raw::c_int
                                                                      as
                                                                      std::os::raw::c_ulong).wrapping_add(10
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      std::os::raw::c_ulong);
                                        if new_size_4 < buf_size {
                                            current_block =
                                                6634944920567295698;
                                            break ;
                                        }
                                        tmp_4 =
                                            xmlRealloc.expect("non-null function pointer")(buf
                                                                                               as
                                                                                               *mut std::os::raw::c_void,
                                                                                           new_size_4)
                                                as *mut xmlChar;
                                        if tmp_4.is_null() {
                                            current_block =
                                                6634944920567295698;
                                            break ;
                                        }
                                        buf = tmp_4;
                                        buf_size = new_size_4
                                    }
                                    if !(*ent).content.is_null() {
                                        let fresh78 = len;
                                        len = len.wrapping_add(1);
                                        *buf.offset(fresh78 as isize) =
                                            *(*ent).content.offset(0 as
                                                                       std::os::raw::c_int
                                                                       as
                                                                       isize)
                                    }
                                }
                            } else if !ent.is_null() {
                                let mut i: std::os::raw::c_int =
                                    xmlStrlen((*ent).name);
                                let mut cur: *const xmlChar = (*ent).name;
                                /*
		     * This may look absurd but is needed to detect
		     * entities problems
		     */
                                if (*ent).etype as std::os::raw::c_uint !=
                                       XML_INTERNAL_PREDEFINED_ENTITY as
                                           std::os::raw::c_int as std::os::raw::c_uint &&
                                       !(*ent).content.is_null() &&
                                       (*ent).checked == 0 as std::os::raw::c_int {
                                    let mut oldnbent: std::os::raw::c_ulong =
                                        (*ctxt).nbentities;
                                    (*ctxt).depth += 1;
                                    rep =
                                        xmlStringDecodeEntities(ctxt,
                                                                (*ent).content,
                                                                1 as
                                                                    std::os::raw::c_int,
                                                                0 as
                                                                    std::os::raw::c_int
                                                                    as
                                                                    xmlChar,
                                                                0 as
                                                                    std::os::raw::c_int
                                                                    as
                                                                    xmlChar,
                                                                0 as
                                                                    std::os::raw::c_int
                                                                    as
                                                                    xmlChar);
                                    (*ctxt).depth -= 1;
                                    (*ent).checked =
                                        (*ctxt).nbentities.wrapping_sub(oldnbent).wrapping_add(1
                                                                                                   as
                                                                                                   std::os::raw::c_int
                                                                                                   as
                                                                                                   std::os::raw::c_ulong).wrapping_mul(2
                                                                                                                                   as
                                                                                                                                   std::os::raw::c_int
                                                                                                                                   as
                                                                                                                                   std::os::raw::c_ulong)
                                            as std::os::raw::c_int;
                                    if !rep.is_null() {
                                        if !xmlStrchr(rep,
                                                      '<' as i32 as
                                                          xmlChar).is_null() {
                                            (*ent).checked |= 1 as std::os::raw::c_int
                                        }
                                        xmlFree.expect("non-null function pointer")(rep
                                                                                        as
                                                                                        *mut std::os::raw::c_void);
                                        rep = 0 as *mut xmlChar
                                    } else {
                                        *(*ent).content.offset(0 as
                                                                   std::os::raw::c_int
                                                                   as isize) =
                                            0 as std::os::raw::c_int as xmlChar
                                    }
                                }
                                /*
		     * Just output the reference
		     */
                                let fresh79 = len;
                                len = len.wrapping_add(1);
                                *buf.offset(fresh79 as isize) =
                                    '&' as i32 as xmlChar;
                                while len.wrapping_add(i as
                                                           std::os::raw::c_ulong).wrapping_add(10
                                                                                           as
                                                                                           std::os::raw::c_int
                                                                                           as
                                                                                           std::os::raw::c_ulong)
                                          > buf_size {
                                    let mut tmp_5: *mut xmlChar =
                                        0 as *mut xmlChar;
                                    let mut new_size_5: size_t =
                                        buf_size.wrapping_mul(2 as std::os::raw::c_int
                                                                  as
                                                                  std::os::raw::c_ulong).wrapping_add(i
                                                                                                  as
                                                                                                  std::os::raw::c_ulong).wrapping_add(10
                                                                                                                                  as
                                                                                                                                  std::os::raw::c_int
                                                                                                                                  as
                                                                                                                                  std::os::raw::c_ulong);
                                    if new_size_5 < buf_size {
                                        current_block = 6634944920567295698;
                                        break 's_99 ;
                                    }
                                    tmp_5 =
                                        xmlRealloc.expect("non-null function pointer")(buf
                                                                                           as
                                                                                           *mut std::os::raw::c_void,
                                                                                       new_size_5)
                                            as *mut xmlChar;
                                    if tmp_5.is_null() {
                                        current_block = 6634944920567295698;
                                        break 's_99 ;
                                    }
                                    buf = tmp_5;
                                    buf_size = new_size_5
                                }
                                while i > 0 as std::os::raw::c_int {
                                    let fresh80 = cur;
                                    cur = cur.offset(1);
                                    let fresh81 = len;
                                    len = len.wrapping_add(1);
                                    *buf.offset(fresh81 as isize) = *fresh80;
                                    i -= 1
                                }
                                let fresh82 = len;
                                len = len.wrapping_add(1);
                                *buf.offset(fresh82 as isize) =
                                    ';' as i32 as xmlChar
                            }
                        }
                    } else {
                        if c == 0x20 as std::os::raw::c_int || c == 0xd as std::os::raw::c_int
                               || c == 0xa as std::os::raw::c_int ||
                               c == 0x9 as std::os::raw::c_int {
                            if len != 0 as std::os::raw::c_int as std::os::raw::c_ulong ||
                                   normalize == 0 {
                                if normalize == 0 || in_space == 0 {
                                    if l == 1 as std::os::raw::c_int {
                                        let fresh83 = len;
                                        len = len.wrapping_add(1);
                                        *buf.offset(fresh83 as isize) =
                                            0x20 as std::os::raw::c_int as xmlChar
                                    } else {
                                        len =
                                            (len as
                                                 std::os::raw::c_ulong).wrapping_add(xmlCopyCharMultiByte(&mut *buf.offset(len
                                                                                                                       as
                                                                                                                       isize),
                                                                                                  0x20
                                                                                                      as
                                                                                                      std::os::raw::c_int)
                                                                                 as
                                                                                 std::os::raw::c_ulong)
                                                as size_t as size_t
                                    }
                                    while len.wrapping_add(10 as std::os::raw::c_int
                                                               as
                                                               std::os::raw::c_ulong)
                                              > buf_size {
                                        let mut tmp_6: *mut xmlChar =
                                            0 as *mut xmlChar;
                                        let mut new_size_6: size_t =
                                            buf_size.wrapping_mul(2 as
                                                                      std::os::raw::c_int
                                                                      as
                                                                      std::os::raw::c_ulong).wrapping_add(10
                                                                                                      as
                                                                                                      std::os::raw::c_int
                                                                                                      as
                                                                                                      std::os::raw::c_ulong);
                                        if new_size_6 < buf_size {
                                            current_block =
                                                6634944920567295698;
                                            break 's_99 ;
                                        }
                                        tmp_6 =
                                            xmlRealloc.expect("non-null function pointer")(buf
                                                                                               as
                                                                                               *mut std::os::raw::c_void,
                                                                                           new_size_6)
                                                as *mut xmlChar;
                                        if tmp_6.is_null() {
                                            current_block =
                                                6634944920567295698;
                                            break 's_99 ;
                                        }
                                        buf = tmp_6;
                                        buf_size = new_size_6
                                    }
                                }
                                in_space = 1 as std::os::raw::c_int
                            }
                        } else {
                            in_space = 0 as std::os::raw::c_int;
                            if l == 1 as std::os::raw::c_int {
                                let fresh84 = len;
                                len = len.wrapping_add(1);
                                *buf.offset(fresh84 as isize) = c as xmlChar
                            } else {
                                len =
                                    (len as
                                         std::os::raw::c_ulong).wrapping_add(xmlCopyCharMultiByte(&mut *buf.offset(len
                                                                                                               as
                                                                                                               isize),
                                                                                          c)
                                                                         as
                                                                         std::os::raw::c_ulong)
                                        as size_t as size_t
                            }
                            if len.wrapping_add(10 as std::os::raw::c_int as
                                                    std::os::raw::c_ulong) > buf_size
                               {
                                let mut tmp_7: *mut xmlChar =
                                    0 as *mut xmlChar;
                                let mut new_size_7: size_t =
                                    buf_size.wrapping_mul(2 as std::os::raw::c_int as
                                                              std::os::raw::c_ulong).wrapping_add(10
                                                                                              as
                                                                                              std::os::raw::c_int
                                                                                              as
                                                                                              std::os::raw::c_ulong);
                                if new_size_7 < buf_size {
                                    current_block = 6634944920567295698;
                                    break ;
                                }
                                tmp_7 =
                                    xmlRealloc.expect("non-null function pointer")(buf
                                                                                       as
                                                                                       *mut std::os::raw::c_void,
                                                                                   new_size_7)
                                        as *mut xmlChar;
                                if tmp_7.is_null() {
                                    current_block = 6634944920567295698;
                                    break ;
                                }
                                buf = tmp_7;
                                buf_size = new_size_7
                            }
                        }
                        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32
                           {
                            (*(*ctxt).input).line += 1;
                            (*(*ctxt).input).col = 1 as std::os::raw::c_int
                        } else { (*(*ctxt).input).col += 1 }
                        (*(*ctxt).input).cur =
                            (*(*ctxt).input).cur.offset(l as isize)
                    }
                    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               250 as std::os::raw::c_int as std::os::raw::c_long {
                        xmlGROW(ctxt);
                    }
                    c = xmlCurrentChar(ctxt, &mut l)
                }
            }
        match current_block {
            6634944920567295698 => { }
            _ => {
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    current_block = 2143638282499924240;
                } else {
                    if in_space != 0 && normalize != 0 {
                        while len > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                                  *buf.offset(len.wrapping_sub(1 as
                                                                   std::os::raw::c_int
                                                                   as
                                                                   std::os::raw::c_ulong)
                                                  as isize) as std::os::raw::c_int ==
                                      0x20 as std::os::raw::c_int {
                            len = len.wrapping_sub(1)
                        }
                    }
                    *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
                    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 {
                        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
                                    0 as *const std::os::raw::c_char);
                    } else if *(*(*ctxt).input).cur as std::os::raw::c_int !=
                                  limit as std::os::raw::c_int {
                        if c != 0 as std::os::raw::c_int &&
                               (if c < 0x100 as std::os::raw::c_int {
                                    (0x9 as std::os::raw::c_int <= c &&
                                         c <= 0xa as std::os::raw::c_int ||
                                         c == 0xd as std::os::raw::c_int ||
                                         0x20 as std::os::raw::c_int <= c) as
                                        std::os::raw::c_int
                                } else {
                                    (0x100 as std::os::raw::c_int <= c &&
                                         c <= 0xd7ff as std::os::raw::c_int ||
                                         0xe000 as std::os::raw::c_int <= c &&
                                             c <= 0xfffd as std::os::raw::c_int ||
                                         0x10000 as std::os::raw::c_int <= c &&
                                             c <= 0x10ffff as std::os::raw::c_int) as
                                        std::os::raw::c_int
                                }) == 0 {
                            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
                                           b"invalid character in attribute value\n\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char);
                        } else {
                            xmlFatalErrMsg(ctxt,
                                           XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                           b"AttValue: \' expected\n\x00" as
                                               *const u8 as
                                               *const std::os::raw::c_char);
                        }
                    } else { xmlNextChar(ctxt); }
                    /*
     * There we potentially risk an overflow, don't allow attribute value of
     * length more than INT_MAX it is a very reasonnable assumption !
     */
                    if len >= 2147483647 as std::os::raw::c_int as std::os::raw::c_ulong {
                        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                       b"AttValue length too long\n\x00" as
                                           *const u8 as *const std::os::raw::c_char);
                    } else {
                        if !attlen.is_null() { *attlen = len as std::os::raw::c_int }
                        return buf
                    }
                    current_block = 6634944920567295698;
                }
            }
        }
    }
    match current_block {
        6634944920567295698 => {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
        }
        _ => { }
    }
    if !buf.is_null() {
        xmlFree.expect("non-null function pointer")(buf as *mut std::os::raw::c_void);
    }
    if !rep.is_null() {
        xmlFree.expect("non-null function pointer")(rep as *mut std::os::raw::c_void);
    }
    return 0 as *mut xmlChar;
}
/* *
 * xmlParseAttValue:
 * @ctxt:  an XML parser context
 *
 * parse a value for an attribute
 * Note: the parser won't do substitution of entities here, this
 * will be handled later in xmlStringGetNodeList
 *
 * [10] AttValue ::= '"' ([^<&"] | Reference)* '"' |
 *                   "'" ([^<&'] | Reference)* "'"
 *
 * 3.3.3 Attribute-Value Normalization:
 * Before the value of an attribute is passed to the application or
 * checked for validity, the XML processor must normalize it as follows:
 * - a character reference is processed by appending the referenced
 *   character to the attribute value
 * - an entity reference is processed by recursively processing the
 *   replacement text of the entity
 * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 *   appending #x20 to the normalized value, except that only a single
 *   #x20 is appended for a "#xD#xA" sequence that is part of an external
 *   parsed entity or the literal entity value of an internal parsed entity
 * - other characters are processed by appending them to the normalized value
 * If the declared value is not CDATA, then the XML processor must further
 * process the normalized attribute value by discarding any leading and
 * trailing space (#x20) characters, and by replacing sequences of space
 * (#x20) characters by a single space (#x20) character.
 * All attributes for which no declaration has been read should be treated
 * by a non-validating parser as if declared CDATA.
 *
 * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseAttValue(mut ctxt: xmlParserCtxtPtr)
 -> *mut xmlChar {
    if ctxt.is_null() || (*ctxt).input.is_null() { return 0 as *mut xmlChar }
    return xmlParseAttValueInternal(ctxt, 0 as *mut std::os::raw::c_int,
                                    0 as *mut std::os::raw::c_int, 0 as std::os::raw::c_int);
}
/* *
 * xmlParseSystemLiteral:
 * @ctxt:  an XML parser context
 *
 * parse an XML Literal
 *
 * [11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'")
 *
 * Returns the SystemLiteral parsed or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseSystemLiteral(mut ctxt: xmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut size: std::os::raw::c_int = 100 as std::os::raw::c_int;
    let mut cur: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut stop: xmlChar = 0;
    let mut state: std::os::raw::c_int = (*ctxt).instate as std::os::raw::c_int;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 {
        xmlNextChar(ctxt);
        stop = '\"' as i32 as xmlChar
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
        xmlNextChar(ctxt);
        stop = '\'' as i32 as xmlChar
    } else {
        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
                    0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    buf =
        xmlMallocAtomic.expect("non-null function pointer")((size as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if buf.is_null() {
        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    (*ctxt).instate = XML_PARSER_SYSTEM_LITERAL;
    cur = xmlCurrentChar(ctxt, &mut l);
    while (if cur < 0x100 as std::os::raw::c_int {
               (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int ||
                    cur == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= cur)
                   as std::os::raw::c_int
           } else {
               (0x100 as std::os::raw::c_int <= cur && cur <= 0xd7ff as std::os::raw::c_int ||
                    0xe000 as std::os::raw::c_int <= cur &&
                        cur <= 0xfffd as std::os::raw::c_int ||
                    0x10000 as std::os::raw::c_int <= cur &&
                        cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
           }) != 0 && cur != stop as std::os::raw::c_int {
        /* checked */
        if len + 5 as std::os::raw::c_int >= size {
            let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
            if size > 50000 as std::os::raw::c_int &&
                   (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                            b"SystemLiteral\x00" as *const u8 as
                                *const std::os::raw::c_char);
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                (*ctxt).instate = state as xmlParserInputState;
                return 0 as *mut xmlChar
            }
            size *= 2 as std::os::raw::c_int;
            tmp =
                xmlRealloc.expect("non-null function pointer")(buf as
                                                                   *mut std::os::raw::c_void,
                                                               (size as
                                                                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                    as
                                                                                                    std::os::raw::c_ulong))
                    as *mut xmlChar;
            if tmp.is_null() {
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                (*ctxt).instate = state as xmlParserInputState;
                return 0 as *mut xmlChar
            }
            buf = tmp
        }
        count += 1;
        if count > 50 as std::os::raw::c_int {
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            count = 0 as std::os::raw::c_int;
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                return 0 as *mut xmlChar
            }
        }
        if l == 1 as std::os::raw::c_int {
            let fresh85 = len;
            len = len + 1;
            *buf.offset(fresh85 as isize) = cur as xmlChar
        } else {
            len += xmlCopyCharMultiByte(&mut *buf.offset(len as isize), cur)
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        cur = xmlCurrentChar(ctxt, &mut l);
        if cur == 0 as std::os::raw::c_int {
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                       as std::os::raw::c_long >
                       (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long
                   &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) <
                       (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long
               {
                xmlSHRINK(ctxt);
            }
            cur = xmlCurrentChar(ctxt, &mut l)
        }
    }
    *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
    (*ctxt).instate = state as xmlParserInputState;
    if if cur < 0x100 as std::os::raw::c_int {
           (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int ||
                cur == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= cur) as
               std::os::raw::c_int
       } else {
           (0x100 as std::os::raw::c_int <= cur && cur <= 0xd7ff as std::os::raw::c_int ||
                0xe000 as std::os::raw::c_int <= cur && cur <= 0xfffd as std::os::raw::c_int
                ||
                0x10000 as std::os::raw::c_int <= cur &&
                    cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
       } == 0 {
        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
    } else { xmlNextChar(ctxt); }
    return buf;
}
/* *
 * xmlParsePubidLiteral:
 * @ctxt:  an XML parser context
 *
 * parse an XML public literal
 *
 * [12] PubidLiteral ::= '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
 *
 * Returns the PubidLiteral parsed or NULL.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParsePubidLiteral(mut ctxt: xmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut size: std::os::raw::c_int = 100 as std::os::raw::c_int;
    let mut cur: xmlChar = 0;
    let mut stop: xmlChar = 0;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut oldstate: xmlParserInputState = (*ctxt).instate;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 {
        xmlNextChar(ctxt);
        stop = '\"' as i32 as xmlChar
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
        xmlNextChar(ctxt);
        stop = '\'' as i32 as xmlChar
    } else {
        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
                    0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    buf =
        xmlMallocAtomic.expect("non-null function pointer")((size as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if buf.is_null() {
        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    (*ctxt).instate = XML_PARSER_PUBLIC_LITERAL;
    cur = *(*(*ctxt).input).cur;
    while xmlIsPubidChar_tab[cur as usize] as std::os::raw::c_int != 0 &&
              cur as std::os::raw::c_int != stop as std::os::raw::c_int {
        /* checked */
        if len + 1 as std::os::raw::c_int >= size {
            let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
            if size > 50000 as std::os::raw::c_int &&
                   (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG,
                            b"Public ID\x00" as *const u8 as
                                *const std::os::raw::c_char);
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                return 0 as *mut xmlChar
            }
            size *= 2 as std::os::raw::c_int;
            tmp =
                xmlRealloc.expect("non-null function pointer")(buf as
                                                                   *mut std::os::raw::c_void,
                                                               (size as
                                                                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                    as
                                                                                                    std::os::raw::c_ulong))
                    as *mut xmlChar;
            if tmp.is_null() {
                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                return 0 as *mut xmlChar
            }
            buf = tmp
        }
        let fresh86 = len;
        len = len + 1;
        *buf.offset(fresh86 as isize) = cur;
        count += 1;
        if count > 50 as std::os::raw::c_int {
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            count = 0 as std::os::raw::c_int;
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                return 0 as *mut xmlChar
            }
        }
        xmlNextChar(ctxt);
        cur = *(*(*ctxt).input).cur;
        if cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                       as std::os::raw::c_long >
                       (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long
                   &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) <
                       (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long
               {
                xmlSHRINK(ctxt);
            }
            cur = *(*(*ctxt).input).cur
        }
    }
    *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
    if cur as std::os::raw::c_int != stop as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
    } else { xmlNextChar(ctxt); }
    (*ctxt).instate = oldstate;
    return buf;
}
/*
 * used for the test in the inner loop of the char data testing
 */
static mut test_char_data: [std::os::raw::c_uchar; 256] =
    [0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0x9 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x20 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x21 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x22 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x23 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x24 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x25 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x27 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x28 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x29 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x2a as std::os::raw::c_int as std::os::raw::c_uchar,
     0x2b as std::os::raw::c_int as std::os::raw::c_uchar,
     0x2c as std::os::raw::c_int as std::os::raw::c_uchar,
     0x2d as std::os::raw::c_int as std::os::raw::c_uchar,
     0x2e as std::os::raw::c_int as std::os::raw::c_uchar,
     0x2f as std::os::raw::c_int as std::os::raw::c_uchar,
     0x30 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x31 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x32 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x33 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x34 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x35 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x36 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x37 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x38 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x39 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x3a as std::os::raw::c_int as std::os::raw::c_uchar,
     0x3b as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x3d as std::os::raw::c_int as std::os::raw::c_uchar,
     0x3e as std::os::raw::c_int as std::os::raw::c_uchar,
     0x3f as std::os::raw::c_int as std::os::raw::c_uchar,
     0x40 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x41 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x42 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x43 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x44 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x45 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x46 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x47 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x48 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x49 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x4a as std::os::raw::c_int as std::os::raw::c_uchar,
     0x4b as std::os::raw::c_int as std::os::raw::c_uchar,
     0x4c as std::os::raw::c_int as std::os::raw::c_uchar,
     0x4d as std::os::raw::c_int as std::os::raw::c_uchar,
     0x4e as std::os::raw::c_int as std::os::raw::c_uchar,
     0x4f as std::os::raw::c_int as std::os::raw::c_uchar,
     0x50 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x51 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x52 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x53 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x54 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x55 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x56 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x57 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x58 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x59 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x5a as std::os::raw::c_int as std::os::raw::c_uchar,
     0x5b as std::os::raw::c_int as std::os::raw::c_uchar,
     0x5c as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x5e as std::os::raw::c_int as std::os::raw::c_uchar,
     0x5f as std::os::raw::c_int as std::os::raw::c_uchar,
     0x60 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x61 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x62 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x63 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x64 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x65 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x66 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x67 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x68 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x69 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x6a as std::os::raw::c_int as std::os::raw::c_uchar,
     0x6b as std::os::raw::c_int as std::os::raw::c_uchar,
     0x6c as std::os::raw::c_int as std::os::raw::c_uchar,
     0x6d as std::os::raw::c_int as std::os::raw::c_uchar,
     0x6e as std::os::raw::c_int as std::os::raw::c_uchar,
     0x6f as std::os::raw::c_int as std::os::raw::c_uchar,
     0x70 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x71 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x72 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x73 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x74 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x75 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x76 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x77 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x78 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x79 as std::os::raw::c_int as std::os::raw::c_uchar,
     0x7a as std::os::raw::c_int as std::os::raw::c_uchar,
     0x7b as std::os::raw::c_int as std::os::raw::c_uchar,
     0x7c as std::os::raw::c_int as std::os::raw::c_uchar,
     0x7d as std::os::raw::c_int as std::os::raw::c_uchar,
     0x7e as std::os::raw::c_int as std::os::raw::c_uchar,
     0x7f as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar, 0 as std::os::raw::c_int as std::os::raw::c_uchar,
     0 as std::os::raw::c_int as std::os::raw::c_uchar];
/* *
 * xmlParseCharData:
 * @ctxt:  an XML parser context
 * @cdata:  int indicating whether we are within a CDATA section
 *
 * parse a CharData section.
 * if we are within a CDATA section ']]>' marks an end of section.
 *
 * The right angle bracket (>) may be represented using the string "&gt;",
 * and must, for compatibility, be escaped using "&gt;" or a character
 * reference when it appears in the string "]]>" in content, when that
 * string is not marking the end of a CDATA section.
 *
 * [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseCharData(mut ctxt: xmlParserCtxtPtr,
                                          mut cdata: std::os::raw::c_int) {
    let mut current_block: u64;
    let mut in_0: *const xmlChar = 0 as *const xmlChar;
    let mut nbchar: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut line: std::os::raw::c_int = (*(*ctxt).input).line;
    let mut col: std::os::raw::c_int = (*(*ctxt).input).col;
    let mut ccol: std::os::raw::c_int = 0;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    /*
     * Accelerated common case where input don't need to be
     * modified before passing it to the handler.
     */
    if cdata == 0 {
        in_0 = (*(*ctxt).input).cur;
        loop  {
            while *in_0 as std::os::raw::c_int == 0x20 as std::os::raw::c_int {
                in_0 = in_0.offset(1);
                (*(*ctxt).input).col += 1
            }
            if *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int {
                loop  {
                    (*(*ctxt).input).line += 1;
                    (*(*ctxt).input).col = 1 as std::os::raw::c_int;
                    in_0 = in_0.offset(1);
                    if !(*in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int) {
                        break ;
                    }
                }
            } else {
                if *in_0 as std::os::raw::c_int == '<' as i32 {
                    nbchar =
                        in_0.offset_from((*(*ctxt).input).cur) as
                            std::os::raw::c_long as std::os::raw::c_int;
                    if nbchar > 0 as std::os::raw::c_int {
                        let mut tmp: *const xmlChar = (*(*ctxt).input).cur;
                        (*(*ctxt).input).cur = in_0;
                        if !(*ctxt).sax.is_null() &&
                               (*(*ctxt).sax).ignorableWhitespace !=
                                   (*(*ctxt).sax).characters {
                            if areBlanks(ctxt, tmp, nbchar, 1 as std::os::raw::c_int)
                                   != 0 {
                                if (*(*ctxt).sax).ignorableWhitespace.is_some()
                                   {
                                    (*(*ctxt).sax).ignorableWhitespace.expect("non-null function pointer")((*ctxt).userData,
                                                                                                           tmp,
                                                                                                           nbchar);
                                }
                            } else {
                                if (*(*ctxt).sax).characters.is_some() {
                                    (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                                  tmp,
                                                                                                  nbchar);
                                }
                                if *(*ctxt).space == -(1 as std::os::raw::c_int) {
                                    *(*ctxt).space = -(2 as std::os::raw::c_int)
                                }
                            }
                        } else if !(*ctxt).sax.is_null() &&
                                      (*(*ctxt).sax).characters.is_some() {
                            (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                          tmp,
                                                                                          nbchar);
                        }
                    }
                    return
                }
                loop  {
                    ccol = (*(*ctxt).input).col;
                    while test_char_data[*in_0 as usize] != 0 {
                        in_0 = in_0.offset(1);
                        ccol += 1
                    }
                    (*(*ctxt).input).col = ccol;
                    if *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int {
                        loop  {
                            (*(*ctxt).input).line += 1;
                            (*(*ctxt).input).col = 1 as std::os::raw::c_int;
                            in_0 = in_0.offset(1);
                            if !(*in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int) {
                                break ;
                            }
                        }
                    } else {
                        if !(*in_0 as std::os::raw::c_int == ']' as i32) { break ; }
                        if *in_0.offset(1 as std::os::raw::c_int as isize) as
                               std::os::raw::c_int == ']' as i32 &&
                               *in_0.offset(2 as std::os::raw::c_int as isize) as
                                   std::os::raw::c_int == '>' as i32 {
                            xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END,
                                        0 as *const std::os::raw::c_char);
                            (*(*ctxt).input).cur =
                                in_0.offset(1 as std::os::raw::c_int as isize);
                            return
                        }
                        in_0 = in_0.offset(1);
                        (*(*ctxt).input).col += 1
                    }
                }
                nbchar =
                    in_0.offset_from((*(*ctxt).input).cur) as
                        std::os::raw::c_long as std::os::raw::c_int;
                if nbchar > 0 as std::os::raw::c_int {
                    if !(*ctxt).sax.is_null() &&
                           (*(*ctxt).sax).ignorableWhitespace !=
                               (*(*ctxt).sax).characters &&
                           (*(*(*ctxt).input).cur as std::os::raw::c_int ==
                                0x20 as std::os::raw::c_int ||
                                0x9 as std::os::raw::c_int <=
                                    *(*(*ctxt).input).cur as std::os::raw::c_int &&
                                    *(*(*ctxt).input).cur as std::os::raw::c_int <=
                                        0xa as std::os::raw::c_int ||
                                *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                    0xd as std::os::raw::c_int) {
                        let mut tmp_0: *const xmlChar = (*(*ctxt).input).cur;
                        (*(*ctxt).input).cur = in_0;
                        if areBlanks(ctxt, tmp_0, nbchar, 0 as std::os::raw::c_int) !=
                               0 {
                            if (*(*ctxt).sax).ignorableWhitespace.is_some() {
                                (*(*ctxt).sax).ignorableWhitespace.expect("non-null function pointer")((*ctxt).userData,
                                                                                                       tmp_0,
                                                                                                       nbchar);
                            }
                        } else {
                            if (*(*ctxt).sax).characters.is_some() {
                                (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                              tmp_0,
                                                                                              nbchar);
                            }
                            if *(*ctxt).space == -(1 as std::os::raw::c_int) {
                                *(*ctxt).space = -(2 as std::os::raw::c_int)
                            }
                        }
                        line = (*(*ctxt).input).line;
                        col = (*(*ctxt).input).col
                    } else if !(*ctxt).sax.is_null() {
                        if (*(*ctxt).sax).characters.is_some() {
                            (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                          (*(*ctxt).input).cur,
                                                                                          nbchar);
                        }
                        line = (*(*ctxt).input).line;
                        col = (*(*ctxt).input).col
                    }
                    /* something really bad happened in the SAX callback */
                    if (*ctxt).instate as std::os::raw::c_int !=
                           XML_PARSER_CONTENT as std::os::raw::c_int {
                        return
                    }
                }
                (*(*ctxt).input).cur = in_0;
                if *in_0 as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                    in_0 = in_0.offset(1);
                    if *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int {
                        (*(*ctxt).input).cur = in_0;
                        in_0 = in_0.offset(1);
                        (*(*ctxt).input).line += 1;
                        (*(*ctxt).input).col = 1 as std::os::raw::c_int;
                        current_block = 1917311967535052937;
                        /* while */
                    } else {
                        in_0 = in_0.offset(-1);
                        current_block = 17769492591016358583;
                    }
                } else { current_block = 17769492591016358583; }
                match current_block {
                    17769492591016358583 => {
                        if *in_0 as std::os::raw::c_int == '<' as i32 { return }
                        if *in_0 as std::os::raw::c_int == '&' as i32 { return }
                        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                               (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                   as std::os::raw::c_long >
                                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                                       std::os::raw::c_long &&
                               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                    as std::os::raw::c_long) <
                                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                                       std::os::raw::c_long {
                            xmlSHRINK(ctxt);
                        }
                        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                    as std::os::raw::c_long) <
                                   250 as std::os::raw::c_int as std::os::raw::c_long {
                            xmlGROW(ctxt);
                        }
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            return
                        }
                        in_0 = (*(*ctxt).input).cur
                    }
                    _ => { }
                }
                if !(*in_0 as std::os::raw::c_int >= 0x20 as std::os::raw::c_int &&
                         *in_0 as std::os::raw::c_int <= 0x7f as std::os::raw::c_int ||
                         *in_0 as std::os::raw::c_int == 0x9 as std::os::raw::c_int) {
                    break ;
                }
            }
        }
        nbchar = 0 as std::os::raw::c_int
    }
    (*(*ctxt).input).line = line;
    (*(*ctxt).input).col = col;
    xmlParseCharDataComplex(ctxt, cdata);
}
/* *
 * xmlParseCharDataComplex:
 * @ctxt:  an XML parser context
 * @cdata:  int indicating whether we are within a CDATA section
 *
 * parse a CharData section.this is the fallback function
 * of xmlParseCharData() when the parsing requires handling
 * of non-ASCII characters.
 */
unsafe extern "C" fn xmlParseCharDataComplex(mut ctxt: xmlParserCtxtPtr,
                                             mut cdata: std::os::raw::c_int) {
    let mut buf: [xmlChar; 305] = [0; 305];
    let mut nbchar: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut cur: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    cur = xmlCurrentChar(ctxt, &mut l);
    while cur != '<' as i32 && cur != '&' as i32 &&
              (if cur < 0x100 as std::os::raw::c_int {
                   (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int ||
                        cur == 0xd as std::os::raw::c_int ||
                        0x20 as std::os::raw::c_int <= cur) as std::os::raw::c_int
               } else {
                   (0x100 as std::os::raw::c_int <= cur &&
                        cur <= 0xd7ff as std::os::raw::c_int ||
                        0xe000 as std::os::raw::c_int <= cur &&
                            cur <= 0xfffd as std::os::raw::c_int ||
                        0x10000 as std::os::raw::c_int <= cur &&
                            cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
               }) != 0 {
        /* test also done in xmlCurrentChar() */
        if cur == ']' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == ']' as i32 &&
               *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '>' as i32 {
            if cdata != 0 { break ; }
            xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END,
                        0 as *const std::os::raw::c_char);
        }
        if l == 1 as std::os::raw::c_int {
            let fresh87 = nbchar;
            nbchar = nbchar + 1;
            buf[fresh87 as usize] = cur as xmlChar
        } else {
            nbchar +=
                xmlCopyCharMultiByte(&mut *buf.as_mut_ptr().offset(nbchar as
                                                                       isize),
                                     cur)
        }
        if nbchar >= 300 as std::os::raw::c_int {
            buf[nbchar as usize] = 0 as std::os::raw::c_int as xmlChar;
            /*
	     * OK the segment is to be consumed as chars.
	     */
            if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 {
                if areBlanks(ctxt, buf.as_mut_ptr(), nbchar, 0 as std::os::raw::c_int)
                       != 0 {
                    if (*(*ctxt).sax).ignorableWhitespace.is_some() {
                        (*(*ctxt).sax).ignorableWhitespace.expect("non-null function pointer")((*ctxt).userData,
                                                                                               buf.as_mut_ptr(),
                                                                                               nbchar);
                    }
                } else {
                    if (*(*ctxt).sax).characters.is_some() {
                        (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                      buf.as_mut_ptr(),
                                                                                      nbchar);
                    }
                    if (*(*ctxt).sax).characters !=
                           (*(*ctxt).sax).ignorableWhitespace &&
                           *(*ctxt).space == -(1 as std::os::raw::c_int) {
                        *(*ctxt).space = -(2 as std::os::raw::c_int)
                    }
                }
            }
            nbchar = 0 as std::os::raw::c_int;
            /* something really bad happened in the SAX callback */
            if (*ctxt).instate as std::os::raw::c_int !=
                   XML_PARSER_CONTENT as std::os::raw::c_int {
                return
            }
        }
        count += 1;
        if count > 50 as std::os::raw::c_int {
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            count = 0 as std::os::raw::c_int;
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                return
            }
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        cur = xmlCurrentChar(ctxt, &mut l)
    }
    if nbchar != 0 as std::os::raw::c_int {
        buf[nbchar as usize] = 0 as std::os::raw::c_int as xmlChar;
        /*
	 * OK the segment is to be consumed as chars.
	 */
        if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 {
            if areBlanks(ctxt, buf.as_mut_ptr(), nbchar, 0 as std::os::raw::c_int) !=
                   0 {
                if (*(*ctxt).sax).ignorableWhitespace.is_some() {
                    (*(*ctxt).sax).ignorableWhitespace.expect("non-null function pointer")((*ctxt).userData,
                                                                                           buf.as_mut_ptr(),
                                                                                           nbchar);
                }
            } else {
                if (*(*ctxt).sax).characters.is_some() {
                    (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                  buf.as_mut_ptr(),
                                                                                  nbchar);
                }
                if (*(*ctxt).sax).characters !=
                       (*(*ctxt).sax).ignorableWhitespace &&
                       *(*ctxt).space == -(1 as std::os::raw::c_int) {
                    *(*ctxt).space = -(2 as std::os::raw::c_int)
                }
            }
        }
    }
    if cur != 0 as std::os::raw::c_int &&
           (if cur < 0x100 as std::os::raw::c_int {
                (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int ||
                     cur == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= cur)
                    as std::os::raw::c_int
            } else {
                (0x100 as std::os::raw::c_int <= cur && cur <= 0xd7ff as std::os::raw::c_int
                     ||
                     0xe000 as std::os::raw::c_int <= cur &&
                         cur <= 0xfffd as std::os::raw::c_int ||
                     0x10000 as std::os::raw::c_int <= cur &&
                         cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
            }) == 0 {
        /* Generate the error and skip the offending character */
        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                          b"PCDATA invalid Char value %d\n\x00" as *const u8
                              as *const std::os::raw::c_char, cur);
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize)
    };
}
/* *
 * xmlParseExternalID:
 * @ctxt:  an XML parser context
 * @publicID:  a xmlChar** receiving PubidLiteral
 * @strict: indicate whether we should restrict parsing to only
 *          production [75], see NOTE below
 *
 * Parse an External ID or a Public ID
 *
 * NOTE: Productions [75] and [83] interact badly since [75] can generate
 *       'PUBLIC' S PubidLiteral S SystemLiteral
 *
 * [75] ExternalID ::= 'SYSTEM' S SystemLiteral
 *                   | 'PUBLIC' S PubidLiteral S SystemLiteral
 *
 * [83] PublicID ::= 'PUBLIC' S PubidLiteral
 *
 * Returns the function returns SystemLiteral and in the second
 *                case publicID receives PubidLiteral, is strict is off
 *                it is possible to return NULL and have publicID set.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseExternalID(mut ctxt: xmlParserCtxtPtr,
                                            mut publicID: *mut *mut xmlChar,
                                            mut strict: std::os::raw::c_int)
 -> *mut xmlChar {
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    *publicID = 0 as *mut xmlChar;
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == 'S' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'Y' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'S' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'M' as i32 {
        (*ctxt).nbChars += 6 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 6 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after \'SYSTEM\'\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
        }
        URI = xmlParseSystemLiteral(ctxt);
        if URI.is_null() {
            xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, 0 as *const std::os::raw::c_char);
        }
    } else if *((*(*ctxt).input).cur as
                    *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == 'P' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'U' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'B' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'L' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'I' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'C' as i32 {
        (*ctxt).nbChars += 6 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 6 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after \'PUBLIC\'\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
        }
        *publicID = xmlParsePubidLiteral(ctxt);
        if (*publicID).is_null() {
            xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED,
                        0 as *const std::os::raw::c_char);
        }
        if strict != 0 {
            /*
	     * We don't handle [83] so "S SystemLiteral" is required.
	     */
            if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                               b"Space required after the Public Identifier\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
        } else {
            /*
	     * We handle [83] so we return immediately, if
	     * "S SystemLiteral" is not detected. We skip blanks if no
             * system literal was found, but this is harmless since we must
             * be at the end of a NotationDecl.
	     */
            if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
                return 0 as *mut xmlChar
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int != '\'' as i32 &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int != '\"' as i32 {
                return 0 as *mut xmlChar
            }
        }
        URI = xmlParseSystemLiteral(ctxt);
        if URI.is_null() {
            xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, 0 as *const std::os::raw::c_char);
        }
    }
    return URI;
}
/* *
 * xmlParseCommentComplex:
 * @ctxt:  an XML parser context
 * @buf:  the already parsed part of the buffer
 * @len:  number of bytes filles in the buffer
 * @size:  allocated size of the buffer
 *
 * Skip an XML (SGML) comment <!-- .... -->
 *  The spec says that "For compatibility, the string "--" (double-hyphen)
 *  must not occur within comments. "
 * This is the slow routine in case the accelerator for ascii didn't work
 *
 * [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
 */
unsafe extern "C" fn xmlParseCommentComplex(mut ctxt: xmlParserCtxtPtr,
                                            mut buf: *mut xmlChar,
                                            mut len: size_t,
                                            mut size: size_t) {
    let mut q: std::os::raw::c_int = 0;
    let mut ql: std::os::raw::c_int = 0;
    let mut r: std::os::raw::c_int = 0;
    let mut rl: std::os::raw::c_int = 0;
    let mut cur: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut count: size_t = 0 as std::os::raw::c_int as size_t;
    let mut inputid: std::os::raw::c_int = 0;
    inputid = (*(*ctxt).input).id;
    if buf.is_null() {
        len = 0 as std::os::raw::c_int as size_t;
        size = 100 as std::os::raw::c_int as size_t;
        buf =
            xmlMallocAtomic.expect("non-null function pointer")(size.wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                      as
                                                                                      std::os::raw::c_ulong))
                as *mut xmlChar;
        if buf.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return
        }
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    /* Assure there's enough input data */
    q = xmlCurrentChar(ctxt, &mut ql);
    if !(q == 0 as std::os::raw::c_int) {
        if if q < 0x100 as std::os::raw::c_int {
               (0x9 as std::os::raw::c_int <= q && q <= 0xa as std::os::raw::c_int ||
                    q == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= q) as
                   std::os::raw::c_int
           } else {
               (0x100 as std::os::raw::c_int <= q && q <= 0xd7ff as std::os::raw::c_int ||
                    0xe000 as std::os::raw::c_int <= q && q <= 0xfffd as std::os::raw::c_int
                    ||
                    0x10000 as std::os::raw::c_int <= q &&
                        q <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
           } == 0 {
            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                              b"xmlParseComment: invalid xmlChar value %d\n\x00"
                                  as *const u8 as *const std::os::raw::c_char, q);
            xmlFree.expect("non-null function pointer")(buf as
                                                            *mut std::os::raw::c_void);
            return
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(ql as isize);
        r = xmlCurrentChar(ctxt, &mut rl);
        if !(r == 0 as std::os::raw::c_int) {
            if if r < 0x100 as std::os::raw::c_int {
                   (0x9 as std::os::raw::c_int <= r && r <= 0xa as std::os::raw::c_int ||
                        r == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= r)
                       as std::os::raw::c_int
               } else {
                   (0x100 as std::os::raw::c_int <= r && r <= 0xd7ff as std::os::raw::c_int ||
                        0xe000 as std::os::raw::c_int <= r &&
                            r <= 0xfffd as std::os::raw::c_int ||
                        0x10000 as std::os::raw::c_int <= r &&
                            r <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
               } == 0 {
                xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                                  b"xmlParseComment: invalid xmlChar value %d\n\x00"
                                      as *const u8 as *const std::os::raw::c_char, q);
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                return
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                (*(*ctxt).input).line += 1;
                (*(*ctxt).input).col = 1 as std::os::raw::c_int
            } else { (*(*ctxt).input).col += 1 }
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(rl as isize);
            cur = xmlCurrentChar(ctxt, &mut l);
            if !(cur == 0 as std::os::raw::c_int) {
                while (if cur < 0x100 as std::os::raw::c_int {
                           (0x9 as std::os::raw::c_int <= cur &&
                                cur <= 0xa as std::os::raw::c_int ||
                                cur == 0xd as std::os::raw::c_int ||
                                0x20 as std::os::raw::c_int <= cur) as std::os::raw::c_int
                       } else {
                           (0x100 as std::os::raw::c_int <= cur &&
                                cur <= 0xd7ff as std::os::raw::c_int ||
                                0xe000 as std::os::raw::c_int <= cur &&
                                    cur <= 0xfffd as std::os::raw::c_int ||
                                0x10000 as std::os::raw::c_int <= cur &&
                                    cur <= 0x10ffff as std::os::raw::c_int) as
                               std::os::raw::c_int
                       }) != 0 &&
                          (cur != '>' as i32 || r != '-' as i32 ||
                               q != '-' as i32) {
                    if r == '-' as i32 && q == '-' as i32 {
                        xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
                                    0 as *const std::os::raw::c_char);
                    }
                    if len > 10000000 as std::os::raw::c_int as std::os::raw::c_ulong &&
                           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                        xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
                                          b"Comment too big found\x00" as
                                              *const u8 as
                                              *const std::os::raw::c_char,
                                          0 as *const xmlChar);
                        xmlFree.expect("non-null function pointer")(buf as
                                                                        *mut std::os::raw::c_void);
                        return
                    }
                    if len.wrapping_add(5 as std::os::raw::c_int as std::os::raw::c_ulong) >=
                           size {
                        let mut new_buf: *mut xmlChar = 0 as *mut xmlChar;
                        let mut new_size: size_t = 0;
                        new_size =
                            size.wrapping_mul(2 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong);
                        new_buf =
                            xmlRealloc.expect("non-null function pointer")(buf
                                                                               as
                                                                               *mut std::os::raw::c_void,
                                                                           new_size)
                                as *mut xmlChar;
                        if new_buf.is_null() {
                            xmlFree.expect("non-null function pointer")(buf as
                                                                            *mut std::os::raw::c_void);
                            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                            return
                        }
                        buf = new_buf;
                        size = new_size
                    }
                    if ql == 1 as std::os::raw::c_int {
                        let fresh88 = len;
                        len = len.wrapping_add(1);
                        *buf.offset(fresh88 as isize) = q as xmlChar
                    } else {
                        len =
                            (len as
                                 std::os::raw::c_ulong).wrapping_add(xmlCopyCharMultiByte(&mut *buf.offset(len
                                                                                                       as
                                                                                                       isize),
                                                                                  q)
                                                                 as
                                                                 std::os::raw::c_ulong)
                                as size_t as size_t
                    }
                    q = r;
                    ql = rl;
                    r = cur;
                    rl = l;
                    count = count.wrapping_add(1);
                    if count > 50 as std::os::raw::c_int as std::os::raw::c_ulong {
                        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                    as std::os::raw::c_long) <
                                   250 as std::os::raw::c_int as std::os::raw::c_long {
                            xmlGROW(ctxt);
                        }
                        count = 0 as std::os::raw::c_int as size_t;
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            xmlFree.expect("non-null function pointer")(buf as
                                                                            *mut std::os::raw::c_void);
                            return
                        }
                    }
                    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                        (*(*ctxt).input).line += 1;
                        (*(*ctxt).input).col = 1 as std::os::raw::c_int
                    } else { (*(*ctxt).input).col += 1 }
                    (*(*ctxt).input).cur =
                        (*(*ctxt).input).cur.offset(l as isize);
                    cur = xmlCurrentChar(ctxt, &mut l);
                    if cur == 0 as std::os::raw::c_int {
                        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                               (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                   as std::os::raw::c_long >
                                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                                       std::os::raw::c_long &&
                               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                    as std::os::raw::c_long) <
                                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                                       std::os::raw::c_long {
                            xmlSHRINK(ctxt);
                        }
                        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                    as std::os::raw::c_long) <
                                   250 as std::os::raw::c_int as std::os::raw::c_long {
                            xmlGROW(ctxt);
                        }
                        cur = xmlCurrentChar(ctxt, &mut l)
                    }
                }
                *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
                if cur == 0 as std::os::raw::c_int {
                    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
                                      b"Comment not terminated \n<!--%.50s\n\x00"
                                          as *const u8 as *const std::os::raw::c_char,
                                      buf);
                } else if if cur < 0x100 as std::os::raw::c_int {
                              (0x9 as std::os::raw::c_int <= cur &&
                                   cur <= 0xa as std::os::raw::c_int ||
                                   cur == 0xd as std::os::raw::c_int ||
                                   0x20 as std::os::raw::c_int <= cur) as std::os::raw::c_int
                          } else {
                              (0x100 as std::os::raw::c_int <= cur &&
                                   cur <= 0xd7ff as std::os::raw::c_int ||
                                   0xe000 as std::os::raw::c_int <= cur &&
                                       cur <= 0xfffd as std::os::raw::c_int ||
                                   0x10000 as std::os::raw::c_int <= cur &&
                                       cur <= 0x10ffff as std::os::raw::c_int) as
                                  std::os::raw::c_int
                          } == 0 {
                    xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                                      b"xmlParseComment: invalid xmlChar value %d\n\x00"
                                          as *const u8 as *const std::os::raw::c_char,
                                      cur);
                } else {
                    if inputid != (*(*ctxt).input).id {
                        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                       b"Comment doesn\'t start and stop in the same entity\n\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char);
                    }
                    xmlNextChar(ctxt);
                    if !(*ctxt).sax.is_null() &&
                           (*(*ctxt).sax).comment.is_some() &&
                           (*ctxt).disableSAX == 0 {
                        (*(*ctxt).sax).comment.expect("non-null function pointer")((*ctxt).userData,
                                                                                   buf);
                    }
                }
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                return
            }
        }
    }
    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
                      b"Comment not terminated\n\x00" as *const u8 as
                          *const std::os::raw::c_char, 0 as *const xmlChar);
    xmlFree.expect("non-null function pointer")(buf as *mut std::os::raw::c_void);
}
/* *
 * xmlParseComment:
 * @ctxt:  an XML parser context
 *
 * Skip an XML (SGML) comment <!-- .... -->
 *  The spec says that "For compatibility, the string "--" (double-hyphen)
 *  must not occur within comments. "
 *
 * [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseComment(mut ctxt: xmlParserCtxtPtr) {
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut size: size_t = 100 as std::os::raw::c_int as size_t;
    let mut len: size_t = 0 as std::os::raw::c_int as size_t;
    let mut state: xmlParserInputState = XML_PARSER_START;
    let mut in_0: *const xmlChar = 0 as *const xmlChar;
    let mut nbchar: size_t = 0 as std::os::raw::c_int as size_t;
    let mut ccol: std::os::raw::c_int = 0;
    let mut inputid: std::os::raw::c_int = 0;
    /*
     * Check that there is a comment right here.
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 ||
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '!' as i32 ||
           *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '-' as i32 ||
           *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '-' as i32 {
        return
    }
    state = (*ctxt).instate;
    (*ctxt).instate = XML_PARSER_COMMENT;
    inputid = (*(*ctxt).input).id;
    (*ctxt).nbChars += 4 as std::os::raw::c_int as std::os::raw::c_long;
    (*(*ctxt).input).cur =
        (*(*ctxt).input).cur.offset(4 as std::os::raw::c_int as isize);
    (*(*ctxt).input).col += 4 as std::os::raw::c_int;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    /*
     * Accelerated common case where input don't need to be
     * modified before passing it to the handler.
     */
    in_0 = (*(*ctxt).input).cur;
    loop  {
        if *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int {
            loop  {
                (*(*ctxt).input).line += 1;
                (*(*ctxt).input).col = 1 as std::os::raw::c_int;
                in_0 = in_0.offset(1);
                if !(*in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int) { break ; }
            }
        }
        loop  {
            ccol = (*(*ctxt).input).col;
            while *in_0 as std::os::raw::c_int > '-' as i32 &&
                      *in_0 as std::os::raw::c_int <= 0x7f as std::os::raw::c_int ||
                      *in_0 as std::os::raw::c_int >= 0x20 as std::os::raw::c_int &&
                          (*in_0 as std::os::raw::c_int) < '-' as i32 ||
                      *in_0 as std::os::raw::c_int == 0x9 as std::os::raw::c_int {
                in_0 = in_0.offset(1);
                ccol += 1
            }
            (*(*ctxt).input).col = ccol;
            if *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int {
                loop  {
                    (*(*ctxt).input).line += 1;
                    (*(*ctxt).input).col = 1 as std::os::raw::c_int;
                    in_0 = in_0.offset(1);
                    if !(*in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int) {
                        break ;
                    }
                }
            } else {
                nbchar =
                    in_0.offset_from((*(*ctxt).input).cur) as
                        std::os::raw::c_long as size_t;
                /*
	 * save current set of data
	 */
                if nbchar > 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                    if !(*ctxt).sax.is_null() &&
                           (*(*ctxt).sax).comment.is_some() {
                        if buf.is_null() {
                            if *in_0 as std::os::raw::c_int == '-' as i32 &&
                                   *in_0.offset(1 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_int == '-' as i32 {
                                size =
                                    nbchar.wrapping_add(1 as std::os::raw::c_int as
                                                            std::os::raw::c_ulong)
                            } else {
                                size =
                                    (100 as std::os::raw::c_int as
                                         std::os::raw::c_ulong).wrapping_add(nbchar)
                            }
                            buf =
                                xmlMallocAtomic.expect("non-null function pointer")(size.wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                          as
                                                                                                          std::os::raw::c_ulong))
                                    as *mut xmlChar;
                            if buf.is_null() {
                                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                                (*ctxt).instate = state;
                                return
                            }
                            len = 0 as std::os::raw::c_int as size_t
                        } else if len.wrapping_add(nbchar).wrapping_add(1 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            std::os::raw::c_ulong)
                                      >= size {
                            let mut new_buf: *mut xmlChar = 0 as *mut xmlChar;
                            size =
                                (size as
                                     std::os::raw::c_ulong).wrapping_add(len.wrapping_add(nbchar).wrapping_add(100
                                                                                                           as
                                                                                                           std::os::raw::c_int
                                                                                                           as
                                                                                                           std::os::raw::c_ulong))
                                    as size_t as size_t;
                            new_buf =
                                xmlRealloc.expect("non-null function pointer")(buf
                                                                                   as
                                                                                   *mut std::os::raw::c_void,
                                                                               size.wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                     as
                                                                                                     std::os::raw::c_ulong))
                                    as *mut xmlChar;
                            if new_buf.is_null() {
                                xmlFree.expect("non-null function pointer")(buf
                                                                                as
                                                                                *mut std::os::raw::c_void);
                                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                                (*ctxt).instate = state;
                                return
                            }
                            buf = new_buf
                        }
                        memcpy(&mut *buf.offset(len as isize) as *mut xmlChar
                                   as *mut std::os::raw::c_void,
                               (*(*ctxt).input).cur as *const std::os::raw::c_void,
                               nbchar);
                        len =
                            (len as std::os::raw::c_ulong).wrapping_add(nbchar) as
                                size_t as size_t;
                        *buf.offset(len as isize) =
                            0 as std::os::raw::c_int as xmlChar
                    }
                }
                if len > 10000000 as std::os::raw::c_int as std::os::raw::c_ulong &&
                       (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
                                      b"Comment too big found\x00" as
                                          *const u8 as *const std::os::raw::c_char,
                                      0 as *const xmlChar);
                    xmlFree.expect("non-null function pointer")(buf as
                                                                    *mut std::os::raw::c_void);
                    return
                }
                (*(*ctxt).input).cur = in_0;
                if *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int {
                    in_0 = in_0.offset(1);
                    (*(*ctxt).input).line += 1;
                    (*(*ctxt).input).col = 1 as std::os::raw::c_int
                }
                if *in_0 as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                    in_0 = in_0.offset(1);
                    if *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int {
                        (*(*ctxt).input).cur = in_0;
                        in_0 = in_0.offset(1);
                        (*(*ctxt).input).line += 1;
                        (*(*ctxt).input).col = 1 as std::os::raw::c_int;
                        break ;
                        /* while */
                    } else { in_0 = in_0.offset(-1) }
                }
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                           as std::os::raw::c_long >
                           (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                               std::os::raw::c_long &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                               std::os::raw::c_long {
                    xmlSHRINK(ctxt);
                }
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    xmlFree.expect("non-null function pointer")(buf as
                                                                    *mut std::os::raw::c_void);
                    return
                }
                in_0 = (*(*ctxt).input).cur;
                if !(*in_0 as std::os::raw::c_int == '-' as i32) { break ; }
                if *in_0.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                       '-' as i32 {
                    if *in_0.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int
                           == '>' as i32 {
                        if (*(*ctxt).input).id != inputid {
                            xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                           b"comment doesn\'t start and stop in the same entity\n\x00"
                                               as *const u8 as
                                               *const std::os::raw::c_char);
                        }
                        (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
                        (*(*ctxt).input).cur =
                            (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                            isize);
                        (*(*ctxt).input).col += 3 as std::os::raw::c_int;
                        if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                            xmlParserInputGrow((*ctxt).input,
                                               250 as std::os::raw::c_int);
                        }
                        if !(*ctxt).sax.is_null() &&
                               (*(*ctxt).sax).comment.is_some() &&
                               (*ctxt).disableSAX == 0 {
                            if !buf.is_null() {
                                (*(*ctxt).sax).comment.expect("non-null function pointer")((*ctxt).userData,
                                                                                           buf);
                            } else {
                                (*(*ctxt).sax).comment.expect("non-null function pointer")((*ctxt).userData,
                                                                                           b"\x00"
                                                                                               as
                                                                                               *const u8
                                                                                               as
                                                                                               *const std::os::raw::c_char
                                                                                               as
                                                                                               *mut xmlChar);
                            }
                        }
                        if !buf.is_null() {
                            xmlFree.expect("non-null function pointer")(buf as
                                                                            *mut std::os::raw::c_void);
                        }
                        if (*ctxt).instate as std::os::raw::c_int !=
                               XML_PARSER_EOF as std::os::raw::c_int {
                            (*ctxt).instate = state
                        }
                        return
                    }
                    if !buf.is_null() {
                        xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
                                          b"Double hyphen within comment: <!--%.50s\n\x00"
                                              as *const u8 as
                                              *const std::os::raw::c_char, buf);
                    } else {
                        xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
                                          b"Double hyphen within comment\n\x00"
                                              as *const u8 as
                                              *const std::os::raw::c_char,
                                          0 as *const xmlChar);
                    }
                    in_0 = in_0.offset(1);
                    (*(*ctxt).input).col += 1
                }
                in_0 = in_0.offset(1);
                (*(*ctxt).input).col += 1
            }
        }
        if !(*in_0 as std::os::raw::c_int >= 0x20 as std::os::raw::c_int &&
                 *in_0 as std::os::raw::c_int <= 0x7f as std::os::raw::c_int ||
                 *in_0 as std::os::raw::c_int == 0x9 as std::os::raw::c_int) {
            break ;
        }
    }
    xmlParseCommentComplex(ctxt, buf, len, size);
    (*ctxt).instate = state;
}
/* *
 * xmlParsePITarget:
 * @ctxt:  an XML parser context
 *
 * parse the name of a PI
 *
 * [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
 *
 * Returns the PITarget name or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParsePITarget(mut ctxt: xmlParserCtxtPtr)
 -> *const xmlChar {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    name = xmlParseName(ctxt);
    if !name.is_null() &&
           (*name.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                'x' as i32 ||
                *name.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                    'X' as i32) &&
           (*name.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                'm' as i32 ||
                *name.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                    'M' as i32) &&
           (*name.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                'l' as i32 ||
                *name.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                    'L' as i32) {
        let mut i: std::os::raw::c_int = 0;
        if *name.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
               'x' as i32 &&
               *name.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   'm' as i32 &&
               *name.offset(2 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   'l' as i32 &&
               *name.offset(3 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
                           b"XML declaration allowed only at the start of the document\n\x00"
                               as *const u8 as *const std::os::raw::c_char);
            return name
        } else {
            if *name.offset(3 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
                xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME,
                            0 as *const std::os::raw::c_char);
                return name
            }
        }
        i = 0 as std::os::raw::c_int;
        while !xmlW3CPIs[i as usize].is_null() {
            if xmlStrEqual(name, xmlW3CPIs[i as usize] as *const xmlChar) != 0
               {
                return name
            }
            i += 1
        }
        xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
                      b"xmlParsePITarget: invalid name prefix \'xml\'\n\x00"
                          as *const u8 as *const std::os::raw::c_char,
                      0 as *const xmlChar, 0 as *const xmlChar);
    }
    if !name.is_null() && !xmlStrchr(name, ':' as i32 as xmlChar).is_null() {
        xmlNsErr(ctxt, XML_NS_ERR_COLON,
                 b"colons are forbidden from PI names \'%s\'\n\x00" as
                     *const u8 as *const std::os::raw::c_char, name,
                 0 as *const xmlChar, 0 as *const xmlChar);
    }
    return name;
}
/* *
 * xmlParseCatalogPI:
 * @ctxt:  an XML parser context
 * @catalog:  the PI value string
 *
 * parse an XML Catalog Processing Instruction.
 *
 * <?oasis-xml-catalog catalog="http://example.com/catalog.xml"?>
 *
 * Occurs only if allowed by the user and if happening in the Misc
 * part of the document before any doctype informations
 * This will add the given catalog to the parsing context in order
 * to be used if there is a resolution need further down in the document
 */
unsafe extern "C" fn xmlParseCatalogPI(mut ctxt: xmlParserCtxtPtr,
                                       mut catalog: *const xmlChar) {
    let mut URL: *mut xmlChar = 0 as *mut xmlChar;
    let mut tmp: *const xmlChar = 0 as *const xmlChar;
    let mut base: *const xmlChar = 0 as *const xmlChar;
    let mut marker: xmlChar = 0;
    tmp = catalog;
    while *tmp as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
              0x9 as std::os::raw::c_int <= *tmp as std::os::raw::c_int &&
                  *tmp as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
              *tmp as std::os::raw::c_int == 0xd as std::os::raw::c_int {
        tmp = tmp.offset(1)
    }
    if !(xmlStrncmp(tmp,
                    b"catalog\x00" as *const u8 as *const std::os::raw::c_char as
                        *mut xmlChar, 7 as std::os::raw::c_int) != 0) {
        tmp = tmp.offset(7 as std::os::raw::c_int as isize);
        while *tmp as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                  0x9 as std::os::raw::c_int <= *tmp as std::os::raw::c_int &&
                      *tmp as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                  *tmp as std::os::raw::c_int == 0xd as std::os::raw::c_int {
            tmp = tmp.offset(1)
        }
        if *tmp as std::os::raw::c_int != '=' as i32 { return }
        tmp = tmp.offset(1);
        while *tmp as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                  0x9 as std::os::raw::c_int <= *tmp as std::os::raw::c_int &&
                      *tmp as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                  *tmp as std::os::raw::c_int == 0xd as std::os::raw::c_int {
            tmp = tmp.offset(1)
        }
        marker = *tmp;
        if !(marker as std::os::raw::c_int != '\'' as i32 &&
                 marker as std::os::raw::c_int != '\"' as i32) {
            tmp = tmp.offset(1);
            base = tmp;
            while *tmp as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                      *tmp as std::os::raw::c_int != marker as std::os::raw::c_int {
                tmp = tmp.offset(1)
            }
            if !(*tmp as std::os::raw::c_int == 0 as std::os::raw::c_int) {
                URL =
                    xmlStrndup(base,
                               tmp.offset_from(base) as std::os::raw::c_long
                                   as std::os::raw::c_int);
                tmp = tmp.offset(1);
                while *tmp as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                          0x9 as std::os::raw::c_int <= *tmp as std::os::raw::c_int &&
                              *tmp as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                          *tmp as std::os::raw::c_int == 0xd as std::os::raw::c_int {
                    tmp = tmp.offset(1)
                }
                if !(*tmp as std::os::raw::c_int != 0 as std::os::raw::c_int) {
                    if !URL.is_null() {
                        (*ctxt).catalogs =
                            xmlCatalogAddLocal((*ctxt).catalogs, URL);
                        xmlFree.expect("non-null function pointer")(URL as
                                                                        *mut std::os::raw::c_void);
                    }
                    return
                }
            }
        }
    }
    xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI,
                  b"Catalog PI syntax error: %s\n\x00" as *const u8 as
                      *const std::os::raw::c_char, catalog, 0 as *const xmlChar);
    if !URL.is_null() {
        xmlFree.expect("non-null function pointer")(URL as *mut std::os::raw::c_void);
    };
}
/* *
 * xmlParsePI:
 * @ctxt:  an XML parser context
 *
 * parse an XML Processing Instruction.
 *
 * [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
 *
 * The processing is transfered to SAX once parsed.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParsePI(mut ctxt: xmlParserCtxtPtr) {
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: size_t = 0 as std::os::raw::c_int as size_t;
    let mut size: size_t = 100 as std::os::raw::c_int as size_t;
    let mut cur: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut target: *const xmlChar = 0 as *const xmlChar;
    let mut state: xmlParserInputState = XML_PARSER_START;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '?' as i32 {
        let mut inputid: std::os::raw::c_int = (*(*ctxt).input).id;
        state = (*ctxt).instate;
        (*ctxt).instate = XML_PARSER_PI;
        /*
	 * this is a Processing Instruction.
	 */
        (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 2 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                   as std::os::raw::c_long >
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) <
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
            xmlSHRINK(ctxt);
        }
        /*
	 * Parse the target name and check for special support like
	 * namespace.
	 */
        target = xmlParsePITarget(ctxt);
        if !target.is_null() {
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '?' as i32 &&
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == '>' as i32 {
                if inputid != (*(*ctxt).input).id {
                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                   b"PI declaration doesn\'t start and stop in the same entity\n\x00"
                                       as *const u8 as *const std::os::raw::c_char);
                }
                (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 2 as std::os::raw::c_int;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
                /*
		 * SAX: PI detected.
		 */
                if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                       (*(*ctxt).sax).processingInstruction.is_some() {
                    (*(*ctxt).sax).processingInstruction.expect("non-null function pointer")((*ctxt).userData,
                                                                                             target,
                                                                                             0
                                                                                                 as
                                                                                                 *const xmlChar);
                }
                if (*ctxt).instate as std::os::raw::c_int !=
                       XML_PARSER_EOF as std::os::raw::c_int {
                    (*ctxt).instate = state
                }
                return
            }
            buf =
                xmlMallocAtomic.expect("non-null function pointer")(size.wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                          as
                                                                                          std::os::raw::c_ulong))
                    as *mut xmlChar;
            if buf.is_null() {
                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                (*ctxt).instate = state;
                return
            }
            if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
                xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,
                                  b"ParsePI: PI %s space expected\n\x00" as
                                      *const u8 as *const std::os::raw::c_char,
                                  target);
            }
            cur = xmlCurrentChar(ctxt, &mut l);
            while (if cur < 0x100 as std::os::raw::c_int {
                       (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int
                            || cur == 0xd as std::os::raw::c_int ||
                            0x20 as std::os::raw::c_int <= cur) as std::os::raw::c_int
                   } else {
                       (0x100 as std::os::raw::c_int <= cur &&
                            cur <= 0xd7ff as std::os::raw::c_int ||
                            0xe000 as std::os::raw::c_int <= cur &&
                                cur <= 0xfffd as std::os::raw::c_int ||
                            0x10000 as std::os::raw::c_int <= cur &&
                                cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
                   }) != 0 &&
                      (cur != '?' as i32 ||
                           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                            isize) as
                               std::os::raw::c_int != '>' as i32) {
                if len.wrapping_add(5 as std::os::raw::c_int as std::os::raw::c_ulong) >= size
                   {
                    let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                    let mut new_size: size_t =
                        size.wrapping_mul(2 as std::os::raw::c_int as std::os::raw::c_ulong);
                    tmp =
                        xmlRealloc.expect("non-null function pointer")(buf as
                                                                           *mut std::os::raw::c_void,
                                                                       new_size)
                            as *mut xmlChar;
                    if tmp.is_null() {
                        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                        xmlFree.expect("non-null function pointer")(buf as
                                                                        *mut std::os::raw::c_void);
                        (*ctxt).instate = state;
                        return
                    }
                    buf = tmp;
                    size = new_size
                }
                count += 1;
                if count > 50 as std::os::raw::c_int {
                    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               250 as std::os::raw::c_int as std::os::raw::c_long {
                        xmlGROW(ctxt);
                    }
                    if (*ctxt).instate as std::os::raw::c_int ==
                           XML_PARSER_EOF as std::os::raw::c_int {
                        xmlFree.expect("non-null function pointer")(buf as
                                                                        *mut std::os::raw::c_void);
                        return
                    }
                    count = 0 as std::os::raw::c_int;
                    if len > 10000000 as std::os::raw::c_int as std::os::raw::c_ulong &&
                           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                        xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
                                          b"PI %s too big found\x00" as
                                              *const u8 as
                                              *const std::os::raw::c_char, target);
                        xmlFree.expect("non-null function pointer")(buf as
                                                                        *mut std::os::raw::c_void);
                        (*ctxt).instate = state;
                        return
                    }
                }
                if l == 1 as std::os::raw::c_int {
                    let fresh89 = len;
                    len = len.wrapping_add(1);
                    *buf.offset(fresh89 as isize) = cur as xmlChar
                } else {
                    len =
                        (len as
                             std::os::raw::c_ulong).wrapping_add(xmlCopyCharMultiByte(&mut *buf.offset(len
                                                                                                   as
                                                                                                   isize),
                                                                              cur)
                                                             as std::os::raw::c_ulong)
                            as size_t as size_t
                }
                if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
                    (*(*ctxt).input).line += 1;
                    (*(*ctxt).input).col = 1 as std::os::raw::c_int
                } else { (*(*ctxt).input).col += 1 }
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(l as isize);
                cur = xmlCurrentChar(ctxt, &mut l);
                if cur == 0 as std::os::raw::c_int {
                    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                               as std::os::raw::c_long >
                               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                                   std::os::raw::c_long &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                                   std::os::raw::c_long {
                        xmlSHRINK(ctxt);
                    }
                    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               250 as std::os::raw::c_int as std::os::raw::c_long {
                        xmlGROW(ctxt);
                    }
                    cur = xmlCurrentChar(ctxt, &mut l)
                }
            }
            if len > 10000000 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
                                  b"PI %s too big found\x00" as *const u8 as
                                      *const std::os::raw::c_char, target);
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                (*ctxt).instate = state;
                return
            }
            *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
            if cur != '?' as i32 {
                xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
                                  b"ParsePI: PI %s never end ...\n\x00" as
                                      *const u8 as *const std::os::raw::c_char,
                                  target);
            } else {
                if inputid != (*(*ctxt).input).id {
                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                   b"PI declaration doesn\'t start and stop in the same entity\n\x00"
                                       as *const u8 as *const std::os::raw::c_char);
                }
                (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 2 as std::os::raw::c_int;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
                if (state as std::os::raw::c_int == XML_PARSER_MISC as std::os::raw::c_int ||
                        state as std::os::raw::c_int ==
                            XML_PARSER_START as std::os::raw::c_int) &&
                       xmlStrEqual(target,
                                   b"oasis-xml-catalog\x00" as *const u8 as
                                       *const std::os::raw::c_char as *const xmlChar)
                           != 0 {
                    let mut allow: xmlCatalogAllow = xmlCatalogGetDefaults();
                    if allow as std::os::raw::c_uint ==
                           XML_CATA_ALLOW_DOCUMENT as std::os::raw::c_int as
                               std::os::raw::c_uint ||
                           allow as std::os::raw::c_uint ==
                               XML_CATA_ALLOW_ALL as std::os::raw::c_int as
                                   std::os::raw::c_uint {
                        xmlParseCatalogPI(ctxt, buf);
                    }
                }
                /*
		 * SAX: PI detected.
		 */
                if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                       (*(*ctxt).sax).processingInstruction.is_some() {
                    (*(*ctxt).sax).processingInstruction.expect("non-null function pointer")((*ctxt).userData,
                                                                                             target,
                                                                                             buf);
                }
            }
            xmlFree.expect("non-null function pointer")(buf as
                                                            *mut std::os::raw::c_void);
        } else {
            xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED,
                        0 as *const std::os::raw::c_char);
        }
        if (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int {
            (*ctxt).instate = state
        }
    };
}
/* *
 * xmlParseNotationDecl:
 * @ctxt:  an XML parser context
 *
 * parse a notation declaration
 *
 * [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID |  PublicID) S? '>'
 *
 * Hence there is actually 3 choices:
 *     'PUBLIC' S PubidLiteral
 *     'PUBLIC' S PubidLiteral S SystemLiteral
 * and 'SYSTEM' S SystemLiteral
 *
 * See the NOTE on xmlParseExternalID().
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseNotationDecl(mut ctxt: xmlParserCtxtPtr) {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut Pubid: *mut xmlChar = 0 as *mut xmlChar;
    let mut Systemid: *mut xmlChar = 0 as *mut xmlChar;
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '!' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'N' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'O' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'I' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(8 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'O' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(9 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'N' as i32 {
        let mut inputid: std::os::raw::c_int = (*(*ctxt).input).id;
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                   as std::os::raw::c_long >
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) <
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
            xmlSHRINK(ctxt);
        }
        (*ctxt).nbChars += 10 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(10 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 10 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after \'<!NOTATION\'\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
            return
        }
        name = xmlParseName(ctxt);
        if name.is_null() {
            xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED,
                        0 as *const std::os::raw::c_char);
            return
        }
        if !xmlStrchr(name, ':' as i32 as xmlChar).is_null() {
            xmlNsErr(ctxt, XML_NS_ERR_COLON,
                     b"colons are forbidden from notation names \'%s\'\n\x00"
                         as *const u8 as *const std::os::raw::c_char, name,
                     0 as *const xmlChar, 0 as *const xmlChar);
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after the NOTATION name\'\n\x00"
                               as *const u8 as *const std::os::raw::c_char);
            return
        }
        /*
	 * Parse the IDs.
	 */
        Systemid = xmlParseExternalID(ctxt, &mut Pubid, 0 as std::os::raw::c_int);
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
            if inputid != (*(*ctxt).input).id {
                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                               b"Notation declaration doesn\'t start and stop in the same entity\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
            xmlNextChar(ctxt);
            if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                   (*(*ctxt).sax).notationDecl.is_some() {
                (*(*ctxt).sax).notationDecl.expect("non-null function pointer")((*ctxt).userData,
                                                                                name,
                                                                                Pubid,
                                                                                Systemid);
            }
        } else {
            xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED,
                        0 as *const std::os::raw::c_char);
        }
        if !Systemid.is_null() {
            xmlFree.expect("non-null function pointer")(Systemid as
                                                            *mut std::os::raw::c_void);
        }
        if !Pubid.is_null() {
            xmlFree.expect("non-null function pointer")(Pubid as
                                                            *mut std::os::raw::c_void);
        }
    };
}
/* *
 * xmlParseEntityDecl:
 * @ctxt:  an XML parser context
 *
 * parse <!ENTITY declarations
 *
 * [70] EntityDecl ::= GEDecl | PEDecl
 *
 * [71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'
 *
 * [72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'
 *
 * [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)
 *
 * [74] PEDef ::= EntityValue | ExternalID
 *
 * [76] NDataDecl ::= S 'NDATA' S Name
 *
 * [ VC: Notation Declared ]
 * The Name must match the declared name of a notation.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseEntityDecl(mut ctxt: xmlParserCtxtPtr) {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut literal: *mut xmlChar = 0 as *mut xmlChar;
    let mut ndata: *const xmlChar = 0 as *const xmlChar;
    let mut isParameter: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut orig: *mut xmlChar = 0 as *mut xmlChar;
    /* GROW; done in the caller */
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '!' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'N' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'I' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'Y' as i32 {
        let mut inputid: std::os::raw::c_int = (*(*ctxt).input).id;
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                   as std::os::raw::c_long >
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) <
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
            xmlSHRINK(ctxt);
        }
        (*ctxt).nbChars += 8 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(8 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 8 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after \'<!ENTITY\'\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '%' as i32 {
            xmlNextChar(ctxt);
            if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                               b"Space required after \'%%\'\n\x00" as
                                   *const u8 as *const std::os::raw::c_char);
            }
            isParameter = 1 as std::os::raw::c_int
        }
        name = xmlParseName(ctxt);
        if name.is_null() {
            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                           b"xmlParseEntityDecl: no name\n\x00" as *const u8
                               as *const std::os::raw::c_char);
            return
        }
        if !xmlStrchr(name, ':' as i32 as xmlChar).is_null() {
            xmlNsErr(ctxt, XML_NS_ERR_COLON,
                     b"colons are forbidden from entities names \'%s\'\n\x00"
                         as *const u8 as *const std::os::raw::c_char, name,
                     0 as *const xmlChar, 0 as *const xmlChar);
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after the entity name\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
        }
        (*ctxt).instate = XML_PARSER_ENTITY_DECL;
        /*
	 * handle the various case of definitions...
	 */
        if isParameter != 0 {
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
                value = xmlParseEntityValue(ctxt, &mut orig);
                if !value.is_null() {
                    if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                           (*(*ctxt).sax).entityDecl.is_some() {
                        (*(*ctxt).sax).entityDecl.expect("non-null function pointer")((*ctxt).userData,
                                                                                      name,
                                                                                      XML_INTERNAL_PARAMETER_ENTITY
                                                                                          as
                                                                                          std::os::raw::c_int,
                                                                                      0
                                                                                          as
                                                                                          *const xmlChar,
                                                                                      0
                                                                                          as
                                                                                          *const xmlChar,
                                                                                      value);
                    }
                }
            } else {
                URI =
                    xmlParseExternalID(ctxt, &mut literal, 1 as std::os::raw::c_int);
                if URI.is_null() && literal.is_null() {
                    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED,
                                0 as *const std::os::raw::c_char);
                }
                if !URI.is_null() {
                    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
                    uri = xmlParseURI(URI as *const std::os::raw::c_char);
                    if uri.is_null() {
                        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
                                     b"Invalid URI: %s\n\x00" as *const u8 as
                                         *const std::os::raw::c_char, URI);
                        /*
			 * This really ought to be a well formedness error
			 * but the XML Core WG decided otherwise c.f. issue
			 * E26 of the XML erratas.
			 */
                    } else {
                        if !(*uri).fragment.is_null() {
                            /*
			     * Okay this is foolish to block those but not
			     * invalid URIs.
			     */
                            xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT,
                                        0 as *const std::os::raw::c_char);
                        } else if !(*ctxt).sax.is_null() &&
                                      (*ctxt).disableSAX == 0 &&
                                      (*(*ctxt).sax).entityDecl.is_some() {
                            (*(*ctxt).sax).entityDecl.expect("non-null function pointer")((*ctxt).userData,
                                                                                          name,
                                                                                          XML_EXTERNAL_PARAMETER_ENTITY
                                                                                              as
                                                                                              std::os::raw::c_int,
                                                                                          literal,
                                                                                          URI,
                                                                                          0
                                                                                              as
                                                                                              *mut xmlChar);
                        }
                        xmlFreeURI(uri);
                    }
                }
            }
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 ||
                      *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
            value = xmlParseEntityValue(ctxt, &mut orig);
            if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                   (*(*ctxt).sax).entityDecl.is_some() {
                (*(*ctxt).sax).entityDecl.expect("non-null function pointer")((*ctxt).userData,
                                                                              name,
                                                                              XML_INTERNAL_GENERAL_ENTITY
                                                                                  as
                                                                                  std::os::raw::c_int,
                                                                              0
                                                                                  as
                                                                                  *const xmlChar,
                                                                              0
                                                                                  as
                                                                                  *const xmlChar,
                                                                              value);
            }
            /*
		 * For expat compatibility in SAX mode.
		 */
            if (*ctxt).myDoc.is_null() ||
                   xmlStrEqual((*(*ctxt).myDoc).version,
                               b"SAX compatibility mode document\x00" as
                                   *const u8 as *const std::os::raw::c_char as
                                   *mut xmlChar) != 0 {
                if (*ctxt).myDoc.is_null() {
                    (*ctxt).myDoc =
                        xmlNewDoc(b"SAX compatibility mode document\x00" as
                                      *const u8 as *const std::os::raw::c_char as
                                      *mut xmlChar);
                    if (*ctxt).myDoc.is_null() {
                        xmlErrMemory(ctxt,
                                     b"New Doc failed\x00" as *const u8 as
                                         *const std::os::raw::c_char);
                        return
                    }
                    (*(*ctxt).myDoc).properties =
                        XML_DOC_INTERNAL as std::os::raw::c_int
                }
                if (*(*ctxt).myDoc).intSubset.is_null() {
                    (*(*ctxt).myDoc).intSubset =
                        xmlNewDtd((*ctxt).myDoc,
                                  b"fake\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar,
                                  0 as *const xmlChar, 0 as *const xmlChar)
                }
                xmlSAX2EntityDecl(ctxt as *mut std::os::raw::c_void, name,
                                  XML_INTERNAL_GENERAL_ENTITY as std::os::raw::c_int,
                                  0 as *const xmlChar, 0 as *const xmlChar,
                                  value);
            }
        } else {
            URI = xmlParseExternalID(ctxt, &mut literal, 1 as std::os::raw::c_int);
            if URI.is_null() && literal.is_null() {
                xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED,
                            0 as *const std::os::raw::c_char);
            }
            if !URI.is_null() {
                let mut uri_0: xmlURIPtr = 0 as *mut xmlURI;
                uri_0 = xmlParseURI(URI as *const std::os::raw::c_char);
                if uri_0.is_null() {
                    xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
                                 b"Invalid URI: %s\n\x00" as *const u8 as
                                     *const std::os::raw::c_char, URI);
                    /*
			 * This really ought to be a well formedness error
			 * but the XML Core WG decided otherwise c.f. issue
			 * E26 of the XML erratas.
			 */
                } else {
                    if !(*uri_0).fragment.is_null() {
                        /*
			     * Okay this is foolish to block those but not
			     * invalid URIs.
			     */
                        xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT,
                                    0 as *const std::os::raw::c_char);
                    }
                    xmlFreeURI(uri_0);
                }
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 &&
                   xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                               b"Space required before \'NDATA\'\n\x00" as
                                   *const u8 as *const std::os::raw::c_char);
            }
            if *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'N' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'D' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'A' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'T' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'A' as i32 {
                (*ctxt).nbChars += 5 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 5 as std::os::raw::c_int;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
                if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
                    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                                   b"Space required after \'NDATA\'\n\x00" as
                                       *const u8 as *const std::os::raw::c_char);
                }
                ndata = xmlParseName(ctxt);
                if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                       (*(*ctxt).sax).unparsedEntityDecl.is_some() {
                    (*(*ctxt).sax).unparsedEntityDecl.expect("non-null function pointer")((*ctxt).userData,
                                                                                          name,
                                                                                          literal,
                                                                                          URI,
                                                                                          ndata);
                }
            } else {
                if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                       (*(*ctxt).sax).entityDecl.is_some() {
                    (*(*ctxt).sax).entityDecl.expect("non-null function pointer")((*ctxt).userData,
                                                                                  name,
                                                                                  XML_EXTERNAL_GENERAL_PARSED_ENTITY
                                                                                      as
                                                                                      std::os::raw::c_int,
                                                                                  literal,
                                                                                  URI,
                                                                                  0
                                                                                      as
                                                                                      *mut xmlChar);
                }
                /*
		     * For expat compatibility in SAX mode.
		     * assuming the entity repalcement was asked for
		     */
                if (*ctxt).replaceEntities != 0 as std::os::raw::c_int &&
                       ((*ctxt).myDoc.is_null() ||
                            xmlStrEqual((*(*ctxt).myDoc).version,
                                        b"SAX compatibility mode document\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char as
                                            *mut xmlChar) != 0) {
                    if (*ctxt).myDoc.is_null() {
                        (*ctxt).myDoc =
                            xmlNewDoc(b"SAX compatibility mode document\x00"
                                          as *const u8 as *const std::os::raw::c_char
                                          as *mut xmlChar);
                        if (*ctxt).myDoc.is_null() {
                            xmlErrMemory(ctxt,
                                         b"New Doc failed\x00" as *const u8 as
                                             *const std::os::raw::c_char);
                            return
                        }
                        (*(*ctxt).myDoc).properties =
                            XML_DOC_INTERNAL as std::os::raw::c_int
                    }
                    if (*(*ctxt).myDoc).intSubset.is_null() {
                        (*(*ctxt).myDoc).intSubset =
                            xmlNewDtd((*ctxt).myDoc,
                                      b"fake\x00" as *const u8 as
                                          *const std::os::raw::c_char as *mut xmlChar,
                                      0 as *const xmlChar,
                                      0 as *const xmlChar)
                    }
                    xmlSAX2EntityDecl(ctxt as *mut std::os::raw::c_void, name,
                                      XML_EXTERNAL_GENERAL_PARSED_ENTITY as
                                          std::os::raw::c_int, literal, URI,
                                      0 as *mut xmlChar);
                }
            }
        }
        if !((*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int)
           {
            xmlSkipBlankChars(ctxt);
            if *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
                xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
                                  b"xmlParseEntityDecl: entity %s not terminated\n\x00"
                                      as *const u8 as *const std::os::raw::c_char,
                                  name);
                xmlHaltParser(ctxt);
            } else {
                if inputid != (*(*ctxt).input).id {
                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                   b"Entity declaration doesn\'t start and stop in the same entity\n\x00"
                                       as *const u8 as *const std::os::raw::c_char);
                }
                xmlNextChar(ctxt);
            }
            if !orig.is_null() {
                /*
	     * Ugly mechanism to save the raw entity value.
	     */
                let mut cur: xmlEntityPtr = 0 as xmlEntityPtr;
                if isParameter != 0 {
                    if !(*ctxt).sax.is_null() &&
                           (*(*ctxt).sax).getParameterEntity.is_some() {
                        cur =
                            (*(*ctxt).sax).getParameterEntity.expect("non-null function pointer")((*ctxt).userData,
                                                                                                  name)
                    }
                } else {
                    if !(*ctxt).sax.is_null() &&
                           (*(*ctxt).sax).getEntity.is_some() {
                        cur =
                            (*(*ctxt).sax).getEntity.expect("non-null function pointer")((*ctxt).userData,
                                                                                         name)
                    }
                    if cur.is_null() &&
                           (*ctxt).userData == ctxt as *mut std::os::raw::c_void {
                        cur =
                            xmlSAX2GetEntity(ctxt as *mut std::os::raw::c_void, name)
                    }
                }
                if !cur.is_null() && (*cur).orig.is_null() {
                    (*cur).orig = orig;
                    orig = 0 as *mut xmlChar
                }
            }
        }
        if !value.is_null() {
            xmlFree.expect("non-null function pointer")(value as
                                                            *mut std::os::raw::c_void);
        }
        if !URI.is_null() {
            xmlFree.expect("non-null function pointer")(URI as
                                                            *mut std::os::raw::c_void);
        }
        if !literal.is_null() {
            xmlFree.expect("non-null function pointer")(literal as
                                                            *mut std::os::raw::c_void);
        }
        if !orig.is_null() {
            xmlFree.expect("non-null function pointer")(orig as
                                                            *mut std::os::raw::c_void);
        }
    };
}
/* *
 * xmlParseDefaultDecl:
 * @ctxt:  an XML parser context
 * @value:  Receive a possible fixed default value for the attribute
 *
 * Parse an attribute default declaration
 *
 * [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue)
 *
 * [ VC: Required Attribute ]
 * if the default declaration is the keyword #REQUIRED, then the
 * attribute must be specified for all elements of the type in the
 * attribute-list declaration.
 *
 * [ VC: Attribute Default Legal ]
 * The declared default value must meet the lexical constraints of
 * the declared attribute type c.f. xmlValidateAttributeDecl()
 *
 * [ VC: Fixed Attribute Default ]
 * if an attribute has a default value declared with the #FIXED
 * keyword, instances of that attribute must match the default value.
 *
 * [ WFC: No < in Attribute Values ]
 * handled in xmlParseAttValue()
 *
 * returns: XML_ATTRIBUTE_NONE, XML_ATTRIBUTE_REQUIRED, XML_ATTRIBUTE_IMPLIED
 *          or XML_ATTRIBUTE_FIXED.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseDefaultDecl(mut ctxt: xmlParserCtxtPtr,
                                             mut value: *mut *mut xmlChar)
 -> std::os::raw::c_int {
    let mut val: std::os::raw::c_int = 0;
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    *value = 0 as *mut xmlChar;
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '#' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'R' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'Q' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'U' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'I' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'R' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(8 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'D' as i32 {
        (*ctxt).nbChars += 9 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(9 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 9 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        return XML_ATTRIBUTE_REQUIRED as std::os::raw::c_int
    }
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '#' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'I' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'M' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'P' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'L' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'I' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'D' as i32 {
        (*ctxt).nbChars += 8 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(8 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 8 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        return XML_ATTRIBUTE_IMPLIED as std::os::raw::c_int
    }
    val = XML_ATTRIBUTE_NONE as std::os::raw::c_int;
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '#' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'F' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'I' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'X' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'D' as i32 {
        (*ctxt).nbChars += 6 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 6 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        val = XML_ATTRIBUTE_FIXED as std::os::raw::c_int;
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after \'#FIXED\'\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
        }
    }
    ret = xmlParseAttValue(ctxt);
    (*ctxt).instate = XML_PARSER_DTD;
    if ret.is_null() {
        xmlFatalErrMsg(ctxt, (*ctxt).errNo as xmlParserErrors,
                       b"Attribute default value declaration error\n\x00" as
                           *const u8 as *const std::os::raw::c_char);
    } else { *value = ret }
    return val;
}
/* *
 * xmlParseNotationType:
 * @ctxt:  an XML parser context
 *
 * parse an Notation attribute type.
 *
 * Note: the leading 'NOTATION' S part has already being parsed...
 *
 * [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'
 *
 * [ VC: Notation Attributes ]
 * Values of this type must match one of the notation names included
 * in the declaration; all notation names in the declaration must be declared.
 *
 * Returns: the notation attribute tree built while parsing
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseNotationType(mut ctxt: xmlParserCtxtPtr)
 -> xmlEnumerationPtr {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlEnumerationPtr = 0 as xmlEnumerationPtr;
    let mut last: xmlEnumerationPtr = 0 as xmlEnumerationPtr;
    let mut cur: xmlEnumerationPtr = 0 as *mut xmlEnumeration;
    let mut tmp: xmlEnumerationPtr = 0 as *mut xmlEnumeration;
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '(' as i32 {
        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED,
                    0 as *const std::os::raw::c_char);
        return 0 as xmlEnumerationPtr
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    loop  {
        xmlNextChar(ctxt);
        xmlSkipBlankChars(ctxt);
        name = xmlParseName(ctxt);
        if name.is_null() {
            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                           b"Name expected in NOTATION declaration\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
            xmlFreeEnumeration(ret);
            return 0 as xmlEnumerationPtr
        }
        tmp = ret;
        while !tmp.is_null() {
            if xmlStrEqual(name, (*tmp).name) != 0 {
                xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
                                 b"standalone: attribute notation value token %s duplicated\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 name, 0 as *const xmlChar);
                if xmlDictOwns((*ctxt).dict, name) == 0 {
                    xmlFree.expect("non-null function pointer")(name as
                                                                    *mut xmlChar
                                                                    as
                                                                    *mut std::os::raw::c_void);
                }
                break ;
            } else { tmp = (*tmp).next }
        }
        if tmp.is_null() {
            cur = xmlCreateEnumeration(name);
            if cur.is_null() {
                xmlFreeEnumeration(ret);
                return 0 as xmlEnumerationPtr
            }
            if last.is_null() {
                last = cur;
                ret = last
            } else { (*last).next = cur; last = cur }
        }
        xmlSkipBlankChars(ctxt);
        if !(*(*(*ctxt).input).cur as std::os::raw::c_int == '|' as i32) { break ; }
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != ')' as i32 {
        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        xmlFreeEnumeration(ret);
        return 0 as xmlEnumerationPtr
    }
    xmlNextChar(ctxt);
    return ret;
}
/* *
 * xmlParseEnumerationType:
 * @ctxt:  an XML parser context
 *
 * parse an Enumeration attribute type.
 *
 * [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'
 *
 * [ VC: Enumeration ]
 * Values of this type must match one of the Nmtoken tokens in
 * the declaration
 *
 * Returns: the enumeration attribute tree built while parsing
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseEnumerationType(mut ctxt: xmlParserCtxtPtr)
 -> xmlEnumerationPtr {
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut ret: xmlEnumerationPtr = 0 as xmlEnumerationPtr;
    let mut last: xmlEnumerationPtr = 0 as xmlEnumerationPtr;
    let mut cur: xmlEnumerationPtr = 0 as *mut xmlEnumeration;
    let mut tmp: xmlEnumerationPtr = 0 as *mut xmlEnumeration;
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '(' as i32 {
        xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED,
                    0 as *const std::os::raw::c_char);
        return 0 as xmlEnumerationPtr
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    loop  {
        xmlNextChar(ctxt);
        xmlSkipBlankChars(ctxt);
        name = xmlParseNmtoken(ctxt);
        if name.is_null() {
            xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED,
                        0 as *const std::os::raw::c_char);
            return ret
        }
        tmp = ret;
        while !tmp.is_null() {
            if xmlStrEqual(name, (*tmp).name) != 0 {
                xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
                                 b"standalone: attribute enumeration value token %s duplicated\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 name, 0 as *const xmlChar);
                if xmlDictOwns((*ctxt).dict, name) == 0 {
                    xmlFree.expect("non-null function pointer")(name as
                                                                    *mut std::os::raw::c_void);
                }
                break ;
            } else { tmp = (*tmp).next }
        }
        if tmp.is_null() {
            cur = xmlCreateEnumeration(name);
            if xmlDictOwns((*ctxt).dict, name) == 0 {
                xmlFree.expect("non-null function pointer")(name as
                                                                *mut std::os::raw::c_void);
            }
            if cur.is_null() {
                xmlFreeEnumeration(ret);
                return 0 as xmlEnumerationPtr
            }
            if last.is_null() {
                last = cur;
                ret = last
            } else { (*last).next = cur; last = cur }
        }
        xmlSkipBlankChars(ctxt);
        if !(*(*(*ctxt).input).cur as std::os::raw::c_int == '|' as i32) { break ; }
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != ')' as i32 {
        xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        return ret
    }
    xmlNextChar(ctxt);
    return ret;
}
/* *
 * xmlParseEnumeratedType:
 * @ctxt:  an XML parser context
 * @tree:  the enumeration tree built while parsing
 *
 * parse an Enumerated attribute type.
 *
 * [57] EnumeratedType ::= NotationType | Enumeration
 *
 * [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'
 *
 *
 * Returns: XML_ATTRIBUTE_ENUMERATION or XML_ATTRIBUTE_NOTATION
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseEnumeratedType(mut ctxt: xmlParserCtxtPtr,
                                                mut tree:
                                                    *mut xmlEnumerationPtr)
 -> std::os::raw::c_int {
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == 'N' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'O' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'I' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'O' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'N' as i32 {
        (*ctxt).nbChars += 8 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(8 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 8 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after \'NOTATION\'\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
            return 0 as std::os::raw::c_int
        }
        *tree = xmlParseNotationType(ctxt);
        if (*tree).is_null() { return 0 as std::os::raw::c_int }
        return XML_ATTRIBUTE_NOTATION as std::os::raw::c_int
    }
    *tree = xmlParseEnumerationType(ctxt);
    if (*tree).is_null() { return 0 as std::os::raw::c_int }
    return XML_ATTRIBUTE_ENUMERATION as std::os::raw::c_int;
}
/* *
 * xmlParseAttributeType:
 * @ctxt:  an XML parser context
 * @tree:  the enumeration tree built while parsing
 *
 * parse the Attribute list def for an element
 *
 * [54] AttType ::= StringType | TokenizedType | EnumeratedType
 *
 * [55] StringType ::= 'CDATA'
 *
 * [56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' |
 *                        'ENTITIES' | 'NMTOKEN' | 'NMTOKENS'
 *
 * Validity constraints for attribute values syntax are checked in
 * xmlValidateAttributeValue()
 *
 * [ VC: ID ]
 * Values of type ID must match the Name production. A name must not
 * appear more than once in an XML document as a value of this type;
 * i.e., ID values must uniquely identify the elements which bear them.
 *
 * [ VC: One ID per Element Type ]
 * No element type may have more than one ID attribute specified.
 *
 * [ VC: ID Attribute Default ]
 * An ID attribute must have a declared default of #IMPLIED or #REQUIRED.
 *
 * [ VC: IDREF ]
 * Values of type IDREF must match the Name production, and values
 * of type IDREFS must match Names; each IDREF Name must match the value
 * of an ID attribute on some element in the XML document; i.e. IDREF
 * values must match the value of some ID attribute.
 *
 * [ VC: Entity Name ]
 * Values of type ENTITY must match the Name production, values
 * of type ENTITIES must match Names; each Entity Name must match the
 * name of an unparsed entity declared in the DTD.
 *
 * [ VC: Name Token ]
 * Values of type NMTOKEN must match the Nmtoken production; values
 * of type NMTOKENS must match Nmtokens.
 *
 * Returns the attribute type
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseAttributeType(mut ctxt: xmlParserCtxtPtr,
                                               mut tree:
                                                   *mut xmlEnumerationPtr)
 -> std::os::raw::c_int {
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == 'C' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'D' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 {
        (*ctxt).nbChars += 5 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 5 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        return XML_ATTRIBUTE_CDATA as std::os::raw::c_int
    } else {
        if *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'I' as i32 &&
               *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'D' as i32 &&
               *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'R' as i32 &&
               *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'E' as i32 &&
               *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'F' as i32 &&
               *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'S' as i32 {
            (*ctxt).nbChars += 6 as std::os::raw::c_int as std::os::raw::c_long;
            (*(*ctxt).input).cur =
                (*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as isize);
            (*(*ctxt).input).col += 6 as std::os::raw::c_int;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
            return XML_ATTRIBUTE_IDREFS as std::os::raw::c_int
        } else {
            if *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'I' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'D' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'R' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'E' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'F' as i32 {
                (*ctxt).nbChars += 5 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 5 as std::os::raw::c_int;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
                return XML_ATTRIBUTE_IDREF as std::os::raw::c_int
            } else {
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 'I' as i32 &&
                       *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int == 'D' as i32 {
                    (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
                    (*(*ctxt).input).cur =
                        (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                        isize);
                    (*(*ctxt).input).col += 2 as std::os::raw::c_int;
                    if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                    }
                    return XML_ATTRIBUTE_ID as std::os::raw::c_int
                } else {
                    if *((*(*ctxt).input).cur as
                             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as
                                                            isize) as
                           std::os::raw::c_int == 'E' as i32 &&
                           *((*(*ctxt).input).cur as
                                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int
                                                                as isize) as
                               std::os::raw::c_int == 'N' as i32 &&
                           *((*(*ctxt).input).cur as
                                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int
                                                                as isize) as
                               std::os::raw::c_int == 'T' as i32 &&
                           *((*(*ctxt).input).cur as
                                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int
                                                                as isize) as
                               std::os::raw::c_int == 'I' as i32 &&
                           *((*(*ctxt).input).cur as
                                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int
                                                                as isize) as
                               std::os::raw::c_int == 'T' as i32 &&
                           *((*(*ctxt).input).cur as
                                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int
                                                                as isize) as
                               std::os::raw::c_int == 'Y' as i32 {
                        (*ctxt).nbChars += 6 as std::os::raw::c_int as std::os::raw::c_long;
                        (*(*ctxt).input).cur =
                            (*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as
                                                            isize);
                        (*(*ctxt).input).col += 6 as std::os::raw::c_int;
                        if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                            xmlParserInputGrow((*ctxt).input,
                                               250 as std::os::raw::c_int);
                        }
                        return XML_ATTRIBUTE_ENTITY as std::os::raw::c_int
                    } else {
                        if *((*(*ctxt).input).cur as
                                 *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int
                                                                as isize) as
                               std::os::raw::c_int == 'E' as i32 &&
                               *((*(*ctxt).input).cur as
                                     *mut std::os::raw::c_uchar).offset(1 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as std::os::raw::c_int == 'N' as i32 &&
                               *((*(*ctxt).input).cur as
                                     *mut std::os::raw::c_uchar).offset(2 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as std::os::raw::c_int == 'T' as i32 &&
                               *((*(*ctxt).input).cur as
                                     *mut std::os::raw::c_uchar).offset(3 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as std::os::raw::c_int == 'I' as i32 &&
                               *((*(*ctxt).input).cur as
                                     *mut std::os::raw::c_uchar).offset(4 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as std::os::raw::c_int == 'T' as i32 &&
                               *((*(*ctxt).input).cur as
                                     *mut std::os::raw::c_uchar).offset(5 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as std::os::raw::c_int == 'I' as i32 &&
                               *((*(*ctxt).input).cur as
                                     *mut std::os::raw::c_uchar).offset(6 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as std::os::raw::c_int == 'E' as i32 &&
                               *((*(*ctxt).input).cur as
                                     *mut std::os::raw::c_uchar).offset(7 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as std::os::raw::c_int == 'S' as i32 {
                            (*ctxt).nbChars +=
                                8 as std::os::raw::c_int as std::os::raw::c_long;
                            (*(*ctxt).input).cur =
                                (*(*ctxt).input).cur.offset(8 as std::os::raw::c_int
                                                                as isize);
                            (*(*ctxt).input).col += 8 as std::os::raw::c_int;
                            if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                   0 as std::os::raw::c_int {
                                xmlParserInputGrow((*ctxt).input,
                                                   250 as std::os::raw::c_int);
                            }
                            return XML_ATTRIBUTE_ENTITIES as std::os::raw::c_int
                        } else {
                            if *((*(*ctxt).input).cur as
                                     *mut std::os::raw::c_uchar).offset(0 as
                                                                    std::os::raw::c_int
                                                                    as isize)
                                   as std::os::raw::c_int == 'N' as i32 &&
                                   *((*(*ctxt).input).cur as
                                         *mut std::os::raw::c_uchar).offset(1 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        isize)
                                       as std::os::raw::c_int == 'M' as i32 &&
                                   *((*(*ctxt).input).cur as
                                         *mut std::os::raw::c_uchar).offset(2 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        isize)
                                       as std::os::raw::c_int == 'T' as i32 &&
                                   *((*(*ctxt).input).cur as
                                         *mut std::os::raw::c_uchar).offset(3 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        isize)
                                       as std::os::raw::c_int == 'O' as i32 &&
                                   *((*(*ctxt).input).cur as
                                         *mut std::os::raw::c_uchar).offset(4 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        isize)
                                       as std::os::raw::c_int == 'K' as i32 &&
                                   *((*(*ctxt).input).cur as
                                         *mut std::os::raw::c_uchar).offset(5 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        isize)
                                       as std::os::raw::c_int == 'E' as i32 &&
                                   *((*(*ctxt).input).cur as
                                         *mut std::os::raw::c_uchar).offset(6 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        isize)
                                       as std::os::raw::c_int == 'N' as i32 &&
                                   *((*(*ctxt).input).cur as
                                         *mut std::os::raw::c_uchar).offset(7 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        isize)
                                       as std::os::raw::c_int == 'S' as i32 {
                                (*ctxt).nbChars +=
                                    8 as std::os::raw::c_int as std::os::raw::c_long;
                                (*(*ctxt).input).cur =
                                    (*(*ctxt).input).cur.offset(8 as
                                                                    std::os::raw::c_int
                                                                    as isize);
                                (*(*ctxt).input).col += 8 as std::os::raw::c_int;
                                if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                       0 as std::os::raw::c_int {
                                    xmlParserInputGrow((*ctxt).input,
                                                       250 as std::os::raw::c_int);
                                }
                                return XML_ATTRIBUTE_NMTOKENS as std::os::raw::c_int
                            } else {
                                if *((*(*ctxt).input).cur as
                                         *mut std::os::raw::c_uchar).offset(0 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        isize)
                                       as std::os::raw::c_int == 'N' as i32 &&
                                       *((*(*ctxt).input).cur as
                                             *mut std::os::raw::c_uchar).offset(1 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                           as std::os::raw::c_int == 'M' as i32 &&
                                       *((*(*ctxt).input).cur as
                                             *mut std::os::raw::c_uchar).offset(2 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                           as std::os::raw::c_int == 'T' as i32 &&
                                       *((*(*ctxt).input).cur as
                                             *mut std::os::raw::c_uchar).offset(3 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                           as std::os::raw::c_int == 'O' as i32 &&
                                       *((*(*ctxt).input).cur as
                                             *mut std::os::raw::c_uchar).offset(4 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                           as std::os::raw::c_int == 'K' as i32 &&
                                       *((*(*ctxt).input).cur as
                                             *mut std::os::raw::c_uchar).offset(5 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                           as std::os::raw::c_int == 'E' as i32 &&
                                       *((*(*ctxt).input).cur as
                                             *mut std::os::raw::c_uchar).offset(6 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                           as std::os::raw::c_int == 'N' as i32 {
                                    (*ctxt).nbChars +=
                                        7 as std::os::raw::c_int as std::os::raw::c_long;
                                    (*(*ctxt).input).cur =
                                        (*(*ctxt).input).cur.offset(7 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        isize);
                                    (*(*ctxt).input).col += 7 as std::os::raw::c_int;
                                    if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                           0 as std::os::raw::c_int {
                                        xmlParserInputGrow((*ctxt).input,
                                                           250 as
                                                               std::os::raw::c_int);
                                    }
                                    return XML_ATTRIBUTE_NMTOKEN as
                                               std::os::raw::c_int
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return xmlParseEnumeratedType(ctxt, tree);
}
/* *
 * xmlParseAttributeListDecl:
 * @ctxt:  an XML parser context
 *
 * : parse the Attribute list def for an element
 *
 * [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'
 *
 * [53] AttDef ::= S Name S AttType S DefaultDecl
 *
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseAttributeListDecl(mut ctxt:
                                                       xmlParserCtxtPtr) {
    let mut elemName: *const xmlChar = 0 as *const xmlChar;
    let mut attrName: *const xmlChar = 0 as *const xmlChar;
    let mut tree: xmlEnumerationPtr = 0 as *mut xmlEnumeration;
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '!' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'L' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'I' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'S' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(8 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 {
        let mut inputid: std::os::raw::c_int = (*(*ctxt).input).id;
        (*ctxt).nbChars += 9 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(9 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 9 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after \'<!ATTLIST\'\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
        }
        elemName = xmlParseName(ctxt);
        if elemName.is_null() {
            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                           b"ATTLIST: no name for Element\n\x00" as *const u8
                               as *const std::os::raw::c_char);
            return
        }
        xmlSkipBlankChars(ctxt);
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        while *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 &&
                  (*ctxt).instate as std::os::raw::c_int !=
                      XML_PARSER_EOF as std::os::raw::c_int {
            let mut type_0: std::os::raw::c_int = 0;
            let mut def: std::os::raw::c_int = 0;
            let mut defaultValue: *mut xmlChar = 0 as *mut xmlChar;
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            tree = 0 as xmlEnumerationPtr;
            attrName = xmlParseName(ctxt);
            if attrName.is_null() {
                xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                               b"ATTLIST: no name for Attribute\n\x00" as
                                   *const u8 as *const std::os::raw::c_char);
                break ;
            } else {
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
                    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                                   b"Space required after the attribute name\n\x00"
                                       as *const u8 as *const std::os::raw::c_char);
                    break ;
                } else {
                    type_0 = xmlParseAttributeType(ctxt, &mut tree);
                    if type_0 <= 0 as std::os::raw::c_int { break ; }
                    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                as std::os::raw::c_long) <
                               250 as std::os::raw::c_int as std::os::raw::c_long {
                        xmlGROW(ctxt);
                    }
                    if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
                        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                                       b"Space required after the attribute type\n\x00"
                                           as *const u8 as
                                           *const std::os::raw::c_char);
                        if !tree.is_null() { xmlFreeEnumeration(tree); }
                        break ;
                    } else {
                        def = xmlParseDefaultDecl(ctxt, &mut defaultValue);
                        if def <= 0 as std::os::raw::c_int {
                            if !defaultValue.is_null() {
                                xmlFree.expect("non-null function pointer")(defaultValue
                                                                                as
                                                                                *mut std::os::raw::c_void);
                            }
                            if !tree.is_null() { xmlFreeEnumeration(tree); }
                            break ;
                        } else {
                            if type_0 != XML_ATTRIBUTE_CDATA as std::os::raw::c_int &&
                                   !defaultValue.is_null() {
                                xmlAttrNormalizeSpace(defaultValue,
                                                      defaultValue);
                            }
                            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                        as std::os::raw::c_long) <
                                       250 as std::os::raw::c_int as std::os::raw::c_long {
                                xmlGROW(ctxt);
                            }
                            if *(*(*ctxt).input).cur as std::os::raw::c_int !=
                                   '>' as i32 {
                                if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int
                                   {
                                    xmlFatalErrMsg(ctxt,
                                                   XML_ERR_SPACE_REQUIRED,
                                                   b"Space required after the attribute default value\n\x00"
                                                       as *const u8 as
                                                       *const std::os::raw::c_char);
                                    if !defaultValue.is_null() {
                                        xmlFree.expect("non-null function pointer")(defaultValue
                                                                                        as
                                                                                        *mut std::os::raw::c_void);
                                    }
                                    if !tree.is_null() {
                                        xmlFreeEnumeration(tree);
                                    }
                                    break ;
                                }
                            }
                            if !(*ctxt).sax.is_null() &&
                                   (*ctxt).disableSAX == 0 &&
                                   (*(*ctxt).sax).attributeDecl.is_some() {
                                (*(*ctxt).sax).attributeDecl.expect("non-null function pointer")((*ctxt).userData,
                                                                                                 elemName,
                                                                                                 attrName,
                                                                                                 type_0,
                                                                                                 def,
                                                                                                 defaultValue,
                                                                                                 tree);
                            } else if !tree.is_null() {
                                xmlFreeEnumeration(tree);
                            }
                            if (*ctxt).sax2 != 0 && !defaultValue.is_null() &&
                                   def != XML_ATTRIBUTE_IMPLIED as std::os::raw::c_int
                                   &&
                                   def !=
                                       XML_ATTRIBUTE_REQUIRED as std::os::raw::c_int {
                                xmlAddDefAttrs(ctxt, elemName, attrName,
                                               defaultValue);
                            }
                            if (*ctxt).sax2 != 0 {
                                xmlAddSpecialAttr(ctxt, elemName, attrName,
                                                  type_0);
                            }
                            if !defaultValue.is_null() {
                                xmlFree.expect("non-null function pointer")(defaultValue
                                                                                as
                                                                                *mut std::os::raw::c_void);
                            }
                            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                                        as std::os::raw::c_long) <
                                       250 as std::os::raw::c_int as std::os::raw::c_long {
                                xmlGROW(ctxt);
                            }
                        }
                    }
                }
            }
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
            if inputid != (*(*ctxt).input).id {
                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                               b"Attribute list declaration doesn\'t start and stop in the same entity\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
            xmlNextChar(ctxt);
        }
    };
}
/* *
 * xmlParseElementMixedContentDecl:
 * @ctxt:  an XML parser context
 * @inputchk:  the input used for the current entity, needed for boundary checks
 *
 * parse the declaration for a Mixed Element content
 * The leading '(' and spaces have been skipped in xmlParseElementContentDecl
 *
 * [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' |
 *                '(' S? '#PCDATA' S? ')'
 *
 * [ VC: Proper Group/PE Nesting ] applies to [51] too (see [49])
 *
 * [ VC: No Duplicate Types ]
 * The same name must not appear more than once in a single
 * mixed-content declaration.
 *
 * returns: the list of the xmlElementContentPtr describing the element choices
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseElementMixedContentDecl(mut ctxt:
                                                             xmlParserCtxtPtr,
                                                         mut inputchk:
                                                             std::os::raw::c_int)
 -> xmlElementContentPtr {
    let mut ret: xmlElementContentPtr = 0 as xmlElementContentPtr;
    let mut cur: xmlElementContentPtr = 0 as xmlElementContentPtr;
    let mut n: xmlElementContentPtr = 0 as *mut xmlElementContent;
    let mut elem: *const xmlChar = 0 as *const xmlChar;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '#' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'P' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'C' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'D' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 {
        (*ctxt).nbChars += 7 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(7 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 7 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        xmlSkipBlankChars(ctxt);
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                   as std::os::raw::c_long >
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) <
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
            xmlSHRINK(ctxt);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ')' as i32 {
            if (*(*ctxt).input).id != inputchk {
                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                               b"Element content declaration doesn\'t start and stop in the same entity\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
            xmlNextChar(ctxt);
            ret =
                xmlNewDocElementContent((*ctxt).myDoc, 0 as *const xmlChar,
                                        XML_ELEMENT_CONTENT_PCDATA);
            if ret.is_null() { return 0 as xmlElementContentPtr }
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '*' as i32 {
                (*ret).ocur = XML_ELEMENT_CONTENT_MULT;
                xmlNextChar(ctxt);
            }
            return ret
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '(' as i32 ||
               *(*(*ctxt).input).cur as std::os::raw::c_int == '|' as i32 {
            cur =
                xmlNewDocElementContent((*ctxt).myDoc, 0 as *const xmlChar,
                                        XML_ELEMENT_CONTENT_PCDATA);
            ret = cur;
            if ret.is_null() { return 0 as xmlElementContentPtr }
        }
        while *(*(*ctxt).input).cur as std::os::raw::c_int == '|' as i32 &&
                  (*ctxt).instate as std::os::raw::c_int !=
                      XML_PARSER_EOF as std::os::raw::c_int {
            xmlNextChar(ctxt);
            if elem.is_null() {
                ret =
                    xmlNewDocElementContent((*ctxt).myDoc,
                                            0 as *const xmlChar,
                                            XML_ELEMENT_CONTENT_OR);
                if ret.is_null() { return 0 as xmlElementContentPtr }
                (*ret).c1 = cur;
                if !cur.is_null() { (*cur).parent = ret }
                cur = ret
            } else {
                n =
                    xmlNewDocElementContent((*ctxt).myDoc,
                                            0 as *const xmlChar,
                                            XML_ELEMENT_CONTENT_OR);
                if n.is_null() { return 0 as xmlElementContentPtr }
                (*n).c1 =
                    xmlNewDocElementContent((*ctxt).myDoc, elem,
                                            XML_ELEMENT_CONTENT_ELEMENT);
                if !(*n).c1.is_null() { (*(*n).c1).parent = n }
                (*cur).c2 = n;
                if !n.is_null() { (*n).parent = cur }
                cur = n
            }
            xmlSkipBlankChars(ctxt);
            elem = xmlParseName(ctxt);
            if elem.is_null() {
                xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                               b"xmlParseElementMixedContentDecl : Name expected\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
                xmlFreeDocElementContent((*ctxt).myDoc, ret);
                return 0 as xmlElementContentPtr
            }
            xmlSkipBlankChars(ctxt);
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ')' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '*' as i32 {
            if !elem.is_null() {
                (*cur).c2 =
                    xmlNewDocElementContent((*ctxt).myDoc, elem,
                                            XML_ELEMENT_CONTENT_ELEMENT);
                if !(*cur).c2.is_null() { (*(*cur).c2).parent = cur }
            }
            if !ret.is_null() { (*ret).ocur = XML_ELEMENT_CONTENT_MULT }
            if (*(*ctxt).input).id != inputchk {
                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                               b"Element content declaration doesn\'t start and stop in the same entity\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
            (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
            (*(*ctxt).input).cur =
                (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
            (*(*ctxt).input).col += 2 as std::os::raw::c_int;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
        } else {
            xmlFreeDocElementContent((*ctxt).myDoc, ret);
            xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED,
                        0 as *const std::os::raw::c_char);
            return 0 as xmlElementContentPtr
        }
    } else {
        xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, 0 as *const std::os::raw::c_char);
    }
    return ret;
}
/* *
 * xmlParseElementChildrenContentDeclPriv:
 * @ctxt:  an XML parser context
 * @inputchk:  the input used for the current entity, needed for boundary checks
 * @depth: the level of recursion
 *
 * parse the declaration for a Mixed Element content
 * The leading '(' and spaces have been skipped in xmlParseElementContentDecl
 *
 *
 * [47] children ::= (choice | seq) ('?' | '*' | '+')?
 *
 * [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?
 *
 * [49] choice ::= '(' S? cp ( S? '|' S? cp )* S? ')'
 *
 * [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'
 *
 * [ VC: Proper Group/PE Nesting ] applies to [49] and [50]
 * TODO Parameter-entity replacement text must be properly nested
 *	with parenthesized groups. That is to say, if either of the
 *	opening or closing parentheses in a choice, seq, or Mixed
 *	construct is contained in the replacement text for a parameter
 *	entity, both must be contained in the same replacement text. For
 *	interoperability, if a parameter-entity reference appears in a
 *	choice, seq, or Mixed construct, its replacement text should not
 *	be empty, and neither the first nor last non-blank character of
 *	the replacement text should be a connector (| or ,).
 *
 * Returns the tree of xmlElementContentPtr describing the element
 *          hierarchy.
 */
unsafe extern "C" fn xmlParseElementChildrenContentDeclPriv(mut ctxt:
                                                                xmlParserCtxtPtr,
                                                            mut inputchk:
                                                                std::os::raw::c_int,
                                                            mut depth:
                                                                std::os::raw::c_int)
 -> xmlElementContentPtr {
    let mut ret: xmlElementContentPtr = 0 as xmlElementContentPtr;
    let mut cur: xmlElementContentPtr = 0 as xmlElementContentPtr;
    let mut last: xmlElementContentPtr = 0 as xmlElementContentPtr;
    let mut op: xmlElementContentPtr = 0 as xmlElementContentPtr;
    let mut elem: *const xmlChar = 0 as *const xmlChar;
    let mut type_0: xmlChar = 0 as std::os::raw::c_int as xmlChar;
    if depth > 128 as std::os::raw::c_int &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
           || depth > 2048 as std::os::raw::c_int {
        xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
                          b"xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n\x00"
                              as *const u8 as *const std::os::raw::c_char, depth);
        return 0 as xmlElementContentPtr
    }
    xmlSkipBlankChars(ctxt);
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '(' as i32 {
        let mut inputid: std::os::raw::c_int = (*(*ctxt).input).id;
        /* Recurse on first child */
        xmlNextChar(ctxt);
        xmlSkipBlankChars(ctxt);
        ret =
            xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
                                                   depth + 1 as std::os::raw::c_int);
        cur = ret;
        xmlSkipBlankChars(ctxt);
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
    } else {
        elem = xmlParseName(ctxt);
        if elem.is_null() {
            xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
                        0 as *const std::os::raw::c_char);
            return 0 as xmlElementContentPtr
        }
        ret =
            xmlNewDocElementContent((*ctxt).myDoc, elem,
                                    XML_ELEMENT_CONTENT_ELEMENT);
        cur = ret;
        if cur.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return 0 as xmlElementContentPtr
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '?' as i32 {
            (*cur).ocur = XML_ELEMENT_CONTENT_OPT;
            xmlNextChar(ctxt);
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '*' as i32 {
            (*cur).ocur = XML_ELEMENT_CONTENT_MULT;
            xmlNextChar(ctxt);
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '+' as i32 {
            (*cur).ocur = XML_ELEMENT_CONTENT_PLUS;
            xmlNextChar(ctxt);
        } else { (*cur).ocur = XML_ELEMENT_CONTENT_ONCE }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
    }
    xmlSkipBlankChars(ctxt);
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    while *(*(*ctxt).input).cur as std::os::raw::c_int != ')' as i32 &&
              (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int
          {
        /*
	 * Each loop we parse one separator and one element.
	 */
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ',' as i32 {
            if type_0 as std::os::raw::c_int == 0 as std::os::raw::c_int {
                type_0 = *(*(*ctxt).input).cur
            } else if type_0 as std::os::raw::c_int !=
                          *(*(*ctxt).input).cur as std::os::raw::c_int {
                xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
                                  b"xmlParseElementChildrenContentDecl : \'%c\' expected\n\x00"
                                      as *const u8 as *const std::os::raw::c_char,
                                  type_0 as std::os::raw::c_int);
                if !last.is_null() && last != ret {
                    xmlFreeDocElementContent((*ctxt).myDoc, last);
                }
                if !ret.is_null() {
                    xmlFreeDocElementContent((*ctxt).myDoc, ret);
                }
                return 0 as xmlElementContentPtr
            }
            xmlNextChar(ctxt);
            op =
                xmlNewDocElementContent((*ctxt).myDoc, 0 as *const xmlChar,
                                        XML_ELEMENT_CONTENT_SEQ);
            if op.is_null() {
                if !last.is_null() && last != ret {
                    xmlFreeDocElementContent((*ctxt).myDoc, last);
                }
                xmlFreeDocElementContent((*ctxt).myDoc, ret);
                return 0 as xmlElementContentPtr
            }
            if last.is_null() {
                (*op).c1 = ret;
                if !ret.is_null() { (*ret).parent = op }
                cur = op;
                ret = cur
            } else {
                (*cur).c2 = op;
                if !op.is_null() { (*op).parent = cur }
                (*op).c1 = last;
                if !last.is_null() { (*last).parent = op }
                cur = op;
                last = 0 as xmlElementContentPtr
            }
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '|' as i32 {
            if type_0 as std::os::raw::c_int == 0 as std::os::raw::c_int {
                type_0 = *(*(*ctxt).input).cur
            } else if type_0 as std::os::raw::c_int !=
                          *(*(*ctxt).input).cur as std::os::raw::c_int {
                xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
                                  b"xmlParseElementChildrenContentDecl : \'%c\' expected\n\x00"
                                      as *const u8 as *const std::os::raw::c_char,
                                  type_0 as std::os::raw::c_int);
                if !last.is_null() && last != ret {
                    xmlFreeDocElementContent((*ctxt).myDoc, last);
                }
                if !ret.is_null() {
                    xmlFreeDocElementContent((*ctxt).myDoc, ret);
                }
                return 0 as xmlElementContentPtr
            }
            xmlNextChar(ctxt);
            op =
                xmlNewDocElementContent((*ctxt).myDoc, 0 as *const xmlChar,
                                        XML_ELEMENT_CONTENT_OR);
            if op.is_null() {
                if !last.is_null() && last != ret {
                    xmlFreeDocElementContent((*ctxt).myDoc, last);
                }
                if !ret.is_null() {
                    xmlFreeDocElementContent((*ctxt).myDoc, ret);
                }
                return 0 as xmlElementContentPtr
            }
            if last.is_null() {
                (*op).c1 = ret;
                if !ret.is_null() { (*ret).parent = op }
                cur = op;
                ret = cur
            } else {
                (*cur).c2 = op;
                if !op.is_null() { (*op).parent = cur }
                (*op).c1 = last;
                if !last.is_null() { (*last).parent = op }
                cur = op;
                last = 0 as xmlElementContentPtr
            }
        } else {
            xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
                        0 as *const std::os::raw::c_char);
            if !last.is_null() && last != ret {
                xmlFreeDocElementContent((*ctxt).myDoc, last);
            }
            if !ret.is_null() {
                xmlFreeDocElementContent((*ctxt).myDoc, ret);
            }
            return 0 as xmlElementContentPtr
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        xmlSkipBlankChars(ctxt);
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '(' as i32 {
            let mut inputid_0: std::os::raw::c_int = (*(*ctxt).input).id;
            /*
	     * Detect "Name | Name , Name" error
	     */
            /*
	     * Detect "Name , Name | Name" error
	     */
            /* Recurse on second child */
            xmlNextChar(ctxt);
            xmlSkipBlankChars(ctxt);
            last =
                xmlParseElementChildrenContentDeclPriv(ctxt, inputid_0,
                                                       depth +
                                                           1 as std::os::raw::c_int);
            xmlSkipBlankChars(ctxt);
        } else {
            elem = xmlParseName(ctxt);
            if elem.is_null() {
                xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
                            0 as *const std::os::raw::c_char);
                if !ret.is_null() {
                    xmlFreeDocElementContent((*ctxt).myDoc, ret);
                }
                return 0 as xmlElementContentPtr
            }
            last =
                xmlNewDocElementContent((*ctxt).myDoc, elem,
                                        XML_ELEMENT_CONTENT_ELEMENT);
            if last.is_null() {
                if !ret.is_null() {
                    xmlFreeDocElementContent((*ctxt).myDoc, ret);
                }
                return 0 as xmlElementContentPtr
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '?' as i32 {
                (*last).ocur = XML_ELEMENT_CONTENT_OPT;
                xmlNextChar(ctxt);
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '*' as i32 {
                (*last).ocur = XML_ELEMENT_CONTENT_MULT;
                xmlNextChar(ctxt);
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '+' as i32 {
                (*last).ocur = XML_ELEMENT_CONTENT_PLUS;
                xmlNextChar(ctxt);
            } else { (*last).ocur = XML_ELEMENT_CONTENT_ONCE }
        }
        xmlSkipBlankChars(ctxt);
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
    }
    if !cur.is_null() && !last.is_null() {
        (*cur).c2 = last;
        if !last.is_null() { (*last).parent = cur }
    }
    if (*(*ctxt).input).id != inputchk {
        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                       b"Element content declaration doesn\'t start and stop in the same entity\n\x00"
                           as *const u8 as *const std::os::raw::c_char);
    }
    xmlNextChar(ctxt);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '?' as i32 {
        if !ret.is_null() {
            if (*ret).ocur as std::os::raw::c_uint ==
                   XML_ELEMENT_CONTENT_PLUS as std::os::raw::c_int as std::os::raw::c_uint ||
                   (*ret).ocur as std::os::raw::c_uint ==
                       XML_ELEMENT_CONTENT_MULT as std::os::raw::c_int as std::os::raw::c_uint
               {
                (*ret).ocur = XML_ELEMENT_CONTENT_MULT
            } else { (*ret).ocur = XML_ELEMENT_CONTENT_OPT }
        }
        xmlNextChar(ctxt);
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '*' as i32 {
        if !ret.is_null() {
            (*ret).ocur = XML_ELEMENT_CONTENT_MULT;
            cur = ret;
            /*
	     * Some normalization:
	     * (a | b* | c?)* == (a | b | c)*
	     */
            while !cur.is_null() &&
                      (*cur).type_0 as std::os::raw::c_uint ==
                          XML_ELEMENT_CONTENT_OR as std::os::raw::c_int as
                              std::os::raw::c_uint {
                if !(*cur).c1.is_null() &&
                       ((*(*cur).c1).ocur as std::os::raw::c_uint ==
                            XML_ELEMENT_CONTENT_OPT as std::os::raw::c_int as
                                std::os::raw::c_uint ||
                            (*(*cur).c1).ocur as std::os::raw::c_uint ==
                                XML_ELEMENT_CONTENT_MULT as std::os::raw::c_int as
                                    std::os::raw::c_uint) {
                    (*(*cur).c1).ocur = XML_ELEMENT_CONTENT_ONCE
                }
                if !(*cur).c2.is_null() &&
                       ((*(*cur).c2).ocur as std::os::raw::c_uint ==
                            XML_ELEMENT_CONTENT_OPT as std::os::raw::c_int as
                                std::os::raw::c_uint ||
                            (*(*cur).c2).ocur as std::os::raw::c_uint ==
                                XML_ELEMENT_CONTENT_MULT as std::os::raw::c_int as
                                    std::os::raw::c_uint) {
                    (*(*cur).c2).ocur = XML_ELEMENT_CONTENT_ONCE
                }
                cur = (*cur).c2
            }
        }
        xmlNextChar(ctxt);
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '+' as i32 {
        if !ret.is_null() {
            let mut found: std::os::raw::c_int = 0 as std::os::raw::c_int;
            if (*ret).ocur as std::os::raw::c_uint ==
                   XML_ELEMENT_CONTENT_OPT as std::os::raw::c_int as std::os::raw::c_uint ||
                   (*ret).ocur as std::os::raw::c_uint ==
                       XML_ELEMENT_CONTENT_MULT as std::os::raw::c_int as std::os::raw::c_uint
               {
                (*ret).ocur = XML_ELEMENT_CONTENT_MULT
            } else { (*ret).ocur = XML_ELEMENT_CONTENT_PLUS }
            /*
	     * Some normalization:
	     * (a | b*)+ == (a | b)*
	     * (a | b?)+ == (a | b)*
	     */
            while !cur.is_null() &&
                      (*cur).type_0 as std::os::raw::c_uint ==
                          XML_ELEMENT_CONTENT_OR as std::os::raw::c_int as
                              std::os::raw::c_uint {
                if !(*cur).c1.is_null() &&
                       ((*(*cur).c1).ocur as std::os::raw::c_uint ==
                            XML_ELEMENT_CONTENT_OPT as std::os::raw::c_int as
                                std::os::raw::c_uint ||
                            (*(*cur).c1).ocur as std::os::raw::c_uint ==
                                XML_ELEMENT_CONTENT_MULT as std::os::raw::c_int as
                                    std::os::raw::c_uint) {
                    (*(*cur).c1).ocur = XML_ELEMENT_CONTENT_ONCE;
                    found = 1 as std::os::raw::c_int
                }
                if !(*cur).c2.is_null() &&
                       ((*(*cur).c2).ocur as std::os::raw::c_uint ==
                            XML_ELEMENT_CONTENT_OPT as std::os::raw::c_int as
                                std::os::raw::c_uint ||
                            (*(*cur).c2).ocur as std::os::raw::c_uint ==
                                XML_ELEMENT_CONTENT_MULT as std::os::raw::c_int as
                                    std::os::raw::c_uint) {
                    (*(*cur).c2).ocur = XML_ELEMENT_CONTENT_ONCE;
                    found = 1 as std::os::raw::c_int
                }
                cur = (*cur).c2
            }
            if found != 0 { (*ret).ocur = XML_ELEMENT_CONTENT_MULT }
        }
        xmlNextChar(ctxt);
    }
    return ret;
}
/* *
 * xmlParseElementChildrenContentDecl:
 * @ctxt:  an XML parser context
 * @inputchk:  the input used for the current entity, needed for boundary checks
 *
 * parse the declaration for a Mixed Element content
 * The leading '(' and spaces have been skipped in xmlParseElementContentDecl
 *
 * [47] children ::= (choice | seq) ('?' | '*' | '+')?
 *
 * [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?
 *
 * [49] choice ::= '(' S? cp ( S? '|' S? cp )* S? ')'
 *
 * [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'
 *
 * [ VC: Proper Group/PE Nesting ] applies to [49] and [50]
 * TODO Parameter-entity replacement text must be properly nested
 *	with parenthesized groups. That is to say, if either of the
 *	opening or closing parentheses in a choice, seq, or Mixed
 *	construct is contained in the replacement text for a parameter
 *	entity, both must be contained in the same replacement text. For
 *	interoperability, if a parameter-entity reference appears in a
 *	choice, seq, or Mixed construct, its replacement text should not
 *	be empty, and neither the first nor last non-blank character of
 *	the replacement text should be a connector (| or ,).
 *
 * Returns the tree of xmlElementContentPtr describing the element
 *          hierarchy.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseElementChildrenContentDecl(mut ctxt:
                                                                xmlParserCtxtPtr,
                                                            mut inputchk:
                                                                std::os::raw::c_int)
 -> xmlElementContentPtr {
    /* stub left for API/ABI compat */
    return xmlParseElementChildrenContentDeclPriv(ctxt, inputchk,
                                                  1 as std::os::raw::c_int);
}
/* *
 * xmlParseElementContentDecl:
 * @ctxt:  an XML parser context
 * @name:  the name of the element being defined.
 * @result:  the Element Content pointer will be stored here if any
 *
 * parse the declaration for an Element content either Mixed or Children,
 * the cases EMPTY and ANY are handled directly in xmlParseElementDecl
 *
 * [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children
 *
 * returns: the type of element content XML_ELEMENT_TYPE_xxx
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseElementContentDecl(mut ctxt:
                                                        xmlParserCtxtPtr,
                                                    mut name: *const xmlChar,
                                                    mut result:
                                                        *mut xmlElementContentPtr)
 -> std::os::raw::c_int {
    let mut tree: xmlElementContentPtr = 0 as xmlElementContentPtr;
    let mut inputid: std::os::raw::c_int = (*(*ctxt).input).id;
    let mut res: std::os::raw::c_int = 0;
    *result = 0 as xmlElementContentPtr;
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '(' as i32 {
        xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
                          b"xmlParseElementContentDecl : %s \'(\' expected\n\x00"
                              as *const u8 as *const std::os::raw::c_char, name);
        return -(1 as std::os::raw::c_int)
    }
    xmlNextChar(ctxt);
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    xmlSkipBlankChars(ctxt);
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '#' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'P' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'C' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'D' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 {
        tree = xmlParseElementMixedContentDecl(ctxt, inputid);
        res = XML_ELEMENT_TYPE_MIXED as std::os::raw::c_int
    } else {
        tree =
            xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
                                                   1 as std::os::raw::c_int);
        res = XML_ELEMENT_TYPE_ELEMENT as std::os::raw::c_int
    }
    xmlSkipBlankChars(ctxt);
    *result = tree;
    return res;
}
/* *
 * xmlParseElementDecl:
 * @ctxt:  an XML parser context
 *
 * parse an Element declaration.
 *
 * [45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'
 *
 * [ VC: Unique Element Type Declaration ]
 * No element type may be declared more than once
 *
 * Returns the type of the element, or -1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseElementDecl(mut ctxt: xmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ret: std::os::raw::c_int = -(1 as std::os::raw::c_int);
    let mut content: xmlElementContentPtr = 0 as xmlElementContentPtr;
    /* GROW; done in the caller */
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '!' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'L' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'M' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'N' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(8 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 {
        let mut inputid: std::os::raw::c_int = (*(*ctxt).input).id;
        (*ctxt).nbChars += 9 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(9 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 9 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after \'ELEMENT\'\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        name = xmlParseName(ctxt);
        if name.is_null() {
            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                           b"xmlParseElementDecl: no name for Element\n\x00"
                               as *const u8 as *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"Space required after the element name\n\x00" as
                               *const u8 as *const std::os::raw::c_char);
        }
        if *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 &&
               *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'M' as i32 &&
               *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'P' as i32 &&
               *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'T' as i32 &&
               *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 'Y' as i32 {
            (*ctxt).nbChars += 5 as std::os::raw::c_int as std::os::raw::c_long;
            (*(*ctxt).input).cur =
                (*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize);
            (*(*ctxt).input).col += 5 as std::os::raw::c_int;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
            /*
	     * Element must always be empty.
	     */
            ret = XML_ELEMENT_TYPE_EMPTY as std::os::raw::c_int
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == 'A' as i32 &&
                      *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                          as std::os::raw::c_int == 'N' as i32 &&
                      *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize)
                          as std::os::raw::c_int == 'Y' as i32 {
            (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
            (*(*ctxt).input).cur =
                (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
            (*(*ctxt).input).col += 3 as std::os::raw::c_int;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
            /*
	     * Element is a generic container.
	     */
            ret = XML_ELEMENT_TYPE_ANY as std::os::raw::c_int
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '(' as i32 {
            ret = xmlParseElementContentDecl(ctxt, name, &mut content)
        } else {
            /*
	     * [ WFC: PEs in Internal Subset ] error handling.
	     */
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '%' as i32 &&
                   (*ctxt).external == 0 as std::os::raw::c_int &&
                   (*ctxt).inputNr == 1 as std::os::raw::c_int {
                xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,
                               b"PEReference: forbidden within markup decl in internal subset\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            } else {
                xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
                               b"xmlParseElementDecl: \'EMPTY\', \'ANY\' or \'(\' expected\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
            return -(1 as std::os::raw::c_int)
        }
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
            xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, 0 as *const std::os::raw::c_char);
            if !content.is_null() {
                xmlFreeDocElementContent((*ctxt).myDoc, content);
            }
        } else {
            if inputid != (*(*ctxt).input).id {
                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                               b"Element declaration doesn\'t start and stop in the same entity\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
            xmlNextChar(ctxt);
            if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 &&
                   (*(*ctxt).sax).elementDecl.is_some() {
                if !content.is_null() {
                    (*content).parent = 0 as *mut _xmlElementContent
                }
                (*(*ctxt).sax).elementDecl.expect("non-null function pointer")((*ctxt).userData,
                                                                               name,
                                                                               ret,
                                                                               content);
                if !content.is_null() && (*content).parent.is_null() {
                    /*
		     * this is a trick: if xmlAddElementDecl is called,
		     * instead of copying the full tree it is plugged directly
		     * if called from the parser. Avoid duplicating the
		     * interfaces or change the API/ABI
		     */
                    xmlFreeDocElementContent((*ctxt).myDoc, content);
                }
            } else if !content.is_null() {
                xmlFreeDocElementContent((*ctxt).myDoc, content);
            }
        }
    }
    return ret;
}
/* *
 * xmlParseConditionalSections
 * @ctxt:  an XML parser context
 *
 * [61] conditionalSect ::= includeSect | ignoreSect
 * [62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>'
 * [63] ignoreSect ::= '<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'
 * [64] ignoreSectContents ::= Ignore ('<![' ignoreSectContents ']]>' Ignore)*
 * [65] Ignore ::= Char* - (Char* ('<![' | ']]>') Char*)
 */
unsafe extern "C" fn xmlParseConditionalSections(mut ctxt: xmlParserCtxtPtr) {
    let mut id: std::os::raw::c_int = (*(*ctxt).input).id;
    (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
    (*(*ctxt).input).cur =
        (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
    (*(*ctxt).input).col += 3 as std::os::raw::c_int;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    xmlSkipBlankChars(ctxt);
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == 'I' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'N' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'C' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'L' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'U' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'D' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 {
        (*ctxt).nbChars += 7 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(7 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 7 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '[' as i32 {
            xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID,
                        0 as *const std::os::raw::c_char);
            xmlHaltParser(ctxt);
            return
        } else {
            if (*(*ctxt).input).id != id {
                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                               b"All markup of the conditional section is not in the same entity\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
            xmlNextChar(ctxt);
        }
        if *__xmlParserDebugEntities() != 0 {
            if !(*ctxt).input.is_null() &&
                   !(*(*ctxt).input).filename.is_null() {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"%s(%d): \x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char,
                                                                           (*(*ctxt).input).filename,
                                                                           (*(*ctxt).input).line);
            }
            (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                       b"Entering INCLUDE Conditional Section\n\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const std::os::raw::c_char);
        }
        xmlSkipBlankChars(ctxt);
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        while *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                  (*(*(*ctxt).input).cur as std::os::raw::c_int != ']' as i32 ||
                       *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int != ']' as i32 ||
                       *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int != '>' as i32) &&
                  (*ctxt).instate as std::os::raw::c_int !=
                      XML_PARSER_EOF as std::os::raw::c_int {
            let mut check: *const xmlChar = (*(*ctxt).input).cur;
            let mut cons: std::os::raw::c_uint =
                (*(*ctxt).input).consumed as std::os::raw::c_uint;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == '!' as i32 &&
                   *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == '[' as i32 {
                xmlParseConditionalSections(ctxt);
            } else { xmlParseMarkupDecl(ctxt); }
            xmlSkipBlankChars(ctxt);
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if !((*(*ctxt).input).cur == check &&
                     cons as std::os::raw::c_ulong == (*(*ctxt).input).consumed) {
                continue ;
            }
            xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED,
                        0 as *const std::os::raw::c_char);
            xmlHaltParser(ctxt);
            break ;
        }
        if *__xmlParserDebugEntities() != 0 {
            if !(*ctxt).input.is_null() &&
                   !(*(*ctxt).input).filename.is_null() {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"%s(%d): \x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char,
                                                                           (*(*ctxt).input).filename,
                                                                           (*(*ctxt).input).line);
            }
            (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                       b"Leaving INCLUDE Conditional Section\n\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const std::os::raw::c_char);
        }
    } else if *((*(*ctxt).input).cur as
                    *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == 'I' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'G' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'N' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'O' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'R' as i32 &&
                  *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == 'E' as i32 {
        let mut state: std::os::raw::c_int = 0;
        let mut instate: xmlParserInputState = XML_PARSER_START;
        let mut depth: std::os::raw::c_int = 0 as std::os::raw::c_int;
        (*ctxt).nbChars += 6 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 6 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '[' as i32 {
            xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID,
                        0 as *const std::os::raw::c_char);
            xmlHaltParser(ctxt);
            return
        } else {
            if (*(*ctxt).input).id != id {
                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                               b"All markup of the conditional section is not in the same entity\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
            xmlNextChar(ctxt);
        }
        if *__xmlParserDebugEntities() != 0 {
            if !(*ctxt).input.is_null() &&
                   !(*(*ctxt).input).filename.is_null() {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"%s(%d): \x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char,
                                                                           (*(*ctxt).input).filename,
                                                                           (*(*ctxt).input).line);
            }
            (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                       b"Entering IGNORE Conditional Section\n\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const std::os::raw::c_char);
        }
        /*
	 * Parse up to the end of the conditional section
	 * But disable SAX event generating DTD building in the meantime
	 */
        state = (*ctxt).disableSAX;
        instate = (*ctxt).instate;
        if (*ctxt).recovery == 0 as std::os::raw::c_int {
            (*ctxt).disableSAX = 1 as std::os::raw::c_int
        }
        (*ctxt).instate = XML_PARSER_IGNORE;
        while depth >= 0 as std::os::raw::c_int &&
                  *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                  (*ctxt).instate as std::os::raw::c_int !=
                      XML_PARSER_EOF as std::os::raw::c_int {
            if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == '!' as i32 &&
                   *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == '[' as i32 {
                depth += 1;
                (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 3 as std::os::raw::c_int;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int == ']' as i32 &&
                          *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                           isize) as
                              std::os::raw::c_int == ']' as i32 &&
                          *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                           isize) as
                              std::os::raw::c_int == '>' as i32 {
                depth -= 1;
                if depth >= 0 as std::os::raw::c_int {
                    (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
                    (*(*ctxt).input).cur =
                        (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                        isize);
                    (*(*ctxt).input).col += 3 as std::os::raw::c_int;
                    if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                    }
                }
            } else { xmlNextChar(ctxt); }
        }
        (*ctxt).disableSAX = state;
        (*ctxt).instate = instate;
        if *__xmlParserDebugEntities() != 0 {
            if !(*ctxt).input.is_null() &&
                   !(*(*ctxt).input).filename.is_null() {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"%s(%d): \x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char,
                                                                           (*(*ctxt).input).filename,
                                                                           (*(*ctxt).input).line);
            }
            (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                       b"Leaving IGNORE Conditional Section\n\x00"
                                                                           as
                                                                           *const u8
                                                                           as
                                                                           *const std::os::raw::c_char);
        }
    } else {
        xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD,
                    0 as *const std::os::raw::c_char);
        xmlHaltParser(ctxt);
        return
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                   as std::os::raw::c_long >
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) <
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
            xmlSHRINK(ctxt);
        }
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
    } else {
        if (*(*ctxt).input).id != id {
            xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                           b"All markup of the conditional section is not in the same entity\n\x00"
                               as *const u8 as *const std::os::raw::c_char);
        }
        if (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int &&
               (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize) <=
                   (*(*ctxt).input).end {
            (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
            (*(*ctxt).input).cur =
                (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
            (*(*ctxt).input).col += 3 as std::os::raw::c_int;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
        }
    };
}
/* *
 * xmlParseMarkupDecl:
 * @ctxt:  an XML parser context
 *
 * parse Markup declarations
 *
 * [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl |
 *                     NotationDecl | PI | Comment
 *
 * [ VC: Proper Declaration/PE Nesting ]
 * Parameter-entity replacement text must be properly nested with
 * markup declarations. That is to say, if either the first character
 * or the last character of a markup declaration (markupdecl above) is
 * contained in the replacement text for a parameter-entity reference,
 * both must be contained in the same replacement text.
 *
 * [ WFC: PEs in Internal Subset ]
 * In the internal DTD subset, parameter-entity references can occur
 * only where markup declarations can occur, not within markup declarations.
 * (This does not apply to references that occur in external parameter
 * entities or to the external subset.)
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseMarkupDecl(mut ctxt: xmlParserCtxtPtr) {
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 {
        if *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '!' as i32 {
            match *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                      std::os::raw::c_int {
                69 => {
                    if *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize)
                           as std::os::raw::c_int == 'L' as i32 {
                        xmlParseElementDecl(ctxt);
                    } else if *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == 'N' as i32 {
                        xmlParseEntityDecl(ctxt);
                    }
                }
                65 => { xmlParseAttributeListDecl(ctxt); }
                78 => { xmlParseNotationDecl(ctxt); }
                45 => { xmlParseComment(ctxt); }
                _ => { }
            }
        } else if *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                      std::os::raw::c_int == '?' as i32 {
            xmlParsePI(ctxt);
        }
    }
    /*
     * detect requirement to exit there and act accordingly
     * and avoid having instate overriden later on
     */
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    /*
     * Conditional sections are allowed from entities included
     * by PE References in the internal subset.
     */
    if (*ctxt).external == 0 as std::os::raw::c_int &&
           (*ctxt).inputNr > 1 as std::os::raw::c_int {
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '!' as i32 &&
               *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '[' as i32 {
            xmlParseConditionalSections(ctxt);
        }
    }
    (*ctxt).instate = XML_PARSER_DTD;
}
/* *
 * xmlParseTextDecl:
 * @ctxt:  an XML parser context
 *
 * parse an XML declaration header for external entities
 *
 * [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseTextDecl(mut ctxt: xmlParserCtxtPtr) {
    let mut version: *mut xmlChar = 0 as *mut xmlChar;
    let mut encoding: *const xmlChar = 0 as *const xmlChar;
    /*
     * We know that '<?xml' is here.
     */
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '?' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'x' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'm' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'l' as i32 &&
           (*(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                0x9 as std::os::raw::c_int <=
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int &&
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                    std::os::raw::c_int == 0xd as std::os::raw::c_int) {
        (*ctxt).nbChars += 5 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 5 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
    } else {
        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED,
                    0 as *const std::os::raw::c_char);
        return
    }
    if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                       b"Space needed after \'<?xml\'\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
    }
    /*
     * We may have the VersionInfo here.
     */
    version = xmlParseVersionInfo(ctxt);
    if version.is_null() {
        version =
            xmlCharStrdup(b"1.0\x00" as *const u8 as *const std::os::raw::c_char)
    } else if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                       b"Space needed here\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
    }
    (*(*ctxt).input).version = version;
    /*
     * We must have the encoding declaration
     */
    encoding = xmlParseEncodingDecl(ctxt);
    if (*ctxt).errNo == XML_ERR_UNSUPPORTED_ENCODING as std::os::raw::c_int {
        /*
	 * The XML REC instructs us to stop parsing right here
	 */
        return
    }
    if encoding.is_null() && (*ctxt).errNo == XML_ERR_OK as std::os::raw::c_int {
        xmlFatalErrMsg(ctxt, XML_ERR_MISSING_ENCODING,
                       b"Missing encoding in text declaration\n\x00" as
                           *const u8 as *const std::os::raw::c_char);
    }
    xmlSkipBlankChars(ctxt);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '?' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '>' as i32 {
        (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 2 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
        /* Deprecated old WD ... */
        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        xmlNextChar(ctxt);
    } else {
        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        while *(*(*ctxt).input).cur as std::os::raw::c_int != 0 &&
                  *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1)
        }
        xmlNextChar(ctxt);
    };
}
/* *
 * xmlParseExternalSubset:
 * @ctxt:  an XML parser context
 * @ExternalID: the external identifier
 * @SystemID: the system identifier (or URL)
 *
 * parse Markup declarations from an external subset
 *
 * [30] extSubset ::= textDecl? extSubsetDecl
 *
 * [31] extSubsetDecl ::= (markupdecl | conditionalSect | PEReference | S) *
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseExternalSubset(mut ctxt: xmlParserCtxtPtr,
                                                mut ExternalID:
                                                    *const xmlChar,
                                                mut SystemID:
                                                    *const xmlChar) {
    xmlDetectSAX2(ctxt);
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if (*ctxt).encoding.is_null() &&
           (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
               std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
        let mut start: [xmlChar; 4] = [0; 4];
        let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
        start[0 as std::os::raw::c_int as usize] = *(*(*ctxt).input).cur;
        start[1 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
        start[2 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        start[3 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
        enc = xmlDetectCharEncoding(start.as_mut_ptr(), 4 as std::os::raw::c_int);
        if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
            xmlSwitchEncoding(ctxt, enc);
        }
    }
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '?' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'x' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'm' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'l' as i32 {
        xmlParseTextDecl(ctxt);
        if (*ctxt).errNo == XML_ERR_UNSUPPORTED_ENCODING as std::os::raw::c_int {
            /*
	     * The XML REC instructs us to stop parsing right here
	     */
            xmlHaltParser(ctxt);
            return
        }
    }
    if (*ctxt).myDoc.is_null() {
        (*ctxt).myDoc =
            xmlNewDoc(b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        if (*ctxt).myDoc.is_null() {
            xmlErrMemory(ctxt,
                         b"New Doc failed\x00" as *const u8 as
                             *const std::os::raw::c_char);
            return
        }
        (*(*ctxt).myDoc).properties = XML_DOC_INTERNAL as std::os::raw::c_int
    }
    if !(*ctxt).myDoc.is_null() && (*(*ctxt).myDoc).intSubset.is_null() {
        xmlCreateIntSubset((*ctxt).myDoc, 0 as *const xmlChar, ExternalID,
                           SystemID);
    }
    (*ctxt).instate = XML_PARSER_DTD;
    (*ctxt).external = 1 as std::os::raw::c_int;
    xmlSkipBlankChars(ctxt);
    while *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
              *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                  std::os::raw::c_int == '?' as i32 ||
              *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                  *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                      std::os::raw::c_int == '!' as i32 ||
              *(*(*ctxt).input).cur as std::os::raw::c_int == '%' as i32 {
        let mut check: *const xmlChar = (*(*ctxt).input).cur;
        let mut cons: std::os::raw::c_uint =
            (*(*ctxt).input).consumed as std::os::raw::c_uint;
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '!' as i32 &&
               *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '[' as i32 {
            xmlParseConditionalSections(ctxt);
        } else { xmlParseMarkupDecl(ctxt); }
        xmlSkipBlankChars(ctxt);
        if !((*(*ctxt).input).cur == check &&
                 cons as std::os::raw::c_ulong == (*(*ctxt).input).consumed) {
            continue ;
        }
        xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        break ;
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
    };
}
/* *
 * xmlParseReference:
 * @ctxt:  an XML parser context
 *
 * parse and handle entity references in content, depending on the SAX
 * interface, this may end-up in a call to character() if this is a
 * CharRef, a predefined entity, if there is no reference() callback.
 * or if the parser was asked to switch to that mode.
 *
 * [67] Reference ::= EntityRef | CharRef
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseReference(mut ctxt: xmlParserCtxtPtr) {
    let mut ent: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut was_checked: std::os::raw::c_int = 0;
    let mut list: xmlNodePtr = 0 as xmlNodePtr;
    let mut ret: xmlParserErrors = XML_ERR_OK;
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '&' as i32 { return }
    /*
     * Simple case of a CharRef
     */
    if *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int
           == '#' as i32 {
        let mut i: std::os::raw::c_int = 0 as std::os::raw::c_int;
        let mut out: [xmlChar; 10] = [0; 10];
        let mut hex: std::os::raw::c_int =
            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize) as
                std::os::raw::c_int;
        let mut value: std::os::raw::c_int = xmlParseCharRef(ctxt);
        if value == 0 as std::os::raw::c_int { return }
        if (*ctxt).charset != XML_CHAR_ENCODING_UTF8 as std::os::raw::c_int {
            /*
	     * So we are using non-UTF-8 buffers
	     * Check that the char fit on 8bits, if not
	     * generate a CharRef.
	     */
            if value <= 0xff as std::os::raw::c_int {
                out[0 as std::os::raw::c_int as usize] = value as xmlChar;
                out[1 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int as xmlChar;
                if !(*ctxt).sax.is_null() &&
                       (*(*ctxt).sax).characters.is_some() &&
                       (*ctxt).disableSAX == 0 {
                    (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                  out.as_mut_ptr(),
                                                                                  1
                                                                                      as
                                                                                      std::os::raw::c_int);
                }
            } else {
                if hex == 'x' as i32 || hex == 'X' as i32 {
                    snprintf(out.as_mut_ptr() as *mut std::os::raw::c_char,
                             ::std::mem::size_of::<[xmlChar; 10]>() as
                                 std::os::raw::c_ulong,
                             b"#x%X\x00" as *const u8 as *const std::os::raw::c_char,
                             value);
                } else {
                    snprintf(out.as_mut_ptr() as *mut std::os::raw::c_char,
                             ::std::mem::size_of::<[xmlChar; 10]>() as
                                 std::os::raw::c_ulong,
                             b"#%d\x00" as *const u8 as *const std::os::raw::c_char,
                             value);
                }
                if !(*ctxt).sax.is_null() &&
                       (*(*ctxt).sax).reference.is_some() &&
                       (*ctxt).disableSAX == 0 {
                    (*(*ctxt).sax).reference.expect("non-null function pointer")((*ctxt).userData,
                                                                                 out.as_mut_ptr());
                }
            }
        } else {
            /*
	     * Just encode the value in UTF-8
	     */
            if 0 as std::os::raw::c_int == 1 as std::os::raw::c_int {
                let fresh90 = i;
                i = i + 1;
                out[fresh90 as usize] = value as xmlChar
            } else {
                i +=
                    xmlCopyCharMultiByte(&mut *out.as_mut_ptr().offset(i as
                                                                           isize),
                                         value)
            }
            out[i as usize] = 0 as std::os::raw::c_int as xmlChar;
            if !(*ctxt).sax.is_null() && (*(*ctxt).sax).characters.is_some()
                   && (*ctxt).disableSAX == 0 {
                (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                              out.as_mut_ptr(),
                                                                              i);
            }
        }
        return
    }
    /*
     * We are seeing an entity reference
     */
    ent = xmlParseEntityRef(ctxt);
    if ent.is_null() { return }
    if (*ctxt).wellFormed == 0 { return }
    was_checked = (*ent).checked;
    /* special case of predefined entities */
    if (*ent).name.is_null() ||
           (*ent).etype as std::os::raw::c_uint ==
               XML_INTERNAL_PREDEFINED_ENTITY as std::os::raw::c_int as std::os::raw::c_uint {
        val = (*ent).content;
        if val.is_null() { return }
        /*
	 * inline the entity.
	 */
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).characters.is_some() &&
               (*ctxt).disableSAX == 0 {
            (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                          val,
                                                                          xmlStrlen(val));
        }
        return
    }
    /*
     * The first reference to the entity trigger a parsing phase
     * where the ent->children is filled with the result from
     * the parsing.
     * Note: external parsed entities will not be loaded, it is not
     * required for a non-validating parser, unless the parsing option
     * of validating, or substituting entities were given. Doing so is
     * far more secure as the parser will only process data coming from
     * the document entity by default.
     */
    if ((*ent).checked == 0 as std::os::raw::c_int ||
            (*ent).children.is_null() &&
                (*ctxt).options & XML_PARSE_NOENT as std::os::raw::c_int != 0) &&
           ((*ent).etype as std::os::raw::c_uint !=
                XML_EXTERNAL_GENERAL_PARSED_ENTITY as std::os::raw::c_int as
                    std::os::raw::c_uint ||
                (*ctxt).options &
                    (XML_PARSE_NOENT as std::os::raw::c_int |
                         XML_PARSE_DTDVALID as std::os::raw::c_int) != 0) {
        let mut oldnbent: std::os::raw::c_ulong = (*ctxt).nbentities;
        /*
	 * This is a bit hackish but this seems the best
	 * way to make sure both SAX and DOM entity support
	 * behaves okay.
	 */
        let mut user_data: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
        if (*ctxt).userData == ctxt as *mut std::os::raw::c_void {
            user_data = 0 as *mut std::os::raw::c_void
        } else { user_data = (*ctxt).userData }
        /*
	 * Check that this entity is well formed
	 * 4.3.2: An internal general parsed entity is well-formed
	 * if its replacement text matches the production labeled
	 * content.
	 */
        if (*ent).etype as std::os::raw::c_uint ==
               XML_INTERNAL_GENERAL_ENTITY as std::os::raw::c_int as std::os::raw::c_uint {
            (*ctxt).depth += 1;
            ret =
                xmlParseBalancedChunkMemoryInternal(ctxt, (*ent).content,
                                                    user_data, &mut list);
            (*ctxt).depth -= 1
        } else if (*ent).etype as std::os::raw::c_uint ==
                      XML_EXTERNAL_GENERAL_PARSED_ENTITY as std::os::raw::c_int as
                          std::os::raw::c_uint {
            (*ctxt).depth += 1;
            ret =
                xmlParseExternalEntityPrivate((*ctxt).myDoc, ctxt,
                                              (*ctxt).sax, user_data,
                                              (*ctxt).depth, (*ent).URI,
                                              (*ent).ExternalID, &mut list);
            (*ctxt).depth -= 1
        } else {
            ret = XML_ERR_ENTITY_PE_INTERNAL;
            xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
                         b"invalid entity type found\n\x00" as *const u8 as
                             *const std::os::raw::c_char, 0 as *const xmlChar);
        }
        /*
	 * Store the number of entities needing parsing for this entity
	 * content and do checkings
	 */
        (*ent).checked =
            (*ctxt).nbentities.wrapping_sub(oldnbent).wrapping_add(1 as
                                                                       std::os::raw::c_int
                                                                       as
                                                                       std::os::raw::c_ulong).wrapping_mul(2
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                                       as
                                                                                                       std::os::raw::c_ulong)
                as std::os::raw::c_int;
        if !(*ent).content.is_null() &&
               !xmlStrchr((*ent).content, '<' as i32 as xmlChar).is_null() {
            (*ent).checked |= 1 as std::os::raw::c_int
        }
        if ret as std::os::raw::c_uint ==
               XML_ERR_ENTITY_LOOP as std::os::raw::c_int as std::os::raw::c_uint {
            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, 0 as *const std::os::raw::c_char);
            xmlFreeNodeList(list);
            return
        }
        if xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t, ent,
                                0 as std::os::raw::c_int as size_t) != 0 {
            xmlFreeNodeList(list);
            return
        }
        if ret as std::os::raw::c_uint == XML_ERR_OK as std::os::raw::c_int as std::os::raw::c_uint &&
               !list.is_null() {
            if ((*ent).etype as std::os::raw::c_uint ==
                    XML_INTERNAL_GENERAL_ENTITY as std::os::raw::c_int as std::os::raw::c_uint
                    ||
                    (*ent).etype as std::os::raw::c_uint ==
                        XML_EXTERNAL_GENERAL_PARSED_ENTITY as std::os::raw::c_int as
                            std::os::raw::c_uint) && (*ent).children.is_null() {
                (*ent).children = list;
                if (*ctxt).replaceEntities != 0 {
                    /*
		     * Prune it directly in the generated document
		     * except for single text nodes.
		     */
                    if (*list).type_0 as std::os::raw::c_uint ==
                           XML_TEXT_NODE as std::os::raw::c_int as std::os::raw::c_uint &&
                           (*list).next.is_null() ||
                           (*ctxt).parseMode as std::os::raw::c_uint ==
                               XML_PARSE_READER as std::os::raw::c_int as std::os::raw::c_uint
                       {
                        (*list).parent = ent as xmlNodePtr;
                        list = 0 as xmlNodePtr;
                        (*ent).owner = 1 as std::os::raw::c_int
                    } else {
                        (*ent).owner = 0 as std::os::raw::c_int;
                        while !list.is_null() {
                            (*list).parent = (*ctxt).node;
                            (*list).doc = (*ctxt).myDoc;
                            if (*list).next.is_null() { (*ent).last = list }
                            list = (*list).next
                        }
                        list = (*ent).children;
                        if (*ent).etype as std::os::raw::c_uint ==
                               XML_EXTERNAL_GENERAL_PARSED_ENTITY as
                                   std::os::raw::c_int as std::os::raw::c_uint {
                            xmlAddEntityReference(ent, list, 0 as xmlNodePtr);
                        }
                        /* LIBXML_LEGACY_ENABLED */
                    }
                } else {
                    (*ent).owner = 1 as std::os::raw::c_int;
                    while !list.is_null() {
                        (*list).parent = ent as xmlNodePtr;
                        xmlSetTreeDoc(list, (*ent).doc);
                        if (*list).next.is_null() { (*ent).last = list }
                        list = (*list).next
                    }
                }
            } else { xmlFreeNodeList(list); list = 0 as xmlNodePtr }
        } else if ret as std::os::raw::c_uint !=
                      XML_ERR_OK as std::os::raw::c_int as std::os::raw::c_uint &&
                      ret as std::os::raw::c_uint !=
                          XML_WAR_UNDECLARED_ENTITY as std::os::raw::c_int as
                              std::os::raw::c_uint {
            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
                              b"Entity \'%s\' failed to parse\n\x00" as
                                  *const u8 as *const std::os::raw::c_char,
                              (*ent).name);
            if !(*ent).content.is_null() {
                *(*ent).content.offset(0 as std::os::raw::c_int as isize) =
                    0 as std::os::raw::c_int as xmlChar
            }
            xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t, ent,
                                 0 as std::os::raw::c_int as size_t);
        } else if !list.is_null() {
            xmlFreeNodeList(list);
            list = 0 as xmlNodePtr
        }
        if (*ent).checked == 0 as std::os::raw::c_int {
            (*ent).checked = 2 as std::os::raw::c_int
        }
        /* Prevent entity from being parsed and expanded twice (Bug 760367). */
        was_checked = 0 as std::os::raw::c_int
    } else if (*ent).checked != 1 as std::os::raw::c_int {
        (*ctxt).nbentities =
            (*ctxt).nbentities.wrapping_add(((*ent).checked /
                                                 2 as std::os::raw::c_int) as
                                                std::os::raw::c_ulong)
    }
    /*
     * Now that the entity content has been gathered
     * provide it to the application, this can take different forms based
     * on the parsing modes.
     */
    if (*ent).children.is_null() {
        /*
	 * Probably running in SAX mode and the callbacks don't
	 * build the entity content. So unless we already went
	 * though parsing for first checking go though the entity
	 * content to generate callbacks associated to the entity
	 */
        if was_checked != 0 as std::os::raw::c_int {
            let mut user_data_0: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
            /*
	     * This is a bit hackish but this seems the best
	     * way to make sure both SAX and DOM entity support
	     * behaves okay.
	     */
            if (*ctxt).userData == ctxt as *mut std::os::raw::c_void {
                user_data_0 = 0 as *mut std::os::raw::c_void
            } else { user_data_0 = (*ctxt).userData }
            if (*ent).etype as std::os::raw::c_uint ==
                   XML_INTERNAL_GENERAL_ENTITY as std::os::raw::c_int as std::os::raw::c_uint
               {
                (*ctxt).depth += 1;
                ret =
                    xmlParseBalancedChunkMemoryInternal(ctxt, (*ent).content,
                                                        user_data_0,
                                                        0 as *mut xmlNodePtr);
                (*ctxt).depth -= 1
            } else if (*ent).etype as std::os::raw::c_uint ==
                          XML_EXTERNAL_GENERAL_PARSED_ENTITY as std::os::raw::c_int as
                              std::os::raw::c_uint {
                (*ctxt).depth += 1;
                ret =
                    xmlParseExternalEntityPrivate((*ctxt).myDoc, ctxt,
                                                  (*ctxt).sax, user_data_0,
                                                  (*ctxt).depth, (*ent).URI,
                                                  (*ent).ExternalID,
                                                  0 as *mut xmlNodePtr);
                (*ctxt).depth -= 1
            } else {
                ret = XML_ERR_ENTITY_PE_INTERNAL;
                xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
                             b"invalid entity type found\n\x00" as *const u8
                                 as *const std::os::raw::c_char, 0 as *const xmlChar);
            }
            if ret as std::os::raw::c_uint ==
                   XML_ERR_ENTITY_LOOP as std::os::raw::c_int as std::os::raw::c_uint {
                xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP,
                            0 as *const std::os::raw::c_char);
                return
            }
        }
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).reference.is_some() &&
               (*ctxt).replaceEntities == 0 as std::os::raw::c_int &&
               (*ctxt).disableSAX == 0 {
            /*
	     * Entity reference callback comes second, it's somewhat
	     * superfluous but a compatibility to historical behaviour
	     */
            (*(*ctxt).sax).reference.expect("non-null function pointer")((*ctxt).userData,
                                                                         (*ent).name);
        }
        return
    }
    /*
     * If we didn't get any children for the entity being built
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).reference.is_some() &&
           (*ctxt).replaceEntities == 0 as std::os::raw::c_int &&
           (*ctxt).disableSAX == 0 {
        /*
	 * Create a node.
	 */
        (*(*ctxt).sax).reference.expect("non-null function pointer")((*ctxt).userData,
                                                                     (*ent).name);
        return
    }
    if (*ctxt).replaceEntities != 0 || (*ent).children.is_null() {
        /*
	 * There is a problem on the handling of _private for entities
	 * (bug 155816): Should we copy the content of the field from
	 * the entity (possibly overwriting some value set by the user
	 * when a copy is created), should we leave it alone, or should
	 * we try to take care of different situations?  The problem
	 * is exacerbated by the usage of this field by the xmlReader.
	 * To fix this bug, we look at _private on the created node
	 * and, if it's NULL, we copy in whatever was in the entity.
	 * If it's not NULL we leave it alone.  This is somewhat of a
	 * hack - maybe we should have further tests to determine
	 * what to do.
	 */
        if !(*ctxt).node.is_null() && !(*ent).children.is_null() {
            /*
	     * Seems we are generating the DOM content, do
	     * a simple tree copy for all references except the first
	     * In the first occurrence list contains the replacement.
	     */
            if list.is_null() && (*ent).owner == 0 as std::os::raw::c_int ||
                   (*ctxt).parseMode as std::os::raw::c_uint ==
                       XML_PARSE_READER as std::os::raw::c_int as std::os::raw::c_uint {
                let mut nw: xmlNodePtr = 0 as xmlNodePtr;
                let mut cur: xmlNodePtr = 0 as *mut xmlNode;
                let mut firstChild: xmlNodePtr = 0 as xmlNodePtr;
                /* LIBXML_LEGACY_ENABLED */
                (*ctxt).sizeentcopy =
                    (*ctxt).sizeentcopy.wrapping_add(((*ent).length +
                                                          5 as std::os::raw::c_int) as
                                                         std::os::raw::c_ulong);
                if xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t, ent,
                                        (*ctxt).sizeentcopy) != 0 {
                    return
                }
                cur = (*ent).children;
                while !cur.is_null() {
                    nw = xmlDocCopyNode(cur, (*ctxt).myDoc, 1 as std::os::raw::c_int);
                    if !nw.is_null() {
                        if (*nw)._private.is_null() {
                            (*nw)._private = (*cur)._private
                        }
                        if firstChild.is_null() { firstChild = nw }
                        nw = xmlAddChild((*ctxt).node, nw)
                    }
                    if cur == (*ent).last {
                        /*
		 * We are copying here, make sure there is no abuse
		 */
                        /*
		 * when operating on a reader, the entities definitions
		 * are always owning the entities subtree.
		if (ctxt->parseMode == XML_PARSE_READER)
		    ent->owner = 1;
		 */
                        /*
			 * needed to detect some strange empty
			 * node cases in the reader tests
			 */
                        if (*ctxt).parseMode as std::os::raw::c_uint ==
                               XML_PARSE_READER as std::os::raw::c_int as std::os::raw::c_uint
                               && !nw.is_null() &&
                               (*nw).type_0 as std::os::raw::c_uint ==
                                   XML_ELEMENT_NODE as std::os::raw::c_int as
                                       std::os::raw::c_uint &&
                               (*nw).children.is_null() {
                            (*nw).extra = 1 as std::os::raw::c_int as std::os::raw::c_ushort
                        }
                        break ;
                    } else { cur = (*cur).next }
                }
                if (*ent).etype as std::os::raw::c_uint ==
                       XML_EXTERNAL_GENERAL_PARSED_ENTITY as std::os::raw::c_int as
                           std::os::raw::c_uint {
                    xmlAddEntityReference(ent, firstChild, nw);
                }
            } else if list.is_null() || (*ctxt).inputNr > 0 as std::os::raw::c_int {
                let mut nw_0: xmlNodePtr = 0 as xmlNodePtr;
                let mut cur_0: xmlNodePtr = 0 as *mut xmlNode;
                let mut next: xmlNodePtr = 0 as *mut xmlNode;
                let mut last: xmlNodePtr = 0 as *mut xmlNode;
                let mut firstChild_0: xmlNodePtr = 0 as xmlNodePtr;
                /* LIBXML_LEGACY_ENABLED */
                (*ctxt).sizeentcopy =
                    (*ctxt).sizeentcopy.wrapping_add(((*ent).length +
                                                          5 as std::os::raw::c_int) as
                                                         std::os::raw::c_ulong);
                if xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t, ent,
                                        (*ctxt).sizeentcopy) != 0 {
                    return
                }
                cur_0 = (*ent).children;
                (*ent).children = 0 as *mut _xmlNode;
                last = (*ent).last;
                (*ent).last = 0 as *mut _xmlNode;
                while !cur_0.is_null() {
                    next = (*cur_0).next;
                    (*cur_0).next = 0 as *mut _xmlNode;
                    (*cur_0).parent = 0 as *mut _xmlNode;
                    nw_0 =
                        xmlDocCopyNode(cur_0, (*ctxt).myDoc,
                                       1 as std::os::raw::c_int);
                    if !nw_0.is_null() {
                        if (*nw_0)._private.is_null() {
                            (*nw_0)._private = (*cur_0)._private
                        }
                        if firstChild_0.is_null() { firstChild_0 = cur_0 }
                        xmlAddChild(ent as xmlNodePtr, nw_0);
                        xmlAddChild((*ctxt).node, cur_0);
                    }
                    if cur_0 == last { break ; }
                    cur_0 = next
                }
                if (*ent).owner == 0 as std::os::raw::c_int {
                    (*ent).owner = 1 as std::os::raw::c_int
                }
                if (*ent).etype as std::os::raw::c_uint ==
                       XML_EXTERNAL_GENERAL_PARSED_ENTITY as std::os::raw::c_int as
                           std::os::raw::c_uint {
                    xmlAddEntityReference(ent, firstChild_0, nw_0);
                }
            } else {
                let mut nbktext: *const xmlChar = 0 as *const xmlChar;
                /*
		 * We are copying here, make sure there is no abuse
		 */
                /*
		 * Copy the entity child list and make it the new
		 * entity child list. The goal is to make sure any
		 * ID or REF referenced will be the one from the
		 * document content and not the entity copy.
		 */
                /*
		 * the name change is to avoid coalescing of the
		 * node with a possible previous text one which
		 * would make ent->children a dangling pointer
		 */
                nbktext =
                    xmlDictLookup((*ctxt).dict,
                                  b"nbktext\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar,
                                  -(1 as std::os::raw::c_int));
                if (*(*ent).children).type_0 as std::os::raw::c_uint ==
                       XML_TEXT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
                    (*(*ent).children).name = nbktext
                }
                if (*ent).last != (*ent).children &&
                       (*(*ent).last).type_0 as std::os::raw::c_uint ==
                           XML_TEXT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
                    (*(*ent).last).name = nbktext
                }
                xmlAddChildList((*ctxt).node, (*ent).children);
            }
            /*
	     * This is to avoid a nasty side effect, see
	     * characters() in SAX.c
	     */
            (*ctxt).nodemem = 0 as std::os::raw::c_int;
            (*ctxt).nodelen = 0 as std::os::raw::c_int;
            return
        }
    };
}
/* *
 * xmlParseEntityRef:
 * @ctxt:  an XML parser context
 *
 * parse ENTITY references declarations
 *
 * [68] EntityRef ::= '&' Name ';'
 *
 * [ WFC: Entity Declared ]
 * In a document without any DTD, a document with only an internal DTD
 * subset which contains no parameter entity references, or a document
 * with "standalone='yes'", the Name given in the entity reference
 * must match that in an entity declaration, except that well-formed
 * documents need not declare any of the following entities: amp, lt,
 * gt, apos, quot.  The declaration of a parameter entity must precede
 * any reference to it.  Similarly, the declaration of a general entity
 * must precede any reference to it which appears in a default value in an
 * attribute-list declaration. Note that if entities are declared in the
 * external subset or in external parameter entities, a non-validating
 * processor is not obligated to read and process their declarations;
 * for such documents, the rule that an entity must be declared is a
 * well-formedness constraint only if standalone='yes'.
 *
 * [ WFC: Parsed Entity ]
 * An entity reference must not contain the name of an unparsed entity
 *
 * Returns the xmlEntityPtr if found, or NULL otherwise.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseEntityRef(mut ctxt: xmlParserCtxtPtr)
 -> xmlEntityPtr {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ent: xmlEntityPtr = 0 as xmlEntityPtr;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return 0 as xmlEntityPtr
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '&' as i32 {
        return 0 as xmlEntityPtr
    }
    xmlNextChar(ctxt);
    name = xmlParseName(ctxt);
    if name.is_null() {
        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                       b"xmlParseEntityRef: no name\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
        return 0 as xmlEntityPtr
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != ';' as i32 {
        xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING,
                    0 as *const std::os::raw::c_char);
        return 0 as xmlEntityPtr
    }
    xmlNextChar(ctxt);
    /*
     * Predefined entities override any extra definition
     */
    if (*ctxt).options & XML_PARSE_OLDSAX as std::os::raw::c_int == 0 as std::os::raw::c_int {
        ent = xmlGetPredefinedEntity(name);
        if !ent.is_null() { return ent }
    }
    /*
     * Increase the number of entity references parsed
     */
    (*ctxt).nbentities = (*ctxt).nbentities.wrapping_add(1);
    /*
     * Ask first SAX for entity resolution, otherwise try the
     * entities which may have stored in the parser context.
     */
    if !(*ctxt).sax.is_null() {
        if (*(*ctxt).sax).getEntity.is_some() {
            ent =
                (*(*ctxt).sax).getEntity.expect("non-null function pointer")((*ctxt).userData,
                                                                             name)
        }
        if (*ctxt).wellFormed == 1 as std::os::raw::c_int && ent.is_null() &&
               (*ctxt).options & XML_PARSE_OLDSAX as std::os::raw::c_int != 0 {
            ent = xmlGetPredefinedEntity(name)
        }
        if (*ctxt).wellFormed == 1 as std::os::raw::c_int && ent.is_null() &&
               (*ctxt).userData == ctxt as *mut std::os::raw::c_void {
            ent = xmlSAX2GetEntity(ctxt as *mut std::os::raw::c_void, name)
        }
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return 0 as xmlEntityPtr
    }
    /*
     * [ WFC: Entity Declared ]
     * In a document without any DTD, a document with only an
     * internal DTD subset which contains no parameter entity
     * references, or a document with "standalone='yes'", the
     * Name given in the entity reference must match that in an
     * entity declaration, except that well-formed documents
     * need not declare any of the following entities: amp, lt,
     * gt, apos, quot.
     * The declaration of a parameter entity must precede any
     * reference to it.
     * Similarly, the declaration of a general entity must
     * precede any reference to it which appears in a default
     * value in an attribute-list declaration. Note that if
     * entities are declared in the external subset or in
     * external parameter entities, a non-validating processor
     * is not obligated to read and process their declarations;
     * for such documents, the rule that an entity must be
     * declared is a well-formedness constraint only if
     * standalone='yes'.
     */
    if ent.is_null() {
        if (*ctxt).standalone == 1 as std::os::raw::c_int ||
               (*ctxt).hasExternalSubset == 0 as std::os::raw::c_int &&
                   (*ctxt).hasPErefs == 0 as std::os::raw::c_int {
            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
                              b"Entity \'%s\' not defined\n\x00" as *const u8
                                  as *const std::os::raw::c_char, name);
        } else {
            xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
                         b"Entity \'%s\' not defined\n\x00" as *const u8 as
                             *const std::os::raw::c_char, name);
            if (*ctxt).inSubset == 0 as std::os::raw::c_int && !(*ctxt).sax.is_null()
                   && (*(*ctxt).sax).reference.is_some() {
                (*(*ctxt).sax).reference.expect("non-null function pointer")((*ctxt).userData,
                                                                             name);
            }
        }
        xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t, ent,
                             0 as std::os::raw::c_int as size_t);
        (*ctxt).valid = 0 as std::os::raw::c_int
    } else if (*ent).etype as std::os::raw::c_uint ==
                  XML_EXTERNAL_GENERAL_UNPARSED_ENTITY as std::os::raw::c_int as
                      std::os::raw::c_uint {
        xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
                          b"Entity reference to unparsed entity %s\n\x00" as
                              *const u8 as *const std::os::raw::c_char, name);
    } else if (*ctxt).instate as std::os::raw::c_int ==
                  XML_PARSER_ATTRIBUTE_VALUE as std::os::raw::c_int &&
                  (*ent).etype as std::os::raw::c_uint ==
                      XML_EXTERNAL_GENERAL_PARSED_ENTITY as std::os::raw::c_int as
                          std::os::raw::c_uint {
        xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
                          b"Attribute references external entity \'%s\'\n\x00"
                              as *const u8 as *const std::os::raw::c_char, name);
    } else if (*ctxt).instate as std::os::raw::c_int ==
                  XML_PARSER_ATTRIBUTE_VALUE as std::os::raw::c_int && !ent.is_null()
                  &&
                  (*ent).etype as std::os::raw::c_uint !=
                      XML_INTERNAL_PREDEFINED_ENTITY as std::os::raw::c_int as
                          std::os::raw::c_uint {
        if ((*ent).checked & 1 as std::os::raw::c_int != 0 ||
                (*ent).checked == 0 as std::os::raw::c_int) &&
               !(*ent).content.is_null() &&
               !xmlStrchr((*ent).content, '<' as i32 as xmlChar).is_null() {
            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
                              b"\'<\' in entity \'%s\' is not allowed in attributes values\n\x00"
                                  as *const u8 as *const std::os::raw::c_char, name);
        }
    } else {
        /*
     * [ WFC: Parsed Entity ]
     * An entity reference must not contain the name of an
     * unparsed entity
     */
        /*
     * [ WFC: No External Entity References ]
     * Attribute values cannot contain direct or indirect
     * entity references to external entities.
     */
        /*
     * [ WFC: No < in Attribute Values ]
     * The replacement text of any entity referred to directly or
     * indirectly in an attribute value (other than "&lt;") must
     * not contain a <.
     */
        /*
     * Internal check, no parameter entities here ...
     */
        match (*ent).etype as std::os::raw::c_uint {
            4 | 5 => {
                xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
                                  b"Attempt to reference the parameter entity \'%s\'\n\x00"
                                      as *const u8 as *const std::os::raw::c_char,
                                  name);
            }
            _ => { }
        }
    }
    /*
     * [ WFC: No Recursion ]
     * A parsed entity must not contain a recursive reference
     * to itself, either directly or indirectly.
     * Done somewhere else
     */
    return ent;
}
/* ***********************************************************************
 *									*
 *		Parser stacks related functions and macros		*
 *									*
 ************************************************************************/
/* *
 * xmlParseStringEntityRef:
 * @ctxt:  an XML parser context
 * @str:  a pointer to an index in the string
 *
 * parse ENTITY references declarations, but this version parses it from
 * a string value.
 *
 * [68] EntityRef ::= '&' Name ';'
 *
 * [ WFC: Entity Declared ]
 * In a document without any DTD, a document with only an internal DTD
 * subset which contains no parameter entity references, or a document
 * with "standalone='yes'", the Name given in the entity reference
 * must match that in an entity declaration, except that well-formed
 * documents need not declare any of the following entities: amp, lt,
 * gt, apos, quot.  The declaration of a parameter entity must precede
 * any reference to it.  Similarly, the declaration of a general entity
 * must precede any reference to it which appears in a default value in an
 * attribute-list declaration. Note that if entities are declared in the
 * external subset or in external parameter entities, a non-validating
 * processor is not obligated to read and process their declarations;
 * for such documents, the rule that an entity must be declared is a
 * well-formedness constraint only if standalone='yes'.
 *
 * [ WFC: Parsed Entity ]
 * An entity reference must not contain the name of an unparsed entity
 *
 * Returns the xmlEntityPtr if found, or NULL otherwise. The str pointer
 * is updated to the current location in the string.
 */
unsafe extern "C" fn xmlParseStringEntityRef(mut ctxt: xmlParserCtxtPtr,
                                             mut str: *mut *const xmlChar)
 -> xmlEntityPtr {
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut ptr: *const xmlChar = 0 as *const xmlChar;
    let mut cur: xmlChar = 0;
    let mut ent: xmlEntityPtr = 0 as xmlEntityPtr;
    if str.is_null() || (*str).is_null() { return 0 as xmlEntityPtr }
    ptr = *str;
    cur = *ptr;
    if cur as std::os::raw::c_int != '&' as i32 { return 0 as xmlEntityPtr }
    ptr = ptr.offset(1);
    name = xmlParseStringName(ctxt, &mut ptr);
    if name.is_null() {
        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                       b"xmlParseStringEntityRef: no name\n\x00" as *const u8
                           as *const std::os::raw::c_char);
        *str = ptr;
        return 0 as xmlEntityPtr
    }
    if *ptr as std::os::raw::c_int != ';' as i32 {
        xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING,
                    0 as *const std::os::raw::c_char);
        xmlFree.expect("non-null function pointer")(name as
                                                        *mut std::os::raw::c_void);
        *str = ptr;
        return 0 as xmlEntityPtr
    }
    ptr = ptr.offset(1);
    /*
     * Predefined entities override any extra definition
     */
    if (*ctxt).options & XML_PARSE_OLDSAX as std::os::raw::c_int == 0 as std::os::raw::c_int {
        ent = xmlGetPredefinedEntity(name);
        if !ent.is_null() {
            xmlFree.expect("non-null function pointer")(name as
                                                            *mut std::os::raw::c_void);
            *str = ptr;
            return ent
        }
    }
    /*
     * Increate the number of entity references parsed
     */
    (*ctxt).nbentities = (*ctxt).nbentities.wrapping_add(1);
    /*
     * Ask first SAX for entity resolution, otherwise try the
     * entities which may have stored in the parser context.
     */
    if !(*ctxt).sax.is_null() {
        if (*(*ctxt).sax).getEntity.is_some() {
            ent =
                (*(*ctxt).sax).getEntity.expect("non-null function pointer")((*ctxt).userData,
                                                                             name)
        }
        if ent.is_null() &&
               (*ctxt).options & XML_PARSE_OLDSAX as std::os::raw::c_int != 0 {
            ent = xmlGetPredefinedEntity(name)
        }
        if ent.is_null() && (*ctxt).userData == ctxt as *mut std::os::raw::c_void {
            ent = xmlSAX2GetEntity(ctxt as *mut std::os::raw::c_void, name)
        }
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        xmlFree.expect("non-null function pointer")(name as
                                                        *mut std::os::raw::c_void);
        return 0 as xmlEntityPtr
    }
    /*
     * [ WFC: Entity Declared ]
     * In a document without any DTD, a document with only an
     * internal DTD subset which contains no parameter entity
     * references, or a document with "standalone='yes'", the
     * Name given in the entity reference must match that in an
     * entity declaration, except that well-formed documents
     * need not declare any of the following entities: amp, lt,
     * gt, apos, quot.
     * The declaration of a parameter entity must precede any
     * reference to it.
     * Similarly, the declaration of a general entity must
     * precede any reference to it which appears in a default
     * value in an attribute-list declaration. Note that if
     * entities are declared in the external subset or in
     * external parameter entities, a non-validating processor
     * is not obligated to read and process their declarations;
     * for such documents, the rule that an entity must be
     * declared is a well-formedness constraint only if
     * standalone='yes'.
     */
    if ent.is_null() {
        if (*ctxt).standalone == 1 as std::os::raw::c_int ||
               (*ctxt).hasExternalSubset == 0 as std::os::raw::c_int &&
                   (*ctxt).hasPErefs == 0 as std::os::raw::c_int {
            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
                              b"Entity \'%s\' not defined\n\x00" as *const u8
                                  as *const std::os::raw::c_char, name);
        } else {
            xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
                         b"Entity \'%s\' not defined\n\x00" as *const u8 as
                             *const std::os::raw::c_char, name);
        }
        xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t, ent,
                             0 as std::os::raw::c_int as size_t);
        /* TODO ? check regressions ctxt->valid = 0; */
    } else if (*ent).etype as std::os::raw::c_uint ==
                  XML_EXTERNAL_GENERAL_UNPARSED_ENTITY as std::os::raw::c_int as
                      std::os::raw::c_uint {
        xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
                          b"Entity reference to unparsed entity %s\n\x00" as
                              *const u8 as *const std::os::raw::c_char, name);
    } else if (*ctxt).instate as std::os::raw::c_int ==
                  XML_PARSER_ATTRIBUTE_VALUE as std::os::raw::c_int &&
                  (*ent).etype as std::os::raw::c_uint ==
                      XML_EXTERNAL_GENERAL_PARSED_ENTITY as std::os::raw::c_int as
                          std::os::raw::c_uint {
        xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
                          b"Attribute references external entity \'%s\'\n\x00"
                              as *const u8 as *const std::os::raw::c_char, name);
    } else if (*ctxt).instate as std::os::raw::c_int ==
                  XML_PARSER_ATTRIBUTE_VALUE as std::os::raw::c_int && !ent.is_null()
                  && !(*ent).content.is_null() &&
                  (*ent).etype as std::os::raw::c_uint !=
                      XML_INTERNAL_PREDEFINED_ENTITY as std::os::raw::c_int as
                          std::os::raw::c_uint &&
                  !xmlStrchr((*ent).content, '<' as i32 as xmlChar).is_null()
     {
        xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
                          b"\'<\' in entity \'%s\' is not allowed in attributes values\n\x00"
                              as *const u8 as *const std::os::raw::c_char, name);
    } else {
        /*
     * [ WFC: Parsed Entity ]
     * An entity reference must not contain the name of an
     * unparsed entity
     */
        /*
     * [ WFC: No External Entity References ]
     * Attribute values cannot contain direct or indirect
     * entity references to external entities.
     */
        /*
     * [ WFC: No < in Attribute Values ]
     * The replacement text of any entity referred to directly or
     * indirectly in an attribute value (other than "&lt;") must
     * not contain a <.
     */
        /*
     * Internal check, no parameter entities here ...
     */
        match (*ent).etype as std::os::raw::c_uint {
            4 | 5 => {
                xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
                                  b"Attempt to reference the parameter entity \'%s\'\n\x00"
                                      as *const u8 as *const std::os::raw::c_char,
                                  name);
            }
            _ => { }
        }
    }
    /*
     * [ WFC: No Recursion ]
     * A parsed entity must not contain a recursive reference
     * to itself, either directly or indirectly.
     * Done somewhere else
     */
    xmlFree.expect("non-null function pointer")(name as *mut std::os::raw::c_void);
    *str = ptr;
    return ent;
}
/* *
 * xmlParsePEReference:
 * @ctxt:  an XML parser context
 *
 * parse PEReference declarations
 * The entity content is handled directly by pushing it's content as
 * a new input stream.
 *
 * [69] PEReference ::= '%' Name ';'
 *
 * [ WFC: No Recursion ]
 * A parsed entity must not contain a recursive
 * reference to itself, either directly or indirectly.
 *
 * [ WFC: Entity Declared ]
 * In a document without any DTD, a document with only an internal DTD
 * subset which contains no parameter entity references, or a document
 * with "standalone='yes'", ...  ... The declaration of a parameter
 * entity must precede any reference to it...
 *
 * [ VC: Entity Declared ]
 * In a document with an external subset or external parameter entities
 * with "standalone='no'", ...  ... The declaration of a parameter entity
 * must precede any reference to it...
 *
 * [ WFC: In DTD ]
 * Parameter-entity references may only appear in the DTD.
 * NOTE: misleading but this is handled.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParsePEReference(mut ctxt: xmlParserCtxtPtr) {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut entity: xmlEntityPtr = 0 as xmlEntityPtr;
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '%' as i32 { return }
    xmlNextChar(ctxt);
    name = xmlParseName(ctxt);
    if name.is_null() {
        xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME,
                       b"PEReference: no name\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
        return
    }
    if *__xmlParserDebugEntities() != 0 {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"PEReference: %s\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   name);
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != ';' as i32 {
        xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING,
                    0 as *const std::os::raw::c_char);
        return
    }
    xmlNextChar(ctxt);
    /*
     * Increate the number of entity references parsed
     */
    (*ctxt).nbentities = (*ctxt).nbentities.wrapping_add(1);
    /*
     * Request the entity from SAX
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).getParameterEntity.is_some() {
        entity =
            (*(*ctxt).sax).getParameterEntity.expect("non-null function pointer")((*ctxt).userData,
                                                                                  name)
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if entity.is_null() {
        /*
	 * [ WFC: Entity Declared ]
	 * In a document without any DTD, a document with only an
	 * internal DTD subset which contains no parameter entity
	 * references, or a document with "standalone='yes'", ...
	 * ... The declaration of a parameter entity must precede
	 * any reference to it...
	 */
        if (*ctxt).standalone == 1 as std::os::raw::c_int ||
               (*ctxt).hasExternalSubset == 0 as std::os::raw::c_int &&
                   (*ctxt).hasPErefs == 0 as std::os::raw::c_int {
            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
                              b"PEReference: %%%s; not found\n\x00" as
                                  *const u8 as *const std::os::raw::c_char, name);
        } else {
            /*
	     * [ VC: Entity Declared ]
	     * In a document with an external subset or external
	     * parameter entities with "standalone='no'", ...
	     * ... The declaration of a parameter entity must
	     * precede any reference to it...
	     */
            if (*ctxt).validate != 0 && (*ctxt).vctxt.error.is_some() {
                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
                                 b"PEReference: %%%s; not found\n\x00" as
                                     *const u8 as *const std::os::raw::c_char, name,
                                 0 as *const xmlChar);
            } else {
                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
                              b"PEReference: %%%s; not found\n\x00" as
                                  *const u8 as *const std::os::raw::c_char, name,
                              0 as *const xmlChar);
            }
            (*ctxt).valid = 0 as std::os::raw::c_int
        }
        xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t,
                             0 as xmlEntityPtr, 0 as std::os::raw::c_int as size_t);
    } else if (*entity).etype as std::os::raw::c_uint !=
                  XML_INTERNAL_PARAMETER_ENTITY as std::os::raw::c_int as std::os::raw::c_uint
                  &&
                  (*entity).etype as std::os::raw::c_uint !=
                      XML_EXTERNAL_PARAMETER_ENTITY as std::os::raw::c_int as
                          std::os::raw::c_uint {
        xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
                      b"Internal: %%%s; is not a parameter entity\n\x00" as
                          *const u8 as *const std::os::raw::c_char, name,
                      0 as *const xmlChar);
    } else {
        let mut start: [xmlChar; 4] = [0; 4];
        let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
        if (*entity).etype as std::os::raw::c_uint ==
               XML_EXTERNAL_PARAMETER_ENTITY as std::os::raw::c_int as std::os::raw::c_uint &&
               (*ctxt).options & XML_PARSE_NOENT as std::os::raw::c_int ==
                   0 as std::os::raw::c_int &&
               (*ctxt).options & XML_PARSE_DTDVALID as std::os::raw::c_int ==
                   0 as std::os::raw::c_int &&
               (*ctxt).options & XML_PARSE_DTDLOAD as std::os::raw::c_int ==
                   0 as std::os::raw::c_int &&
               (*ctxt).options & XML_PARSE_DTDATTR as std::os::raw::c_int ==
                   0 as std::os::raw::c_int &&
               (*ctxt).replaceEntities == 0 as std::os::raw::c_int &&
               (*ctxt).validate == 0 as std::os::raw::c_int {
            return
        }
        input = xmlNewEntityInputStream(ctxt, entity);
        if xmlPushInput(ctxt, input) < 0 as std::os::raw::c_int {
            xmlFreeInputStream(input);
            return
        }
        if (*entity).etype as std::os::raw::c_uint ==
               XML_EXTERNAL_PARAMETER_ENTITY as std::os::raw::c_int as std::os::raw::c_uint {
            /*
	 * Internal checking in case the entity quest barfed
	 */
            /*
                 * Get the 4 first bytes and decode the charset
                 * if enc != XML_CHAR_ENCODING_NONE
                 * plug some encoding conversion routines.
                 * Note that, since we may have some non-UTF8
                 * encoding (like UTF16, bug 135229), the 'length'
                 * is not known, but we can calculate based upon
                 * the amount of data in the buffer.
                 */
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                return
            }
            if (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                   as std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
                start[0 as std::os::raw::c_int as usize] = *(*(*ctxt).input).cur;
                start[1 as std::os::raw::c_int as usize] =
                    *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
                start[2 as std::os::raw::c_int as usize] =
                    *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
                start[3 as std::os::raw::c_int as usize] =
                    *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
                enc =
                    xmlDetectCharEncoding(start.as_mut_ptr(),
                                          4 as std::os::raw::c_int);
                if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int
                   {
                    xmlSwitchEncoding(ctxt, enc);
                }
            }
            if *((*(*ctxt).input).cur as
                     *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '<' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == '?' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'x' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'm' as i32 &&
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == 'l' as i32 &&
                   (*(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                        0x9 as std::os::raw::c_int <=
                            *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int &&
                            *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as
                                                             isize) as
                                std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                        *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as
                                                         isize) as std::os::raw::c_int
                            == 0xd as std::os::raw::c_int) {
                xmlParseTextDecl(ctxt);
            }
        }
    }
    (*ctxt).hasPErefs = 1 as std::os::raw::c_int;
}
/* *
 * xmlLoadEntityContent:
 * @ctxt:  an XML parser context
 * @entity: an unloaded system entity
 *
 * Load the original content of the given system entity from the
 * ExternalID/SystemID given. This is to be used for Included in Literal
 * http://www.w3.org/TR/REC-xml/#inliteral processing of entities references
 *
 * Returns 0 in case of success and -1 in case of failure
 */
unsafe extern "C" fn xmlLoadEntityContent(mut ctxt: xmlParserCtxtPtr,
                                          mut entity: xmlEntityPtr)
 -> std::os::raw::c_int {
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: xmlBufferPtr = 0 as *mut xmlBuffer;
    let mut l: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_int = 0;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if ctxt.is_null() || entity.is_null() ||
           (*entity).etype as std::os::raw::c_uint !=
               XML_EXTERNAL_PARAMETER_ENTITY as std::os::raw::c_int as std::os::raw::c_uint &&
               (*entity).etype as std::os::raw::c_uint !=
                   XML_EXTERNAL_GENERAL_PARSED_ENTITY as std::os::raw::c_int as
                       std::os::raw::c_uint || !(*entity).content.is_null() {
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    b"xmlLoadEntityContent parameter error\x00" as *const u8
                        as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    if *__xmlParserDebugEntities() != 0 {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Reading %s entity content input\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char,
                                                                   (*entity).name);
    }
    buf = xmlBufferCreate();
    if buf.is_null() {
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    b"xmlLoadEntityContent parameter error\x00" as *const u8
                        as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    input = xmlNewEntityInputStream(ctxt, entity);
    if input.is_null() {
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    b"xmlLoadEntityContent input error\x00" as *const u8 as
                        *const std::os::raw::c_char);
        xmlBufferFree(buf);
        return -(1 as std::os::raw::c_int)
    }
    /*
     * Push the entity as the current input, read char by char
     * saving to the buffer until the end of the entity or an error
     */
    if xmlPushInput(ctxt, input) < 0 as std::os::raw::c_int {
        xmlBufferFree(buf);
        return -(1 as std::os::raw::c_int)
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    c = xmlCurrentChar(ctxt, &mut l);
    while (*ctxt).input == input &&
              (*(*ctxt).input).cur < (*(*ctxt).input).end &&
              (if c < 0x100 as std::os::raw::c_int {
                   (0x9 as std::os::raw::c_int <= c && c <= 0xa as std::os::raw::c_int ||
                        c == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= c)
                       as std::os::raw::c_int
               } else {
                   (0x100 as std::os::raw::c_int <= c && c <= 0xd7ff as std::os::raw::c_int ||
                        0xe000 as std::os::raw::c_int <= c &&
                            c <= 0xfffd as std::os::raw::c_int ||
                        0x10000 as std::os::raw::c_int <= c &&
                            c <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
               }) != 0 {
        xmlBufferAdd(buf, (*(*ctxt).input).cur, l);
        let fresh91 = count;
        count = count + 1;
        if fresh91 > 100 as std::os::raw::c_int {
            count = 0 as std::os::raw::c_int;
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                xmlBufferFree(buf);
                return -(1 as std::os::raw::c_int)
            }
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        c = xmlCurrentChar(ctxt, &mut l);
        if c == 0 as std::os::raw::c_int {
            count = 0 as std::os::raw::c_int;
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                xmlBufferFree(buf);
                return -(1 as std::os::raw::c_int)
            }
            c = xmlCurrentChar(ctxt, &mut l)
        }
    }
    if (*ctxt).input == input && (*(*ctxt).input).cur >= (*(*ctxt).input).end
       {
        xmlPopInput(ctxt);
    } else if if c < 0x100 as std::os::raw::c_int {
                  (0x9 as std::os::raw::c_int <= c && c <= 0xa as std::os::raw::c_int ||
                       c == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= c) as
                      std::os::raw::c_int
              } else {
                  (0x100 as std::os::raw::c_int <= c && c <= 0xd7ff as std::os::raw::c_int ||
                       0xe000 as std::os::raw::c_int <= c &&
                           c <= 0xfffd as std::os::raw::c_int ||
                       0x10000 as std::os::raw::c_int <= c &&
                           c <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
              } == 0 {
        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                          b"xmlLoadEntityContent: invalid char value %d\n\x00"
                              as *const u8 as *const std::os::raw::c_char, c);
        xmlBufferFree(buf);
        return -(1 as std::os::raw::c_int)
    }
    (*entity).content = (*buf).content;
    (*buf).content = 0 as *mut xmlChar;
    xmlBufferFree(buf);
    return 0 as std::os::raw::c_int;
}
/* DEPR void xmlParserHandleReference(xmlParserCtxtPtr ctxt); */
/* *
 * xmlParseStringPEReference:
 * @ctxt:  an XML parser context
 * @str:  a pointer to an index in the string
 *
 * parse PEReference declarations
 *
 * [69] PEReference ::= '%' Name ';'
 *
 * [ WFC: No Recursion ]
 * A parsed entity must not contain a recursive
 * reference to itself, either directly or indirectly.
 *
 * [ WFC: Entity Declared ]
 * In a document without any DTD, a document with only an internal DTD
 * subset which contains no parameter entity references, or a document
 * with "standalone='yes'", ...  ... The declaration of a parameter
 * entity must precede any reference to it...
 *
 * [ VC: Entity Declared ]
 * In a document with an external subset or external parameter entities
 * with "standalone='no'", ...  ... The declaration of a parameter entity
 * must precede any reference to it...
 *
 * [ WFC: In DTD ]
 * Parameter-entity references may only appear in the DTD.
 * NOTE: misleading but this is handled.
 *
 * Returns the string of the entity content.
 *         str is updated to the current value of the index
 */
unsafe extern "C" fn xmlParseStringPEReference(mut ctxt: xmlParserCtxtPtr,
                                               mut str: *mut *const xmlChar)
 -> xmlEntityPtr {
    let mut ptr: *const xmlChar = 0 as *const xmlChar;
    let mut cur: xmlChar = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut entity: xmlEntityPtr = 0 as xmlEntityPtr;
    if str.is_null() || (*str).is_null() { return 0 as xmlEntityPtr }
    ptr = *str;
    cur = *ptr;
    if cur as std::os::raw::c_int != '%' as i32 { return 0 as xmlEntityPtr }
    ptr = ptr.offset(1);
    name = xmlParseStringName(ctxt, &mut ptr);
    if name.is_null() {
        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                       b"xmlParseStringPEReference: no name\n\x00" as
                           *const u8 as *const std::os::raw::c_char);
        *str = ptr;
        return 0 as xmlEntityPtr
    }
    cur = *ptr;
    if cur as std::os::raw::c_int != ';' as i32 {
        xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING,
                    0 as *const std::os::raw::c_char);
        xmlFree.expect("non-null function pointer")(name as
                                                        *mut std::os::raw::c_void);
        *str = ptr;
        return 0 as xmlEntityPtr
    }
    ptr = ptr.offset(1);
    /*
     * Increate the number of entity references parsed
     */
    (*ctxt).nbentities = (*ctxt).nbentities.wrapping_add(1);
    /*
     * Request the entity from SAX
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).getParameterEntity.is_some() {
        entity =
            (*(*ctxt).sax).getParameterEntity.expect("non-null function pointer")((*ctxt).userData,
                                                                                  name)
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        xmlFree.expect("non-null function pointer")(name as
                                                        *mut std::os::raw::c_void);
        *str = ptr;
        return 0 as xmlEntityPtr
    }
    if entity.is_null() {
        /*
	 * [ WFC: Entity Declared ]
	 * In a document without any DTD, a document with only an
	 * internal DTD subset which contains no parameter entity
	 * references, or a document with "standalone='yes'", ...
	 * ... The declaration of a parameter entity must precede
	 * any reference to it...
	 */
        if (*ctxt).standalone == 1 as std::os::raw::c_int ||
               (*ctxt).hasExternalSubset == 0 as std::os::raw::c_int &&
                   (*ctxt).hasPErefs == 0 as std::os::raw::c_int {
            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
                              b"PEReference: %%%s; not found\n\x00" as
                                  *const u8 as *const std::os::raw::c_char, name);
        } else {
            /*
	     * [ VC: Entity Declared ]
	     * In a document with an external subset or external
	     * parameter entities with "standalone='no'", ...
	     * ... The declaration of a parameter entity must
	     * precede any reference to it...
	     */
            xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
                          b"PEReference: %%%s; not found\n\x00" as *const u8
                              as *const std::os::raw::c_char, name,
                          0 as *const xmlChar);
            (*ctxt).valid = 0 as std::os::raw::c_int
        }
        xmlParserEntityCheck(ctxt, 0 as std::os::raw::c_int as size_t,
                             0 as xmlEntityPtr, 0 as std::os::raw::c_int as size_t);
    } else if (*entity).etype as std::os::raw::c_uint !=
                  XML_INTERNAL_PARAMETER_ENTITY as std::os::raw::c_int as std::os::raw::c_uint
                  &&
                  (*entity).etype as std::os::raw::c_uint !=
                      XML_EXTERNAL_PARAMETER_ENTITY as std::os::raw::c_int as
                          std::os::raw::c_uint {
        xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
                      b"%%%s; is not a parameter entity\n\x00" as *const u8 as
                          *const std::os::raw::c_char, name, 0 as *const xmlChar);
    }
    (*ctxt).hasPErefs = 1 as std::os::raw::c_int;
    xmlFree.expect("non-null function pointer")(name as *mut std::os::raw::c_void);
    *str = ptr;
    return entity;
}
/*
	 * Internal checking in case the entity quest barfed
	 */
/* *
 * xmlParseDocTypeDecl:
 * @ctxt:  an XML parser context
 *
 * parse a DOCTYPE declaration
 *
 * [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S?
 *                      ('[' (markupdecl | PEReference | S)* ']' S?)? '>'
 *
 * [ VC: Root Element Type ]
 * The Name in the document type declaration must match the element
 * type of the root element.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseDocTypeDecl(mut ctxt: xmlParserCtxtPtr) {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    /*
     * We know that '<!DOCTYPE' has been detected.
     */
    (*ctxt).nbChars += 9 as std::os::raw::c_int as std::os::raw::c_long;
    (*(*ctxt).input).cur =
        (*(*ctxt).input).cur.offset(9 as std::os::raw::c_int as isize);
    (*(*ctxt).input).col += 9 as std::os::raw::c_int;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    xmlSkipBlankChars(ctxt);
    /*
     * Parse the DOCTYPE name.
     */
    name = xmlParseName(ctxt);
    if name.is_null() {
        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                       b"xmlParseDocTypeDecl : no DOCTYPE name !\n\x00" as
                           *const u8 as *const std::os::raw::c_char);
    }
    (*ctxt).intSubName = name;
    xmlSkipBlankChars(ctxt);
    /*
     * Check for SystemID and ExternalID
     */
    URI = xmlParseExternalID(ctxt, &mut ExternalID, 1 as std::os::raw::c_int);
    if !URI.is_null() || !ExternalID.is_null() {
        (*ctxt).hasExternalSubset = 1 as std::os::raw::c_int
    }
    (*ctxt).extSubURI = URI;
    (*ctxt).extSubSystem = ExternalID;
    xmlSkipBlankChars(ctxt);
    /*
     * Create and update the internal subset.
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).internalSubset.is_some() &&
           (*ctxt).disableSAX == 0 {
        (*(*ctxt).sax).internalSubset.expect("non-null function pointer")((*ctxt).userData,
                                                                          name,
                                                                          ExternalID,
                                                                          URI);
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    /*
     * Is there any internal subset declarations ?
     * they are handled separately in xmlParseInternalSubset()
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '[' as i32 { return }
    /*
     * We should be at the end of the DOCTYPE declaration.
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
        xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
    }
    xmlNextChar(ctxt);
}
/* *
 * xmlParseInternalSubset:
 * @ctxt:  an XML parser context
 *
 * parse the internal subset declaration
 *
 * [28 end] ('[' (markupdecl | PEReference | S)* ']' S?)? '>'
 */
unsafe extern "C" fn xmlParseInternalSubset(mut ctxt: xmlParserCtxtPtr) {
    /*
     * Is there any DTD definition ?
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '[' as i32 {
        let mut baseInputNr: std::os::raw::c_int = (*ctxt).inputNr;
        (*ctxt).instate = XML_PARSER_DTD;
        xmlNextChar(ctxt);
        /*
	 * Parse the succession of Markup declarations and
	 * PEReferences.
	 * Subsequence (markupdecl | PEReference | S)*
	 */
        while (*(*(*ctxt).input).cur as std::os::raw::c_int != ']' as i32 ||
                   (*ctxt).inputNr > baseInputNr) &&
                  (*ctxt).instate as std::os::raw::c_int !=
                      XML_PARSER_EOF as std::os::raw::c_int {
            let mut check: *const xmlChar = (*(*ctxt).input).cur;
            let mut cons: std::os::raw::c_uint =
                (*(*ctxt).input).consumed as std::os::raw::c_uint;
            xmlSkipBlankChars(ctxt);
            xmlParseMarkupDecl(ctxt);
            xmlParsePEReference(ctxt);
            if !((*(*ctxt).input).cur == check &&
                     cons as std::os::raw::c_ulong == (*(*ctxt).input).consumed) {
                continue ;
            }
            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                        b"xmlParseInternalSubset: error detected in Markup declaration\n\x00"
                            as *const u8 as *const std::os::raw::c_char);
            if !((*ctxt).inputNr > baseInputNr) { break ; }
            xmlPopInput(ctxt);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ']' as i32 {
            xmlNextChar(ctxt);
            xmlSkipBlankChars(ctxt);
        }
    }
    /*
     * We should be at the end of the DOCTYPE declaration.
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
        xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        return
    }
    xmlNextChar(ctxt);
}
/* *
 * xmlParseAttribute:
 * @ctxt:  an XML parser context
 * @value:  a xmlChar ** used to store the value of the attribute
 *
 * parse an attribute
 *
 * [41] Attribute ::= Name Eq AttValue
 *
 * [ WFC: No External Entity References ]
 * Attribute values cannot contain direct or indirect entity references
 * to external entities.
 *
 * [ WFC: No < in Attribute Values ]
 * The replacement text of any entity referred to directly or indirectly in
 * an attribute value (other than "&lt;") must not contain a <.
 *
 * [ VC: Attribute Value Type ]
 * The attribute must have been declared; the value must be of the type
 * declared for it.
 *
 * [25] Eq ::= S? '=' S?
 *
 * With namespace:
 *
 * [NS 11] Attribute ::= QName Eq AttValue
 *
 * Also the case QName == xmlns:??? is handled independently as a namespace
 * definition.
 *
 * Returns the attribute name, and the value in *value.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseAttribute(mut ctxt: xmlParserCtxtPtr,
                                           mut value: *mut *mut xmlChar)
 -> *const xmlChar {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    *value = 0 as *mut xmlChar;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    name = xmlParseName(ctxt);
    if name.is_null() {
        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                       b"error parsing attribute name\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
        return 0 as *const xmlChar
    }
    /*
     * read the value
     */
    xmlSkipBlankChars(ctxt);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '=' as i32 {
        xmlNextChar(ctxt);
        xmlSkipBlankChars(ctxt);
        val = xmlParseAttValue(ctxt);
        (*ctxt).instate = XML_PARSER_CONTENT
    } else {
        xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
                          b"Specification mandates value for attribute %s\n\x00"
                              as *const u8 as *const std::os::raw::c_char, name);
        return 0 as *const xmlChar
    }
    /*
     * Check that xml:lang conforms to the specification
     * No more registered as an error, just generate a warning now
     * since this was deprecated in XML second edition
     */
    if (*ctxt).pedantic != 0 &&
           xmlStrEqual(name,
                       b"xml:lang\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
        if xmlCheckLanguageID(val) == 0 {
            xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
                          b"Malformed value for xml:lang : %s\n\x00" as
                              *const u8 as *const std::os::raw::c_char, val,
                          0 as *const xmlChar);
        }
    }
    /*
     * Check that xml:space conforms to the specification
     */
    if xmlStrEqual(name,
                   b"xml:space\x00" as *const u8 as *const std::os::raw::c_char as
                       *mut xmlChar) != 0 {
        if xmlStrEqual(val,
                       b"default\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
            *(*ctxt).space = 0 as std::os::raw::c_int
        } else if xmlStrEqual(val,
                              b"preserve\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar) != 0 {
            *(*ctxt).space = 1 as std::os::raw::c_int
        } else {
            xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
                          b"Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n\x00"
                              as *const u8 as *const std::os::raw::c_char, val,
                          0 as *const xmlChar);
        }
    }
    *value = val;
    return name;
}
/* *
 * xmlParseStartTag:
 * @ctxt:  an XML parser context
 *
 * parse a start of tag either for rule element or
 * EmptyElement. In both case we don't parse the tag closing chars.
 *
 * [40] STag ::= '<' Name (S Attribute)* S? '>'
 *
 * [ WFC: Unique Att Spec ]
 * No attribute name may appear more than once in the same start-tag or
 * empty-element tag.
 *
 * [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'
 *
 * [ WFC: Unique Att Spec ]
 * No attribute name may appear more than once in the same start-tag or
 * empty-element tag.
 *
 * With namespace:
 *
 * [NS 8] STag ::= '<' QName (S Attribute)* S? '>'
 *
 * [NS 10] EmptyElement ::= '<' QName (S Attribute)* S? '/>'
 *
 * Returns the element name parsed
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseStartTag(mut ctxt: xmlParserCtxtPtr)
 -> *const xmlChar {
    let mut current_block: u64;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut attname: *const xmlChar = 0 as *const xmlChar;
    let mut attvalue: *mut xmlChar = 0 as *mut xmlChar;
    let mut atts: *mut *const xmlChar = (*ctxt).atts;
    let mut nbatts: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut maxatts: std::os::raw::c_int = (*ctxt).maxatts;
    let mut i: std::os::raw::c_int = 0;
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 {
        return 0 as *const xmlChar
    }
    (*(*ctxt).input).col += 1;
    (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1);
    (*ctxt).nbChars += 1;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    name = xmlParseName(ctxt);
    if name.is_null() {
        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                       b"xmlParseStartTag: invalid element name\n\x00" as
                           *const u8 as *const std::os::raw::c_char);
        return 0 as *const xmlChar
    }
    /*
     * Now parse the attributes, it ends up with the ending
     *
     * (S Attribute)* S?
     */
    xmlSkipBlankChars(ctxt);
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    while *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 &&
              (*(*(*ctxt).input).cur as std::os::raw::c_int != '/' as i32 ||
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int != '>' as i32) &&
              (0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int
                   ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int
                   ||
                   0x20 as std::os::raw::c_int <=
                       *(*(*ctxt).input).cur as std::os::raw::c_int) &&
              (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int
          {
        let mut q: *const xmlChar = (*(*ctxt).input).cur;
        let mut cons: std::os::raw::c_uint =
            (*(*ctxt).input).consumed as std::os::raw::c_uint;
        attname = xmlParseAttribute(ctxt, &mut attvalue);
        if !attname.is_null() && !attvalue.is_null() {
            /*
	     * [ WFC: Unique Att Spec ]
	     * No attribute name may appear more than once in the same
	     * start-tag or empty-element tag.
	     */
            i = 0 as std::os::raw::c_int;
            loop  {
                if !(i < nbatts) {
                    current_block = 4775909272756257391;
                    break ;
                }
                if xmlStrEqual(*atts.offset(i as isize), attname) != 0 {
                    xmlErrAttributeDup(ctxt, 0 as *const xmlChar, attname);
                    xmlFree.expect("non-null function pointer")(attvalue as
                                                                    *mut std::os::raw::c_void);
                    current_block = 17775676470731931083;
                    break ;
                } else { i += 2 as std::os::raw::c_int }
            }
            match current_block {
                17775676470731931083 => { }
                _ =>
                /*
	     * Add the pair to atts
	     */
                {
                    if atts.is_null() {
                        maxatts =
                            22 as
                                std::os::raw::c_int; /* allow for 10 attrs by default */
                        atts =
                            xmlMalloc.expect("non-null function pointer")((maxatts
                                                                               as
                                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlChar>()
                                                                                                               as
                                                                                                               std::os::raw::c_ulong))
                                as *mut *const xmlChar;
                        if atts.is_null() {
                            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                            if !attvalue.is_null() {
                                xmlFree.expect("non-null function pointer")(attvalue
                                                                                as
                                                                                *mut std::os::raw::c_void);
                            }
                            current_block = 17775676470731931083;
                        } else {
                            (*ctxt).atts = atts;
                            (*ctxt).maxatts = maxatts;
                            current_block = 16738040538446813684;
                        }
                    } else if nbatts + 4 as std::os::raw::c_int > maxatts {
                        let mut n: *mut *const xmlChar =
                            0 as *mut *const xmlChar;
                        maxatts *= 2 as std::os::raw::c_int;
                        n =
                            xmlRealloc.expect("non-null function pointer")(atts
                                                                               as
                                                                               *mut std::os::raw::c_void,
                                                                           (maxatts
                                                                                as
                                                                                std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*const xmlChar>()
                                                                                                                as
                                                                                                                std::os::raw::c_ulong))
                                as *mut *const xmlChar;
                        if n.is_null() {
                            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                            if !attvalue.is_null() {
                                xmlFree.expect("non-null function pointer")(attvalue
                                                                                as
                                                                                *mut std::os::raw::c_void);
                            }
                            current_block = 17775676470731931083;
                        } else {
                            atts = n;
                            (*ctxt).atts = atts;
                            (*ctxt).maxatts = maxatts;
                            current_block = 16738040538446813684;
                        }
                    } else { current_block = 16738040538446813684; }
                    match current_block {
                        17775676470731931083 => { }
                        _ => {
                            let fresh92 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh93 =
                                *atts.offset(fresh92 as isize);
                            *fresh93 = attname;
                            let fresh94 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh95 =
                                *atts.offset(fresh94 as isize);
                            *fresh95 = attvalue;
                            let ref mut fresh96 =
                                *atts.offset(nbatts as isize);
                            *fresh96 = 0 as *const xmlChar;
                            let ref mut fresh97 =
                                *atts.offset((nbatts + 1 as std::os::raw::c_int) as
                                                 isize);
                            *fresh97 = 0 as *const xmlChar
                        }
                    }
                }
            }
        } else if !attvalue.is_null() {
            xmlFree.expect("non-null function pointer")(attvalue as
                                                            *mut std::os::raw::c_void);
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 ||
               *(*(*ctxt).input).cur as std::os::raw::c_int == '/' as i32 &&
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == '>' as i32 {
            break ;
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"attributes construct error\n\x00" as *const u8 as
                               *const std::os::raw::c_char);
        }
        if cons as std::os::raw::c_ulong == (*(*ctxt).input).consumed &&
               q == (*(*ctxt).input).cur && attname.is_null() &&
               attvalue.is_null() {
            xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
                           b"xmlParseStartTag: problem parsing attributes\n\x00"
                               as *const u8 as *const std::os::raw::c_char);
            break ;
        } else {
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                       as std::os::raw::c_long >
                       (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long
                   &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) <
                       (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long
               {
                xmlSHRINK(ctxt);
            }
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
        }
    }
    /*
     * SAX: Start of Element !
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startElement.is_some() &&
           (*ctxt).disableSAX == 0 {
        if nbatts > 0 as std::os::raw::c_int {
            (*(*ctxt).sax).startElement.expect("non-null function pointer")((*ctxt).userData,
                                                                            name,
                                                                            atts);
        } else {
            (*(*ctxt).sax).startElement.expect("non-null function pointer")((*ctxt).userData,
                                                                            name,
                                                                            0
                                                                                as
                                                                                *mut *const xmlChar);
        }
    }
    if !atts.is_null() {
        /* Free only the content strings */
        i = 1 as std::os::raw::c_int;
        while i < nbatts {
            if !(*atts.offset(i as isize)).is_null() {
                xmlFree.expect("non-null function pointer")(*atts.offset(i as
                                                                             isize)
                                                                as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            i += 2 as std::os::raw::c_int
        }
    }
    return name;
}
/* *
 * xmlParseEndTag1:
 * @ctxt:  an XML parser context
 * @line:  line of the start tag
 * @nsNr:  number of namespaces on the start tag
 *
 * parse an end of tag
 *
 * [42] ETag ::= '</' Name S? '>'
 *
 * With namespace
 *
 * [NS 9] ETag ::= '</' QName S? '>'
 */
unsafe extern "C" fn xmlParseEndTag1(mut ctxt: xmlParserCtxtPtr,
                                     mut line: std::os::raw::c_int) {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 ||
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '/' as i32 {
        xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,
                       b"xmlParseEndTag: \'</\' not found\n\x00" as *const u8
                           as *const std::os::raw::c_char);
        return
    }
    (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
    (*(*ctxt).input).cur =
        (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
    (*(*ctxt).input).col += 2 as std::os::raw::c_int;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    name = xmlParseNameAndCompare(ctxt, (*ctxt).name);
    /*
     * We should definitely be at the ending "S? '>'" part
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    xmlSkipBlankChars(ctxt);
    if !(0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
             *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
             *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
             0x20 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int) ||
           *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
        xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, 0 as *const std::os::raw::c_char);
    } else {
        (*(*ctxt).input).col += 1;
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1);
        (*ctxt).nbChars += 1;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
    }
    /*
     * [ WFC: Element Type Match ]
     * The Name in an element's end-tag must match the element type in the
     * start-tag.
     *
     */
    if name != 1 as std::os::raw::c_int as *mut xmlChar {
        if name.is_null() {
            name =
                b"unparseable\x00" as *const u8 as *const std::os::raw::c_char as
                    *mut xmlChar
        }
        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
                                b"Opening and ending tag mismatch: %s line %d and %s\n\x00"
                                    as *const u8 as *const std::os::raw::c_char,
                                (*ctxt).name, line, name);
    }
    /*
     * SAX: End of Tag
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElement.is_some() &&
           (*ctxt).disableSAX == 0 {
        (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                      (*ctxt).name);
    }
    namePop(ctxt);
    spacePop(ctxt);
}
/* *
 * xmlParseEndTag:
 * @ctxt:  an XML parser context
 *
 * parse an end of tag
 *
 * [42] ETag ::= '</' Name S? '>'
 *
 * With namespace
 *
 * [NS 9] ETag ::= '</' QName S? '>'
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseEndTag(mut ctxt: xmlParserCtxtPtr) {
    xmlParseEndTag1(ctxt, 0 as std::os::raw::c_int);
}
/* LIBXML_SAX1_ENABLED */
/* ***********************************************************************
 *									*
 *		      SAX 2 specific operations				*
 *									*
 ************************************************************************/
/*
 * xmlGetNamespace:
 * @ctxt:  an XML parser context
 * @prefix:  the prefix to lookup
 *
 * Lookup the namespace name for the @prefix (which ca be NULL)
 * The prefix must come from the @ctxt->dict dictionary
 *
 * Returns the namespace name or NULL if not bound
 */
unsafe extern "C" fn xmlGetNamespace(mut ctxt: xmlParserCtxtPtr,
                                     mut prefix: *const xmlChar)
 -> *const xmlChar {
    let mut i: std::os::raw::c_int = 0;
    if prefix == (*ctxt).str_xml { return (*ctxt).str_xml_ns }
    i = (*ctxt).nsNr - 2 as std::os::raw::c_int;
    while i >= 0 as std::os::raw::c_int {
        if *(*ctxt).nsTab.offset(i as isize) == prefix {
            if prefix.is_null() &&
                   **(*ctxt).nsTab.offset((i + 1 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int == 0 as std::os::raw::c_int {
                return 0 as *const xmlChar
            }
            return *(*ctxt).nsTab.offset((i + 1 as std::os::raw::c_int) as isize)
        }
        i -= 2 as std::os::raw::c_int
    }
    return 0 as *const xmlChar;
}
/* *
 * xmlParseQName:
 * @ctxt:  an XML parser context
 * @prefix:  pointer to store the prefix part
 *
 * parse an XML Namespace QName
 *
 * [6]  QName  ::= (Prefix ':')? LocalPart
 * [7]  Prefix  ::= NCName
 * [8]  LocalPart  ::= NCName
 *
 * Returns the Name parsed or NULL
 */
unsafe extern "C" fn xmlParseQName(mut ctxt: xmlParserCtxtPtr,
                                   mut prefix: *mut *const xmlChar)
 -> *const xmlChar {
    let mut l: *const xmlChar = 0 as *const xmlChar;
    let mut p: *const xmlChar = 0 as *const xmlChar;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    l = xmlParseNCName(ctxt);
    if l.is_null() {
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ':' as i32 {
            l = xmlParseName(ctxt);
            if !l.is_null() {
                xmlNsErr(ctxt, XML_NS_ERR_QNAME,
                         b"Failed to parse QName \'%s\'\n\x00" as *const u8 as
                             *const std::os::raw::c_char, l, 0 as *const xmlChar,
                         0 as *const xmlChar);
                *prefix = 0 as *const xmlChar;
                return l
            }
        }
        return 0 as *const xmlChar
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == ':' as i32 {
        xmlNextChar(ctxt);
        p = l;
        l = xmlParseNCName(ctxt);
        if l.is_null() {
            let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
            xmlNsErr(ctxt, XML_NS_ERR_QNAME,
                     b"Failed to parse QName \'%s:\'\n\x00" as *const u8 as
                         *const std::os::raw::c_char, p, 0 as *const xmlChar,
                     0 as *const xmlChar);
            l = xmlParseNmtoken(ctxt);
            if l.is_null() {
                tmp =
                    xmlBuildQName(b"\x00" as *const u8 as *const std::os::raw::c_char
                                      as *mut xmlChar, p, 0 as *mut xmlChar,
                                  0 as std::os::raw::c_int)
            } else {
                tmp =
                    xmlBuildQName(l, p, 0 as *mut xmlChar, 0 as std::os::raw::c_int);
                xmlFree.expect("non-null function pointer")(l as
                                                                *mut std::os::raw::c_char
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            p = xmlDictLookup((*ctxt).dict, tmp, -(1 as std::os::raw::c_int));
            if !tmp.is_null() {
                xmlFree.expect("non-null function pointer")(tmp as
                                                                *mut std::os::raw::c_void);
            }
            *prefix = 0 as *const xmlChar;
            return p
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == ':' as i32 {
            let mut tmp_0: *mut xmlChar = 0 as *mut xmlChar;
            xmlNsErr(ctxt, XML_NS_ERR_QNAME,
                     b"Failed to parse QName \'%s:%s:\'\n\x00" as *const u8 as
                         *const std::os::raw::c_char, p, l, 0 as *const xmlChar);
            xmlNextChar(ctxt);
            tmp_0 = xmlParseName(ctxt) as *mut xmlChar;
            if !tmp_0.is_null() {
                tmp_0 =
                    xmlBuildQName(tmp_0, l, 0 as *mut xmlChar,
                                  0 as std::os::raw::c_int);
                l = xmlDictLookup((*ctxt).dict, tmp_0, -(1 as std::os::raw::c_int));
                if !tmp_0.is_null() {
                    xmlFree.expect("non-null function pointer")(tmp_0 as
                                                                    *mut std::os::raw::c_void);
                }
                *prefix = p;
                return l
            }
            tmp_0 =
                xmlBuildQName(b"\x00" as *const u8 as *const std::os::raw::c_char as
                                  *mut xmlChar, l, 0 as *mut xmlChar,
                              0 as std::os::raw::c_int);
            l = xmlDictLookup((*ctxt).dict, tmp_0, -(1 as std::os::raw::c_int));
            if !tmp_0.is_null() {
                xmlFree.expect("non-null function pointer")(tmp_0 as
                                                                *mut std::os::raw::c_void);
            }
            *prefix = p;
            return l
        }
        *prefix = p
    } else { *prefix = 0 as *const xmlChar }
    return l;
}
/* *
 * xmlParseQNameAndCompare:
 * @ctxt:  an XML parser context
 * @name:  the localname
 * @prefix:  the prefix, if any.
 *
 * parse an XML name and compares for match
 * (specialized for endtag parsing)
 *
 * Returns NULL for an illegal name, (xmlChar*) 1 for success
 * and the name for mismatch
 */
unsafe extern "C" fn xmlParseQNameAndCompare(mut ctxt: xmlParserCtxtPtr,
                                             mut name: *const xmlChar,
                                             mut prefix: *const xmlChar)
 -> *const xmlChar {
    let mut cmp: *const xmlChar = 0 as *const xmlChar;
    let mut in_0: *const xmlChar = 0 as *const xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    let mut prefix2: *const xmlChar = 0 as *const xmlChar;
    if prefix.is_null() { return xmlParseNameAndCompare(ctxt, name) }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    in_0 = (*(*ctxt).input).cur;
    cmp = prefix;
    while *in_0 as std::os::raw::c_int != 0 as std::os::raw::c_int &&
              *in_0 as std::os::raw::c_int == *cmp as std::os::raw::c_int {
        in_0 = in_0.offset(1);
        cmp = cmp.offset(1)
    }
    if *cmp as std::os::raw::c_int == 0 as std::os::raw::c_int &&
           *in_0 as std::os::raw::c_int == ':' as i32 {
        in_0 = in_0.offset(1);
        cmp = name;
        while *in_0 as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                  *in_0 as std::os::raw::c_int == *cmp as std::os::raw::c_int {
            in_0 = in_0.offset(1);
            cmp = cmp.offset(1)
        }
        if *cmp as std::os::raw::c_int == 0 as std::os::raw::c_int &&
               (*in_0 as std::os::raw::c_int == '>' as i32 ||
                    (*in_0 as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                         0x9 as std::os::raw::c_int <= *in_0 as std::os::raw::c_int &&
                             *in_0 as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                         *in_0 as std::os::raw::c_int == 0xd as std::os::raw::c_int)) {
            /* success */
            (*(*ctxt).input).cur = in_0;
            return 1 as std::os::raw::c_int as *const xmlChar
        }
    }
    /*
     * all strings coms from the dictionary, equality can be done directly
     */
    ret = xmlParseQName(ctxt, &mut prefix2);
    if ret == name && prefix == prefix2 {
        return 1 as std::os::raw::c_int as *const xmlChar
    }
    return ret;
}
/* *
 * xmlParseAttValueInternal:
 * @ctxt:  an XML parser context
 * @len:  attribute len result
 * @alloc:  whether the attribute was reallocated as a new string
 * @normalize:  if 1 then further non-CDATA normalization must be done
 *
 * parse a value for an attribute.
 * NOTE: if no normalization is needed, the routine will return pointers
 *       directly from the data buffer.
 *
 * 3.3.3 Attribute-Value Normalization:
 * Before the value of an attribute is passed to the application or
 * checked for validity, the XML processor must normalize it as follows:
 * - a character reference is processed by appending the referenced
 *   character to the attribute value
 * - an entity reference is processed by recursively processing the
 *   replacement text of the entity
 * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 *   appending #x20 to the normalized value, except that only a single
 *   #x20 is appended for a "#xD#xA" sequence that is part of an external
 *   parsed entity or the literal entity value of an internal parsed entity
 * - other characters are processed by appending them to the normalized value
 * If the declared value is not CDATA, then the XML processor must further
 * process the normalized attribute value by discarding any leading and
 * trailing space (#x20) characters, and by replacing sequences of space
 * (#x20) characters by a single space (#x20) character.
 * All attributes for which no declaration has been read should be treated
 * by a non-validating parser as if declared CDATA.
 *
 * Returns the AttValue parsed or NULL. The value has to be freed by the
 *     caller if it was copied, this can be detected by val[*len] == 0.
 */
unsafe extern "C" fn xmlParseAttValueInternal(mut ctxt: xmlParserCtxtPtr,
                                              mut len: *mut std::os::raw::c_int,
                                              mut alloc: *mut std::os::raw::c_int,
                                              mut normalize: std::os::raw::c_int)
 -> *mut xmlChar {
    let mut current_block: u64;
    let mut limit: xmlChar = 0 as std::os::raw::c_int as xmlChar;
    let mut in_0: *const xmlChar = 0 as *const xmlChar;
    let mut start: *const xmlChar = 0 as *const xmlChar;
    let mut end: *const xmlChar = 0 as *const xmlChar;
    let mut last: *const xmlChar = 0 as *const xmlChar;
    let mut ret: *mut xmlChar = 0 as *mut xmlChar;
    let mut line: std::os::raw::c_int = 0;
    let mut col: std::os::raw::c_int = 0;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    in_0 = (*(*ctxt).input).cur as *mut xmlChar;
    line = (*(*ctxt).input).line;
    col = (*(*ctxt).input).col;
    if *in_0 as std::os::raw::c_int != '\"' as i32 &&
           *in_0 as std::os::raw::c_int != '\'' as i32 {
        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED,
                    0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    (*ctxt).instate = XML_PARSER_ATTRIBUTE_VALUE;
    /*
     * try to handle in this routine the most common case where no
     * allocation of a new string is required and where content is
     * pure ASCII.
     */
    let fresh98 = in_0;
    in_0 = in_0.offset(1);
    limit = *fresh98;
    col += 1;
    end = (*(*ctxt).input).end;
    start = in_0;
    if in_0 >= end {
        let mut oldbase: *const xmlChar = (*(*ctxt).input).base;
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        if oldbase != (*(*ctxt).input).base {
            let mut delta: std::os::raw::c_long =
                (*(*ctxt).input).base.offset_from(oldbase) as
                    std::os::raw::c_long;
            start = start.offset(delta as isize);
            in_0 = in_0.offset(delta as isize)
        }
        end = (*(*ctxt).input).end
    }
    if normalize != 0 {
        /*
	 * Skip any leading spaces
	 */
        while in_0 < end && *in_0 as std::os::raw::c_int != limit as std::os::raw::c_int &&
                  (*in_0 as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                       *in_0 as std::os::raw::c_int == 0x9 as std::os::raw::c_int ||
                       *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int ||
                       *in_0 as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
            if *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int {
                line += 1;
                col = 1 as std::os::raw::c_int
            } else { col += 1 }
            in_0 = in_0.offset(1);
            start = in_0;
            if in_0 >= end {
                let mut oldbase_0: *const xmlChar = (*(*ctxt).input).base;
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    return 0 as *mut xmlChar
                }
                if oldbase_0 != (*(*ctxt).input).base {
                    let mut delta_0: std::os::raw::c_long =
                        (*(*ctxt).input).base.offset_from(oldbase_0)
                            as std::os::raw::c_long;
                    start = start.offset(delta_0 as isize);
                    in_0 = in_0.offset(delta_0 as isize)
                }
                end = (*(*ctxt).input).end;
                if in_0.offset_from(start) as std::os::raw::c_long >
                       10000000 as std::os::raw::c_int as std::os::raw::c_long &&
                       (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                   b"AttValue length too long\n\x00" as
                                       *const u8 as *const std::os::raw::c_char);
                    return 0 as *mut xmlChar
                }
            }
        }
        while in_0 < end && *in_0 as std::os::raw::c_int != limit as std::os::raw::c_int &&
                  *in_0 as std::os::raw::c_int >= 0x20 as std::os::raw::c_int &&
                  *in_0 as std::os::raw::c_int <= 0x7f as std::os::raw::c_int &&
                  *in_0 as std::os::raw::c_int != '&' as i32 &&
                  *in_0 as std::os::raw::c_int != '<' as i32 {
            col += 1;
            let fresh99 = in_0;
            in_0 = in_0.offset(1);
            if *fresh99 as std::os::raw::c_int == 0x20 as std::os::raw::c_int &&
                   *in_0 as std::os::raw::c_int == 0x20 as std::os::raw::c_int {
                break ;
            }
            if in_0 >= end {
                let mut oldbase_1: *const xmlChar = (*(*ctxt).input).base;
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    return 0 as *mut xmlChar
                }
                if oldbase_1 != (*(*ctxt).input).base {
                    let mut delta_1: std::os::raw::c_long =
                        (*(*ctxt).input).base.offset_from(oldbase_1)
                            as std::os::raw::c_long;
                    start = start.offset(delta_1 as isize);
                    in_0 = in_0.offset(delta_1 as isize)
                }
                end = (*(*ctxt).input).end;
                if in_0.offset_from(start) as std::os::raw::c_long >
                       10000000 as std::os::raw::c_int as std::os::raw::c_long &&
                       (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                   b"AttValue length too long\n\x00" as
                                       *const u8 as *const std::os::raw::c_char);
                    return 0 as *mut xmlChar
                }
            }
        }
        last = in_0;
        /*
	 * skip the trailing blanks
	 */
        while *last.offset(-(1 as std::os::raw::c_int) as isize) as std::os::raw::c_int ==
                  0x20 as std::os::raw::c_int && last > start {
            last = last.offset(-1)
        }
        while in_0 < end && *in_0 as std::os::raw::c_int != limit as std::os::raw::c_int &&
                  (*in_0 as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                       *in_0 as std::os::raw::c_int == 0x9 as std::os::raw::c_int ||
                       *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int ||
                       *in_0 as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
            if *in_0 as std::os::raw::c_int == 0xa as std::os::raw::c_int {
                line += 1;
                col = 1 as std::os::raw::c_int
            } else { col += 1 }
            in_0 = in_0.offset(1);
            if in_0 >= end {
                let mut oldbase_2: *const xmlChar = (*(*ctxt).input).base;
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    return 0 as *mut xmlChar
                }
                if oldbase_2 != (*(*ctxt).input).base {
                    let mut delta_2: std::os::raw::c_long =
                        (*(*ctxt).input).base.offset_from(oldbase_2)
                            as std::os::raw::c_long;
                    start = start.offset(delta_2 as isize);
                    in_0 = in_0.offset(delta_2 as isize);
                    last = last.offset(delta_2 as isize)
                }
                end = (*(*ctxt).input).end;
                if in_0.offset_from(start) as std::os::raw::c_long >
                       10000000 as std::os::raw::c_int as std::os::raw::c_long &&
                       (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                   b"AttValue length too long\n\x00" as
                                       *const u8 as *const std::os::raw::c_char);
                    return 0 as *mut xmlChar
                }
            }
        }
        if in_0.offset_from(start) as std::os::raw::c_long >
               10000000 as std::os::raw::c_int as std::os::raw::c_long &&
               (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                           b"AttValue length too long\n\x00" as *const u8 as
                               *const std::os::raw::c_char);
            return 0 as *mut xmlChar
        }
        if *in_0 as std::os::raw::c_int != limit as std::os::raw::c_int {
            current_block = 13519220108271260009;
        } else { current_block = 6407515180622463684; }
    } else {
        while in_0 < end && *in_0 as std::os::raw::c_int != limit as std::os::raw::c_int &&
                  *in_0 as std::os::raw::c_int >= 0x20 as std::os::raw::c_int &&
                  *in_0 as std::os::raw::c_int <= 0x7f as std::os::raw::c_int &&
                  *in_0 as std::os::raw::c_int != '&' as i32 &&
                  *in_0 as std::os::raw::c_int != '<' as i32 {
            in_0 = in_0.offset(1);
            col += 1;
            if in_0 >= end {
                let mut oldbase_3: *const xmlChar = (*(*ctxt).input).base;
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                if (*ctxt).instate as std::os::raw::c_int ==
                       XML_PARSER_EOF as std::os::raw::c_int {
                    return 0 as *mut xmlChar
                }
                if oldbase_3 != (*(*ctxt).input).base {
                    let mut delta_3: std::os::raw::c_long =
                        (*(*ctxt).input).base.offset_from(oldbase_3)
                            as std::os::raw::c_long;
                    start = start.offset(delta_3 as isize);
                    in_0 = in_0.offset(delta_3 as isize)
                }
                end = (*(*ctxt).input).end;
                if in_0.offset_from(start) as std::os::raw::c_long >
                       10000000 as std::os::raw::c_int as std::os::raw::c_long &&
                       (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                           0 as std::os::raw::c_int {
                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                   b"AttValue length too long\n\x00" as
                                       *const u8 as *const std::os::raw::c_char);
                    return 0 as *mut xmlChar
                }
            }
        }
        last = in_0;
        if in_0.offset_from(start) as std::os::raw::c_long >
               10000000 as std::os::raw::c_int as std::os::raw::c_long &&
               (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                           b"AttValue length too long\n\x00" as *const u8 as
                               *const std::os::raw::c_char);
            return 0 as *mut xmlChar
        }
        if *in_0 as std::os::raw::c_int != limit as std::os::raw::c_int {
            current_block = 13519220108271260009;
        } else { current_block = 6407515180622463684; }
    }
    match current_block {
        13519220108271260009 => {
            if !alloc.is_null() { *alloc = 1 as std::os::raw::c_int }
            return xmlParseAttValueComplex(ctxt, len, normalize)
        }
        _ => {
            in_0 = in_0.offset(1);
            col += 1;
            if !len.is_null() {
                *len =
                    last.offset_from(start) as std::os::raw::c_long as
                        std::os::raw::c_int;
                ret = start as *mut xmlChar
            } else {
                if !alloc.is_null() { *alloc = 1 as std::os::raw::c_int }
                ret =
                    xmlStrndup(start,
                               last.offset_from(start) as
                                   std::os::raw::c_long as std::os::raw::c_int)
            }
            (*(*ctxt).input).cur = in_0;
            (*(*ctxt).input).line = line;
            (*(*ctxt).input).col = col;
            if !alloc.is_null() { *alloc = 0 as std::os::raw::c_int }
            return ret
        }
    };
}
/* *
 * xmlParseAttribute2:
 * @ctxt:  an XML parser context
 * @pref:  the element prefix
 * @elem:  the element name
 * @prefix:  a xmlChar ** used to store the value of the attribute prefix
 * @value:  a xmlChar ** used to store the value of the attribute
 * @len:  an int * to save the length of the attribute
 * @alloc:  an int * to indicate if the attribute was allocated
 *
 * parse an attribute in the new SAX2 framework.
 *
 * Returns the attribute name, and the value in *value, .
 */
unsafe extern "C" fn xmlParseAttribute2(mut ctxt: xmlParserCtxtPtr,
                                        mut pref: *const xmlChar,
                                        mut elem: *const xmlChar,
                                        mut prefix: *mut *const xmlChar,
                                        mut value: *mut *mut xmlChar,
                                        mut len: *mut std::os::raw::c_int,
                                        mut alloc: *mut std::os::raw::c_int)
 -> *const xmlChar {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut internal_val: *mut xmlChar = 0 as *mut xmlChar;
    let mut normalize: std::os::raw::c_int = 0 as std::os::raw::c_int;
    *value = 0 as *mut xmlChar;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    name = xmlParseQName(ctxt, prefix);
    if name.is_null() {
        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                       b"error parsing attribute name\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
        return 0 as *const xmlChar
    }
    /*
     * get the type if needed
     */
    if !(*ctxt).attsSpecial.is_null() {
        let mut type_0: std::os::raw::c_int = 0;
        type_0 =
            xmlHashQLookup2((*ctxt).attsSpecial, pref, elem, *prefix, name) as
                ptrdiff_t as std::os::raw::c_int;
        if type_0 != 0 as std::os::raw::c_int { normalize = 1 as std::os::raw::c_int }
    }
    /*
     * read the value
     */
    xmlSkipBlankChars(ctxt);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '=' as i32 {
        xmlNextChar(ctxt);
        xmlSkipBlankChars(ctxt);
        val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
        if normalize != 0 {
            /*
	     * Sometimes a second normalisation pass for spaces is needed
	     * but that only happens if charrefs or entities refernces
	     * have been used in the attribute value, i.e. the attribute
	     * value have been extracted in an allocated string already.
	     */
            if *alloc != 0 {
                let mut val2: *const xmlChar = 0 as *const xmlChar;
                val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
                if !val2.is_null() && val2 != val {
                    xmlFree.expect("non-null function pointer")(val as
                                                                    *mut std::os::raw::c_void);
                    val = val2 as *mut xmlChar
                }
            }
        }
        (*ctxt).instate = XML_PARSER_CONTENT
    } else {
        xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
                          b"Specification mandates value for attribute %s\n\x00"
                              as *const u8 as *const std::os::raw::c_char, name);
        return 0 as *const xmlChar
    }
    if *prefix == (*ctxt).str_xml {
        /*
         * Check that xml:lang conforms to the specification
         * No more registered as an error, just generate a warning now
         * since this was deprecated in XML second edition
         */
        if (*ctxt).pedantic != 0 &&
               xmlStrEqual(name,
                           b"lang\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) != 0 {
            internal_val = xmlStrndup(val, *len);
            if xmlCheckLanguageID(internal_val) == 0 {
                xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
                              b"Malformed value for xml:lang : %s\n\x00" as
                                  *const u8 as *const std::os::raw::c_char,
                              internal_val, 0 as *const xmlChar);
            }
        }
        /*
         * Check that xml:space conforms to the specification
         */
        if xmlStrEqual(name,
                       b"space\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 {
            internal_val = xmlStrndup(val, *len);
            if xmlStrEqual(internal_val,
                           b"default\x00" as *const u8 as *const std::os::raw::c_char
                               as *mut xmlChar) != 0 {
                *(*ctxt).space = 0 as std::os::raw::c_int
            } else if xmlStrEqual(internal_val,
                                  b"preserve\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) !=
                          0 {
                *(*ctxt).space = 1 as std::os::raw::c_int
            } else {
                xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
                              b"Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n\x00"
                                  as *const u8 as *const std::os::raw::c_char,
                              internal_val, 0 as *const xmlChar);
            }
        }
        if !internal_val.is_null() {
            xmlFree.expect("non-null function pointer")(internal_val as
                                                            *mut std::os::raw::c_void);
        }
    }
    *value = val;
    return name;
}
/* *
 * xmlParseStartTag2:
 * @ctxt:  an XML parser context
 *
 * parse a start of tag either for rule element or
 * EmptyElement. In both case we don't parse the tag closing chars.
 * This routine is called when running SAX2 parsing
 *
 * [40] STag ::= '<' Name (S Attribute)* S? '>'
 *
 * [ WFC: Unique Att Spec ]
 * No attribute name may appear more than once in the same start-tag or
 * empty-element tag.
 *
 * [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'
 *
 * [ WFC: Unique Att Spec ]
 * No attribute name may appear more than once in the same start-tag or
 * empty-element tag.
 *
 * With namespace:
 *
 * [NS 8] STag ::= '<' QName (S Attribute)* S? '>'
 *
 * [NS 10] EmptyElement ::= '<' QName (S Attribute)* S? '/>'
 *
 * Returns the element name parsed
 */
unsafe extern "C" fn xmlParseStartTag2(mut ctxt: xmlParserCtxtPtr,
                                       mut pref: *mut *const xmlChar,
                                       mut URI: *mut *const xmlChar,
                                       mut tlen: *mut std::os::raw::c_int)
 -> *const xmlChar {
    let mut current_block: u64;
    let mut localname: *const xmlChar = 0 as *const xmlChar;
    let mut prefix: *const xmlChar = 0 as *const xmlChar;
    let mut attname: *const xmlChar = 0 as *const xmlChar;
    let mut aprefix: *const xmlChar = 0 as *const xmlChar;
    let mut nsname: *const xmlChar = 0 as *const xmlChar;
    let mut attvalue: *mut xmlChar = 0 as *mut xmlChar;
    let mut atts: *mut *const xmlChar = (*ctxt).atts;
    let mut maxatts: std::os::raw::c_int = (*ctxt).maxatts;
    let mut nratts: std::os::raw::c_int = 0;
    let mut nbatts: std::os::raw::c_int = 0;
    let mut nbdef: std::os::raw::c_int = 0;
    let mut inputid: std::os::raw::c_int = 0;
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut nbNs: std::os::raw::c_int = 0;
    let mut attval: std::os::raw::c_int = 0;
    let mut cur: std::os::raw::c_ulong = 0;
    let mut nsNr: std::os::raw::c_int = (*ctxt).nsNr;
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 {
        return 0 as *const xmlChar
    }
    (*(*ctxt).input).col += 1;
    (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1);
    (*ctxt).nbChars += 1;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    /*
     * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that
     *       point since the attribute values may be stored as pointers to
     *       the buffer and calling SHRINK would destroy them !
     *       The Shrinking is only possible once the full set of attribute
     *       callbacks have been done.
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long >
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) <
               (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
        xmlSHRINK(ctxt);
    }
    cur =
        (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
            std::os::raw::c_long as std::os::raw::c_ulong;
    inputid = (*(*ctxt).input).id;
    nbatts = 0 as std::os::raw::c_int;
    nratts = 0 as std::os::raw::c_int;
    nbdef = 0 as std::os::raw::c_int;
    nbNs = 0 as std::os::raw::c_int;
    attval = 0 as std::os::raw::c_int;
    /* Forget any namespaces added during an earlier parse of this element. */
    (*ctxt).nsNr = nsNr;
    localname = xmlParseQName(ctxt, &mut prefix);
    if localname.is_null() {
        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                       b"StartTag: invalid element name\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
        return 0 as *const xmlChar
    }
    *tlen =
        ((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
             std::os::raw::c_long as std::os::raw::c_ulong).wrapping_sub(cur) as std::os::raw::c_int;
    /*
     * Now parse the attributes, it ends up with the ending
     *
     * (S Attribute)* S?
     */
    xmlSkipBlankChars(ctxt);
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    while *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 &&
              (*(*(*ctxt).input).cur as std::os::raw::c_int != '/' as i32 ||
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int != '>' as i32) &&
              (0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                   *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int
                   ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int
                   ||
                   0x20 as std::os::raw::c_int <=
                       *(*(*ctxt).input).cur as std::os::raw::c_int) &&
              (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int
          {
        let mut q: *const xmlChar = (*(*ctxt).input).cur;
        let mut cons: std::os::raw::c_uint =
            (*(*ctxt).input).consumed as std::os::raw::c_uint;
        let mut len: std::os::raw::c_int = -(1 as std::os::raw::c_int);
        let mut alloc: std::os::raw::c_int = 0 as std::os::raw::c_int;
        attname =
            xmlParseAttribute2(ctxt, prefix, localname, &mut aprefix,
                               &mut attvalue, &mut len, &mut alloc);
        if !(attname.is_null() || attvalue.is_null()) {
            if len < 0 as std::os::raw::c_int { len = xmlStrlen(attvalue) }
            if attname == (*ctxt).str_xmlns && aprefix.is_null() {
                let mut URL: *const xmlChar =
                    xmlDictLookup((*ctxt).dict, attvalue, len);
                let mut uri: xmlURIPtr = 0 as *mut xmlURI;
                if URL.is_null() {
                    xmlErrMemory(ctxt,
                                 b"dictionary allocation failure\x00" as
                                     *const u8 as *const std::os::raw::c_char);
                    if !attvalue.is_null() && alloc != 0 as std::os::raw::c_int {
                        xmlFree.expect("non-null function pointer")(attvalue
                                                                        as
                                                                        *mut std::os::raw::c_void);
                    }
                    return 0 as *const xmlChar
                }
                if *URL as std::os::raw::c_int != 0 as std::os::raw::c_int {
                    uri = xmlParseURI(URL as *const std::os::raw::c_char);
                    if uri.is_null() {
                        xmlNsErr(ctxt, XML_WAR_NS_URI,
                                 b"xmlns: \'%s\' is not a valid URI\n\x00" as
                                     *const u8 as *const std::os::raw::c_char, URL,
                                 0 as *const xmlChar, 0 as *const xmlChar);
                    } else {
                        if (*uri).scheme.is_null() {
                            xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
                                      b"xmlns: URI %s is not absolute\n\x00"
                                          as *const u8 as *const std::os::raw::c_char,
                                      URL, 0 as *const xmlChar,
                                      0 as *const xmlChar);
                        }
                        xmlFreeURI(uri);
                    }
                    if URL == (*ctxt).str_xml_ns {
                        if attname != (*ctxt).str_xml {
                            xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                                     b"xml namespace URI cannot be the default namespace\n\x00"
                                         as *const u8 as *const std::os::raw::c_char,
                                     0 as *const xmlChar, 0 as *const xmlChar,
                                     0 as *const xmlChar);
                        }
                        current_block = 15832256105180430443;
                    } else if len == 29 as std::os::raw::c_int &&
                                  xmlStrEqual(URL,
                                              b"http://www.w3.org/2000/xmlns/\x00"
                                                  as *const u8 as
                                                  *const std::os::raw::c_char as
                                                  *mut xmlChar) != 0 {
                        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                                 b"reuse of the xmlns namespace name is forbidden\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar,
                                 0 as *const xmlChar);
                        current_block = 15832256105180430443;
                    } else { current_block = 4888910987971495881; }
                } else { current_block = 4888910987971495881; }
                match current_block {
                    15832256105180430443 => { }
                    _ => {
                        /*
             * check that it's not a defined namespace
             */
                        j = 1 as std::os::raw::c_int;
                        while j <= nbNs {
                            if (*(*ctxt).nsTab.offset(((*ctxt).nsNr -
                                                           2 as std::os::raw::c_int *
                                                               j) as
                                                          isize)).is_null() {
                                break ;
                            }
                            j += 1
                        }
                        if j <= nbNs {
                            xmlErrAttributeDup(ctxt, 0 as *const xmlChar,
                                               attname);
                        } else if nsPush(ctxt, 0 as *const xmlChar, URL) >
                                      0 as std::os::raw::c_int {
                            nbNs += 1
                        }
                    }
                }
            } else if aprefix == (*ctxt).str_xmlns {
                let mut URL_0: *const xmlChar =
                    xmlDictLookup((*ctxt).dict, attvalue, len);
                let mut uri_0: xmlURIPtr = 0 as *mut xmlURI;
                if attname == (*ctxt).str_xml {
                    if URL_0 != (*ctxt).str_xml_ns {
                        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                                 b"xml namespace prefix mapped to wrong URI\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar,
                                 0 as *const xmlChar);
                    }
                } else if URL_0 == (*ctxt).str_xml_ns {
                    if attname != (*ctxt).str_xml {
                        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                                 b"xml namespace URI mapped to wrong prefix\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 0 as *const xmlChar, 0 as *const xmlChar,
                                 0 as *const xmlChar);
                    }
                } else if attname == (*ctxt).str_xmlns {
                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                             b"redefinition of the xmlns prefix is forbidden\n\x00"
                                 as *const u8 as *const std::os::raw::c_char,
                             0 as *const xmlChar, 0 as *const xmlChar,
                             0 as *const xmlChar);
                } else if len == 29 as std::os::raw::c_int &&
                              xmlStrEqual(URL_0,
                                          b"http://www.w3.org/2000/xmlns/\x00"
                                              as *const u8 as
                                              *const std::os::raw::c_char as
                                              *mut xmlChar) != 0 {
                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                             b"reuse of the xmlns namespace name is forbidden\n\x00"
                                 as *const u8 as *const std::os::raw::c_char,
                             0 as *const xmlChar, 0 as *const xmlChar,
                             0 as *const xmlChar);
                } else if URL_0.is_null() ||
                              *URL_0.offset(0 as std::os::raw::c_int as isize) as
                                  std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                             b"xmlns:%s: Empty XML namespace is not allowed\n\x00"
                                 as *const u8 as *const std::os::raw::c_char, attname,
                             0 as *const xmlChar, 0 as *const xmlChar);
                } else {
                    uri_0 = xmlParseURI(URL_0 as *const std::os::raw::c_char);
                    if uri_0.is_null() {
                        xmlNsErr(ctxt, XML_WAR_NS_URI,
                                 b"xmlns:%s: \'%s\' is not a valid URI\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 attname, URL_0, 0 as *const xmlChar);
                    } else {
                        if (*ctxt).pedantic != 0 && (*uri_0).scheme.is_null()
                           {
                            xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
                                      b"xmlns:%s: URI %s is not absolute\n\x00"
                                          as *const u8 as *const std::os::raw::c_char,
                                      attname, URL_0, 0 as *const xmlChar);
                        }
                        xmlFreeURI(uri_0);
                    }
                    /*
             * check that it's not a defined namespace
             */
                    j = 1 as std::os::raw::c_int;
                    while j <= nbNs {
                        if *(*ctxt).nsTab.offset(((*ctxt).nsNr -
                                                      2 as std::os::raw::c_int * j) as
                                                     isize) == attname {
                            break ;
                        }
                        j += 1
                    }
                    if j <= nbNs {
                        xmlErrAttributeDup(ctxt, aprefix, attname);
                    } else if nsPush(ctxt, attname, URL_0) > 0 as std::os::raw::c_int
                     {
                        nbNs += 1
                    }
                }
            } else {
                /*
             * Add the pair to atts
             */
                if atts.is_null() || nbatts + 5 as std::os::raw::c_int > maxatts {
                    if xmlCtxtGrowAttrs(ctxt, nbatts + 5 as std::os::raw::c_int) <
                           0 as std::os::raw::c_int {
                        current_block = 15832256105180430443;
                    } else {
                        maxatts = (*ctxt).maxatts;
                        atts = (*ctxt).atts;
                        current_block = 10863493864285401582;
                    }
                } else { current_block = 10863493864285401582; }
                match current_block {
                    15832256105180430443 => { }
                    _ => {
                        let fresh100 = nratts;
                        nratts = nratts + 1;
                        *(*ctxt).attallocs.offset(fresh100 as isize) = alloc;
                        let fresh101 = nbatts;
                        nbatts = nbatts + 1;
                        let ref mut fresh102 =
                            *atts.offset(fresh101 as isize);
                        *fresh102 = attname;
                        let fresh103 = nbatts;
                        nbatts = nbatts + 1;
                        let ref mut fresh104 =
                            *atts.offset(fresh103 as isize);
                        *fresh104 = aprefix;
                        /*
             * The namespace URI field is used temporarily to point at the
             * base of the current input buffer for non-alloced attributes.
             * When the input buffer is reallocated, all the pointers become
             * invalid, but they can be reconstructed later.
             */
                        if alloc != 0 {
                            let fresh105 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh106 =
                                *atts.offset(fresh105 as isize);
                            *fresh106 = 0 as *const xmlChar
                        } else {
                            let fresh107 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh108 =
                                *atts.offset(fresh107 as isize);
                            *fresh108 = (*(*ctxt).input).base
                        }
                        let fresh109 = nbatts;
                        nbatts = nbatts + 1;
                        let ref mut fresh110 =
                            *atts.offset(fresh109 as isize);
                        *fresh110 = attvalue;
                        attvalue = attvalue.offset(len as isize);
                        let fresh111 = nbatts;
                        nbatts = nbatts + 1;
                        let ref mut fresh112 =
                            *atts.offset(fresh111 as isize);
                        *fresh112 = attvalue;
                        /*
             * tag if some deallocation is needed
             */
                        if alloc != 0 as std::os::raw::c_int {
                            attval = 1 as std::os::raw::c_int
                        }
                        attvalue = 0 as *mut xmlChar
                    }
                }
                /* moved into atts */
            }
        }
        /*
                 * Do not keep a namespace definition node
                 */
        if !attvalue.is_null() && alloc != 0 as std::os::raw::c_int {
            xmlFree.expect("non-null function pointer")(attvalue as
                                                            *mut std::os::raw::c_void);
            attvalue = 0 as *mut xmlChar
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
            break ;
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 ||
               *(*(*ctxt).input).cur as std::os::raw::c_int == '/' as i32 &&
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == '>' as i32 {
            break ;
        }
        if xmlSkipBlankChars(ctxt) == 0 as std::os::raw::c_int {
            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                           b"attributes construct error\n\x00" as *const u8 as
                               *const std::os::raw::c_char);
            break ;
        } else if cons as std::os::raw::c_ulong == (*(*ctxt).input).consumed &&
                      q == (*(*ctxt).input).cur && attname.is_null() &&
                      attvalue.is_null() {
            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                        b"xmlParseStartTag: problem parsing attributes\n\x00"
                            as *const u8 as *const std::os::raw::c_char);
            break ;
        } else if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                      ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                           as std::os::raw::c_long) <
                          250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
    }
    if (*(*ctxt).input).id != inputid {
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    b"Unexpected change of input\n\x00" as *const u8 as
                        *const std::os::raw::c_char);
        localname = 0 as *const xmlChar
    } else {
        /* Reconstruct attribute value pointers. */
        i = 0 as std::os::raw::c_int;
        j = 0 as std::os::raw::c_int;
        while j < nratts {
            if !(*atts.offset((i + 2 as std::os::raw::c_int) as isize)).is_null() {
                /*
             * Arithmetic on dangling pointers is technically undefined
             * behavior, but well...
             */
                let mut offset: ptrdiff_t =
                    (*(*ctxt).input).base.offset_from(*atts.offset((i
                                                                                 +
                                                                                 2
                                                                                     as
                                                                                     std::os::raw::c_int)
                                                                                as
                                                                                isize))
                        as std::os::raw::c_long; /* Reset repurposed namespace URI */
                let ref mut fresh113 =
                    *atts.offset((i + 2 as std::os::raw::c_int) as isize); /* value */
                *fresh113 = 0 as *const xmlChar;
                let ref mut fresh114 =
                    *atts.offset((i + 3 as std::os::raw::c_int) as isize);
                *fresh114 = (*fresh114).offset(offset as isize);
                let ref mut fresh115 =
                    *atts.offset((i + 4 as std::os::raw::c_int) as isize);
                *fresh115 = (*fresh115).offset(offset as isize)
            }
            i += 5 as std::os::raw::c_int;
            j += 1
        }
        /*
     * The attributes defaulting
     */
        if !(*ctxt).attsDefault.is_null() {
            let mut defaults: xmlDefAttrsPtr = 0 as *mut xmlDefAttrs;
            defaults =
                xmlHashLookup2((*ctxt).attsDefault, localname, prefix) as
                    xmlDefAttrsPtr;
            if !defaults.is_null() {
                i = 0 as std::os::raw::c_int;
                while i < (*defaults).nbAttrs {
                    attname =
                        *(*defaults).values.as_mut_ptr().offset((5 as
                                                                     std::os::raw::c_int
                                                                     * i) as
                                                                    isize);
                    aprefix =
                        *(*defaults).values.as_mut_ptr().offset((5 as
                                                                     std::os::raw::c_int
                                                                     * i +
                                                                     1 as
                                                                         std::os::raw::c_int)
                                                                    as isize);
                    /*
		 * special work for namespaces defaulted defs
		 */
                    if attname == (*ctxt).str_xmlns && aprefix.is_null() {
                        /*
		     * check that it's not a defined namespace
		     */
                        j = 1 as std::os::raw::c_int;
                        while j <= nbNs {
                            if (*(*ctxt).nsTab.offset(((*ctxt).nsNr -
                                                           2 as std::os::raw::c_int *
                                                               j) as
                                                          isize)).is_null() {
                                break ;
                            }
                            j += 1
                        }
                        if !(j <= nbNs) {
                            nsname =
                                xmlGetNamespace(ctxt, 0 as *const xmlChar);
                            if nsname !=
                                   *(*defaults).values.as_mut_ptr().offset((5
                                                                                as
                                                                                std::os::raw::c_int
                                                                                *
                                                                                i
                                                                                +
                                                                                2
                                                                                    as
                                                                                    std::os::raw::c_int)
                                                                               as
                                                                               isize)
                               {
                                if nsPush(ctxt, 0 as *const xmlChar,
                                          *(*defaults).values.as_mut_ptr().offset((5
                                                                                       as
                                                                                       std::os::raw::c_int
                                                                                       *
                                                                                       i
                                                                                       +
                                                                                       2
                                                                                           as
                                                                                           std::os::raw::c_int)
                                                                                      as
                                                                                      isize))
                                       > 0 as std::os::raw::c_int {
                                    nbNs += 1
                                }
                            }
                        }
                    } else if aprefix == (*ctxt).str_xmlns {
                        /*
		     * check that it's not a defined namespace
		     */
                        j = 1 as std::os::raw::c_int;
                        while j <= nbNs {
                            if *(*ctxt).nsTab.offset(((*ctxt).nsNr -
                                                          2 as std::os::raw::c_int *
                                                              j) as isize) ==
                                   attname {
                                break ;
                            }
                            j += 1
                        }
                        if !(j <= nbNs) {
                            nsname = xmlGetNamespace(ctxt, attname);
                            if nsname !=
                                   *(*defaults).values.as_mut_ptr().offset(2
                                                                               as
                                                                               std::os::raw::c_int
                                                                               as
                                                                               isize)
                               {
                                if nsPush(ctxt, attname,
                                          *(*defaults).values.as_mut_ptr().offset((5
                                                                                       as
                                                                                       std::os::raw::c_int
                                                                                       *
                                                                                       i
                                                                                       +
                                                                                       2
                                                                                           as
                                                                                           std::os::raw::c_int)
                                                                                      as
                                                                                      isize))
                                       > 0 as std::os::raw::c_int {
                                    nbNs += 1
                                }
                            }
                        }
                    } else {
                        /*
		     * check that it's not a defined attribute
		     */
                        j = 0 as std::os::raw::c_int;
                        while j < nbatts {
                            if attname == *atts.offset(j as isize) &&
                                   aprefix ==
                                       *atts.offset((j + 1 as std::os::raw::c_int) as
                                                        isize) {
                                break ;
                            }
                            j += 5 as std::os::raw::c_int
                        }
                        if !(j < nbatts) {
                            if atts.is_null() ||
                                   nbatts + 5 as std::os::raw::c_int > maxatts {
                                if xmlCtxtGrowAttrs(ctxt,
                                                    nbatts + 5 as std::os::raw::c_int)
                                       < 0 as std::os::raw::c_int {
                                    return 0 as *const xmlChar
                                }
                                maxatts = (*ctxt).maxatts;
                                atts = (*ctxt).atts
                            }
                            let fresh116 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh117 =
                                *atts.offset(fresh116 as isize);
                            *fresh117 = attname;
                            let fresh118 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh119 =
                                *atts.offset(fresh118 as isize);
                            *fresh119 = aprefix;
                            if aprefix.is_null() {
                                let fresh120 = nbatts;
                                nbatts = nbatts + 1;
                                let ref mut fresh121 =
                                    *atts.offset(fresh120 as isize);
                                *fresh121 = 0 as *const xmlChar
                            } else {
                                let fresh122 = nbatts;
                                nbatts = nbatts + 1;
                                let ref mut fresh123 =
                                    *atts.offset(fresh122 as isize);
                                *fresh123 = xmlGetNamespace(ctxt, aprefix)
                            }
                            let fresh124 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh125 =
                                *atts.offset(fresh124 as isize);
                            *fresh125 =
                                *(*defaults).values.as_mut_ptr().offset((5 as
                                                                             std::os::raw::c_int
                                                                             *
                                                                             i
                                                                             +
                                                                             2
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                            as
                                                                            isize);
                            let fresh126 = nbatts;
                            nbatts = nbatts + 1;
                            let ref mut fresh127 =
                                *atts.offset(fresh126 as isize);
                            *fresh127 =
                                *(*defaults).values.as_mut_ptr().offset((5 as
                                                                             std::os::raw::c_int
                                                                             *
                                                                             i
                                                                             +
                                                                             3
                                                                                 as
                                                                                 std::os::raw::c_int)
                                                                            as
                                                                            isize);
                            if (*ctxt).standalone == 1 as std::os::raw::c_int &&
                                   !(*(*defaults).values.as_mut_ptr().offset((5
                                                                                  as
                                                                                  std::os::raw::c_int
                                                                                  *
                                                                                  i
                                                                                  +
                                                                                  4
                                                                                      as
                                                                                      std::os::raw::c_int)
                                                                                 as
                                                                                 isize)).is_null()
                               {
                                xmlValidityError(ctxt,
                                                 XML_DTD_STANDALONE_DEFAULTED,
                                                 b"standalone: attribute %s on %s defaulted from external subset\n\x00"
                                                     as *const u8 as
                                                     *const std::os::raw::c_char,
                                                 attname, localname);
                            }
                            nbdef += 1
                        }
                    }
                    i += 1
                }
            }
        }
        /*
     * The attributes checkings
     */
        i = 0 as std::os::raw::c_int;
        while i < nbatts {
            /*
	* The default namespace does not apply to attribute names.
	*/
            if !(*atts.offset((i + 1 as std::os::raw::c_int) as isize)).is_null() {
                nsname =
                    xmlGetNamespace(ctxt,
                                    *atts.offset((i + 1 as std::os::raw::c_int) as
                                                     isize));
                if nsname.is_null() {
                    xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
                             b"Namespace prefix %s for %s on %s is not defined\n\x00"
                                 as *const u8 as *const std::os::raw::c_char,
                             *atts.offset((i + 1 as std::os::raw::c_int) as isize),
                             *atts.offset(i as isize), localname);
                }
                let ref mut fresh128 =
                    *atts.offset((i + 2 as std::os::raw::c_int) as isize);
                *fresh128 = nsname
            } else { nsname = 0 as *const xmlChar }
            /*
	 * [ WFC: Unique Att Spec ]
	 * No attribute name may appear more than once in the same
	 * start-tag or empty-element tag.
	 * As extended by the Namespace in XML REC.
	 */
            j = 0 as std::os::raw::c_int;
            while j < i {
                if *atts.offset(i as isize) == *atts.offset(j as isize) {
                    if *atts.offset((i + 1 as std::os::raw::c_int) as isize) ==
                           *atts.offset((j + 1 as std::os::raw::c_int) as isize) {
                        xmlErrAttributeDup(ctxt,
                                           *atts.offset((i + 1 as std::os::raw::c_int)
                                                            as isize),
                                           *atts.offset(i as isize));
                        break ;
                    } else if !nsname.is_null() &&
                                  *atts.offset((j + 2 as std::os::raw::c_int) as
                                                   isize) == nsname {
                        xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
                                 b"Namespaced Attribute %s in \'%s\' redefined\n\x00"
                                     as *const u8 as *const std::os::raw::c_char,
                                 *atts.offset(i as isize), nsname,
                                 0 as *const xmlChar);
                        break ;
                    }
                }
                j += 5 as std::os::raw::c_int
            }
            i += 5 as std::os::raw::c_int
        }
        nsname = xmlGetNamespace(ctxt, prefix);
        if !prefix.is_null() && nsname.is_null() {
            xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
                     b"Namespace prefix %s on %s is not defined\n\x00" as
                         *const u8 as *const std::os::raw::c_char, prefix, localname,
                     0 as *const xmlChar);
        }
        *pref = prefix;
        *URI = nsname;
        /*
     * SAX: Start of Element !
     */
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startElementNs.is_some()
               && (*ctxt).disableSAX == 0 {
            if nbNs > 0 as std::os::raw::c_int {
                (*(*ctxt).sax).startElementNs.expect("non-null function pointer")((*ctxt).userData,
                                                                                  localname,
                                                                                  prefix,
                                                                                  nsname,
                                                                                  nbNs,
                                                                                  &mut *(*ctxt).nsTab.offset(((*ctxt).nsNr
                                                                                                                  -
                                                                                                                  2
                                                                                                                      as
                                                                                                                      std::os::raw::c_int
                                                                                                                      *
                                                                                                                      nbNs)
                                                                                                                 as
                                                                                                                 isize),
                                                                                  nbatts
                                                                                      /
                                                                                      5
                                                                                          as
                                                                                          std::os::raw::c_int,
                                                                                  nbdef,
                                                                                  atts);
            } else {
                (*(*ctxt).sax).startElementNs.expect("non-null function pointer")((*ctxt).userData,
                                                                                  localname,
                                                                                  prefix,
                                                                                  nsname,
                                                                                  0
                                                                                      as
                                                                                      std::os::raw::c_int,
                                                                                  0
                                                                                      as
                                                                                      *mut *const xmlChar,
                                                                                  nbatts
                                                                                      /
                                                                                      5
                                                                                          as
                                                                                          std::os::raw::c_int,
                                                                                  nbdef,
                                                                                  atts);
            }
        }
    }
    /*
     * Free up attribute allocated strings if needed
     */
    if attval != 0 as std::os::raw::c_int {
        i = 3 as std::os::raw::c_int;
        j = 0 as std::os::raw::c_int;
        while j < nratts {
            if *(*ctxt).attallocs.offset(j as isize) != 0 as std::os::raw::c_int &&
                   !(*atts.offset(i as isize)).is_null() {
                xmlFree.expect("non-null function pointer")(*atts.offset(i as
                                                                             isize)
                                                                as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            i += 5 as std::os::raw::c_int;
            j += 1
        }
    }
    return localname;
}
/* *
 * xmlParseEndTag2:
 * @ctxt:  an XML parser context
 * @line:  line of the start tag
 * @nsNr:  number of namespaces on the start tag
 *
 * parse an end of tag
 *
 * [42] ETag ::= '</' Name S? '>'
 *
 * With namespace
 *
 * [NS 9] ETag ::= '</' QName S? '>'
 */
unsafe extern "C" fn xmlParseEndTag2(mut ctxt: xmlParserCtxtPtr,
                                     mut prefix: *const xmlChar,
                                     mut URI: *const xmlChar,
                                     mut line: std::os::raw::c_int,
                                     mut nsNr: std::os::raw::c_int,
                                     mut tlen: std::os::raw::c_int) {
    let mut current_block: u64;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut curLength: size_t = 0;
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 ||
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int != '/' as i32 {
        xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, 0 as *const std::os::raw::c_char);
        return
    }
    (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
    (*(*ctxt).input).cur =
        (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
    (*(*ctxt).input).col += 2 as std::os::raw::c_int;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    curLength =
        (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
            std::os::raw::c_long as size_t;
    if tlen > 0 as std::os::raw::c_int && curLength >= tlen as size_t &&
           xmlStrncmp((*(*ctxt).input).cur, (*ctxt).name, tlen) ==
               0 as std::os::raw::c_int {
        if curLength >= (tlen + 1 as std::os::raw::c_int) as size_t &&
               *(*(*ctxt).input).cur.offset(tlen as isize) as std::os::raw::c_int ==
                   '>' as i32 {
            (*(*ctxt).input).cur =
                (*(*ctxt).input).cur.offset((tlen + 1 as std::os::raw::c_int) as
                                                isize);
            (*(*ctxt).input).col += tlen + 1 as std::os::raw::c_int;
            current_block = 9823798601130020030;
        } else {
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(tlen as isize);
            (*(*ctxt).input).col += tlen;
            name = 1 as std::os::raw::c_int as *mut xmlChar;
            current_block = 11307063007268554308;
        }
    } else {
        if prefix.is_null() {
            name = xmlParseNameAndCompare(ctxt, (*ctxt).name)
        } else { name = xmlParseQNameAndCompare(ctxt, (*ctxt).name, prefix) }
        current_block = 11307063007268554308;
    }
    match current_block {
        11307063007268554308 => {
            /*
     * We should definitely be at the ending "S? '>'" part
     */
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                return
            }
            xmlSkipBlankChars(ctxt);
            if !(0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                     *(*(*ctxt).input).cur as std::os::raw::c_int <=
                         0xa as std::os::raw::c_int ||
                     *(*(*ctxt).input).cur as std::os::raw::c_int ==
                         0xd as std::os::raw::c_int ||
                     0x20 as std::os::raw::c_int <=
                         *(*(*ctxt).input).cur as std::os::raw::c_int) ||
                   *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
                xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED,
                            0 as *const std::os::raw::c_char);
            } else {
                (*(*ctxt).input).col += 1;
                (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1);
                (*ctxt).nbChars += 1;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
            }
            /*
     * [ WFC: Element Type Match ]
     * The Name in an element's end-tag must match the element type in the
     * start-tag.
     *
     */
            if name != 1 as std::os::raw::c_int as *mut xmlChar {
                if name.is_null() {
                    name =
                        b"unparseable\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut xmlChar
                }
                if line == 0 as std::os::raw::c_int && !(*ctxt).node.is_null() {
                    line = (*(*ctxt).node).line as std::os::raw::c_int
                }
                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
                                        b"Opening and ending tag mismatch: %s line %d and %s\n\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char, (*ctxt).name,
                                        line, name);
            }
        }
        _ => { }
    }
    /*
     * SAX: End of Tag
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElementNs.is_some() &&
           (*ctxt).disableSAX == 0 {
        (*(*ctxt).sax).endElementNs.expect("non-null function pointer")((*ctxt).userData,
                                                                        (*ctxt).name,
                                                                        prefix,
                                                                        URI);
    }
    spacePop(ctxt);
    if nsNr != 0 as std::os::raw::c_int { nsPop(ctxt, nsNr); };
}
/* LIBXML_SAX1_ENABLED */
/* *
 * xmlParseCDSect:
 * @ctxt:  an XML parser context
 *
 * Parse escaped pure raw content.
 *
 * [18] CDSect ::= CDStart CData CDEnd
 *
 * [19] CDStart ::= '<![CDATA['
 *
 * [20] Data ::= (Char* - (Char* ']]>' Char*))
 *
 * [21] CDEnd ::= ']]>'
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseCDSect(mut ctxt: xmlParserCtxtPtr) {
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut size: std::os::raw::c_int = 100 as std::os::raw::c_int;
    let mut r: std::os::raw::c_int = 0;
    let mut rl: std::os::raw::c_int = 0;
    let mut s: std::os::raw::c_int = 0;
    let mut sl: std::os::raw::c_int = 0;
    let mut cur: std::os::raw::c_int = 0;
    let mut l: std::os::raw::c_int = 0;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    /* Check 2.6.0 was NXT(0) not RAW */
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '!' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '[' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'C' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'D' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'A' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(8 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '[' as i32 {
        (*ctxt).nbChars += 9 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(9 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 9 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
    } else { return }
    (*ctxt).instate = XML_PARSER_CDATA_SECTION;
    r = xmlCurrentChar(ctxt, &mut rl);
    if if r < 0x100 as std::os::raw::c_int {
           (0x9 as std::os::raw::c_int <= r && r <= 0xa as std::os::raw::c_int ||
                r == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= r) as
               std::os::raw::c_int
       } else {
           (0x100 as std::os::raw::c_int <= r && r <= 0xd7ff as std::os::raw::c_int ||
                0xe000 as std::os::raw::c_int <= r && r <= 0xfffd as std::os::raw::c_int ||
                0x10000 as std::os::raw::c_int <= r && r <= 0x10ffff as std::os::raw::c_int)
               as std::os::raw::c_int
       } == 0 {
        xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        (*ctxt).instate = XML_PARSER_CONTENT;
        return
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
        (*(*ctxt).input).line += 1;
        (*(*ctxt).input).col = 1 as std::os::raw::c_int
    } else { (*(*ctxt).input).col += 1 }
    (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(rl as isize);
    s = xmlCurrentChar(ctxt, &mut sl);
    if if s < 0x100 as std::os::raw::c_int {
           (0x9 as std::os::raw::c_int <= s && s <= 0xa as std::os::raw::c_int ||
                s == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= s) as
               std::os::raw::c_int
       } else {
           (0x100 as std::os::raw::c_int <= s && s <= 0xd7ff as std::os::raw::c_int ||
                0xe000 as std::os::raw::c_int <= s && s <= 0xfffd as std::os::raw::c_int ||
                0x10000 as std::os::raw::c_int <= s && s <= 0x10ffff as std::os::raw::c_int)
               as std::os::raw::c_int
       } == 0 {
        xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        (*ctxt).instate = XML_PARSER_CONTENT;
        return
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
        (*(*ctxt).input).line += 1;
        (*(*ctxt).input).col = 1 as std::os::raw::c_int
    } else { (*(*ctxt).input).col += 1 }
    (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(sl as isize);
    cur = xmlCurrentChar(ctxt, &mut l);
    buf =
        xmlMallocAtomic.expect("non-null function pointer")((size as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if buf.is_null() { xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char); return }
    while (if cur < 0x100 as std::os::raw::c_int {
               (0x9 as std::os::raw::c_int <= cur && cur <= 0xa as std::os::raw::c_int ||
                    cur == 0xd as std::os::raw::c_int || 0x20 as std::os::raw::c_int <= cur)
                   as std::os::raw::c_int
           } else {
               (0x100 as std::os::raw::c_int <= cur && cur <= 0xd7ff as std::os::raw::c_int ||
                    0xe000 as std::os::raw::c_int <= cur &&
                        cur <= 0xfffd as std::os::raw::c_int ||
                    0x10000 as std::os::raw::c_int <= cur &&
                        cur <= 0x10ffff as std::os::raw::c_int) as std::os::raw::c_int
           }) != 0 &&
              (r != ']' as i32 || s != ']' as i32 || cur != '>' as i32) {
        if len + 5 as std::os::raw::c_int >= size {
            let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
            if size > 10000000 as std::os::raw::c_int &&
                   (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                       0 as std::os::raw::c_int {
                xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
                                  b"CData section too big found\x00" as
                                      *const u8 as *const std::os::raw::c_char,
                                  0 as *const xmlChar);
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                return
            }
            tmp =
                xmlRealloc.expect("non-null function pointer")(buf as
                                                                   *mut std::os::raw::c_void,
                                                               ((size *
                                                                     2 as
                                                                         std::os::raw::c_int)
                                                                    as
                                                                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                    as
                                                                                                    std::os::raw::c_ulong))
                    as *mut xmlChar;
            if tmp.is_null() {
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                return
            }
            buf = tmp;
            size *= 2 as std::os::raw::c_int
        }
        if rl == 1 as std::os::raw::c_int {
            let fresh129 = len;
            len = len + 1;
            *buf.offset(fresh129 as isize) = r as xmlChar
        } else {
            len += xmlCopyCharMultiByte(&mut *buf.offset(len as isize), r)
        }
        r = s;
        rl = sl;
        s = cur;
        sl = l;
        count += 1;
        if count > 50 as std::os::raw::c_int {
            if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                   ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                        as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long
               {
                xmlGROW(ctxt);
            }
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                return
            }
            count = 0 as std::os::raw::c_int
        }
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
            (*(*ctxt).input).line += 1;
            (*(*ctxt).input).col = 1 as std::os::raw::c_int
        } else { (*(*ctxt).input).col += 1 }
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
        cur = xmlCurrentChar(ctxt, &mut l)
    }
    *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
    (*ctxt).instate = XML_PARSER_CONTENT;
    if cur != '>' as i32 {
        xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
                          b"CData section not finished\n%.50s\n\x00" as
                              *const u8 as *const std::os::raw::c_char, buf);
        xmlFree.expect("non-null function pointer")(buf as *mut std::os::raw::c_void);
        return
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '\n' as i32 {
        (*(*ctxt).input).line += 1;
        (*(*ctxt).input).col = 1 as std::os::raw::c_int
    } else { (*(*ctxt).input).col += 1 }
    (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(l as isize);
    /*
     * OK the buffer is to be consumed as cdata.
     */
    if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 {
        if (*(*ctxt).sax).cdataBlock.is_some() {
            (*(*ctxt).sax).cdataBlock.expect("non-null function pointer")((*ctxt).userData,
                                                                          buf,
                                                                          len);
        } else if (*(*ctxt).sax).characters.is_some() {
            (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                          buf,
                                                                          len);
        }
    }
    xmlFree.expect("non-null function pointer")(buf as *mut std::os::raw::c_void);
}
/* *
 * xmlParseContent:
 * @ctxt:  an XML parser context
 *
 * Parse a content:
 *
 * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseContent(mut ctxt: xmlParserCtxtPtr) {
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    while *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int &&
              (*(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 ||
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int != '/' as i32) &&
              (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int
          {
        let mut test: *const xmlChar = (*(*ctxt).input).cur;
        let mut cons: std::os::raw::c_uint =
            (*(*ctxt).input).consumed as std::os::raw::c_uint;
        let mut cur: *const xmlChar = (*(*ctxt).input).cur;
        /*
	 * First case : a Processing Instruction.
	 */
        if *cur as std::os::raw::c_int == '<' as i32 &&
               *cur.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
                   '?' as i32 {
            xmlParsePI(ctxt);
        } else if *((*(*ctxt).input).cur as
                        *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize)
                      as std::os::raw::c_int == '<' as i32 &&
                      *((*(*ctxt).input).cur as
                            *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as
                                                           isize) as
                          std::os::raw::c_int == '!' as i32 &&
                      *((*(*ctxt).input).cur as
                            *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as
                                                           isize) as
                          std::os::raw::c_int == '[' as i32 &&
                      *((*(*ctxt).input).cur as
                            *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as
                                                           isize) as
                          std::os::raw::c_int == 'C' as i32 &&
                      *((*(*ctxt).input).cur as
                            *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as
                                                           isize) as
                          std::os::raw::c_int == 'D' as i32 &&
                      *((*(*ctxt).input).cur as
                            *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as
                                                           isize) as
                          std::os::raw::c_int == 'A' as i32 &&
                      *((*(*ctxt).input).cur as
                            *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as
                                                           isize) as
                          std::os::raw::c_int == 'T' as i32 &&
                      *((*(*ctxt).input).cur as
                            *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as
                                                           isize) as
                          std::os::raw::c_int == 'A' as i32 &&
                      *((*(*ctxt).input).cur as
                            *mut std::os::raw::c_uchar).offset(8 as std::os::raw::c_int as
                                                           isize) as
                          std::os::raw::c_int == '[' as i32 {
            xmlParseCDSect(ctxt);
        } else if *cur as std::os::raw::c_int == '<' as i32 &&
                      *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                          as std::os::raw::c_int == '!' as i32 &&
                      *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize)
                          as std::os::raw::c_int == '-' as i32 &&
                      *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize)
                          as std::os::raw::c_int == '-' as i32 {
            xmlParseComment(ctxt);
            (*ctxt).instate = XML_PARSER_CONTENT
        } else if *cur as std::os::raw::c_int == '<' as i32 {
            xmlParseElement(ctxt);
        } else if *cur as std::os::raw::c_int == '&' as i32 {
            xmlParseReference(ctxt);
        } else {
            /*
	 * Second case : a CDSection
	 */
	/* 2.6.0 test was *cur not RAW */
            /*
	 * Third case :  a comment
	 */
            /*
	 * Fourth case :  a sub-element.
	 */
            /*
	 * Fifth case : a reference. If if has not been resolved,
	 *    parsing returns it's Name, create the node
	 */
            /*
	 * Last case, text. Note that References are handled directly.
	 */
            xmlParseCharData(ctxt, 0 as std::os::raw::c_int);
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                   as std::os::raw::c_long >
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) <
                   (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as std::os::raw::c_long {
            xmlSHRINK(ctxt);
        }
        if !(cons as std::os::raw::c_ulong == (*(*ctxt).input).consumed &&
                 test == (*(*ctxt).input).cur) {
            continue ;
        }
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    b"detected an error in element content\n\x00" as *const u8
                        as *const std::os::raw::c_char);
        xmlHaltParser(ctxt);
        break ;
    };
}
/* *
 * xmlParseElement:
 * @ctxt:  an XML parser context
 *
 * parse an XML element, this is highly recursive
 *
 * [39] element ::= EmptyElemTag | STag content ETag
 *
 * [ WFC: Element Type Match ]
 * The Name in an element's end-tag must match the element type in the
 * start-tag.
 *
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseElement(mut ctxt: xmlParserCtxtPtr) {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut prefix: *const xmlChar = 0 as *const xmlChar;
    let mut URI: *const xmlChar = 0 as *const xmlChar;
    let mut node_info: xmlParserNodeInfo =
        xmlParserNodeInfo{node: 0 as *const _xmlNode,
                          begin_pos: 0,
                          begin_line: 0,
                          end_pos: 0,
                          end_line: 0,};
    let mut line: std::os::raw::c_int = 0;
    let mut tlen: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret: xmlNodePtr = 0 as *mut xmlNode;
    let mut nsNr: std::os::raw::c_int = (*ctxt).nsNr;
    if (*ctxt).nameNr as std::os::raw::c_uint > xmlParserMaxDepth &&
           (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
       {
        xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
                          b"Excessive depth in document: %d use XML_PARSE_HUGE option\n\x00"
                              as *const u8 as *const std::os::raw::c_char,
                          xmlParserMaxDepth as std::os::raw::c_int);
        xmlHaltParser(ctxt);
        return
    }
    /* Capture start position */
    if (*ctxt).record_info != 0 {
        node_info.begin_pos =
            (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                       as std::os::raw::c_long as
                                                       std::os::raw::c_ulong);
        node_info.begin_line = (*(*ctxt).input).line as std::os::raw::c_ulong
    }
    if (*ctxt).spaceNr == 0 as std::os::raw::c_int {
        spacePush(ctxt, -(1 as std::os::raw::c_int));
    } else if *(*ctxt).space == -(2 as std::os::raw::c_int) {
        spacePush(ctxt, -(1 as std::os::raw::c_int));
    } else { spacePush(ctxt, *(*ctxt).space); }
    line = (*(*ctxt).input).line;
    if (*ctxt).sax2 != 0 {
        /* LIBXML_SAX1_ENABLED */
        name = xmlParseStartTag2(ctxt, &mut prefix, &mut URI, &mut tlen)
    } else { name = xmlParseStartTag(ctxt) }
    /* LIBXML_SAX1_ENABLED */
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if name.is_null() { spacePop(ctxt); return }
    namePush(ctxt, name);
    ret = (*ctxt).node;
    /*
     * [ VC: Root Element Type ]
     * The Name in the document type declaration must match the element
     * type of the root element.
     */
    if (*ctxt).validate != 0 && (*ctxt).wellFormed != 0 &&
           !(*ctxt).myDoc.is_null() && !(*ctxt).node.is_null() &&
           (*ctxt).node == (*(*ctxt).myDoc).children {
        (*ctxt).valid &= xmlValidateRoot(&mut (*ctxt).vctxt, (*ctxt).myDoc)
    }
    /* LIBXML_VALID_ENABLED */
    /*
     * Check for an Empty Element.
     */
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '/' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '>' as i32 {
        (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 2 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        if (*ctxt).sax2 != 0 {
            if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endElementNs.is_some()
                   && (*ctxt).disableSAX == 0 {
                (*(*ctxt).sax).endElementNs.expect("non-null function pointer")((*ctxt).userData,
                                                                                name,
                                                                                prefix,
                                                                                URI);
            }
        } else if !(*ctxt).sax.is_null() &&
                      (*(*ctxt).sax).endElement.is_some() &&
                      (*ctxt).disableSAX == 0 {
            (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                          name);
        }
        namePop(ctxt);
        spacePop(ctxt);
        if nsNr != (*ctxt).nsNr { nsPop(ctxt, (*ctxt).nsNr - nsNr); }
        if !ret.is_null() && (*ctxt).record_info != 0 {
            node_info.end_pos =
                (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                           as std::os::raw::c_long as
                                                           std::os::raw::c_ulong);
            node_info.end_line = (*(*ctxt).input).line as std::os::raw::c_ulong;
            node_info.node = ret as *const _xmlNode;
            xmlParserAddNodeInfo(ctxt, &mut node_info);
        }
        return
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
        (*(*ctxt).input).col += 1;
        (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1);
        (*ctxt).nbChars += 1;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
    } else {
        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
                                b"Couldn\'t find end of Start Tag %s line %d\n\x00"
                                    as *const u8 as *const std::os::raw::c_char, name,
                                line, 0 as *const xmlChar);
        /* LIBXML_SAX1_ENABLED */
        /*
	 * end of parsing of this node.
	 */
        nodePop(ctxt);
        namePop(ctxt);
        spacePop(ctxt);
        if nsNr != (*ctxt).nsNr { nsPop(ctxt, (*ctxt).nsNr - nsNr); }
        /*
	 * Capture end position and add node
	 */
        if !ret.is_null() && (*ctxt).record_info != 0 {
            node_info.end_pos =
                (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                           as std::os::raw::c_long as
                                                           std::os::raw::c_ulong);
            node_info.end_line = (*(*ctxt).input).line as std::os::raw::c_ulong;
            node_info.node = ret as *const _xmlNode;
            xmlParserAddNodeInfo(ctxt, &mut node_info);
        }
        return
    }
    /*
     * Parse the content of the element:
     */
    xmlParseContent(ctxt);
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return
    }
    if !(0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
             *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
             *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
             0x20 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int) {
        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
                                b"Premature end of data in tag %s line %d\n\x00"
                                    as *const u8 as *const std::os::raw::c_char, name,
                                line, 0 as *const xmlChar);
        /*
	 * end of parsing of this node.
	 */
        nodePop(ctxt);
        namePop(ctxt);
        spacePop(ctxt);
        if nsNr != (*ctxt).nsNr { nsPop(ctxt, (*ctxt).nsNr - nsNr); }
        return
    }
    /*
     * parse the end of tag: '</' should be here.
     */
    if (*ctxt).sax2 != 0 {
        xmlParseEndTag2(ctxt, prefix, URI, line, (*ctxt).nsNr - nsNr, tlen);
        namePop(ctxt);
    } else { xmlParseEndTag1(ctxt, line); }
    /* LIBXML_SAX1_ENABLED */
    /*
     * Capture end position and add node
     */
    if !ret.is_null() && (*ctxt).record_info != 0 {
        node_info.end_pos =
            (*(*ctxt).input).consumed.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                       as std::os::raw::c_long as
                                                       std::os::raw::c_ulong);
        node_info.end_line = (*(*ctxt).input).line as std::os::raw::c_ulong;
        node_info.node = ret as *const _xmlNode;
        xmlParserAddNodeInfo(ctxt, &mut node_info);
    };
}
/* *
 * xmlParseVersionNum:
 * @ctxt:  an XML parser context
 *
 * parse the XML version value.
 *
 * [26] VersionNum ::= '1.' [0-9]+
 *
 * In practice allow [0-9].[0-9]+ at that level
 *
 * Returns the string giving the XML version number, or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseVersionNum(mut ctxt: xmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut size: std::os::raw::c_int = 10 as std::os::raw::c_int;
    let mut cur: xmlChar = 0;
    buf =
        xmlMallocAtomic.expect("non-null function pointer")((size as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong))
            as *mut xmlChar;
    if buf.is_null() {
        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
        return 0 as *mut xmlChar
    }
    cur = *(*(*ctxt).input).cur;
    if !(cur as std::os::raw::c_int >= '0' as i32 && cur as std::os::raw::c_int <= '9' as i32)
       {
        xmlFree.expect("non-null function pointer")(buf as *mut std::os::raw::c_void);
        return 0 as *mut xmlChar
    }
    let fresh130 = len;
    len = len + 1;
    *buf.offset(fresh130 as isize) = cur;
    xmlNextChar(ctxt);
    cur = *(*(*ctxt).input).cur;
    if cur as std::os::raw::c_int != '.' as i32 {
        xmlFree.expect("non-null function pointer")(buf as *mut std::os::raw::c_void);
        return 0 as *mut xmlChar
    }
    let fresh131 = len;
    len = len + 1;
    *buf.offset(fresh131 as isize) = cur;
    xmlNextChar(ctxt);
    cur = *(*(*ctxt).input).cur;
    while cur as std::os::raw::c_int >= '0' as i32 && cur as std::os::raw::c_int <= '9' as i32
          {
        if len + 1 as std::os::raw::c_int >= size {
            let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
            size *= 2 as std::os::raw::c_int;
            tmp =
                xmlRealloc.expect("non-null function pointer")(buf as
                                                                   *mut std::os::raw::c_void,
                                                               (size as
                                                                    std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                    as
                                                                                                    std::os::raw::c_ulong))
                    as *mut xmlChar;
            if tmp.is_null() {
                xmlFree.expect("non-null function pointer")(buf as
                                                                *mut std::os::raw::c_void);
                xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                return 0 as *mut xmlChar
            }
            buf = tmp
        }
        let fresh132 = len;
        len = len + 1;
        *buf.offset(fresh132 as isize) = cur;
        xmlNextChar(ctxt);
        cur = *(*(*ctxt).input).cur
    }
    *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar;
    return buf;
}
/* *
 * xmlParseVersionInfo:
 * @ctxt:  an XML parser context
 *
 * parse the XML version.
 *
 * [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | " VersionNum ")
 *
 * [25] Eq ::= S? '=' S?
 *
 * Returns the version string, e.g. "1.0"
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseVersionInfo(mut ctxt: xmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut version: *mut xmlChar = 0 as *mut xmlChar;
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == 'v' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'e' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'r' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 's' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'i' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'o' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'n' as i32 {
        (*ctxt).nbChars += 7 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(7 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 7 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '=' as i32 {
            xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED,
                        0 as *const std::os::raw::c_char);
            return 0 as *mut xmlChar
        }
        xmlNextChar(ctxt);
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 {
            xmlNextChar(ctxt);
            version = xmlParseVersionNum(ctxt);
            if *(*(*ctxt).input).cur as std::os::raw::c_int != '\"' as i32 {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED,
                            0 as *const std::os::raw::c_char);
            } else { xmlNextChar(ctxt); }
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
            xmlNextChar(ctxt);
            version = xmlParseVersionNum(ctxt);
            if *(*(*ctxt).input).cur as std::os::raw::c_int != '\'' as i32 {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED,
                            0 as *const std::os::raw::c_char);
            } else { xmlNextChar(ctxt); }
        } else {
            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED,
                        0 as *const std::os::raw::c_char);
        }
    }
    return version;
}
/* *
 * xmlParseEncName:
 * @ctxt:  an XML parser context
 *
 * parse the XML encoding name
 *
 * [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
 *
 * Returns the encoding name value or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseEncName(mut ctxt: xmlParserCtxtPtr)
 -> *mut xmlChar {
    let mut buf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut size: std::os::raw::c_int = 10 as std::os::raw::c_int;
    let mut cur: xmlChar = 0;
    cur = *(*(*ctxt).input).cur;
    if cur as std::os::raw::c_int >= 'a' as i32 && cur as std::os::raw::c_int <= 'z' as i32 ||
           cur as std::os::raw::c_int >= 'A' as i32 &&
               cur as std::os::raw::c_int <= 'Z' as i32 {
        buf =
            xmlMallocAtomic.expect("non-null function pointer")((size as
                                                                     std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                     as
                                                                                                     std::os::raw::c_ulong))
                as *mut xmlChar;
        if buf.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            return 0 as *mut xmlChar
        }
        let fresh133 = len;
        len = len + 1;
        *buf.offset(fresh133 as isize) = cur;
        xmlNextChar(ctxt);
        cur = *(*(*ctxt).input).cur;
        while cur as std::os::raw::c_int >= 'a' as i32 &&
                  cur as std::os::raw::c_int <= 'z' as i32 ||
                  cur as std::os::raw::c_int >= 'A' as i32 &&
                      cur as std::os::raw::c_int <= 'Z' as i32 ||
                  cur as std::os::raw::c_int >= '0' as i32 &&
                      cur as std::os::raw::c_int <= '9' as i32 ||
                  cur as std::os::raw::c_int == '.' as i32 ||
                  cur as std::os::raw::c_int == '_' as i32 ||
                  cur as std::os::raw::c_int == '-' as i32 {
            if len + 1 as std::os::raw::c_int >= size {
                let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
                size *= 2 as std::os::raw::c_int;
                tmp =
                    xmlRealloc.expect("non-null function pointer")(buf as
                                                                       *mut std::os::raw::c_void,
                                                                   (size as
                                                                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlChar>()
                                                                                                        as
                                                                                                        std::os::raw::c_ulong))
                        as *mut xmlChar;
                if tmp.is_null() {
                    xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                    xmlFree.expect("non-null function pointer")(buf as
                                                                    *mut std::os::raw::c_void);
                    return 0 as *mut xmlChar
                }
                buf = tmp
            }
            let fresh134 = len;
            len = len + 1;
            *buf.offset(fresh134 as isize) = cur;
            xmlNextChar(ctxt);
            cur = *(*(*ctxt).input).cur;
            if cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                           as std::os::raw::c_long >
                           (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                               std::os::raw::c_long &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           (2 as std::os::raw::c_int * 250 as std::os::raw::c_int) as
                               std::os::raw::c_long {
                    xmlSHRINK(ctxt);
                }
                if (*ctxt).progressive == 0 as std::os::raw::c_int &&
                       ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                            as std::os::raw::c_long) <
                           250 as std::os::raw::c_int as std::os::raw::c_long {
                    xmlGROW(ctxt);
                }
                cur = *(*(*ctxt).input).cur
            }
        }
        *buf.offset(len as isize) = 0 as std::os::raw::c_int as xmlChar
    } else {
        xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, 0 as *const std::os::raw::c_char);
    }
    return buf;
}
/* *
 * xmlParseEncodingDecl:
 * @ctxt:  an XML parser context
 *
 * parse the XML encoding declaration
 *
 * [80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' |  "'" EncName "'")
 *
 * this setups the conversion filters.
 *
 * Returns the encoding value or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseEncodingDecl(mut ctxt: xmlParserCtxtPtr)
 -> *const xmlChar {
    let mut encoding: *mut xmlChar = 0 as *mut xmlChar;
    xmlSkipBlankChars(ctxt);
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == 'e' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'n' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'c' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'o' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'd' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'i' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'n' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'g' as i32 {
        (*ctxt).nbChars += 8 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(8 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 8 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '=' as i32 {
            xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED,
                        0 as *const std::os::raw::c_char);
            return 0 as *const xmlChar
        }
        xmlNextChar(ctxt);
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 {
            xmlNextChar(ctxt);
            encoding = xmlParseEncName(ctxt);
            if *(*(*ctxt).input).cur as std::os::raw::c_int != '\"' as i32 {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED,
                            0 as *const std::os::raw::c_char);
                xmlFree.expect("non-null function pointer")(encoding as
                                                                *mut std::os::raw::c_void);
                return 0 as *const xmlChar
            } else { xmlNextChar(ctxt); }
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
            xmlNextChar(ctxt);
            encoding = xmlParseEncName(ctxt);
            if *(*(*ctxt).input).cur as std::os::raw::c_int != '\'' as i32 {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED,
                            0 as *const std::os::raw::c_char);
                xmlFree.expect("non-null function pointer")(encoding as
                                                                *mut std::os::raw::c_void);
                return 0 as *const xmlChar
            } else { xmlNextChar(ctxt); }
        } else {
            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED,
                        0 as *const std::os::raw::c_char);
        }
        /*
         * Non standard parsing, allowing the user to ignore encoding
         */
        if (*ctxt).options & XML_PARSE_IGNORE_ENC as std::os::raw::c_int != 0 {
            xmlFree.expect("non-null function pointer")(encoding as
                                                            *mut std::os::raw::c_void);
            return 0 as *const xmlChar
        }
        /*
	 * UTF-16 encoding stwich has already taken place at this stage,
	 * more over the little-endian/big-endian selection is already done
	 */
        if !encoding.is_null() &&
               (xmlStrcasecmp(encoding,
                              b"UTF-16\x00" as *const u8 as
                                  *const std::os::raw::c_char as *mut xmlChar) == 0 ||
                    xmlStrcasecmp(encoding,
                                  b"UTF16\x00" as *const u8 as
                                      *const std::os::raw::c_char as *mut xmlChar) ==
                        0) {
            /*
	     * If no encoding was passed to the parser, that we are
	     * using UTF-16 and no decoder is present i.e. the
	     * document is apparently UTF-8 compatible, then raise an
	     * encoding mismatch fatal error
	     */
            if (*ctxt).encoding.is_null() && !(*(*ctxt).input).buf.is_null()
                   && (*(*(*ctxt).input).buf).encoder.is_null() {
                xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,
                               b"Document labelled UTF-16 but has UTF-8 content\n\x00"
                                   as *const u8 as *const std::os::raw::c_char);
            }
            if !(*ctxt).encoding.is_null() {
                xmlFree.expect("non-null function pointer")((*ctxt).encoding
                                                                as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            (*ctxt).encoding = encoding
        } else if !encoding.is_null() &&
                      (xmlStrcasecmp(encoding,
                                     b"UTF-8\x00" as *const u8 as
                                         *const std::os::raw::c_char as *mut xmlChar)
                           == 0 ||
                           xmlStrcasecmp(encoding,
                                         b"UTF8\x00" as *const u8 as
                                             *const std::os::raw::c_char as
                                             *mut xmlChar) == 0) {
            if !(*ctxt).encoding.is_null() {
                xmlFree.expect("non-null function pointer")((*ctxt).encoding
                                                                as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            (*ctxt).encoding = encoding
        } else if !encoding.is_null() {
            let mut handler: xmlCharEncodingHandlerPtr =
                0 as *mut xmlCharEncodingHandler;
            if !(*(*ctxt).input).encoding.is_null() {
                xmlFree.expect("non-null function pointer")((*(*ctxt).input).encoding
                                                                as
                                                                *mut xmlChar
                                                                as
                                                                *mut std::os::raw::c_void);
            }
            (*(*ctxt).input).encoding = encoding;
            handler =
                xmlFindCharEncodingHandler(encoding as *const std::os::raw::c_char);
            if !handler.is_null() {
                if xmlSwitchToEncoding(ctxt, handler) < 0 as std::os::raw::c_int {
                    /*
	 * UTF-8 encoding is handled natively
	 */
                    /* failed to convert */
                    (*ctxt).errNo =
                        XML_ERR_UNSUPPORTED_ENCODING as std::os::raw::c_int;
                    return 0 as *const xmlChar
                }
            } else {
                xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
                                  b"Unsupported encoding %s\n\x00" as
                                      *const u8 as *const std::os::raw::c_char,
                                  encoding);
                return 0 as *const xmlChar
            }
        }
    }
    return encoding;
}
/* *
 * xmlParseSDDecl:
 * @ctxt:  an XML parser context
 *
 * parse the XML standalone declaration
 *
 * [32] SDDecl ::= S 'standalone' Eq
 *                 (("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no')'"'))
 *
 * [ VC: Standalone Document Declaration ]
 * TODO The standalone document declaration must have the value "no"
 * if any external markup declarations contain declarations of:
 *  - attributes with default values, if elements to which these
 *    attributes apply appear in the document without specifications
 *    of values for these attributes, or
 *  - entities (other than amp, lt, gt, apos, quot), if references
 *    to those entities appear in the document, or
 *  - attributes with values subject to normalization, where the
 *    attribute appears in the document with a value which will change
 *    as a result of normalization, or
 *  - element types with element content, if white space occurs directly
 *    within any instance of those types.
 *
 * Returns:
 *   1 if standalone="yes"
 *   0 if standalone="no"
 *  -2 if standalone attribute is missing or invalid
 *	  (A standalone value of -2 means that the XML declaration was found,
 *	   but no value was specified for the standalone attribute).
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseSDDecl(mut ctxt: xmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut standalone: std::os::raw::c_int = -(2 as std::os::raw::c_int);
    xmlSkipBlankChars(ctxt);
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == 's' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 't' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'a' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'n' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'd' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'a' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'l' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'o' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(8 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'n' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(9 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'e' as i32 {
        (*ctxt).nbChars += 10 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(10 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 10 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int != '=' as i32 {
            xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED,
                        0 as *const std::os::raw::c_char);
            return standalone
        }
        xmlNextChar(ctxt);
        xmlSkipBlankChars(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '\'' as i32 {
            xmlNextChar(ctxt);
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 'n' as i32 &&
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == 'o' as i32 {
                standalone = 0 as std::os::raw::c_int;
                (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 2 as std::os::raw::c_int;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int == 'y' as i32 &&
                          *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                           isize) as
                              std::os::raw::c_int == 'e' as i32 &&
                          *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                           isize) as
                              std::os::raw::c_int == 's' as i32 {
                standalone = 1 as std::os::raw::c_int;
                (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 3 as std::os::raw::c_int;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
            } else {
                xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE,
                            0 as *const std::os::raw::c_char);
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int != '\'' as i32 {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED,
                            0 as *const std::os::raw::c_char);
            } else { xmlNextChar(ctxt); }
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '\"' as i32 {
            xmlNextChar(ctxt);
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 'n' as i32 &&
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == 'o' as i32 {
                standalone = 0 as std::os::raw::c_int;
                (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 2 as std::os::raw::c_int;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
            } else if *(*(*ctxt).input).cur as std::os::raw::c_int == 'y' as i32 &&
                          *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                           isize) as
                              std::os::raw::c_int == 'e' as i32 &&
                          *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                           isize) as
                              std::os::raw::c_int == 's' as i32 {
                standalone = 1 as std::os::raw::c_int;
                (*ctxt).nbChars += 3 as std::os::raw::c_int as std::os::raw::c_long;
                (*(*ctxt).input).cur =
                    (*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
                (*(*ctxt).input).col += 3 as std::os::raw::c_int;
                if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                    xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
                }
            } else {
                xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE,
                            0 as *const std::os::raw::c_char);
            }
            if *(*(*ctxt).input).cur as std::os::raw::c_int != '\"' as i32 {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED,
                            0 as *const std::os::raw::c_char);
            } else { xmlNextChar(ctxt); }
        } else {
            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED,
                        0 as *const std::os::raw::c_char);
        }
    }
    return standalone;
}
/* *
 * xmlParseXMLDecl:
 * @ctxt:  an XML parser context
 *
 * parse an XML declaration header
 *
 * [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseXMLDecl(mut ctxt: xmlParserCtxtPtr) {
    let mut version: *mut xmlChar = 0 as *mut xmlChar;
    /*
     * This value for standalone indicates that the document has an
     * XML declaration but it does not have a standalone attribute.
     * It will be overwritten later if a standalone attribute is found.
     */
    (*(*ctxt).input).standalone = -(2 as std::os::raw::c_int);
    /*
     * We know that '<?xml' is here.
     */
    (*ctxt).nbChars += 5 as std::os::raw::c_int as std::os::raw::c_long;
    (*(*ctxt).input).cur =
        (*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize);
    (*(*ctxt).input).col += 5 as std::os::raw::c_int;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
    }
    if !(*(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
             0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                 *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
             *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                       b"Blank needed after \'<?xml\'\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
    }
    xmlSkipBlankChars(ctxt);
    /*
     * We must have the VersionInfo here.
     */
    version = xmlParseVersionInfo(ctxt);
    if version.is_null() {
        xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, 0 as *const std::os::raw::c_char);
    } else {
        if xmlStrEqual(version,
                       b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                           *const xmlChar) == 0 {
            /*
	     * Changed here for XML-1.0 5th edition
	     */
            if (*ctxt).options & XML_PARSE_OLD10 as std::os::raw::c_int != 0 {
                xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
                                  b"Unsupported version \'%s\'\n\x00" as
                                      *const u8 as *const std::os::raw::c_char,
                                  version);
            } else if *version.offset(0 as std::os::raw::c_int as isize) as
                          std::os::raw::c_int == '1' as i32 &&
                          *version.offset(1 as std::os::raw::c_int as isize) as
                              std::os::raw::c_int == '.' as i32 {
                xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,
                              b"Unsupported version \'%s\'\n\x00" as *const u8
                                  as *const std::os::raw::c_char, version,
                              0 as *const xmlChar);
            } else {
                xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
                                  b"Unsupported version \'%s\'\n\x00" as
                                      *const u8 as *const std::os::raw::c_char,
                                  version);
            }
        }
        if !(*ctxt).version.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).version as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).version = version
    }
    /*
     * We may have the encoding declaration
     */
    if !(*(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
             0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                 *(*(*ctxt).input).cur as std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
             *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '?' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '>' as i32 {
            (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
            (*(*ctxt).input).cur =
                (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
            (*(*ctxt).input).col += 2 as std::os::raw::c_int;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
            return
        }
        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                       b"Blank needed here\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
    }
    xmlParseEncodingDecl(ctxt);
    if (*ctxt).errNo == XML_ERR_UNSUPPORTED_ENCODING as std::os::raw::c_int ||
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        /*
	 * The XML REC instructs us to stop parsing right here
	 */
        return
    }
    /*
     * We may have the standalone status.
     */
    if !(*(*ctxt).input).encoding.is_null() &&
           !(*(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                 0x9 as std::os::raw::c_int <= *(*(*ctxt).input).cur as std::os::raw::c_int &&
                     *(*(*ctxt).input).cur as std::os::raw::c_int <=
                         0xa as std::os::raw::c_int ||
                 *(*(*ctxt).input).cur as std::os::raw::c_int == 0xd as std::os::raw::c_int) {
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '?' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '>' as i32 {
            (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
            (*(*ctxt).input).cur =
                (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
            (*(*ctxt).input).col += 2 as std::os::raw::c_int;
            if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
            }
            return
        }
        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                       b"Blank needed here\n\x00" as *const u8 as
                           *const std::os::raw::c_char);
    }
    /*
     * We can grow the input buffer freely at that point
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    xmlSkipBlankChars(ctxt);
    (*(*ctxt).input).standalone = xmlParseSDDecl(ctxt);
    xmlSkipBlankChars(ctxt);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '?' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '>' as i32 {
        (*ctxt).nbChars += 2 as std::os::raw::c_int as std::os::raw::c_long;
        (*(*ctxt).input).cur =
            (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        (*(*ctxt).input).col += 2 as std::os::raw::c_int;
        if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
            xmlParserInputGrow((*ctxt).input, 250 as std::os::raw::c_int);
        }
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int == '>' as i32 {
        /* Deprecated old WD ... */
        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        xmlNextChar(ctxt);
    } else {
        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED,
                    0 as *const std::os::raw::c_char);
        while *(*(*ctxt).input).cur as std::os::raw::c_int != 0 &&
                  *(*(*ctxt).input).cur as std::os::raw::c_int != '>' as i32 {
            (*(*ctxt).input).cur = (*(*ctxt).input).cur.offset(1)
        }
        xmlNextChar(ctxt);
    };
}
/* *
 * xmlParseMisc:
 * @ctxt:  an XML parser context
 *
 * parse an XML Misc* optional field.
 *
 * [27] Misc ::= Comment | PI |  S
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseMisc(mut ctxt: xmlParserCtxtPtr) {
    while (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int &&
              (*(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
                   *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                       std::os::raw::c_int == '?' as i32 ||
                   *((*(*ctxt).input).cur as
                         *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize)
                       as std::os::raw::c_int == '<' as i32 &&
                       *((*(*ctxt).input).cur as
                             *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as
                                                            isize) as
                           std::os::raw::c_int == '!' as i32 &&
                       *((*(*ctxt).input).cur as
                             *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as
                                                            isize) as
                           std::os::raw::c_int == '-' as i32 &&
                       *((*(*ctxt).input).cur as
                             *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as
                                                            isize) as
                           std::os::raw::c_int == '-' as i32 ||
                   (*(*(*ctxt).input).cur as std::os::raw::c_int ==
                        0x20 as std::os::raw::c_int ||
                        0x9 as std::os::raw::c_int <=
                            *(*(*ctxt).input).cur as std::os::raw::c_int &&
                            *(*(*ctxt).input).cur as std::os::raw::c_int <=
                                0xa as std::os::raw::c_int ||
                        *(*(*ctxt).input).cur as std::os::raw::c_int ==
                            0xd as std::os::raw::c_int)) {
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == '?' as i32 {
            xmlParsePI(ctxt);
        } else if *(*(*ctxt).input).cur as std::os::raw::c_int == 0x20 as std::os::raw::c_int
                      ||
                      0x9 as std::os::raw::c_int <=
                          *(*(*ctxt).input).cur as std::os::raw::c_int &&
                          *(*(*ctxt).input).cur as std::os::raw::c_int <=
                              0xa as std::os::raw::c_int ||
                      *(*(*ctxt).input).cur as std::os::raw::c_int ==
                          0xd as std::os::raw::c_int {
            xmlNextChar(ctxt);
        } else { xmlParseComment(ctxt); }
    };
}
/* *
 * xmlParseDocument:
 * @ctxt:  an XML parser context
 *
 * parse an XML document (and build a tree if using the standard SAX
 * interface).
 *
 * [1] document ::= prolog element Misc*
 *
 * [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?
 *
 * Returns 0, -1 in case of error. the parser context is augmented
 *                as a result of the parsing.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseDocument(mut ctxt: xmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut start: [xmlChar; 4] = [0; 4];
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    xmlInitParser();
    if ctxt.is_null() || (*ctxt).input.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    /*
     * SAX: detecting the level.
     */
    xmlDetectSAX2(ctxt);
    /*
     * SAX: beginning of the document processing.
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).setDocumentLocator.is_some() {
        (*(*ctxt).sax).setDocumentLocator.expect("non-null function pointer")((*ctxt).userData,
                                                                              __xmlDefaultSAXLocator());
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    if (*ctxt).encoding.is_null() &&
           (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
               std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
        /*
	 * Get the 4 first bytes and decode the charset
	 * if enc != XML_CHAR_ENCODING_NONE
	 * plug some encoding conversion routines.
	 */
        start[0 as std::os::raw::c_int as usize] = *(*(*ctxt).input).cur;
        start[1 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
        start[2 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        start[3 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
        enc =
            xmlDetectCharEncoding(&mut *start.as_mut_ptr().offset(0 as
                                                                      std::os::raw::c_int
                                                                      as
                                                                      isize),
                                  4 as std::os::raw::c_int);
        if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
            xmlSwitchEncoding(ctxt, enc);
        }
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, 0 as *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    /*
     * Check for the XMLDecl in the Prolog.
     * do not GROW here to avoid the detected encoder to decode more
     * than just the first line, unless the amount of data is really
     * too small to hold "<?xml version="1.0" encoding="foo"
     */
    if ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
            std::os::raw::c_long) < 35 as std::os::raw::c_int as std::os::raw::c_long {
        if (*ctxt).progressive == 0 as std::os::raw::c_int &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
            xmlGROW(ctxt);
        }
    }
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '?' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'x' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'm' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'l' as i32 &&
           (*(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                0x9 as std::os::raw::c_int <=
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int &&
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                    std::os::raw::c_int == 0xd as std::os::raw::c_int) {
        /*
	 * Note that we will switch encoding on the fly.
	 */
        xmlParseXMLDecl(ctxt);
        if (*ctxt).errNo == XML_ERR_UNSUPPORTED_ENCODING as std::os::raw::c_int ||
               (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
           {
            /*
	     * The XML REC instructs us to stop parsing right here
	     */
            return -(1 as std::os::raw::c_int)
        }
        (*ctxt).standalone = (*(*ctxt).input).standalone;
        xmlSkipBlankChars(ctxt);
    } else {
        (*ctxt).version =
            xmlCharStrdup(b"1.0\x00" as *const u8 as *const std::os::raw::c_char)
    }
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startDocument.is_some() &&
           (*ctxt).disableSAX == 0 {
        (*(*ctxt).sax).startDocument.expect("non-null function pointer")((*ctxt).userData);
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    if !(*ctxt).myDoc.is_null() && !(*ctxt).input.is_null() &&
           !(*(*ctxt).input).buf.is_null() &&
           (*(*(*ctxt).input).buf).compressed >= 0 as std::os::raw::c_int {
        (*(*ctxt).myDoc).compression = (*(*(*ctxt).input).buf).compressed
    }
    /*
     * The Misc part of the Prolog
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    xmlParseMisc(ctxt);
    /*
     * Then possibly doc type declaration(s) and more Misc
     * (doctypedecl Misc*)?
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '!' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'D' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'O' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'C' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(5 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'T' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(6 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'Y' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(7 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'P' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(8 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'E' as i32 {
        (*ctxt).inSubset = 1 as std::os::raw::c_int;
        xmlParseDocTypeDecl(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int == '[' as i32 {
            (*ctxt).instate = XML_PARSER_DTD;
            xmlParseInternalSubset(ctxt);
            if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int
               {
                return -(1 as std::os::raw::c_int)
            }
        }
        /*
	 * Create and update the external subset.
	 */
        (*ctxt).inSubset = 2 as std::os::raw::c_int;
        if !(*ctxt).sax.is_null() && (*(*ctxt).sax).externalSubset.is_some()
               && (*ctxt).disableSAX == 0 {
            (*(*ctxt).sax).externalSubset.expect("non-null function pointer")((*ctxt).userData,
                                                                              (*ctxt).intSubName,
                                                                              (*ctxt).extSubSystem,
                                                                              (*ctxt).extSubURI);
        }
        if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
            return -(1 as std::os::raw::c_int)
        }
        (*ctxt).inSubset = 0 as std::os::raw::c_int;
        xmlCleanSpecialAttr(ctxt);
        (*ctxt).instate = XML_PARSER_PROLOG;
        xmlParseMisc(ctxt);
    }
    /*
     * Time to start parsing the tree itself
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int != '<' as i32 {
        xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
                       b"Start tag expected, \'<\' not found\n\x00" as
                           *const u8 as *const std::os::raw::c_char);
    } else {
        (*ctxt).instate = XML_PARSER_CONTENT;
        xmlParseElement(ctxt);
        (*ctxt).instate = XML_PARSER_EPILOG;
        /*
	 * The Misc part at the end
	 */
        xmlParseMisc(ctxt);
        if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, 0 as *const std::os::raw::c_char);
        }
        (*ctxt).instate = XML_PARSER_EOF
    }
    /*
     * SAX: end of the document processing.
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endDocument.is_some() {
        (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
    }
    /*
     * Remove locally kept entity definitions if the tree was not built
     */
    if !(*ctxt).myDoc.is_null() &&
           xmlStrEqual((*(*ctxt).myDoc).version,
                       b"SAX compatibility mode document\x00" as *const u8 as
                           *const std::os::raw::c_char as *mut xmlChar) != 0 {
        xmlFreeDoc((*ctxt).myDoc);
        (*ctxt).myDoc = 0 as xmlDocPtr
    }
    if (*ctxt).wellFormed != 0 && !(*ctxt).myDoc.is_null() {
        (*(*ctxt).myDoc).properties |= XML_DOC_WELLFORMED as std::os::raw::c_int;
        if (*ctxt).valid != 0 {
            (*(*ctxt).myDoc).properties |= XML_DOC_DTDVALID as std::os::raw::c_int
        }
        if (*ctxt).nsWellFormed != 0 {
            (*(*ctxt).myDoc).properties |= XML_DOC_NSVALID as std::os::raw::c_int
        }
        if (*ctxt).options & XML_PARSE_OLD10 as std::os::raw::c_int != 0 {
            (*(*ctxt).myDoc).properties |= XML_DOC_OLD10 as std::os::raw::c_int
        }
    }
    if (*ctxt).wellFormed == 0 {
        (*ctxt).valid = 0 as std::os::raw::c_int;
        return -(1 as std::os::raw::c_int)
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlParseExtParsedEnt:
 * @ctxt:  an XML parser context
 *
 * parse a general parsed entity
 * An external general parsed entity is well-formed if it matches the
 * production labeled extParsedEnt.
 *
 * [78] extParsedEnt ::= TextDecl? content
 *
 * Returns 0, -1 in case of error. the parser context is augmented
 *                as a result of the parsing.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseExtParsedEnt(mut ctxt: xmlParserCtxtPtr)
 -> std::os::raw::c_int {
    let mut start: [xmlChar; 4] = [0; 4];
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    if ctxt.is_null() || (*ctxt).input.is_null() {
        return -(1 as std::os::raw::c_int)
    }
    xmlDefaultSAXHandlerInit();
    xmlDetectSAX2(ctxt);
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    /*
     * SAX: beginning of the document processing.
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).setDocumentLocator.is_some() {
        (*(*ctxt).sax).setDocumentLocator.expect("non-null function pointer")((*ctxt).userData,
                                                                              __xmlDefaultSAXLocator());
    }
    /*
     * Get the 4 first bytes and decode the charset
     * if enc != XML_CHAR_ENCODING_NONE
     * plug some encoding conversion routines.
     */
    if (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
           std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
        start[0 as std::os::raw::c_int as usize] = *(*(*ctxt).input).cur;
        start[1 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
        start[2 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        start[3 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
        enc = xmlDetectCharEncoding(start.as_mut_ptr(), 4 as std::os::raw::c_int);
        if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
            xmlSwitchEncoding(ctxt, enc);
        }
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, 0 as *const std::os::raw::c_char);
    }
    /*
     * Check for the XMLDecl in the Prolog.
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '?' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'x' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'm' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'l' as i32 &&
           (*(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                0x9 as std::os::raw::c_int <=
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int &&
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                    std::os::raw::c_int == 0xd as std::os::raw::c_int) {
        /*
	 * Note that we will switch encoding on the fly.
	 */
        xmlParseXMLDecl(ctxt);
        if (*ctxt).errNo == XML_ERR_UNSUPPORTED_ENCODING as std::os::raw::c_int {
            /*
	     * The XML REC instructs us to stop parsing right here
	     */
            return -(1 as std::os::raw::c_int)
        }
        xmlSkipBlankChars(ctxt);
    } else {
        (*ctxt).version =
            xmlCharStrdup(b"1.0\x00" as *const u8 as *const std::os::raw::c_char)
    }
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).startDocument.is_some() &&
           (*ctxt).disableSAX == 0 {
        (*(*ctxt).sax).startDocument.expect("non-null function pointer")((*ctxt).userData);
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    /*
     * Doing validity checking on chunk doesn't make sense
     */
    (*ctxt).instate = XML_PARSER_CONTENT;
    (*ctxt).validate = 0 as std::os::raw::c_int;
    (*ctxt).loadsubset = 0 as std::os::raw::c_int;
    (*ctxt).depth = 0 as std::os::raw::c_int;
    xmlParseContent(ctxt);
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '/' as i32 {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, 0 as *const std::os::raw::c_char);
    }
    /*
     * SAX: end of the document processing.
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endDocument.is_some() {
        (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
    }
    if (*ctxt).wellFormed == 0 { return -(1 as std::os::raw::c_int) }
    return 0 as std::os::raw::c_int;
}
/* ***********************************************************************
 *									*
 *		Progressive parsing interfaces				*
 *									*
 ************************************************************************/
/* *
 * xmlParseLookupSequence:
 * @ctxt:  an XML parser context
 * @first:  the first char to lookup
 * @next:  the next char to lookup or zero
 * @third:  the next char to lookup or zero
 *
 * Try to find if a sequence (first, next, third) or  just (first next) or
 * (first) is available in the input stream.
 * This function has a side effect of (possibly) incrementing ctxt->checkIndex
 * to avoid rescanning sequences of bytes, it DOES change the state of the
 * parser, do not use liberally.
 *
 * Returns the index to the current parsing point if the full sequence
 *      is available, -1 otherwise.
 */
unsafe extern "C" fn xmlParseLookupSequence(mut ctxt: xmlParserCtxtPtr,
                                            mut first: xmlChar,
                                            mut next: xmlChar,
                                            mut third: xmlChar)
 -> std::os::raw::c_int {
    let mut base: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: *const xmlChar = 0 as *const xmlChar;
    in_0 = (*ctxt).input;
    if in_0.is_null() { return -(1 as std::os::raw::c_int) }
    base =
        (*in_0).cur.offset_from((*in_0).base) as std::os::raw::c_long as
            std::os::raw::c_int;
    if base < 0 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
    if (*ctxt).checkIndex > base as std::os::raw::c_long {
        base = (*ctxt).checkIndex as std::os::raw::c_int
    }
    if (*in_0).buf.is_null() {
        buf = (*in_0).base;
        len = (*in_0).length
    } else {
        buf = xmlBufContent((*(*in_0).buf).buffer as *const xmlBuf);
        len = xmlBufUse((*(*in_0).buf).buffer) as std::os::raw::c_int
    }
    /* take into account the sequence length */
    if third != 0 { len -= 2 as std::os::raw::c_int } else if next != 0 { len -= 1 }
    let mut current_block_20: u64;
    while base < len {
        if *buf.offset(base as isize) as std::os::raw::c_int == first as std::os::raw::c_int {
            if third as std::os::raw::c_int != 0 as std::os::raw::c_int {
                if *buf.offset((base + 1 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int != next as std::os::raw::c_int ||
                       *buf.offset((base + 2 as std::os::raw::c_int) as isize) as
                           std::os::raw::c_int != third as std::os::raw::c_int {
                    current_block_20 = 2370887241019905314;
                } else { current_block_20 = 18386322304582297246; }
            } else if next as std::os::raw::c_int != 0 as std::os::raw::c_int {
                if *buf.offset((base + 1 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int != next as std::os::raw::c_int {
                    current_block_20 = 2370887241019905314;
                } else { current_block_20 = 18386322304582297246; }
            } else { current_block_20 = 18386322304582297246; }
            match current_block_20 {
                2370887241019905314 => { }
                _ => {
                    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long;
                    return (base as std::os::raw::c_long -
                                (*in_0).cur.offset_from((*in_0).base)
                                    as std::os::raw::c_long) as std::os::raw::c_int
                }
            }
        }
        base += 1
    }
    (*ctxt).checkIndex = base as std::os::raw::c_long;
    return -(1 as std::os::raw::c_int);
}
/* *
 * xmlParseGetLasts:
 * @ctxt:  an XML parser context
 * @lastlt:  pointer to store the last '<' from the input
 * @lastgt:  pointer to store the last '>' from the input
 *
 * Lookup the last < and > in the current chunk
 */
unsafe extern "C" fn xmlParseGetLasts(mut ctxt: xmlParserCtxtPtr,
                                      mut lastlt: *mut *const xmlChar,
                                      mut lastgt: *mut *const xmlChar) {
    let mut tmp: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || lastlt.is_null() || lastgt.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Internal error: xmlParseGetLasts\n\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char);
        return
    }
    if (*ctxt).progressive != 0 as std::os::raw::c_int &&
           (*ctxt).inputNr == 1 as std::os::raw::c_int {
        tmp = (*(*ctxt).input).end;
        tmp = tmp.offset(-1);
        while tmp >= (*(*ctxt).input).base &&
                  *tmp as std::os::raw::c_int != '<' as i32 {
            tmp = tmp.offset(-1)
        }
        if tmp < (*(*ctxt).input).base {
            *lastlt = 0 as *const xmlChar;
            *lastgt = 0 as *const xmlChar
        } else {
            *lastlt = tmp;
            tmp = tmp.offset(1);
            while tmp < (*(*ctxt).input).end &&
                      *tmp as std::os::raw::c_int != '>' as i32 {
                if *tmp as std::os::raw::c_int == '\'' as i32 {
                    tmp = tmp.offset(1);
                    while tmp < (*(*ctxt).input).end &&
                              *tmp as std::os::raw::c_int != '\'' as i32 {
                        tmp = tmp.offset(1)
                    }
                    if tmp < (*(*ctxt).input).end { tmp = tmp.offset(1) }
                } else if *tmp as std::os::raw::c_int == '\"' as i32 {
                    tmp = tmp.offset(1);
                    while tmp < (*(*ctxt).input).end &&
                              *tmp as std::os::raw::c_int != '\"' as i32 {
                        tmp = tmp.offset(1)
                    }
                    if tmp < (*(*ctxt).input).end { tmp = tmp.offset(1) }
                } else { tmp = tmp.offset(1) }
            }
            if tmp < (*(*ctxt).input).end {
                *lastgt = tmp
            } else {
                tmp = *lastlt;
                tmp = tmp.offset(-1);
                while tmp >= (*(*ctxt).input).base &&
                          *tmp as std::os::raw::c_int != '>' as i32 {
                    tmp = tmp.offset(-1)
                }
                if tmp >= (*(*ctxt).input).base {
                    *lastgt = tmp
                } else { *lastgt = 0 as *const xmlChar }
            }
        }
    } else { *lastlt = 0 as *const xmlChar; *lastgt = 0 as *const xmlChar };
}
/* *
 * xmlCheckCdataPush:
 * @cur: pointer to the block of characters
 * @len: length of the block in bytes
 * @complete: 1 if complete CDATA block is passed in, 0 if partial block
 *
 * Check that the block of characters is okay as SCdata content [20]
 *
 * Returns the number of bytes to pass if okay, a negative index where an
 *         UTF-8 error occurred otherwise
 */
unsafe extern "C" fn xmlCheckCdataPush(mut utf: *const xmlChar,
                                       mut len: std::os::raw::c_int,
                                       mut complete: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut ix: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_uchar = 0;
    let mut codepoint: std::os::raw::c_int = 0;
    if utf.is_null() || len <= 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    ix = 0 as std::os::raw::c_int;
    while ix < len {
        /* string is 0-terminated */
        c = *utf.offset(ix as isize);
        if c as std::os::raw::c_int & 0x80 as std::os::raw::c_int == 0 as std::os::raw::c_int {
            /* 1-byte code, starts with 10 */
            if c as std::os::raw::c_int >= 0x20 as std::os::raw::c_int {
                ix += 1
            } else if c as std::os::raw::c_int == 0xa as std::os::raw::c_int ||
                          c as std::os::raw::c_int == 0xd as std::os::raw::c_int ||
                          c as std::os::raw::c_int == 0x9 as std::os::raw::c_int {
                ix += 1
            } else { return -ix }
        } else if c as std::os::raw::c_int & 0xe0 as std::os::raw::c_int ==
                      0xc0 as std::os::raw::c_int {
            /* 2-byte code, starts with 110 */
            if ix + 2 as std::os::raw::c_int > len {
                return if complete != 0 { -ix } else { ix }
            }
            if *utf.offset((ix + 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int &
                   0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int {
                return -ix
            }
            codepoint =
                (*utf.offset(ix as isize) as std::os::raw::c_int &
                     0x1f as std::os::raw::c_int) << 6 as std::os::raw::c_int;
            codepoint |=
                *utf.offset((ix + 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int &
                    0x3f as std::os::raw::c_int;
            if if codepoint < 0x100 as std::os::raw::c_int {
                   (0x9 as std::os::raw::c_int <= codepoint &&
                        codepoint <= 0xa as std::os::raw::c_int ||
                        codepoint == 0xd as std::os::raw::c_int ||
                        0x20 as std::os::raw::c_int <= codepoint) as std::os::raw::c_int
               } else {
                   (0x100 as std::os::raw::c_int <= codepoint &&
                        codepoint <= 0xd7ff as std::os::raw::c_int ||
                        0xe000 as std::os::raw::c_int <= codepoint &&
                            codepoint <= 0xfffd as std::os::raw::c_int ||
                        0x10000 as std::os::raw::c_int <= codepoint &&
                            codepoint <= 0x10ffff as std::os::raw::c_int) as
                       std::os::raw::c_int
               } == 0 {
                return -ix
            }
            ix += 2 as std::os::raw::c_int
        } else if c as std::os::raw::c_int & 0xf0 as std::os::raw::c_int ==
                      0xe0 as std::os::raw::c_int {
            /* 3-byte code, starts with 1110 */
            if ix + 3 as std::os::raw::c_int > len {
                return if complete != 0 { -ix } else { ix }
            } /* unknown encoding */
            if *utf.offset((ix + 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int &
                   0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int ||
                   *utf.offset((ix + 2 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                       0x80 as std::os::raw::c_int {
                return -ix
            }
            codepoint =
                (*utf.offset(ix as isize) as std::os::raw::c_int & 0xf as std::os::raw::c_int)
                    << 12 as std::os::raw::c_int;
            codepoint |=
                (*utf.offset((ix + 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int
                     & 0x3f as std::os::raw::c_int) << 6 as std::os::raw::c_int;
            codepoint |=
                *utf.offset((ix + 2 as std::os::raw::c_int) as isize) as std::os::raw::c_int &
                    0x3f as std::os::raw::c_int;
            if if codepoint < 0x100 as std::os::raw::c_int {
                   (0x9 as std::os::raw::c_int <= codepoint &&
                        codepoint <= 0xa as std::os::raw::c_int ||
                        codepoint == 0xd as std::os::raw::c_int ||
                        0x20 as std::os::raw::c_int <= codepoint) as std::os::raw::c_int
               } else {
                   (0x100 as std::os::raw::c_int <= codepoint &&
                        codepoint <= 0xd7ff as std::os::raw::c_int ||
                        0xe000 as std::os::raw::c_int <= codepoint &&
                            codepoint <= 0xfffd as std::os::raw::c_int ||
                        0x10000 as std::os::raw::c_int <= codepoint &&
                            codepoint <= 0x10ffff as std::os::raw::c_int) as
                       std::os::raw::c_int
               } == 0 {
                return -ix
            }
            ix += 3 as std::os::raw::c_int
        } else if c as std::os::raw::c_int & 0xf8 as std::os::raw::c_int ==
                      0xf0 as std::os::raw::c_int {
            /* 4-byte code, starts with 11110 */
            if ix + 4 as std::os::raw::c_int > len {
                return if complete != 0 { -ix } else { ix }
            }
            if *utf.offset((ix + 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int &
                   0xc0 as std::os::raw::c_int != 0x80 as std::os::raw::c_int ||
                   *utf.offset((ix + 2 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                       0x80 as std::os::raw::c_int ||
                   *utf.offset((ix + 3 as std::os::raw::c_int) as isize) as
                       std::os::raw::c_int & 0xc0 as std::os::raw::c_int !=
                       0x80 as std::os::raw::c_int {
                return -ix
            }
            codepoint =
                (*utf.offset(ix as isize) as std::os::raw::c_int & 0x7 as std::os::raw::c_int)
                    << 18 as std::os::raw::c_int;
            codepoint |=
                (*utf.offset((ix + 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int
                     & 0x3f as std::os::raw::c_int) << 12 as std::os::raw::c_int;
            codepoint |=
                (*utf.offset((ix + 2 as std::os::raw::c_int) as isize) as std::os::raw::c_int
                     & 0x3f as std::os::raw::c_int) << 6 as std::os::raw::c_int;
            codepoint |=
                *utf.offset((ix + 3 as std::os::raw::c_int) as isize) as std::os::raw::c_int &
                    0x3f as std::os::raw::c_int;
            if if codepoint < 0x100 as std::os::raw::c_int {
                   (0x9 as std::os::raw::c_int <= codepoint &&
                        codepoint <= 0xa as std::os::raw::c_int ||
                        codepoint == 0xd as std::os::raw::c_int ||
                        0x20 as std::os::raw::c_int <= codepoint) as std::os::raw::c_int
               } else {
                   (0x100 as std::os::raw::c_int <= codepoint &&
                        codepoint <= 0xd7ff as std::os::raw::c_int ||
                        0xe000 as std::os::raw::c_int <= codepoint &&
                            codepoint <= 0xfffd as std::os::raw::c_int ||
                        0x10000 as std::os::raw::c_int <= codepoint &&
                            codepoint <= 0x10ffff as std::os::raw::c_int) as
                       std::os::raw::c_int
               } == 0 {
                return -ix
            }
            ix += 4 as std::os::raw::c_int
        } else { return -ix }
    }
    return ix;
}
/* *
 * xmlParseTryOrFinish:
 * @ctxt:  an XML parser context
 * @terminate:  last chunk indicator
 *
 * Try to progress on parsing
 *
 * Returns zero if no parsing was possible
 */
unsafe extern "C" fn xmlParseTryOrFinish(mut ctxt: xmlParserCtxtPtr,
                                         mut terminate: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut current_block: u64;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut avail: std::os::raw::c_int = 0;
    let mut tlen: std::os::raw::c_int = 0;
    let mut cur: xmlChar = 0;
    let mut next: xmlChar = 0;
    let mut lastlt: *const xmlChar = 0 as *const xmlChar;
    let mut lastgt: *const xmlChar = 0 as *const xmlChar;
    if (*ctxt).input.is_null() { return 0 as std::os::raw::c_int }
    if !(*ctxt).input.is_null() &&
           (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base) as
               std::os::raw::c_long > 4096 as std::os::raw::c_int as std::os::raw::c_long {
        xmlSHRINK(ctxt);
        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
    }
    xmlParseGetLasts(ctxt, &mut lastlt, &mut lastgt);
    loop  {
        if !((*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int)
           {
            current_block = 10600518110600957295;
            break ;
        }
        if (*ctxt).errNo != XML_ERR_OK as std::os::raw::c_int &&
               (*ctxt).disableSAX == 1 as std::os::raw::c_int {
            return 0 as std::os::raw::c_int
        }
        if (*ctxt).input.is_null() {
            current_block = 10600518110600957295;
            break ;
        }
        if (*(*ctxt).input).buf.is_null() {
            avail =
                ((*(*ctxt).input).length as std::os::raw::c_long -
                     (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                         as std::os::raw::c_long) as std::os::raw::c_int
        } else {
            /*
	     * If we are operating on converted input, try to flush
	     * remainng chars to avoid them stalling in the non-converted
	     * buffer. But do not do this in document start where
	     * encoding="..." may not have been read and we work on a
	     * guessed encoding.
	     */
            if (*ctxt).instate as std::os::raw::c_int !=
                   XML_PARSER_START as std::os::raw::c_int &&
                   !(*(*(*ctxt).input).buf).raw.is_null() &&
                   xmlBufIsEmpty((*(*(*ctxt).input).buf).raw) ==
                       0 as std::os::raw::c_int {
                let mut base: size_t =
                    xmlBufGetInputBase((*(*(*ctxt).input).buf).buffer,
                                       (*ctxt).input);
                let mut current: size_t =
                    (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                        as std::os::raw::c_long as size_t;
                xmlParserInputBufferPush((*(*ctxt).input).buf,
                                         0 as std::os::raw::c_int,
                                         b"\x00" as *const u8 as
                                             *const std::os::raw::c_char);
                xmlBufSetInputBaseCur((*(*(*ctxt).input).buf).buffer,
                                      (*ctxt).input, base, current);
            }
            avail =
                xmlBufUse((*(*(*ctxt).input).buf).buffer).wrapping_sub((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                                           as
                                                                           std::os::raw::c_long
                                                                           as
                                                                           std::os::raw::c_ulong)
                    as std::os::raw::c_int
        }
        if avail < 1 as std::os::raw::c_int {
            current_block = 10600518110600957295;
            break ;
        }
        match (*ctxt).instate as std::os::raw::c_int {
            -1 => { current_block = 10600518110600957295; break ; }
            0 => {
                if (*ctxt).charset == XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
                    let mut start: [xmlChar; 4] = [0; 4];
                    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
                    /*
		     * Very first chars read from the document flow.
		     */
                    if avail < 4 as std::os::raw::c_int {
                        current_block = 10600518110600957295;
                        break ;
                    }
                    /*
		     * Get the 4 first bytes and decode the charset
		     * if enc != XML_CHAR_ENCODING_NONE
		     * plug some encoding conversion routines,
		     * else xmlSwitchEncoding will set to (default)
		     * UTF8.
		     */
                    start[0 as std::os::raw::c_int as usize] = *(*(*ctxt).input).cur;
                    start[1 as std::os::raw::c_int as usize] =
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize);
                    start[2 as std::os::raw::c_int as usize] =
                        *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                         isize);
                    start[3 as std::os::raw::c_int as usize] =
                        *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                         isize);
                    enc =
                        xmlDetectCharEncoding(start.as_mut_ptr(),
                                              4 as std::os::raw::c_int);
                    xmlSwitchEncoding(ctxt, enc);
                } else {
                    if avail < 2 as std::os::raw::c_int {
                        current_block = 10600518110600957295;
                        break ;
                    }
                    cur =
                        *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as
                                                         isize);
                    next =
                        *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as
                                                         isize);
                    if cur as std::os::raw::c_int == 0 as std::os::raw::c_int {
                        if !(*ctxt).sax.is_null() &&
                               (*(*ctxt).sax).setDocumentLocator.is_some() {
                            (*(*ctxt).sax).setDocumentLocator.expect("non-null function pointer")((*ctxt).userData,
                                                                                                  __xmlDefaultSAXLocator());
                        }
                        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY,
                                    0 as *const std::os::raw::c_char);
                        xmlHaltParser(ctxt);
                        if !(*ctxt).sax.is_null() &&
                               (*(*ctxt).sax).endDocument.is_some() {
                            (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
                        }
                        current_block = 10600518110600957295;
                        break ;
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  next as std::os::raw::c_int == '?' as i32 {
                        /* PI or XML decl */
                        if avail < 5 as std::os::raw::c_int { return ret }
                        if terminate == 0 &&
                               xmlParseLookupSequence(ctxt,
                                                      '?' as i32 as xmlChar,
                                                      '>' as i32 as xmlChar,
                                                      0 as std::os::raw::c_int as
                                                          xmlChar) <
                                   0 as std::os::raw::c_int {
                            return ret
                        }
                        if !(*ctxt).sax.is_null() &&
                               (*(*ctxt).sax).setDocumentLocator.is_some() {
                            (*(*ctxt).sax).setDocumentLocator.expect("non-null function pointer")((*ctxt).userData,
                                                                                                  __xmlDefaultSAXLocator());
                        }
                        if *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                            isize) as
                               std::os::raw::c_int == 'x' as i32 &&
                               *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int
                                                                as isize) as
                                   std::os::raw::c_int == 'm' as i32 &&
                               *(*(*ctxt).input).cur.offset(4 as std::os::raw::c_int
                                                                as isize) as
                                   std::os::raw::c_int == 'l' as i32 &&
                               (*(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int
                                                                 as isize) as
                                    std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                                    0x9 as std::os::raw::c_int <=
                                        *(*(*ctxt).input).cur.offset(5 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                                            as std::os::raw::c_int &&
                                        *(*(*ctxt).input).cur.offset(5 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         isize)
                                            as std::os::raw::c_int <=
                                            0xa as std::os::raw::c_int ||
                                    *(*(*ctxt).input).cur.offset(5 as
                                                                     std::os::raw::c_int
                                                                     as isize)
                                        as std::os::raw::c_int == 0xd as std::os::raw::c_int)
                           {
                            ret += 5 as std::os::raw::c_int;
                            xmlParseXMLDecl(ctxt);
                            if (*ctxt).errNo ==
                                   XML_ERR_UNSUPPORTED_ENCODING as std::os::raw::c_int
                               {
                                /*
			     * The XML REC instructs us to stop parsing right
			     * here
			     */
                                xmlHaltParser(ctxt);
                                return 0 as std::os::raw::c_int
                            }
                            (*ctxt).standalone = (*(*ctxt).input).standalone;
                            if (*ctxt).encoding.is_null() &&
                                   !(*(*ctxt).input).encoding.is_null() {
                                (*ctxt).encoding =
                                    xmlStrdup((*(*ctxt).input).encoding)
                            }
                            if !(*ctxt).sax.is_null() &&
                                   (*(*ctxt).sax).startDocument.is_some() &&
                                   (*ctxt).disableSAX == 0 {
                                (*(*ctxt).sax).startDocument.expect("non-null function pointer")((*ctxt).userData);
                            }
                            (*ctxt).instate = XML_PARSER_MISC
                        } else {
                            (*ctxt).version =
                                xmlCharStrdup(b"1.0\x00" as *const u8 as
                                                  *const std::os::raw::c_char);
                            if !(*ctxt).sax.is_null() &&
                                   (*(*ctxt).sax).startDocument.is_some() &&
                                   (*ctxt).disableSAX == 0 {
                                (*(*ctxt).sax).startDocument.expect("non-null function pointer")((*ctxt).userData);
                            }
                            (*ctxt).instate = XML_PARSER_MISC
                        }
                    } else {
                        if !(*ctxt).sax.is_null() &&
                               (*(*ctxt).sax).setDocumentLocator.is_some() {
                            (*(*ctxt).sax).setDocumentLocator.expect("non-null function pointer")((*ctxt).userData,
                                                                                                  __xmlDefaultSAXLocator());
                        }
                        (*ctxt).version =
                            xmlCharStrdup(b"1.0\x00" as *const u8 as
                                              *const std::os::raw::c_char);
                        if (*ctxt).version.is_null() {
                            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
                        } else {
                            if !(*ctxt).sax.is_null() &&
                                   (*(*ctxt).sax).startDocument.is_some() &&
                                   (*ctxt).disableSAX == 0 {
                                (*(*ctxt).sax).startDocument.expect("non-null function pointer")((*ctxt).userData);
                            }
                            (*ctxt).instate = XML_PARSER_MISC
                        }
                    }
                }
            }
            6 => {
                let mut name: *const xmlChar = 0 as *const xmlChar;
                let mut prefix: *const xmlChar = 0 as *const xmlChar;
                let mut URI: *const xmlChar = 0 as *const xmlChar;
                let mut nsNr: std::os::raw::c_int = (*ctxt).nsNr;
                if avail < 2 as std::os::raw::c_int &&
                       (*ctxt).inputNr == 1 as std::os::raw::c_int {
                    current_block = 10600518110600957295;
                    break ;
                }
                cur = *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as isize);
                if cur as std::os::raw::c_int != '<' as i32 {
                    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY,
                                0 as *const std::os::raw::c_char);
                    xmlHaltParser(ctxt);
                    if !(*ctxt).sax.is_null() &&
                           (*(*ctxt).sax).endDocument.is_some() {
                        (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
                    }
                    current_block = 10600518110600957295;
                    break ;
                } else {
                    if terminate == 0 {
                        if (*ctxt).progressive != 0 {
                            /* > can be found unescaped in attribute values */
                            if lastgt.is_null() ||
                                   (*(*ctxt).input).cur >= lastgt {
                                current_block = 10600518110600957295;
                                break ;
                            }
                        } else if xmlParseLookupSequence(ctxt,
                                                         '>' as i32 as
                                                             xmlChar,
                                                         0 as std::os::raw::c_int as
                                                             xmlChar,
                                                         0 as std::os::raw::c_int as
                                                             xmlChar) <
                                      0 as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                    }
                    if (*ctxt).spaceNr == 0 as std::os::raw::c_int {
                        spacePush(ctxt, -(1 as std::os::raw::c_int));
                    } else if *(*ctxt).space == -(2 as std::os::raw::c_int) {
                        spacePush(ctxt, -(1 as std::os::raw::c_int));
                    } else { spacePush(ctxt, *(*ctxt).space); }
                    if (*ctxt).sax2 != 0 {
                        /* LIBXML_SAX1_ENABLED */
                        name =
                            xmlParseStartTag2(ctxt, &mut prefix, &mut URI,
                                              &mut tlen)
                    } else { name = xmlParseStartTag(ctxt) }
                    /* LIBXML_SAX1_ENABLED */
                    if (*ctxt).instate as std::os::raw::c_int ==
                           XML_PARSER_EOF as std::os::raw::c_int {
                        current_block = 10600518110600957295;
                        break ;
                    }
                    if name.is_null() {
                        spacePop(ctxt);
                        xmlHaltParser(ctxt);
                        if !(*ctxt).sax.is_null() &&
                               (*(*ctxt).sax).endDocument.is_some() {
                            (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
                        }
                        current_block = 10600518110600957295;
                        break ;
                    } else {
                        /*
		 * [ VC: Root Element Type ]
		 * The Name in the document type declaration must match
		 * the element type of the root element.
		 */
                        if (*ctxt).validate != 0 && (*ctxt).wellFormed != 0 &&
                               !(*ctxt).myDoc.is_null() &&
                               !(*ctxt).node.is_null() &&
                               (*ctxt).node == (*(*ctxt).myDoc).children {
                            (*ctxt).valid &=
                                xmlValidateRoot(&mut (*ctxt).vctxt,
                                                (*ctxt).myDoc)
                        }
                        /* LIBXML_VALID_ENABLED */
                        /*
		 * Check for an Empty Element.
		 */
                        if *(*(*ctxt).input).cur as std::os::raw::c_int == '/' as i32
                               &&
                               *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int
                                                                as isize) as
                                   std::os::raw::c_int == '>' as i32 {
                            (*ctxt).nbChars +=
                                2 as std::os::raw::c_int as std::os::raw::c_long;
                            (*(*ctxt).input).cur =
                                (*(*ctxt).input).cur.offset(2 as std::os::raw::c_int
                                                                as isize);
                            (*(*ctxt).input).col += 2 as std::os::raw::c_int;
                            if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                   0 as std::os::raw::c_int {
                                xmlParserInputGrow((*ctxt).input,
                                                   250 as std::os::raw::c_int);
                            }
                            if (*ctxt).sax2 != 0 {
                                if !(*ctxt).sax.is_null() &&
                                       (*(*ctxt).sax).endElementNs.is_some()
                                       && (*ctxt).disableSAX == 0 {
                                    (*(*ctxt).sax).endElementNs.expect("non-null function pointer")((*ctxt).userData,
                                                                                                    name,
                                                                                                    prefix,
                                                                                                    URI);
                                }
                                if (*ctxt).nsNr - nsNr > 0 as std::os::raw::c_int {
                                    nsPop(ctxt, (*ctxt).nsNr - nsNr);
                                }
                            } else if !(*ctxt).sax.is_null() &&
                                          (*(*ctxt).sax).endElement.is_some()
                                          && (*ctxt).disableSAX == 0 {
                                (*(*ctxt).sax).endElement.expect("non-null function pointer")((*ctxt).userData,
                                                                                              name);
                            }
                            if (*ctxt).instate as std::os::raw::c_int ==
                                   XML_PARSER_EOF as std::os::raw::c_int {
                                current_block = 10600518110600957295;
                                break ;
                            }
                            spacePop(ctxt);
                            if (*ctxt).nameNr == 0 as std::os::raw::c_int {
                                (*ctxt).instate = XML_PARSER_EPILOG
                            } else { (*ctxt).instate = XML_PARSER_CONTENT }
                            (*ctxt).progressive = 1 as std::os::raw::c_int
                        } else {
                            if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                   '>' as i32 {
                                xmlNextChar(ctxt);
                            } else {
                                xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,
                                                  b"Couldn\'t find end of Start Tag %s\n\x00"
                                                      as *const u8 as
                                                      *const std::os::raw::c_char,
                                                  name);
                                nodePop(ctxt);
                                spacePop(ctxt);
                            }
                            if (*ctxt).sax2 != 0 {
                                nameNsPush(ctxt, name, prefix, URI,
                                           (*ctxt).nsNr - nsNr);
                            } else { namePush(ctxt, name); }
                            /* LIBXML_SAX1_ENABLED */
                            /* LIBXML_SAX1_ENABLED */
                            (*ctxt).instate = XML_PARSER_CONTENT;
                            (*ctxt).progressive = 1 as std::os::raw::c_int
                        }
                    }
                }
            }
            7 => {
                let mut test: *const xmlChar = 0 as *const xmlChar;
                let mut cons: std::os::raw::c_uint = 0;
                if avail < 2 as std::os::raw::c_int &&
                       (*ctxt).inputNr == 1 as std::os::raw::c_int {
                    current_block = 10600518110600957295;
                    break ;
                }
                cur = *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as isize);
                next =
                    *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
                test = (*(*ctxt).input).cur;
                cons = (*(*ctxt).input).consumed as std::os::raw::c_uint;
                if cur as std::os::raw::c_int == '<' as i32 &&
                       next as std::os::raw::c_int == '/' as i32 {
                    (*ctxt).instate = XML_PARSER_END_TAG
                } else {
                    if cur as std::os::raw::c_int == '<' as i32 &&
                           next as std::os::raw::c_int == '?' as i32 {
                        if terminate == 0 &&
                               xmlParseLookupSequence(ctxt,
                                                      '?' as i32 as xmlChar,
                                                      '>' as i32 as xmlChar,
                                                      0 as std::os::raw::c_int as
                                                          xmlChar) <
                                   0 as std::os::raw::c_int {
                            (*ctxt).progressive =
                                XML_PARSER_PI as std::os::raw::c_int;
                            current_block = 10600518110600957295;
                            break ;
                        } else {
                            xmlParsePI(ctxt);
                            (*ctxt).instate = XML_PARSER_CONTENT;
                            (*ctxt).progressive = 1 as std::os::raw::c_int
                        }
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  next as std::os::raw::c_int != '!' as i32 {
                        (*ctxt).instate = XML_PARSER_START_TAG;
                        continue ;
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  next as std::os::raw::c_int == '!' as i32 &&
                                  *(*(*ctxt).input).cur.offset(2 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == '-' as i32 &&
                                  *(*(*ctxt).input).cur.offset(3 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == '-' as i32 {
                        let mut term: std::os::raw::c_int = 0;
                        if avail < 4 as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        (*(*ctxt).input).cur =
                            (*(*ctxt).input).cur.offset(4 as std::os::raw::c_int as
                                                            isize);
                        term =
                            xmlParseLookupSequence(ctxt,
                                                   '-' as i32 as xmlChar,
                                                   '-' as i32 as xmlChar,
                                                   '>' as i32 as xmlChar);
                        (*(*ctxt).input).cur =
                            (*(*ctxt).input).cur.offset(-(4 as std::os::raw::c_int as
                                                              isize));
                        if terminate == 0 && term < 0 as std::os::raw::c_int {
                            (*ctxt).progressive =
                                XML_PARSER_COMMENT as std::os::raw::c_int;
                            current_block = 10600518110600957295;
                            break ;
                        } else {
                            xmlParseComment(ctxt);
                            (*ctxt).instate = XML_PARSER_CONTENT;
                            (*ctxt).progressive = 1 as std::os::raw::c_int
                        }
                    } else if cur as std::os::raw::c_int == '<' as i32 &&
                                  *(*(*ctxt).input).cur.offset(1 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == '!' as i32 &&
                                  *(*(*ctxt).input).cur.offset(2 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == '[' as i32 &&
                                  *(*(*ctxt).input).cur.offset(3 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == 'C' as i32 &&
                                  *(*(*ctxt).input).cur.offset(4 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == 'D' as i32 &&
                                  *(*(*ctxt).input).cur.offset(5 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == 'A' as i32 &&
                                  *(*(*ctxt).input).cur.offset(6 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == 'T' as i32 &&
                                  *(*(*ctxt).input).cur.offset(7 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == 'A' as i32 &&
                                  *(*(*ctxt).input).cur.offset(8 as
                                                                   std::os::raw::c_int
                                                                   as isize)
                                      as std::os::raw::c_int == '[' as i32 {
                        (*ctxt).nbChars += 9 as std::os::raw::c_int as std::os::raw::c_long;
                        (*(*ctxt).input).cur =
                            (*(*ctxt).input).cur.offset(9 as std::os::raw::c_int as
                                                            isize);
                        (*(*ctxt).input).col += 9 as std::os::raw::c_int;
                        if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                            xmlParserInputGrow((*ctxt).input,
                                               250 as std::os::raw::c_int);
                        }
                        (*ctxt).instate = XML_PARSER_CDATA_SECTION;
                        continue ;
                    } else {
                        if cur as std::os::raw::c_int == '<' as i32 &&
                               next as std::os::raw::c_int == '!' as i32 &&
                               avail < 9 as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        if cur as std::os::raw::c_int == '&' as i32 {
                            if terminate == 0 &&
                                   xmlParseLookupSequence(ctxt,
                                                          ';' as i32 as
                                                              xmlChar,
                                                          0 as std::os::raw::c_int as
                                                              xmlChar,
                                                          0 as std::os::raw::c_int as
                                                              xmlChar) <
                                       0 as std::os::raw::c_int {
                                current_block = 10600518110600957295;
                                break ;
                            }
                            xmlParseReference(ctxt);
                        } else {
                            /* TODO Avoid the extra copy, handle directly !!! */
		    /*
		     * Goal of the following test is:
		     *  - minimize calls to the SAX 'character' callback
		     *    when they are mergeable
		     *  - handle an problem for isBlank when we only parse
		     *    a sequence of blank chars and the next one is
		     *    not available to check against '<' presence.
		     *  - tries to homogenize the differences in SAX
		     *    callbacks between the push and pull versions
		     *    of the parser.
		     */
                            if (*ctxt).inputNr == 1 as std::os::raw::c_int &&
                                   avail < 300 as std::os::raw::c_int {
                                if terminate == 0 {
                                    if (*ctxt).progressive != 0 {
                                        if lastlt.is_null() ||
                                               (*(*ctxt).input).cur > lastlt {
                                            current_block =
                                                10600518110600957295;
                                            break ;
                                        }
                                    } else if xmlParseLookupSequence(ctxt,
                                                                     '<' as
                                                                         i32
                                                                         as
                                                                         xmlChar,
                                                                     0 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         xmlChar,
                                                                     0 as
                                                                         std::os::raw::c_int
                                                                         as
                                                                         xmlChar)
                                                  < 0 as std::os::raw::c_int {
                                        current_block = 10600518110600957295;
                                        break ;
                                    }
                                }
                            }
                            (*ctxt).checkIndex =
                                0 as std::os::raw::c_int as std::os::raw::c_long;
                            xmlParseCharData(ctxt, 0 as std::os::raw::c_int);
                        }
                    }
                    if !(cons as std::os::raw::c_ulong == (*(*ctxt).input).consumed &&
                             test == (*(*ctxt).input).cur) {
                        continue ;
                    }
                    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                                b"detected an error in element content\n\x00"
                                    as *const u8 as *const std::os::raw::c_char);
                    xmlHaltParser(ctxt);
                }
            }
            9 => {
                if avail < 2 as std::os::raw::c_int {
                    current_block = 10600518110600957295;
                    break ;
                }
                if terminate == 0 {
                    if (*ctxt).progressive != 0 {
                        /* > can be found unescaped in attribute values */
                        if lastgt.is_null() || (*(*ctxt).input).cur >= lastgt
                           {
                            current_block = 10600518110600957295;
                            break ;
                        }
                    } else if xmlParseLookupSequence(ctxt,
                                                     '>' as i32 as xmlChar,
                                                     0 as std::os::raw::c_int as
                                                         xmlChar,
                                                     0 as std::os::raw::c_int as
                                                         xmlChar) <
                                  0 as std::os::raw::c_int {
                        current_block = 10600518110600957295;
                        break ;
                    }
                }
                if (*ctxt).sax2 != 0 {
                    xmlParseEndTag2(ctxt,
                                    *(*ctxt).pushTab.offset(((*ctxt).nameNr *
                                                                 3 as
                                                                     std::os::raw::c_int
                                                                 -
                                                                 3 as
                                                                     std::os::raw::c_int)
                                                                as isize) as
                                        *const xmlChar,
                                    *(*ctxt).pushTab.offset(((*ctxt).nameNr *
                                                                 3 as
                                                                     std::os::raw::c_int
                                                                 -
                                                                 2 as
                                                                     std::os::raw::c_int)
                                                                as isize) as
                                        *const xmlChar, 0 as std::os::raw::c_int,
                                    *(*ctxt).pushTab.offset(((*ctxt).nameNr *
                                                                 3 as
                                                                     std::os::raw::c_int
                                                                 -
                                                                 1 as
                                                                     std::os::raw::c_int)
                                                                as isize) as
                                        ptrdiff_t as std::os::raw::c_int,
                                    0 as std::os::raw::c_int);
                    nameNsPop(ctxt);
                } else { xmlParseEndTag1(ctxt, 0 as std::os::raw::c_int); }
                /* LIBXML_SAX1_ENABLED */
                if !((*ctxt).instate as std::os::raw::c_int ==
                         XML_PARSER_EOF as std::os::raw::c_int) {
                    if (*ctxt).nameNr == 0 as std::os::raw::c_int {
                        (*ctxt).instate = XML_PARSER_EPILOG
                    } else { (*ctxt).instate = XML_PARSER_CONTENT }
                }
            }
            8 => {
                /*
		 * The Push mode need to have the SAX callback for
		 * cdataBlock merge back contiguous callbacks.
		 */
                let mut base_0: std::os::raw::c_int = 0;
                base_0 =
                    xmlParseLookupSequence(ctxt, ']' as i32 as xmlChar,
                                           ']' as i32 as xmlChar,
                                           '>' as i32 as xmlChar);
                if base_0 < 0 as std::os::raw::c_int {
                    if !(avail >= 300 as std::os::raw::c_int + 2 as std::os::raw::c_int) {
                        current_block = 10600518110600957295;
                        break ;
                    }
                    let mut tmp: std::os::raw::c_int = 0;
                    tmp =
                        xmlCheckCdataPush((*(*ctxt).input).cur,
                                          300 as std::os::raw::c_int,
                                          0 as std::os::raw::c_int);
                    if tmp < 0 as std::os::raw::c_int {
                        tmp = -tmp;
                        (*(*ctxt).input).cur =
                            (*(*ctxt).input).cur.offset(tmp as isize);
                        current_block = 940383661390974020;
                        break ;
                    } else {
                        if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0 {
                            if (*(*ctxt).sax).cdataBlock.is_some() {
                                (*(*ctxt).sax).cdataBlock.expect("non-null function pointer")((*ctxt).userData,
                                                                                              (*(*ctxt).input).cur,
                                                                                              tmp);
                            } else if (*(*ctxt).sax).characters.is_some() {
                                (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                              (*(*ctxt).input).cur,
                                                                                              tmp);
                            }
                        }
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        let mut skipl: std::os::raw::c_int = 0;
                        skipl = 0 as std::os::raw::c_int;
                        while skipl < tmp {
                            if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                   '\n' as i32 {
                                (*(*ctxt).input).line += 1;
                                (*(*ctxt).input).col = 1 as std::os::raw::c_int
                            } else { (*(*ctxt).input).col += 1 }
                            (*ctxt).nbChars += 1;
                            (*(*ctxt).input).cur =
                                (*(*ctxt).input).cur.offset(1);
                            skipl += 1
                        }
                        if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                            xmlParserInputGrow((*ctxt).input,
                                               250 as std::os::raw::c_int);
                        }
                        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long;
                        current_block = 10600518110600957295;
                        break ;
                    }
                } else {
                    let mut tmp_0: std::os::raw::c_int = 0;
                    tmp_0 =
                        xmlCheckCdataPush((*(*ctxt).input).cur, base_0,
                                          1 as std::os::raw::c_int);
                    if tmp_0 < 0 as std::os::raw::c_int || tmp_0 != base_0 {
                        tmp_0 = -tmp_0;
                        (*(*ctxt).input).cur =
                            (*(*ctxt).input).cur.offset(tmp_0 as isize);
                        current_block = 940383661390974020;
                        break ;
                    } else {
                        if !(*ctxt).sax.is_null() &&
                               base_0 == 0 as std::os::raw::c_int &&
                               (*(*ctxt).sax).cdataBlock.is_some() &&
                               (*ctxt).disableSAX == 0 {
                            /*
			 * Special case to provide identical behaviour
			 * between pull and push parsers on enpty CDATA
			 * sections
			 */
                            if (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                   as std::os::raw::c_long >=
                                   9 as std::os::raw::c_int as std::os::raw::c_long &&
                                   strncmp(&*(*(*ctxt).input).cur.offset(-(9
                                                                               as
                                                                               std::os::raw::c_int)
                                                                             as
                                                                             isize)
                                               as *const xmlChar as
                                               *const std::os::raw::c_char,
                                           b"<![CDATA[\x00" as *const u8 as
                                               *const std::os::raw::c_char,
                                           9 as std::os::raw::c_int as std::os::raw::c_ulong)
                                       == 0 {
                                (*(*ctxt).sax).cdataBlock.expect("non-null function pointer")((*ctxt).userData,
                                                                                              b"\x00"
                                                                                                  as
                                                                                                  *const u8
                                                                                                  as
                                                                                                  *const std::os::raw::c_char
                                                                                                  as
                                                                                                  *mut xmlChar,
                                                                                              0
                                                                                                  as
                                                                                                  std::os::raw::c_int);
                            }
                        } else if !(*ctxt).sax.is_null() &&
                                      base_0 > 0 as std::os::raw::c_int &&
                                      (*ctxt).disableSAX == 0 {
                            if (*(*ctxt).sax).cdataBlock.is_some() {
                                (*(*ctxt).sax).cdataBlock.expect("non-null function pointer")((*ctxt).userData,
                                                                                              (*(*ctxt).input).cur,
                                                                                              base_0);
                            } else if (*(*ctxt).sax).characters.is_some() {
                                (*(*ctxt).sax).characters.expect("non-null function pointer")((*ctxt).userData,
                                                                                              (*(*ctxt).input).cur,
                                                                                              base_0);
                            }
                        }
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        let mut skipl_0: std::os::raw::c_int = 0;
                        skipl_0 = 0 as std::os::raw::c_int;
                        while skipl_0 < base_0 + 3 as std::os::raw::c_int {
                            if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                                   '\n' as i32 {
                                (*(*ctxt).input).line += 1;
                                (*(*ctxt).input).col = 1 as std::os::raw::c_int
                            } else { (*(*ctxt).input).col += 1 }
                            (*ctxt).nbChars += 1;
                            (*(*ctxt).input).cur =
                                (*(*ctxt).input).cur.offset(1);
                            skipl_0 += 1
                        }
                        if *(*(*ctxt).input).cur as std::os::raw::c_int ==
                               0 as std::os::raw::c_int {
                            xmlParserInputGrow((*ctxt).input,
                                               250 as std::os::raw::c_int);
                        }
                        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long;
                        (*ctxt).instate = XML_PARSER_CONTENT
                    }
                }
            }
            1 => {
                xmlSkipBlankChars(ctxt);
                if (*(*ctxt).input).buf.is_null() {
                    avail =
                        ((*(*ctxt).input).length as std::os::raw::c_long -
                             (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                 as std::os::raw::c_long) as std::os::raw::c_int
                } else {
                    avail =
                        xmlBufUse((*(*(*ctxt).input).buf).buffer).wrapping_sub((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                                                   as
                                                                                   std::os::raw::c_long
                                                                                   as
                                                                                   std::os::raw::c_ulong)
                            as std::os::raw::c_int
                }
                if avail < 2 as std::os::raw::c_int {
                    current_block = 10600518110600957295;
                    break ;
                }
                cur = *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as isize);
                next =
                    *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
                if cur as std::os::raw::c_int == '<' as i32 &&
                       next as std::os::raw::c_int == '?' as i32 {
                    if terminate == 0 &&
                           xmlParseLookupSequence(ctxt, '?' as i32 as xmlChar,
                                                  '>' as i32 as xmlChar,
                                                  0 as std::os::raw::c_int as xmlChar)
                               < 0 as std::os::raw::c_int {
                        (*ctxt).progressive = XML_PARSER_PI as std::os::raw::c_int;
                        current_block = 10600518110600957295;
                        break ;
                    } else {
                        xmlParsePI(ctxt);
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        (*ctxt).instate = XML_PARSER_MISC;
                        (*ctxt).progressive = 1 as std::os::raw::c_int;
                        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                    }
                } else if cur as std::os::raw::c_int == '<' as i32 &&
                              next as std::os::raw::c_int == '!' as i32 &&
                              *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == '-' as i32 &&
                              *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == '-' as i32 {
                    if terminate == 0 &&
                           xmlParseLookupSequence(ctxt, '-' as i32 as xmlChar,
                                                  '-' as i32 as xmlChar,
                                                  '>' as i32 as xmlChar) <
                               0 as std::os::raw::c_int {
                        (*ctxt).progressive =
                            XML_PARSER_COMMENT as std::os::raw::c_int;
                        current_block = 10600518110600957295;
                        break ;
                    } else {
                        xmlParseComment(ctxt);
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        (*ctxt).instate = XML_PARSER_MISC;
                        (*ctxt).progressive = 1 as std::os::raw::c_int;
                        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                    }
                } else if cur as std::os::raw::c_int == '<' as i32 &&
                              next as std::os::raw::c_int == '!' as i32 &&
                              *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == 'D' as i32 &&
                              *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == 'O' as i32 &&
                              *(*(*ctxt).input).cur.offset(4 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == 'C' as i32 &&
                              *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == 'T' as i32 &&
                              *(*(*ctxt).input).cur.offset(6 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == 'Y' as i32 &&
                              *(*(*ctxt).input).cur.offset(7 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == 'P' as i32 &&
                              *(*(*ctxt).input).cur.offset(8 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == 'E' as i32 {
                    if terminate == 0 &&
                           xmlParseLookupSequence(ctxt, '>' as i32 as xmlChar,
                                                  0 as std::os::raw::c_int as xmlChar,
                                                  0 as std::os::raw::c_int as xmlChar)
                               < 0 as std::os::raw::c_int {
                        (*ctxt).progressive = XML_PARSER_DTD as std::os::raw::c_int;
                        current_block = 10600518110600957295;
                        break ;
                    } else {
                        (*ctxt).inSubset = 1 as std::os::raw::c_int;
                        (*ctxt).progressive = 0 as std::os::raw::c_int;
                        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long;
                        xmlParseDocTypeDecl(ctxt);
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        if *(*(*ctxt).input).cur as std::os::raw::c_int == '[' as i32
                           {
                            (*ctxt).instate = XML_PARSER_DTD
                        } else {
                            /*
			 * Create and update the external subset.
			 */
                            (*ctxt).inSubset = 2 as std::os::raw::c_int;
                            if !(*ctxt).sax.is_null() &&
                                   (*ctxt).disableSAX == 0 &&
                                   (*(*ctxt).sax).externalSubset.is_some() {
                                (*(*ctxt).sax).externalSubset.expect("non-null function pointer")((*ctxt).userData,
                                                                                                  (*ctxt).intSubName,
                                                                                                  (*ctxt).extSubSystem,
                                                                                                  (*ctxt).extSubURI);
                            }
                            (*ctxt).inSubset = 0 as std::os::raw::c_int;
                            xmlCleanSpecialAttr(ctxt);
                            (*ctxt).instate = XML_PARSER_PROLOG
                        }
                    }
                } else {
                    if cur as std::os::raw::c_int == '<' as i32 &&
                           next as std::os::raw::c_int == '!' as i32 &&
                           avail < 9 as std::os::raw::c_int {
                        current_block = 10600518110600957295;
                        break ;
                    }
                    (*ctxt).instate = XML_PARSER_START_TAG;
                    (*ctxt).progressive = XML_PARSER_START_TAG as std::os::raw::c_int;
                    xmlParseGetLasts(ctxt, &mut lastlt, &mut lastgt);
                }
            }
            4 => {
                xmlSkipBlankChars(ctxt);
                if (*(*ctxt).input).buf.is_null() {
                    avail =
                        ((*(*ctxt).input).length as std::os::raw::c_long -
                             (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                 as std::os::raw::c_long) as std::os::raw::c_int
                } else {
                    avail =
                        xmlBufUse((*(*(*ctxt).input).buf).buffer).wrapping_sub((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                                                   as
                                                                                   std::os::raw::c_long
                                                                                   as
                                                                                   std::os::raw::c_ulong)
                            as std::os::raw::c_int
                }
                if avail < 2 as std::os::raw::c_int {
                    current_block = 10600518110600957295;
                    break ;
                }
                cur = *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as isize);
                next =
                    *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
                if cur as std::os::raw::c_int == '<' as i32 &&
                       next as std::os::raw::c_int == '?' as i32 {
                    if terminate == 0 &&
                           xmlParseLookupSequence(ctxt, '?' as i32 as xmlChar,
                                                  '>' as i32 as xmlChar,
                                                  0 as std::os::raw::c_int as xmlChar)
                               < 0 as std::os::raw::c_int {
                        (*ctxt).progressive = XML_PARSER_PI as std::os::raw::c_int;
                        current_block = 10600518110600957295;
                        break ;
                    } else {
                        xmlParsePI(ctxt);
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        (*ctxt).instate = XML_PARSER_PROLOG;
                        (*ctxt).progressive = 1 as std::os::raw::c_int
                    }
                } else if cur as std::os::raw::c_int == '<' as i32 &&
                              next as std::os::raw::c_int == '!' as i32 &&
                              *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == '-' as i32 &&
                              *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == '-' as i32 {
                    if terminate == 0 &&
                           xmlParseLookupSequence(ctxt, '-' as i32 as xmlChar,
                                                  '-' as i32 as xmlChar,
                                                  '>' as i32 as xmlChar) <
                               0 as std::os::raw::c_int {
                        (*ctxt).progressive =
                            XML_PARSER_COMMENT as std::os::raw::c_int;
                        current_block = 10600518110600957295;
                        break ;
                    } else {
                        xmlParseComment(ctxt);
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        (*ctxt).instate = XML_PARSER_PROLOG;
                        (*ctxt).progressive = 1 as std::os::raw::c_int
                    }
                } else {
                    if cur as std::os::raw::c_int == '<' as i32 &&
                           next as std::os::raw::c_int == '!' as i32 &&
                           avail < 4 as std::os::raw::c_int {
                        current_block = 10600518110600957295;
                        break ;
                    }
                    (*ctxt).instate = XML_PARSER_START_TAG;
                    if (*ctxt).progressive == 0 as std::os::raw::c_int {
                        (*ctxt).progressive =
                            XML_PARSER_START_TAG as std::os::raw::c_int
                    }
                    xmlParseGetLasts(ctxt, &mut lastlt, &mut lastgt);
                }
            }
            14 => {
                xmlSkipBlankChars(ctxt);
                if (*(*ctxt).input).buf.is_null() {
                    avail =
                        ((*(*ctxt).input).length as std::os::raw::c_long -
                             (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                 as std::os::raw::c_long) as std::os::raw::c_int
                } else {
                    avail =
                        xmlBufUse((*(*(*ctxt).input).buf).buffer).wrapping_sub((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                                                   as
                                                                                   std::os::raw::c_long
                                                                                   as
                                                                                   std::os::raw::c_ulong)
                            as std::os::raw::c_int
                }
                if avail < 2 as std::os::raw::c_int {
                    current_block = 10600518110600957295;
                    break ;
                }
                cur = *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as isize);
                next =
                    *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
                if cur as std::os::raw::c_int == '<' as i32 &&
                       next as std::os::raw::c_int == '?' as i32 {
                    if terminate == 0 &&
                           xmlParseLookupSequence(ctxt, '?' as i32 as xmlChar,
                                                  '>' as i32 as xmlChar,
                                                  0 as std::os::raw::c_int as xmlChar)
                               < 0 as std::os::raw::c_int {
                        (*ctxt).progressive = XML_PARSER_PI as std::os::raw::c_int;
                        current_block = 10600518110600957295;
                        break ;
                    } else {
                        xmlParsePI(ctxt);
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        (*ctxt).instate = XML_PARSER_EPILOG;
                        (*ctxt).progressive = 1 as std::os::raw::c_int
                    }
                } else if cur as std::os::raw::c_int == '<' as i32 &&
                              next as std::os::raw::c_int == '!' as i32 &&
                              *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == '-' as i32 &&
                              *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as
                                                               isize) as
                                  std::os::raw::c_int == '-' as i32 {
                    if terminate == 0 &&
                           xmlParseLookupSequence(ctxt, '-' as i32 as xmlChar,
                                                  '-' as i32 as xmlChar,
                                                  '>' as i32 as xmlChar) <
                               0 as std::os::raw::c_int {
                        (*ctxt).progressive =
                            XML_PARSER_COMMENT as std::os::raw::c_int;
                        current_block = 10600518110600957295;
                        break ;
                    } else {
                        xmlParseComment(ctxt);
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        (*ctxt).instate = XML_PARSER_EPILOG;
                        (*ctxt).progressive = 1 as std::os::raw::c_int
                    }
                } else {
                    if cur as std::os::raw::c_int == '<' as i32 &&
                           next as std::os::raw::c_int == '!' as i32 &&
                           avail < 4 as std::os::raw::c_int {
                        current_block = 10600518110600957295;
                        break ;
                    }
                    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END,
                                0 as *const std::os::raw::c_char);
                    xmlHaltParser(ctxt);
                    if !(*ctxt).sax.is_null() &&
                           (*(*ctxt).sax).endDocument.is_some() {
                        (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
                    }
                    current_block = 10600518110600957295;
                    break ;
                }
            }
            3 => {
                /*
		 * Sorry but progressive parsing of the internal subset
		 * is not expected to be supported. We first check that
		 * the full content of the internal subset is available and
		 * the parsing is launched only at that point.
		 * Internal subset ends up with "']' S? '>'" in an unescaped
		 * section and not in a ']]>' sequence which are conditional
		 * sections (whoever argued to keep that crap in XML deserve
		 * a place in hell !).
		 */
                let mut base_1: std::os::raw::c_int = 0;
                let mut i: std::os::raw::c_int = 0;
                let mut buf: *mut xmlChar = 0 as *mut xmlChar;
                let mut quote: xmlChar = 0 as std::os::raw::c_int as xmlChar;
                let mut use_0: size_t = 0;
                base_1 =
                    (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                        as std::os::raw::c_long as std::os::raw::c_int;
                if base_1 < 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
                if (*ctxt).checkIndex > base_1 as std::os::raw::c_long {
                    base_1 = (*ctxt).checkIndex as std::os::raw::c_int
                }
                buf =
                    xmlBufContent((*(*(*ctxt).input).buf).buffer as
                                      *const xmlBuf);
                use_0 = xmlBufUse((*(*(*ctxt).input).buf).buffer);
                's_1960:
                    loop  {
                        if !((base_1 as std::os::raw::c_uint as std::os::raw::c_ulong) <
                                 use_0) {
                            current_block = 12222138187225603145;
                            break ;
                        }
                        if quote as std::os::raw::c_int != 0 as std::os::raw::c_int {
                            if *buf.offset(base_1 as isize) as std::os::raw::c_int ==
                                   quote as std::os::raw::c_int {
                                quote = 0 as std::os::raw::c_int as xmlChar
                            }
                        } else {
                            if quote as std::os::raw::c_int == 0 as std::os::raw::c_int &&
                                   *buf.offset(base_1 as isize) as std::os::raw::c_int
                                       == '<' as i32 {
                                let mut found: std::os::raw::c_int = 0 as std::os::raw::c_int;
                                /* special handling of comments */
                                if ((base_1 as
                                         std::os::raw::c_uint).wrapping_add(4 as
                                                                        std::os::raw::c_int
                                                                        as
                                                                        std::os::raw::c_uint)
                                        as std::os::raw::c_ulong) < use_0 &&
                                       *buf.offset((base_1 + 1 as std::os::raw::c_int)
                                                       as isize) as
                                           std::os::raw::c_int == '!' as i32 &&
                                       *buf.offset((base_1 + 2 as std::os::raw::c_int)
                                                       as isize) as
                                           std::os::raw::c_int == '-' as i32 &&
                                       *buf.offset((base_1 + 3 as std::os::raw::c_int)
                                                       as isize) as
                                           std::os::raw::c_int == '-' as i32 {
                                    while ((base_1 as
                                                std::os::raw::c_uint).wrapping_add(3
                                                                               as
                                                                               std::os::raw::c_int
                                                                               as
                                                                               std::os::raw::c_uint)
                                               as std::os::raw::c_ulong) < use_0 {
                                        if *buf.offset(base_1 as isize) as
                                               std::os::raw::c_int == '-' as i32 &&
                                               *buf.offset((base_1 +
                                                                1 as
                                                                    std::os::raw::c_int)
                                                               as isize) as
                                                   std::os::raw::c_int == '-' as i32
                                               &&
                                               *buf.offset((base_1 +
                                                                2 as
                                                                    std::os::raw::c_int)
                                                               as isize) as
                                                   std::os::raw::c_int == '>' as i32 {
                                            found = 1 as std::os::raw::c_int;
                                            base_1 += 2 as std::os::raw::c_int;
                                            break ;
                                        } else { base_1 += 1 }
                                    }
                                    if found == 0 {
                                        current_block = 12222138187225603145;
                                        break ;
                                    }
                                    current_block = 10637788488912693274;
                                } else {
                                    current_block = 12839741003815810352;
                                }
                            } else { current_block = 12839741003815810352; }
                            match current_block {
                                10637788488912693274 => { }
                                _ => {
                                    if *buf.offset(base_1 as isize) as
                                           std::os::raw::c_int == '\"' as i32 {
                                        quote = '\"' as i32 as xmlChar
                                    } else if *buf.offset(base_1 as isize) as
                                                  std::os::raw::c_int == '\'' as i32 {
                                        quote = '\'' as i32 as xmlChar
                                    } else if *buf.offset(base_1 as isize) as
                                                  std::os::raw::c_int == ']' as i32 {
                                        if (base_1 as
                                                std::os::raw::c_uint).wrapping_add(1
                                                                               as
                                                                               std::os::raw::c_int
                                                                               as
                                                                               std::os::raw::c_uint)
                                               as std::os::raw::c_ulong >= use_0 {
                                            current_block =
                                                12222138187225603145;
                                            break ;
                                        }
                                        if *buf.offset((base_1 +
                                                            1 as std::os::raw::c_int)
                                                           as isize) as
                                               std::os::raw::c_int == ']' as i32 {
                                            /* conditional crap, skip both ']' ! */
                                            base_1 += 1
                                        } else {
                                            i = 1 as std::os::raw::c_int;
                                            loop  {
                                                if !(((base_1 as
                                                           std::os::raw::c_uint).wrapping_add(i
                                                                                          as
                                                                                          std::os::raw::c_uint)
                                                          as std::os::raw::c_ulong) <
                                                         use_0) {
                                                    current_block =
                                                        12222138187225603145;
                                                    break 's_1960 ;
                                                }
                                                if *buf.offset((base_1 + i) as
                                                                   isize) as
                                                       std::os::raw::c_int ==
                                                       '>' as i32 {
                                                    current_block =
                                                        14312436259099301365;
                                                    break 's_1960 ;
                                                }
                                                if !(*buf.offset((base_1 + i)
                                                                     as isize)
                                                         as std::os::raw::c_int ==
                                                         0x20 as std::os::raw::c_int
                                                         ||
                                                         0x9 as std::os::raw::c_int <=
                                                             *buf.offset((base_1
                                                                              +
                                                                              i)
                                                                             as
                                                                             isize)
                                                                 as
                                                                 std::os::raw::c_int
                                                             &&
                                                             *buf.offset((base_1
                                                                              +
                                                                              i)
                                                                             as
                                                                             isize)
                                                                 as
                                                                 std::os::raw::c_int
                                                                 <=
                                                                 0xa as
                                                                     std::os::raw::c_int
                                                         ||
                                                         *buf.offset((base_1 +
                                                                          i)
                                                                         as
                                                                         isize)
                                                             as std::os::raw::c_int ==
                                                             0xd as
                                                                 std::os::raw::c_int)
                                                   {
                                                    break ;
                                                }
                                                i += 1
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        base_1 += 1
                        /* for */
                    }
                match current_block {
                    12222138187225603145 => {
                        /* for */
                        if quote as std::os::raw::c_int == 0 as std::os::raw::c_int {
                            (*ctxt).checkIndex = base_1 as std::os::raw::c_long
                        } else {
                            (*ctxt).checkIndex =
                                0 as std::os::raw::c_int as std::os::raw::c_long
                        }
                        current_block = 10600518110600957295;
                        break ;
                    }
                    _ => {
                        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long;
                        xmlParseInternalSubset(ctxt);
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        (*ctxt).inSubset = 2 as std::os::raw::c_int;
                        if !(*ctxt).sax.is_null() && (*ctxt).disableSAX == 0
                               && (*(*ctxt).sax).externalSubset.is_some() {
                            (*(*ctxt).sax).externalSubset.expect("non-null function pointer")((*ctxt).userData,
                                                                                              (*ctxt).intSubName,
                                                                                              (*ctxt).extSubSystem,
                                                                                              (*ctxt).extSubURI);
                        }
                        (*ctxt).inSubset = 0 as std::os::raw::c_int;
                        xmlCleanSpecialAttr(ctxt);
                        if (*ctxt).instate as std::os::raw::c_int ==
                               XML_PARSER_EOF as std::os::raw::c_int {
                            current_block = 10600518110600957295;
                            break ;
                        }
                        (*ctxt).instate = XML_PARSER_PROLOG;
                        (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long
                    }
                }
            }
            5 => {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"PP: internal error, state == COMMENT\n\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char);
                (*ctxt).instate = XML_PARSER_CONTENT
            }
            15 => {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"PP: internal error, state == IGNORE\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char);
                (*ctxt).instate = XML_PARSER_DTD
            }
            2 => {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"PP: internal error, state == PI\n\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char);
                (*ctxt).instate = XML_PARSER_CONTENT
            }
            10 => {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"PP: internal error, state == ENTITY_DECL\n\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char);
                (*ctxt).instate = XML_PARSER_DTD
            }
            11 => {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"PP: internal error, state == ENTITY_VALUE\n\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char);
                (*ctxt).instate = XML_PARSER_CONTENT
            }
            12 => {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"PP: internal error, state == ATTRIBUTE_VALUE\n\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char);
                (*ctxt).instate = XML_PARSER_START_TAG
            }
            13 => {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"PP: internal error, state == SYSTEM_LITERAL\n\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char);
                (*ctxt).instate = XML_PARSER_START_TAG
            }
            16 => {
                (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                           b"PP: internal error, state == PUBLIC_LITERAL\n\x00"
                                                                               as
                                                                               *const u8
                                                                               as
                                                                               *const std::os::raw::c_char);
                (*ctxt).instate = XML_PARSER_START_TAG
            }
            _ => { }
        }
    }
    match current_block {
        10600518110600957295 =>
        /*
		 * We didn't found the end of the Internal subset
		 */
        /*
		 * Document parsing is done !
		 */
        {
            return ret
        }
        _ => {
            let mut buffer: [std::os::raw::c_char; 150] = [0; 150];
            snprintf(buffer.as_mut_ptr(), 149 as std::os::raw::c_int as std::os::raw::c_ulong,
                     b"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n\x00" as *const u8
                         as *const std::os::raw::c_char,
                     *(*(*ctxt).input).cur.offset(0 as std::os::raw::c_int as isize)
                         as std::os::raw::c_int,
                     *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize)
                         as std::os::raw::c_int,
                     *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize)
                         as std::os::raw::c_int,
                     *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize)
                         as std::os::raw::c_int);
            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
                             b"Input is not proper UTF-8, indicate encoding !\n%s\x00"
                                 as *const u8 as *const std::os::raw::c_char,
                             buffer.as_mut_ptr() as *mut xmlChar,
                             0 as *const xmlChar);
            return 0 as std::os::raw::c_int
        }
    };
}
/* *
 * xmlParseCheckTransition:
 * @ctxt:  an XML parser context
 * @chunk:  a char array
 * @size:  the size in byte of the chunk
 *
 * Check depending on the current parser state if the chunk given must be
 * processed immediately or one need more data to advance on parsing.
 *
 * Returns -1 in case of error, 0 if the push is not needed and 1 if needed
 */
unsafe extern "C" fn xmlParseCheckTransition(mut ctxt: xmlParserCtxtPtr,
                                             mut chunk: *const std::os::raw::c_char,
                                             mut size: std::os::raw::c_int)
 -> std::os::raw::c_int {
    if ctxt.is_null() || chunk.is_null() || size < 0 as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_START_TAG as std::os::raw::c_int {
        if !memchr(chunk as *const std::os::raw::c_void, '>' as i32,
                   size as std::os::raw::c_ulong).is_null() {
            return 1 as std::os::raw::c_int
        }
        return 0 as std::os::raw::c_int
    }
    if (*ctxt).progressive == XML_PARSER_COMMENT as std::os::raw::c_int {
        if !memchr(chunk as *const std::os::raw::c_void, '>' as i32,
                   size as std::os::raw::c_ulong).is_null() {
            return 1 as std::os::raw::c_int
        }
        return 0 as std::os::raw::c_int
    }
    if (*ctxt).instate as std::os::raw::c_int ==
           XML_PARSER_CDATA_SECTION as std::os::raw::c_int {
        if !memchr(chunk as *const std::os::raw::c_void, '>' as i32,
                   size as std::os::raw::c_ulong).is_null() {
            return 1 as std::os::raw::c_int
        }
        return 0 as std::os::raw::c_int
    }
    if (*ctxt).progressive == XML_PARSER_PI as std::os::raw::c_int {
        if !memchr(chunk as *const std::os::raw::c_void, '>' as i32,
                   size as std::os::raw::c_ulong).is_null() {
            return 1 as std::os::raw::c_int
        }
        return 0 as std::os::raw::c_int
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_END_TAG as std::os::raw::c_int {
        if !memchr(chunk as *const std::os::raw::c_void, '>' as i32,
                   size as std::os::raw::c_ulong).is_null() {
            return 1 as std::os::raw::c_int
        }
        return 0 as std::os::raw::c_int
    }
    if (*ctxt).progressive == XML_PARSER_DTD as std::os::raw::c_int ||
           (*ctxt).instate as std::os::raw::c_int == XML_PARSER_DTD as std::os::raw::c_int {
        if !memchr(chunk as *const std::os::raw::c_void, '>' as i32,
                   size as std::os::raw::c_ulong).is_null() {
            return 1 as std::os::raw::c_int
        }
        return 0 as std::os::raw::c_int
    }
    return 1 as std::os::raw::c_int;
}
/* *
 * xmlParseChunk:
 * @ctxt:  an XML parser context
 * @chunk:  an char array
 * @size:  the size in byte of the chunk
 * @terminate:  last chunk indicator
 *
 * Parse a Chunk of memory
 *
 * Returns zero if no error, the xmlParserErrors otherwise.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseChunk(mut ctxt: xmlParserCtxtPtr,
                                       mut chunk: *const std::os::raw::c_char,
                                       mut size: std::os::raw::c_int,
                                       mut terminate: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut end_in_lf: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut remain: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut old_avail: size_t = 0 as std::os::raw::c_int as size_t;
    let mut avail: size_t = 0 as std::os::raw::c_int as size_t;
    if ctxt.is_null() { return XML_ERR_INTERNAL_ERROR as std::os::raw::c_int }
    if (*ctxt).errNo != XML_ERR_OK as std::os::raw::c_int &&
           (*ctxt).disableSAX == 1 as std::os::raw::c_int {
        return (*ctxt).errNo
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
        return -(1 as std::os::raw::c_int)
    }
    if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_START as std::os::raw::c_int {
        xmlDetectSAX2(ctxt);
    }
    if size > 0 as std::os::raw::c_int && !chunk.is_null() && terminate == 0 &&
           *chunk.offset((size - 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int ==
               '\r' as i32 {
        end_in_lf = 1 as std::os::raw::c_int;
        size -= 1
    }
    loop  {
        if size > 0 as std::os::raw::c_int && !chunk.is_null() &&
               !(*ctxt).input.is_null() && !(*(*ctxt).input).buf.is_null() &&
               (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int
           {
            let mut base: size_t =
                xmlBufGetInputBase((*(*(*ctxt).input).buf).buffer,
                                   (*ctxt).input);
            let mut cur: size_t =
                (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                    as std::os::raw::c_long as size_t;
            let mut res: std::os::raw::c_int = 0;
            old_avail = xmlBufUse((*(*(*ctxt).input).buf).buffer);
            /*
         * Specific handling if we autodetected an encoding, we should not
         * push more than the first line ... which depend on the encoding
         * And only push the rest once the final encoding was detected
         */
            if (*ctxt).instate as std::os::raw::c_int ==
                   XML_PARSER_START as std::os::raw::c_int && !(*ctxt).input.is_null()
                   && !(*(*ctxt).input).buf.is_null() &&
                   !(*(*(*ctxt).input).buf).encoder.is_null() {
                let mut len: std::os::raw::c_uint = 45 as std::os::raw::c_int as std::os::raw::c_uint;
                if !xmlStrcasestr((*(*(*(*ctxt).input).buf).encoder).name as
                                      *mut xmlChar,
                                  b"UTF-16\x00" as *const u8 as
                                      *const std::os::raw::c_char as
                                      *mut xmlChar).is_null() ||
                       !xmlStrcasestr((*(*(*(*ctxt).input).buf).encoder).name
                                          as *mut xmlChar,
                                      b"UTF16\x00" as *const u8 as
                                          *const std::os::raw::c_char as
                                          *mut xmlChar).is_null() {
                    len = 90 as std::os::raw::c_int as std::os::raw::c_uint
                } else if !xmlStrcasestr((*(*(*(*ctxt).input).buf).encoder).name
                                             as *mut xmlChar,
                                         b"UCS-4\x00" as *const u8 as
                                             *const std::os::raw::c_char as
                                             *mut xmlChar).is_null() ||
                              !xmlStrcasestr((*(*(*(*ctxt).input).buf).encoder).name
                                                 as *mut xmlChar,
                                             b"UCS4\x00" as *const u8 as
                                                 *const std::os::raw::c_char as
                                                 *mut xmlChar).is_null() {
                    len = 180 as std::os::raw::c_int as std::os::raw::c_uint
                }
                if (*(*(*ctxt).input).buf).rawconsumed < len as std::os::raw::c_ulong
                   {
                    len =
                        (len as
                             std::os::raw::c_ulong).wrapping_sub((*(*(*ctxt).input).buf).rawconsumed)
                            as std::os::raw::c_uint as std::os::raw::c_uint
                }
                /*
             * Change size for reading the initial declaration only
             * if size is greater than len. Otherwise, memmove in xmlBufferAdd
             * will blindly copy extra bytes from memory.
             */
                if size as std::os::raw::c_uint > len {
                    remain =
                        (size as std::os::raw::c_uint).wrapping_sub(len) as
                            std::os::raw::c_int;
                    size = len as std::os::raw::c_int
                } else { remain = 0 as std::os::raw::c_int }
            }
            res = xmlParserInputBufferPush((*(*ctxt).input).buf, size, chunk);
            if res < 0 as std::os::raw::c_int {
                (*ctxt).errNo = XML_PARSER_EOF as std::os::raw::c_int;
                xmlHaltParser(ctxt);
                return XML_PARSER_EOF as std::os::raw::c_int
            }
            xmlBufSetInputBaseCur((*(*(*ctxt).input).buf).buffer,
                                  (*ctxt).input, base, cur);
        } else if (*ctxt).instate as std::os::raw::c_int !=
                      XML_PARSER_EOF as std::os::raw::c_int {
            if !(*ctxt).input.is_null() && !(*(*ctxt).input).buf.is_null() {
                let mut in_0: xmlParserInputBufferPtr = (*(*ctxt).input).buf;
                if !(*in_0).encoder.is_null() && !(*in_0).buffer.is_null() &&
                       !(*in_0).raw.is_null() {
                    let mut nbchars: std::os::raw::c_int = 0;
                    let mut base_0: size_t =
                        xmlBufGetInputBase((*in_0).buffer, (*ctxt).input);
                    let mut current: size_t =
                        (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                            as std::os::raw::c_long as size_t;
                    nbchars = xmlCharEncInput(in_0, terminate);
                    if nbchars < 0 as std::os::raw::c_int {
                        /* TODO 2.6.0 */
                        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                                   b"xmlParseChunk: encoder error\n\x00"
                                                                                       as
                                                                                       *const u8
                                                                                       as
                                                                                       *const std::os::raw::c_char);
                        xmlHaltParser(ctxt);
                        return XML_ERR_INVALID_ENCODING as std::os::raw::c_int
                    }
                    xmlBufSetInputBaseCur((*in_0).buffer, (*ctxt).input,
                                          base_0, current);
                }
            }
        }
        if remain != 0 as std::os::raw::c_int {
            xmlParseTryOrFinish(ctxt, 0 as std::os::raw::c_int);
        } else {
            if !(*ctxt).input.is_null() && !(*(*ctxt).input).buf.is_null() {
                avail = xmlBufUse((*(*(*ctxt).input).buf).buffer)
            }
            /*
         * Depending on the current state it may not be such
         * a good idea to try parsing if there is nothing in the chunk
         * which would be worth doing a parser state transition and we
         * need to wait for more data
         */
            if terminate != 0 ||
                   avail > 10000000 as std::os::raw::c_int as std::os::raw::c_ulong ||
                   old_avail == 0 as std::os::raw::c_int as std::os::raw::c_ulong ||
                   avail == 0 as std::os::raw::c_int as std::os::raw::c_ulong ||
                   xmlParseCheckTransition(ctxt,
                                           &*(*(*ctxt).input).base.offset(old_avail
                                                                              as
                                                                              isize)
                                               as *const xmlChar as
                                               *const std::os::raw::c_char,
                                           avail.wrapping_sub(old_avail) as
                                               std::os::raw::c_int) != 0 {
                xmlParseTryOrFinish(ctxt, terminate);
            }
        }
        if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EOF as std::os::raw::c_int {
            return (*ctxt).errNo
        }
        if !(*ctxt).input.is_null() &&
               ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur)
                    as std::os::raw::c_long > 10000000 as std::os::raw::c_int as std::os::raw::c_long
                    ||
                    (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                        as std::os::raw::c_long >
                        10000000 as std::os::raw::c_int as std::os::raw::c_long) &&
               (*ctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                   0 as std::os::raw::c_int {
            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                        b"Huge input lookup\x00" as *const u8 as
                            *const std::os::raw::c_char);
            xmlHaltParser(ctxt);
        }
        if (*ctxt).errNo != XML_ERR_OK as std::os::raw::c_int &&
               (*ctxt).disableSAX == 1 as std::os::raw::c_int {
            return (*ctxt).errNo
        }
        if !(remain != 0 as std::os::raw::c_int) { break ; }
        chunk = chunk.offset(size as isize);
        size = remain;
        remain = 0 as std::os::raw::c_int
    }
    if end_in_lf == 1 as std::os::raw::c_int && !(*ctxt).input.is_null() &&
           !(*(*ctxt).input).buf.is_null() {
        let mut base_1: size_t =
            xmlBufGetInputBase((*(*(*ctxt).input).buf).buffer, (*ctxt).input);
        let mut current_0: size_t =
            (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                as std::os::raw::c_long as size_t;
        xmlParserInputBufferPush((*(*ctxt).input).buf, 1 as std::os::raw::c_int,
                                 b"\r\x00" as *const u8 as
                                     *const std::os::raw::c_char);
        xmlBufSetInputBaseCur((*(*(*ctxt).input).buf).buffer, (*ctxt).input,
                              base_1, current_0);
    }
    if terminate != 0 {
        /*
	 * Check for termination
	 */
        let mut cur_avail: std::os::raw::c_int = 0 as std::os::raw::c_int;
        if !(*ctxt).input.is_null() {
            if (*(*ctxt).input).buf.is_null() {
                cur_avail =
                    ((*(*ctxt).input).length as std::os::raw::c_long -
                         (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                             as std::os::raw::c_long) as std::os::raw::c_int
            } else {
                cur_avail =
                    xmlBufUse((*(*(*ctxt).input).buf).buffer).wrapping_sub((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                                               as
                                                                               std::os::raw::c_long
                                                                               as
                                                                               std::os::raw::c_ulong)
                        as std::os::raw::c_int
            }
        }
        if (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int &&
               (*ctxt).instate as std::os::raw::c_int !=
                   XML_PARSER_EPILOG as std::os::raw::c_int {
            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, 0 as *const std::os::raw::c_char);
        }
        if (*ctxt).instate as std::os::raw::c_int == XML_PARSER_EPILOG as std::os::raw::c_int
               && cur_avail > 0 as std::os::raw::c_int {
            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, 0 as *const std::os::raw::c_char);
        }
        if (*ctxt).instate as std::os::raw::c_int != XML_PARSER_EOF as std::os::raw::c_int {
            if !(*ctxt).sax.is_null() && (*(*ctxt).sax).endDocument.is_some()
               {
                (*(*ctxt).sax).endDocument.expect("non-null function pointer")((*ctxt).userData);
            }
        }
        (*ctxt).instate = XML_PARSER_EOF
    }
    if (*ctxt).wellFormed == 0 as std::os::raw::c_int {
        return (*ctxt).errNo as xmlParserErrors as std::os::raw::c_int
    } else { return 0 as std::os::raw::c_int };
}
/* ***********************************************************************
 *									*
 *		I/O front end functions to the parser			*
 *									*
 ************************************************************************/
/* *
 * xmlCreatePushParserCtxt:
 * @sax:  a SAX handler
 * @user_data:  The user data returned on SAX callbacks
 * @chunk:  a pointer to an array of chars
 * @size:  number of chars in the array
 * @filename:  an optional file name or URI
 *
 * Create a parser context for using the XML parser in push mode.
 * If @buffer and @size are non-NULL, the data is used to detect
 * the encoding.  The remaining characters will be parsed so they
 * don't need to be fed in again through xmlParseChunk.
 * To allow content encoding detection, @size should be >= 4
 * The value of @filename is used for fetching external entities
 * and error/warning reports.
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCreatePushParserCtxt(mut sax: xmlSAXHandlerPtr,
                                                 mut user_data:
                                                     *mut std::os::raw::c_void,
                                                 mut chunk:
                                                     *const std::os::raw::c_char,
                                                 mut size: std::os::raw::c_int,
                                                 mut filename:
                                                     *const std::os::raw::c_char)
 -> xmlParserCtxtPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut inputStream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    /*
     * plug some encoding conversion routines
     */
    if !chunk.is_null() && size >= 4 as std::os::raw::c_int {
        enc = xmlDetectCharEncoding(chunk as *const xmlChar, size)
    }
    buf = xmlAllocParserInputBuffer(enc);
    if buf.is_null() { return 0 as xmlParserCtxtPtr }
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() {
        xmlErrMemory(0 as xmlParserCtxtPtr,
                     b"creating parser: out of memory\n\x00" as *const u8 as
                         *const std::os::raw::c_char);
        xmlFreeParserInputBuffer(buf);
        return 0 as xmlParserCtxtPtr
    }
    (*ctxt).dictNames = 1 as std::os::raw::c_int;
    (*ctxt).pushTab =
        xmlMalloc.expect("non-null function pointer")((((*ctxt).nameMax *
                                                            3 as std::os::raw::c_int)
                                                           as
                                                           std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlChar>()
                                                                                           as
                                                                                           std::os::raw::c_ulong))
            as *mut *mut std::os::raw::c_void;
    if (*ctxt).pushTab.is_null() {
        xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
        xmlFreeParserInputBuffer(buf);
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlParserCtxtPtr
    }
    if !sax.is_null() {
        if (*ctxt).sax != __xmlDefaultSAXHandler() as xmlSAXHandlerPtr {
            /* LIBXML_SAX1_ENABLED */
            xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).sax =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSAXHandler>()
                                                              as
                                                              std::os::raw::c_ulong)
                as xmlSAXHandlerPtr;
        if (*ctxt).sax.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            xmlFreeParserInputBuffer(buf);
            xmlFreeParserCtxt(ctxt);
            return 0 as xmlParserCtxtPtr
        }
        memset((*ctxt).sax as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
               ::std::mem::size_of::<xmlSAXHandler>() as std::os::raw::c_ulong);
        if (*sax).initialized == 0xdeedbeaf as std::os::raw::c_uint {
            memcpy((*ctxt).sax as *mut std::os::raw::c_void,
                   sax as *const std::os::raw::c_void,
                   ::std::mem::size_of::<xmlSAXHandler>() as std::os::raw::c_ulong);
        } else {
            memcpy((*ctxt).sax as *mut std::os::raw::c_void,
                   sax as *const std::os::raw::c_void,
                   ::std::mem::size_of::<xmlSAXHandlerV1>() as std::os::raw::c_ulong);
        }
        if !user_data.is_null() { (*ctxt).userData = user_data }
    }
    if filename.is_null() {
        (*ctxt).directory = 0 as *mut std::os::raw::c_char
    } else { (*ctxt).directory = xmlParserGetDirectory(filename) }
    inputStream = xmlNewInputStream(ctxt);
    if inputStream.is_null() {
        xmlFreeParserCtxt(ctxt);
        xmlFreeParserInputBuffer(buf);
        return 0 as xmlParserCtxtPtr
    }
    if filename.is_null() {
        (*inputStream).filename = 0 as *const std::os::raw::c_char
    } else {
        (*inputStream).filename =
            xmlCanonicPath(filename as *const xmlChar) as *mut std::os::raw::c_char;
        if (*inputStream).filename.is_null() {
            xmlFreeParserCtxt(ctxt);
            xmlFreeParserInputBuffer(buf);
            return 0 as xmlParserCtxtPtr
        }
    }
    (*inputStream).buf = buf;
    xmlBufResetInput((*(*inputStream).buf).buffer, inputStream);
    inputPush(ctxt, inputStream);
    /*
     * If the caller didn't provide an initial 'chunk' for determining
     * the encoding, we set the context to XML_CHAR_ENCODING_NONE so
     * that it can be automatically determined later
     */
    if size == 0 as std::os::raw::c_int || chunk.is_null() {
        (*ctxt).charset = XML_CHAR_ENCODING_NONE as std::os::raw::c_int
    } else if !(*ctxt).input.is_null() && !(*(*ctxt).input).buf.is_null() {
        let mut base: size_t =
            xmlBufGetInputBase((*(*(*ctxt).input).buf).buffer, (*ctxt).input);
        let mut cur: size_t =
            (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                as std::os::raw::c_long as size_t;
        xmlParserInputBufferPush((*(*ctxt).input).buf, size, chunk);
        xmlBufSetInputBaseCur((*(*(*ctxt).input).buf).buffer, (*ctxt).input,
                              base, cur);
    }
    if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
        xmlSwitchEncoding(ctxt, enc);
    }
    return ctxt;
}
/* LIBXML_PUSH_ENABLED */
/* *
 * xmlHaltParser:
 * @ctxt:  an XML parser context
 *
 * Blocks further parser processing don't override error
 * for internal use
 */
unsafe extern "C" fn xmlHaltParser(mut ctxt: xmlParserCtxtPtr) {
    if ctxt.is_null() { return }
    (*ctxt).instate = XML_PARSER_EOF;
    (*ctxt).disableSAX = 1 as std::os::raw::c_int;
    while (*ctxt).inputNr > 1 as std::os::raw::c_int {
        xmlFreeInputStream(inputPop(ctxt));
    }
    if !(*ctxt).input.is_null() {
        /*
	 * in case there was a specific allocation deallocate before
	 * overriding base
	 */
        if (*(*ctxt).input).free.is_some() {
            (*(*ctxt).input).free.expect("non-null function pointer")((*(*ctxt).input).base
                                                                          as
                                                                          *mut xmlChar);
            (*(*ctxt).input).free = None
        }
        (*(*ctxt).input).cur =
            b"\x00" as *const u8 as *const std::os::raw::c_char as *mut xmlChar;
        (*(*ctxt).input).base = (*(*ctxt).input).cur;
        (*(*ctxt).input).end = (*(*ctxt).input).cur
    };
}
/* *
 * xmlStopParser:
 * @ctxt:  an XML parser context
 *
 * Blocks further parser processing
 */
#[no_mangle]
pub unsafe extern "C" fn xmlStopParser(mut ctxt: xmlParserCtxtPtr) {
    if ctxt.is_null() { return }
    xmlHaltParser(ctxt);
    (*ctxt).errNo = XML_ERR_USER_STOP as std::os::raw::c_int;
}
/* *
 * xmlCreateIOParserCtxt:
 * @sax:  a SAX handler
 * @user_data:  The user data returned on SAX callbacks
 * @ioread:  an I/O read function
 * @ioclose:  an I/O close function
 * @ioctx:  an I/O handler
 * @enc:  the charset encoding if known
 *
 * Create a parser context for using the XML parser with an existing
 * I/O stream
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCreateIOParserCtxt(mut sax: xmlSAXHandlerPtr,
                                               mut user_data:
                                                   *mut std::os::raw::c_void,
                                               mut ioread:
                                                   xmlInputReadCallback,
                                               mut ioclose:
                                                   xmlInputCloseCallback,
                                               mut ioctx: *mut std::os::raw::c_void,
                                               mut enc: xmlCharEncoding)
 -> xmlParserCtxtPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut inputStream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    if ioread.is_none() { return 0 as xmlParserCtxtPtr }
    buf = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc);
    if buf.is_null() {
        if ioclose.is_some() {
            ioclose.expect("non-null function pointer")(ioctx);
        }
        return 0 as xmlParserCtxtPtr
    }
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() {
        xmlFreeParserInputBuffer(buf);
        return 0 as xmlParserCtxtPtr
    }
    if !sax.is_null() {
        if (*ctxt).sax != __xmlDefaultSAXHandler() as xmlSAXHandlerPtr {
            /* LIBXML_SAX1_ENABLED */
            xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).sax =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSAXHandler>()
                                                              as
                                                              std::os::raw::c_ulong)
                as xmlSAXHandlerPtr;
        if (*ctxt).sax.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            xmlFreeParserCtxt(ctxt);
            return 0 as xmlParserCtxtPtr
        }
        memset((*ctxt).sax as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
               ::std::mem::size_of::<xmlSAXHandler>() as std::os::raw::c_ulong);
        if (*sax).initialized == 0xdeedbeaf as std::os::raw::c_uint {
            memcpy((*ctxt).sax as *mut std::os::raw::c_void,
                   sax as *const std::os::raw::c_void,
                   ::std::mem::size_of::<xmlSAXHandler>() as std::os::raw::c_ulong);
        } else {
            memcpy((*ctxt).sax as *mut std::os::raw::c_void,
                   sax as *const std::os::raw::c_void,
                   ::std::mem::size_of::<xmlSAXHandlerV1>() as std::os::raw::c_ulong);
        }
        if !user_data.is_null() { (*ctxt).userData = user_data }
    }
    inputStream = xmlNewIOInputStream(ctxt, buf, enc);
    if inputStream.is_null() {
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlParserCtxtPtr
    }
    inputPush(ctxt, inputStream);
    return ctxt;
}
/* ***********************************************************************
 *									*
 *		Front ends when parsing a DTD				*
 *									*
 ************************************************************************/
/* *
 * xmlIOParseDTD:
 * @sax:  the SAX handler block or NULL
 * @input:  an Input Buffer
 * @enc:  the charset encoding if known
 *
 * Load and parse a DTD
 *
 * Returns the resulting xmlDtdPtr or NULL in case of error.
 * @input will be freed by the function in any case.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlIOParseDTD(mut sax: xmlSAXHandlerPtr,
                                       mut input: xmlParserInputBufferPtr,
                                       mut enc: xmlCharEncoding)
 -> xmlDtdPtr {
    let mut ret: xmlDtdPtr = 0 as xmlDtdPtr;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pinput: xmlParserInputPtr = 0 as xmlParserInputPtr;
    let mut start: [xmlChar; 4] = [0; 4];
    if input.is_null() { return 0 as xmlDtdPtr }
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as xmlDtdPtr
    }
    /* We are loading a DTD */
    (*ctxt).options |= XML_PARSE_DTDLOAD as std::os::raw::c_int;
    /*
     * Set-up the SAX context
     */
    if !sax.is_null() {
        if !(*ctxt).sax.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).sax = sax;
        (*ctxt).userData = ctxt as *mut std::os::raw::c_void
    }
    xmlDetectSAX2(ctxt);
    /*
     * generate a parser input from the I/O handler
     */
    pinput = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if pinput.is_null() {
        if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
        xmlFreeParserInputBuffer(input);
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlDtdPtr
    }
    /*
     * plug some encoding conversion routines here.
     */
    if xmlPushInput(ctxt, pinput) < 0 as std::os::raw::c_int {
        if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlDtdPtr
    }
    if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
        xmlSwitchEncoding(ctxt, enc);
    }
    (*pinput).filename = 0 as *const std::os::raw::c_char;
    (*pinput).line = 1 as std::os::raw::c_int;
    (*pinput).col = 1 as std::os::raw::c_int;
    (*pinput).base = (*(*ctxt).input).cur;
    (*pinput).cur = (*(*ctxt).input).cur;
    (*pinput).free = None;
    /*
     * let's parse that entity knowing it's an external subset.
     */
    (*ctxt).inSubset = 2 as std::os::raw::c_int;
    (*ctxt).myDoc =
        xmlNewDoc(b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if (*ctxt).myDoc.is_null() {
        xmlErrMemory(ctxt,
                     b"New Doc failed\x00" as *const u8 as
                         *const std::os::raw::c_char);
        return 0 as xmlDtdPtr
    }
    (*(*ctxt).myDoc).properties = XML_DOC_INTERNAL as std::os::raw::c_int;
    (*(*ctxt).myDoc).extSubset =
        xmlNewDtd((*ctxt).myDoc,
                  b"none\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar,
                  b"none\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar,
                  b"none\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if enc as std::os::raw::c_int == XML_CHAR_ENCODING_NONE as std::os::raw::c_int &&
           (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
               std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
        /*
	 * Get the 4 first bytes and decode the charset
	 * if enc != XML_CHAR_ENCODING_NONE
	 * plug some encoding conversion routines.
	 */
        start[0 as std::os::raw::c_int as usize] = *(*(*ctxt).input).cur;
        start[1 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
        start[2 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        start[3 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
        enc = xmlDetectCharEncoding(start.as_mut_ptr(), 4 as std::os::raw::c_int);
        if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
            xmlSwitchEncoding(ctxt, enc);
        }
    }
    xmlParseExternalSubset(ctxt,
                           b"none\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar,
                           b"none\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar);
    if !(*ctxt).myDoc.is_null() {
        if (*ctxt).wellFormed != 0 {
            ret = (*(*ctxt).myDoc).extSubset;
            (*(*ctxt).myDoc).extSubset = 0 as *mut _xmlDtd;
            if !ret.is_null() {
                let mut tmp: xmlNodePtr = 0 as *mut xmlNode;
                (*ret).doc = 0 as *mut _xmlDoc;
                tmp = (*ret).children;
                while !tmp.is_null() {
                    (*tmp).doc = 0 as *mut _xmlDoc;
                    tmp = (*tmp).next
                }
            }
        } else { ret = 0 as xmlDtdPtr }
        xmlFreeDoc((*ctxt).myDoc);
        (*ctxt).myDoc = 0 as xmlDocPtr
    }
    if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
    xmlFreeParserCtxt(ctxt);
    return ret;
}
/* *
 * xmlSAXParseDTD:
 * @sax:  the SAX handler block
 * @ExternalID:  a NAME* containing the External ID of the DTD
 * @SystemID:  a NAME* containing the URL to the DTD
 *
 * Load and parse an external subset.
 *
 * Returns the resulting xmlDtdPtr or NULL in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSAXParseDTD(mut sax: xmlSAXHandlerPtr,
                                        mut ExternalID: *const xmlChar,
                                        mut SystemID: *const xmlChar)
 -> xmlDtdPtr {
    let mut ret: xmlDtdPtr = 0 as xmlDtdPtr;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut input: xmlParserInputPtr = 0 as xmlParserInputPtr;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    let mut systemIdCanonic: *mut xmlChar = 0 as *mut xmlChar;
    if ExternalID.is_null() && SystemID.is_null() { return 0 as xmlDtdPtr }
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() { return 0 as xmlDtdPtr }
    /* We are loading a DTD */
    (*ctxt).options |= XML_PARSE_DTDLOAD as std::os::raw::c_int;
    /*
     * Set-up the SAX context
     */
    if !sax.is_null() {
        if !(*ctxt).sax.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).sax = sax;
        (*ctxt).userData = ctxt as *mut std::os::raw::c_void
    }
    /*
     * Canonicalise the system ID
     */
    systemIdCanonic = xmlCanonicPath(SystemID);
    if !SystemID.is_null() && systemIdCanonic.is_null() {
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlDtdPtr
    }
    /*
     * Ask the Entity resolver to load the damn thing
     */
    if !(*ctxt).sax.is_null() && (*(*ctxt).sax).resolveEntity.is_some() {
        input =
            (*(*ctxt).sax).resolveEntity.expect("non-null function pointer")((*ctxt).userData,
                                                                             ExternalID,
                                                                             systemIdCanonic)
    }
    if input.is_null() {
        if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
        xmlFreeParserCtxt(ctxt);
        if !systemIdCanonic.is_null() {
            xmlFree.expect("non-null function pointer")(systemIdCanonic as
                                                            *mut std::os::raw::c_void);
        }
        return 0 as xmlDtdPtr
    }
    /*
     * plug some encoding conversion routines here.
     */
    if xmlPushInput(ctxt, input) < 0 as std::os::raw::c_int {
        if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
        xmlFreeParserCtxt(ctxt);
        if !systemIdCanonic.is_null() {
            xmlFree.expect("non-null function pointer")(systemIdCanonic as
                                                            *mut std::os::raw::c_void);
        }
        return 0 as xmlDtdPtr
    }
    if (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
           std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
        enc = xmlDetectCharEncoding((*(*ctxt).input).cur, 4 as std::os::raw::c_int);
        xmlSwitchEncoding(ctxt, enc);
    }
    if (*input).filename.is_null() {
        (*input).filename = systemIdCanonic as *mut std::os::raw::c_char
    } else {
        xmlFree.expect("non-null function pointer")(systemIdCanonic as
                                                        *mut std::os::raw::c_void);
    }
    (*input).line = 1 as std::os::raw::c_int;
    (*input).col = 1 as std::os::raw::c_int;
    (*input).base = (*(*ctxt).input).cur;
    (*input).cur = (*(*ctxt).input).cur;
    (*input).free = None;
    /*
     * let's parse that entity knowing it's an external subset.
     */
    (*ctxt).inSubset = 2 as std::os::raw::c_int;
    (*ctxt).myDoc =
        xmlNewDoc(b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if (*ctxt).myDoc.is_null() {
        xmlErrMemory(ctxt,
                     b"New Doc failed\x00" as *const u8 as
                         *const std::os::raw::c_char);
        if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlDtdPtr
    }
    (*(*ctxt).myDoc).properties = XML_DOC_INTERNAL as std::os::raw::c_int;
    (*(*ctxt).myDoc).extSubset =
        xmlNewDtd((*ctxt).myDoc,
                  b"none\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar, ExternalID, SystemID);
    xmlParseExternalSubset(ctxt, ExternalID, SystemID);
    if !(*ctxt).myDoc.is_null() {
        if (*ctxt).wellFormed != 0 {
            ret = (*(*ctxt).myDoc).extSubset;
            (*(*ctxt).myDoc).extSubset = 0 as *mut _xmlDtd;
            if !ret.is_null() {
                let mut tmp: xmlNodePtr = 0 as *mut xmlNode;
                (*ret).doc = 0 as *mut _xmlDoc;
                tmp = (*ret).children;
                while !tmp.is_null() {
                    (*tmp).doc = 0 as *mut _xmlDoc;
                    tmp = (*tmp).next
                }
            }
        } else { ret = 0 as xmlDtdPtr }
        xmlFreeDoc((*ctxt).myDoc);
        (*ctxt).myDoc = 0 as xmlDocPtr
    }
    if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
    xmlFreeParserCtxt(ctxt);
    return ret;
}
/* *
 * xmlParseDTD:
 * @ExternalID:  a NAME* containing the External ID of the DTD
 * @SystemID:  a NAME* containing the URL to the DTD
 *
 * Load and parse an external subset.
 *
 * Returns the resulting xmlDtdPtr or NULL in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseDTD(mut ExternalID: *const xmlChar,
                                     mut SystemID: *const xmlChar)
 -> xmlDtdPtr {
    return xmlSAXParseDTD(0 as xmlSAXHandlerPtr, ExternalID, SystemID);
}
/* LIBXML_VALID_ENABLED */
/* ***********************************************************************
 *									*
 *		Front ends when parsing an Entity			*
 *									*
 ************************************************************************/
/* *
 * xmlParseCtxtExternalEntity:
 * @ctx:  the existing parsing context
 * @URL:  the URL for the entity to load
 * @ID:  the System ID for the entity to load
 * @lst:  the return value for the set of parsed nodes
 *
 * Parse an external general entity within an existing parsing context
 * An external general parsed entity is well-formed if it matches the
 * production labeled extParsedEnt.
 *
 * [78] extParsedEnt ::= TextDecl? content
 *
 * Returns 0 if the entity is well formed, -1 in case of args problem and
 *    the parser error code otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseCtxtExternalEntity(mut ctx: xmlParserCtxtPtr,
                                                    mut URL: *const xmlChar,
                                                    mut ID: *const xmlChar,
                                                    mut lst: *mut xmlNodePtr)
 -> std::os::raw::c_int {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut newDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut newRoot: xmlNodePtr = 0 as *mut xmlNode;
    let mut oldsax: xmlSAXHandlerPtr = 0 as xmlSAXHandlerPtr;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut start: [xmlChar; 4] = [0; 4];
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    if ctx.is_null() { return -(1 as std::os::raw::c_int) }
    if (*ctx).depth > 40 as std::os::raw::c_int &&
           (*ctx).options & XML_PARSE_HUGE as std::os::raw::c_int == 0 as std::os::raw::c_int
           || (*ctx).depth > 1024 as std::os::raw::c_int {
        return XML_ERR_ENTITY_LOOP as std::os::raw::c_int
    }
    if !lst.is_null() { *lst = 0 as xmlNodePtr }
    if URL.is_null() && ID.is_null() { return -(1 as std::os::raw::c_int) }
    if (*ctx).myDoc.is_null() {
        /* @@ relax but check for dereferences */
        return -(1 as std::os::raw::c_int)
    }
    ctxt =
        xmlCreateEntityParserCtxtInternal(URL, ID, 0 as *const xmlChar, ctx);
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    oldsax = (*ctxt).sax;
    (*ctxt).sax = (*ctx).sax;
    xmlDetectSAX2(ctxt);
    newDoc =
        xmlNewDoc(b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if newDoc.is_null() {
        xmlFreeParserCtxt(ctxt);
        return -(1 as std::os::raw::c_int)
    }
    (*newDoc).properties = XML_DOC_INTERNAL as std::os::raw::c_int;
    if !(*(*ctx).myDoc).dict.is_null() {
        (*newDoc).dict = (*(*ctx).myDoc).dict;
        xmlDictReference((*newDoc).dict);
    }
    if !(*ctx).myDoc.is_null() {
        (*newDoc).intSubset = (*(*ctx).myDoc).intSubset;
        (*newDoc).extSubset = (*(*ctx).myDoc).extSubset
    }
    if !(*(*ctx).myDoc).URL.is_null() {
        (*newDoc).URL = xmlStrdup((*(*ctx).myDoc).URL)
    }
    newRoot =
        xmlNewDocNode(newDoc, 0 as xmlNsPtr,
                      b"pseudoroot\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 0 as *const xmlChar);
    if newRoot.is_null() {
        (*ctxt).sax = oldsax;
        xmlFreeParserCtxt(ctxt);
        (*newDoc).intSubset = 0 as *mut _xmlDtd;
        (*newDoc).extSubset = 0 as *mut _xmlDtd;
        xmlFreeDoc(newDoc);
        return -(1 as std::os::raw::c_int)
    }
    xmlAddChild(newDoc as xmlNodePtr, newRoot);
    nodePush(ctxt, (*newDoc).children);
    if (*ctx).myDoc.is_null() {
        (*ctxt).myDoc = newDoc
    } else {
        (*ctxt).myDoc = (*ctx).myDoc;
        (*(*newDoc).children).doc = (*ctx).myDoc
    }
    /*
     * Get the 4 first bytes and decode the charset
     * if enc != XML_CHAR_ENCODING_NONE
     * plug some encoding conversion routines.
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
           std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
        start[0 as std::os::raw::c_int as usize] = *(*(*ctxt).input).cur;
        start[1 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
        start[2 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        start[3 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
        enc = xmlDetectCharEncoding(start.as_mut_ptr(), 4 as std::os::raw::c_int);
        if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
            xmlSwitchEncoding(ctxt, enc);
        }
    }
    /*
     * Parse a possible text declaration first
     */
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '?' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'x' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'm' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'l' as i32 &&
           (*(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                0x9 as std::os::raw::c_int <=
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int &&
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                    std::os::raw::c_int == 0xd as std::os::raw::c_int) {
        xmlParseTextDecl(ctxt);
        /*
	 * An XML-1.0 document can't reference an entity not XML-1.0
	 */
        if xmlStrEqual((*ctx).version,
                       b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut xmlChar) != 0 &&
               xmlStrEqual((*(*ctxt).input).version,
                           b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                               *mut xmlChar) == 0 {
            xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,
                           b"Version mismatch between document and entity\n\x00"
                               as *const u8 as *const std::os::raw::c_char);
        }
    }
    /*
     * If the user provided its own SAX callbacks then reuse the
     * useData callback field, otherwise the expected setup in a
     * DOM builder is to have userData == ctxt
     */
    if (*ctx).userData == ctx as *mut std::os::raw::c_void {
        (*ctxt).userData = ctxt as *mut std::os::raw::c_void
    } else { (*ctxt).userData = (*ctx).userData }
    /*
     * Doing validity checking on chunk doesn't make sense
     */
    (*ctxt).instate = XML_PARSER_CONTENT;
    (*ctxt).validate = (*ctx).validate;
    (*ctxt).valid = (*ctx).valid;
    (*ctxt).loadsubset = (*ctx).loadsubset;
    (*ctxt).depth = (*ctx).depth + 1 as std::os::raw::c_int;
    (*ctxt).replaceEntities = (*ctx).replaceEntities;
    if (*ctxt).validate != 0 {
        (*ctxt).vctxt.error = (*ctx).vctxt.error;
        (*ctxt).vctxt.warning = (*ctx).vctxt.warning
    } else { (*ctxt).vctxt.error = None; (*ctxt).vctxt.warning = None }
    (*ctxt).vctxt.nodeTab = 0 as *mut xmlNodePtr;
    (*ctxt).vctxt.nodeNr = 0 as std::os::raw::c_int;
    (*ctxt).vctxt.nodeMax = 0 as std::os::raw::c_int;
    (*ctxt).vctxt.node = 0 as xmlNodePtr;
    if !(*ctxt).dict.is_null() { xmlDictFree((*ctxt).dict); }
    (*ctxt).dict = (*ctx).dict;
    (*ctxt).str_xml =
        xmlDictLookup((*ctxt).dict,
                      b"xml\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 3 as std::os::raw::c_int);
    (*ctxt).str_xmlns =
        xmlDictLookup((*ctxt).dict,
                      b"xmlns\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 5 as std::os::raw::c_int);
    (*ctxt).str_xml_ns =
        xmlDictLookup((*ctxt).dict,
                      b"http://www.w3.org/XML/1998/namespace\x00" as *const u8
                          as *const std::os::raw::c_char as *const xmlChar,
                      36 as std::os::raw::c_int);
    (*ctxt).dictNames = (*ctx).dictNames;
    (*ctxt).attsDefault = (*ctx).attsDefault;
    (*ctxt).attsSpecial = (*ctx).attsSpecial;
    (*ctxt).linenumbers = (*ctx).linenumbers;
    xmlParseContent(ctxt);
    (*ctx).validate = (*ctxt).validate;
    (*ctx).valid = (*ctxt).valid;
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '/' as i32 {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, 0 as *const std::os::raw::c_char);
    }
    if (*ctxt).node != (*newDoc).children {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    }
    if (*ctxt).wellFormed == 0 {
        if (*ctxt).errNo == 0 as std::os::raw::c_int {
            ret = 1 as std::os::raw::c_int
        } else { ret = (*ctxt).errNo }
    } else {
        if !lst.is_null() {
            let mut cur: xmlNodePtr = 0 as *mut xmlNode;
            /*
	     * Return the newly created nodeset after unlinking it from
	     * they pseudo parent.
	     */
            cur = (*(*newDoc).children).children;
            *lst = cur;
            while !cur.is_null() {
                (*cur).parent = 0 as *mut _xmlNode;
                cur = (*cur).next
            }
            (*(*newDoc).children).children = 0 as *mut _xmlNode
        }
        ret = 0 as std::os::raw::c_int
    }
    (*ctxt).sax = oldsax;
    (*ctxt).dict = 0 as xmlDictPtr;
    (*ctxt).attsDefault = 0 as xmlHashTablePtr;
    (*ctxt).attsSpecial = 0 as xmlHashTablePtr;
    xmlFreeParserCtxt(ctxt);
    (*newDoc).intSubset = 0 as *mut _xmlDtd;
    (*newDoc).extSubset = 0 as *mut _xmlDtd;
    xmlFreeDoc(newDoc);
    return ret;
}
/* *
 * xmlParseExternalEntityPrivate:
 * @doc:  the document the chunk pertains to
 * @oldctxt:  the previous parser context if available
 * @sax:  the SAX handler bloc (possibly NULL)
 * @user_data:  The user data returned on SAX callbacks (possibly NULL)
 * @depth:  Used for loop detection, use 0
 * @URL:  the URL for the entity to load
 * @ID:  the System ID for the entity to load
 * @list:  the return value for the set of parsed nodes
 *
 * Private version of xmlParseExternalEntity()
 *
 * Returns 0 if the entity is well formed, -1 in case of args problem and
 *    the parser error code otherwise
 */
unsafe extern "C" fn xmlParseExternalEntityPrivate(mut doc: xmlDocPtr,
                                                   mut oldctxt:
                                                       xmlParserCtxtPtr,
                                                   mut sax: xmlSAXHandlerPtr,
                                                   mut user_data:
                                                       *mut std::os::raw::c_void,
                                                   mut depth: std::os::raw::c_int,
                                                   mut URL: *const xmlChar,
                                                   mut ID: *const xmlChar,
                                                   mut list: *mut xmlNodePtr)
 -> xmlParserErrors {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut newDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut newRoot: xmlNodePtr = 0 as *mut xmlNode;
    let mut oldsax: xmlSAXHandlerPtr = 0 as xmlSAXHandlerPtr;
    let mut ret: xmlParserErrors = XML_ERR_OK;
    let mut start: [xmlChar; 4] = [0; 4];
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    if depth > 40 as std::os::raw::c_int &&
           (oldctxt.is_null() ||
                (*oldctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
                    0 as std::os::raw::c_int) || depth > 1024 as std::os::raw::c_int {
        return XML_ERR_ENTITY_LOOP
    }
    if !list.is_null() { *list = 0 as xmlNodePtr }
    if URL.is_null() && ID.is_null() { return XML_ERR_INTERNAL_ERROR }
    if doc.is_null() { return XML_ERR_INTERNAL_ERROR }
    ctxt =
        xmlCreateEntityParserCtxtInternal(URL, ID, 0 as *const xmlChar,
                                          oldctxt);
    if ctxt.is_null() { return XML_WAR_UNDECLARED_ENTITY }
    (*ctxt).userData = ctxt as *mut std::os::raw::c_void;
    if !oldctxt.is_null() {
        (*ctxt)._private = (*oldctxt)._private;
        (*ctxt).loadsubset = (*oldctxt).loadsubset;
        (*ctxt).validate = (*oldctxt).validate;
        (*ctxt).external = (*oldctxt).external;
        (*ctxt).record_info = (*oldctxt).record_info;
        (*ctxt).node_seq.maximum = (*oldctxt).node_seq.maximum;
        (*ctxt).node_seq.length = (*oldctxt).node_seq.length;
        (*ctxt).node_seq.buffer = (*oldctxt).node_seq.buffer
    } else {
        /*
	 * Doing validity checking on chunk without context
	 * doesn't make sense
	 */
        (*ctxt)._private = 0 as *mut std::os::raw::c_void;
        (*ctxt).validate = 0 as std::os::raw::c_int;
        (*ctxt).external = 2 as std::os::raw::c_int;
        (*ctxt).loadsubset = 0 as std::os::raw::c_int
    }
    if !sax.is_null() {
        oldsax = (*ctxt).sax;
        (*ctxt).sax = sax;
        if !user_data.is_null() { (*ctxt).userData = user_data }
    }
    xmlDetectSAX2(ctxt);
    newDoc =
        xmlNewDoc(b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if newDoc.is_null() {
        (*ctxt).node_seq.maximum = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
        (*ctxt).node_seq.length = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
        (*ctxt).node_seq.buffer = 0 as *mut xmlParserNodeInfo;
        xmlFreeParserCtxt(ctxt);
        return XML_ERR_INTERNAL_ERROR
    }
    (*newDoc).properties = XML_DOC_INTERNAL as std::os::raw::c_int;
    (*newDoc).intSubset = (*doc).intSubset;
    (*newDoc).extSubset = (*doc).extSubset;
    (*newDoc).dict = (*doc).dict;
    xmlDictReference((*newDoc).dict);
    if !(*doc).URL.is_null() { (*newDoc).URL = xmlStrdup((*doc).URL) }
    newRoot =
        xmlNewDocNode(newDoc, 0 as xmlNsPtr,
                      b"pseudoroot\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 0 as *const xmlChar);
    if newRoot.is_null() {
        if !sax.is_null() { (*ctxt).sax = oldsax }
        (*ctxt).node_seq.maximum = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
        (*ctxt).node_seq.length = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
        (*ctxt).node_seq.buffer = 0 as *mut xmlParserNodeInfo;
        xmlFreeParserCtxt(ctxt);
        (*newDoc).intSubset = 0 as *mut _xmlDtd;
        (*newDoc).extSubset = 0 as *mut _xmlDtd;
        xmlFreeDoc(newDoc);
        return XML_ERR_INTERNAL_ERROR
    }
    xmlAddChild(newDoc as xmlNodePtr, newRoot);
    nodePush(ctxt, (*newDoc).children);
    (*ctxt).myDoc = doc;
    (*newRoot).doc = doc;
    /*
     * Get the 4 first bytes and decode the charset
     * if enc != XML_CHAR_ENCODING_NONE
     * plug some encoding conversion routines.
     */
    if (*ctxt).progressive == 0 as std::os::raw::c_int &&
           ((*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
                std::os::raw::c_long) < 250 as std::os::raw::c_int as std::os::raw::c_long {
        xmlGROW(ctxt);
    }
    if (*(*ctxt).input).end.offset_from((*(*ctxt).input).cur) as
           std::os::raw::c_long >= 4 as std::os::raw::c_int as std::os::raw::c_long {
        start[0 as std::os::raw::c_int as usize] = *(*(*ctxt).input).cur;
        start[1 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize);
        start[2 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(2 as std::os::raw::c_int as isize);
        start[3 as std::os::raw::c_int as usize] =
            *(*(*ctxt).input).cur.offset(3 as std::os::raw::c_int as isize);
        enc = xmlDetectCharEncoding(start.as_mut_ptr(), 4 as std::os::raw::c_int);
        if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
            xmlSwitchEncoding(ctxt, enc);
        }
    }
    /*
     * Parse a possible text declaration first
     */
    if *((*(*ctxt).input).cur as
             *mut std::os::raw::c_uchar).offset(0 as std::os::raw::c_int as isize) as
           std::os::raw::c_int == '<' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '?' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(2 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'x' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(3 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'm' as i32 &&
           *((*(*ctxt).input).cur as
                 *mut std::os::raw::c_uchar).offset(4 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == 'l' as i32 &&
           (*(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                std::os::raw::c_int == 0x20 as std::os::raw::c_int ||
                0x9 as std::os::raw::c_int <=
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int &&
                    *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int <= 0xa as std::os::raw::c_int ||
                *(*(*ctxt).input).cur.offset(5 as std::os::raw::c_int as isize) as
                    std::os::raw::c_int == 0xd as std::os::raw::c_int) {
        xmlParseTextDecl(ctxt);
    }
    (*ctxt).instate = XML_PARSER_CONTENT;
    (*ctxt).depth = depth;
    xmlParseContent(ctxt);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '/' as i32 {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, 0 as *const std::os::raw::c_char);
    }
    if (*ctxt).node != (*newDoc).children {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    }
    if (*ctxt).wellFormed == 0 {
        if (*ctxt).errNo == 0 as std::os::raw::c_int {
            ret = XML_ERR_INTERNAL_ERROR
        } else { ret = (*ctxt).errNo as xmlParserErrors }
    } else {
        if !list.is_null() {
            let mut cur: xmlNodePtr = 0 as *mut xmlNode;
            /*
	     * Return the newly created nodeset after unlinking it from
	     * they pseudo parent.
	     */
            cur = (*(*newDoc).children).children;
            *list = cur;
            while !cur.is_null() {
                (*cur).parent = 0 as *mut _xmlNode;
                cur = (*cur).next
            }
            (*(*newDoc).children).children = 0 as *mut _xmlNode
        }
        ret = XML_ERR_OK
    }
    /*
     * Record in the parent context the number of entities replacement
     * done when parsing that reference.
     */
    if !oldctxt.is_null() {
        (*oldctxt).nbentities =
            (*oldctxt).nbentities.wrapping_add((*ctxt).nbentities)
    }
    /*
     * Also record the size of the entity parsed
     */
    if !(*ctxt).input.is_null() && !oldctxt.is_null() {
        (*oldctxt).sizeentities =
            (*oldctxt).sizeentities.wrapping_add((*(*ctxt).input).consumed);
        (*oldctxt).sizeentities =
            (*oldctxt).sizeentities.wrapping_add((*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                                                     as std::os::raw::c_long as
                                                     std::os::raw::c_ulong)
    }
    /*
     * And record the last error if any
     */
    if !oldctxt.is_null() &&
           (*ctxt).lastError.code != XML_ERR_OK as std::os::raw::c_int {
        xmlCopyError(&mut (*ctxt).lastError, &mut (*oldctxt).lastError);
    }
    if !sax.is_null() { (*ctxt).sax = oldsax }
    if !oldctxt.is_null() {
        (*oldctxt).node_seq.maximum = (*ctxt).node_seq.maximum;
        (*oldctxt).node_seq.length = (*ctxt).node_seq.length;
        (*oldctxt).node_seq.buffer = (*ctxt).node_seq.buffer
    }
    (*ctxt).node_seq.maximum = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    (*ctxt).node_seq.length = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    (*ctxt).node_seq.buffer = 0 as *mut xmlParserNodeInfo;
    xmlFreeParserCtxt(ctxt);
    (*newDoc).intSubset = 0 as *mut _xmlDtd;
    (*newDoc).extSubset = 0 as *mut _xmlDtd;
    xmlFreeDoc(newDoc);
    return ret;
}
/* *
 * xmlParseExternalEntity:
 * @doc:  the document the chunk pertains to
 * @sax:  the SAX handler bloc (possibly NULL)
 * @user_data:  The user data returned on SAX callbacks (possibly NULL)
 * @depth:  Used for loop detection, use 0
 * @URL:  the URL for the entity to load
 * @ID:  the System ID for the entity to load
 * @lst:  the return value for the set of parsed nodes
 *
 * Parse an external general entity
 * An external general parsed entity is well-formed if it matches the
 * production labeled extParsedEnt.
 *
 * [78] extParsedEnt ::= TextDecl? content
 *
 * Returns 0 if the entity is well formed, -1 in case of args problem and
 *    the parser error code otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseExternalEntity(mut doc: xmlDocPtr,
                                                mut sax: xmlSAXHandlerPtr,
                                                mut user_data:
                                                    *mut std::os::raw::c_void,
                                                mut depth: std::os::raw::c_int,
                                                mut URL: *const xmlChar,
                                                mut ID: *const xmlChar,
                                                mut lst: *mut xmlNodePtr)
 -> std::os::raw::c_int {
    return xmlParseExternalEntityPrivate(doc, 0 as xmlParserCtxtPtr, sax,
                                         user_data, depth, URL, ID, lst) as
               std::os::raw::c_int;
}
/* *
 * xmlParseBalancedChunkMemory:
 * @doc:  the document the chunk pertains to
 * @sax:  the SAX handler bloc (possibly NULL)
 * @user_data:  The user data returned on SAX callbacks (possibly NULL)
 * @depth:  Used for loop detection, use 0
 * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
 * @lst:  the return value for the set of parsed nodes
 *
 * Parse a well-balanced chunk of an XML document
 * called by the parser
 * The allowed sequence for the Well Balanced Chunk is the one defined by
 * the content production in the XML grammar:
 *
 * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 *
 * Returns 0 if the chunk is well balanced, -1 in case of args problem and
 *    the parser error code otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseBalancedChunkMemory(mut doc: xmlDocPtr,
                                                     mut sax:
                                                         xmlSAXHandlerPtr,
                                                     mut user_data:
                                                         *mut std::os::raw::c_void,
                                                     mut depth: std::os::raw::c_int,
                                                     mut string:
                                                         *const xmlChar,
                                                     mut lst: *mut xmlNodePtr)
 -> std::os::raw::c_int {
    return xmlParseBalancedChunkMemoryRecover(doc, sax, user_data, depth,
                                              string, lst, 0 as std::os::raw::c_int);
}
/* LIBXML_LEGACY_ENABLED */
/* LIBXML_SAX1_ENABLED */
/* *
 * xmlParseBalancedChunkMemoryInternal:
 * @oldctxt:  the existing parsing context
 * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
 * @user_data:  the user data field for the parser context
 * @lst:  the return value for the set of parsed nodes
 *
 *
 * Parse a well-balanced chunk of an XML document
 * called by the parser
 * The allowed sequence for the Well Balanced Chunk is the one defined by
 * the content production in the XML grammar:
 *
 * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 *
 * Returns XML_ERR_OK if the chunk is well balanced, and the parser
 * error code otherwise
 *
 * In case recover is set to 1, the nodelist will not be empty even if
 * the parsed chunk is not well balanced.
 */
unsafe extern "C" fn xmlParseBalancedChunkMemoryInternal(mut oldctxt:
                                                             xmlParserCtxtPtr,
                                                         mut string:
                                                             *const xmlChar,
                                                         mut user_data:
                                                             *mut std::os::raw::c_void,
                                                         mut lst:
                                                             *mut xmlNodePtr)
 -> xmlParserErrors {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut newDoc: xmlDocPtr = 0 as xmlDocPtr;
    let mut newRoot: xmlNodePtr = 0 as *mut xmlNode;
    let mut oldsax: xmlSAXHandlerPtr = 0 as xmlSAXHandlerPtr;
    let mut content: xmlNodePtr = 0 as xmlNodePtr;
    let mut last: xmlNodePtr = 0 as xmlNodePtr;
    let mut size: std::os::raw::c_int = 0;
    let mut ret: xmlParserErrors = XML_ERR_OK;
    let mut i: std::os::raw::c_int = 0;
    if (*oldctxt).depth > 40 as std::os::raw::c_int &&
           (*oldctxt).options & XML_PARSE_HUGE as std::os::raw::c_int ==
               0 as std::os::raw::c_int || (*oldctxt).depth > 1024 as std::os::raw::c_int {
        return XML_ERR_ENTITY_LOOP
    }
    if !lst.is_null() { *lst = 0 as xmlNodePtr }
    if string.is_null() { return XML_ERR_INTERNAL_ERROR }
    size = xmlStrlen(string);
    ctxt = xmlCreateMemoryParserCtxt(string as *mut std::os::raw::c_char, size);
    if ctxt.is_null() { return XML_WAR_UNDECLARED_ENTITY }
    if !user_data.is_null() {
        (*ctxt).userData = user_data
    } else { (*ctxt).userData = ctxt as *mut std::os::raw::c_void }
    if !(*ctxt).dict.is_null() { xmlDictFree((*ctxt).dict); }
    (*ctxt).dict = (*oldctxt).dict;
    (*ctxt).input_id = (*oldctxt).input_id + 1 as std::os::raw::c_int;
    (*ctxt).str_xml =
        xmlDictLookup((*ctxt).dict,
                      b"xml\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 3 as std::os::raw::c_int);
    (*ctxt).str_xmlns =
        xmlDictLookup((*ctxt).dict,
                      b"xmlns\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 5 as std::os::raw::c_int);
    (*ctxt).str_xml_ns =
        xmlDictLookup((*ctxt).dict,
                      b"http://www.w3.org/XML/1998/namespace\x00" as *const u8
                          as *const std::os::raw::c_char as *const xmlChar,
                      36 as std::os::raw::c_int);
    /* propagate namespaces down the entity */
    i = 0 as std::os::raw::c_int;
    while i < (*oldctxt).nsNr {
        nsPush(ctxt, *(*oldctxt).nsTab.offset(i as isize),
               *(*oldctxt).nsTab.offset((i + 1 as std::os::raw::c_int) as isize));
        i += 2 as std::os::raw::c_int
    }
    oldsax = (*ctxt).sax;
    (*ctxt).sax = (*oldctxt).sax;
    xmlDetectSAX2(ctxt);
    (*ctxt).replaceEntities = (*oldctxt).replaceEntities;
    (*ctxt).options = (*oldctxt).options;
    (*ctxt)._private = (*oldctxt)._private;
    if (*oldctxt).myDoc.is_null() {
        newDoc =
            xmlNewDoc(b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar);
        if newDoc.is_null() {
            (*ctxt).sax = oldsax;
            (*ctxt).dict = 0 as xmlDictPtr;
            xmlFreeParserCtxt(ctxt);
            return XML_ERR_INTERNAL_ERROR
        }
        (*newDoc).properties = XML_DOC_INTERNAL as std::os::raw::c_int;
        (*newDoc).dict = (*ctxt).dict;
        xmlDictReference((*newDoc).dict);
        (*ctxt).myDoc = newDoc
    } else {
        (*ctxt).myDoc = (*oldctxt).myDoc;
        content = (*(*ctxt).myDoc).children;
        last = (*(*ctxt).myDoc).last
    }
    newRoot =
        xmlNewDocNode((*ctxt).myDoc, 0 as xmlNsPtr,
                      b"pseudoroot\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 0 as *const xmlChar);
    if newRoot.is_null() {
        (*ctxt).sax = oldsax;
        (*ctxt).dict = 0 as xmlDictPtr;
        xmlFreeParserCtxt(ctxt);
        if !newDoc.is_null() { xmlFreeDoc(newDoc); }
        return XML_ERR_INTERNAL_ERROR
    }
    (*(*ctxt).myDoc).children = 0 as *mut _xmlNode;
    (*(*ctxt).myDoc).last = 0 as *mut _xmlNode;
    xmlAddChild((*ctxt).myDoc as xmlNodePtr, newRoot);
    nodePush(ctxt, (*(*ctxt).myDoc).children);
    (*ctxt).instate = XML_PARSER_CONTENT;
    (*ctxt).depth = (*oldctxt).depth + 1 as std::os::raw::c_int;
    (*ctxt).validate = 0 as std::os::raw::c_int;
    (*ctxt).loadsubset = (*oldctxt).loadsubset;
    if (*oldctxt).validate != 0 ||
           (*oldctxt).replaceEntities != 0 as std::os::raw::c_int {
        /*
	 * ID/IDREF registration will be done in xmlValidateElement below
	 */
        (*ctxt).loadsubset |= 8 as std::os::raw::c_int
    }
    (*ctxt).dictNames = (*oldctxt).dictNames;
    (*ctxt).attsDefault = (*oldctxt).attsDefault;
    (*ctxt).attsSpecial = (*oldctxt).attsSpecial;
    xmlParseContent(ctxt);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '/' as i32 {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, 0 as *const std::os::raw::c_char);
    }
    if (*ctxt).node != (*(*ctxt).myDoc).children {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    }
    if (*ctxt).wellFormed == 0 {
        if (*ctxt).errNo == 0 as std::os::raw::c_int {
            ret = XML_ERR_INTERNAL_ERROR
        } else { ret = (*ctxt).errNo as xmlParserErrors }
    } else { ret = XML_ERR_OK }
    if !lst.is_null() &&
           ret as std::os::raw::c_uint == XML_ERR_OK as std::os::raw::c_int as std::os::raw::c_uint {
        let mut cur: xmlNodePtr = 0 as *mut xmlNode;
        /*
	 * Return the newly created nodeset after unlinking it from
	 * they pseudo parent.
	 */
        cur = (*(*(*ctxt).myDoc).children).children;
        *lst = cur;
        while !cur.is_null() {
            if (*oldctxt).validate != 0 && (*oldctxt).wellFormed != 0 &&
                   !(*oldctxt).myDoc.is_null() &&
                   !(*(*oldctxt).myDoc).intSubset.is_null() &&
                   (*cur).type_0 as std::os::raw::c_uint ==
                       XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
                (*oldctxt).valid &=
                    xmlValidateElement(&mut (*oldctxt).vctxt,
                                       (*oldctxt).myDoc, cur)
            }
            /* LIBXML_VALID_ENABLED */
            (*cur).parent = 0 as *mut _xmlNode;
            cur = (*cur).next
        }
        (*(*(*ctxt).myDoc).children).children = 0 as *mut _xmlNode
    }
    if !(*ctxt).myDoc.is_null() {
        xmlFreeNode((*(*ctxt).myDoc).children);
        (*(*ctxt).myDoc).children = content;
        (*(*ctxt).myDoc).last = last
    }
    /*
     * Record in the parent context the number of entities replacement
     * done when parsing that reference.
     */
    if !oldctxt.is_null() {
        (*oldctxt).nbentities =
            (*oldctxt).nbentities.wrapping_add((*ctxt).nbentities)
    }
    /*
     * Also record the last error if any
     */
    if (*ctxt).lastError.code != XML_ERR_OK as std::os::raw::c_int {
        xmlCopyError(&mut (*ctxt).lastError, &mut (*oldctxt).lastError);
    }
    (*ctxt).sax = oldsax;
    (*ctxt).dict = 0 as xmlDictPtr;
    (*ctxt).attsDefault = 0 as xmlHashTablePtr;
    (*ctxt).attsSpecial = 0 as xmlHashTablePtr;
    xmlFreeParserCtxt(ctxt);
    if !newDoc.is_null() { xmlFreeDoc(newDoc); }
    return ret;
}
/* *
 * xmlParseInNodeContext:
 * @node:  the context node
 * @data:  the input string
 * @datalen:  the input string length in bytes
 * @options:  a combination of xmlParserOption
 * @lst:  the return value for the set of parsed nodes
 *
 * Parse a well-balanced chunk of an XML document
 * within the context (DTD, namespaces, etc ...) of the given node.
 *
 * The allowed sequence for the data is a Well Balanced Chunk defined by
 * the content production in the XML grammar:
 *
 * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 *
 * Returns XML_ERR_OK if the chunk is well balanced, and the parser
 * error code otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseInNodeContext(mut node: xmlNodePtr,
                                               mut data: *const std::os::raw::c_char,
                                               mut datalen: std::os::raw::c_int,
                                               mut options: std::os::raw::c_int,
                                               mut lst: *mut xmlNodePtr)
 -> xmlParserErrors {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut doc: xmlDocPtr = 0 as xmlDocPtr;
    let mut fake: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut nsnr: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ret: xmlParserErrors = XML_ERR_OK;
    /*
     * check all input parameters, grab the document
     */
    if lst.is_null() || node.is_null() || data.is_null() ||
           datalen < 0 as std::os::raw::c_int {
        return XML_ERR_INTERNAL_ERROR
    }
    match (*node).type_0 as std::os::raw::c_uint {
        1 | 2 | 3 | 4 | 5 | 7 | 8 | 9 | 13 => { }
        _ => { return XML_ERR_INTERNAL_ERROR }
    }
    while !node.is_null() &&
              (*node).type_0 as std::os::raw::c_uint !=
                  XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint &&
              (*node).type_0 as std::os::raw::c_uint !=
                  XML_DOCUMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint &&
              (*node).type_0 as std::os::raw::c_uint !=
                  XML_HTML_DOCUMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        node = (*node).parent
    }
    if node.is_null() { return XML_ERR_INTERNAL_ERROR }
    if (*node).type_0 as std::os::raw::c_uint ==
           XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        doc = (*node).doc
    } else { doc = node as xmlDocPtr }
    if doc.is_null() { return XML_ERR_INTERNAL_ERROR }
    /*
     * allocate a context and set-up everything not related to the
     * node position in the tree
     */
    if (*doc).type_0 as std::os::raw::c_uint ==
           XML_DOCUMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        ctxt = xmlCreateMemoryParserCtxt(data as *mut std::os::raw::c_char, datalen)
    } else if (*doc).type_0 as std::os::raw::c_uint ==
                  XML_HTML_DOCUMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        ctxt = htmlCreateMemoryParserCtxt(data as *mut std::os::raw::c_char, datalen);
        /*
         * When parsing in context, it makes no sense to add implied
         * elements like html/body/etc...
         */
        options |= HTML_PARSE_NOIMPLIED as std::os::raw::c_int
    } else { return XML_ERR_INTERNAL_ERROR }
    if ctxt.is_null() { return XML_ERR_NO_MEMORY }
    /*
     * Use input doc's dict if present, else assure XML_PARSE_NODICT is set.
     * We need a dictionary for xmlDetectSAX2, so if there's no doc dict
     * we must wait until the last moment to free the original one.
     */
    if !(*doc).dict.is_null() {
        if !(*ctxt).dict.is_null() { xmlDictFree((*ctxt).dict); }
        (*ctxt).dict = (*doc).dict
    } else { options |= XML_PARSE_NODICT as std::os::raw::c_int }
    if !(*doc).encoding.is_null() {
        let mut hdlr: xmlCharEncodingHandlerPtr =
            0 as *mut xmlCharEncodingHandler;
        if !(*ctxt).encoding.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).encoding as
                                                            *mut xmlChar as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).encoding = xmlStrdup((*doc).encoding);
        hdlr =
            xmlFindCharEncodingHandler((*doc).encoding as
                                           *const std::os::raw::c_char);
        if !hdlr.is_null() {
            xmlSwitchToEncoding(ctxt, hdlr);
        } else { return XML_ERR_UNSUPPORTED_ENCODING }
    }
    xmlCtxtUseOptionsInternal(ctxt, options, 0 as *const std::os::raw::c_char);
    xmlDetectSAX2(ctxt);
    (*ctxt).myDoc = doc;
    /* parsing in context, i.e. as within existing content */
    (*ctxt).input_id = 2 as std::os::raw::c_int;
    (*ctxt).instate = XML_PARSER_CONTENT;
    fake = xmlNewComment(0 as *const xmlChar);
    if fake.is_null() { xmlFreeParserCtxt(ctxt); return XML_ERR_NO_MEMORY }
    xmlAddChild(node, fake);
    if (*node).type_0 as std::os::raw::c_uint ==
           XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        nodePush(ctxt, node);
        /*
	 * initialize the SAX2 namespaces stack
	 */
        cur = node;
        while !cur.is_null() &&
                  (*cur).type_0 as std::os::raw::c_uint ==
                      XML_ELEMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
            let mut ns: xmlNsPtr = (*cur).nsDef;
            let mut iprefix: *const xmlChar = 0 as *const xmlChar;
            let mut ihref: *const xmlChar = 0 as *const xmlChar;
            while !ns.is_null() {
                if !(*ctxt).dict.is_null() {
                    iprefix =
                        xmlDictLookup((*ctxt).dict, (*ns).prefix,
                                      -(1 as std::os::raw::c_int));
                    ihref =
                        xmlDictLookup((*ctxt).dict, (*ns).href,
                                      -(1 as std::os::raw::c_int))
                } else { iprefix = (*ns).prefix; ihref = (*ns).href }
                if xmlGetNamespace(ctxt, iprefix).is_null() {
                    nsPush(ctxt, iprefix, ihref);
                    nsnr += 1
                }
                ns = (*ns).next
            }
            cur = (*cur).parent
        }
    }
    if (*ctxt).validate != 0 || (*ctxt).replaceEntities != 0 as std::os::raw::c_int {
        /*
	 * ID/IDREF registration will be done in xmlValidateElement below
	 */
        (*ctxt).loadsubset |= 8 as std::os::raw::c_int
    }
    if (*doc).type_0 as std::os::raw::c_uint ==
           XML_HTML_DOCUMENT_NODE as std::os::raw::c_int as std::os::raw::c_uint {
        __htmlParseContent(ctxt as *mut std::os::raw::c_void);
    } else { xmlParseContent(ctxt); }
    nsPop(ctxt, nsnr);
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '/' as i32 {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, 0 as *const std::os::raw::c_char);
    }
    if !(*ctxt).node.is_null() && (*ctxt).node != node {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
        (*ctxt).wellFormed = 0 as std::os::raw::c_int
    }
    if (*ctxt).wellFormed == 0 {
        if (*ctxt).errNo == 0 as std::os::raw::c_int {
            ret = XML_ERR_INTERNAL_ERROR
        } else { ret = (*ctxt).errNo as xmlParserErrors }
    } else { ret = XML_ERR_OK }
    /*
     * Return the newly created nodeset after unlinking it from
     * the pseudo sibling.
     */
    cur = (*fake).next;
    (*fake).next = 0 as *mut _xmlNode;
    (*node).last = fake;
    if !cur.is_null() { (*cur).prev = 0 as *mut _xmlNode }
    *lst = cur;
    while !cur.is_null() {
        (*cur).parent = 0 as *mut _xmlNode;
        cur = (*cur).next
    }
    xmlUnlinkNode(fake);
    xmlFreeNode(fake);
    if ret as std::os::raw::c_uint != XML_ERR_OK as std::os::raw::c_int as std::os::raw::c_uint {
        xmlFreeNodeList(*lst);
        *lst = 0 as xmlNodePtr
    }
    if !(*doc).dict.is_null() { (*ctxt).dict = 0 as xmlDictPtr }
    xmlFreeParserCtxt(ctxt);
    return ret;
    /* !SAX2 */
}
/* *
 * xmlParseBalancedChunkMemoryRecover:
 * @doc:  the document the chunk pertains to
 * @sax:  the SAX handler bloc (possibly NULL)
 * @user_data:  The user data returned on SAX callbacks (possibly NULL)
 * @depth:  Used for loop detection, use 0
 * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
 * @lst:  the return value for the set of parsed nodes
 * @recover: return nodes even if the data is broken (use 0)
 *
 *
 * Parse a well-balanced chunk of an XML document
 * called by the parser
 * The allowed sequence for the Well Balanced Chunk is the one defined by
 * the content production in the XML grammar:
 *
 * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 *
 * Returns 0 if the chunk is well balanced, -1 in case of args problem and
 *    the parser error code otherwise
 *
 * In case recover is set to 1, the nodelist will not be empty even if
 * the parsed chunk is not well balanced, assuming the parsing succeeded to
 * some extent.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseBalancedChunkMemoryRecover(mut doc:
                                                                xmlDocPtr,
                                                            mut sax:
                                                                xmlSAXHandlerPtr,
                                                            mut user_data:
                                                                *mut std::os::raw::c_void,
                                                            mut depth:
                                                                std::os::raw::c_int,
                                                            mut string:
                                                                *const xmlChar,
                                                            mut lst:
                                                                *mut xmlNodePtr,
                                                            mut recover:
                                                                std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut newDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut oldsax: xmlSAXHandlerPtr = 0 as xmlSAXHandlerPtr;
    let mut content: xmlNodePtr = 0 as *mut xmlNode;
    let mut newRoot: xmlNodePtr = 0 as *mut xmlNode;
    let mut size: std::os::raw::c_int = 0;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if depth > 40 as std::os::raw::c_int { return XML_ERR_ENTITY_LOOP as std::os::raw::c_int }
    if !lst.is_null() { *lst = 0 as xmlNodePtr }
    if string.is_null() { return -(1 as std::os::raw::c_int) }
    size = xmlStrlen(string);
    ctxt = xmlCreateMemoryParserCtxt(string as *mut std::os::raw::c_char, size);
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    (*ctxt).userData = ctxt as *mut std::os::raw::c_void;
    if !sax.is_null() {
        oldsax = (*ctxt).sax;
        (*ctxt).sax = sax;
        if !user_data.is_null() { (*ctxt).userData = user_data }
    }
    newDoc =
        xmlNewDoc(b"1.0\x00" as *const u8 as *const std::os::raw::c_char as
                      *mut xmlChar);
    if newDoc.is_null() {
        xmlFreeParserCtxt(ctxt);
        return -(1 as std::os::raw::c_int)
    }
    (*newDoc).properties = XML_DOC_INTERNAL as std::os::raw::c_int;
    if !doc.is_null() && !(*doc).dict.is_null() {
        xmlDictFree((*ctxt).dict);
        (*ctxt).dict = (*doc).dict;
        xmlDictReference((*ctxt).dict);
        (*ctxt).str_xml =
            xmlDictLookup((*ctxt).dict,
                          b"xml\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar, 3 as std::os::raw::c_int);
        (*ctxt).str_xmlns =
            xmlDictLookup((*ctxt).dict,
                          b"xmlns\x00" as *const u8 as *const std::os::raw::c_char as
                              *mut xmlChar, 5 as std::os::raw::c_int);
        (*ctxt).str_xml_ns =
            xmlDictLookup((*ctxt).dict,
                          b"http://www.w3.org/XML/1998/namespace\x00" as
                              *const u8 as *const std::os::raw::c_char as
                              *const xmlChar, 36 as std::os::raw::c_int);
        (*ctxt).dictNames = 1 as std::os::raw::c_int
    } else {
        xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT as std::os::raw::c_int,
                                  0 as *const std::os::raw::c_char);
    }
    if !doc.is_null() {
        (*newDoc).intSubset = (*doc).intSubset;
        (*newDoc).extSubset = (*doc).extSubset
    }
    newRoot =
        xmlNewDocNode(newDoc, 0 as xmlNsPtr,
                      b"pseudoroot\x00" as *const u8 as *const std::os::raw::c_char as
                          *mut xmlChar, 0 as *const xmlChar);
    if newRoot.is_null() {
        if !sax.is_null() { (*ctxt).sax = oldsax }
        xmlFreeParserCtxt(ctxt);
        (*newDoc).intSubset = 0 as *mut _xmlDtd;
        (*newDoc).extSubset = 0 as *mut _xmlDtd;
        xmlFreeDoc(newDoc);
        return -(1 as std::os::raw::c_int)
    }
    xmlAddChild(newDoc as xmlNodePtr, newRoot);
    nodePush(ctxt, newRoot);
    if doc.is_null() {
        (*ctxt).myDoc = newDoc
    } else {
        (*ctxt).myDoc = newDoc;
        (*(*newDoc).children).doc = doc;
        /* Ensure that doc has XML spec namespace */
        xmlSearchNsByHref(doc, doc as xmlNodePtr,
                          b"http://www.w3.org/XML/1998/namespace\x00" as
                              *const u8 as *const std::os::raw::c_char as
                              *const xmlChar);
        (*newDoc).oldNs = (*doc).oldNs
    }
    (*ctxt).instate = XML_PARSER_CONTENT;
    (*ctxt).input_id = 2 as std::os::raw::c_int;
    (*ctxt).depth = depth;
    /*
     * Doing validity checking on chunk doesn't make sense
     */
    (*ctxt).validate = 0 as std::os::raw::c_int;
    (*ctxt).loadsubset = 0 as std::os::raw::c_int;
    xmlDetectSAX2(ctxt);
    if !doc.is_null() {
        content = (*doc).children;
        (*doc).children = 0 as *mut _xmlNode;
        xmlParseContent(ctxt);
        (*doc).children = content
    } else { xmlParseContent(ctxt); }
    if *(*(*ctxt).input).cur as std::os::raw::c_int == '<' as i32 &&
           *(*(*ctxt).input).cur.offset(1 as std::os::raw::c_int as isize) as
               std::os::raw::c_int == '/' as i32 {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    } else if *(*(*ctxt).input).cur as std::os::raw::c_int != 0 as std::os::raw::c_int {
        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, 0 as *const std::os::raw::c_char);
    }
    if (*ctxt).node != (*newDoc).children {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED,
                    0 as *const std::os::raw::c_char);
    }
    if (*ctxt).wellFormed == 0 {
        if (*ctxt).errNo == 0 as std::os::raw::c_int {
            ret = 1 as std::os::raw::c_int
        } else { ret = (*ctxt).errNo }
    } else { ret = 0 as std::os::raw::c_int }
    if !lst.is_null() &&
           (ret == 0 as std::os::raw::c_int || recover == 1 as std::os::raw::c_int) {
        let mut cur: xmlNodePtr = 0 as *mut xmlNode;
        /*
	 * Return the newly created nodeset after unlinking it from
	 * they pseudo parent.
	 */
        cur = (*(*newDoc).children).children;
        *lst = cur;
        while !cur.is_null() {
            xmlSetTreeDoc(cur, doc);
            (*cur).parent = 0 as *mut _xmlNode;
            cur = (*cur).next
        }
        (*(*newDoc).children).children = 0 as *mut _xmlNode
    }
    if !sax.is_null() { (*ctxt).sax = oldsax }
    xmlFreeParserCtxt(ctxt);
    (*newDoc).intSubset = 0 as *mut _xmlDtd;
    (*newDoc).extSubset = 0 as *mut _xmlDtd;
    (*newDoc).oldNs = 0 as *mut _xmlNs;
    xmlFreeDoc(newDoc);
    return ret;
}
/* *
 * xmlSAXParseEntity:
 * @sax:  the SAX handler block
 * @filename:  the filename
 *
 * parse an XML external entity out of context and build a tree.
 * It use the given SAX function block to handle the parsing callback.
 * If sax is NULL, fallback to the default DOM tree building routines.
 *
 * [78] extParsedEnt ::= TextDecl? content
 *
 * This correspond to a "Well Balanced" chunk
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSAXParseEntity(mut sax: xmlSAXHandlerPtr,
                                           mut filename: *const std::os::raw::c_char)
 -> xmlDocPtr {
    let mut ret: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    ctxt = xmlCreateFileParserCtxt(filename);
    if ctxt.is_null() { return 0 as xmlDocPtr }
    if !sax.is_null() {
        if !(*ctxt).sax.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).sax = sax;
        (*ctxt).userData = 0 as *mut std::os::raw::c_void
    }
    xmlParseExtParsedEnt(ctxt);
    if (*ctxt).wellFormed != 0 {
        ret = (*ctxt).myDoc
    } else {
        ret = 0 as xmlDocPtr;
        xmlFreeDoc((*ctxt).myDoc);
        (*ctxt).myDoc = 0 as xmlDocPtr
    }
    if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
    xmlFreeParserCtxt(ctxt);
    return ret;
}
/* *
 * xmlParseEntity:
 * @filename:  the filename
 *
 * parse an XML external entity out of context and build a tree.
 *
 * [78] extParsedEnt ::= TextDecl? content
 *
 * This correspond to a "Well Balanced" chunk
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseEntity(mut filename: *const std::os::raw::c_char)
 -> xmlDocPtr {
    return xmlSAXParseEntity(0 as xmlSAXHandlerPtr, filename);
}
/* LIBXML_SAX1_ENABLED */
/* *
 * xmlCreateEntityParserCtxtInternal:
 * @URL:  the entity URL
 * @ID:  the entity PUBLIC ID
 * @base:  a possible base for the target URI
 * @pctx:  parser context used to set options on new context
 *
 * Create a parser context for an external entity
 * Automatic support for ZLIB/Compress compressed document is provided
 * by default if found at compile-time.
 *
 * Returns the new parser context or NULL
 */
unsafe extern "C" fn xmlCreateEntityParserCtxtInternal(mut URL:
                                                           *const xmlChar,
                                                       mut ID: *const xmlChar,
                                                       mut base:
                                                           *const xmlChar,
                                                       mut pctx:
                                                           xmlParserCtxtPtr)
 -> xmlParserCtxtPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut inputStream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut directory: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut uri: *mut xmlChar = 0 as *mut xmlChar;
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() { return 0 as xmlParserCtxtPtr }
    if !pctx.is_null() {
        (*ctxt).options = (*pctx).options;
        (*ctxt)._private = (*pctx)._private;
        /*
	 * this is a subparser of pctx, so the input_id should be
	 * incremented to distinguish from main entity
	 */
        (*ctxt).input_id = (*pctx).input_id + 1 as std::os::raw::c_int
    }
    uri = xmlBuildURI(URL, base);
    if uri.is_null() {
        inputStream =
            xmlLoadExternalEntity(URL as *mut std::os::raw::c_char,
                                  ID as *mut std::os::raw::c_char, ctxt);
        if inputStream.is_null() {
            xmlFreeParserCtxt(ctxt);
            return 0 as xmlParserCtxtPtr
        }
        inputPush(ctxt, inputStream);
        if (*ctxt).directory.is_null() && directory.is_null() {
            directory = xmlParserGetDirectory(URL as *mut std::os::raw::c_char)
        }
        if (*ctxt).directory.is_null() && !directory.is_null() {
            (*ctxt).directory = directory
        }
    } else {
        inputStream =
            xmlLoadExternalEntity(uri as *mut std::os::raw::c_char,
                                  ID as *mut std::os::raw::c_char, ctxt);
        if inputStream.is_null() {
            xmlFree.expect("non-null function pointer")(uri as
                                                            *mut std::os::raw::c_void);
            xmlFreeParserCtxt(ctxt);
            return 0 as xmlParserCtxtPtr
        }
        inputPush(ctxt, inputStream);
        if (*ctxt).directory.is_null() && directory.is_null() {
            directory = xmlParserGetDirectory(uri as *mut std::os::raw::c_char)
        }
        if (*ctxt).directory.is_null() && !directory.is_null() {
            (*ctxt).directory = directory
        }
        xmlFree.expect("non-null function pointer")(uri as *mut std::os::raw::c_void);
    }
    return ctxt;
}
/* *
 * xmlCreateEntityParserCtxt:
 * @URL:  the entity URL
 * @ID:  the entity PUBLIC ID
 * @base:  a possible base for the target URI
 *
 * Create a parser context for an external entity
 * Automatic support for ZLIB/Compress compressed document is provided
 * by default if found at compile-time.
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCreateEntityParserCtxt(mut URL: *const xmlChar,
                                                   mut ID: *const xmlChar,
                                                   mut base: *const xmlChar)
 -> xmlParserCtxtPtr {
    return xmlCreateEntityParserCtxtInternal(URL, ID, base,
                                             0 as xmlParserCtxtPtr);
}
/* ***********************************************************************
 *									*
 *		Front ends when parsing from a file			*
 *									*
 ************************************************************************/
/* *
 * xmlCreateURLParserCtxt:
 * @filename:  the filename or URL
 * @options:  a combination of xmlParserOption
 *
 * Create a parser context for a file or URL content.
 * Automatic support for ZLIB/Compress compressed document is provided
 * by default if found at compile-time and for file accesses
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCreateURLParserCtxt(mut filename:
                                                    *const std::os::raw::c_char,
                                                mut options: std::os::raw::c_int)
 -> xmlParserCtxtPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut inputStream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut directory: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() {
        xmlErrMemory(0 as xmlParserCtxtPtr,
                     b"cannot allocate parser context\x00" as *const u8 as
                         *const std::os::raw::c_char);
        return 0 as xmlParserCtxtPtr
    }
    if options != 0 {
        xmlCtxtUseOptionsInternal(ctxt, options, 0 as *const std::os::raw::c_char);
    }
    (*ctxt).linenumbers = 1 as std::os::raw::c_int;
    inputStream =
        xmlLoadExternalEntity(filename, 0 as *const std::os::raw::c_char, ctxt);
    if inputStream.is_null() {
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlParserCtxtPtr
    }
    inputPush(ctxt, inputStream);
    if (*ctxt).directory.is_null() && directory.is_null() {
        directory = xmlParserGetDirectory(filename)
    }
    if (*ctxt).directory.is_null() && !directory.is_null() {
        (*ctxt).directory = directory
    }
    return ctxt;
}
/* *
 * Parser context.
 */
/* *
 * xmlCreateFileParserCtxt:
 * @filename:  the filename
 *
 * Create a parser context for a file content.
 * Automatic support for ZLIB/Compress compressed document is provided
 * by default if found at compile-time.
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCreateFileParserCtxt(mut filename:
                                                     *const std::os::raw::c_char)
 -> xmlParserCtxtPtr {
    return xmlCreateURLParserCtxt(filename, 0 as std::os::raw::c_int);
}
/* *
 * xmlSAXParseFileWithData:
 * @sax:  the SAX handler block
 * @filename:  the filename
 * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
 *             documents
 * @data:  the userdata
 *
 * parse an XML file and build a tree. Automatic support for ZLIB/Compress
 * compressed document is provided by default if found at compile-time.
 * It use the given SAX function block to handle the parsing callback.
 * If sax is NULL, fallback to the default DOM tree building routines.
 *
 * User data (void *) is stored within the parser context in the
 * context's _private member, so it is available nearly everywhere in libxml
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSAXParseFileWithData(mut sax: xmlSAXHandlerPtr,
                                                 mut filename:
                                                     *const std::os::raw::c_char,
                                                 mut recovery: std::os::raw::c_int,
                                                 mut data: *mut std::os::raw::c_void)
 -> xmlDocPtr {
    let mut ret: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    xmlInitParser();
    ctxt = xmlCreateFileParserCtxt(filename);
    if ctxt.is_null() { return 0 as xmlDocPtr }
    if !sax.is_null() {
        if !(*ctxt).sax.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).sax = sax
    }
    xmlDetectSAX2(ctxt);
    if !data.is_null() { (*ctxt)._private = data }
    if (*ctxt).directory.is_null() {
        (*ctxt).directory = xmlParserGetDirectory(filename)
    }
    (*ctxt).recovery = recovery;
    xmlParseDocument(ctxt);
    if (*ctxt).wellFormed != 0 || recovery != 0 {
        ret = (*ctxt).myDoc;
        if !ret.is_null() {
            if (*(*(*ctxt).input).buf).compressed > 0 as std::os::raw::c_int {
                (*ret).compression = 9 as std::os::raw::c_int
            } else { (*ret).compression = (*(*(*ctxt).input).buf).compressed }
        }
    } else {
        ret = 0 as xmlDocPtr;
        xmlFreeDoc((*ctxt).myDoc);
        (*ctxt).myDoc = 0 as xmlDocPtr
    }
    if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
    xmlFreeParserCtxt(ctxt);
    return ret;
}
/* *
 * xmlSAXParseFile:
 * @sax:  the SAX handler block
 * @filename:  the filename
 * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
 *             documents
 *
 * parse an XML file and build a tree. Automatic support for ZLIB/Compress
 * compressed document is provided by default if found at compile-time.
 * It use the given SAX function block to handle the parsing callback.
 * If sax is NULL, fallback to the default DOM tree building routines.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSAXParseFile(mut sax: xmlSAXHandlerPtr,
                                         mut filename: *const std::os::raw::c_char,
                                         mut recovery: std::os::raw::c_int)
 -> xmlDocPtr {
    return xmlSAXParseFileWithData(sax, filename, recovery,
                                   0 as *mut std::os::raw::c_void);
}
/* *
 * xmlRecoverDoc:
 * @cur:  a pointer to an array of xmlChar
 *
 * parse an XML in-memory document and build a tree.
 * In the case the document is not Well Formed, a attempt to build a
 * tree is tried anyway
 *
 * Returns the resulting document tree or NULL in case of failure
 */
#[no_mangle]
pub unsafe extern "C" fn xmlRecoverDoc(mut cur: *const xmlChar) -> xmlDocPtr {
    return xmlSAXParseDoc(0 as xmlSAXHandlerPtr, cur, 1 as std::os::raw::c_int);
}
/* *
 * xmlParseFile:
 * @filename:  the filename
 *
 * parse an XML file and build a tree. Automatic support for ZLIB/Compress
 * compressed document is provided by default if found at compile-time.
 *
 * Returns the resulting document tree if the file was wellformed,
 * NULL otherwise.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseFile(mut filename: *const std::os::raw::c_char)
 -> xmlDocPtr {
    return xmlSAXParseFile(0 as xmlSAXHandlerPtr, filename, 0 as std::os::raw::c_int);
}
/* *
 * xmlRecoverFile:
 * @filename:  the filename
 *
 * parse an XML file and build a tree. Automatic support for ZLIB/Compress
 * compressed document is provided by default if found at compile-time.
 * In the case the document is not Well Formed, it attempts to build
 * a tree anyway
 *
 * Returns the resulting document tree or NULL in case of failure
 */
#[no_mangle]
pub unsafe extern "C" fn xmlRecoverFile(mut filename: *const std::os::raw::c_char)
 -> xmlDocPtr {
    return xmlSAXParseFile(0 as xmlSAXHandlerPtr, filename, 1 as std::os::raw::c_int);
}
/* *
 * xmlSetupParserForBuffer:
 * @ctxt:  an XML parser context
 * @buffer:  a xmlChar * buffer
 * @filename:  a file name
 *
 * Setup the parser context to parse a new buffer; Clears any prior
 * contents from the parser context. The buffer parameter must not be
 * NULL, but the filename parameter can be
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSetupParserForBuffer(mut ctxt: xmlParserCtxtPtr,
                                                 mut buffer: *const xmlChar,
                                                 mut filename:
                                                     *const std::os::raw::c_char) {
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if ctxt.is_null() || buffer.is_null() { return }
    input = xmlNewInputStream(ctxt);
    if input.is_null() {
        xmlErrMemory(0 as xmlParserCtxtPtr,
                     b"parsing new buffer: out of memory\n\x00" as *const u8
                         as *const std::os::raw::c_char);
        xmlClearParserCtxt(ctxt);
        return
    }
    xmlClearParserCtxt(ctxt);
    if !filename.is_null() {
        (*input).filename =
            xmlCanonicPath(filename as *const xmlChar) as *mut std::os::raw::c_char
    }
    (*input).base = buffer;
    (*input).cur = buffer;
    (*input).end =
        &*buffer.offset((xmlStrlen as
                             unsafe extern "C" fn(_: *const xmlChar)
                                 -> std::os::raw::c_int)(buffer) as isize) as
            *const xmlChar;
    inputPush(ctxt, input);
}
/* *
 * xmlSAXUserParseFile:
 * @sax:  a SAX handler
 * @user_data:  The user data returned on SAX callbacks
 * @filename:  a file name
 *
 * parse an XML file and call the given SAX handler routines.
 * Automatic support for ZLIB/Compress compressed document is provided
 *
 * Returns 0 in case of success or a error number otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSAXUserParseFile(mut sax: xmlSAXHandlerPtr,
                                             mut user_data: *mut std::os::raw::c_void,
                                             mut filename:
                                                 *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    ctxt = xmlCreateFileParserCtxt(filename);
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    if (*ctxt).sax != __xmlDefaultSAXHandler() as xmlSAXHandlerPtr {
        xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).sax = sax;
    xmlDetectSAX2(ctxt);
    if !user_data.is_null() { (*ctxt).userData = user_data }
    xmlParseDocument(ctxt);
    if (*ctxt).wellFormed != 0 {
        ret = 0 as std::os::raw::c_int
    } else if (*ctxt).errNo != 0 as std::os::raw::c_int {
        ret = (*ctxt).errNo
    } else { ret = -(1 as std::os::raw::c_int) }
    if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
    if !(*ctxt).myDoc.is_null() {
        xmlFreeDoc((*ctxt).myDoc);
        (*ctxt).myDoc = 0 as xmlDocPtr
    }
    xmlFreeParserCtxt(ctxt);
    return ret;
}
/* LIBXML_SAX1_ENABLED */
/* ***********************************************************************
 *									*
 *		Front ends when parsing from memory			*
 *									*
 ************************************************************************/
/* *
 * xmlCreateMemoryParserCtxt:
 * @buffer:  a pointer to a char array
 * @size:  the size of the array
 *
 * Create a parser context for an XML in-memory document.
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCreateMemoryParserCtxt(mut buffer:
                                                       *const std::os::raw::c_char,
                                                   mut size: std::os::raw::c_int)
 -> xmlParserCtxtPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    if buffer.is_null() { return 0 as xmlParserCtxtPtr }
    if size <= 0 as std::os::raw::c_int { return 0 as xmlParserCtxtPtr }
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() { return 0 as xmlParserCtxtPtr }
    /* TODO: xmlParserInputBufferCreateStatic, requires some serious changes */
    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
    if buf.is_null() { xmlFreeParserCtxt(ctxt); return 0 as xmlParserCtxtPtr }
    input = xmlNewInputStream(ctxt);
    if input.is_null() {
        xmlFreeParserInputBuffer(buf);
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlParserCtxtPtr
    }
    (*input).filename = 0 as *const std::os::raw::c_char;
    (*input).buf = buf;
    xmlBufResetInput((*(*input).buf).buffer, input);
    inputPush(ctxt, input);
    return ctxt;
}
/* *
 * xmlSAXParseMemoryWithData:
 * @sax:  the SAX handler block
 * @buffer:  an pointer to a char array
 * @size:  the size of the array
 * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
 *             documents
 * @data:  the userdata
 *
 * parse an XML in-memory block and use the given SAX function block
 * to handle the parsing callback. If sax is NULL, fallback to the default
 * DOM tree building routines.
 *
 * User data (void *) is stored within the parser context in the
 * context's _private member, so it is available nearly everywhere in libxml
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSAXParseMemoryWithData(mut sax: xmlSAXHandlerPtr,
                                                   mut buffer:
                                                       *const std::os::raw::c_char,
                                                   mut size: std::os::raw::c_int,
                                                   mut recovery: std::os::raw::c_int,
                                                   mut data:
                                                       *mut std::os::raw::c_void)
 -> xmlDocPtr {
    let mut ret: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    xmlInitParser();
    ctxt = xmlCreateMemoryParserCtxt(buffer, size);
    if ctxt.is_null() { return 0 as xmlDocPtr }
    if !sax.is_null() {
        if !(*ctxt).sax.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).sax = sax
    }
    xmlDetectSAX2(ctxt);
    if !data.is_null() { (*ctxt)._private = data }
    (*ctxt).recovery = recovery;
    xmlParseDocument(ctxt);
    if (*ctxt).wellFormed != 0 || recovery != 0 {
        ret = (*ctxt).myDoc
    } else {
        ret = 0 as xmlDocPtr;
        xmlFreeDoc((*ctxt).myDoc);
        (*ctxt).myDoc = 0 as xmlDocPtr
    }
    if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
    xmlFreeParserCtxt(ctxt);
    return ret;
}
/* *
 * xmlSAXParseMemory:
 * @sax:  the SAX handler block
 * @buffer:  an pointer to a char array
 * @size:  the size of the array
 * @recovery:  work in recovery mode, i.e. tries to read not Well Formed
 *             documents
 *
 * parse an XML in-memory block and use the given SAX function block
 * to handle the parsing callback. If sax is NULL, fallback to the default
 * DOM tree building routines.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSAXParseMemory(mut sax: xmlSAXHandlerPtr,
                                           mut buffer: *const std::os::raw::c_char,
                                           mut size: std::os::raw::c_int,
                                           mut recovery: std::os::raw::c_int)
 -> xmlDocPtr {
    return xmlSAXParseMemoryWithData(sax, buffer, size, recovery,
                                     0 as *mut std::os::raw::c_void);
}
/* *
 * xmlParseMemory:
 * @buffer:  an pointer to a char array
 * @size:  the size of the array
 *
 * parse an XML in-memory block and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseMemory(mut buffer: *const std::os::raw::c_char,
                                        mut size: std::os::raw::c_int) -> xmlDocPtr {
    return xmlSAXParseMemory(0 as xmlSAXHandlerPtr, buffer, size,
                             0 as std::os::raw::c_int);
}
/* *
 * xmlRecoverMemory:
 * @buffer:  an pointer to a char array
 * @size:  the size of the array
 *
 * parse an XML in-memory block and build a tree.
 * In the case the document is not Well Formed, an attempt to
 * build a tree is tried anyway
 *
 * Returns the resulting document tree or NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlRecoverMemory(mut buffer: *const std::os::raw::c_char,
                                          mut size: std::os::raw::c_int)
 -> xmlDocPtr {
    return xmlSAXParseMemory(0 as xmlSAXHandlerPtr, buffer, size,
                             1 as std::os::raw::c_int);
}
/* *
 * xmlSAXUserParseMemory:
 * @sax:  a SAX handler
 * @user_data:  The user data returned on SAX callbacks
 * @buffer:  an in-memory XML document input
 * @size:  the length of the XML document in bytes
 *
 * A better SAX parsing routine.
 * parse an XML in-memory buffer and call the given SAX handler routines.
 *
 * Returns 0 in case of success or a error number otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSAXUserParseMemory(mut sax: xmlSAXHandlerPtr,
                                               mut user_data:
                                                   *mut std::os::raw::c_void,
                                               mut buffer:
                                                   *const std::os::raw::c_char,
                                               mut size: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    xmlInitParser();
    ctxt = xmlCreateMemoryParserCtxt(buffer, size);
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    if (*ctxt).sax != __xmlDefaultSAXHandler() as xmlSAXHandlerPtr {
        xmlFree.expect("non-null function pointer")((*ctxt).sax as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).sax = sax;
    xmlDetectSAX2(ctxt);
    if !user_data.is_null() { (*ctxt).userData = user_data }
    xmlParseDocument(ctxt);
    if (*ctxt).wellFormed != 0 {
        ret = 0 as std::os::raw::c_int
    } else if (*ctxt).errNo != 0 as std::os::raw::c_int {
        ret = (*ctxt).errNo
    } else { ret = -(1 as std::os::raw::c_int) }
    if !sax.is_null() { (*ctxt).sax = 0 as *mut _xmlSAXHandler }
    if !(*ctxt).myDoc.is_null() {
        xmlFreeDoc((*ctxt).myDoc);
        (*ctxt).myDoc = 0 as xmlDocPtr
    }
    xmlFreeParserCtxt(ctxt);
    return ret;
}
/* LIBXML_SAX1_ENABLED */
/* *
 * xmlCreateDocParserCtxt:
 * @cur:  a pointer to an array of xmlChar
 *
 * Creates a parser context for an XML in-memory document.
 *
 * Returns the new parser context or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCreateDocParserCtxt(mut cur: *const xmlChar)
 -> xmlParserCtxtPtr {
    let mut len: std::os::raw::c_int = 0;
    if cur.is_null() { return 0 as xmlParserCtxtPtr }
    len = xmlStrlen(cur);
    return xmlCreateMemoryParserCtxt(cur as *const std::os::raw::c_char, len);
}
/* *
 * xmlSAXParseDoc:
 * @sax:  the SAX handler block
 * @cur:  a pointer to an array of xmlChar
 * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
 *             documents
 *
 * parse an XML in-memory document and build a tree.
 * It use the given SAX function block to handle the parsing callback.
 * If sax is NULL, fallback to the default DOM tree building routines.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSAXParseDoc(mut sax: xmlSAXHandlerPtr,
                                        mut cur: *const xmlChar,
                                        mut recovery: std::os::raw::c_int)
 -> xmlDocPtr {
    let mut ret: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut oldsax: xmlSAXHandlerPtr = 0 as xmlSAXHandlerPtr;
    if cur.is_null() { return 0 as xmlDocPtr }
    ctxt = xmlCreateDocParserCtxt(cur);
    if ctxt.is_null() { return 0 as xmlDocPtr }
    if !sax.is_null() {
        oldsax = (*ctxt).sax;
        (*ctxt).sax = sax;
        (*ctxt).userData = 0 as *mut std::os::raw::c_void
    }
    xmlDetectSAX2(ctxt);
    xmlParseDocument(ctxt);
    if (*ctxt).wellFormed != 0 || recovery != 0 {
        ret = (*ctxt).myDoc
    } else {
        ret = 0 as xmlDocPtr;
        xmlFreeDoc((*ctxt).myDoc);
        (*ctxt).myDoc = 0 as xmlDocPtr
    }
    if !sax.is_null() { (*ctxt).sax = oldsax }
    xmlFreeParserCtxt(ctxt);
    return ret;
}
/* *
 * xmlParseDoc:
 * @cur:  a pointer to an array of xmlChar
 *
 * parse an XML in-memory document and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlParseDoc(mut cur: *const xmlChar) -> xmlDocPtr {
    return xmlSAXParseDoc(0 as xmlSAXHandlerPtr, cur, 0 as std::os::raw::c_int);
}
/* LIBXML_SAX1_ENABLED */
/* ***********************************************************************
 *									*
 *	Specific function to keep track of entities references		*
 *	and used by the XSLT debugger					*
 *									*
 ************************************************************************/
static mut xmlEntityRefFunc: xmlEntityReferenceFunc = None;
/* *
 * xmlAddEntityReference:
 * @ent : A valid entity
 * @firstNode : A valid first node for children of entity
 * @lastNode : A valid last node of children entity
 *
 * Notify of a reference to an entity of type XML_EXTERNAL_GENERAL_PARSED_ENTITY
 */
unsafe extern "C" fn xmlAddEntityReference(mut ent: xmlEntityPtr,
                                           mut firstNode: xmlNodePtr,
                                           mut lastNode: xmlNodePtr) {
    if xmlEntityRefFunc.is_some() {
        Some(xmlEntityRefFunc.expect("non-null function pointer")).expect("non-null function pointer")(ent,
                                                                                                       firstNode,
                                                                                                       lastNode);
    };
}
/* *
 * xmlSetEntityReferenceFunc:
 * @func: A valid function
 *
 * Set the function to call call back when a xml reference has been made
 */
#[no_mangle]
pub unsafe extern "C" fn xmlSetEntityReferenceFunc(mut func:
                                                       xmlEntityReferenceFunc) {
    xmlEntityRefFunc = func;
}
static mut xmlParserInitialized: std::os::raw::c_int = 0 as std::os::raw::c_int;
/* *
 * xmlInitParser:
 *
 * Initialization function for the XML parser.
 * This is not reentrant. Call once before processing in case of
 * use in multithreaded programs.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlInitParser() {
    if xmlParserInitialized != 0 as std::os::raw::c_int { return }
    __xmlGlobalInitMutexLock();
    if xmlParserInitialized == 0 as std::os::raw::c_int {
        xmlInitThreads();
        xmlInitGlobals();
        if *__xmlGenericError() ==
               Some(xmlGenericErrorDefaultFunc as
                        unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                             _: *const std::os::raw::c_char, _: ...)
                            -> ()) || (*__xmlGenericError()).is_none() {
            initGenericErrorDefaultFunc(0 as *mut xmlGenericErrorFunc);
        }
        xmlInitMemory();
        xmlInitializeDict();
        xmlInitCharEncodingHandlers();
        xmlDefaultSAXHandlerInit();
        xmlRegisterDefaultInputCallbacks();
        xmlRegisterDefaultOutputCallbacks();
        /* LIBXML_OUTPUT_ENABLED */
        htmlInitAutoClose();
        htmlDefaultSAXHandlerInit();
        xmlXPathInit();
        xmlParserInitialized = 1 as std::os::raw::c_int
    }
    __xmlGlobalInitMutexUnlock();
}
/* *
 * xmlCleanupParser:
 *
 * This function name is somewhat misleading. It does not clean up
 * parser state, it cleans up memory allocated by the library itself.
 * It is a cleanup function for the XML library. It tries to reclaim all
 * related global memory allocated for the library processing.
 * It doesn't deallocate any document related memory. One should
 * call xmlCleanupParser() only when the process has finished using
 * the library and all XML/HTML documents built with it.
 * See also xmlInitParser() which has the opposite function of preparing
 * the library for operations.
 *
 * WARNING: if your application is multithreaded or has plugin support
 *          calling this may crash the application if another thread or
 *          a plugin is still using libxml2. It's sometimes very hard to
 *          guess if libxml2 is in use in the application, some libraries
 *          or plugins may use it without notice. In case of doubt abstain
 *          from calling this function or do it just before calling exit()
 *          to avoid leak reports from valgrind !
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCleanupParser() {
    if xmlParserInitialized == 0 {
        return
    } /* must be last if called not from the main thread */
    xmlCleanupCharEncodingHandlers();
    xmlCatalogCleanup();
    xmlDictCleanup();
    xmlCleanupInputCallbacks();
    xmlCleanupOutputCallbacks();
    xmlSchemaCleanupTypes();
    xmlRelaxNGCleanupTypes();
    xmlResetLastError();
    xmlCleanupGlobals();
    xmlCleanupThreads();
    xmlCleanupMemory();
    xmlParserInitialized = 0 as std::os::raw::c_int;
}
/* ***********************************************************************
 *									*
 *	New set (2.6.0) of simpler and more flexible APIs		*
 *									*
 ************************************************************************/
/* *
 * DICT_FREE:
 * @str:  a string
 *
 * Free a string if it is not owned by the "dict" dictionary in the
 * current scope
 */
/* *
 * xmlCtxtReset:
 * @ctxt: an XML parser context
 *
 * Reset a parser context
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCtxtReset(mut ctxt: xmlParserCtxtPtr) {
    let mut input: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut dict: xmlDictPtr = 0 as *mut xmlDict;
    if ctxt.is_null() { return }
    dict = (*ctxt).dict;
    loop  {
        input = inputPop(ctxt);
        if input.is_null() { break ; }
        /* Non consuming */
        xmlFreeInputStream(input);
    }
    (*ctxt).inputNr = 0 as std::os::raw::c_int;
    (*ctxt).input = 0 as xmlParserInputPtr;
    (*ctxt).spaceNr = 0 as std::os::raw::c_int;
    if !(*ctxt).spaceTab.is_null() {
        *(*ctxt).spaceTab.offset(0 as std::os::raw::c_int as isize) =
            -(1 as std::os::raw::c_int);
        (*ctxt).space =
            &mut *(*ctxt).spaceTab.offset(0 as std::os::raw::c_int as isize) as
                *mut std::os::raw::c_int
    } else { (*ctxt).space = 0 as *mut std::os::raw::c_int }
    (*ctxt).nodeNr = 0 as std::os::raw::c_int;
    (*ctxt).node = 0 as xmlNodePtr;
    (*ctxt).nameNr = 0 as std::os::raw::c_int;
    (*ctxt).name = 0 as *const xmlChar;
    if !(*ctxt).version.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).version) == 0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).version as
                                                        *mut std::os::raw::c_char as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).version = 0 as *const xmlChar;
    if !(*ctxt).encoding.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).encoding) == 0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).encoding as
                                                        *mut std::os::raw::c_char as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).encoding = 0 as *const xmlChar;
    if !(*ctxt).directory.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).directory as *const xmlChar) ==
                    0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).directory as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).directory = 0 as *mut std::os::raw::c_char;
    if !(*ctxt).extSubURI.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).extSubURI as *const xmlChar) ==
                    0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).extSubURI as
                                                        *mut std::os::raw::c_char as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).extSubURI = 0 as *mut xmlChar;
    if !(*ctxt).extSubSystem.is_null() &&
           (dict.is_null() ||
                xmlDictOwns(dict, (*ctxt).extSubSystem as *const xmlChar) ==
                    0 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*ctxt).extSubSystem as
                                                        *mut std::os::raw::c_char as
                                                        *mut std::os::raw::c_void);
    }
    (*ctxt).extSubSystem = 0 as *mut xmlChar;
    if !(*ctxt).myDoc.is_null() { xmlFreeDoc((*ctxt).myDoc); }
    (*ctxt).myDoc = 0 as xmlDocPtr;
    (*ctxt).standalone = -(1 as std::os::raw::c_int);
    (*ctxt).hasExternalSubset = 0 as std::os::raw::c_int;
    (*ctxt).hasPErefs = 0 as std::os::raw::c_int;
    (*ctxt).html = 0 as std::os::raw::c_int;
    (*ctxt).external = 0 as std::os::raw::c_int;
    (*ctxt).instate = XML_PARSER_START;
    (*ctxt).token = 0 as std::os::raw::c_int;
    (*ctxt).wellFormed = 1 as std::os::raw::c_int;
    (*ctxt).nsWellFormed = 1 as std::os::raw::c_int;
    (*ctxt).disableSAX = 0 as std::os::raw::c_int;
    (*ctxt).valid = 1 as std::os::raw::c_int;
    (*ctxt).record_info = 0 as std::os::raw::c_int;
    (*ctxt).nbChars = 0 as std::os::raw::c_int as std::os::raw::c_long;
    (*ctxt).checkIndex = 0 as std::os::raw::c_int as std::os::raw::c_long;
    (*ctxt).inSubset = 0 as std::os::raw::c_int;
    (*ctxt).errNo = XML_ERR_OK as std::os::raw::c_int;
    (*ctxt).depth = 0 as std::os::raw::c_int;
    (*ctxt).charset = XML_CHAR_ENCODING_UTF8 as std::os::raw::c_int;
    (*ctxt).catalogs = 0 as *mut std::os::raw::c_void;
    (*ctxt).nbentities = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    (*ctxt).sizeentities = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    (*ctxt).sizeentcopy = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    xmlInitNodeInfoSeq(&mut (*ctxt).node_seq);
    if !(*ctxt).attsDefault.is_null() {
        xmlHashFree((*ctxt).attsDefault,
                    Some(xmlHashDefaultDeallocator as
                             unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                                  _: *const xmlChar) -> ()));
        (*ctxt).attsDefault = 0 as xmlHashTablePtr
    }
    if !(*ctxt).attsSpecial.is_null() {
        xmlHashFree((*ctxt).attsSpecial, None);
        (*ctxt).attsSpecial = 0 as xmlHashTablePtr
    }
    if !(*ctxt).catalogs.is_null() { xmlCatalogFreeLocal((*ctxt).catalogs); }
    if (*ctxt).lastError.code != XML_ERR_OK as std::os::raw::c_int {
        xmlResetError(&mut (*ctxt).lastError);
    };
}
/* *
 * xmlCtxtResetPush:
 * @ctxt: an XML parser context
 * @chunk:  a pointer to an array of chars
 * @size:  number of chars in the array
 * @filename:  an optional file name or URI
 * @encoding:  the document encoding, or NULL
 *
 * Reset a push parser context
 *
 * Returns 0 in case of success and 1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCtxtResetPush(mut ctxt: xmlParserCtxtPtr,
                                          mut chunk: *const std::os::raw::c_char,
                                          mut size: std::os::raw::c_int,
                                          mut filename: *const std::os::raw::c_char,
                                          mut encoding: *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    let mut inputStream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    let mut buf: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut enc: xmlCharEncoding = XML_CHAR_ENCODING_NONE;
    if ctxt.is_null() { return 1 as std::os::raw::c_int }
    if encoding.is_null() && !chunk.is_null() && size >= 4 as std::os::raw::c_int {
        enc = xmlDetectCharEncoding(chunk as *const xmlChar, size)
    }
    buf = xmlAllocParserInputBuffer(enc);
    if buf.is_null() { return 1 as std::os::raw::c_int }
    if ctxt.is_null() {
        xmlFreeParserInputBuffer(buf);
        return 1 as std::os::raw::c_int
    }
    xmlCtxtReset(ctxt);
    if (*ctxt).pushTab.is_null() {
        (*ctxt).pushTab =
            xmlMalloc.expect("non-null function pointer")((((*ctxt).nameMax *
                                                                3 as
                                                                    std::os::raw::c_int)
                                                               as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<*mut xmlChar>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut *mut std::os::raw::c_void;
        if (*ctxt).pushTab.is_null() {
            xmlErrMemory(ctxt, 0 as *const std::os::raw::c_char);
            xmlFreeParserInputBuffer(buf);
            return 1 as std::os::raw::c_int
        }
    }
    if filename.is_null() {
        (*ctxt).directory = 0 as *mut std::os::raw::c_char
    } else { (*ctxt).directory = xmlParserGetDirectory(filename) }
    inputStream = xmlNewInputStream(ctxt);
    if inputStream.is_null() {
        xmlFreeParserInputBuffer(buf);
        return 1 as std::os::raw::c_int
    }
    if filename.is_null() {
        (*inputStream).filename = 0 as *const std::os::raw::c_char
    } else {
        (*inputStream).filename =
            xmlCanonicPath(filename as *const xmlChar) as *mut std::os::raw::c_char
    }
    (*inputStream).buf = buf;
    xmlBufResetInput((*buf).buffer, inputStream);
    inputPush(ctxt, inputStream);
    if size > 0 as std::os::raw::c_int && !chunk.is_null() && !(*ctxt).input.is_null()
           && !(*(*ctxt).input).buf.is_null() {
        let mut base: size_t =
            xmlBufGetInputBase((*(*(*ctxt).input).buf).buffer, (*ctxt).input);
        let mut cur: size_t =
            (*(*ctxt).input).cur.offset_from((*(*ctxt).input).base)
                as std::os::raw::c_long as size_t;
        xmlParserInputBufferPush((*(*ctxt).input).buf, size, chunk);
        xmlBufSetInputBaseCur((*(*(*ctxt).input).buf).buffer, (*ctxt).input,
                              base, cur);
    }
    if !encoding.is_null() {
        let mut hdlr: xmlCharEncodingHandlerPtr =
            0 as *mut xmlCharEncodingHandler;
        if !(*ctxt).encoding.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).encoding as
                                                            *mut xmlChar as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).encoding = xmlStrdup(encoding as *const xmlChar);
        hdlr = xmlFindCharEncodingHandler(encoding);
        if !hdlr.is_null() {
            xmlSwitchToEncoding(ctxt, hdlr);
        } else {
            xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
                              b"Unsupported encoding %s\n\x00" as *const u8 as
                                  *const std::os::raw::c_char,
                              encoding as *mut xmlChar);
        }
    } else if enc as std::os::raw::c_int != XML_CHAR_ENCODING_NONE as std::os::raw::c_int {
        xmlSwitchEncoding(ctxt, enc);
    }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlCtxtUseOptionsInternal:
 * @ctxt: an XML parser context
 * @options:  a combination of xmlParserOption
 * @encoding:  the user provided encoding to use
 *
 * Applies the options to the parser context
 *
 * Returns 0 in case of success, the set of unknown or unimplemented options
 *         in case of error.
 */
unsafe extern "C" fn xmlCtxtUseOptionsInternal(mut ctxt: xmlParserCtxtPtr,
                                               mut options: std::os::raw::c_int,
                                               mut encoding:
                                                   *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    if ctxt.is_null() { return -(1 as std::os::raw::c_int) }
    if !encoding.is_null() {
        if !(*ctxt).encoding.is_null() {
            xmlFree.expect("non-null function pointer")((*ctxt).encoding as
                                                            *mut xmlChar as
                                                            *mut std::os::raw::c_void);
        }
        (*ctxt).encoding = xmlStrdup(encoding as *const xmlChar)
    }
    if options & XML_PARSE_RECOVER as std::os::raw::c_int != 0 {
        (*ctxt).recovery = 1 as std::os::raw::c_int;
        options -= XML_PARSE_RECOVER as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_RECOVER as std::os::raw::c_int
    } else { (*ctxt).recovery = 0 as std::os::raw::c_int }
    if options & XML_PARSE_DTDLOAD as std::os::raw::c_int != 0 {
        (*ctxt).loadsubset = 2 as std::os::raw::c_int;
        options -= XML_PARSE_DTDLOAD as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_DTDLOAD as std::os::raw::c_int
    } else { (*ctxt).loadsubset = 0 as std::os::raw::c_int }
    if options & XML_PARSE_DTDATTR as std::os::raw::c_int != 0 {
        (*ctxt).loadsubset |= 4 as std::os::raw::c_int;
        options -= XML_PARSE_DTDATTR as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_DTDATTR as std::os::raw::c_int
    }
    if options & XML_PARSE_NOENT as std::os::raw::c_int != 0 {
        (*ctxt).replaceEntities = 1 as std::os::raw::c_int;
        /* ctxt->loadsubset |= XML_DETECT_IDS; */
        options -= XML_PARSE_NOENT as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_NOENT as std::os::raw::c_int
    } else { (*ctxt).replaceEntities = 0 as std::os::raw::c_int }
    if options & XML_PARSE_PEDANTIC as std::os::raw::c_int != 0 {
        (*ctxt).pedantic = 1 as std::os::raw::c_int;
        options -= XML_PARSE_PEDANTIC as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_PEDANTIC as std::os::raw::c_int
    } else { (*ctxt).pedantic = 0 as std::os::raw::c_int }
    if options & XML_PARSE_NOBLANKS as std::os::raw::c_int != 0 {
        (*ctxt).keepBlanks = 0 as std::os::raw::c_int;
        (*(*ctxt).sax).ignorableWhitespace =
            Some(xmlSAX2IgnorableWhitespace as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar, _: std::os::raw::c_int)
                         -> ());
        options -= XML_PARSE_NOBLANKS as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_NOBLANKS as std::os::raw::c_int
    } else { (*ctxt).keepBlanks = 1 as std::os::raw::c_int }
    if options & XML_PARSE_DTDVALID as std::os::raw::c_int != 0 {
        (*ctxt).validate = 1 as std::os::raw::c_int;
        if options & XML_PARSE_NOWARNING as std::os::raw::c_int != 0 {
            (*ctxt).vctxt.warning = None
        }
        if options & XML_PARSE_NOERROR as std::os::raw::c_int != 0 {
            (*ctxt).vctxt.error = None
        }
        options -= XML_PARSE_DTDVALID as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_DTDVALID as std::os::raw::c_int
    } else { (*ctxt).validate = 0 as std::os::raw::c_int }
    if options & XML_PARSE_NOWARNING as std::os::raw::c_int != 0 {
        (*(*ctxt).sax).warning = None;
        options -= XML_PARSE_NOWARNING as std::os::raw::c_int
    }
    if options & XML_PARSE_NOERROR as std::os::raw::c_int != 0 {
        (*(*ctxt).sax).error = None;
        (*(*ctxt).sax).fatalError = None;
        options -= XML_PARSE_NOERROR as std::os::raw::c_int
    }
    if options & XML_PARSE_SAX1 as std::os::raw::c_int != 0 {
        (*(*ctxt).sax).startElement =
            Some(xmlSAX2StartElement as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar,
                                          _: *mut *const xmlChar) -> ());
        (*(*ctxt).sax).endElement =
            Some(xmlSAX2EndElement as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *const xmlChar) -> ());
        (*(*ctxt).sax).startElementNs = None;
        (*(*ctxt).sax).endElementNs = None;
        (*(*ctxt).sax).initialized = 1 as std::os::raw::c_int as std::os::raw::c_uint;
        options -= XML_PARSE_SAX1 as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_SAX1 as std::os::raw::c_int
    }
    /* LIBXML_SAX1_ENABLED */
    if options & XML_PARSE_NODICT as std::os::raw::c_int != 0 {
        (*ctxt).dictNames = 0 as std::os::raw::c_int;
        options -= XML_PARSE_NODICT as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_NODICT as std::os::raw::c_int
    } else { (*ctxt).dictNames = 1 as std::os::raw::c_int }
    if options & XML_PARSE_NOCDATA as std::os::raw::c_int != 0 {
        (*(*ctxt).sax).cdataBlock = None;
        options -= XML_PARSE_NOCDATA as std::os::raw::c_int;
        (*ctxt).options |= XML_PARSE_NOCDATA as std::os::raw::c_int
    }
    if options & XML_PARSE_NSCLEAN as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_NSCLEAN as std::os::raw::c_int;
        options -= XML_PARSE_NSCLEAN as std::os::raw::c_int
    }
    if options & XML_PARSE_NONET as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_NONET as std::os::raw::c_int;
        options -= XML_PARSE_NONET as std::os::raw::c_int
    }
    if options & XML_PARSE_COMPACT as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_COMPACT as std::os::raw::c_int;
        options -= XML_PARSE_COMPACT as std::os::raw::c_int
    }
    if options & XML_PARSE_OLD10 as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_OLD10 as std::os::raw::c_int;
        options -= XML_PARSE_OLD10 as std::os::raw::c_int
    }
    if options & XML_PARSE_NOBASEFIX as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_NOBASEFIX as std::os::raw::c_int;
        options -= XML_PARSE_NOBASEFIX as std::os::raw::c_int
    }
    if options & XML_PARSE_HUGE as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_HUGE as std::os::raw::c_int;
        options -= XML_PARSE_HUGE as std::os::raw::c_int;
        if !(*ctxt).dict.is_null() {
            xmlDictSetLimit((*ctxt).dict, 0 as std::os::raw::c_int as size_t);
        }
    }
    if options & XML_PARSE_OLDSAX as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_OLDSAX as std::os::raw::c_int;
        options -= XML_PARSE_OLDSAX as std::os::raw::c_int
    }
    if options & XML_PARSE_IGNORE_ENC as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_IGNORE_ENC as std::os::raw::c_int;
        options -= XML_PARSE_IGNORE_ENC as std::os::raw::c_int
    }
    if options & XML_PARSE_BIG_LINES as std::os::raw::c_int != 0 {
        (*ctxt).options |= XML_PARSE_BIG_LINES as std::os::raw::c_int;
        options -= XML_PARSE_BIG_LINES as std::os::raw::c_int
    }
    (*ctxt).linenumbers = 1 as std::os::raw::c_int;
    return options;
}
/* *
 * xmlCtxtUseOptions:
 * @ctxt: an XML parser context
 * @options:  a combination of xmlParserOption
 *
 * Applies the options to the parser context
 *
 * Returns 0 in case of success, the set of unknown or unimplemented options
 *         in case of error.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCtxtUseOptions(mut ctxt: xmlParserCtxtPtr,
                                           mut options: std::os::raw::c_int)
 -> std::os::raw::c_int {
    return xmlCtxtUseOptionsInternal(ctxt, options, 0 as *const std::os::raw::c_char);
}
/* *
 * xmlDoRead:
 * @ctxt:  an XML parser context
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 * @reuse:  keep the context for reuse
 *
 * Common front-end for the xmlRead functions
 *
 * Returns the resulting document tree or NULL
 */
unsafe extern "C" fn xmlDoRead(mut ctxt: xmlParserCtxtPtr,
                               mut URL: *const std::os::raw::c_char,
                               mut encoding: *const std::os::raw::c_char,
                               mut options: std::os::raw::c_int,
                               mut reuse: std::os::raw::c_int) -> xmlDocPtr {
    let mut ret: xmlDocPtr = 0 as *mut xmlDoc;
    xmlCtxtUseOptionsInternal(ctxt, options, encoding);
    if !encoding.is_null() {
        let mut hdlr: xmlCharEncodingHandlerPtr =
            0 as *mut xmlCharEncodingHandler;
        hdlr = xmlFindCharEncodingHandler(encoding);
        if !hdlr.is_null() { xmlSwitchToEncoding(ctxt, hdlr); }
    }
    if !URL.is_null() && !(*ctxt).input.is_null() &&
           (*(*ctxt).input).filename.is_null() {
        (*(*ctxt).input).filename =
            xmlStrdup(URL as *const xmlChar) as *mut std::os::raw::c_char
    }
    xmlParseDocument(ctxt);
    if (*ctxt).wellFormed != 0 || (*ctxt).recovery != 0 {
        ret = (*ctxt).myDoc
    } else {
        ret = 0 as xmlDocPtr;
        if !(*ctxt).myDoc.is_null() { xmlFreeDoc((*ctxt).myDoc); }
    }
    (*ctxt).myDoc = 0 as xmlDocPtr;
    if reuse == 0 { xmlFreeParserCtxt(ctxt); }
    return ret;
}
/* *
 * xmlReadDoc:
 * @cur:  a pointer to a zero terminated string
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML in-memory document and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlReadDoc(mut cur: *const xmlChar,
                                    mut URL: *const std::os::raw::c_char,
                                    mut encoding: *const std::os::raw::c_char,
                                    mut options: std::os::raw::c_int) -> xmlDocPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    if cur.is_null() { return 0 as xmlDocPtr }
    xmlInitParser();
    ctxt = xmlCreateDocParserCtxt(cur);
    if ctxt.is_null() { return 0 as xmlDocPtr }
    return xmlDoRead(ctxt, URL, encoding, options, 0 as std::os::raw::c_int);
}
/* *
 * xmlReadFile:
 * @filename:  a file or URL
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML file from the filesystem or the network.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlReadFile(mut filename: *const std::os::raw::c_char,
                                     mut encoding: *const std::os::raw::c_char,
                                     mut options: std::os::raw::c_int) -> xmlDocPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    xmlInitParser();
    ctxt = xmlCreateURLParserCtxt(filename, options);
    if ctxt.is_null() { return 0 as xmlDocPtr }
    return xmlDoRead(ctxt, 0 as *const std::os::raw::c_char, encoding, options,
                     0 as std::os::raw::c_int);
}
/* *
 * xmlReadMemory:
 * @buffer:  a pointer to a char array
 * @size:  the size of the array
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML in-memory document and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlReadMemory(mut buffer: *const std::os::raw::c_char,
                                       mut size: std::os::raw::c_int,
                                       mut URL: *const std::os::raw::c_char,
                                       mut encoding: *const std::os::raw::c_char,
                                       mut options: std::os::raw::c_int)
 -> xmlDocPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    xmlInitParser();
    ctxt = xmlCreateMemoryParserCtxt(buffer, size);
    if ctxt.is_null() { return 0 as xmlDocPtr }
    return xmlDoRead(ctxt, URL, encoding, options, 0 as std::os::raw::c_int);
}
/* *
 * xmlReadFd:
 * @fd:  an open file descriptor
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML from a file descriptor and build a tree.
 * NOTE that the file descriptor will not be closed when the
 *      reader is closed or reset.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlReadFd(mut fd: std::os::raw::c_int,
                                   mut URL: *const std::os::raw::c_char,
                                   mut encoding: *const std::os::raw::c_char,
                                   mut options: std::os::raw::c_int) -> xmlDocPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if fd < 0 as std::os::raw::c_int { return 0 as xmlDocPtr }
    xmlInitParser();
    input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
    if input.is_null() { return 0 as xmlDocPtr }
    (*input).closecallback = None;
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as xmlDocPtr
    }
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlDocPtr
    }
    inputPush(ctxt, stream);
    return xmlDoRead(ctxt, URL, encoding, options, 0 as std::os::raw::c_int);
}
/* *
 * xmlReadIO:
 * @ioread:  an I/O read function
 * @ioclose:  an I/O close function
 * @ioctx:  an I/O handler
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML document from I/O functions and source and build a tree.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlReadIO(mut ioread: xmlInputReadCallback,
                                   mut ioclose: xmlInputCloseCallback,
                                   mut ioctx: *mut std::os::raw::c_void,
                                   mut URL: *const std::os::raw::c_char,
                                   mut encoding: *const std::os::raw::c_char,
                                   mut options: std::os::raw::c_int) -> xmlDocPtr {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if ioread.is_none() { return 0 as xmlDocPtr }
    xmlInitParser();
    input =
        xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
                                     XML_CHAR_ENCODING_NONE);
    if input.is_null() {
        if ioclose.is_some() {
            ioclose.expect("non-null function pointer")(ioctx);
        }
        return 0 as xmlDocPtr
    }
    ctxt = xmlNewParserCtxt();
    if ctxt.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as xmlDocPtr
    }
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        xmlFreeParserCtxt(ctxt);
        return 0 as xmlDocPtr
    }
    inputPush(ctxt, stream);
    return xmlDoRead(ctxt, URL, encoding, options, 0 as std::os::raw::c_int);
}
/* *
 * xmlCtxtReadDoc:
 * @ctxt:  an XML parser context
 * @cur:  a pointer to a zero terminated string
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML in-memory document and build a tree.
 * This reuses the existing @ctxt parser context
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCtxtReadDoc(mut ctxt: xmlParserCtxtPtr,
                                        mut cur: *const xmlChar,
                                        mut URL: *const std::os::raw::c_char,
                                        mut encoding: *const std::os::raw::c_char,
                                        mut options: std::os::raw::c_int)
 -> xmlDocPtr {
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if cur.is_null() { return 0 as xmlDocPtr }
    if ctxt.is_null() { return 0 as xmlDocPtr }
    xmlInitParser();
    xmlCtxtReset(ctxt);
    stream = xmlNewStringInputStream(ctxt, cur);
    if stream.is_null() { return 0 as xmlDocPtr }
    inputPush(ctxt, stream);
    return xmlDoRead(ctxt, URL, encoding, options, 1 as std::os::raw::c_int);
}
/* *
 * xmlCtxtReadFile:
 * @ctxt:  an XML parser context
 * @filename:  a file or URL
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML file from the filesystem or the network.
 * This reuses the existing @ctxt parser context
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCtxtReadFile(mut ctxt: xmlParserCtxtPtr,
                                         mut filename: *const std::os::raw::c_char,
                                         mut encoding: *const std::os::raw::c_char,
                                         mut options: std::os::raw::c_int)
 -> xmlDocPtr {
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if filename.is_null() { return 0 as xmlDocPtr }
    if ctxt.is_null() { return 0 as xmlDocPtr }
    xmlInitParser();
    xmlCtxtReset(ctxt);
    stream = xmlLoadExternalEntity(filename, 0 as *const std::os::raw::c_char, ctxt);
    if stream.is_null() { return 0 as xmlDocPtr }
    inputPush(ctxt, stream);
    return xmlDoRead(ctxt, 0 as *const std::os::raw::c_char, encoding, options,
                     1 as std::os::raw::c_int);
}
/* *
 * xmlCtxtReadMemory:
 * @ctxt:  an XML parser context
 * @buffer:  a pointer to a char array
 * @size:  the size of the array
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML in-memory document and build a tree.
 * This reuses the existing @ctxt parser context
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCtxtReadMemory(mut ctxt: xmlParserCtxtPtr,
                                           mut buffer: *const std::os::raw::c_char,
                                           mut size: std::os::raw::c_int,
                                           mut URL: *const std::os::raw::c_char,
                                           mut encoding: *const std::os::raw::c_char,
                                           mut options: std::os::raw::c_int)
 -> xmlDocPtr {
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if ctxt.is_null() { return 0 as xmlDocPtr }
    if buffer.is_null() { return 0 as xmlDocPtr }
    xmlInitParser();
    xmlCtxtReset(ctxt);
    input =
        xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
    if input.is_null() { return 0 as xmlDocPtr }
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as xmlDocPtr
    }
    inputPush(ctxt, stream);
    return xmlDoRead(ctxt, URL, encoding, options, 1 as std::os::raw::c_int);
}
/* *
 * xmlCtxtReadFd:
 * @ctxt:  an XML parser context
 * @fd:  an open file descriptor
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML from a file descriptor and build a tree.
 * This reuses the existing @ctxt parser context
 * NOTE that the file descriptor will not be closed when the
 *      reader is closed or reset.
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCtxtReadFd(mut ctxt: xmlParserCtxtPtr,
                                       mut fd: std::os::raw::c_int,
                                       mut URL: *const std::os::raw::c_char,
                                       mut encoding: *const std::os::raw::c_char,
                                       mut options: std::os::raw::c_int)
 -> xmlDocPtr {
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if fd < 0 as std::os::raw::c_int { return 0 as xmlDocPtr }
    if ctxt.is_null() { return 0 as xmlDocPtr }
    xmlInitParser();
    xmlCtxtReset(ctxt);
    input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
    if input.is_null() { return 0 as xmlDocPtr }
    (*input).closecallback = None;
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as xmlDocPtr
    }
    inputPush(ctxt, stream);
    return xmlDoRead(ctxt, URL, encoding, options, 1 as std::os::raw::c_int);
}
/*
 * Init/Cleanup
 */
/*
 * Input functions
 */
/*
 * Basic parsing Interfaces
 */
/* LIBXML_SAX1_ENABLED */
/*
 * Recovery mode
 */
/* LIBXML_SAX1_ENABLED */
/*
 * Less common routines and SAX interfaces
 */
/* LIBXML_SAX1_ENABLED */
/* LIBXML_VALID_ENABLE */
/* LIBXML_SAX1_ENABLED */
/* LIBXML_SAX1_ENABLED */
/*
 * Parser contexts handling.
 */
/* LIBXML_SAX1_ENABLED */
/*
 * Reading/setting optional parsing features.
 */
/* LIBXML_LEGACY_ENABLED */
/*
 * Interfaces for the Push mode.
 */
/* LIBXML_PUSH_ENABLED */
/*
 * Special I/O mode.
 */
/*
 * Node infos.
 */
/*
 * External entities handling actually implemented in xmlIO.
 */
/*
 * Index lookup, actually implemented in the encoding module
 */
/*
 * New set of simpler/more flexible APIs
 */
/* *
 * xmlParserOption:
 *
 * This is the set of XML parser options that can be passed down
 * to the xmlReadDoc() and similar calls.
 */
/* recover on errors */
/* substitute entities */
/* load the external subset */
/* default DTD attributes */
/* validate with the DTD */
/* suppress error reports */
/* suppress warning reports */
/* pedantic error reporting */
/* remove blank nodes */
/* use the SAX1 interface internally */
/* Implement XInclude substitition  */
/* Forbid network access */
/* Do not reuse the context dictionary */
/* remove redundant namespaces declarations */
/* merge CDATA as text nodes */
/* do not generate XINCLUDE START/END nodes */
/* compact small text nodes; no modification of
                                   the tree allowed afterwards (will possibly
				   crash if you try to modify the tree) */
/* parse using XML-1.0 before update 5 */
/* do not fixup XINCLUDE xml:base uris */
/* relax any hardcoded limit from the parser */
/* parse using SAX2 interface before 2.7.0 */
/* ignore internal document encoding hint */
/* Store big lines numbers in text PSVI field */
/* *
 * xmlCtxtReadIO:
 * @ctxt:  an XML parser context
 * @ioread:  an I/O read function
 * @ioclose:  an I/O close function
 * @ioctx:  an I/O handler
 * @URL:  the base URL to use for the document
 * @encoding:  the document encoding, or NULL
 * @options:  a combination of xmlParserOption
 *
 * parse an XML document from I/O functions and source and build a tree.
 * This reuses the existing @ctxt parser context
 *
 * Returns the resulting document tree
 */
#[no_mangle]
pub unsafe extern "C" fn xmlCtxtReadIO(mut ctxt: xmlParserCtxtPtr,
                                       mut ioread: xmlInputReadCallback,
                                       mut ioclose: xmlInputCloseCallback,
                                       mut ioctx: *mut std::os::raw::c_void,
                                       mut URL: *const std::os::raw::c_char,
                                       mut encoding: *const std::os::raw::c_char,
                                       mut options: std::os::raw::c_int)
 -> xmlDocPtr {
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut stream: xmlParserInputPtr = 0 as *mut xmlParserInput;
    if ioread.is_none() { return 0 as xmlDocPtr }
    if ctxt.is_null() { return 0 as xmlDocPtr }
    xmlInitParser();
    xmlCtxtReset(ctxt);
    input =
        xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
                                     XML_CHAR_ENCODING_NONE);
    if input.is_null() {
        if ioclose.is_some() {
            ioclose.expect("non-null function pointer")(ioctx);
        }
        return 0 as xmlDocPtr
    }
    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
    if stream.is_null() {
        xmlFreeParserInputBuffer(input);
        return 0 as xmlDocPtr
    }
    inputPush(ctxt, stream);
    return xmlDoRead(ctxt, URL, encoding, options, 1 as std::os::raw::c_int);
}
/* __INCLUDE_ELFGCCHACK */
