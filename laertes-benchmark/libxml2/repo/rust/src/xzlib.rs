
extern "C" {
    pub type internal_state;
    pub type lzma_internal_s;
    #[no_mangle]
    fn sprintf(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char, _: ...)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn memcpy(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_void, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn memcmp(_: *const std::os::raw::c_void, _: *const std::os::raw::c_void,
              _: std::os::raw::c_ulong) -> std::os::raw::c_int;
    #[no_mangle]
    fn strcpy(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strcat(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strlen(_: *const std::os::raw::c_char) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn strerror(_: std::os::raw::c_int) -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn __errno_location() -> *mut std::os::raw::c_int;
    #[no_mangle]
    fn open(__file: *const std::os::raw::c_char, __oflag: std::os::raw::c_int, _: ...)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn lseek(__fd: std::os::raw::c_int, __offset: __off64_t, __whence: std::os::raw::c_int)
     -> __off64_t;
    #[no_mangle]
    fn close(__fd: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn read(__fd: std::os::raw::c_int, __buf: *mut std::os::raw::c_void, __nbytes: size_t)
     -> ssize_t;
    #[no_mangle]
    fn free(__ptr: *mut std::os::raw::c_void);
    #[no_mangle]
    fn inflate(strm: z_streamp, flush: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn inflateEnd(strm: z_streamp) -> std::os::raw::c_int;
    #[no_mangle]
    fn inflateReset(strm: z_streamp) -> std::os::raw::c_int;
    #[no_mangle]
    fn crc32(crc: uLong, buf: *const Bytef, len: uInt) -> uLong;
    #[no_mangle]
    fn inflateInit2_(strm: z_streamp, windowBits: std::os::raw::c_int,
                     version: *const std::os::raw::c_char, stream_size: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn lzma_code(strm: *mut lzma_stream, action: lzma_action) -> lzma_ret;
    #[no_mangle]
    fn lzma_end(strm: *mut lzma_stream);
    #[no_mangle]
    fn lzma_properties_decode(filter: *mut lzma_filter,
                              allocator: *const lzma_allocator,
                              props: *const uint8_t, props_size: size_t)
     -> lzma_ret;
    #[no_mangle]
    fn lzma_auto_decoder(strm: *mut lzma_stream, memlimit: uint64_t,
                         flags: uint32_t) -> lzma_ret;
    /*
 * Summary: interface for all global variables of the library
 * Description: all the global variables and thread handling for
 *              those variables is handled by this module.
 *
 * The bottom of this file is automatically generated by build_glob.py
 * based on the description file global.data
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
 */
    /* *
 * xmlParserInputBufferCreateFilenameFunc:
 * @URI: the URI to read from
 * @enc: the requested source encoding
 *
 * Signature for the function doing the lookup for a suitable input method
 * corresponding to an URI.
 *
 * Returns the new xmlParserInputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /* *
 * xmlOutputBufferCreateFilenameFunc:
 * @URI: the URI to write to
 * @enc: the requested target encoding
 *
 * Signature for the function doing the lookup for a suitable output method
 * corresponding to an URI.
 *
 * Returns the new xmlOutputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /*
 * Externally global symbols which need to be protected for backwards
 * compatibility support.
 */
    /* *
 * xmlRegisterNodeFunc:
 * @node: the current node
 *
 * Signature for the registration callback of a created node
 */
    /* *
 * xmlDeregisterNodeFunc:
 * @node: the current node
 *
 * Signature for the deregistration callback of a discarded node
 */
    /* * DOC_DISABLE */
/*
 * In general the memory allocation entry points are not kept
 * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED
 *    - xmlMalloc
 *    - xmlMallocAtomic
 *    - xmlRealloc
 *    - xmlMemStrdup
 *    - xmlFree
 */
    /* !LIBXML_THREAD_ALLOC_ENABLED */
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    #[no_mangle]
    static mut xmlMalloc: xmlMallocFunc;
}
pub type size_t = std::os::raw::c_ulong;
pub type __uint8_t = std::os::raw::c_uchar;
pub type __uint32_t = std::os::raw::c_uint;
pub type __uint64_t = std::os::raw::c_ulong;
pub type __off64_t = std::os::raw::c_long;
pub type __ssize_t = std::os::raw::c_long;
pub type ssize_t = __ssize_t;
pub type Byte = std::os::raw::c_uchar;
pub type uInt = std::os::raw::c_uint;
pub type uLong = std::os::raw::c_ulong;
pub type Bytef = Byte;
pub type voidpf = *mut std::os::raw::c_void;
pub type alloc_func
    =
    Option<unsafe extern "C" fn(_: voidpf, _: uInt, _: uInt) -> voidpf>;
pub type free_func = Option<unsafe extern "C" fn(_: voidpf, _: voidpf) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct z_stream_s {
    pub next_in: *mut Bytef,
    pub avail_in: uInt,
    pub total_in: uLong,
    pub next_out: *mut Bytef,
    pub avail_out: uInt,
    pub total_out: uLong,
    pub msg: *mut std::os::raw::c_char,
    pub state: *mut internal_state,
    pub zalloc: alloc_func,
    pub zfree: free_func,
    pub opaque: voidpf,
    pub data_type: std::os::raw::c_int,
    pub adler: uLong,
    pub reserved: uLong,
}
pub type z_stream = z_stream_s;
pub type z_streamp = *mut z_stream;
pub type uint8_t = __uint8_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type lzma_reserved_enum = std::os::raw::c_uint;
pub const LZMA_RESERVED_ENUM: lzma_reserved_enum = 0;
pub type lzma_ret = std::os::raw::c_uint;
pub const LZMA_PROG_ERROR: lzma_ret = 11;
pub const LZMA_BUF_ERROR: lzma_ret = 10;
pub const LZMA_DATA_ERROR: lzma_ret = 9;
pub const LZMA_OPTIONS_ERROR: lzma_ret = 8;
pub const LZMA_FORMAT_ERROR: lzma_ret = 7;
pub const LZMA_MEMLIMIT_ERROR: lzma_ret = 6;
pub const LZMA_MEM_ERROR: lzma_ret = 5;
pub const LZMA_GET_CHECK: lzma_ret = 4;
pub const LZMA_UNSUPPORTED_CHECK: lzma_ret = 3;
pub const LZMA_NO_CHECK: lzma_ret = 2;
pub const LZMA_STREAM_END: lzma_ret = 1;
pub const LZMA_OK: lzma_ret = 0;
pub type lzma_action = std::os::raw::c_uint;
pub const LZMA_FINISH: lzma_action = 3;
pub const LZMA_FULL_BARRIER: lzma_action = 4;
pub const LZMA_FULL_FLUSH: lzma_action = 2;
pub const LZMA_SYNC_FLUSH: lzma_action = 1;
pub const LZMA_RUN: lzma_action = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lzma_allocator {
    pub alloc: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: size_t,
                                           _: size_t) -> *mut std::os::raw::c_void>,
    pub free: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *mut std::os::raw::c_void) -> ()>,
    pub opaque: *mut std::os::raw::c_void,
}
pub type lzma_internal = lzma_internal_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lzma_stream {
    pub next_in: *const uint8_t,
    pub avail_in: size_t,
    pub total_in: uint64_t,
    pub next_out: *mut uint8_t,
    pub avail_out: size_t,
    pub total_out: uint64_t,
    pub allocator: *const lzma_allocator,
    pub internal: *mut lzma_internal,
    pub reserved_ptr1: *mut std::os::raw::c_void,
    pub reserved_ptr2: *mut std::os::raw::c_void,
    pub reserved_ptr3: *mut std::os::raw::c_void,
    pub reserved_ptr4: *mut std::os::raw::c_void,
    pub reserved_int1: uint64_t,
    pub reserved_int2: uint64_t,
    pub reserved_int3: size_t,
    pub reserved_int4: size_t,
    pub reserved_enum1: lzma_reserved_enum,
    pub reserved_enum2: lzma_reserved_enum,
}
pub type lzma_vli = uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lzma_filter {
    pub id: lzma_vli,
    pub options: *mut std::os::raw::c_void,
}
pub type lzma_match_finder = std::os::raw::c_uint;
pub const LZMA_MF_BT4: lzma_match_finder = 20;
pub const LZMA_MF_BT3: lzma_match_finder = 19;
pub const LZMA_MF_BT2: lzma_match_finder = 18;
pub const LZMA_MF_HC4: lzma_match_finder = 4;
pub const LZMA_MF_HC3: lzma_match_finder = 3;
pub type lzma_mode = std::os::raw::c_uint;
pub const LZMA_MODE_NORMAL: lzma_mode = 2;
pub const LZMA_MODE_FAST: lzma_mode = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lzma_options_lzma {
    pub dict_size: uint32_t,
    pub preset_dict: *const uint8_t,
    pub preset_dict_size: uint32_t,
    pub lc: uint32_t,
    pub lp: uint32_t,
    pub pb: uint32_t,
    pub mode: lzma_mode,
    pub nice_len: uint32_t,
    pub mf: lzma_match_finder,
    pub depth: uint32_t,
    pub reserved_int1: uint32_t,
    pub reserved_int2: uint32_t,
    pub reserved_int3: uint32_t,
    pub reserved_int4: uint32_t,
    pub reserved_int5: uint32_t,
    pub reserved_int6: uint32_t,
    pub reserved_int7: uint32_t,
    pub reserved_int8: uint32_t,
    pub reserved_enum1: lzma_reserved_enum,
    pub reserved_enum2: lzma_reserved_enum,
    pub reserved_enum3: lzma_reserved_enum,
    pub reserved_enum4: lzma_reserved_enum,
    pub reserved_ptr1: *mut std::os::raw::c_void,
    pub reserved_ptr2: *mut std::os::raw::c_void,
}
/* *
 * xzlib.h: header for the front end for the transparent suport of lzma
 *          compression at the I/O layer
 *
 * See Copyright for the status of this software.
 *
 * Anders F Bjorklund <afb@users.sourceforge.net>
 */
pub type xzFile = *mut std::os::raw::c_void;
pub type xz_statep = *mut xz_state;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct xz_state {
    pub mode: std::os::raw::c_int,
    pub fd: std::os::raw::c_int,
    pub path: *mut std::os::raw::c_char,
    pub pos: uint64_t,
    pub size: std::os::raw::c_uint,
    pub want: std::os::raw::c_uint,
    pub in_0: *mut std::os::raw::c_uchar,
    pub out: *mut std::os::raw::c_uchar,
    pub next: *mut std::os::raw::c_uchar,
    pub have: std::os::raw::c_uint,
    pub eof: std::os::raw::c_int,
    pub start: uint64_t,
    pub raw: uint64_t,
    pub how: std::os::raw::c_int,
    pub direct: std::os::raw::c_int,
    pub skip: uint64_t,
    pub seek: std::os::raw::c_int,
    pub err: std::os::raw::c_int,
    pub msg: *mut std::os::raw::c_char,
    pub init: std::os::raw::c_int,
    pub strm: lzma_stream,
    pub padding1: [std::os::raw::c_char; 32],
    pub zstrm: z_stream,
    pub padding2: [std::os::raw::c_char; 32],
}
/* *
 * xmlMallocFunc:
 * @size:  the size requested in bytes
 *
 * Signature for a malloc() implementation.
 *
 * Returns a pointer to the newly allocated block or NULL in case of error.
 */
pub type xmlMallocFunc
    =
    Option<unsafe extern "C" fn(_: size_t) -> *mut std::os::raw::c_void>;
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */
/* *
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/* *
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
unsafe extern "C" fn xz_error(mut state: xz_statep, mut err: std::os::raw::c_int,
                              mut msg: *const std::os::raw::c_char) {
    /* free previously allocated message and clear */
    if !(*state).msg.is_null() {
        if (*state).err != LZMA_MEM_ERROR as std::os::raw::c_int {
            xmlFree.expect("non-null function pointer")((*state).msg as
                                                            *mut std::os::raw::c_void);
        }
        (*state).msg = 0 as *mut std::os::raw::c_char
    }
    /* set error code, and if no message, then done */
    (*state).err = err;
    if msg.is_null() { return }
    /* for an out of memory error, save as static string */
    if err == LZMA_MEM_ERROR as std::os::raw::c_int {
        (*state).msg = msg as *mut std::os::raw::c_char;
        return
    }
    /* construct error message with path */
    (*state).msg =
        xmlMalloc.expect("non-null function pointer")(strlen((*state).path).wrapping_add(strlen(msg)).wrapping_add(3
                                                                                                                       as
                                                                                                                       std::os::raw::c_int
                                                                                                                       as
                                                                                                                       std::os::raw::c_ulong))
            as *mut std::os::raw::c_char; /* no output data available */
    if (*state).msg.is_null() {
        (*state).err = LZMA_MEM_ERROR as std::os::raw::c_int; /* not at end of file */
        (*state).msg =
            b"out of memory\x00" as *const u8 as *const std::os::raw::c_char as
                *mut std::os::raw::c_char; /* look for gzip header */
        return
    } /* default for empty file */
    strcpy((*state).msg, (*state).path); /* no seek request pending */
    strcat((*state).msg,
           b": \x00" as *const u8 as *const std::os::raw::c_char); /* clear error */
    strcat((*state).msg, msg); /* no uncompressed data yet */
}
unsafe extern "C" fn xz_reset(mut state: xz_statep) {
    (*state).have = 0 as std::os::raw::c_int as std::os::raw::c_uint; /* no input data yet */
    (*state).eof = 0 as std::os::raw::c_int;
    (*state).how = 0 as std::os::raw::c_int;
    (*state).direct = 1 as std::os::raw::c_int;
    (*state).seek = 0 as std::os::raw::c_int;
    xz_error(state, LZMA_OK as std::os::raw::c_int, 0 as *const std::os::raw::c_char);
    (*state).pos = 0 as std::os::raw::c_int as uint64_t;
    (*state).strm.avail_in = 0 as std::os::raw::c_int as size_t;
    (*state).zstrm.avail_in = 0 as std::os::raw::c_int as uInt;
    /* no input data yet */
}
unsafe extern "C" fn xz_open(mut path: *const std::os::raw::c_char,
                             mut fd: std::os::raw::c_int,
                             mut mode: *const std::os::raw::c_char) -> xzFile {
    let mut state: xz_statep = 0 as *mut xz_state;
    /* allocate xzFile structure to return */
    state =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xz_state>()
                                                          as std::os::raw::c_ulong) as
            xz_statep; /* no buffers allocated yet */
    if state.is_null() {
        return 0 as *mut std::os::raw::c_void
    } /* requested buffer size */
    (*state).size =
        0 as std::os::raw::c_int as std::os::raw::c_uint; /* no error message yet */
    (*state).want =
        8192 as std::os::raw::c_int as std::os::raw::c_uint; /* initialization of zlib data */
    (*state).msg = 0 as *mut std::os::raw::c_char;
    (*state).init = 0 as std::os::raw::c_int;
    /* save the path name for error messages */
    (*state).path =
        xmlMalloc.expect("non-null function pointer")(strlen(path).wrapping_add(1
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    std::os::raw::c_ulong))
            as *mut std::os::raw::c_char;
    if (*state).path.is_null() {
        xmlFree.expect("non-null function pointer")(state as
                                                        *mut std::os::raw::c_void);
        return 0 as *mut std::os::raw::c_void
    }
    strcpy((*state).path, path);
    /* open the file with the appropriate mode (or just use fd) */
    (*state).fd =
        if fd != -(1 as std::os::raw::c_int) {
            fd
        } else { open(path, 0 as std::os::raw::c_int, 0o666 as std::os::raw::c_int) };
    if (*state).fd == -(1 as std::os::raw::c_int) {
        xmlFree.expect("non-null function pointer")((*state).path as
                                                        *mut std::os::raw::c_void);
        xmlFree.expect("non-null function pointer")(state as
                                                        *mut std::os::raw::c_void);
        return 0 as *mut std::os::raw::c_void
    }
    /* save the current position for rewinding (only if reading) */
    (*state).start =
        lseek((*state).fd, 0 as std::os::raw::c_int as __off64_t, 1 as std::os::raw::c_int) as
            uint64_t;
    if (*state).start == -(1 as std::os::raw::c_int) as uint64_t {
        (*state).start = 0 as std::os::raw::c_int as uint64_t
    }
    /* initialize stream */
    xz_reset(state);
    /* return stream */
    return state as xzFile;
}
unsafe extern "C" fn xz_compressed(mut f: xzFile) -> std::os::raw::c_int {
    let mut state: xz_statep = 0 as *mut xz_state;
    if f.is_null() { return -(1 as std::os::raw::c_int) }
    state = f as xz_statep;
    if (*state).init <= 0 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
    match (*state).how {
        1 => { return 0 as std::os::raw::c_int }
        2 | 3 => { return 1 as std::os::raw::c_int }
        _ => { }
    }
    return -(1 as std::os::raw::c_int);
}
/* opaque lzma file descriptor */
#[no_mangle]
pub unsafe extern "C" fn __libxml2_xzopen(mut path: *const std::os::raw::c_char,
                                          mut mode: *const std::os::raw::c_char)
 -> xzFile {
    return xz_open(path, -(1 as std::os::raw::c_int),
                   mode); /* identifier for error messages */
}
#[no_mangle]
pub unsafe extern "C" fn __libxml2_xzcompressed(mut f: xzFile)
 -> std::os::raw::c_int {
    return xz_compressed(f); /* for debugging */
}
#[no_mangle]
pub unsafe extern "C" fn __libxml2_xzdopen(mut fd: std::os::raw::c_int,
                                           mut mode: *const std::os::raw::c_char)
 -> xzFile {
    let mut path: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut xz: xzFile = 0 as *mut std::os::raw::c_void;
    if fd == -(1 as std::os::raw::c_int) ||
           {
               path =
                   xmlMalloc.expect("non-null function pointer")((7 as
                                                                      std::os::raw::c_int
                                                                      as
                                                                      std::os::raw::c_ulong).wrapping_add((3
                                                                                                       as
                                                                                                       std::os::raw::c_int
                                                                                                       as
                                                                                                       std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<std::os::raw::c_int>()
                                                                                                                                       as
                                                                                                                                       std::os::raw::c_ulong)))
                       as *mut std::os::raw::c_char;
               path.is_null()
           } {
        return 0 as *mut std::os::raw::c_void
    }
    sprintf(path, b"<fd:%d>\x00" as *const u8 as *const std::os::raw::c_char, fd);
    xz = xz_open(path, fd, mode);
    xmlFree.expect("non-null function pointer")(path as *mut std::os::raw::c_void);
    return xz;
}
unsafe extern "C" fn xz_load(mut state: xz_statep,
                             mut buf: *mut std::os::raw::c_uchar,
                             mut len: std::os::raw::c_uint,
                             mut have: *mut std::os::raw::c_uint) -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    *have = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    loop  {
        ret =
            read((*state).fd, buf.offset(*have as isize) as *mut std::os::raw::c_void,
                 len.wrapping_sub(*have) as size_t) as std::os::raw::c_int;
        if ret <= 0 as std::os::raw::c_int { break ; }
        *have = (*have).wrapping_add(ret as std::os::raw::c_uint);
        if !(*have < len) { break ; }
    }
    if ret < 0 as std::os::raw::c_int {
        xz_error(state, -(1 as std::os::raw::c_int), strerror(*__errno_location()));
        return -(1 as std::os::raw::c_int)
    }
    if ret == 0 as std::os::raw::c_int { (*state).eof = 1 as std::os::raw::c_int }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xz_avail(mut state: xz_statep) -> std::os::raw::c_int {
    let mut strm: *mut lzma_stream = &mut (*state).strm;
    if (*state).err != LZMA_OK as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
    if (*state).eof == 0 as std::os::raw::c_int {
        /* avail_in is size_t, which is not necessary sizeof(unsigned) */
        let mut tmp: std::os::raw::c_uint =
            (*strm).avail_in as
                std::os::raw::c_uint; /* we can't use xmlFree on a string returned by zlib */
        if xz_load(state, (*state).in_0, (*state).size, &mut tmp) ==
               -(1 as std::os::raw::c_int) {
            (*strm).avail_in = tmp as size_t;
            return -(1 as std::os::raw::c_int)
        }
        (*strm).avail_in = tmp as size_t;
        (*strm).next_in = (*state).in_0
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xz_avail_zstrm(mut state: xz_statep) -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    (*state).strm.avail_in = (*state).zstrm.avail_in as size_t;
    (*state).strm.next_in = (*state).zstrm.next_in;
    ret = xz_avail(state);
    (*state).zstrm.avail_in = (*state).strm.avail_in as uInt;
    (*state).zstrm.next_in = (*state).strm.next_in as *mut Bytef;
    return ret;
}
unsafe extern "C" fn is_format_xz(mut state: xz_statep) -> std::os::raw::c_int {
    let mut strm: *mut lzma_stream = &mut (*state).strm;
    return ((*strm).avail_in >= 6 as std::os::raw::c_int as std::os::raw::c_ulong &&
                memcmp((*state).in_0 as *const std::os::raw::c_void,
                       b"\xfd7zXZ\x00" as *const u8 as *const std::os::raw::c_char as
                           *const std::os::raw::c_void,
                       6 as std::os::raw::c_int as std::os::raw::c_ulong) == 0 as std::os::raw::c_int)
               as std::os::raw::c_int;
}
unsafe extern "C" fn is_format_lzma(mut state: xz_statep) -> std::os::raw::c_int {
    let mut strm: *mut lzma_stream = &mut (*state).strm;
    let mut filter: lzma_filter =
        lzma_filter{id: 0, options: 0 as *mut std::os::raw::c_void,};
    let mut opt: *mut lzma_options_lzma = 0 as *mut lzma_options_lzma;
    let mut dict_size: uint32_t = 0;
    let mut uncompressed_size: uint64_t = 0;
    let mut i: size_t = 0;
    if (*strm).avail_in < 13 as std::os::raw::c_int as std::os::raw::c_ulong {
        return 0 as std::os::raw::c_int
    }
    filter.id = 0x4000000000000001 as std::os::raw::c_ulong;
    if lzma_properties_decode(&mut filter, 0 as *const lzma_allocator,
                              (*state).in_0, 5 as std::os::raw::c_int as size_t) as
           std::os::raw::c_uint != LZMA_OK as std::os::raw::c_int as std::os::raw::c_uint {
        return 0 as std::os::raw::c_int
    }
    opt = filter.options as *mut lzma_options_lzma;
    dict_size = (*opt).dict_size;
    free(opt as *mut std::os::raw::c_void);
    /* A hack to ditch tons of false positives: We allow only dictionary
     * sizes that are 2^n or 2^n + 2^(n-1) or UINT32_MAX. LZMA_Alone
     * created only files with 2^n, but accepts any dictionary size.
     * If someone complains, this will be reconsidered.
     */
    if dict_size != 4294967295 as std::os::raw::c_uint {
        let mut d: uint32_t =
            dict_size.wrapping_sub(1 as std::os::raw::c_int as std::os::raw::c_uint);
        d |= d >> 2 as std::os::raw::c_int;
        d |= d >> 3 as std::os::raw::c_int;
        d |= d >> 4 as std::os::raw::c_int;
        d |= d >> 8 as std::os::raw::c_int;
        d |= d >> 16 as std::os::raw::c_int;
        d = d.wrapping_add(1);
        if d != dict_size || dict_size == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            return 0 as std::os::raw::c_int
        }
    }
    /* Another hack to ditch false positives: Assume that if the
     * uncompressed size is known, it must be less than 256 GiB.
     * Again, if someone complains, this will be reconsidered.
     */
    uncompressed_size = 0 as std::os::raw::c_int as uint64_t;
    i = 0 as std::os::raw::c_int as size_t;
    while i < 8 as std::os::raw::c_int as std::os::raw::c_ulong {
        uncompressed_size |=
            (*(*state).in_0.offset((5 as std::os::raw::c_int as
                                        std::os::raw::c_ulong).wrapping_add(i) as
                                       isize) as uint64_t) <<
                i.wrapping_mul(8 as std::os::raw::c_int as std::os::raw::c_ulong);
        i = i.wrapping_add(1)
    }
    if uncompressed_size != 18446744073709551615 as std::os::raw::c_ulong &&
           uncompressed_size > (1 as std::os::raw::c_ulong) << 38 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    return 1 as std::os::raw::c_int;
}
/* Get a four-byte little-endian integer and return 0 on success and the value
   in *ret.  Otherwise -1 is returned and *ret is not modified. */
unsafe extern "C" fn gz_next4(mut state: xz_statep,
                              mut ret: *mut std::os::raw::c_ulong) -> std::os::raw::c_int {
    let mut ch: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_ulong = 0;
    let mut strm: z_streamp = &mut (*state).zstrm;
    val =
        if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint &&
               xz_avail_zstrm(state) == -(1 as std::os::raw::c_int) {
            -(1 as std::os::raw::c_int)
        } else if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            -(1 as std::os::raw::c_int)
        } else {
            (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
            let fresh0 = (*strm).next_in;
            (*strm).next_in = (*strm).next_in.offset(1);
            *fresh0 as std::os::raw::c_int
        } as std::os::raw::c_ulong;
    val =
        val.wrapping_add((((if (*strm).avail_in ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint &&
                                   xz_avail_zstrm(state) ==
                                       -(1 as std::os::raw::c_int) {
                                -(1 as std::os::raw::c_int)
                            } else {
                                (if (*strm).avail_in ==
                                        0 as std::os::raw::c_int as std::os::raw::c_uint {
                                     -(1 as std::os::raw::c_int)
                                 } else {
                                     (*strm).avail_in =
                                         (*strm).avail_in.wrapping_sub(1);
                                     let fresh1 = (*strm).next_in;
                                     (*strm).next_in =
                                         (*strm).next_in.offset(1);
                                     *fresh1 as std::os::raw::c_int
                                 })
                            }) as std::os::raw::c_uint) << 8 as std::os::raw::c_int) as
                             std::os::raw::c_ulong);
    val =
        val.wrapping_add(((if (*strm).avail_in ==
                                  0 as std::os::raw::c_int as std::os::raw::c_uint &&
                                  xz_avail_zstrm(state) == -(1 as std::os::raw::c_int)
                              {
                               -(1 as std::os::raw::c_int)
                           } else {
                               (if (*strm).avail_in ==
                                       0 as std::os::raw::c_int as std::os::raw::c_uint {
                                    -(1 as std::os::raw::c_int)
                                } else {
                                    (*strm).avail_in =
                                        (*strm).avail_in.wrapping_sub(1);
                                    let fresh2 = (*strm).next_in;
                                    (*strm).next_in =
                                        (*strm).next_in.offset(1);
                                    *fresh2 as std::os::raw::c_int
                                })
                           }) as std::os::raw::c_ulong) << 16 as std::os::raw::c_int);
    ch =
        if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint &&
               xz_avail_zstrm(state) == -(1 as std::os::raw::c_int) {
            -(1 as std::os::raw::c_int)
        } else if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            -(1 as std::os::raw::c_int)
        } else {
            (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
            let fresh3 = (*strm).next_in;
            (*strm).next_in = (*strm).next_in.offset(1);
            *fresh3 as std::os::raw::c_int
        };
    if ch == -(1 as std::os::raw::c_int) { return -(1 as std::os::raw::c_int) }
    val = val.wrapping_add((ch as std::os::raw::c_ulong) << 24 as std::os::raw::c_int);
    *ret = val;
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xz_head(mut state: xz_statep) -> std::os::raw::c_int {
    let mut strm: *mut lzma_stream = &mut (*state).strm;
    let mut init: lzma_stream =
        {
            let mut init =
                lzma_stream{next_in: 0 as *const uint8_t,
                            avail_in: 0 as std::os::raw::c_int as size_t,
                            total_in: 0 as std::os::raw::c_int as uint64_t,
                            next_out: 0 as *mut uint8_t,
                            avail_out: 0 as std::os::raw::c_int as size_t,
                            total_out: 0 as std::os::raw::c_int as uint64_t,
                            allocator: 0 as *const lzma_allocator,
                            internal: 0 as *mut lzma_internal,
                            reserved_ptr1: 0 as *mut std::os::raw::c_void,
                            reserved_ptr2: 0 as *mut std::os::raw::c_void,
                            reserved_ptr3: 0 as *mut std::os::raw::c_void,
                            reserved_ptr4: 0 as *mut std::os::raw::c_void,
                            reserved_int1: 0 as std::os::raw::c_int as uint64_t,
                            reserved_int2: 0 as std::os::raw::c_int as uint64_t,
                            reserved_int3: 0 as std::os::raw::c_int as size_t,
                            reserved_int4: 0 as std::os::raw::c_int as size_t,
                            reserved_enum1: LZMA_RESERVED_ENUM,
                            reserved_enum2: LZMA_RESERVED_ENUM,};
            init
        };
    let mut flags: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_uint = 0;
    /* allocate read buffers and inflate memory */
    if (*state).size == 0 as std::os::raw::c_int as std::os::raw::c_uint {
        /* allocate buffers */
        (*state).in_0 =
            xmlMalloc.expect("non-null function pointer")((*state).want as
                                                              size_t) as
                *mut std::os::raw::c_uchar;
        (*state).out =
            xmlMalloc.expect("non-null function pointer")(((*state).want <<
                                                               1 as
                                                                   std::os::raw::c_int)
                                                              as size_t) as
                *mut std::os::raw::c_uchar;
        if (*state).in_0.is_null() || (*state).out.is_null() {
            if !(*state).out.is_null() {
                xmlFree.expect("non-null function pointer")((*state).out as
                                                                *mut std::os::raw::c_void);
            }
            if !(*state).in_0.is_null() {
                xmlFree.expect("non-null function pointer")((*state).in_0 as
                                                                *mut std::os::raw::c_void);
            }
            xz_error(state, LZMA_MEM_ERROR as std::os::raw::c_int,
                     b"out of memory\x00" as *const u8 as
                         *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        (*state).size = (*state).want;
        /* allocate decoder memory */
        (*state).strm = init;
        (*state).strm.avail_in = 0 as std::os::raw::c_int as size_t;
        (*state).strm.next_in = 0 as *const uint8_t;
        if lzma_auto_decoder(&mut (*state).strm,
                             100000000 as std::os::raw::c_int as uint64_t,
                             0 as std::os::raw::c_int as uint32_t) as std::os::raw::c_uint !=
               LZMA_OK as std::os::raw::c_int as std::os::raw::c_uint {
            xmlFree.expect("non-null function pointer")((*state).out as
                                                            *mut std::os::raw::c_void);
            xmlFree.expect("non-null function pointer")((*state).in_0 as
                                                            *mut std::os::raw::c_void);
            (*state).size = 0 as std::os::raw::c_int as std::os::raw::c_uint;
            xz_error(state, LZMA_MEM_ERROR as std::os::raw::c_int,
                     b"out of memory\x00" as *const u8 as
                         *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        /* allocate inflate memory */
        (*state).zstrm.zalloc = None;
        (*state).zstrm.zfree = None;
        (*state).zstrm.opaque = 0 as voidpf;
        (*state).zstrm.avail_in = 0 as std::os::raw::c_int as uInt;
        (*state).zstrm.next_in = 0 as *mut Bytef;
        if (*state).init == 0 as std::os::raw::c_int {
            if inflateInit2_(&mut (*state).zstrm, -(15 as std::os::raw::c_int),
                             b"1.2.11\x00" as *const u8 as
                                 *const std::os::raw::c_char,
                             ::std::mem::size_of::<z_stream>() as
                                 std::os::raw::c_ulong as std::os::raw::c_int) !=
                   0 as std::os::raw::c_int {
                /* raw inflate */
                xmlFree.expect("non-null function pointer")((*state).out as
                                                                *mut std::os::raw::c_void);
                xmlFree.expect("non-null function pointer")((*state).in_0 as
                                                                *mut std::os::raw::c_void);
                (*state).size = 0 as std::os::raw::c_int as std::os::raw::c_uint;
                xz_error(state, LZMA_MEM_ERROR as std::os::raw::c_int,
                         b"out of memory\x00" as *const u8 as
                             *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            (*state).init = 1 as std::os::raw::c_int
        }
    }
    /* get some data in the input buffer */
    if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
        if xz_avail(state) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
        if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
            return 0 as std::os::raw::c_int
        }
    }
    /* look for the xz magic header bytes */
    if is_format_xz(state) != 0 || is_format_lzma(state) != 0 {
        (*state).how = 3 as std::os::raw::c_int;
        (*state).direct = 0 as std::os::raw::c_int;
        return 0 as std::os::raw::c_int
    }
    /* look for the gzip magic header bytes 31 and 139 */
    if *(*strm).next_in.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
           31 as std::os::raw::c_int {
        (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
        (*strm).next_in = (*strm).next_in.offset(1);
        if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
               xz_avail(state) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
        if (*strm).avail_in != 0 &&
               *(*strm).next_in.offset(0 as std::os::raw::c_int as isize) as
                   std::os::raw::c_int == 139 as std::os::raw::c_int {
            /* we have a gzip header, woo hoo! */
            (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
            (*strm).next_in = (*strm).next_in.offset(1);
            /* skip rest of header */
            if (if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                       xz_avail(state) == -(1 as std::os::raw::c_int) {
                    -(1 as std::os::raw::c_int)
                } else {
                    (if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong
                        {
                         -(1 as std::os::raw::c_int)
                     } else {
                         (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                         let fresh4 = (*strm).next_in;
                         (*strm).next_in = (*strm).next_in.offset(1);
                         *fresh4 as std::os::raw::c_int
                     })
                }) != 8 as std::os::raw::c_int {
                /* compression method */
                xz_error(state, LZMA_DATA_ERROR as std::os::raw::c_int,
                         b"unknown compression method\x00" as *const u8 as
                             *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            flags =
                if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                       xz_avail(state) == -(1 as std::os::raw::c_int) {
                    -(1 as std::os::raw::c_int)
                } else if (*strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_ulong {
                    -(1 as std::os::raw::c_int)
                } else {
                    (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                    let fresh5 = (*strm).next_in;
                    (*strm).next_in = (*strm).next_in.offset(1);
                    *fresh5 as std::os::raw::c_int
                };
            if flags & 0xe0 as std::os::raw::c_int != 0 {
                /* reserved flag bits */
                xz_error(state, LZMA_DATA_ERROR as std::os::raw::c_int,
                         b"unknown header flags set\x00" as *const u8 as
                             *const std::os::raw::c_char); /* modification time */
                return -(1 as std::os::raw::c_int)
            } /* extra flags */
            if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   xz_avail(state) == -(1 as std::os::raw::c_int) {
            } else {
                if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                } else {
                    (*strm).avail_in =
                        (*strm).avail_in.wrapping_sub(1); /* operating system */
                    let fresh6 = (*strm).next_in;
                    (*strm).next_in = (*strm).next_in.offset(1)
                };
            };
            if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   xz_avail(state) == -(1 as std::os::raw::c_int) {
            } else {
                if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                } else {
                    (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                    let fresh7 = (*strm).next_in;
                    (*strm).next_in = (*strm).next_in.offset(1)
                };
            };
            if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   xz_avail(state) == -(1 as std::os::raw::c_int) {
            } else {
                if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                } else {
                    (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                    let fresh8 = (*strm).next_in;
                    (*strm).next_in = (*strm).next_in.offset(1)
                };
            };
            if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   xz_avail(state) == -(1 as std::os::raw::c_int) {
            } else {
                if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                } else {
                    (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                    let fresh9 = (*strm).next_in;
                    (*strm).next_in = (*strm).next_in.offset(1)
                };
            };
            if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   xz_avail(state) == -(1 as std::os::raw::c_int) {
            } else {
                if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                } else {
                    (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                    let fresh10 = (*strm).next_in;
                    (*strm).next_in = (*strm).next_in.offset(1)
                };
            };
            if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   xz_avail(state) == -(1 as std::os::raw::c_int) {
            } else {
                if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                } else {
                    (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                    let fresh11 = (*strm).next_in;
                    (*strm).next_in = (*strm).next_in.offset(1)
                };
            };
            if flags & 4 as std::os::raw::c_int != 0 {
                /* extra field */
                len =
                    if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong
                           && xz_avail(state) == -(1 as std::os::raw::c_int) {
                        -(1 as std::os::raw::c_int)
                    } else if (*strm).avail_in ==
                                  0 as std::os::raw::c_int as std::os::raw::c_ulong {
                        -(1 as std::os::raw::c_int)
                    } else {
                        (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                        let fresh12 = (*strm).next_in;
                        (*strm).next_in = (*strm).next_in.offset(1);
                        *fresh12 as std::os::raw::c_int
                    } as std::os::raw::c_uint;
                len =
                    len.wrapping_add(((if (*strm).avail_in ==
                                              0 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong &&
                                              xz_avail(state) ==
                                                  -(1 as std::os::raw::c_int) {
                                           -(1 as std::os::raw::c_int)
                                       } else {
                                           (if (*strm).avail_in ==
                                                   0 as std::os::raw::c_int as
                                                       std::os::raw::c_ulong {
                                                -(1 as std::os::raw::c_int)
                                            } else {
                                                (*strm).avail_in =
                                                    (*strm).avail_in.wrapping_sub(1);
                                                let fresh13 = (*strm).next_in;
                                                (*strm).next_in =
                                                    (*strm).next_in.offset(1);
                                                *fresh13 as std::os::raw::c_int
                                            })
                                       }) as std::os::raw::c_uint) <<
                                         8 as std::os::raw::c_int);
                loop  {
                    let fresh14 = len;
                    len = len.wrapping_sub(1);
                    if !(fresh14 != 0) { break ; }
                    if (if (*strm).avail_in ==
                               0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                               xz_avail(state) == -(1 as std::os::raw::c_int) {
                            -(1 as std::os::raw::c_int)
                        } else {
                            (if (*strm).avail_in ==
                                    0 as std::os::raw::c_int as std::os::raw::c_ulong {
                                 -(1 as std::os::raw::c_int)
                             } else {
                                 (*strm).avail_in =
                                     (*strm).avail_in.wrapping_sub(1);
                                 let fresh15 = (*strm).next_in;
                                 (*strm).next_in = (*strm).next_in.offset(1);
                                 *fresh15 as std::os::raw::c_int
                             })
                        }) < 0 as std::os::raw::c_int {
                        break ;
                    }
                }
            }
            if flags & 8 as std::os::raw::c_int != 0 {
                /* file name */
                while (if (*strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                              xz_avail(state) == -(1 as std::os::raw::c_int) {
                           -(1 as std::os::raw::c_int)
                       } else {
                           (if (*strm).avail_in ==
                                   0 as std::os::raw::c_int as std::os::raw::c_ulong {
                                -(1 as std::os::raw::c_int)
                            } else {
                                (*strm).avail_in =
                                    (*strm).avail_in.wrapping_sub(1);
                                let fresh16 = (*strm).next_in;
                                (*strm).next_in = (*strm).next_in.offset(1);
                                *fresh16 as std::os::raw::c_int
                            })
                       }) > 0 as std::os::raw::c_int {
                }
            }
            if flags & 16 as std::os::raw::c_int != 0 {
                /* comment */
                while (if (*strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                              xz_avail(state) == -(1 as std::os::raw::c_int) {
                           -(1 as std::os::raw::c_int)
                       } else {
                           (if (*strm).avail_in ==
                                   0 as std::os::raw::c_int as std::os::raw::c_ulong {
                                -(1 as std::os::raw::c_int)
                            } else {
                                (*strm).avail_in =
                                    (*strm).avail_in.wrapping_sub(1);
                                let fresh17 = (*strm).next_in;
                                (*strm).next_in = (*strm).next_in.offset(1);
                                *fresh17 as std::os::raw::c_int
                            })
                       }) > 0 as std::os::raw::c_int {
                }
            }
            if flags & 2 as std::os::raw::c_int != 0 {
                /* header crc */
                if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                       xz_avail(state) == -(1 as std::os::raw::c_int) {
                } else {
                    if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                    } else {
                        (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                        let fresh18 = (*strm).next_in;
                        (*strm).next_in = (*strm).next_in.offset(1)
                    };
                };
                if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                       xz_avail(state) == -(1 as std::os::raw::c_int) {
                } else {
                    if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                    } else {
                        (*strm).avail_in = (*strm).avail_in.wrapping_sub(1);
                        let fresh19 = (*strm).next_in;
                        (*strm).next_in = (*strm).next_in.offset(1)
                    };
                };
            }
            /* an unexpected end of file is not checked for here -- it will be
             * noticed on the first request for uncompressed data */
            /* set up for decompression */
            inflateReset(&mut (*state).zstrm);
            (*state).zstrm.adler =
                crc32(0 as std::os::raw::c_long as uLong, 0 as *const Bytef,
                      0 as std::os::raw::c_int as uInt);
            (*state).how = 2 as std::os::raw::c_int;
            (*state).direct = 0 as std::os::raw::c_int;
            return 0 as std::os::raw::c_int
        } else {
            /* not a gzip file -- save first byte (31) and fall to raw i/o */
            *(*state).out.offset(0 as std::os::raw::c_int as isize) =
                31 as std::os::raw::c_int as std::os::raw::c_uchar;
            (*state).have = 1 as std::os::raw::c_int as std::os::raw::c_uint
        }
    }
    /* doing raw i/o, save start of raw data for seeking, copy any leftover
     * input to output -- this assumes that the output buffer is larger than
     * the input buffer, which also assures space for gzungetc() */
    (*state).raw = (*state).pos;
    (*state).next = (*state).out;
    if (*strm).avail_in != 0 {
        memcpy((*state).next.offset((*state).have as isize) as
                   *mut std::os::raw::c_void, (*strm).next_in as *const std::os::raw::c_void,
               (*strm).avail_in);
        (*state).have =
            ((*state).have as std::os::raw::c_ulong).wrapping_add((*strm).avail_in) as
                std::os::raw::c_uint as std::os::raw::c_uint;
        (*strm).avail_in = 0 as std::os::raw::c_int as size_t
    }
    (*state).how = 1 as std::os::raw::c_int;
    (*state).direct = 1 as std::os::raw::c_int;
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xz_decomp(mut state: xz_statep) -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    let mut had: std::os::raw::c_uint = 0;
    let mut crc: std::os::raw::c_ulong = 0;
    let mut len: std::os::raw::c_ulong = 0;
    let mut strm: *mut lzma_stream = &mut (*state).strm;
    let mut action: lzma_action = LZMA_RUN;
    /* fill output buffer up to end of deflate stream */
    had = (*strm).avail_out as std::os::raw::c_uint;
    loop  {
        /* get more input for inflate() */
        if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
               xz_avail(state) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
        if (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
            xz_error(state, LZMA_DATA_ERROR as std::os::raw::c_int,
                     b"unexpected end of file\x00" as *const u8 as
                         *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        if (*state).eof != 0 { action = LZMA_FINISH }
        /* decompress and handle errors */
        if (*state).how == 2 as std::os::raw::c_int {
            (*state).zstrm.avail_in =
                (*state).strm.avail_in as uInt; /* state->how == LZMA */
            (*state).zstrm.next_in = (*state).strm.next_in as *mut Bytef;
            (*state).zstrm.avail_out = (*state).strm.avail_out as uInt;
            (*state).zstrm.next_out = (*state).strm.next_out as *mut Bytef;
            ret = inflate(&mut (*state).zstrm, 0 as std::os::raw::c_int);
            if ret == -(2 as std::os::raw::c_int) || ret == 2 as std::os::raw::c_int {
                xz_error(state, -(2 as std::os::raw::c_int),
                         b"internal error: inflate stream corrupt\x00" as
                             *const u8 as *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            if ret == -(4 as std::os::raw::c_int) {
                ret = LZMA_MEM_ERROR as std::os::raw::c_int
            }
            if ret == -(3 as std::os::raw::c_int) {
                ret = LZMA_DATA_ERROR as std::os::raw::c_int
            }
            if ret == 1 as std::os::raw::c_int {
                ret = LZMA_STREAM_END as std::os::raw::c_int
            }
            (*state).strm.avail_in = (*state).zstrm.avail_in as size_t;
            (*state).strm.next_in = (*state).zstrm.next_in;
            (*state).strm.avail_out = (*state).zstrm.avail_out as size_t;
            (*state).strm.next_out = (*state).zstrm.next_out
        } else { ret = lzma_code(strm, action) as std::os::raw::c_int }
        if ret == LZMA_MEM_ERROR as std::os::raw::c_int {
            xz_error(state, LZMA_MEM_ERROR as std::os::raw::c_int,
                     b"out of memory\x00" as *const u8 as
                         *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        if ret == LZMA_DATA_ERROR as std::os::raw::c_int {
            xz_error(state, LZMA_DATA_ERROR as std::os::raw::c_int,
                     b"compressed data error\x00" as *const u8 as
                         *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        if ret == LZMA_PROG_ERROR as std::os::raw::c_int {
            xz_error(state, LZMA_PROG_ERROR as std::os::raw::c_int,
                     b"compression error\x00" as *const u8 as
                         *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        if !((*strm).avail_out != 0 && ret != LZMA_STREAM_END as std::os::raw::c_int)
           {
            break ;
        }
    }
    /* update available output and crc check value */
    (*state).have =
        (had as std::os::raw::c_ulong).wrapping_sub((*strm).avail_out) as
            std::os::raw::c_uint;
    (*state).next = (*strm).next_out.offset(-((*state).have as isize));
    (*state).zstrm.adler =
        crc32((*state).zstrm.adler, (*state).next, (*state).have);
    if ret == LZMA_STREAM_END as std::os::raw::c_int {
        if (*state).how == 2 as std::os::raw::c_int {
            if gz_next4(state, &mut crc) == -(1 as std::os::raw::c_int) ||
                   gz_next4(state, &mut len) == -(1 as std::os::raw::c_int) {
                xz_error(state, LZMA_DATA_ERROR as std::os::raw::c_int,
                         b"unexpected end of file\x00" as *const u8 as
                             *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            if crc != (*state).zstrm.adler {
                xz_error(state, LZMA_DATA_ERROR as std::os::raw::c_int,
                         b"incorrect data check\x00" as *const u8 as
                             *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            if len !=
                   (*state).zstrm.total_out &
                       0xffffffff as std::os::raw::c_long as std::os::raw::c_ulong {
                xz_error(state, LZMA_DATA_ERROR as std::os::raw::c_int,
                         b"incorrect length check\x00" as *const u8 as
                             *const std::os::raw::c_char);
                return -(1 as std::os::raw::c_int)
            }
            (*state).strm.avail_in = 0 as std::os::raw::c_int as size_t;
            (*state).strm.next_in = 0 as *const uint8_t;
            (*state).strm.avail_out = 0 as std::os::raw::c_int as size_t;
            (*state).strm.next_out = 0 as *mut uint8_t
        } else if (*strm).avail_in != 0 as std::os::raw::c_int as std::os::raw::c_ulong ||
                      (*state).eof == 0 {
            xz_error(state, LZMA_DATA_ERROR as std::os::raw::c_int,
                     b"trailing garbage\x00" as *const u8 as
                         *const std::os::raw::c_char);
            return -(1 as std::os::raw::c_int)
        }
        (*state).how = 0 as std::os::raw::c_int
        /* ready for next stream, once have is 0 (leave
                                 * state->direct unchanged to remember how) */
    }
    /* good decompression */
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xz_make(mut state: xz_statep) -> std::os::raw::c_int {
    let mut strm: *mut lzma_stream = &mut (*state).strm;
    if (*state).how == 0 as std::os::raw::c_int {
        /* look for lzma / gzip header */
        if xz_head(state) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
        if (*state).have != 0 {
            /* got some data from xz_head() */
            return 0 as std::os::raw::c_int
        }
    }
    if (*state).how == 1 as std::os::raw::c_int {
        /* straight copy */
        if xz_load(state, (*state).out, (*state).size << 1 as std::os::raw::c_int,
                   &mut (*state).have) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
        (*state).next = (*state).out
    } else if (*state).how == 3 as std::os::raw::c_int ||
                  (*state).how == 2 as std::os::raw::c_int {
        /* decompress */
        (*strm).avail_out = ((*state).size << 1 as std::os::raw::c_int) as size_t;
        (*strm).next_out = (*state).out;
        if xz_decomp(state) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
    }
    return 0 as std::os::raw::c_int;
}
unsafe extern "C" fn xz_skip(mut state: xz_statep, mut len: uint64_t)
 -> std::os::raw::c_int {
    let mut n: std::os::raw::c_uint = 0;
    /* skip over len bytes or reach end-of-file, whichever comes first */
    while len != 0 {
        /* skip over whatever is in output buffer */
        if (*state).have != 0 {
            n =
                if (*state).have as uint64_t > len {
                    len as std::os::raw::c_uint
                } else { (*state).have };
            (*state).have = (*state).have.wrapping_sub(n);
            (*state).next = (*state).next.offset(n as isize);
            (*state).pos =
                ((*state).pos as
                     std::os::raw::c_ulong).wrapping_add(n as std::os::raw::c_ulong) as
                    uint64_t as uint64_t;
            len =
                (len as std::os::raw::c_ulong).wrapping_sub(n as std::os::raw::c_ulong) as
                    uint64_t as uint64_t
        } else {
            /* output buffer empty -- return if we're at the end of the input */
            if (*state).eof != 0 &&
                   (*state).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong
               {
                break ;
            }
            /* need more data to skip -- load up output buffer */
            /* get more output, looking for header if required */
            if xz_make(state) == -(1 as std::os::raw::c_int) {
                return -(1 as std::os::raw::c_int)
            }
        }
    }
    return 0 as std::os::raw::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn __libxml2_xzread(mut file: xzFile,
                                          mut buf: *mut std::os::raw::c_void,
                                          mut len: std::os::raw::c_uint)
 -> std::os::raw::c_int {
    let mut got: std::os::raw::c_uint = 0;
    let mut n: std::os::raw::c_uint = 0;
    let mut state: xz_statep = 0 as *mut xz_state;
    let mut strm: *mut lzma_stream = 0 as *mut lzma_stream;
    /* get internal structure */
    if file.is_null() { return -(1 as std::os::raw::c_int) }
    state = file as xz_statep;
    strm = &mut (*state).strm;
    /* check that we're reading and that there's no error */
    if (*state).err != LZMA_OK as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
    /* since an int is returned, make sure len fits in one, otherwise return
     * with an error (this avoids the flaw in the interface) */
    if (len as std::os::raw::c_int) < 0 as std::os::raw::c_int {
        xz_error(state, LZMA_BUF_ERROR as std::os::raw::c_int,
                 b"requested length does not fit in int\x00" as *const u8 as
                     *const std::os::raw::c_char);
        return -(1 as std::os::raw::c_int)
    }
    /* if len is zero, avoid unnecessary operations */
    if len == 0 as std::os::raw::c_int as std::os::raw::c_uint { return 0 as std::os::raw::c_int }
    /* process a skip request */
    if (*state).seek != 0 {
        (*state).seek = 0 as std::os::raw::c_int;
        if xz_skip(state, (*state).skip) == -(1 as std::os::raw::c_int) {
            return -(1 as std::os::raw::c_int)
        }
    }
    /* get len bytes to buf, or less than len if at the end */
    got = 0 as std::os::raw::c_int as std::os::raw::c_uint;
    let mut current_block_39: u64;
    loop 
         /* first just try copying data from the output buffer */
         {
        if (*state).have != 0 {
            n = if (*state).have > len { len } else { (*state).have };
            memcpy(buf, (*state).next as *const std::os::raw::c_void,
                   n as std::os::raw::c_ulong);
            (*state).next = (*state).next.offset(n as isize);
            (*state).have = (*state).have.wrapping_sub(n);
            current_block_39 = 1836292691772056875;
        } else {
            /* output buffer empty -- return if we're at the end of the input */
            if (*state).eof != 0 &&
                   (*strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                break ;
            }
            /* need output data -- for small len or new stream load up our output
         * buffer */
            if (*state).how == 0 as std::os::raw::c_int ||
                   len < (*state).size << 1 as std::os::raw::c_int {
                /* get more output, looking for header if required */
                if xz_make(state) == -(1 as std::os::raw::c_int) {
                    return -(1 as std::os::raw::c_int)
                }
                current_block_39 = 15976848397966268834;
                /* no progress yet -- go back to memcpy() above */
                /* the copy above assures that we will leave with space in the
             * output buffer, allowing at least one gzungetc() to succeed */
            } else {
                /* large len -- read directly into user buffer */
                if (*state).how == 1 as std::os::raw::c_int {
                    /* read directly */
                    if xz_load(state, buf as *mut std::os::raw::c_uchar, len, &mut n)
                           == -(1 as std::os::raw::c_int) {
                        return -(1 as std::os::raw::c_int)
                    }
                } else {
                    /* large len -- decompress directly into user buffer */
                    /* state->how == LZMA */
                    (*strm).avail_out = len as size_t;
                    (*strm).next_out = buf as *mut uint8_t;
                    if xz_decomp(state) == -(1 as std::os::raw::c_int) {
                        return -(1 as std::os::raw::c_int)
                    }
                    n = (*state).have;
                    (*state).have = 0 as std::os::raw::c_int as std::os::raw::c_uint
                }
                current_block_39 = 1836292691772056875;
            }
        }
        match current_block_39 {
            1836292691772056875 => {
                /* update progress */
                len = len.wrapping_sub(n);
                buf =
                    (buf as *mut std::os::raw::c_char).offset(n as isize) as
                        *mut std::os::raw::c_void;
                got = got.wrapping_add(n);
                (*state).pos =
                    ((*state).pos as
                         std::os::raw::c_ulong).wrapping_add(n as std::os::raw::c_ulong) as
                        uint64_t as uint64_t
            }
            _ => { }
        }
        if !(len != 0) { break ; }
    }
    /* return number of bytes read into user buffer (will fit in int) */
    return got as std::os::raw::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn __libxml2_xzclose(mut file: xzFile) -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    let mut state: xz_statep = 0 as *mut xz_state;
    /* get internal structure */
    if file.is_null() { return LZMA_DATA_ERROR as std::os::raw::c_int }
    state = file as xz_statep;
    /* free memory and close file */
    if (*state).size != 0 {
        lzma_end(&mut (*state).strm);
        if (*state).init == 1 as std::os::raw::c_int {
            inflateEnd(&mut (*state).zstrm);
        }
        (*state).init = 0 as std::os::raw::c_int;
        xmlFree.expect("non-null function pointer")((*state).out as
                                                        *mut std::os::raw::c_void);
        xmlFree.expect("non-null function pointer")((*state).in_0 as
                                                        *mut std::os::raw::c_void);
    }
    xmlFree.expect("non-null function pointer")((*state).path as
                                                    *mut std::os::raw::c_void);
    if !(*state).msg.is_null() &&
           (*state).err != LZMA_MEM_ERROR as std::os::raw::c_int {
        xmlFree.expect("non-null function pointer")((*state).msg as
                                                        *mut std::os::raw::c_void);
    }
    ret = close((*state).fd);
    xmlFree.expect("non-null function pointer")(state as *mut std::os::raw::c_void);
    return if ret != 0 { ret } else { LZMA_OK as std::os::raw::c_int };
}
/* LIBXML_LZMA_ENABLED */
