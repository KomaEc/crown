
extern "C" {
    #[no_mangle]
    fn memset(_: *mut std::os::raw::c_void, _: std::os::raw::c_int, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    /*
 * Summary: interface for all global variables of the library
 * Description: all the global variables and thread handling for
 *              those variables is handled by this module.
 *
 * The bottom of this file is automatically generated by build_glob.py
 * based on the description file global.data
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
 */
    /* *
 * xmlParserInputBufferCreateFilenameFunc:
 * @URI: the URI to read from
 * @enc: the requested source encoding
 *
 * Signature for the function doing the lookup for a suitable input method
 * corresponding to an URI.
 *
 * Returns the new xmlParserInputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /* *
 * xmlOutputBufferCreateFilenameFunc:
 * @URI: the URI to write to
 * @enc: the requested target encoding
 *
 * Signature for the function doing the lookup for a suitable output method
 * corresponding to an URI.
 *
 * Returns the new xmlOutputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /*
 * Externally global symbols which need to be protected for backwards
 * compatibility support.
 */
    /* *
 * xmlRegisterNodeFunc:
 * @node: the current node
 *
 * Signature for the registration callback of a created node
 */
    /* *
 * xmlDeregisterNodeFunc:
 * @node: the current node
 *
 * Signature for the deregistration callback of a discarded node
 */
    /* * DOC_DISABLE */
/*
 * In general the memory allocation entry points are not kept
 * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED
 *    - xmlMalloc
 *    - xmlMallocAtomic
 *    - xmlRealloc
 *    - xmlMemStrdup
 *    - xmlFree
 */
    /* !LIBXML_THREAD_ALLOC_ENABLED */
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    /* LIBXML_THREAD_ALLOC_ENABLED */
    /*
 * Everything starting from the line below is
 * Automatically generated by build_glob.py.
 * Do not modify the previous line.
 */
    #[no_mangle]
    fn __xmlGenericErrorContext() -> *mut *mut std::os::raw::c_void;
    #[no_mangle]
    fn __xmlGenericError() -> *mut xmlGenericErrorFunc;
    #[no_mangle]
    static mut xmlMalloc: xmlMallocFunc;
}
pub type size_t = std::os::raw::c_ulong;
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */
/* *
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/* *
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
/* *
 * xmlMallocFunc:
 * @size:  the size requested in bytes
 *
 * Signature for a malloc() implementation.
 *
 * Returns a pointer to the newly allocated block or NULL in case of error.
 */
pub type xmlMallocFunc
    =
    Option<unsafe extern "C" fn(_: size_t) -> *mut std::os::raw::c_void>;
pub type xmlGenericErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
/*
 * list.c: lists handling implementation
 *
 * Copyright (C) 2000 Gary Pennington and Daniel Veillard.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
 * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
 *
 * Author: Gary.Pennington@uk.sun.com
 */
/*
 * Type definition are kept internal
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlLink {
    pub next: *mut _xmlLink,
    pub prev: *mut _xmlLink,
    pub data: *mut std::os::raw::c_void,
}
pub type xmlLink = _xmlLink;
pub type xmlLinkPtr = *mut xmlLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlList {
    pub sentinel: xmlLinkPtr,
    pub linkDeallocator: Option<unsafe extern "C" fn(_: xmlLinkPtr) -> ()>,
    pub linkCompare: Option<unsafe extern "C" fn(_: *const std::os::raw::c_void,
                                                 _: *const std::os::raw::c_void)
                                -> std::os::raw::c_int>,
}
pub type xmlList = _xmlList;
pub type xmlListPtr = *mut xmlList;
pub type xmlListDeallocator
    =
    Option<unsafe extern "C" fn(_: xmlLinkPtr) -> ()>;
pub type xmlListDataCompare
    =
    Option<unsafe extern "C" fn(_: *const std::os::raw::c_void,
                                _: *const std::os::raw::c_void) -> std::os::raw::c_int>;
pub type xmlListWalker
    =
    Option<unsafe extern "C" fn(_: *const std::os::raw::c_void, _: *mut std::os::raw::c_void)
               -> std::os::raw::c_int>;
/* ***********************************************************************
 *                                    *
 *                Interfaces                *
 *                                    *
 ************************************************************************/
/* *
 * xmlLinkDeallocator:
 * @l:  a list
 * @lk:  a link
 *
 * Unlink and deallocate @lk from list @l
 */
unsafe extern "C" fn xmlLinkDeallocator(mut l: xmlListPtr,
                                        mut lk: xmlLinkPtr) {
    (*(*lk).prev).next = (*lk).next;
    (*(*lk).next).prev = (*lk).prev;
    if (*l).linkDeallocator.is_some() {
        (*l).linkDeallocator.expect("non-null function pointer")(lk);
    }
    xmlFree.expect("non-null function pointer")(lk as *mut std::os::raw::c_void);
}
/* *
 * xmlLinkCompare:
 * @data0:  first data
 * @data1:  second data
 *
 * Compares two arbitrary data
 *
 * Returns -1, 0 or 1 depending on whether data1 is greater equal or smaller
 *          than data0
 */
unsafe extern "C" fn xmlLinkCompare(mut data0: *const std::os::raw::c_void,
                                    mut data1: *const std::os::raw::c_void)
 -> std::os::raw::c_int {
    if data0 < data1 {
        return -(1 as std::os::raw::c_int)
    } else { if data0 == data1 { return 0 as std::os::raw::c_int } }
    return 1 as std::os::raw::c_int;
}
/* *
 * xmlListLowerSearch:
 * @l:  a list
 * @data:  a data
 *
 * Search data in the ordered list walking from the beginning
 *
 * Returns the link containing the data or NULL
 */
unsafe extern "C" fn xmlListLowerSearch(mut l: xmlListPtr,
                                        mut data: *mut std::os::raw::c_void)
 -> xmlLinkPtr {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as xmlLinkPtr }
    lk = (*(*l).sentinel).next;
    while lk != (*l).sentinel &&
              (*l).linkCompare.expect("non-null function pointer")((*lk).data,
                                                                   data) <
                  0 as std::os::raw::c_int {
        lk = (*lk).next
    }
    return lk;
}
/* *
 * xmlListHigherSearch:
 * @l:  a list
 * @data:  a data
 *
 * Search data in the ordered list walking backward from the end
 *
 * Returns the link containing the data or NULL
 */
unsafe extern "C" fn xmlListHigherSearch(mut l: xmlListPtr,
                                         mut data: *mut std::os::raw::c_void)
 -> xmlLinkPtr {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as xmlLinkPtr }
    lk = (*(*l).sentinel).prev;
    while lk != (*l).sentinel &&
              (*l).linkCompare.expect("non-null function pointer")((*lk).data,
                                                                   data) >
                  0 as std::os::raw::c_int {
        lk = (*lk).prev
    }
    return lk;
}
/* *
 * xmlListSearch:
 * @l:  a list
 * @data:  a data
 *
 * Search data in the list
 *
 * Returns the link containing the data or NULL
 */
unsafe extern "C" fn xmlListLinkSearch(mut l: xmlListPtr,
                                       mut data: *mut std::os::raw::c_void)
 -> xmlLinkPtr {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as xmlLinkPtr }
    lk = xmlListLowerSearch(l, data);
    if lk == (*l).sentinel {
        return 0 as xmlLinkPtr
    } else {
        if (*l).linkCompare.expect("non-null function pointer")((*lk).data,
                                                                data) ==
               0 as std::os::raw::c_int {
            return lk
        }
        return 0 as xmlLinkPtr
    };
}
/* *
 * xmlListLinkReverseSearch:
 * @l:  a list
 * @data:  a data
 *
 * Search data in the list processing backward
 *
 * Returns the link containing the data or NULL
 */
unsafe extern "C" fn xmlListLinkReverseSearch(mut l: xmlListPtr,
                                              mut data: *mut std::os::raw::c_void)
 -> xmlLinkPtr {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as xmlLinkPtr }
    lk = xmlListHigherSearch(l, data);
    if lk == (*l).sentinel {
        return 0 as xmlLinkPtr
    } else {
        if (*l).linkCompare.expect("non-null function pointer")((*lk).data,
                                                                data) ==
               0 as std::os::raw::c_int {
            return lk
        }
        return 0 as xmlLinkPtr
    };
}
/* *
 * xmlListCreate:
 * @deallocator:  an optional deallocator function
 * @compare:  an optional comparison function
 *
 * Create a new list
 *
 * Returns the new list or NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListCreate(mut deallocator: xmlListDeallocator,
                                       mut compare: xmlListDataCompare)
 -> xmlListPtr {
    let mut l: xmlListPtr = 0 as *mut xmlList;
    l =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlList>()
                                                          as std::os::raw::c_ulong) as
            xmlListPtr;
    if l.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Cannot initialize memory for list\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char);
        return 0 as xmlListPtr
    }
    /* Initialize the list to NULL */
    memset(l as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           ::std::mem::size_of::<xmlList>() as std::os::raw::c_ulong);
    /* Add the sentinel */
    (*l).sentinel =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlLink>()
                                                          as std::os::raw::c_ulong) as
            xmlLinkPtr;
    if (*l).sentinel.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Cannot initialize memory for sentinel\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char);
        xmlFree.expect("non-null function pointer")(l as *mut std::os::raw::c_void);
        return 0 as xmlListPtr
    }
    (*(*l).sentinel).next = (*l).sentinel;
    (*(*l).sentinel).prev = (*l).sentinel;
    (*(*l).sentinel).data = 0 as *mut std::os::raw::c_void;
    /* If there is a link deallocator, use it */
    if deallocator.is_some() { (*l).linkDeallocator = deallocator }
    /* If there is a link comparator, use it */
    if compare.is_some() {
        (*l).linkCompare = compare
    } else {
        /* Use our own */
        (*l).linkCompare =
            Some(xmlLinkCompare as
                     unsafe extern "C" fn(_: *const std::os::raw::c_void,
                                          _: *const std::os::raw::c_void)
                         -> std::os::raw::c_int)
    }
    return l;
}
/* *
 * xmlListSearch:
 * @l:  a list
 * @data:  a search value
 *
 * Search the list for an existing value of @data
 *
 * Returns the value associated to @data or NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListSearch(mut l: xmlListPtr,
                                       mut data: *mut std::os::raw::c_void)
 -> *mut std::os::raw::c_void {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as *mut std::os::raw::c_void }
    lk = xmlListLinkSearch(l, data);
    if !lk.is_null() { return (*lk).data }
    return 0 as *mut std::os::raw::c_void;
}
/* *
 * xmlListReverseSearch:
 * @l:  a list
 * @data:  a search value
 *
 * Search the list in reverse order for an existing value of @data
 *
 * Returns the value associated to @data or NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListReverseSearch(mut l: xmlListPtr,
                                              mut data: *mut std::os::raw::c_void)
 -> *mut std::os::raw::c_void {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as *mut std::os::raw::c_void }
    lk = xmlListLinkReverseSearch(l, data);
    if !lk.is_null() { return (*lk).data }
    return 0 as *mut std::os::raw::c_void;
}
/* *
 * xmlListInsert:
 * @l:  a list
 * @data:  the data
 *
 * Insert data in the ordered list at the beginning for this value
 *
 * Returns 0 in case of success, 1 in case of failure
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListInsert(mut l: xmlListPtr,
                                       mut data: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut lkPlace: xmlLinkPtr = 0 as *mut xmlLink;
    let mut lkNew: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 1 as std::os::raw::c_int }
    lkPlace = xmlListLowerSearch(l, data);
    /* Add the new link */
    lkNew =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlLink>()
                                                          as std::os::raw::c_ulong) as
            xmlLinkPtr;
    if lkNew.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Cannot initialize memory for new link\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char);
        return 1 as std::os::raw::c_int
    }
    (*lkNew).data = data;
    lkPlace = (*lkPlace).prev;
    (*lkNew).next = (*lkPlace).next;
    (*(*lkPlace).next).prev = lkNew;
    (*lkPlace).next = lkNew;
    (*lkNew).prev = lkPlace;
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlListAppend:
 * @l:  a list
 * @data:  the data
 *
 * Insert data in the ordered list at the end for this value
 *
 * Returns 0 in case of success, 1 in case of failure
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListAppend(mut l: xmlListPtr,
                                       mut data: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut lkPlace: xmlLinkPtr = 0 as *mut xmlLink;
    let mut lkNew: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 1 as std::os::raw::c_int }
    lkPlace = xmlListHigherSearch(l, data);
    /* Add the new link */
    lkNew =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlLink>()
                                                          as std::os::raw::c_ulong) as
            xmlLinkPtr;
    if lkNew.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Cannot initialize memory for new link\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char);
        return 1 as std::os::raw::c_int
    }
    (*lkNew).data = data;
    (*lkNew).next = (*lkPlace).next;
    (*(*lkPlace).next).prev = lkNew;
    (*lkPlace).next = lkNew;
    (*lkNew).prev = lkPlace;
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlListDelete:
 * @l:  a list
 *
 * Deletes the list and its associated data
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListDelete(mut l: xmlListPtr) {
    if l.is_null() { return }
    xmlListClear(l);
    xmlFree.expect("non-null function pointer")((*l).sentinel as
                                                    *mut std::os::raw::c_void);
    xmlFree.expect("non-null function pointer")(l as *mut std::os::raw::c_void);
}
/* *
 * xmlListRemoveFirst:
 * @l:  a list
 * @data:  list data
 *
 * Remove the first instance associated to data in the list
 *
 * Returns 1 if a deallocation occurred, or 0 if not found
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListRemoveFirst(mut l: xmlListPtr,
                                            mut data: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as std::os::raw::c_int }
    /*Find the first instance of this data */
    lk = xmlListLinkSearch(l, data);
    if !lk.is_null() { xmlLinkDeallocator(l, lk); return 1 as std::os::raw::c_int }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlListRemoveLast:
 * @l:  a list
 * @data:  list data
 *
 * Remove the last instance associated to data in the list
 *
 * Returns 1 if a deallocation occurred, or 0 if not found
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListRemoveLast(mut l: xmlListPtr,
                                           mut data: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as std::os::raw::c_int }
    /*Find the last instance of this data */
    lk = xmlListLinkReverseSearch(l, data);
    if !lk.is_null() { xmlLinkDeallocator(l, lk); return 1 as std::os::raw::c_int }
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlListRemoveAll:
 * @l:  a list
 * @data:  list data
 *
 * Remove the all instance associated to data in the list
 *
 * Returns the number of deallocation, or 0 if not found
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListRemoveAll(mut l: xmlListPtr,
                                          mut data: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if l.is_null() { return 0 as std::os::raw::c_int }
    while xmlListRemoveFirst(l, data) != 0 { count += 1 }
    return count;
}
/* *
 * xmlListClear:
 * @l:  a list
 *
 * Remove the all data in the list
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListClear(mut l: xmlListPtr) {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return }
    lk = (*(*l).sentinel).next;
    while lk != (*l).sentinel {
        let mut next: xmlLinkPtr = (*lk).next;
        xmlLinkDeallocator(l, lk);
        lk = next
    };
}
/* *
 * xmlListEmpty:
 * @l:  a list
 *
 * Is the list empty ?
 *
 * Returns 1 if the list is empty, 0 if not empty and -1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListEmpty(mut l: xmlListPtr) -> std::os::raw::c_int {
    if l.is_null() { return -(1 as std::os::raw::c_int) }
    return ((*(*l).sentinel).next == (*l).sentinel) as std::os::raw::c_int;
}
/* *
 * xmlListFront:
 * @l:  a list
 *
 * Get the first element in the list
 *
 * Returns the first element in the list, or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListFront(mut l: xmlListPtr) -> xmlLinkPtr {
    if l.is_null() { return 0 as xmlLinkPtr }
    return (*(*l).sentinel).next;
}
/* *
 * xmlListEnd:
 * @l:  a list
 *
 * Get the last element in the list
 *
 * Returns the last element in the list, or NULL
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListEnd(mut l: xmlListPtr) -> xmlLinkPtr {
    if l.is_null() { return 0 as xmlLinkPtr }
    return (*(*l).sentinel).prev;
}
/* *
 * xmlListSize:
 * @l:  a list
 *
 * Get the number of elements in the list
 *
 * Returns the number of elements in the list or -1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListSize(mut l: xmlListPtr) -> std::os::raw::c_int {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if l.is_null() { return -(1 as std::os::raw::c_int) }
    /* TODO: keep a counter in xmlList instead */
    lk = (*(*l).sentinel).next;
    while lk != (*l).sentinel { lk = (*lk).next; count += 1 }
    return count;
}
/* *
 * xmlListPopFront:
 * @l:  a list
 *
 * Removes the first element in the list
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListPopFront(mut l: xmlListPtr) {
    if xmlListEmpty(l) == 0 { xmlLinkDeallocator(l, (*(*l).sentinel).next); };
}
/* *
 * xmlListPopBack:
 * @l:  a list
 *
 * Removes the last element in the list
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListPopBack(mut l: xmlListPtr) {
    if xmlListEmpty(l) == 0 { xmlLinkDeallocator(l, (*(*l).sentinel).prev); };
}
/* *
 * xmlListPushFront:
 * @l:  a list
 * @data:  new data
 *
 * add the new data at the beginning of the list
 *
 * Returns 1 if successful, 0 otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListPushFront(mut l: xmlListPtr,
                                          mut data: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut lkPlace: xmlLinkPtr = 0 as *mut xmlLink;
    let mut lkNew: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as std::os::raw::c_int }
    lkPlace = (*l).sentinel;
    /* Add the new link */
    lkNew =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlLink>()
                                                          as std::os::raw::c_ulong) as
            xmlLinkPtr;
    if lkNew.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Cannot initialize memory for new link\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char);
        return 0 as std::os::raw::c_int
    }
    (*lkNew).data = data;
    (*lkNew).next = (*lkPlace).next;
    (*(*lkPlace).next).prev = lkNew;
    (*lkPlace).next = lkNew;
    (*lkNew).prev = lkPlace;
    return 1 as std::os::raw::c_int;
}
/* *
 * xmlListPushBack:
 * @l:  a list
 * @data:  new data
 *
 * add the new data at the end of the list
 *
 * Returns 1 if successful, 0 otherwise
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListPushBack(mut l: xmlListPtr,
                                         mut data: *mut std::os::raw::c_void)
 -> std::os::raw::c_int {
    let mut lkPlace: xmlLinkPtr = 0 as *mut xmlLink;
    let mut lkNew: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return 0 as std::os::raw::c_int }
    lkPlace = (*(*l).sentinel).prev;
    /* Add the new link */
    lkNew =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlLink>()
                                                          as std::os::raw::c_ulong) as
            xmlLinkPtr;
    if lkNew.is_null() {
        (*__xmlGenericError()).expect("non-null function pointer")(*__xmlGenericErrorContext(),
                                                                   b"Cannot initialize memory for new link\x00"
                                                                       as
                                                                       *const u8
                                                                       as
                                                                       *const std::os::raw::c_char);
        return 0 as std::os::raw::c_int
    }
    (*lkNew).data = data;
    (*lkNew).next = (*lkPlace).next;
    (*(*lkPlace).next).prev = lkNew;
    (*lkPlace).next = lkNew;
    (*lkNew).prev = lkPlace;
    return 1 as std::os::raw::c_int;
}
/* Link operators */
/* *
 * xmlLinkGetData:
 * @lk:  a link
 *
 * See Returns.
 *
 * Returns a pointer to the data referenced from this link
 */
#[no_mangle]
pub unsafe extern "C" fn xmlLinkGetData(mut lk: xmlLinkPtr)
 -> *mut std::os::raw::c_void {
    if lk.is_null() { return 0 as *mut std::os::raw::c_void }
    return (*lk).data;
}
/* *
 * xmlListReverse:
 * @l:  a list
 *
 * Reverse the order of the elements in the list
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListReverse(mut l: xmlListPtr) {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    let mut lkPrev: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() { return }
    lkPrev = (*l).sentinel;
    lk = (*(*l).sentinel).next;
    while lk != (*l).sentinel {
        (*lkPrev).next = (*lkPrev).prev;
        (*lkPrev).prev = lk;
        lkPrev = lk;
        lk = (*lk).next
    }
    /* Fix up the last node */
    (*lkPrev).next = (*lkPrev).prev;
    (*lkPrev).prev = lk;
}
/* *
 * xmlListSort:
 * @l:  a list
 *
 * Sort all the elements in the list
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListSort(mut l: xmlListPtr) {
    let mut lTemp: xmlListPtr = 0 as *mut xmlList;
    if l.is_null() { return }
    if xmlListEmpty(l) != 0 { return }
    /* I think that the real answer is to implement quicksort, the
     * alternative is to implement some list copying procedure which
     * would be based on a list copy followed by a clear followed by
     * an insert. This is slow...
     */
    lTemp = xmlListDup(l);
    if lTemp.is_null() { return }
    xmlListClear(l);
    xmlListMerge(l, lTemp);
    xmlListDelete(lTemp);
}
/* *
 * xmlListWalk:
 * @l:  a list
 * @walker:  a processing function
 * @user:  a user parameter passed to the walker function
 *
 * Walk all the element of the first from first to last and
 * apply the walker function to it
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListWalk(mut l: xmlListPtr,
                                     mut walker: xmlListWalker,
                                     mut user: *mut std::os::raw::c_void) {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() || walker.is_none() { return }
    lk = (*(*l).sentinel).next;
    while lk != (*l).sentinel {
        if walker.expect("non-null function pointer")((*lk).data, user) ==
               0 as std::os::raw::c_int {
            break ;
        }
        lk = (*lk).next
    };
}
/* *
 * xmlListReverseWalk:
 * @l:  a list
 * @walker:  a processing function
 * @user:  a user parameter passed to the walker function
 *
 * Walk all the element of the list in reverse order and
 * apply the walker function to it
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListReverseWalk(mut l: xmlListPtr,
                                            mut walker: xmlListWalker,
                                            mut user: *mut std::os::raw::c_void) {
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if l.is_null() || walker.is_none() { return }
    lk = (*(*l).sentinel).prev;
    while lk != (*l).sentinel {
        if walker.expect("non-null function pointer")((*lk).data, user) ==
               0 as std::os::raw::c_int {
            break ;
        }
        lk = (*lk).prev
    };
}
/* *
 * xmlListMerge:
 * @l1:  the original list
 * @l2:  the new list
 *
 * include all the elements of the second list in the first one and
 * clear the second list
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListMerge(mut l1: xmlListPtr,
                                      mut l2: xmlListPtr) {
    xmlListCopy(l1, l2);
    xmlListClear(l2);
}
/* *
 * xmlListDup:
 * @old:  the list
 *
 * Duplicate the list
 *
 * Returns a new copy of the list or NULL in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListDup(old: xmlListPtr) -> xmlListPtr {
    let mut cur: xmlListPtr = 0 as *mut xmlList;
    if old.is_null() { return 0 as xmlListPtr }
    /* Hmmm, how to best deal with allocation issues when copying
     * lists. If there is a de-allocator, should responsibility lie with
     * the new list or the old list. Surely not both. I'll arbitrarily
     * set it to be the old list for the time being whilst I work out
     * the answer
     */
    cur = xmlListCreate(None, (*old).linkCompare);
    if cur.is_null() { return 0 as xmlListPtr }
    if 0 as std::os::raw::c_int != xmlListCopy(cur, old) { return 0 as xmlListPtr }
    return cur;
}
/*
 * Summary: lists interfaces
 * Description: this module implement the list support used in
 * various place in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>
 */
/* *
 * xmlListDeallocator:
 * @lk:  the data to deallocate
 *
 * Callback function used to free data from a list.
 */
/* *
 * xmlListDataCompare:
 * @data0: the first data
 * @data1: the second data
 *
 * Callback function used to compare 2 data.
 *
 * Returns 0 is equality, -1 or 1 otherwise depending on the ordering.
 */
/* *
 * xmlListWalker:
 * @data: the data found in the list
 * @user: extra user provided data to the walker
 *
 * Callback function used when walking a list with xmlListWalk().
 *
 * Returns 0 to stop walking the list, 1 otherwise.
 */
/* Creation/Deletion */
/* Basic Operators */
/* Advanced Operators */
/* *
 * xmlListCopy:
 * @cur:  the new list
 * @old:  the old list
 *
 * Move all the element from the old list in the new list
 *
 * Returns 0 in case of success 1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlListCopy(mut cur: xmlListPtr, old: xmlListPtr)
 -> std::os::raw::c_int {
    /* Walk the old tree and insert the data into the new one */
    let mut lk: xmlLinkPtr = 0 as *mut xmlLink;
    if old.is_null() || cur.is_null() { return 1 as std::os::raw::c_int }
    lk = (*(*old).sentinel).next;
    while lk != (*old).sentinel {
        if 0 as std::os::raw::c_int != xmlListInsert(cur, (*lk).data) {
            xmlListDelete(cur);
            return 1 as std::os::raw::c_int
        }
        lk = (*lk).next
    }
    return 0 as std::os::raw::c_int;
}
/* __INCLUDE_ELFGCCHACK */
/* xmlListUnique() */
/* xmlListSwap */
