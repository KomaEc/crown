
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type PyMemberDef;
    pub type _xmlBuf;
    pub type _xmlDict;
    /*
 * Summary: Chained hash tables
 * Description: This module implements the hash table support used in
 *		various places in the library.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Bjorn Reese <bjorn.reese@systematic.dk>
 */
    /*
 * The hash table.
 */
    pub type _xmlHashTable;
    pub type _xmlAutomataState;
    /*
 * Summary: API to build regexp automata
 * Description: the API to build regexp automata
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlAutomataPtr:
 *
 * A libxml automata description, It can be compiled into a regexp
 */
    pub type _xmlAutomata;
    pub type _xmlValidState;
    /*
 * Summary: regular expressions handling
 * Description: basic API for libxml regular expressions handling used
 *              for XML Schemas and validation.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlRegexpPtr:
 *
 * A libxml regular expression, they can actually be far more complex
 * thank the POSIX regex expressions.
 */
    pub type _xmlRegexp;
    pub type _xmlSchemaParserCtxt;
    pub type _xmlSchemaValidCtxt;
    pub type _xmlCatalog;
    pub type _xmlXPathCompExpr;
    /*
 * Summary: implementation of the Relax-NG validation
 * Description: implementation of the Relax-NG validation
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    pub type _xmlRelaxNG;
    /* *
 * A schemas validation context
 */
    pub type _xmlRelaxNGParserCtxt;
    pub type _xmlRelaxNGValidCtxt;
    pub type _xmlTextReader;
    #[no_mangle]
    static mut stdout: *mut FILE;
    #[no_mangle]
    fn PyType_IsSubtype(_: *mut PyTypeObject, _: *mut PyTypeObject)
     -> std::os::raw::c_int;
    #[no_mangle]
    static mut _Py_NoneStruct: PyObject;
    #[no_mangle]
    static mut PyFile_Type: PyTypeObject;
    #[no_mangle]
    fn PyFile_AsFile(_: *mut PyObject) -> *mut FILE;
    #[no_mangle]
    fn PyArg_ParseTuple(_: *mut PyObject, _: *const std::os::raw::c_char, _: ...)
     -> std::os::raw::c_int;
    /*
 * Summary: compile-time version informations
 * Description: compile-time version informations for the XML library
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * use those to be sure nothing nasty will happen if
 * your library and includes mismatch
 */
    #[no_mangle]
    fn xmlCheckVersion(version: std::os::raw::c_int);
    /*
 * Summary: interface for the XML entities handling
 * Description: this module provides some of the entity API needed
 *              for the parser and applications.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * The different valid entity types.
 */
    /*
 * An unit of storage for an entity, contains the string, the value
 * and the linkind data needed for the linking in the hash table.
 */
    /* application data */
    /* XML_ENTITY_DECL, must be second ! */
    /* Entity name */
    /* First child link */
    /* Last child link */
    /* -> DTD */
    /* next sibling link  */
    /* previous sibling link  */
    /* the containing document */
    /* content without ref substitution */
    /* content or ndata if unparsed */
    /* the content length */
    /* The entity type */
    /* External identifier for PUBLIC */
    /* URI for a SYSTEM or PUBLIC Entity */
    /* unused */
    /* the full URI as computed */
    /* does the entity own the childrens */
    /* was the entity content checked */
    /* this is also used to count entities
					 * references done from that entity
					 * and if it contains '<' */
    /*
 * All entities are stored in an hash table.
 * There is 2 separate hash tables for global and parameter entities.
 */
    /*
 * External functions:
 */
    /* LIBXML_LEGACY_ENABLED */
    #[no_mangle]
    fn xmlEncodeEntities(doc: xmlDocPtr, input: *const xmlChar)
     -> *const xmlChar;
    /*
 * Summary: set of routines to process strings
 * Description: type and interfaces needed for the internal string handling
 *              of the library, especially UTF8 processing.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * xmlChar:
 *
 * This is a basic byte in an UTF-8 encoded string.
 * It's unsigned allowing to pinpoint case where char * are assigned
 * to xmlChar * (possibly making serialization back impossible).
 */
    /* *
 * BAD_CAST:
 *
 * Macro to cast a string to an xmlChar * when one know its safe.
 */
    /*
 * xmlChar handling
 */
    #[no_mangle]
    fn xmlUTF8Strpos(utf: *const xmlChar, pos: std::os::raw::c_int) -> *const xmlChar;
    #[no_mangle]
    fn xmlUTF8Charcmp(utf1: *const xmlChar, utf2: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUTF8Size(utf: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUTF8Strlen(utf: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUTF8Strsub(utf: *const xmlChar, start: std::os::raw::c_int,
                     len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlUTF8Strloc(utf: *const xmlChar, utfchar: *const xmlChar)
     -> std::os::raw::c_int;
    /*
 * Initializer
 */
    #[no_mangle]
    fn xmlInitializeDict() -> std::os::raw::c_int;
    /*
 * Cleanup function
 */
    #[no_mangle]
    fn xmlDictCleanup();
    /*
 * The POSIX like API
 */
    #[no_mangle]
    fn xmlRegexpCompile(regexp: *const xmlChar) -> xmlRegexpPtr;
    #[no_mangle]
    fn xmlRegFreeRegexp(regexp: xmlRegexpPtr);
    #[no_mangle]
    fn xmlRegexpExec(comp: xmlRegexpPtr, value: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRegexpPrint(output: *mut FILE, regexp: xmlRegexpPtr);
    #[no_mangle]
    fn xmlRegexpIsDeterminist(comp: xmlRegexpPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCharStrdup(cur: *const std::os::raw::c_char) -> *mut xmlChar;
    #[no_mangle]
    fn xmlUTF8Strndup(utf: *const xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlUTF8Strsize(utf: *const xmlChar, len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCheckUTF8(utf: *const std::os::raw::c_uchar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrncatNew(str1: *const xmlChar, str2: *const xmlChar,
                     len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrncat(cur: *mut xmlChar, add: *const xmlChar, len: std::os::raw::c_int)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrcat(cur: *mut xmlChar, add: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrlen(str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrQEqual(pref: *const xmlChar, name: *const xmlChar,
                    str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrncasecmp(str1: *const xmlChar, str2: *const xmlChar,
                      len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcasecmp(str1: *const xmlChar, str2: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrncmp(str1: *const xmlChar, str2: *const xmlChar,
                  len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcmp(str1: *const xmlChar, str2: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStrcasestr(str: *const xmlChar, val: *const xmlChar)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlStrstr(str: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
    #[no_mangle]
    fn xmlStrchr(str: *const xmlChar, val: xmlChar) -> *const xmlChar;
    #[no_mangle]
    fn xmlStrsub(str: *const xmlChar, start: std::os::raw::c_int, len: std::os::raw::c_int)
     -> *mut xmlChar;
    /* *
 * xmlChildrenNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children."
 */
    /* *
 * xmlRootNode:
 *
 * Macro for compatibility naming layer with libxml1. Maps
 * to "children".
 */
    /*
 * Variables.
 */
    /*
 * Some helper functions
 */
    #[no_mangle]
    fn xmlValidateNCName(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateQName(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateName(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNMToken(value: *const xmlChar, space: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBuildQName(ncname: *const xmlChar, prefix: *const xmlChar,
                     memory: *mut xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    /*
 * Creating/freeing new structures.
 */
    #[no_mangle]
    fn xmlCreateIntSubset(doc: xmlDocPtr, name: *const xmlChar,
                          ExternalID: *const xmlChar,
                          SystemID: *const xmlChar) -> xmlDtdPtr;
    #[no_mangle]
    fn xmlNewDtd(doc: xmlDocPtr, name: *const xmlChar,
                 ExternalID: *const xmlChar, SystemID: *const xmlChar)
     -> xmlDtdPtr;
    #[no_mangle]
    fn xmlGetIntSubset(doc: *const xmlDoc) -> xmlDtdPtr;
    #[no_mangle]
    fn xmlFreeDtd(cur: xmlDtdPtr);
    #[no_mangle]
    fn xmlNewGlobalNs(doc: xmlDocPtr, href: *const xmlChar,
                      prefix: *const xmlChar) -> xmlNsPtr;
    /* LIBXML_LEGACY_ENABLED */
    #[no_mangle]
    fn xmlNewNs(node: xmlNodePtr, href: *const xmlChar,
                prefix: *const xmlChar) -> xmlNsPtr;
    #[no_mangle]
    fn xmlFreeNs(cur: xmlNsPtr);
    #[no_mangle]
    fn xmlFreeNsList(cur: xmlNsPtr);
    #[no_mangle]
    fn xmlNewDoc(version: *const xmlChar) -> xmlDocPtr;
    #[no_mangle]
    fn xmlFreeDoc(cur: xmlDocPtr);
    #[no_mangle]
    fn xmlNewDocProp(doc: xmlDocPtr, name: *const xmlChar,
                     value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlNewProp(node: xmlNodePtr, name: *const xmlChar,
                  value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlNewNsProp(node: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar,
                    value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlNewNsPropEatName(node: xmlNodePtr, ns: xmlNsPtr, name: *mut xmlChar,
                           value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlFreePropList(cur: xmlAttrPtr);
    #[no_mangle]
    fn xmlFreeProp(cur: xmlAttrPtr);
    #[no_mangle]
    fn xmlCopyProp(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlCopyPropList(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlCopyDtd(dtd: xmlDtdPtr) -> xmlDtdPtr;
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlCopyDoc(doc: xmlDocPtr, recursive: std::os::raw::c_int) -> xmlDocPtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
    /*
 * Creating new nodes.
 */
    #[no_mangle]
    fn xmlNewDocNode(doc: xmlDocPtr, ns: xmlNsPtr, name: *const xmlChar,
                     content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocNodeEatName(doc: xmlDocPtr, ns: xmlNsPtr, name: *mut xmlChar,
                            content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewNodeEatName(ns: xmlNsPtr, name: *mut xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewChild(parent: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar,
                   content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocText(doc: *const xmlDoc, content: *const xmlChar)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewText(content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocPI(doc: xmlDocPtr, name: *const xmlChar,
                   content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewPI(name: *const xmlChar, content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocTextLen(doc: xmlDocPtr, content: *const xmlChar,
                        len: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewTextLen(content: *const xmlChar, len: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocComment(doc: xmlDocPtr, content: *const xmlChar)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewComment(content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewCDataBlock(doc: xmlDocPtr, content: *const xmlChar,
                        len: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewCharRef(doc: xmlDocPtr, name: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewReference(doc: *const xmlDoc, name: *const xmlChar)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlCopyNode(node: xmlNodePtr, recursive: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlDocCopyNode(node: xmlNodePtr, doc: xmlDocPtr,
                      recursive: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlDocCopyNodeList(doc: xmlDocPtr, node: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlCopyNodeList(node: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewTextChild(parent: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar,
                       content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocRawNode(doc: xmlDocPtr, ns: xmlNsPtr, name: *const xmlChar,
                        content: *const xmlChar) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNewDocFragment(doc: xmlDocPtr) -> xmlNodePtr;
    /* LIBXML_TREE_ENABLED */
    /*
 * Navigating.
 */
    #[no_mangle]
    fn xmlGetLineNo(node: *const xmlNode) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlGetNodePath(node: *const xmlNode) -> *mut xmlChar;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
    #[no_mangle]
    fn xmlDocGetRootElement(doc: *const xmlDoc) -> xmlNodePtr;
    #[no_mangle]
    fn xmlGetLastChild(parent: *const xmlNode) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNodeIsText(node: *const xmlNode) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsBlankNode(node: *const xmlNode) -> std::os::raw::c_int;
    /*
 * Changing the structure.
 */
    #[no_mangle]
    fn xmlDocSetRootElement(doc: xmlDocPtr, root: xmlNodePtr) -> xmlNodePtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
    #[no_mangle]
    fn xmlNodeSetName(cur: xmlNodePtr, name: *const xmlChar);
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlAddChild(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlAddChildList(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlReplaceNode(old: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
    #[no_mangle]
    fn xmlAddPrevSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
    /* LIBXML_TREE_ENABLED || LIBXML_HTML_ENABLED || LIBXML_SCHEMAS_ENABLED */
    #[no_mangle]
    fn xmlAddSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlAddNextSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlUnlinkNode(cur: xmlNodePtr);
    #[no_mangle]
    fn xmlTextMerge(first: xmlNodePtr, second: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlTextConcat(node: xmlNodePtr, content: *const xmlChar,
                     len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlFreeNodeList(cur: xmlNodePtr);
    #[no_mangle]
    fn xmlFreeNode(cur: xmlNodePtr);
    #[no_mangle]
    fn xmlSetTreeDoc(tree: xmlNodePtr, doc: xmlDocPtr);
    #[no_mangle]
    fn xmlSetListDoc(list: xmlNodePtr, doc: xmlDocPtr);
    /*
 * Namespaces.
 */
    #[no_mangle]
    fn xmlSearchNs(doc: xmlDocPtr, node: xmlNodePtr,
                   nameSpace: *const xmlChar) -> xmlNsPtr;
    #[no_mangle]
    fn xmlSearchNsByHref(doc: xmlDocPtr, node: xmlNodePtr,
                         href: *const xmlChar) -> xmlNsPtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) */
    #[no_mangle]
    fn xmlSetNs(node: xmlNodePtr, ns: xmlNsPtr);
    #[no_mangle]
    fn xmlCopyNamespace(cur: xmlNsPtr) -> xmlNsPtr;
    #[no_mangle]
    fn xmlCopyNamespaceList(cur: xmlNsPtr) -> xmlNsPtr;
    /*
 * Changing the content.
 */
    #[no_mangle]
    fn xmlSetProp(node: xmlNodePtr, name: *const xmlChar,
                  value: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlSetNsProp(node: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar,
                    value: *const xmlChar) -> xmlAttrPtr;
    /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \
	  defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
    #[no_mangle]
    fn xmlGetNoNsProp(node: *const xmlNode, name: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlGetProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlHasProp(node: *const xmlNode, name: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlHasNsProp(node: *const xmlNode, name: *const xmlChar,
                    nameSpace: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlGetNsProp(node: *const xmlNode, name: *const xmlChar,
                    nameSpace: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStringGetNodeList(doc: *const xmlDoc, value: *const xmlChar)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlStringLenGetNodeList(doc: *const xmlDoc, value: *const xmlChar,
                               len: std::os::raw::c_int) -> xmlNodePtr;
    #[no_mangle]
    fn xmlNodeListGetString(doc: xmlDocPtr, list: *const xmlNode,
                            inLine: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeListGetRawString(doc: *const xmlDoc, list: *const xmlNode,
                               inLine: std::os::raw::c_int) -> *mut xmlChar;
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlNodeSetContent(cur: xmlNodePtr, content: *const xmlChar);
    #[no_mangle]
    fn xmlNodeSetContentLen(cur: xmlNodePtr, content: *const xmlChar,
                            len: std::os::raw::c_int);
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlNodeAddContent(cur: xmlNodePtr, content: *const xmlChar);
    #[no_mangle]
    fn xmlNodeAddContentLen(cur: xmlNodePtr, content: *const xmlChar,
                            len: std::os::raw::c_int);
    #[no_mangle]
    fn xmlNodeGetContent(cur: *const xmlNode) -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeGetLang(cur: *const xmlNode) -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeGetSpacePreserve(cur: *const xmlNode) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNodeSetLang(cur: xmlNodePtr, lang: *const xmlChar);
    #[no_mangle]
    fn xmlNodeSetSpacePreserve(cur: xmlNodePtr, val: std::os::raw::c_int);
    /* LIBXML_TREE_ENABLED */
    #[no_mangle]
    fn xmlNodeGetBase(doc: *const xmlDoc, cur: *const xmlNode)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlNodeSetBase(cur: xmlNodePtr, uri: *const xmlChar);
    /*
 * Removing content.
 */
    #[no_mangle]
    fn xmlRemoveProp(cur: xmlAttrPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUnsetNsProp(node: xmlNodePtr, ns: xmlNsPtr, name: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUnsetProp(node: xmlNodePtr, name: *const xmlChar) -> std::os::raw::c_int;
    /* LIBXML_OUTPUT_ENABLED */
    /*
 * Namespace handling.
 */
    #[no_mangle]
    fn xmlReconciliateNs(doc: xmlDocPtr, tree: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDocFormatDump(f: *mut FILE, cur: xmlDocPtr, format: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlElemDump(f: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
    #[no_mangle]
    fn xmlSaveFile(filename: *const std::os::raw::c_char, cur: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSaveFormatFile(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                         format: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNodeDumpOutput(buf: xmlOutputBufferPtr, doc: xmlDocPtr,
                         cur: xmlNodePtr, level: std::os::raw::c_int,
                         format: std::os::raw::c_int, encoding: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlSaveFormatFileEnc(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                            encoding: *const std::os::raw::c_char,
                            format: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSaveFileEnc(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                      encoding: *const std::os::raw::c_char) -> std::os::raw::c_int;
    /* LIBXML_OUTPUT_ENABLED */
    /*
 * XHTML
 */
    #[no_mangle]
    fn xmlIsXHTML(systemID: *const xmlChar, publicID: *const xmlChar)
     -> std::os::raw::c_int;
    /*
 * Compression.
 */
    #[no_mangle]
    fn xmlGetDocCompressMode(doc: *const xmlDoc) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSetDocCompressMode(doc: xmlDocPtr, mode: std::os::raw::c_int);
    #[no_mangle]
    fn xmlGetCompressMode() -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSetCompressMode(mode: std::os::raw::c_int);
    #[no_mangle]
    fn xmlNextElementSibling(node: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlFirstElementChild(parent: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlLastElementChild(parent: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlPreviousElementSibling(node: xmlNodePtr) -> xmlNodePtr;
    /*
 * Extended error information routines
 */
    #[no_mangle]
    fn xmlGetLastError() -> xmlErrorPtr;
    #[no_mangle]
    fn xmlResetLastError();
    #[no_mangle]
    fn xmlResetError(err: xmlErrorPtr);
    #[no_mangle]
    fn xmlCopyError(from: xmlErrorPtr, to: xmlErrorPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlGetID(doc: xmlDocPtr, ID: *const xmlChar) -> xmlAttrPtr;
    #[no_mangle]
    fn xmlIsID(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRemoveID(doc: xmlDocPtr, attr: xmlAttrPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsRef(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRemoveRef(doc: xmlDocPtr, attr: xmlAttrPtr) -> std::os::raw::c_int;
    /* *
 * The public function calls related to validity checking.
 */
    /* Allocate/Release Validation Contexts */
    #[no_mangle]
    fn xmlNewValidCtxt() -> xmlValidCtxtPtr;
    #[no_mangle]
    fn xmlValidateRoot(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidNormalizeAttributeValue(doc: xmlDocPtr, elem: xmlNodePtr,
                                       name: *const xmlChar,
                                       value: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlValidCtxtNormalizeAttributeValue(ctxt: xmlValidCtxtPtr,
                                           doc: xmlDocPtr, elem: xmlNodePtr,
                                           name: *const xmlChar,
                                           value: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlValidateDtd(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr, dtd: xmlDtdPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateDtdFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateDocument(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateElement(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                          elem: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateOneElement(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                             elem: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateOneAttribute(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                               elem: xmlNodePtr, attr: xmlAttrPtr,
                               value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateOneNamespace(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                               elem: xmlNodePtr, prefix: *const xmlChar,
                               ns: xmlNsPtr, value: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateDocumentFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    /* LIBXML_VALID_ENABLED */
    #[no_mangle]
    fn xmlValidateNotationUse(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                              notationName: *const xmlChar) -> std::os::raw::c_int;
    /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */
    #[no_mangle]
    fn xmlIsMixedElement(doc: xmlDocPtr, name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlGetDtdAttrDesc(dtd: xmlDtdPtr, elem: *const xmlChar,
                         name: *const xmlChar) -> xmlAttributePtr;
    #[no_mangle]
    fn xmlGetDtdQAttrDesc(dtd: xmlDtdPtr, elem: *const xmlChar,
                          name: *const xmlChar, prefix: *const xmlChar)
     -> xmlAttributePtr;
    #[no_mangle]
    fn xmlGetDtdQElementDesc(dtd: xmlDtdPtr, name: *const xmlChar,
                             prefix: *const xmlChar) -> xmlElementPtr;
    #[no_mangle]
    fn xmlGetDtdElementDesc(dtd: xmlDtdPtr, name: *const xmlChar)
     -> xmlElementPtr;
    #[no_mangle]
    fn xmlValidateNameValue(value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNamesValue(value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNmtokenValue(value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidateNmtokensValue(value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidatePushElement(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                              elem: xmlNodePtr, qname: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidatePushCData(ctxt: xmlValidCtxtPtr, data: *const xmlChar,
                            len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlValidatePopElement(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr,
                             elem: xmlNodePtr, qname: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlInitializePredefinedEntities();
    #[no_mangle]
    fn xmlNewEntity(doc: xmlDocPtr, name: *const xmlChar, type_0: std::os::raw::c_int,
                    ExternalID: *const xmlChar, SystemID: *const xmlChar,
                    content: *const xmlChar) -> xmlEntityPtr;
    #[no_mangle]
    fn xmlAddDocEntity(doc: xmlDocPtr, name: *const xmlChar,
                       type_0: std::os::raw::c_int, ExternalID: *const xmlChar,
                       SystemID: *const xmlChar, content: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlAddDtdEntity(doc: xmlDocPtr, name: *const xmlChar,
                       type_0: std::os::raw::c_int, ExternalID: *const xmlChar,
                       SystemID: *const xmlChar, content: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlGetPredefinedEntity(name: *const xmlChar) -> xmlEntityPtr;
    #[no_mangle]
    fn xmlGetDocEntity(doc: *const xmlDoc, name: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlGetDtdEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
    #[no_mangle]
    fn xmlGetParameterEntity(doc: xmlDocPtr, name: *const xmlChar)
     -> xmlEntityPtr;
    #[no_mangle]
    fn xmlCharStrndup(cur: *const std::os::raw::c_char, len: std::os::raw::c_int)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrndup(cur: *const xmlChar, len: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
    /* LIBXML_ICONV_ENABLED */
    /* LIBXML_ICU_ENABLED */
    /*
 * Interfaces for encoding handlers.
 */
    #[no_mangle]
    fn xmlInitCharEncodingHandlers();
    #[no_mangle]
    fn xmlCleanupCharEncodingHandlers();
    /*
 * Interfaces for encoding names and aliases.
 */
    #[no_mangle]
    fn xmlAddEncodingAlias(name: *const std::os::raw::c_char,
                           alias: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlDelEncodingAlias(alias: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlGetEncodingAlias(alias: *const std::os::raw::c_char) -> *const std::os::raw::c_char;
    #[no_mangle]
    fn xmlCleanupEncodingAliases();
    /* LIBXML_OUTPUT_ENABLED */
    /*
 * Interfaces for input
 */
    #[no_mangle]
    fn xmlCleanupInputCallbacks();
    #[no_mangle]
    fn xmlRegisterDefaultInputCallbacks();
    #[no_mangle]
    fn xmlParserInputBufferRead(in_0: xmlParserInputBufferPtr,
                                len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParserInputBufferGrow(in_0: xmlParserInputBufferPtr,
                                len: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParserInputBufferPush(in_0: xmlParserInputBufferPtr,
                                len: std::os::raw::c_int, buf: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlFreeParserInputBuffer(in_0: xmlParserInputBufferPtr);
    #[no_mangle]
    fn xmlParserGetDirectory(filename: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    /*
 * Interfaces for output
 */
    #[no_mangle]
    fn xmlCleanupOutputCallbacks();
    #[no_mangle]
    fn xmlRegisterDefaultOutputCallbacks();
    /* Couple of APIs to get the output without digging into the buffers */
    #[no_mangle]
    fn xmlOutputBufferGetContent(out: xmlOutputBufferPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlOutputBufferWrite(out: xmlOutputBufferPtr, len: std::os::raw::c_int,
                            buf: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlOutputBufferWriteString(out: xmlOutputBufferPtr,
                                  str: *const std::os::raw::c_char) -> std::os::raw::c_int;
    /*  This function only exists if HTTP support built into the library  */
    #[no_mangle]
    fn xmlRegisterHTTPPostCallbacks();
    /*
 * xmlNormalizeWindowsPath is obsolete, don't use it.
 * Check xmlCanonicPath in uri.h for a better alternative.
 */
    #[no_mangle]
    fn xmlNormalizeWindowsPath(path: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCheckFilename(path: *const std::os::raw::c_char) -> std::os::raw::c_int;
    /* *
 * Default 'file://' protocol callbacks
 */
    #[no_mangle]
    fn xmlFileMatch(filename: *const std::os::raw::c_char) -> std::os::raw::c_int;
    /* *
 * Default 'http://' protocol callbacks
 */
    #[no_mangle]
    fn xmlIOHTTPMatch(filename: *const std::os::raw::c_char) -> std::os::raw::c_int;
    /* LIBXML_HTTP_ENABLED */
    /* *
 * Default 'ftp://' protocol callbacks
 */
    #[no_mangle]
    fn xmlIOFTPMatch(filename: *const std::os::raw::c_char) -> std::os::raw::c_int;
    /*
 * Init/Cleanup
 */
    #[no_mangle]
    fn xmlInitParser();
    /*
 * Basic parsing Interfaces
 */
    #[no_mangle]
    fn xmlParseDoc(cur: *const xmlChar) -> xmlDocPtr;
    #[no_mangle]
    fn xmlParseFile(filename: *const std::os::raw::c_char) -> xmlDocPtr;
    #[no_mangle]
    fn xmlParseMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int)
     -> xmlDocPtr;
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlSubstituteEntitiesDefault(val: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlKeepBlanksDefault(val: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlStopParser(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlPedanticParserDefault(val: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlLineNumbersDefault(val: std::os::raw::c_int) -> std::os::raw::c_int;
    /*
 * Recovery mode
 */
    #[no_mangle]
    fn xmlRecoverDoc(cur: *const xmlChar) -> xmlDocPtr;
    #[no_mangle]
    fn xmlRecoverMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlRecoverFile(filename: *const std::os::raw::c_char) -> xmlDocPtr;
    /* LIBXML_SAX1_ENABLED */
    /*
 * Less common routines and SAX interfaces
 */
    #[no_mangle]
    fn xmlParseDocument(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParseExtParsedEnt(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParseEntity(filename: *const std::os::raw::c_char) -> xmlDocPtr;
    #[no_mangle]
    fn xmlParseDTD(ExternalID: *const xmlChar, SystemID: *const xmlChar)
     -> xmlDtdPtr;
    /*
 * Parser contexts handling.
 */
    #[no_mangle]
    fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlInitParserCtxt(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlClearParserCtxt(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlSetupParserForBuffer(ctxt: xmlParserCtxtPtr, buffer: *const xmlChar,
                               filename: *const std::os::raw::c_char);
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlCreateDocParserCtxt(cur: *const xmlChar) -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlParseChunk(ctxt: xmlParserCtxtPtr, chunk: *const std::os::raw::c_char,
                     size: std::os::raw::c_int, terminate: std::os::raw::c_int)
     -> std::os::raw::c_int;
    /*
 * Index lookup, actually implemented in the encoding module
 */
    #[no_mangle]
    fn xmlByteConsumed(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlCtxtReset(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlCtxtResetPush(ctxt: xmlParserCtxtPtr, chunk: *const std::os::raw::c_char,
                        size: std::os::raw::c_int, filename: *const std::os::raw::c_char,
                        encoding: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCtxtUseOptions(ctxt: xmlParserCtxtPtr, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReadDoc(cur: *const xmlChar, URL: *const std::os::raw::c_char,
                  encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlReadFile(URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                   options: std::os::raw::c_int) -> xmlDocPtr;
    #[no_mangle]
    fn xmlReadMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int,
                     URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                     options: std::os::raw::c_int) -> xmlDocPtr;
    #[no_mangle]
    fn xmlReadFd(fd: std::os::raw::c_int, URL: *const std::os::raw::c_char,
                 encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlCtxtReadDoc(ctxt: xmlParserCtxtPtr, cur: *const xmlChar,
                      URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                      options: std::os::raw::c_int) -> xmlDocPtr;
    #[no_mangle]
    fn xmlCtxtReadFile(ctxt: xmlParserCtxtPtr, filename: *const std::os::raw::c_char,
                       encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlCtxtReadMemory(ctxt: xmlParserCtxtPtr, buffer: *const std::os::raw::c_char,
                         size: std::os::raw::c_int, URL: *const std::os::raw::c_char,
                         encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlDocPtr;
    #[no_mangle]
    fn xmlCtxtReadFd(ctxt: xmlParserCtxtPtr, fd: std::os::raw::c_int,
                     URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                     options: std::os::raw::c_int) -> xmlDocPtr;
    #[no_mangle]
    fn xmlSAXDefaultVersion(version: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlDefaultSAXHandlerInit();
    #[no_mangle]
    fn docbDefaultSAXHandlerInit();
    #[no_mangle]
    fn xmlDefaultSAXHandlerInit();
    /*
 * Summary: interface for all global variables of the library
 * Description: all the global variables and thread handling for
 *              those variables is handled by this module.
 *
 * The bottom of this file is automatically generated by build_glob.py
 * based on the description file global.data
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
 */
    #[no_mangle]
    fn xmlInitGlobals();
    #[no_mangle]
    fn xmlCleanupGlobals();
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    #[no_mangle]
    fn xmlThrDefDefaultBufferSize(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefDoValidityCheckingDefaultValue(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefGetWarningsDefaultValue(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefIndentTreeOutput(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefTreeIndentString(v: *const std::os::raw::c_char)
     -> *const std::os::raw::c_char;
    #[no_mangle]
    fn xmlThrDefKeepBlanksDefaultValue(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefLineNumbersDefaultValue(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefLoadExtDtdDefaultValue(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefParserDebugEntities(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefPedanticParserDefaultValue(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefSaveNoEmptyTags(v: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlThrDefSubstituteEntitiesDefaultValue(v: std::os::raw::c_int) -> std::os::raw::c_int;
    /* LIBXML_LEGACY_ENABLED */
    #[no_mangle]
    fn xmlEncodeEntitiesReentrant(doc: xmlDocPtr, input: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlEncodeSpecialChars(doc: *const xmlDoc, input: *const xmlChar)
     -> *mut xmlChar;
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn xmlCleanupPredefinedEntities();
    /*
 * Interfaces for parsing.
 */
    #[no_mangle]
    fn xmlSchemaNewParserCtxt(URL: *const std::os::raw::c_char)
     -> xmlSchemaParserCtxtPtr;
    #[no_mangle]
    fn xmlSchemaNewMemParserCtxt(buffer: *const std::os::raw::c_char,
                                 size: std::os::raw::c_int) -> xmlSchemaParserCtxtPtr;
    #[no_mangle]
    fn xmlSchemaNewDocParserCtxt(doc: xmlDocPtr) -> xmlSchemaParserCtxtPtr;
    #[no_mangle]
    fn xmlSchemaFreeParserCtxt(ctxt: xmlSchemaParserCtxtPtr);
    #[no_mangle]
    fn xmlSchemaIsValid(ctxt: xmlSchemaValidCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaParse(ctxt: xmlSchemaParserCtxtPtr) -> xmlSchemaPtr;
    #[no_mangle]
    fn xmlSchemaFree(schema: xmlSchemaPtr);
    #[no_mangle]
    fn xmlSchemaDump(output: *mut FILE, schema: xmlSchemaPtr);
    #[no_mangle]
    fn xmlSchemaSetValidOptions(ctxt: xmlSchemaValidCtxtPtr,
                                options: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateSetFilename(vctxt: xmlSchemaValidCtxtPtr,
                                    filename: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlSchemaValidCtxtGetOptions(ctxt: xmlSchemaValidCtxtPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaNewValidCtxt(schema: xmlSchemaPtr) -> xmlSchemaValidCtxtPtr;
    #[no_mangle]
    fn xmlSchemaValidateDoc(ctxt: xmlSchemaValidCtxtPtr, instance: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateOneElement(ctxt: xmlSchemaValidCtxtPtr,
                                   elem: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidateFile(ctxt: xmlSchemaValidCtxtPtr,
                             filename: *const std::os::raw::c_char,
                             options: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSchemaValidCtxtGetParserCtxt(ctxt: xmlSchemaValidCtxtPtr)
     -> xmlParserCtxtPtr;
    /*
 * Summary: implementation of XML Schema Datatypes
 * Description: module providing the XML Schema Datatypes implementation
 *              both definition and validity checking
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    #[no_mangle]
    fn xmlSchemaCollapseString(value: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlSchemaInitTypes();
    #[no_mangle]
    fn xmlSchemaCleanupTypes();
    #[no_mangle]
    fn xmlSchemaWhiteSpaceReplace(value: *const xmlChar) -> *mut xmlChar;
    /*
 * Constructors & Destructor
 */
    #[no_mangle]
    fn xmlNewTextReader(input: xmlParserInputBufferPtr,
                        URI: *const std::os::raw::c_char) -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlNewTextReaderFilename(URI: *const std::os::raw::c_char) -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlTextReaderSetup(reader: xmlTextReaderPtr,
                          input: xmlParserInputBufferPtr,
                          URL: *const std::os::raw::c_char,
                          encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    /*
 * Iterators
 */
    #[no_mangle]
    fn xmlTextReaderRead(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderReadInnerXml(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderReadOuterXml(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderReadString(reader: xmlTextReaderPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderReadAttributeValue(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    /*
 * Attributes of the node
 */
    #[no_mangle]
    fn xmlTextReaderAttributeCount(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderDepth(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderHasAttributes(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderHasValue(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderIsDefault(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderIsEmptyElement(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderNodeType(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderQuoteChar(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderReadState(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderIsNamespaceDecl(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderConstBaseUri(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstLocalName(reader: xmlTextReaderPtr)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstName(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstNamespaceUri(reader: xmlTextReaderPtr)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstPrefix(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstXmlLang(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstString(reader: xmlTextReaderPtr, str: *const xmlChar)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderConstValue(reader: xmlTextReaderPtr) -> *const xmlChar;
    /*
 * Methods of the XmlTextReader
 */
    #[no_mangle]
    fn xmlTextReaderClose(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderGetAttributeNo(reader: xmlTextReaderPtr, no: std::os::raw::c_int)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderGetAttribute(reader: xmlTextReaderPtr,
                                 name: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderGetAttributeNs(reader: xmlTextReaderPtr,
                                   localName: *const xmlChar,
                                   namespaceURI: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderGetRemainder(reader: xmlTextReaderPtr)
     -> xmlParserInputBufferPtr;
    #[no_mangle]
    fn xmlTextReaderLookupNamespace(reader: xmlTextReaderPtr,
                                    prefix: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderMoveToAttributeNo(reader: xmlTextReaderPtr,
                                      no: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToAttribute(reader: xmlTextReaderPtr,
                                    name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToAttributeNs(reader: xmlTextReaderPtr,
                                      localName: *const xmlChar,
                                      namespaceURI: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToFirstAttribute(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToNextAttribute(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderMoveToElement(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderNormalization(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    /*
 * Summary: Unicode character APIs
 * Description: API for the Unicode character APIs
 *
 * This file is automatically generated from the
 * UCS description files of the Unicode Character Database
 * http://www.unicode.org/Public/4.0-Update1/UCD-4.0.1.html
 * using the genUnicode.py Python script.
 *
 * Generation date: Mon Mar 27 11:09:52 2006
 * Sources: Blocks-4.0.1.txt UnicodeData-4.0.1.txt
 * Author: Daniel Veillard
 */
    #[no_mangle]
    fn xmlUCSIsGreekandCoptic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    /* *
 * xmlIsPubidChar_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
    /* *
 * xmlIsPubidCharQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
    #[no_mangle]
    fn xmlIsBaseChar(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsBlank(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsChar(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsCombining(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsDigit(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsExtender(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsIdeographic(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlIsPubidChar(ch: std::os::raw::c_uint) -> std::os::raw::c_int;
    /*
 * Function to finish the work of the macros where needed.
 */
    #[no_mangle]
    fn xmlIsLetter(c: std::os::raw::c_int) -> std::os::raw::c_int;
    /* *
 * Parser context.
 */
    #[no_mangle]
    fn xmlCreateFileParserCtxt(filename: *const std::os::raw::c_char)
     -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlCreateURLParserCtxt(filename: *const std::os::raw::c_char,
                              options: std::os::raw::c_int) -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlCreateMemoryParserCtxt(buffer: *const std::os::raw::c_char,
                                 size: std::os::raw::c_int) -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlCreateEntityParserCtxt(URL: *const xmlChar, ID: *const xmlChar,
                                 base: *const xmlChar) -> xmlParserCtxtPtr;
    #[no_mangle]
    fn xmlPopInput(ctxt: xmlParserCtxtPtr) -> xmlChar;
    /* *
 * Generic production rules.
 */
    #[no_mangle]
    fn xmlParseName(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlParseNmtoken(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseAttValue(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseSystemLiteral(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParsePubidLiteral(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseCharData(ctxt: xmlParserCtxtPtr, cdata: std::os::raw::c_int);
    #[no_mangle]
    fn xmlParseComment(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParsePITarget(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlParsePI(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseNotationDecl(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseEntityDecl(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseAttributeListDecl(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseElementDecl(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParseMarkupDecl(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseCharRef(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParseEntityRef(ctxt: xmlParserCtxtPtr) -> xmlEntityPtr;
    #[no_mangle]
    fn xmlParseReference(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParsePEReference(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseDocTypeDecl(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseStartTag(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlParseEndTag(ctxt: xmlParserCtxtPtr);
    /* LIBXML_SAX1_ENABLED */
    #[no_mangle]
    fn xmlParseCDSect(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseContent(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseElement(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseVersionNum(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseVersionInfo(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseEncName(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseEncodingDecl(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlParseSDDecl(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParseXMLDecl(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseTextDecl(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseMisc(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlParseExternalSubset(ctxt: xmlParserCtxtPtr,
                              ExternalID: *const xmlChar,
                              SystemID: *const xmlChar);
    /* *
 * XML_SUBSTITUTE_NONE:
 *
 * If no entities need to be substituted.
 */
    /* *
 * XML_SUBSTITUTE_REF:
 *
 * Whether general entities need to be substituted.
 */
    /* *
 * XML_SUBSTITUTE_PEREF:
 *
 * Whether parameter entities need to be substituted.
 */
    /* *
 * XML_SUBSTITUTE_BOTH:
 *
 * Both general and parameter entities need to be substituted.
 */
    #[no_mangle]
    fn xmlStringDecodeEntities(ctxt: xmlParserCtxtPtr, str: *const xmlChar,
                               what: std::os::raw::c_int, end: xmlChar, end2: xmlChar,
                               end3: xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlStringLenDecodeEntities(ctxt: xmlParserCtxtPtr, str: *const xmlChar,
                                  len: std::os::raw::c_int, what: std::os::raw::c_int,
                                  end: xmlChar, end2: xmlChar, end3: xmlChar)
     -> *mut xmlChar;
    /*
 * Generated by MACROS on top of parser.c c.f. PUSH_AND_POP.
 */
    #[no_mangle]
    fn nodePush(ctxt: xmlParserCtxtPtr, value: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn nodePop(ctxt: xmlParserCtxtPtr) -> xmlNodePtr;
    #[no_mangle]
    fn namePop(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    #[no_mangle]
    fn namePush(ctxt: xmlParserCtxtPtr, value: *const xmlChar) -> std::os::raw::c_int;
    /*
 * other commodities shared between parser.c and parserInternals.
 */
    #[no_mangle]
    fn xmlSkipBlankChars(ctxt: xmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParserHandlePEReference(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlCheckLanguageID(lang: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCopyCharMultiByte(out: *mut xmlChar, val: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCopyChar(len: std::os::raw::c_int, out: *mut xmlChar, val: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlNextChar(ctxt: xmlParserCtxtPtr);
    /*
 * Actually comes from the HTML parser but launched from the init stuff.
 */
    #[no_mangle]
    fn htmlInitAutoClose();
    #[no_mangle]
    fn htmlCreateFileParserCtxt(filename: *const std::os::raw::c_char,
                                encoding: *const std::os::raw::c_char)
     -> htmlParserCtxtPtr;
    #[no_mangle]
    fn xmlParseQuotedString(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseNamespace(ctxt: xmlParserCtxtPtr);
    #[no_mangle]
    fn xmlNamespaceParseNSDef(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlScanName(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlNamespaceParseNCName(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlParserHandleReference(ctxt: xmlParserCtxtPtr);
    /* *
 * Entities
 */
    #[no_mangle]
    fn xmlDecodeEntities(ctxt: xmlParserCtxtPtr, len: std::os::raw::c_int,
                         what: std::os::raw::c_int, end: xmlChar, end2: xmlChar,
                         end3: xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlHandleEntity(ctxt: xmlParserCtxtPtr, entity: xmlEntityPtr);
    /*
 * Operations on a given catalog.
 */
    #[no_mangle]
    fn xmlNewCatalog(sgml: std::os::raw::c_int) -> xmlCatalogPtr;
    #[no_mangle]
    fn xmlLoadACatalog(filename: *const std::os::raw::c_char) -> xmlCatalogPtr;
    #[no_mangle]
    fn xmlLoadSGMLSuperCatalog(filename: *const std::os::raw::c_char)
     -> xmlCatalogPtr;
    #[no_mangle]
    fn xmlConvertSGMLCatalog(catal: xmlCatalogPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlACatalogAdd(catal: xmlCatalogPtr, type_0: *const xmlChar,
                      orig: *const xmlChar, replace: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlACatalogRemove(catal: xmlCatalogPtr, value: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlACatalogResolve(catal: xmlCatalogPtr, pubID: *const xmlChar,
                          sysID: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlACatalogResolveSystem(catal: xmlCatalogPtr, sysID: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlACatalogResolvePublic(catal: xmlCatalogPtr, pubID: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlACatalogResolveURI(catal: xmlCatalogPtr, URI: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlACatalogDump(catal: xmlCatalogPtr, out: *mut FILE);
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn xmlFreeCatalog(catal: xmlCatalogPtr);
    #[no_mangle]
    fn xmlCatalogIsEmpty(catal: xmlCatalogPtr) -> std::os::raw::c_int;
    /*
 * Global operations.
 */
    #[no_mangle]
    fn xmlInitializeCatalog();
    #[no_mangle]
    fn xmlLoadCatalog(filename: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlLoadCatalogs(paths: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlCatalogCleanup();
    #[no_mangle]
    fn xmlCatalogDump(out: *mut FILE);
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn xmlCatalogResolve(pubID: *const xmlChar, sysID: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogResolveSystem(sysID: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogResolvePublic(pubID: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogResolveURI(URI: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlCatalogAdd(type_0: *const xmlChar, orig: *const xmlChar,
                     replace: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlCatalogRemove(value: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlParseCatalogFile(filename: *const std::os::raw::c_char) -> xmlDocPtr;
    #[no_mangle]
    fn xmlCatalogConvert() -> std::os::raw::c_int;
    /*
 * Preference settings.
 */
    #[no_mangle]
    fn xmlCatalogSetDebug(level: std::os::raw::c_int) -> std::os::raw::c_int;
    /* DEPRECATED interfaces */
    #[no_mangle]
    fn xmlCatalogGetSystem(sysID: *const xmlChar) -> *const xmlChar;
    #[no_mangle]
    fn xmlCatalogGetPublic(pubID: *const xmlChar) -> *const xmlChar;
    /*
 * Init
 */
    #[no_mangle]
    fn xmlNanoFTPInit();
    #[no_mangle]
    fn xmlNanoFTPCleanup();
    #[no_mangle]
    fn xmlNanoFTPScanProxy(URL: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlNanoFTPProxy(host: *const std::os::raw::c_char, port: std::os::raw::c_int,
                       user: *const std::os::raw::c_char, passwd: *const std::os::raw::c_char,
                       type_0: std::os::raw::c_int);
    /*
 * Summary: minimal HTTP implementation
 * Description: minimal HTTP implementation allowing to fetch resources
 *              like external subset.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    #[no_mangle]
    fn xmlNanoHTTPInit();
    #[no_mangle]
    fn xmlNanoHTTPCleanup();
    #[no_mangle]
    fn xmlNanoHTTPScanProxy(URL: *const std::os::raw::c_char);
    /* the query string (as it appears in the URI) */
    /*
 * This function is in tree.h:
 * xmlChar *	xmlNodeGetBase	(xmlDocPtr doc,
 *                               xmlNodePtr cur);
 */
    #[no_mangle]
    fn xmlCreateURI() -> xmlURIPtr;
    #[no_mangle]
    fn xmlBuildURI(URI: *const xmlChar, base: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlBuildRelativeURI(URI: *const xmlChar, base: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlParseURI(str: *const std::os::raw::c_char) -> xmlURIPtr;
    #[no_mangle]
    fn xmlParseURIRaw(str: *const std::os::raw::c_char, raw: std::os::raw::c_int)
     -> xmlURIPtr;
    #[no_mangle]
    fn xmlParseURIReference(uri: xmlURIPtr, str: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlSaveUri(uri: xmlURIPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlPrintURI(stream: *mut FILE, uri: xmlURIPtr);
    #[no_mangle]
    fn xmlURIEscapeStr(str: *const xmlChar, list: *const xmlChar)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlURIUnescapeString(str: *const std::os::raw::c_char, len: std::os::raw::c_int,
                            target: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn xmlNormalizeURIPath(path: *mut std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlURIEscape(str: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlFreeURI(uri: xmlURIPtr);
    #[no_mangle]
    fn xmlCanonicPath(path: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlPathToURI(path: *const xmlChar) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathCmpNodes(node1: xmlNodePtr, node2: xmlNodePtr) -> std::os::raw::c_int;
    /* *
 * Conversion functions to basic types.
 */
    #[no_mangle]
    fn xmlXPathCastNumberToBoolean(val: std::os::raw::c_double) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathCastStringToBoolean(val: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathCastBooleanToNumber(val: std::os::raw::c_int) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathCastStringToNumber(val: *const xmlChar) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathCastNodeToNumber(node: xmlNodePtr) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathCastBooleanToString(val: std::os::raw::c_int) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathCastNumberToString(val: std::os::raw::c_double) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathCastNodeToString(node: xmlNodePtr) -> *mut xmlChar;
    /* *
 * Context handling.
 */
    #[no_mangle]
    fn xmlXPathNewContext(doc: xmlDocPtr) -> xmlXPathContextPtr;
    #[no_mangle]
    fn xmlXPathFreeContext(ctxt: xmlXPathContextPtr);
    #[no_mangle]
    fn xmlXPathContextSetCache(ctxt: xmlXPathContextPtr, active: std::os::raw::c_int,
                               value: std::os::raw::c_int, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    /* *
 * Evaluation functions.
 */
    #[no_mangle]
    fn xmlXPathOrderDocElems(doc: xmlDocPtr) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlXPathNodeEval(node: xmlNodePtr, str: *const xmlChar,
                        ctx: xmlXPathContextPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathEval(str: *const xmlChar, ctx: xmlXPathContextPtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathEvalExpression(str: *const xmlChar, ctxt: xmlXPathContextPtr)
     -> xmlXPathObjectPtr;
    /* LIBXML_XPATH_ENABLED */
    #[no_mangle]
    fn xmlXPathInit();
    #[no_mangle]
    fn xmlXPathIsNaN(val: std::os::raw::c_double) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathIsInf(val: std::os::raw::c_double) -> std::os::raw::c_int;
    /*
 * Summary: internal interfaces for XML Path Language implementation
 * Description: internal interfaces for XML Path Language implementation
 *              used to build new modules on top of XPath like XPointer and
 *              XSLT
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* ***********************************************************************
 *									*
 *			Helpers						*
 *									*
 ************************************************************************/
    /*
 * Many of these macros may later turn into functions. They
 * shouldn't be used in #ifdef's preprocessor instructions.
 */
/* *
 * xmlXPathSetError:
 * @ctxt:  an XPath parser context
 * @err:  an xmlXPathError code
 *
 * Raises an error.
 */
    /* *
 * xmlXPathSetArityError:
 * @ctxt:  an XPath parser context
 *
 * Raises an XPATH_INVALID_ARITY error.
 */
    /* *
 * xmlXPathSetTypeError:
 * @ctxt:  an XPath parser context
 *
 * Raises an XPATH_INVALID_TYPE error.
 */
    /* *
 * xmlXPathGetError:
 * @ctxt:  an XPath parser context
 *
 * Get the error code of an XPath context.
 *
 * Returns the context error.
 */
    /* *
 * xmlXPathCheckError:
 * @ctxt:  an XPath parser context
 *
 * Check if an XPath error was raised.
 *
 * Returns true if an error has been raised, false otherwise.
 */
    /* *
 * xmlXPathGetDocument:
 * @ctxt:  an XPath parser context
 *
 * Get the document of an XPath context.
 *
 * Returns the context document.
 */
    /* *
 * xmlXPathGetContextNode:
 * @ctxt: an XPath parser context
 *
 * Get the context node of an XPath context.
 *
 * Returns the context node.
 */
    #[no_mangle]
    fn xmlXPathPopBoolean(ctxt: xmlXPathParserContextPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathPopNumber(ctxt: xmlXPathParserContextPtr) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathPopString(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
    /*
 * Error reporting.
 */
    #[no_mangle]
    fn xmlXPatherror(ctxt: xmlXPathParserContextPtr,
                     file: *const std::os::raw::c_char, line: std::os::raw::c_int,
                     no: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathErr(ctxt: xmlXPathParserContextPtr, error: std::os::raw::c_int);
    /* *
 * Extending a context.
 */
    #[no_mangle]
    fn xmlXPathRegisterNs(ctxt: xmlXPathContextPtr, prefix: *const xmlChar,
                          ns_uri: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNsLookup(ctxt: xmlXPathContextPtr, prefix: *const xmlChar)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlXPathRegisteredNsCleanup(ctxt: xmlXPathContextPtr);
    #[no_mangle]
    fn xmlXPathRegisteredFuncsCleanup(ctxt: xmlXPathContextPtr);
    #[no_mangle]
    fn xmlXPathVariableLookup(ctxt: xmlXPathContextPtr, name: *const xmlChar)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathVariableLookupNS(ctxt: xmlXPathContextPtr,
                                name: *const xmlChar, ns_uri: *const xmlChar)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathRegisteredVariablesCleanup(ctxt: xmlXPathContextPtr);
    /* *
 * Utilities to extend XPath.
 */
    #[no_mangle]
    fn xmlXPathNewParserContext(str: *const xmlChar, ctxt: xmlXPathContextPtr)
     -> xmlXPathParserContextPtr;
    #[no_mangle]
    fn xmlXPathFreeParserContext(ctxt: xmlXPathParserContextPtr);
    /* TODO: remap to xmlXPathValuePop and Push. */
    #[no_mangle]
    fn valuePop(ctxt: xmlXPathParserContextPtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewString(val: *const xmlChar) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewCString(val: *const std::os::raw::c_char) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewFloat(val: std::os::raw::c_double) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewBoolean(val: std::os::raw::c_int) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewNodeSet(val: xmlNodePtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathNewValueTree(val: xmlNodePtr) -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPathRoot(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathEvalExpr(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathParseName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
    #[no_mangle]
    fn xmlXPathParseNCName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
    /*
 * Existing functions.
 */
    #[no_mangle]
    fn xmlXPathStringEvalNumber(str: *const xmlChar) -> std::os::raw::c_double;
    #[no_mangle]
    fn xmlXPathRegisterAllFunctions(ctxt: xmlXPathContextPtr);
    #[no_mangle]
    fn xmlXPathEqualValues(ctxt: xmlXPathParserContextPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathNotEqualValues(ctxt: xmlXPathParserContextPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathCompareValues(ctxt: xmlXPathParserContextPtr, inf: std::os::raw::c_int,
                             strict: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPathValueFlipSign(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathAddValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathSubValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathMultValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathDivValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathModValues(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlXPathIsNodeType(name: *const xmlChar) -> std::os::raw::c_int;
    /*
 * Some of the axis navigation routines.
 */
    #[no_mangle]
    fn xmlXPathNextSelf(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextChild(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextDescendant(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextDescendantOrSelf(ctxt: xmlXPathParserContextPtr,
                                    cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextParent(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextAncestorOrSelf(ctxt: xmlXPathParserContextPtr,
                                  cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextFollowingSibling(ctxt: xmlXPathParserContextPtr,
                                    cur: xmlNodePtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextFollowing(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextNamespace(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextAttribute(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextPreceding(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextAncestor(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr)
     -> xmlNodePtr;
    #[no_mangle]
    fn xmlXPathNextPrecedingSibling(ctxt: xmlXPathParserContextPtr,
                                    cur: xmlNodePtr) -> xmlNodePtr;
    /*
 * The official core of XPath functions.
 */
    #[no_mangle]
    fn xmlXPathLastFunction(ctxt: xmlXPathParserContextPtr,
                            nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathPositionFunction(ctxt: xmlXPathParserContextPtr,
                                nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathCountFunction(ctxt: xmlXPathParserContextPtr,
                             nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathIdFunction(ctxt: xmlXPathParserContextPtr, nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathLocalNameFunction(ctxt: xmlXPathParserContextPtr,
                                 nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathNamespaceURIFunction(ctxt: xmlXPathParserContextPtr,
                                    nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathStringFunction(ctxt: xmlXPathParserContextPtr,
                              nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathStringLengthFunction(ctxt: xmlXPathParserContextPtr,
                                    nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathConcatFunction(ctxt: xmlXPathParserContextPtr,
                              nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathContainsFunction(ctxt: xmlXPathParserContextPtr,
                                nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathStartsWithFunction(ctxt: xmlXPathParserContextPtr,
                                  nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathSubstringFunction(ctxt: xmlXPathParserContextPtr,
                                 nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathSubstringBeforeFunction(ctxt: xmlXPathParserContextPtr,
                                       nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathSubstringAfterFunction(ctxt: xmlXPathParserContextPtr,
                                      nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathNormalizeFunction(ctxt: xmlXPathParserContextPtr,
                                 nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathTranslateFunction(ctxt: xmlXPathParserContextPtr,
                                 nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathNotFunction(ctxt: xmlXPathParserContextPtr,
                           nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathTrueFunction(ctxt: xmlXPathParserContextPtr,
                            nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathFalseFunction(ctxt: xmlXPathParserContextPtr,
                             nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathLangFunction(ctxt: xmlXPathParserContextPtr,
                            nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathNumberFunction(ctxt: xmlXPathParserContextPtr,
                              nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathSumFunction(ctxt: xmlXPathParserContextPtr,
                           nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathFloorFunction(ctxt: xmlXPathParserContextPtr,
                             nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathCeilingFunction(ctxt: xmlXPathParserContextPtr,
                               nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathRoundFunction(ctxt: xmlXPathParserContextPtr,
                             nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPathBooleanFunction(ctxt: xmlXPathParserContextPtr,
                               nargs: std::os::raw::c_int);
    /* *
 * Really internal functions
 */
    #[no_mangle]
    fn xmlXPathNodeSetFreeNs(ns: xmlNsPtr);
    /*
 * Summary: Tree debugging APIs
 * Description: Interfaces to a set of routines used for debugging the tree
 *              produced by the XML parser.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /*
 * The standard Dump routines.
 */
    #[no_mangle]
    fn xmlDebugDumpString(output: *mut FILE, str: *const xmlChar);
    #[no_mangle]
    fn xmlDebugDumpAttr(output: *mut FILE, attr: xmlAttrPtr,
                        depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpAttrList(output: *mut FILE, attr: xmlAttrPtr,
                            depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpOneNode(output: *mut FILE, node: xmlNodePtr,
                           depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpNode(output: *mut FILE, node: xmlNodePtr,
                        depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpNodeList(output: *mut FILE, node: xmlNodePtr,
                            depth: std::os::raw::c_int);
    #[no_mangle]
    fn xmlDebugDumpDocumentHead(output: *mut FILE, doc: xmlDocPtr);
    #[no_mangle]
    fn xmlDebugDumpDocument(output: *mut FILE, doc: xmlDocPtr);
    #[no_mangle]
    fn xmlDebugDumpDTD(output: *mut FILE, dtd: xmlDtdPtr);
    #[no_mangle]
    fn xmlDebugDumpEntities(output: *mut FILE, doc: xmlDocPtr);
    /* ***************************************************************
 *								*
 *			Checking routines			*
 *								*
 ****************************************************************/
    #[no_mangle]
    fn xmlDebugCheckDocument(output: *mut FILE, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    /* ***************************************************************
 *								*
 *			XML shell helpers			*
 *								*
 ****************************************************************/
    #[no_mangle]
    fn xmlLsOneNode(output: *mut FILE, node: xmlNodePtr);
    #[no_mangle]
    fn xmlLsCountNode(node: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlBoolToText(boolval: std::os::raw::c_int) -> *const std::os::raw::c_char;
    #[no_mangle]
    fn xmlShellPrintXPathError(errorType: std::os::raw::c_int,
                               arg: *const std::os::raw::c_char);
    #[no_mangle]
    fn xmlShellPrintNode(node: xmlNodePtr);
    /*
 * Summary: specific APIs to process HTML tree, especially serialization
 * Description: this module implements a few function needed to process
 *              tree in an HTML specific way.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
    /* *
 * HTML_TEXT_NODE:
 *
 * Macro. A text node in a HTML document is really implemented
 * the same way as a text node in an XML document.
 */
    /* *
 * HTML_ENTITY_REF_NODE:
 *
 * Macro. An entity reference in a HTML document is really implemented
 * the same way as an entity reference in an XML document.
 */
    /* *
 * HTML_COMMENT_NODE:
 *
 * Macro. A comment in a HTML document is really implemented
 * the same way as a comment in an XML document.
 */
    /* *
 * HTML_PRESERVE_NODE:
 *
 * Macro. A preserved node in a HTML document is really implemented
 * the same way as a CDATA section in an XML document.
 */
    /* *
 * HTML_PI_NODE:
 *
 * Macro. A processing instruction in a HTML document is really implemented
 * the same way as a processing instruction in an XML document.
 */
    #[no_mangle]
    fn htmlNewDoc(URI: *const xmlChar, ExternalID: *const xmlChar)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlNewDocNoDtD(URI: *const xmlChar, ExternalID: *const xmlChar)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlGetMetaEncoding(doc: htmlDocPtr) -> *const xmlChar;
    #[no_mangle]
    fn htmlSetMetaEncoding(doc: htmlDocPtr, encoding: *const xmlChar)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlSaveFile(filename: *const std::os::raw::c_char, cur: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlNodeDumpFile(out: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
    #[no_mangle]
    fn htmlNodeDumpFileFormat(out: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr,
                              encoding: *const std::os::raw::c_char,
                              format: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlSaveFileEnc(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                       encoding: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlSaveFileFormat(filename: *const std::os::raw::c_char, cur: xmlDocPtr,
                          encoding: *const std::os::raw::c_char, format: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlNodeDumpFormatOutput(buf: xmlOutputBufferPtr, doc: xmlDocPtr,
                                cur: xmlNodePtr,
                                encoding: *const std::os::raw::c_char,
                                format: std::os::raw::c_int);
    #[no_mangle]
    fn htmlDocContentDumpOutput(buf: xmlOutputBufferPtr, cur: xmlDocPtr,
                                encoding: *const std::os::raw::c_char);
    #[no_mangle]
    fn htmlDocContentDumpFormatOutput(buf: xmlOutputBufferPtr, cur: xmlDocPtr,
                                      encoding: *const std::os::raw::c_char,
                                      format: std::os::raw::c_int);
    #[no_mangle]
    fn htmlNodeDumpOutput(buf: xmlOutputBufferPtr, doc: xmlDocPtr,
                          cur: xmlNodePtr, encoding: *const std::os::raw::c_char);
    /* LIBXML_OUTPUT_ENABLED */
    #[no_mangle]
    fn htmlIsBooleanAttr(name: *const xmlChar) -> std::os::raw::c_int;
    /*
 * standalone processing
 */
    #[no_mangle]
    fn xmlXIncludeProcess(doc: xmlDocPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeProcessFlags(doc: xmlDocPtr, flags: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeProcessTree(tree: xmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXIncludeProcessTreeFlags(tree: xmlNodePtr, flags: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlXPtrNewRange(start: xmlNodePtr, startindex: std::os::raw::c_int,
                       end: xmlNodePtr, endindex: std::os::raw::c_int)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewRangeNodes(start: xmlNodePtr, end: xmlNodePtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewLocationSetNodes(start: xmlNodePtr, end: xmlNodePtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrNewCollapsedRange(start: xmlNodePtr) -> xmlXPathObjectPtr;
    /*
 * Functions.
 */
    #[no_mangle]
    fn xmlXPtrNewContext(doc: xmlDocPtr, here: xmlNodePtr, origin: xmlNodePtr)
     -> xmlXPathContextPtr;
    #[no_mangle]
    fn xmlXPtrEval(str: *const xmlChar, ctx: xmlXPathContextPtr)
     -> xmlXPathObjectPtr;
    #[no_mangle]
    fn xmlXPtrRangeToFunction(ctxt: xmlXPathParserContextPtr,
                              nargs: std::os::raw::c_int);
    #[no_mangle]
    fn xmlXPtrEvalRangePredicate(ctxt: xmlXPathParserContextPtr);
    #[no_mangle]
    fn xmlUCSIsAegeanNumbers(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsAlphabeticPresentationForms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArabic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArabicPresentationFormsA(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArabicPresentationFormsB(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArmenian(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsArrows(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBasicLatin(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBengali(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBlockElements(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBopomofo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBopomofoExtended(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBoxDrawing(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBraillePatterns(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBuhid(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsByzantineMusicalSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKCompatibility(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKCompatibilityForms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKCompatibilityIdeographs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKCompatibilityIdeographsSupplement(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKRadicalsSupplement(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKSymbolsandPunctuation(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKUnifiedIdeographs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKUnifiedIdeographsExtensionA(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCJKUnifiedIdeographsExtensionB(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCherokee(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCombiningDiacriticalMarks(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCombiningDiacriticalMarksforSymbols(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCombiningHalfMarks(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCombiningMarksforSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsControlPictures(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCurrencySymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCypriotSyllabary(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCyrillic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCyrillicSupplement(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsDeseret(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsDevanagari(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsDingbats(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsEnclosedAlphanumerics(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsEnclosedCJKLettersandMonths(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsEthiopic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGeneralPunctuation(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGeometricShapes(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGeorgian(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGothic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGreek(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGreekExtended(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn libxml_xmlErrorPtrWrap(error: xmlErrorPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlSchemaValidCtxtPtrWrap(valid: xmlSchemaValidCtxtPtr)
     -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlSchemaParserCtxtPtrWrap(ctxt: xmlSchemaParserCtxtPtr)
     -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlSchemaPtrWrap(ctxt: xmlSchemaPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlRelaxNGValidCtxtPtrWrap(valid: xmlRelaxNGValidCtxtPtr)
     -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlRelaxNGParserCtxtPtrWrap(ctxt: xmlRelaxNGParserCtxtPtr)
     -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlRelaxNGPtrWrap(ctxt: xmlRelaxNGPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlTextReaderPtrWrap(reader: xmlTextReaderPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlRegexpPtrWrap(regexp: xmlRegexpPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlParserInputBufferPtrWrap(buffer: xmlParserInputBufferPtr)
     -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlURIPtrWrap(uri: xmlURIPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlCatalogPtrWrap(obj: xmlCatalogPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlValidCtxtPtrWrap(valid: xmlValidCtxtPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlXPathObjectPtrWrap(obj: xmlXPathObjectPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlXPathParserContextPtrWrap(ctxt: xmlXPathParserContextPtr)
     -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlParserCtxtPtrWrap(ctxt: xmlParserCtxtPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlXPathContextPtrWrap(ctxt: xmlXPathContextPtr)
     -> *mut PyObject;
    #[no_mangle]
    fn libxml_doubleWrap(val: std::os::raw::c_double) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlElementPtrWrap(ns: xmlElementPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlAttributePtrWrap(ns: xmlAttributePtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlNsPtrWrap(ns: xmlNsPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlNodePtrWrap(node: xmlNodePtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlDocPtrWrap(doc: xmlDocPtr) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlCharPtrConstWrap(str: *const xmlChar) -> *mut PyObject;
    #[no_mangle]
    fn libxml_charPtrConstWrap(str: *const std::os::raw::c_char) -> *mut PyObject;
    #[no_mangle]
    fn libxml_charPtrWrap(str: *mut std::os::raw::c_char) -> *mut PyObject;
    #[no_mangle]
    fn libxml_xmlCharPtrWrap(str: *mut xmlChar) -> *mut PyObject;
    #[no_mangle]
    fn libxml_longWrap(val: std::os::raw::c_long) -> *mut PyObject;
    #[no_mangle]
    fn libxml_intWrap(val: std::os::raw::c_int) -> *mut PyObject;
    #[no_mangle]
    fn xmlTextReaderLocatorBaseURI(locator: xmlTextReaderLocatorPtr)
     -> *mut xmlChar;
    #[no_mangle]
    fn xmlTextReaderLocatorLineNumber(locator: xmlTextReaderLocatorPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReaderNewFd(reader: xmlTextReaderPtr, fd: std::os::raw::c_int,
                      URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                      options: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReaderNewMemory(reader: xmlTextReaderPtr,
                          buffer: *const std::os::raw::c_char, size: std::os::raw::c_int,
                          URL: *const std::os::raw::c_char,
                          encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReaderNewFile(reader: xmlTextReaderPtr,
                        filename: *const std::os::raw::c_char,
                        encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReaderNewDoc(reader: xmlTextReaderPtr, cur: *const xmlChar,
                       URL: *const std::os::raw::c_char,
                       encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReaderNewWalker(reader: xmlTextReaderPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlReaderForFd(fd: std::os::raw::c_int, URL: *const std::os::raw::c_char,
                      encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlReaderForMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int,
                          URL: *const std::os::raw::c_char,
                          encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlReaderForFile(filename: *const std::os::raw::c_char,
                        encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlRelaxNGInitTypes() -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGCleanupTypes();
    /*
 * Interfaces for parsing.
 */
    #[no_mangle]
    fn xmlRelaxNGNewParserCtxt(URL: *const std::os::raw::c_char)
     -> xmlRelaxNGParserCtxtPtr;
    #[no_mangle]
    fn xmlRelaxNGNewMemParserCtxt(buffer: *const std::os::raw::c_char,
                                  size: std::os::raw::c_int)
     -> xmlRelaxNGParserCtxtPtr;
    #[no_mangle]
    fn xmlRelaxNGNewDocParserCtxt(doc: xmlDocPtr) -> xmlRelaxNGParserCtxtPtr;
    #[no_mangle]
    fn xmlRelaxParserSetFlag(ctxt: xmlRelaxNGParserCtxtPtr, flag: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGFreeParserCtxt(ctxt: xmlRelaxNGParserCtxtPtr);
    #[no_mangle]
    fn xmlRelaxNGParse(ctxt: xmlRelaxNGParserCtxtPtr) -> xmlRelaxNGPtr;
    #[no_mangle]
    fn xmlRelaxNGFree(schema: xmlRelaxNGPtr);
    #[no_mangle]
    fn xmlRelaxNGDump(output: *mut FILE, schema: xmlRelaxNGPtr);
    #[no_mangle]
    fn xmlRelaxNGDumpTree(output: *mut FILE, schema: xmlRelaxNGPtr);
    #[no_mangle]
    fn xmlRelaxNGNewValidCtxt(schema: xmlRelaxNGPtr)
     -> xmlRelaxNGValidCtxtPtr;
    #[no_mangle]
    fn xmlRelaxNGValidateDoc(ctxt: xmlRelaxNGValidCtxtPtr, doc: xmlDocPtr)
     -> std::os::raw::c_int;
    /*
 * Interfaces for progressive validation when possible
 */
    #[no_mangle]
    fn xmlRelaxNGValidatePushElement(ctxt: xmlRelaxNGValidCtxtPtr,
                                     doc: xmlDocPtr, elem: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGValidatePushCData(ctxt: xmlRelaxNGValidCtxtPtr,
                                   data: *const xmlChar, len: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGValidatePopElement(ctxt: xmlRelaxNGValidCtxtPtr,
                                    doc: xmlDocPtr, elem: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlRelaxNGValidateFullElement(ctxt: xmlRelaxNGValidCtxtPtr,
                                     doc: xmlDocPtr, elem: xmlNodePtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlCtxtReadFd(ctxt: xmlParserCtxtPtr, fd: std::os::raw::c_int,
                      URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                      options: std::os::raw::c_int) -> htmlDocPtr;
    #[no_mangle]
    fn htmlCtxtReadMemory(ctxt: xmlParserCtxtPtr, buffer: *const std::os::raw::c_char,
                          size: std::os::raw::c_int, URL: *const std::os::raw::c_char,
                          encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlCtxtReadFile(ctxt: xmlParserCtxtPtr, filename: *const std::os::raw::c_char,
                        encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlCtxtReadDoc(ctxt: xmlParserCtxtPtr, cur: *const xmlChar,
                       URL: *const std::os::raw::c_char,
                       encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlReadFd(fd: std::os::raw::c_int, URL: *const std::os::raw::c_char,
                  encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlReadMemory(buffer: *const std::os::raw::c_char, size: std::os::raw::c_int,
                      URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                      options: std::os::raw::c_int) -> htmlDocPtr;
    #[no_mangle]
    fn htmlReadFile(URL: *const std::os::raw::c_char, encoding: *const std::os::raw::c_char,
                    options: std::os::raw::c_int) -> htmlDocPtr;
    #[no_mangle]
    fn htmlReadDoc(cur: *const xmlChar, URL: *const std::os::raw::c_char,
                   encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlCtxtUseOptions(ctxt: htmlParserCtxtPtr, options: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlCtxtReset(ctxt: htmlParserCtxtPtr);
    #[no_mangle]
    fn htmlFreeParserCtxt(ctxt: htmlParserCtxtPtr);
    #[no_mangle]
    fn htmlParseChunk(ctxt: htmlParserCtxtPtr, chunk: *const std::os::raw::c_char,
                      size: std::os::raw::c_int, terminate: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlHandleOmittedElem(val: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlIsScriptAttribute(name: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlParseFile(filename: *const std::os::raw::c_char,
                     encoding: *const std::os::raw::c_char) -> htmlDocPtr;
    #[no_mangle]
    fn htmlParseDoc(cur: *const xmlChar, encoding: *const std::os::raw::c_char)
     -> htmlDocPtr;
    #[no_mangle]
    fn htmlParseDocument(ctxt: htmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlCreateMemoryParserCtxt(buffer: *const std::os::raw::c_char,
                                  size: std::os::raw::c_int) -> htmlParserCtxtPtr;
    #[no_mangle]
    fn htmlNewParserCtxt() -> htmlParserCtxtPtr;
    #[no_mangle]
    fn htmlParseElement(ctxt: htmlParserCtxtPtr);
    #[no_mangle]
    fn htmlParseCharRef(ctxt: htmlParserCtxtPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlAutoCloseTag(doc: htmlDocPtr, name: *const xmlChar,
                        elem: htmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn htmlIsAutoClosed(doc: htmlDocPtr, elem: htmlNodePtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderConstEncoding(reader: xmlTextReaderPtr) -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderSetParserProp(reader: xmlTextReaderPtr, prop: std::os::raw::c_int,
                                  value: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderGetParserProp(reader: xmlTextReaderPtr, prop: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderCurrentNode(reader: xmlTextReaderPtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlTextReaderGetParserLineNumber(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderGetParserColumnNumber(reader: xmlTextReaderPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderPreserve(reader: xmlTextReaderPtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlTextReaderCurrentDoc(reader: xmlTextReaderPtr) -> xmlDocPtr;
    #[no_mangle]
    fn xmlTextReaderExpand(reader: xmlTextReaderPtr) -> xmlNodePtr;
    #[no_mangle]
    fn xmlTextReaderNext(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderNextSibling(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderIsValid(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderRelaxNGValidate(reader: xmlTextReaderPtr,
                                    rng: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderRelaxNGValidateCtxt(reader: xmlTextReaderPtr,
                                        ctxt: xmlRelaxNGValidCtxtPtr,
                                        options: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderRelaxNGSetSchema(reader: xmlTextReaderPtr,
                                     schema: xmlRelaxNGPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderSchemaValidate(reader: xmlTextReaderPtr,
                                   xsd: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderSchemaValidateCtxt(reader: xmlTextReaderPtr,
                                       ctxt: xmlSchemaValidCtxtPtr,
                                       options: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderSetSchema(reader: xmlTextReaderPtr, schema: xmlSchemaPtr)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderConstXmlVersion(reader: xmlTextReaderPtr)
     -> *const xmlChar;
    #[no_mangle]
    fn xmlTextReaderStandalone(reader: xmlTextReaderPtr) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlTextReaderByteConsumed(reader: xmlTextReaderPtr) -> std::os::raw::c_long;
    #[no_mangle]
    fn xmlReaderWalker(doc: xmlDocPtr) -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlReaderForDoc(cur: *const xmlChar, URL: *const std::os::raw::c_char,
                       encoding: *const std::os::raw::c_char, options: std::os::raw::c_int)
     -> xmlTextReaderPtr;
    #[no_mangle]
    fn xmlUCSIsThaana(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsIPAExtensions(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHiragana(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKanbun(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKangxiRadicals(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKannada(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKatakana(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKatakanaPhoneticExtensions(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKhmer(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsKhmerSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHighSurrogates(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHighPrivateUseSurrogates(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHebrew(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHanunoo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHangulSyllables(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHangulJamo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLao(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHangulCompatibilityJamo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsHalfwidthandFullwidthForms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGurmukhi(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLatin1Supplement(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsGujarati(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLatinExtendedA(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLatinExtendedB(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLatinExtendedAdditional(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLetterlikeSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLimbu(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLinearBIdeograms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLinearBSyllabary(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsLowSurrogates(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMalayalam(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMathematicalAlphanumericSymbols(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMathematicalOperators(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousMathematicalSymbolsA(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousMathematicalSymbolsB(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousSymbolsandArrows(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMiscellaneousTechnical(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMongolian(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMusicalSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsMyanmar(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsNumberForms(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOgham(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOldItalic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOpticalCharacterRecognition(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOriya(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsOsmanya(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsIdeographicDescriptionCharacters(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTelugu(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTamil(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTaiXuanJingSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTaiLe(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTags(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTagbanwa(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTagalog(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSyriac(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementaryPrivateUseAreaB(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementaryPrivateUseAreaA(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementalMathematicalOperators(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementalArrowsB(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSupplementalArrowsA(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSuperscriptsandSubscripts(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSpecials(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSpacingModifierLetters(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSmallFormVariants(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsSinhala(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsShavian(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsRunic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsPrivateUseArea(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsPrivateUse(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsPhoneticExtensions(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPc(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsTibetan(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsUgaritic(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsUnifiedCanadianAboriginalSyllabics(code: std::os::raw::c_int)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsVariationSelectors(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsVariationSelectorsSupplement(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsYiRadicals(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsYiSyllables(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsYijingHexagramSymbols(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsBlock(code: std::os::raw::c_int, block: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatC(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatCc(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatCf(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatCo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatCs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatL(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLl(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLm(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLt(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatLu(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatM(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatMc(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatMe(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatMn(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatN(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatNd(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatNl(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatNo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsThai(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatP(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPd(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPe(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPf(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPi(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatPs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatS(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatSc(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatSk(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatSm(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatSo(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatZ(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatZl(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatZp(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCatZs(code: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn xmlUCSIsCat(code: std::os::raw::c_int, cat: *const std::os::raw::c_char)
     -> std::os::raw::c_int;
}
pub type size_t = std::os::raw::c_ulong;
pub type __off_t = std::os::raw::c_long;
pub type __off64_t = std::os::raw::c_long;
pub type __ssize_t = std::os::raw::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: std::os::raw::c_int,
    pub _IO_read_ptr: *mut std::os::raw::c_char,
    pub _IO_read_end: *mut std::os::raw::c_char,
    pub _IO_read_base: *mut std::os::raw::c_char,
    pub _IO_write_base: *mut std::os::raw::c_char,
    pub _IO_write_ptr: *mut std::os::raw::c_char,
    pub _IO_write_end: *mut std::os::raw::c_char,
    pub _IO_buf_base: *mut std::os::raw::c_char,
    pub _IO_buf_end: *mut std::os::raw::c_char,
    pub _IO_save_base: *mut std::os::raw::c_char,
    pub _IO_backup_base: *mut std::os::raw::c_char,
    pub _IO_save_end: *mut std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: std::os::raw::c_int,
    pub _flags2: std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: std::os::raw::c_ushort,
    pub _vtable_offset: std::os::raw::c_schar,
    pub _shortbuf: [std::os::raw::c_char; 1],
    pub _lock: *mut std::os::raw::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: std::os::raw::c_int,
    pub _unused2: [std::os::raw::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type ssize_t = __ssize_t;
/* HAVE_UINTPTR_T */
/* Py_ssize_t is a signed integral type such that sizeof(Py_ssize_t) ==
 * sizeof(size_t).  C99 doesn't define such a thing directly (size_t is an
 * unsigned integral type).  See PEP 353 for details.
 */
pub type Py_ssize_t = ssize_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _typeobject {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub ob_size: Py_ssize_t,
    pub tp_name: *const std::os::raw::c_char,
    pub tp_basicsize: Py_ssize_t,
    pub tp_itemsize: Py_ssize_t,
    pub tp_dealloc: destructor,
    pub tp_print: printfunc,
    pub tp_getattr: getattrfunc,
    pub tp_setattr: setattrfunc,
    pub tp_compare: cmpfunc,
    pub tp_repr: reprfunc,
    pub tp_as_number: *mut PyNumberMethods,
    pub tp_as_sequence: *mut PySequenceMethods,
    pub tp_as_mapping: *mut PyMappingMethods,
    pub tp_hash: hashfunc,
    pub tp_call: ternaryfunc,
    pub tp_str: reprfunc,
    pub tp_getattro: getattrofunc,
    pub tp_setattro: setattrofunc,
    pub tp_as_buffer: *mut PyBufferProcs,
    pub tp_flags: std::os::raw::c_long,
    pub tp_doc: *const std::os::raw::c_char,
    pub tp_traverse: traverseproc,
    pub tp_clear: inquiry,
    pub tp_richcompare: richcmpfunc,
    pub tp_weaklistoffset: Py_ssize_t,
    pub tp_iter: getiterfunc,
    pub tp_iternext: iternextfunc,
    pub tp_methods: *mut PyMethodDef,
    pub tp_members: *mut PyMemberDef,
    pub tp_getset: *mut PyGetSetDef,
    pub tp_base: *mut _typeobject,
    pub tp_dict: *mut PyObject,
    pub tp_descr_get: descrgetfunc,
    pub tp_descr_set: descrsetfunc,
    pub tp_dictoffset: Py_ssize_t,
    pub tp_init: initproc,
    pub tp_alloc: allocfunc,
    pub tp_new: newfunc,
    pub tp_free: freefunc,
    pub tp_is_gc: inquiry,
    pub tp_bases: *mut PyObject,
    pub tp_mro: *mut PyObject,
    pub tp_cache: *mut PyObject,
    pub tp_subclasses: *mut PyObject,
    pub tp_weaklist: *mut PyObject,
    pub tp_del: destructor,
    pub tp_version_tag: std::os::raw::c_uint,
}
pub type destructor = Option<unsafe extern "C" fn(_: *mut PyObject) -> ()>;
pub type PyObject = _object;
pub type inquiry
    =
    Option<unsafe extern "C" fn(_: *mut PyObject) -> std::os::raw::c_int>;
pub type freefunc = Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type newfunc
    =
    Option<unsafe extern "C" fn(_: *mut _typeobject, _: *mut PyObject,
                                _: *mut PyObject) -> *mut PyObject>;
pub type allocfunc
    =
    Option<unsafe extern "C" fn(_: *mut _typeobject, _: Py_ssize_t)
               -> *mut PyObject>;
pub type initproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject,
                                _: *mut PyObject) -> std::os::raw::c_int>;
pub type descrsetfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject,
                                _: *mut PyObject) -> std::os::raw::c_int>;
pub type descrgetfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject,
                                _: *mut PyObject) -> *mut PyObject>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyGetSetDef {
    pub name: *mut std::os::raw::c_char,
    pub get: getter,
    pub set: setter,
    pub doc: *mut std::os::raw::c_char,
    pub closure: *mut std::os::raw::c_void,
}
/* Descriptors */
pub type setter
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject,
                                _: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type getter
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut std::os::raw::c_void)
               -> *mut PyObject>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyMethodDef {
    pub ml_name: *const std::os::raw::c_char,
    pub ml_meth: PyCFunction,
    pub ml_flags: std::os::raw::c_int,
    pub ml_doc: *const std::os::raw::c_char,
}
/* Method object interface */
/* This is about the type 'builtin_function_or_method',
   not Python methods in user-defined classes.  See classobject.h
   for the latter. */
pub type PyCFunction
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject)
               -> *mut PyObject>;
pub type iternextfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject) -> *mut PyObject>;
pub type getiterfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject) -> *mut PyObject>;
pub type richcmpfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject,
                                _: std::os::raw::c_int) -> *mut PyObject>;
pub type traverseproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: visitproc,
                                _: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type visitproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut std::os::raw::c_void)
               -> std::os::raw::c_int>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyBufferProcs {
    pub bf_getreadbuffer: readbufferproc,
    pub bf_getwritebuffer: writebufferproc,
    pub bf_getsegcount: segcountproc,
    pub bf_getcharbuffer: charbufferproc,
    pub bf_getbuffer: getbufferproc,
    pub bf_releasebuffer: releasebufferproc,
}
pub type releasebufferproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut Py_buffer) -> ()>;
pub type Py_buffer = bufferinfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bufferinfo {
    pub buf: *mut std::os::raw::c_void,
    pub obj: *mut PyObject,
    pub len: Py_ssize_t,
    pub itemsize: Py_ssize_t,
    pub readonly: std::os::raw::c_int,
    pub ndim: std::os::raw::c_int,
    pub format: *mut std::os::raw::c_char,
    pub shape: *mut Py_ssize_t,
    pub strides: *mut Py_ssize_t,
    pub suboffsets: *mut Py_ssize_t,
    pub smalltable: [Py_ssize_t; 2],
    pub internal: *mut std::os::raw::c_void,
}
pub type getbufferproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut Py_buffer,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
pub type charbufferproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: Py_ssize_t,
                                _: *mut *mut std::os::raw::c_char) -> Py_ssize_t>;
pub type segcountproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut Py_ssize_t)
               -> Py_ssize_t>;
pub type writebufferproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: Py_ssize_t,
                                _: *mut *mut std::os::raw::c_void) -> Py_ssize_t>;
pub type readbufferproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: Py_ssize_t,
                                _: *mut *mut std::os::raw::c_void) -> Py_ssize_t>;
pub type setattrofunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject,
                                _: *mut PyObject) -> std::os::raw::c_int>;
pub type getattrofunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject)
               -> *mut PyObject>;
pub type reprfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject) -> *mut PyObject>;
pub type ternaryfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject,
                                _: *mut PyObject) -> *mut PyObject>;
pub type hashfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject) -> std::os::raw::c_long>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyMappingMethods {
    pub mp_length: lenfunc,
    pub mp_subscript: binaryfunc,
    pub mp_ass_subscript: objobjargproc,
}
pub type objobjargproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject,
                                _: *mut PyObject) -> std::os::raw::c_int>;
pub type binaryfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject)
               -> *mut PyObject>;
pub type lenfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject) -> Py_ssize_t>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PySequenceMethods {
    pub sq_length: lenfunc,
    pub sq_concat: binaryfunc,
    pub sq_repeat: ssizeargfunc,
    pub sq_item: ssizeargfunc,
    pub sq_slice: ssizessizeargfunc,
    pub sq_ass_item: ssizeobjargproc,
    pub sq_ass_slice: ssizessizeobjargproc,
    pub sq_contains: objobjproc,
    pub sq_inplace_concat: binaryfunc,
    pub sq_inplace_repeat: ssizeargfunc,
}
pub type ssizeargfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: Py_ssize_t)
               -> *mut PyObject>;
pub type objobjproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject)
               -> std::os::raw::c_int>;
pub type ssizessizeobjargproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: Py_ssize_t,
                                _: Py_ssize_t, _: *mut PyObject)
               -> std::os::raw::c_int>;
pub type ssizeobjargproc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: Py_ssize_t,
                                _: *mut PyObject) -> std::os::raw::c_int>;
pub type ssizessizeargfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: Py_ssize_t,
                                _: Py_ssize_t) -> *mut PyObject>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyNumberMethods {
    pub nb_add: binaryfunc,
    pub nb_subtract: binaryfunc,
    pub nb_multiply: binaryfunc,
    pub nb_divide: binaryfunc,
    pub nb_remainder: binaryfunc,
    pub nb_divmod: binaryfunc,
    pub nb_power: ternaryfunc,
    pub nb_negative: unaryfunc,
    pub nb_positive: unaryfunc,
    pub nb_absolute: unaryfunc,
    pub nb_nonzero: inquiry,
    pub nb_invert: unaryfunc,
    pub nb_lshift: binaryfunc,
    pub nb_rshift: binaryfunc,
    pub nb_and: binaryfunc,
    pub nb_xor: binaryfunc,
    pub nb_or: binaryfunc,
    pub nb_coerce: coercion,
    pub nb_int: unaryfunc,
    pub nb_long: unaryfunc,
    pub nb_float: unaryfunc,
    pub nb_oct: unaryfunc,
    pub nb_hex: unaryfunc,
    pub nb_inplace_add: binaryfunc,
    pub nb_inplace_subtract: binaryfunc,
    pub nb_inplace_multiply: binaryfunc,
    pub nb_inplace_divide: binaryfunc,
    pub nb_inplace_remainder: binaryfunc,
    pub nb_inplace_power: ternaryfunc,
    pub nb_inplace_lshift: binaryfunc,
    pub nb_inplace_rshift: binaryfunc,
    pub nb_inplace_and: binaryfunc,
    pub nb_inplace_xor: binaryfunc,
    pub nb_inplace_or: binaryfunc,
    pub nb_floor_divide: binaryfunc,
    pub nb_true_divide: binaryfunc,
    pub nb_inplace_floor_divide: binaryfunc,
    pub nb_inplace_true_divide: binaryfunc,
    pub nb_index: unaryfunc,
}
pub type unaryfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject) -> *mut PyObject>;
pub type coercion
    =
    Option<unsafe extern "C" fn(_: *mut *mut PyObject, _: *mut *mut PyObject)
               -> std::os::raw::c_int>;
pub type cmpfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut PyObject)
               -> std::os::raw::c_int>;
pub type setattrfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut std::os::raw::c_char,
                                _: *mut PyObject) -> std::os::raw::c_int>;
pub type getattrfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut std::os::raw::c_char)
               -> *mut PyObject>;
pub type printfunc
    =
    Option<unsafe extern "C" fn(_: *mut PyObject, _: *mut FILE,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
pub type PyTypeObject = _typeobject;
pub type xmlChar = std::os::raw::c_uchar;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInputBuffer {
    pub context: *mut std::os::raw::c_void,
    pub readcallback: xmlInputReadCallback,
    pub closecallback: xmlInputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub raw: xmlBufPtr,
    pub compressed: std::os::raw::c_int,
    pub error: std::os::raw::c_int,
    pub rawconsumed: std::os::raw::c_ulong,
}
/* *
 * xmlBufPtr:
 *
 * A pointer to a buffer structure, the actual structure internals are not
 * public
 */
pub type xmlBufPtr = *mut xmlBuf;
/* in IO mode we may have a different base */
/* *
 * xmlBuf:
 *
 * A buffer structure, new one, the actual structure internals are not public
 */
pub type xmlBuf = _xmlBuf;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
/*
 * Block defining the handlers for non UTF-8 encodings.
 * If iconv is supported, there are two extra fields.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlCharEncodingHandler {
    pub name: *mut std::os::raw::c_char,
    pub input: xmlCharEncodingInputFunc,
    pub output: xmlCharEncodingOutputFunc,
    pub iconv_in: iconv_t,
    pub iconv_out: iconv_t,
}
pub type iconv_t = *mut std::os::raw::c_void;
/* *
 * xmlCharEncodingOutputFunc:
 * @out:  a pointer to an array of bytes to store the result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of UTF-8 chars
 * @inlen:  the length of @in
 *
 * Take a block of UTF-8 chars in and try to convert it to another
 * encoding.
 * Note: a first call designed to produce heading info is called with
 * in = NULL. If stateful this should also initialize the encoder state.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets produced.
 */
pub type xmlCharEncodingOutputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
/*
 * Summary: interface for the encoding conversion functions
 * Description: interface for the encoding conversion functions needed for
 *              XML basic encoding and iconv() support.
 *
 * Related specs are
 * rfc2044        (UTF-8 and UTF-16) F. Yergeau Alis Technologies
 * [ISO-10646]    UTF-8 and UTF-16 in Annexes
 * [ISO-8859-1]   ISO Latin-1 characters codes.
 * [UNICODE]      The Unicode Consortium, "The Unicode Standard --
 *                Worldwide Character Encoding -- Version 1.0", Addison-
 *                Wesley, Volume 1, 1991, Volume 2, 1992.  UTF-8 is
 *                described in Unicode Technical Report #4.
 * [US-ASCII]     Coded Character Set--7-bit American Standard Code for
 *                Information Interchange, ANSI X3.4-1986.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * xmlCharEncoding:
 *
 * Predefined values for some standard encodings.
 * Libxml does not do beforehand translation on UTF8 and ISOLatinX.
 * It also supports ASCII, ISO-8859-1, and UTF16 (LE and BE) by default.
 *
 * Anything else would have to be translated to UTF8 before being
 * given to the parser itself. The BOM for UTF16 and the encoding
 * declaration are looked at and a converter is looked for at that
 * point. If not found the parser stops here as asked by the XML REC. A
 * converter can be registered by the user using xmlRegisterCharEncodingHandler
 * but the current form doesn't allow stateful transcoding (a serious
 * problem agreed !). If iconv has been found it will be used
 * automatically and allow stateful transcoding, the simplest is then
 * to be sure to enable iconv and to provide iconv libs for the encoding
 * support needed.
 *
 * Note that the generic "UTF-16" is not a predefined value.  Instead, only
 * the specific UTF-16LE and UTF-16BE are present.
 */
/* No char encoding detected */
/* No char encoding detected */
/* UTF-8 */
/* UTF-16 little endian */
/* UTF-16 big endian */
/* UCS-4 little endian */
/* UCS-4 big endian */
/* EBCDIC uh! */
/* UCS-4 unusual ordering */
/* UCS-4 unusual ordering */
/* UCS-2 */
/* ISO-8859-1 ISO Latin 1 */
/* ISO-8859-2 ISO Latin 2 */
/* ISO-8859-3 */
/* ISO-8859-4 */
/* ISO-8859-5 */
/* ISO-8859-6 */
/* ISO-8859-7 */
/* ISO-8859-8 */
/* ISO-8859-9 */
/* ISO-2022-JP */
/* Shift_JIS */
/* EUC-JP */
/* pure ASCII */
/* *
 * xmlCharEncodingInputFunc:
 * @out:  a pointer to an array of bytes to store the UTF-8 result
 * @outlen:  the length of @out
 * @in:  a pointer to an array of chars in the original encoding
 * @inlen:  the length of @in
 *
 * Take a block of chars in the original encoding and try to convert
 * it to an UTF-8 block of chars out.
 *
 * Returns the number of bytes written, -1 if lack of space, or -2
 *     if the transcoding failed.
 * The value of @inlen after return is the number of octets consumed
 *     if the return value is positive, else unpredictiable.
 * The value of @outlen after return is the number of octets consumed.
 */
pub type xmlCharEncodingInputFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_uchar, _: *mut std::os::raw::c_int,
                                _: *const std::os::raw::c_uchar, _: *mut std::os::raw::c_int)
               -> std::os::raw::c_int>;
pub type xmlInputCloseCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type xmlInputReadCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *mut std::os::raw::c_char,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
/*
 * Summary: interfaces for tree manipulation
 * Description: this module describes the structures found in an tree resulting
 *              from an XML or HTML parsing, as well as the API provided for
 *              various processing on that tree
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Some of the basic types pointer to structures:
 */
/* xmlIO.h */
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
/* LIBXML_OUTPUT_ENABLED */
/* I18N conversions to UTF-8 */
/* Local buffer encoded in UTF-8 */
/* if encoder != NULL buffer for raw input */
/* -1=unknown, 0=not compressed, 1=compressed */
/* amount consumed from raw */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlOutputBuffer {
    pub context: *mut std::os::raw::c_void,
    pub writecallback: xmlOutputWriteCallback,
    pub closecallback: xmlOutputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub conv: xmlBufPtr,
    pub written: std::os::raw::c_int,
    pub error: std::os::raw::c_int,
}
/* *
 * xmlOutputCloseCallback:
 * @context:  an Output context
 *
 * Callback used in the I/O Output API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
pub type xmlOutputCloseCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
/*
 * Summary: interface for the I/O interfaces used by the parser
 * Description: interface for the I/O interfaces used by the parser
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Those are the functions and datatypes for the parser input
 * I/O structures.
 */
/* *
 * xmlInputMatchCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Input API to detect if the current handler
 * can provide input fonctionnalities for this resource.
 *
 * Returns 1 if yes and 0 if another Input module should be used
 */
/* *
 * xmlInputOpenCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Input API to open the resource
 *
 * Returns an Input context or NULL in case or error
 */
/* *
 * xmlInputReadCallback:
 * @context:  an Input context
 * @buffer:  the buffer to store data read
 * @len:  the length of the buffer in bytes
 *
 * Callback used in the I/O Input API to read the resource
 *
 * Returns the number of bytes read or -1 in case of error
 */
/* *
 * xmlInputCloseCallback:
 * @context:  an Input context
 *
 * Callback used in the I/O Input API to close the resource
 *
 * Returns 0 or -1 in case of error
 */
/*
 * Those are the functions and datatypes for the library output
 * I/O structures.
 */
/* *
 * xmlOutputMatchCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Output API to detect if the current handler
 * can provide output fonctionnalities for this resource.
 *
 * Returns 1 if yes and 0 if another Output module should be used
 */
/* *
 * xmlOutputOpenCallback:
 * @filename: the filename or URI
 *
 * Callback used in the I/O Output API to open the resource
 *
 * Returns an Output context or NULL in case or error
 */
/* *
 * xmlOutputWriteCallback:
 * @context:  an Output context
 * @buffer:  the buffer of data to write
 * @len:  the length of the buffer in bytes
 *
 * Callback used in the I/O Output API to write to the resource
 *
 * Returns the number of bytes written or -1 in case of error
 */
pub type xmlOutputWriteCallback
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: std::os::raw::c_int) -> std::os::raw::c_int>;
pub type xmlOutputBuffer = _xmlOutputBuffer;
pub type xmlOutputBufferPtr = *mut xmlOutputBuffer;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInput {
    pub buf: xmlParserInputBufferPtr,
    pub filename: *const std::os::raw::c_char,
    pub directory: *const std::os::raw::c_char,
    pub base: *const xmlChar,
    pub cur: *const xmlChar,
    pub end: *const xmlChar,
    pub length: std::os::raw::c_int,
    pub line: std::os::raw::c_int,
    pub col: std::os::raw::c_int,
    pub consumed: std::os::raw::c_ulong,
    pub free: xmlParserInputDeallocate,
    pub encoding: *const xmlChar,
    pub version: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub id: std::os::raw::c_int,
}
pub type xmlParserInputDeallocate
    =
    Option<unsafe extern "C" fn(_: *mut xmlChar) -> ()>;
/* parser.h */
pub type xmlParserInput = _xmlParserInput;
pub type xmlParserInputPtr = *mut xmlParserInput;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserCtxt {
    pub sax: *mut _xmlSAXHandler,
    pub userData: *mut std::os::raw::c_void,
    pub myDoc: xmlDocPtr,
    pub wellFormed: std::os::raw::c_int,
    pub replaceEntities: std::os::raw::c_int,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub standalone: std::os::raw::c_int,
    pub html: std::os::raw::c_int,
    pub input: xmlParserInputPtr,
    pub inputNr: std::os::raw::c_int,
    pub inputMax: std::os::raw::c_int,
    pub inputTab: *mut xmlParserInputPtr,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub record_info: std::os::raw::c_int,
    pub node_seq: xmlParserNodeInfoSeq,
    pub errNo: std::os::raw::c_int,
    pub hasExternalSubset: std::os::raw::c_int,
    pub hasPErefs: std::os::raw::c_int,
    pub external: std::os::raw::c_int,
    pub valid: std::os::raw::c_int,
    pub validate: std::os::raw::c_int,
    pub vctxt: xmlValidCtxt,
    pub instate: xmlParserInputState,
    pub token: std::os::raw::c_int,
    pub directory: *mut std::os::raw::c_char,
    pub name: *const xmlChar,
    pub nameNr: std::os::raw::c_int,
    pub nameMax: std::os::raw::c_int,
    pub nameTab: *mut *const xmlChar,
    pub nbChars: std::os::raw::c_long,
    pub checkIndex: std::os::raw::c_long,
    pub keepBlanks: std::os::raw::c_int,
    pub disableSAX: std::os::raw::c_int,
    pub inSubset: std::os::raw::c_int,
    pub intSubName: *const xmlChar,
    pub extSubURI: *mut xmlChar,
    pub extSubSystem: *mut xmlChar,
    pub space: *mut std::os::raw::c_int,
    pub spaceNr: std::os::raw::c_int,
    pub spaceMax: std::os::raw::c_int,
    pub spaceTab: *mut std::os::raw::c_int,
    pub depth: std::os::raw::c_int,
    pub entity: xmlParserInputPtr,
    pub charset: std::os::raw::c_int,
    pub nodelen: std::os::raw::c_int,
    pub nodemem: std::os::raw::c_int,
    pub pedantic: std::os::raw::c_int,
    pub _private: *mut std::os::raw::c_void,
    pub loadsubset: std::os::raw::c_int,
    pub linenumbers: std::os::raw::c_int,
    pub catalogs: *mut std::os::raw::c_void,
    pub recovery: std::os::raw::c_int,
    pub progressive: std::os::raw::c_int,
    pub dict: xmlDictPtr,
    pub atts: *mut *const xmlChar,
    pub maxatts: std::os::raw::c_int,
    pub docdict: std::os::raw::c_int,
    pub str_xml: *const xmlChar,
    pub str_xmlns: *const xmlChar,
    pub str_xml_ns: *const xmlChar,
    pub sax2: std::os::raw::c_int,
    pub nsNr: std::os::raw::c_int,
    pub nsMax: std::os::raw::c_int,
    pub nsTab: *mut *const xmlChar,
    pub attallocs: *mut std::os::raw::c_int,
    pub pushTab: *mut *mut std::os::raw::c_void,
    pub attsDefault: xmlHashTablePtr,
    pub attsSpecial: xmlHashTablePtr,
    pub nsWellFormed: std::os::raw::c_int,
    pub options: std::os::raw::c_int,
    pub dictNames: std::os::raw::c_int,
    pub freeElemsNr: std::os::raw::c_int,
    pub freeElems: xmlNodePtr,
    pub freeAttrsNr: std::os::raw::c_int,
    pub freeAttrs: xmlAttrPtr,
    pub lastError: xmlError,
    pub parseMode: xmlParserMode,
    pub nbentities: std::os::raw::c_ulong,
    pub sizeentities: std::os::raw::c_ulong,
    pub nodeInfo: *mut xmlParserNodeInfo,
    pub nodeInfoNr: std::os::raw::c_int,
    pub nodeInfoMax: std::os::raw::c_int,
    pub nodeInfoTab: *mut xmlParserNodeInfo,
    pub input_id: std::os::raw::c_int,
    pub sizeentcopy: std::os::raw::c_ulong,
}
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfo {
    pub node: *const _xmlNode,
    pub begin_pos: std::os::raw::c_ulong,
    pub begin_line: std::os::raw::c_ulong,
    pub end_pos: std::os::raw::c_ulong,
    pub end_line: std::os::raw::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNode {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub content: *mut xmlChar,
    pub properties: *mut _xmlAttr,
    pub nsDef: *mut xmlNs,
    pub psvi: *mut std::os::raw::c_void,
    pub line: std::os::raw::c_ushort,
    pub extra: std::os::raw::c_ushort,
}
/* *
 * xmlNs:
 *
 * An XML namespace.
 * Note that prefix == NULL is valid, it defines the default namespace
 * within the subtree (until overridden).
 *
 * xmlNsType is unified with xmlElementType.
 */
pub type xmlNs = _xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNs {
    pub next: *mut _xmlNs,
    pub type_0: xmlNsType,
    pub href: *const xmlChar,
    pub prefix: *const xmlChar,
    pub _private: *mut std::os::raw::c_void,
    pub context: *mut _xmlDoc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDoc {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *mut std::os::raw::c_char,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub compression: std::os::raw::c_int,
    pub standalone: std::os::raw::c_int,
    pub intSubset: *mut _xmlDtd,
    pub extSubset: *mut _xmlDtd,
    pub oldNs: *mut _xmlNs,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub ids: *mut std::os::raw::c_void,
    pub refs: *mut std::os::raw::c_void,
    pub URL: *const xmlChar,
    pub charset: std::os::raw::c_int,
    pub dict: *mut _xmlDict,
    pub psvi: *mut std::os::raw::c_void,
    pub parseFlags: std::os::raw::c_int,
    pub properties: std::os::raw::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDtd {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDoc,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub notations: *mut std::os::raw::c_void,
    pub elements: *mut std::os::raw::c_void,
    pub attributes: *mut std::os::raw::c_void,
    pub entities: *mut std::os::raw::c_void,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub pentities: *mut std::os::raw::c_void,
}
pub type xmlElementType = std::os::raw::c_uint;
pub const XML_DOCB_DOCUMENT_NODE: xmlElementType = 21;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
/* the validating regexp */
/* *
 * XML_LOCAL_NAMESPACE:
 *
 * A namespace declaration node.
 */
pub type xmlNsType = xmlElementType;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttr {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlAttr,
    pub prev: *mut _xmlAttr,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub atype: xmlAttributeType,
    pub psvi: *mut std::os::raw::c_void,
}
pub type xmlAttributeType = std::os::raw::c_uint;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = std::os::raw::c_uint;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
pub type xmlError = _xmlError;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlError {
    pub domain: std::os::raw::c_int,
    pub code: std::os::raw::c_int,
    pub message: *mut std::os::raw::c_char,
    pub level: xmlErrorLevel,
    pub file: *mut std::os::raw::c_char,
    pub line: std::os::raw::c_int,
    pub str1: *mut std::os::raw::c_char,
    pub str2: *mut std::os::raw::c_char,
    pub str3: *mut std::os::raw::c_char,
    pub int1: std::os::raw::c_int,
    pub int2: std::os::raw::c_int,
    pub ctxt: *mut std::os::raw::c_void,
    pub node: *mut std::os::raw::c_void,
}
pub type xmlErrorLevel = std::os::raw::c_uint;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
pub type xmlAttrPtr = *mut xmlAttr;
/* Hash table for param entities if any */
/* *
 * xmlAttr:
 *
 * An attribute on an XML node.
 */
pub type xmlAttr = _xmlAttr;
pub type xmlNodePtr = *mut xmlNode;
/* The line number if attr is not available */
/* *
 * xmlNode:
 *
 * A node in an XML tree.
 */
pub type xmlNode = _xmlNode;
pub type xmlHashTablePtr = *mut xmlHashTable;
pub type xmlHashTable = _xmlHashTable;
pub type xmlDictPtr = *mut xmlDict;
/*
 * Summary: string dictionary
 * Description: dictionary of reusable strings, just used to avoid allocation
 *         and freeing operations.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * The dictionary.
 */
pub type xmlDict = _xmlDict;
pub type xmlParserInputState = std::os::raw::c_int;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
/*
 * xmlValidCtxt:
 * An xmlValidCtxt is used for error reporting when validating.
 */
pub type xmlValidCtxt = _xmlValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlValidCtxt {
    pub userData: *mut std::os::raw::c_void,
    pub error: xmlValidityErrorFunc,
    pub warning: xmlValidityWarningFunc,
    pub node: xmlNodePtr,
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub finishDtd: std::os::raw::c_uint,
    pub doc: xmlDocPtr,
    pub valid: std::os::raw::c_int,
    pub vstate: *mut xmlValidState,
    pub vstateNr: std::os::raw::c_int,
    pub vstateMax: std::os::raw::c_int,
    pub vstateTab: *mut xmlValidState,
    pub am: xmlAutomataPtr,
    pub state: xmlAutomataStatePtr,
}
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
/* *
 * xmlAutomataStatePtr:
 *
 * A state int the automata description,
 */
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataPtr = *mut xmlAutomata;
pub type xmlAutomata = _xmlAutomata;
/*
 * Summary: The DTD validation
 * Description: API for the DTD handling and the validity checking
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Validation state added for non-determinist content model.
 */
pub type xmlValidState = _xmlValidState;
pub type xmlDocPtr = *mut xmlDoc;
/* *
 * xmlDoc:
 *
 * An XML document.
 */
pub type xmlDoc = _xmlDoc;
/* *
 * xmlValidityErrorFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity error is found. This is a message
 * oriented function similar to an *printf function.
 */
/* *
 * xmlValidityWarningFunc:
 * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
 *        but comes from ctxt->userData (which normally contains such
 *        a pointer); ctxt->userData can be changed by the user.
 * @msg:  the string to format *printf like vararg
 * @...:  remaining arguments to the format
 *
 * Callback called when a validity warning is found. This is a message
 * oriented function similar to an *printf function.
 */
pub type xmlValidityWarningFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type xmlValidityErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
/*
 * Summary: the core parser module
 * Description: Interfaces, constants and types related to the XML parser
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * XML_DEFAULT_VERSION:
 *
 * The default version of XML used: 1.0
 */
/* *
 * xmlParserInput:
 *
 * An xmlParserInput is an input flow for the XML processor.
 * Each entity parsed is associated an xmlParserInput (except the
 * few predefined ones). This is the case both for internal entities
 * - in which case the flow is already completely in memory - or
 * external entities - in which case we use the buf structure for
 * progressive reading and I18N conversions to the internal UTF-8 format.
 */
/* *
 * xmlParserInputDeallocate:
 * @str:  the string to deallocate
 *
 * Callback for freeing some parser input allocations.
 */
/* Input buffer */
/* UTF-8 encoded buffer */
/* The file analyzed, if any */
/* the directory/base of the file */
/* Base of the array to parse */
/* Current char being parsed */
/* end of the array to parse */
/* length if known */
/* Current line */
/* Current column */
/*
     * NOTE: consumed is only tested for equality in the parser code,
     *       so even if there is an overflow this should not give troubles
     *       for parsing very large instances.
     */
/* How many xmlChars already consumed */
/* function to deallocate the base */
/* the encoding string for entity */
/* the version string for entity */
/* Was that entity marked standalone */
/* an unique identifier for the entity */
/* *
 * xmlParserNodeInfo:
 *
 * The parser can be asked to collect Node informations, i.e. at what
 * place in the file they were detected.
 * NOTE: This is off by default and not very well tested.
 */
/* Position & line # that text that created the node begins & ends on */
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfoSeq {
    pub maximum: std::os::raw::c_ulong,
    pub length: std::os::raw::c_ulong,
    pub buffer: *mut xmlParserNodeInfo,
}
/* *
 * xmlParserInputState:
 *
 * The parser is now working also as a state based parser.
 * The recursive one use the state info for entities processing.
 */
/* nothing is to be parsed */
/* nothing has been parsed */
/* Misc* before int subset */
/* Within a processing instruction */
/* within some DTD content */
/* Misc* after internal subset */
/* within a comment */
/* within a start tag */
/* within the content */
/* within a CDATA section */
/* within a closing tag */
/* within an entity declaration */
/* within an entity value in a decl */
/* within an attribute value */
/* within a SYSTEM value */
/* the Misc* after the last end tag */
/* within an IGNORED section */
/* within a PUBLIC value */
/* *
 * XML_DETECT_IDS:
 *
 * Bit in the loadsubset context field to tell to do ID/REFs lookups.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
/* *
 * XML_COMPLETE_ATTRS:
 *
 * Bit in the loadsubset context field to tell to do complete the
 * elements attributes lists with the ones defaulted from the DTDs.
 * Use it to initialize xmlLoadExtDtdDefaultValue.
 */
/* *
 * XML_SKIP_IDS:
 *
 * Bit in the loadsubset context field to tell to not do ID/REFs registration.
 * Used to initialize xmlLoadExtDtdDefaultValue in some special cases.
 */
/* *
 * xmlParserMode:
 *
 * A parser can operate in various modes
 */
/* *
 * xmlParserCtxt:
 *
 * The parser context.
 * NOTE This doesn't completely define the parser state, the (current ?)
 *      design of the parser uses recursive function calls since this allow
 *      and easy mapping from the production rules of the specification
 *      to the actual code. The drawback is that the actual function call
 *      also reflect the parser state. However most of the parsing routines
 *      takes as the only argument the parser context pointer, so migrating
 *      to a state based parser for progressive parsing shouldn't be too hard.
 */
/* The SAX handler */
/* For SAX interface only, used by DOM build */
/* the document being built */
/* is the document well formed */
/* shall we replace entities ? */
/* the XML version string */
/* the declared encoding, if any */
/* standalone document */
/* an HTML(1)/Docbook(2) document
                                       * 3 is HTML after <head>
                                       * 10 is HTML after <body>
                                       */
/* Input stream stack */
/* Current input stream */
/* Number of current input streams */
/* Max number of input streams */
/* stack of inputs */
/* Node analysis stack only used for DOM building */
/* Current parsed Node */
/* Depth of the parsing stack */
/* Max depth of the parsing stack */
/* array of nodes */
/* Whether node info should be kept */
/* info about each node parsed */
/* error code */
/* reference and external subset */
/* the internal subset has PE refs */
/* are we parsing an external entity */
/* is the document valid */
/* shall we try to validate ? */
/* The validity context */
/* current type of input */
/* next char look-ahead */
/* the data directory */
/* Node name stack */
/* Current parsed Node */
/* Depth of the parsing stack */
/* Max depth of the parsing stack */
/* array of nodes */
/* number of xmlChar processed */
/* used by progressive parsing lookup */
/* ugly but ... */
/* SAX callbacks are disabled */
/* Parsing is in int 1/ext 2 subset */
/* name of subset */
/* URI of external subset */
/* SYSTEM ID of external subset */
/* xml:space values */
/* Should the parser preserve spaces */
/* Depth of the parsing stack */
/* Max depth of the parsing stack */
/* array of space infos */
/* to prevent entity substitution loops */
/* used to check entities boundaries */
/* encoding of the in-memory content
				         actually an xmlCharEncoding */
/* Those two fields are there to */
/* Speed up large node parsing */
/* signal pedantic warnings */
/* For user data, libxml won't touch it */
/* should the external subset be loaded */
/* set line number in element content */
/* document's own catalog */
/* run in recovery mode */
/* is this a progressive parsing */
/* dictionary for the parser */
/* array for the attributes callbacks */
/* the size of the array */
/* use strings from dict to build tree */
/*
     * pre-interned strings
     */
/*
     * Everything below is used only by the new SAX mode
     */
/* operating in the new SAX mode */
/* the number of inherited namespaces */
/* the size of the arrays */
/* the array of prefix/namespace name */
/* which attribute were allocated */
/* array of data for push */
/* defaulted attributes if any */
/* non-CDATA attributes if any */
/* is the document XML Nanespace okay */
/* Extra options */
/*
     * Those fields are needed only for treaming parsing so far
     */
/* Use dictionary names for the tree */
/* number of freed element nodes */
/* List of freed element nodes */
/* number of freed attributes nodes */
/* List of freed attributes nodes */
/*
     * the complete error informations for the last error.
     */
/* the parser mode */
/* number of entities references */
/* size of parsed entities */
/* for use by HTML non-recursive parser */
/* Current NodeInfo */
/* Depth of the parsing stack */
/* Max depth of the parsing stack */
/* array of nodeInfos */
/* we need to label inputs */
/* volume of entity copy */
/* *
 * xmlSAXLocator:
 *
 * A SAX Locator.
 */
/* *
 * xmlSAXHandler:
 *
 * A SAX handler is bunch of callbacks called by the parser when processing
 * of the input generate data or structure informations.
 */
/* *
 * resolveEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * Callback:
 * The entity loader, to control the loading of external entities,
 * the application can either:
 *    - override this resolveEntity() callback in the SAX block
 *    - or better use the xmlSetExternalEntityLoader() function to
 *      set up it's own entity resolution routine
 *
 * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
 */
/* *
 * internalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on internal subset declaration.
 */
/* *
 * externalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the root element name
 * @ExternalID:  the external ID
 * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 *
 * Callback on external subset declaration.
 */
/* *
 * getEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get an entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
/* *
 * getParameterEntitySAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The entity name
 *
 * Get a parameter entity by name.
 *
 * Returns the xmlEntityPtr if found.
 */
/* *
 * entityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the entity name
 * @type:  the entity type
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @content: the entity value (without processing).
 *
 * An entity definition has been parsed.
 */
/* *
 * notationDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the notation
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 *
 * What to do when a notation declaration has been parsed.
 */
/* *
 * attributeDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @elem:  the name of the element
 * @fullname:  the attribute name
 * @type:  the attribute type
 * @def:  the type of default value
 * @defaultValue: the attribute default value
 * @tree:  the tree of enumerated value set
 *
 * An attribute definition has been parsed.
 */
/* *
 * elementDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  the element name
 * @type:  the element type
 * @content: the element value tree
 *
 * An element definition has been parsed.
 */
/* *
 * unparsedEntityDeclSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name: The name of the entity
 * @publicId: The public ID of the entity
 * @systemId: The system ID of the entity
 * @notationName: the name of the notation
 *
 * What to do when an unparsed entity declaration is parsed.
 */
/* *
 * setDocumentLocatorSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @loc: A SAX Locator
 *
 * Receive the document locator at startup, actually xmlDefaultSAXLocator.
 * Everything is available on the context, so this is useless in our case.
 */
/* *
 * startDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document start being processed.
 */
/* *
 * endDocumentSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Called when the document end has been detected.
 */
/* *
 * startElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name, including namespace prefix
 * @atts:  An array of name/value attributes pairs, NULL terminated
 *
 * Called when an opening tag has been processed.
 */
/* *
 * endElementSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The element name
 *
 * Called when the end of an element has been detected.
 */
/* *
 * attributeSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The attribute name, including namespace prefix
 * @value:  The attribute value
 *
 * Handle an attribute that has been read by the parser.
 * The default handling is to convert the attribute into an
 * DOM subtree and past it in a new xmlAttr element added to
 * the element.
 */
/* *
 * referenceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @name:  The entity name
 *
 * Called when an entity reference is detected.
 */
/* *
 * charactersSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some chars from the parser.
 */
/* *
 * ignorableWhitespaceSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @ch:  a xmlChar string
 * @len: the number of xmlChar
 *
 * Receiving some ignorable whitespaces from the parser.
 * UNUSED: by default the DOM building will use characters.
 */
/* *
 * processingInstructionSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @target:  the target name
 * @data: the PI data's
 *
 * A processing instruction has been parsed.
 */
/* *
 * commentSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  the comment content
 *
 * A comment has been parsed.
 */
/* *
 * cdataBlockSAXFunc:
 * @ctx:  the user data (XML parser context)
 * @value:  The pcdata content
 * @len:  the block length
 *
 * Called when a pcdata block has been parsed.
 */
/* *
 * warningSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format a warning messages, callback.
 */
/* *
 * errorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format an error messages, callback.
 */
/* *
 * fatalErrorSAXFunc:
 * @ctx:  an XML parser context
 * @msg:  the message to display/transmit
 * @...:  extra parameters for the message display
 *
 * Display and format fatal error messages, callback.
 * Note: so far fatalError() SAX callbacks are not used, error()
 *       get all the callbacks for errors.
 */
/* *
 * isStandaloneSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Is this document tagged standalone?
 *
 * Returns 1 if true
 */
/* *
 * hasInternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an internal subset.
 *
 * Returns 1 if true
 */
/* *
 * hasExternalSubsetSAXFunc:
 * @ctx:  the user data (XML parser context)
 *
 * Does this document has an external subset?
 *
 * Returns 1 if true
 */
/* ***********************************************************************
 *									*
 *			The SAX version 2 API extensions		*
 *									*
 ************************************************************************/
/* *
 * XML_SAX2_MAGIC:
 *
 * Special constant found in SAX2 blocks initialized fields
 */
/* *
 * startElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 * @nb_namespaces:  number of namespace definitions on that node
 * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
 * @nb_attributes:  the number of attributes on that node
 * @nb_defaulted:  the number of defaulted attributes. The defaulted
 *                  ones are at the end of the array
 * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
 *               attribute values.
 *
 * SAX2 callback when an element start has been detected by the parser.
 * It provides the namespace informations for the element, as well as
 * the new namespace declarations on the element.
 */
/* *
 * endElementNsSAX2Func:
 * @ctx:  the user data (XML parser context)
 * @localname:  the local name of the element
 * @prefix:  the element namespace prefix if available
 * @URI:  the element namespace name if available
 *
 * SAX2 callback when an element end has been detected by the parser.
 * It provides the namespace informations for the element.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandler {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: std::os::raw::c_uint,
    pub _private: *mut std::os::raw::c_void,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub serror: xmlStructuredErrorFunc,
}
/*
 * Summary: error handling
 * Description: the API used to report errors
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlErrorLevel:
 *
 * Indicates the level of an error
 */
/* A simple warning */
/* A recoverable error */
/* A fatal error */
/* *
 * xmlErrorDomain:
 *
 * Indicates where an error may have come from
 */
/* The XML parser */
/* The tree module */
/* The XML Namespace module */
/* The XML DTD validation with parser context*/
/* The HTML parser */
/* The memory allocator */
/* The serialization code */
/* The Input/Output stack */
/* The FTP module */
/* The HTTP module */
/* The XInclude processing */
/* The XPath module */
/* The XPointer module */
/* The regular expressions module */
/* The W3C XML Schemas Datatype module */
/* The W3C XML Schemas parser module */
/* The W3C XML Schemas validation module */
/* The Relax-NG parser module */
/* The Relax-NG validator module */
/* The Catalog module */
/* The Canonicalization module */
/* The XSLT engine from libxslt */
/* The XML DTD validation with valid context */
/* The error checking module */
/* The xmlwriter module */
/* The dynamically loaded module module*/
/* The module handling character conversion */
/* The Schematron validator module */
/* The buffers module */
/* The URI module */
/* *
 * xmlError:
 *
 * An XML Error instance.
 */
/* What part of the library raised this error */
/* The error code, e.g. an xmlParserError */
/* human-readable informative error message */
/* how consequent is the error */
/* the filename */
/* the line number if available */
/* extra string information */
/* extra string information */
/* extra string information */
/* extra number information */
/* error column # or 0 if N/A (todo: rename field when we would brk ABI) */
/* the parser context if available */
/* the node in the tree */
/* *
 * xmlParserError:
 *
 * This is an error that the XML (or HTML) parser can generate
 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* 11 */
/* 12 */
/* 13 */
/* 14 */
/* 15 */
/* 16 */
/* 17 */
/* 18 */
/* 19 */
/* 20 */
/* 21 */
/* 22 */
/* 23 */
/* 24 */
/* 25 */
/* 26 */
/* 27 */
/* 28 */
/* 29 */
/* 30 */
/* 31 */
/* 32 */
/* 33 */
/* 34 */
/* 35 */
/* 36 */
/* 37 */
/* 38 */
/* 39 */
/* 40 */
/* 41 */
/* 42 */
/* 43 */
/* 44 */
/* 45 */
/* 46 */
/* 47 */
/* 48 */
/* 49 */
/* 50 */
/* 51 */
/* 52 */
/* 53 */
/* 54 */
/* 55 */
/* 56 */
/* 57 */
/* 58 */
/* 59 */
/* 60 */
/* 61 */
/* 62 */
/* 63 */
/* 64 */
/* 65 */
/* 66 */
/* 67 */
/* 68 */
/* 69 */
/* 70 */
/* 71 */
/* 72 */
/* 73 */
/* 74 */
/* 75 */
/* 76 */
/* 77 */
/* 78 */
/* 79 */
/* 80 */
/* 81 */
/* 82 */
/* 83 */
/* 84 */
/* 85 */
/* 86 */
/* 87 */
/* 88 */
/* 89 */
/* 90 */
/* 91 */
/* 92 */
/* 93 */
/* 94 */
/* 95 */
/* 96 */
/* 97 */
/* 98 */
/* 99 */
/* 100 */
/* 101 */
/* 102 */
/* 103 */
/* 104 */
/* 105 */
/* 106 */
/* 107 */
/* 108 */
/* 109 */
/* 110 */
/* 111 */
/* 201 */
/* 202 */
/* 203 */
/* 204 */
/* 205 */
/* 501 */
/* 502 */
/* 503 */
/* 504 */
/* 505 */
/* 506 */
/* 507 */
/* 508 */
/* 509 */
/* 510 */
/* 511 */
/* 512 */
/* 513 */
/* 514 */
/* 515 */
/* 516 */
/* 517 */
/* 518 */
/* 519 */
/* 520 */
/* 521 */
/* 522 */
/* 523 */
/* 524 */
/* 525 */
/* 526 */
/* 527 */
/* 528 */
/* 529 */
/* 530 */
/* 531 */
/* 532 */
/* 533 */
/* 534 */
/* 535 */
/* 536 */
/* 537 */
/* 538 */
/* 539 */
/* 540 */
/* 541 */
/* 801 */
/* 1001 */
/* 1002 */
/* 1003 */
/* 1004 */
/* 1005 */
/* 1006 */
/* 1007 */
/* 1008 */
/* 1009 */
/* 1010 */
/* 1011 */
/* 1012 */
/* 1013 */
/* 1014 */
/* 1015 */
/* 1016 */
/* 1017 */
/* 1018 */
/* 1019 */
/* 1020 */
/* 1021 */
/* 1022 */
/* 1023 */
/* 1024 */
/* 1025 */
/* 1026 */
/* 1027 */
/* 1028 */
/* 1029 */
/* 1030 */
/* 1031 */
/* 1032 */
/* 1033 */
/* 1034 */
/* 1035 */
/* 1036 */
/* 1037 */
/* 1038 */
/* 1039 */
/* 1040 */
/* 1041 */
/* 1042 */
/* 1043 */
/* 1044 */
/* 1045 */
/* 1046 */
/* 1047 */
/* 1048 */
/* 1049 */
/* 1050 */
/* 1051 */
/* 1052 */
/* 1053 */
/* 1054 */
/* 1055 */
/* 1056 */
/* 1057 */
/* 1058 */
/* 1059 */
/* 1060 */
/* 1061 */
/* 1062 */
/* 1063 */
/* 1064 */
/* 1065 */
/* 1066 */
/* 1067 */
/* 1068 */
/* 1069 */
/* 1070 */
/* 1071 */
/* 1072 */
/* 1073 */
/* 1074 */
/* 1075 */
/* 1076 */
/* 1077 */
/* 1078 */
/* 1079 */
/* 1080 */
/* 1081 */
/* 1082 */
/* 1083 */
/* 1084 */
/* 1085 */
/* 1086 */
/* 1087 */
/* 1088 */
/* 1089 */
/* 1090 */
/* 1091 */
/* 1092 */
/* 1093 */
/* 1094 */
/* 1095 */
/* 1096 */
/* 1097 */
/* 1098 */
/* 1099 */
/* 1100 */
/* 1101 */
/* 1102 */
/* 1103 */
/* 1104 */
/* 1105 */
/* 1106 */
/* 1107 */
/* 1108 */
/* 1109 */
/* 1110 */
/* 1111 */
/* 1112 */
/* 1113 */
/* 1114 */
/* 1115 */
/* 1116 */
/* 1117 */
/* 1118 */
/* 1119 */
/* 1120 */
/* 1121 */
/* 1122 */
/* 1201 */
/* 1202 */
/* 1203 */
/* 1204 */
/* 1205 */
/* 1206 */
/* 1207 */
/* 1208 */
/* 1209 */
/* 1210 */
/* 1211 */
/* 1212 */
/* 1213 */
/* 1214 */
/* 1215 */
/* 1216 */
/* 1217 */
/* 1218 */
/* 1219 */
/* 1220 */
/* 1221 */
/* 1301 */
/* 1302 */
/* 1303 */
/* 1401 */
/* 1402 */
/* 1403 */
/* 1501 */
/* 1502 */
/* 1503 */
/* 1504 */
/* 1505 */
/* 1506 */
/* 1507 */
/* 1508 */
/* 1509 */
/* 1510 */
/* 1511 */
/* 1512 */
/* 1513 */
/* 1514 */
/* 1515 */
/* 1516 */
/* 1517 */
/* 1518 */
/* 1519 */
/* 1520 */
/* 1521 */
/* 1522 */
/* 1523 */
/* 1524 */
/* 1525 */
/* 1526 */
/* 1527 */
/* 1528 */
/* 1529 */
/* 1530 */
/* 1531 */
/* 1532 */
/* 1533 */
/* 1534 */
/* 1535 */
/* 1536 */
/* 1537 */
/* 1538 */
/* 1539 */
/* 1540 */
/* 1541 */
/* 1542 */
/* 1543 */
/* 1544 */
/* 1545 */
/* 1546 */
/* 1547 */
/* 1548 */
/* 1549 */
/* 1550 */
/* 1551 */
/* 1552 */
/* 1553 */
/* 1554 */
/* 1555 */
/* 1556 */
/* 1601 */
/* 1602 */
/* 1603 */
/* 1604 */
/* 1605 */
/* 1606 */
/* 1607 */
/* 1608 */
/* 1609 */
/* 1610 */
/* 1611 */
/* 1612 */
/* 1613 */
/* 1614 */
/* 1615 */
/* 1616 */
/* 1617 */
/* 1618 */
/* 1651 */
/* 1652 */
/* 1653 */
/* 1654 */
/* 1701 */
/* 1702 */
/* 1703 */
/* 1704 */
/* 1705 */
/* 1706 */
/* 1707 */
/* 1708 */
/* 1709 */
/* 1710 */
/* 1711 */
/* 1712 */
/* 1713 */
/* 1714 */
/* 1715 */
/* 1716 */
/* 1717 */
/* 1718 */
/* 1719 */
/* 1720 */
/* 1721 */
/* 1722 */
/* 1723 */
/* 1724 */
/* 1725 */
/* 1726 */
/* 1727 */
/* 1728 */
/* 1729 */
/* 1730 */
/* 1731 */
/* 1732 */
/* 1733 */
/* 1734 */
/* 1735 */
/* 1736 */
/* 1737 */
/* 1738 */
/* 1739 */
/* 1740 */
/* 1741 */
/* 1742 */
/* 1743 */
/* 1744 */
/* 1745 */
/* 1746 */
/* 1747 */
/* 1748 */
/* 1749 */
/* 1750 */
/* 1751 */
/* 1752 */
/* 1753 */
/* 1754 */
/* 1755 */
/* 1756 */
/* 1757 */
/* 1758 */
/* 1759 */
/* 1760 */
/* 1761 */
/* 1762 */
/* 1763 */
/* 1764 */
/* 1765 */
/* 1766 */
/* 1767 */
/* 1768 */
/* 1769 */
/* 1770 */
/* 1771 */
/* 1772 */
/* 1773 */
/* 1774 */
/* 1775 */
/* 1776 */
/* 1777 */
/* 1778 */
/* 1779 */
/* 1780 */
/* 1781 */
/* 1782 */
/* 1783 */
/* 1784 */
/* 1785 */
/* 1786 */
/* 1787 */
/* 1788 */
/* 1789 */
/* 1790 */
/* 1791 */
/* 1792 */
/* 1793 */
/* 1794 */
/* 1795 */
/* 1796 */
/* 1797 */
/* 1798 */
/* 1799 */
/* 1800 */
/* 1802 */
/* 1803 */
/* 1804 */
/* 1805 */
/* 1806 */
/* 1807 */
/* 1808 */
/* 1809 */
/* 1810 */
/* 1811 */
/* 1812 */
/* 1813 */
/* 1814 */
/* 1815 */
/* 1816 */
/* 1817 */
/* 1818 */
/* 1819 */
/* 1820 */
/* 1821 */
/* 1822 */
/* 1823 */
/* 1824 */
/* 1825 */
/* 1826 */
/* 1827 */
/* 1828 */
/* 1829 */
/* 1830 */
/* 1831 */
/* 1832 */
/* 1833 */
/* 1834 */
/* 1835 */
/* 1836 */
/* 1837 */
/* 1838 */
/* 1839 */
/* 1840 */
/* 1841 */
/* 1842 */
/* 1843 */
/* 1844 */
/* 1845 */
/* 1846 */
/* 1847 */
/* 1848 */
/* 1849 */
/* 1850 */
/* 1851 */
/* 1852 */
/* 1853 */
/* 1854 */
/* 1855 */
/* 1856 */
/* 1857 */
/* 1858 */
/* 1859 */
/* 1860 */
/* 1861 */
/* 1862 */
/* 1863 */
/* 1864 */
/* 1865 */
/* 1866 */
/* 1867 */
/* 1868 */
/* 1869 */
/* 1870 */
/* 1871 */
/* 1872 */
/* 1873 */
/* 1874 */
/* 1875 */
/* 1876 */
/* 1877 */
/* 1878 */
/* 1879 */
/* 1901 */
/* 1902 */
/* 1903 */
/* 1951 */
/* 1952 */
/* 1953 */
/* 1954 */
/* 1955 */
/* 2001 */
/* 2002 */
/* 2003 */
/* 2021 */
/* 2022 */
/* 3001 */
/* 3002 */
/* 3003 */
/* 3004 */
/* 3005 */
/* 3006 */
/* 3007 */
/* 3008 */
/* 3009 */
/* 3010 */
/* 3011 */
/* 3012 */
/* 3013 */
/* 3014 */
/* 3015 */
/* 3016 */
/* 3017 */
/* 3018 */
/* 3019 */
/* 3020 */
/* 3021 */
/* 3022 */
/* 3023 */
/* 3024 */
/* 3025 */
/* 3026 */
/* 3027 */
/* 3028 */
/* 3029 */
/* 3030 */
/* 3031 */
/* 3032 */
/* 3033 */
/* 3034 */
/* 3035 */
/* 3036 */
/* 3037 */
/* 3038 */
/* 3039 */
/* 3040 */
/* 3041 */
/* 3042 */
/* 3043 */
/* 3044 */
/* 3045 */
/* 3046 */
/* 3047 */
/* 3048 */
/* 3049 */
/* 3050 */
/* 3051 */
/* 3052 */
/* 3053 */
/* 3054 */
/* 3055 */
/* 3056 */
/* 3057 */
/* 3058 */
/* 3059 */
/* 3060 */
/* 3061 */
/* 3062 */
/* 3063 */
/* 3064 */
/* 3065 */
/* 3066 */
/* 3067 */
/* 3068 */
/* 3069 non-W3C */
/* 3070 non-W3C */
/* 3071 */
/* 3072 */
/* 3073 */
/* 3074 */
/* 3075 */
/* 3076 */
/* 3077 */
/* 3078 */
/* 3079 */
/* 3080 */
/* 3081 */
/* 3082 */
/* 3083 */
/* 3084 */
/* 3085 */
/* 3085 */
/* 3086 */
/* 3087 */
/* 3088 */
/* 3089 */
/* 3090 */
/* 4000 */
/* 4900 */
/* 4901 */
/* 5001 */
/* 5002 */
/* 5003 */
/* 5004 */
/* 5005 */
/* 5006 */
/* 5007 */
/* 5008 */
/* 5009 */
/* 5010 */
/* 5011 */
/* 5012 */
/* 5013 */
/* 5014 */
/* 5015 */
/* 5016 */
/* 5017 */
/* 5018 */
/* 5019 */
/* 5020 */
/* 5021 */
/* 5022 */
/* 5023 */
/* 5024 */
/* 5025 */
/* 5026 */
/* 5027 */
/* 5028 */
/* 5029 */
/* 5030 */
/* 5031 */
/* 5032 */
/* 5033 */
/* 5034 */
/* 5035 */
/* 5036 */
/* 5037 */
/* 6001 */
/* 6002 */
/* 6003 */
/* 6004 */
/* *
 * xmlGenericErrorFunc:
 * @ctx:  a parsing context
 * @msg:  the message
 * @...:  the extra arguments of the varags to format the message
 *
 * Signature of the function to use when there is an error and
 * no parsing or validity context available .
 */
/* *
 * xmlStructuredErrorFunc:
 * @userData:  user provided data for the error callback
 * @error:  the error being raised.
 *
 * Signature of the function to use when there is an error and
 * the module handles the new error reporting mechanism.
 */
pub type xmlStructuredErrorFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlErrorPtr) -> ()>;
pub type xmlErrorPtr = *mut xmlError;
pub type endElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type startElementNsSAX2Func
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *mut *const xmlChar,
                                _: std::os::raw::c_int, _: std::os::raw::c_int,
                                _: *mut *const xmlChar) -> ()>;
pub type externalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type cdataBlockSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type getParameterEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type xmlEntityPtr = *mut xmlEntity;
/* entities.h */
pub type xmlEntity = _xmlEntity;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEntity {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub orig: *mut xmlChar,
    pub content: *mut xmlChar,
    pub length: std::os::raw::c_int,
    pub etype: xmlEntityType,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub nexte: *mut _xmlEntity,
    pub URI: *const xmlChar,
    pub owner: std::os::raw::c_int,
    pub checked: std::os::raw::c_int,
}
pub type xmlEntityType = std::os::raw::c_uint;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub type fatalErrorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type errorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type warningSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_char,
                                _: ...) -> ()>;
pub type commentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type processingInstructionSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type ignorableWhitespaceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type charactersSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int) -> ()>;
pub type referenceSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type endElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> ()>;
pub type startElementSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *mut *const xmlChar) -> ()>;
pub type endDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type startDocumentSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type setDocumentLocatorSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: xmlSAXLocatorPtr)
               -> ()>;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXLocator = _xmlSAXLocator;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXLocator {
    pub getPublicId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getSystemId: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                -> *const xmlChar>,
    pub getLineNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                  -> std::os::raw::c_int>,
    pub getColumnNumber: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                                    -> std::os::raw::c_int>,
}
pub type unparsedEntityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar,
                                _: *const xmlChar) -> ()>;
pub type elementDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: xmlElementContentPtr)
               -> ()>;
pub type xmlElementContentPtr = *mut xmlElementContent;
/* *
 * xmlElementContent:
 *
 * An XML Element content as stored after parsing an element definition
 * in a DTD.
 */
pub type xmlElementContent = _xmlElementContent;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElementContent {
    pub type_0: xmlElementContentType,
    pub ocur: xmlElementContentOccur,
    pub name: *const xmlChar,
    pub c1: *mut _xmlElementContent,
    pub c2: *mut _xmlElementContent,
    pub parent: *mut _xmlElementContent,
    pub prefix: *const xmlChar,
}
pub type xmlElementContentOccur = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = std::os::raw::c_uint;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub type attributeDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: std::os::raw::c_int,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: xmlEnumerationPtr) -> ()>;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
/* *
 * xmlEnumeration:
 *
 * List structure used when there is an enumeration in DTDs.
 */
pub type xmlEnumeration = _xmlEnumeration;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEnumeration {
    pub next: *mut _xmlEnumeration,
    pub name: *const xmlChar,
}
pub type notationDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type entityDeclSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: std::os::raw::c_int, _: *const xmlChar,
                                _: *const xmlChar, _: *mut xmlChar) -> ()>;
pub type getEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar)
               -> xmlEntityPtr>;
pub type resolveEntitySAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlParserInputPtr>;
pub type hasExternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type hasInternalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type isStandaloneSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> std::os::raw::c_int>;
pub type internalSubsetSAXFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar, _: *const xmlChar) -> ()>;
pub type xmlParserCtxt = _xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
pub type xmlAttributeDefault = std::os::raw::c_uint;
pub const XML_ATTRIBUTE_FIXED: xmlAttributeDefault = 4;
pub const XML_ATTRIBUTE_IMPLIED: xmlAttributeDefault = 3;
pub const XML_ATTRIBUTE_REQUIRED: xmlAttributeDefault = 2;
pub const XML_ATTRIBUTE_NONE: xmlAttributeDefault = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttribute {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub nexth: *mut _xmlAttribute,
    pub atype: xmlAttributeType,
    pub def: xmlAttributeDefault,
    pub defaultValue: *const xmlChar,
    pub tree: xmlEnumerationPtr,
    pub prefix: *const xmlChar,
    pub elem: *const xmlChar,
}
/* Enumeration name */
/* *
 * xmlAttribute:
 *
 * An Attribute declaration in a DTD.
 */
pub type xmlAttribute = _xmlAttribute;
pub type xmlAttributePtr = *mut xmlAttribute;
pub type xmlElementTypeVal = std::os::raw::c_uint;
pub const XML_ELEMENT_TYPE_ELEMENT: xmlElementTypeVal = 4;
pub const XML_ELEMENT_TYPE_MIXED: xmlElementTypeVal = 3;
pub const XML_ELEMENT_TYPE_ANY: xmlElementTypeVal = 2;
pub const XML_ELEMENT_TYPE_EMPTY: xmlElementTypeVal = 1;
pub const XML_ELEMENT_TYPE_UNDEFINED: xmlElementTypeVal = 0;
pub type xmlRegexp = _xmlRegexp;
pub type xmlRegexpPtr = *mut xmlRegexp;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElement {
    pub _private: *mut std::os::raw::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub etype: xmlElementTypeVal,
    pub content: xmlElementContentPtr,
    pub attributes: xmlAttributePtr,
    pub prefix: *const xmlChar,
    pub contModel: xmlRegexpPtr,
}
/* *
 * xmlElement:
 *
 * An XML Element declaration from a DTD.
 */
pub type xmlElement = _xmlElement;
pub type xmlElementPtr = *mut xmlElement;
pub type xmlNsPtr = *mut xmlNs;
/* normally an xmlDoc */
/* *
 * xmlDtd:
 *
 * An XML DTD, as defined by <!DOCTYPE ... There is actually one for
 * the internal subset and for the external subset.
 */
pub type xmlDtd = _xmlDtd;
pub type xmlDtdPtr = *mut xmlDtd;
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */
/* *
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/* *
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
pub type xmlValidCtxtPtr = *mut xmlValidCtxt;
pub type xmlSchemaAnnotPtr = *mut xmlSchemaAnnot;
pub type xmlSchemaAnnot = _xmlSchemaAnnot;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnot {
    pub next: *mut _xmlSchemaAnnot,
    pub content: xmlNodePtr,
}
/*
* TODO: Actually all those flags used for the schema should sit
* on the schema parser context, since they are used only
* during parsing an XML schema document, and not available
* on the component level as per spec.
*/
/* *
 * XML_SCHEMAS_QUALIF_ELEM:
 *
 * Reflects elementFormDefault == qualified in
 * an XML schema document.
 */
/* *
 * XML_SCHEMAS_QUALIF_ATTR:
 *
 * Reflects attributeFormDefault == qualified in
 * an XML schema document.
 */
/* *
 * XML_SCHEMAS_FINAL_DEFAULT_EXTENSION:
 *
 * the schema has "extension" in the set of finalDefault.
 */
/* *
 * XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION:
 *
 * the schema has "restriction" in the set of finalDefault.
 */
/* *
 * XML_SCHEMAS_FINAL_DEFAULT_LIST:
 *
 * the cshema has "list" in the set of finalDefault.
 */
/* *
 * XML_SCHEMAS_FINAL_DEFAULT_UNION:
 *
 * the schema has "union" in the set of finalDefault.
 */
/* *
 * XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION:
 *
 * the schema has "extension" in the set of blockDefault.
 */
/* *
 * XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION:
 *
 * the schema has "restriction" in the set of blockDefault.
 */
/* *
 * XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION:
 *
 * the schema has "substitution" in the set of blockDefault.
 */
/* *
 * XML_SCHEMAS_INCLUDING_CONVERT_NS:
 *
 * the schema is currently including an other schema with
 * no target namespace.
 */
/* *
 * _xmlSchema:
 *
 * A Schemas definition
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchema {
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub version: *const xmlChar,
    pub id: *const xmlChar,
    pub doc: xmlDocPtr,
    pub annot: xmlSchemaAnnotPtr,
    pub flags: std::os::raw::c_int,
    pub typeDecl: xmlHashTablePtr,
    pub attrDecl: xmlHashTablePtr,
    pub attrgrpDecl: xmlHashTablePtr,
    pub elemDecl: xmlHashTablePtr,
    pub notaDecl: xmlHashTablePtr,
    pub schemasImports: xmlHashTablePtr,
    pub _private: *mut std::os::raw::c_void,
    pub groupDecl: xmlHashTablePtr,
    pub dict: xmlDictPtr,
    pub includes: *mut std::os::raw::c_void,
    pub preserve: std::os::raw::c_int,
    pub counter: std::os::raw::c_int,
    pub idcDef: xmlHashTablePtr,
    pub volatiles: *mut std::os::raw::c_void,
}
/*
    XML_SCHEMA_VAL_XSI_ASSEMBLE			= 1<<1,
	* assemble schemata using
	* xsi:schemaLocation and
	* xsi:noNamespaceSchemaLocation
*/
/* *
 * The schemas related types are kept internal
 */
pub type xmlSchema = _xmlSchema;
pub type xmlSchemaPtr = *mut xmlSchema;
/* *
 * A schemas validation context
 */
pub type xmlSchemaParserCtxt = _xmlSchemaParserCtxt;
pub type xmlSchemaParserCtxtPtr = *mut xmlSchemaParserCtxt;
pub type xmlSchemaValidCtxt = _xmlSchemaValidCtxt;
pub type xmlSchemaValidCtxtPtr = *mut xmlSchemaValidCtxt;
/*
 * Summary: interface for an HTML 4.0 non-verifying parser
 * Description: this module implements an HTML 4.0 non-verifying parser
 *              with API compatible with the XML parser ones. It should
 *              be able to parse "real world" HTML, even if severely
 *              broken from a specification point of view.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * Most of the back-end structures from XML and HTML are shared.
 */
pub type htmlParserCtxtPtr = xmlParserCtxtPtr;
pub type htmlDocPtr = xmlDocPtr;
pub type htmlNodePtr = xmlNodePtr;
pub type xmlCatalog = _xmlCatalog;
pub type xmlCatalogPtr = *mut xmlCatalog;
/* *
 * Summary: library of generic URI related routines
 * Description: library of generic URI related routines
 *              Implements RFC 2396
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * xmlURI:
 *
 * A parsed URI reference. This is a struct containing the various fields
 * as described in RFC 2396 but separated for further processing.
 *
 * Note: query is a deprecated field which is incorrectly unescaped.
 * query_raw takes precedence over query if the former is set.
 * See: http://mail.gnome.org/archives/xml/2007-April/thread.html#00127
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlURI {
    pub scheme: *mut std::os::raw::c_char,
    pub opaque: *mut std::os::raw::c_char,
    pub authority: *mut std::os::raw::c_char,
    pub server: *mut std::os::raw::c_char,
    pub user: *mut std::os::raw::c_char,
    pub port: std::os::raw::c_int,
    pub path: *mut std::os::raw::c_char,
    pub query: *mut std::os::raw::c_char,
    pub fragment: *mut std::os::raw::c_char,
    pub cleanup: std::os::raw::c_int,
    pub query_raw: *mut std::os::raw::c_char,
}
pub type xmlURI = _xmlURI;
pub type xmlURIPtr = *mut xmlURI;
/*
 * Summary: XML Path Language implementation
 * Description: API for the XML Path Language implementation
 *
 * XML Path Language implementation
 * XPath is a language for addressing parts of an XML document,
 * designed to be used by both XSLT and XPointer
 *     http://www.w3.org/TR/xpath
 *
 * Implements
 * W3C Recommendation 16 November 1999
 *     http://www.w3.org/TR/1999/REC-xpath-19991116
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* LIBXML_XPATH_ENABLED */
/* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED */
/* *
 * The set of XPath error codes.
 */
/*
 * A node-set (an unordered collection of nodes without duplicates).
 */
/* number of nodes in the set */
/* size of the array as allocated */
/* array of nodes in no particular order */
/* @@ with_ns to check wether namespace nodes should be looked at @@ */
/*
 * An expression is evaluated to yield an object, which
 * has one of the following four basic types:
 *   - node-set
 *   - boolean
 *   - number
 *   - string
 *
 * @@ XPointer will add more types !
 */
/* An XSLT value tree, non modifiable */
/* *
 * xmlXPathConvertFunc:
 * @obj:  an XPath object
 * @type:  the number of the target type
 *
 * A conversion function is associated to a type and used to cast
 * the new type to primitive values.
 *
 * Returns -1 in case of error, 0 otherwise
 */
/*
 * Extra type: a name and a conversion function.
 */
/* the type name */
/* the conversion function */
/*
 * Extra variable: a name and a value.
 */
/* the variable name */
/* the value */
/* *
 * xmlXPathEvalFunc:
 * @ctxt: an XPath parser context
 * @nargs: the number of arguments passed to the function
 *
 * An XPath evaluation function, the parameters are on the XPath context stack.
 */
/*
 * Extra function: a name and a evaluation function.
 */
/* the function name */
/* the evaluation function */
/* *
 * xmlXPathAxisFunc:
 * @ctxt:  the XPath interpreter context
 * @cur:  the previous node being explored on that axis
 *
 * An axis traversal function. To traverse an axis, the engine calls
 * the first time with cur == NULL and repeat until the function returns
 * NULL indicating the end of the axis traversal.
 *
 * Returns the next node in that axis or NULL if at the end of the axis.
 */
/*
 * Extra axis: a name and an axis function.
 */
/* the axis name */
/* the search function */
/* *
 * xmlXPathFunction:
 * @ctxt:  the XPath interprestation context
 * @nargs:  the number of arguments
 *
 * An XPath function.
 * The arguments (if any) are popped out from the context stack
 * and the result is pushed on the stack.
 */
/*
 * Function and Variable Lookup.
 */
/* *
 * xmlXPathVariableLookupFunc:
 * @ctxt:  an XPath context
 * @name:  name of the variable
 * @ns_uri:  the namespace name hosting this variable
 *
 * Prototype for callbacks used to plug variable lookup in the XPath
 * engine.
 *
 * Returns the XPath object value or NULL if not found.
 */
/* *
 * xmlXPathFuncLookupFunc:
 * @ctxt:  an XPath context
 * @name:  name of the function
 * @ns_uri:  the namespace name hosting this function
 *
 * Prototype for callbacks used to plug function lookup in the XPath
 * engine.
 *
 * Returns the XPath function or NULL if not found.
 */
/* *
 * xmlXPathFlags:
 * Flags for XPath engine compilation and runtime
 */
/* *
 * XML_XPATH_CHECKNS:
 *
 * check namespaces at compilation
 */
/* *
 * XML_XPATH_NOVAR:
 *
 * forbid variables in expression
 */
/* *
 * xmlXPathContext:
 *
 * Expression evaluation occurs with respect to a context.
 * he context consists of:
 *    - a node (the context node)
 *    - a node list (the context node list)
 *    - a set of variable bindings
 *    - a function library
 *    - the set of namespace declarations in scope for the expression
 * Following the switch to hash tables, this need to be trimmed up at
 * the next binary incompatible release.
 * The node may be modified when the context is passed to libxml2
 * for an XPath evaluation so you may need to initialize it again
 * before the next call.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathContext {
    pub doc: xmlDocPtr,
    pub node: xmlNodePtr,
    pub nb_variables_unused: std::os::raw::c_int,
    pub max_variables_unused: std::os::raw::c_int,
    pub varHash: xmlHashTablePtr,
    pub nb_types: std::os::raw::c_int,
    pub max_types: std::os::raw::c_int,
    pub types: xmlXPathTypePtr,
    pub nb_funcs_unused: std::os::raw::c_int,
    pub max_funcs_unused: std::os::raw::c_int,
    pub funcHash: xmlHashTablePtr,
    pub nb_axis: std::os::raw::c_int,
    pub max_axis: std::os::raw::c_int,
    pub axis: xmlXPathAxisPtr,
    pub namespaces: *mut xmlNsPtr,
    pub nsNr: std::os::raw::c_int,
    pub user: *mut std::os::raw::c_void,
    pub contextSize: std::os::raw::c_int,
    pub proximityPosition: std::os::raw::c_int,
    pub xptr: std::os::raw::c_int,
    pub here: xmlNodePtr,
    pub origin: xmlNodePtr,
    pub nsHash: xmlHashTablePtr,
    pub varLookupFunc: xmlXPathVariableLookupFunc,
    pub varLookupData: *mut std::os::raw::c_void,
    pub extra: *mut std::os::raw::c_void,
    pub function: *const xmlChar,
    pub functionURI: *const xmlChar,
    pub funcLookupFunc: xmlXPathFuncLookupFunc,
    pub funcLookupData: *mut std::os::raw::c_void,
    pub tmpNsList: *mut xmlNsPtr,
    pub tmpNsNr: std::os::raw::c_int,
    pub userData: *mut std::os::raw::c_void,
    pub error: xmlStructuredErrorFunc,
    pub lastError: xmlError,
    pub debugNode: xmlNodePtr,
    pub dict: xmlDictPtr,
    pub flags: std::os::raw::c_int,
    pub cache: *mut std::os::raw::c_void,
}
pub type xmlXPathFuncLookupFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlXPathFunction>;
pub type xmlXPathFunction
    =
    Option<unsafe extern "C" fn(_: xmlXPathParserContextPtr, _: std::os::raw::c_int)
               -> ()>;
pub type xmlXPathParserContextPtr = *mut xmlXPathParserContext;
pub type xmlXPathParserContext = _xmlXPathParserContext;
/*
 * The structure of a compiled expression form is not public.
 */
/* *
 * xmlXPathParserContext:
 *
 * An XPath parser context. It contains pure parsing informations,
 * an xmlXPathContext, and the stack of objects.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathParserContext {
    pub cur: *const xmlChar,
    pub base: *const xmlChar,
    pub error: std::os::raw::c_int,
    pub context: xmlXPathContextPtr,
    pub value: xmlXPathObjectPtr,
    pub valueNr: std::os::raw::c_int,
    pub valueMax: std::os::raw::c_int,
    pub valueTab: *mut xmlXPathObjectPtr,
    pub comp: xmlXPathCompExprPtr,
    pub xptr: std::os::raw::c_int,
    pub ancestor: xmlNodePtr,
    pub valueFrame: std::os::raw::c_int,
}
pub type xmlXPathCompExprPtr = *mut xmlXPathCompExpr;
pub type xmlXPathCompExpr = _xmlXPathCompExpr;
pub type xmlXPathObjectPtr = *mut xmlXPathObject;
pub type xmlXPathObject = _xmlXPathObject;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathObject {
    pub type_0: xmlXPathObjectType,
    pub nodesetval: xmlNodeSetPtr,
    pub boolval: std::os::raw::c_int,
    pub floatval: std::os::raw::c_double,
    pub stringval: *mut xmlChar,
    pub user: *mut std::os::raw::c_void,
    pub index: std::os::raw::c_int,
    pub user2: *mut std::os::raw::c_void,
    pub index2: std::os::raw::c_int,
}
pub type xmlNodeSetPtr = *mut xmlNodeSet;
pub type xmlNodeSet = _xmlNodeSet;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNodeSet {
    pub nodeNr: std::os::raw::c_int,
    pub nodeMax: std::os::raw::c_int,
    pub nodeTab: *mut xmlNodePtr,
}
pub type xmlXPathObjectType = std::os::raw::c_uint;
pub const XPATH_XSLT_TREE: xmlXPathObjectType = 9;
pub const XPATH_USERS: xmlXPathObjectType = 8;
pub const XPATH_LOCATIONSET: xmlXPathObjectType = 7;
pub const XPATH_RANGE: xmlXPathObjectType = 6;
pub const XPATH_POINT: xmlXPathObjectType = 5;
pub const XPATH_STRING: xmlXPathObjectType = 4;
pub const XPATH_NUMBER: xmlXPathObjectType = 3;
pub const XPATH_BOOLEAN: xmlXPathObjectType = 2;
pub const XPATH_NODESET: xmlXPathObjectType = 1;
pub const XPATH_UNDEFINED: xmlXPathObjectType = 0;
pub type xmlXPathContextPtr = *mut xmlXPathContext;
pub type xmlXPathContext = _xmlXPathContext;
pub type xmlXPathVariableLookupFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: *const xmlChar,
                                _: *const xmlChar) -> xmlXPathObjectPtr>;
pub type xmlXPathAxisPtr = *mut xmlXPathAxis;
pub type xmlXPathAxis = _xmlXPathAxis;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathAxis {
    pub name: *const xmlChar,
    pub func: xmlXPathAxisFunc,
}
pub type xmlXPathAxisFunc
    =
    Option<unsafe extern "C" fn(_: xmlXPathParserContextPtr,
                                _: xmlXPathObjectPtr) -> xmlXPathObjectPtr>;
pub type xmlXPathTypePtr = *mut xmlXPathType;
pub type xmlXPathType = _xmlXPathType;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathType {
    pub name: *const xmlChar,
    pub func: xmlXPathConvertFunc,
}
pub type xmlXPathConvertFunc
    =
    Option<unsafe extern "C" fn(_: xmlXPathObjectPtr, _: std::os::raw::c_int)
               -> std::os::raw::c_int>;
pub type xmlRelaxNG = _xmlRelaxNG;
pub type xmlRelaxNGPtr = *mut xmlRelaxNG;
pub type xmlRelaxNGParserCtxt = _xmlRelaxNGParserCtxt;
pub type xmlRelaxNGParserCtxtPtr = *mut xmlRelaxNGParserCtxt;
pub type xmlRelaxNGValidCtxt = _xmlRelaxNGValidCtxt;
pub type xmlRelaxNGValidCtxtPtr = *mut xmlRelaxNGValidCtxt;
/* *
 * xmlTextReader:
 *
 * Structure for an xmlReader context.
 */
pub type xmlTextReader = _xmlTextReader;
/* *
 * xmlTextReaderPtr:
 *
 * Pointer to an xmlReader context.
 */
pub type xmlTextReaderPtr = *mut xmlTextReader;
pub type xmlTextReaderLocatorPtr = *mut std::os::raw::c_void;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlNode_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlNodePtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlXPathContext_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlXPathContextPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlXPathParserContext_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlXPathParserContextPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyparserCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlParserCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyValidCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlValidCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Pycatalog_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlCatalogPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlReg_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlRegexpPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlTextReader_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlTextReaderPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlTextReaderLocator_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlTextReaderLocatorPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyError_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlErrorPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyoutputBuffer_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlOutputBufferPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyinputBuffer_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlParserInputBufferPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyURI_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlURIPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyrelaxNgSchema_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlRelaxNGPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyrelaxNgParserCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlRelaxNGParserCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyrelaxNgValidCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlRelaxNGValidCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PySchema_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlSchemaPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PySchemaParserCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlSchemaParserCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PySchemaValidCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlSchemaValidCtxtPtr,
}
/* Generated */
/* Generated */
#[no_mangle]
pub unsafe extern "C" fn libxml_docbDefaultSAXHandlerInit(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    docbDefaultSAXHandlerInit();
    let ref mut fresh0 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh0 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DOCB_ENABLED) */
/* defined(LIBXML_DOCB_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlAutoCloseTag(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut elem: htmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OzO:htmlAutoCloseTag\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as htmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = htmlAutoCloseTag(doc, name, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCreateFileParserCtxt(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"zz:htmlCreateFileParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlCreateFileParserCtxt(filename, encoding);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCreateMemoryParserCtxt(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"s#i:htmlCreateMemoryParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlCreateMemoryParserCtxt(buffer, size);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReadDoc(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozzzi:htmlCtxtReadDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut cur as *mut *mut xmlChar,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = htmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReadFd(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut fd: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oizzi:htmlCtxtReadFd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut fd as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = htmlCtxtReadFd(ctxt, fd, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReadFile(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozzi:htmlCtxtReadFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = htmlCtxtReadFile(ctxt, filename, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReadMemory(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Os#izzi:htmlCtxtReadMemory\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = htmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReset(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:htmlCtxtReset\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    htmlCtxtReset(ctxt);
    let ref mut fresh1 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh1 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtUseOptions(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:htmlCtxtUseOptions\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = htmlCtxtUseOptions(ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlDefaultSAXHandlerInit(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    htmlDefaultSAXHandlerInit();
    let ref mut fresh2 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh2 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlDocContentDumpFormatOutput(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut format: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOzi:htmlDocContentDumpFormatOutput\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char,
                        &mut pyobj_buf as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut format as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    buf =
        if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlOutputBufferPtr
        } else { (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    htmlDocContentDumpFormatOutput(buf, cur, encoding, format);
    let ref mut fresh3 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh3 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlDocContentDumpOutput(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"OOz:htmlDocContentDumpOutput\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_buf as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut encoding as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    buf =
        if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlOutputBufferPtr
        } else { (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    htmlDocContentDumpOutput(buf, cur, encoding);
    let ref mut fresh4 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh4 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlDocDump(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut pyobj_f: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:htmlDocDump\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_f as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    f =
        if pyobj_f == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_f).ob_type == &mut PyFile_Type as *mut PyTypeObject
                      ||
                      PyType_IsSubtype((*pyobj_f).ob_type, &mut PyFile_Type)
                          != 0 {
            PyFile_AsFile(pyobj_f)
        } else { stdout };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = htmlDocDump(f, cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlFreeParserCtxt(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:htmlFreeParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    htmlFreeParserCtxt(ctxt);
    let ref mut fresh5 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh5 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlGetMetaEncoding(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:htmlGetMetaEncoding\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as htmlDocPtr;
    c_retval = htmlGetMetaEncoding(doc);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlHandleOmittedElem(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:htmlHandleOmittedElem\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlHandleOmittedElem(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlInitAutoClose(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    htmlInitAutoClose();
    let ref mut fresh6 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh6 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlIsAutoClosed(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: htmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:htmlIsAutoClosed\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as htmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = htmlIsAutoClosed(doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlIsBooleanAttr(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:htmlIsBooleanAttr\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlIsBooleanAttr(name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlIsScriptAttribute(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:htmlIsScriptAttribute\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlIsScriptAttribute(name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNewDoc(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:htmlNewDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URI as *mut *mut xmlChar,
                        &mut ExternalID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlNewDoc(URI, ExternalID);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNewDocNoDtD(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:htmlNewDocNoDtD\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URI as *mut *mut xmlChar,
                        &mut ExternalID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlNewDocNoDtD(URI, ExternalID);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNewParserCtxt(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    c_retval = htmlNewParserCtxt();
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNodeDumpFile(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:htmlNodeDumpFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_out as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    out =
        if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_out).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_out).ob_type, &mut PyFile_Type)
                          != 0 {
            PyFile_AsFile(pyobj_out)
        } else { stdout };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    htmlNodeDumpFile(out, doc, cur);
    let ref mut fresh7 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh7 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNodeDumpFileFormat(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut format: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOOzi:htmlNodeDumpFileFormat\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_out as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut format as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    out =
        if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_out).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_out).ob_type, &mut PyFile_Type)
                          != 0 {
            PyFile_AsFile(pyobj_out)
        } else { stdout };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = htmlNodeDumpFileFormat(out, doc, cur, encoding, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNodeDumpFormatOutput(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut format: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOOzi:htmlNodeDumpFormatOutput\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_buf as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut format as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    buf =
        if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlOutputBufferPtr
        } else { (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);
    let ref mut fresh8 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh8 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNodeDumpOutput(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"OOOz:htmlNodeDumpOutput\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_buf as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut encoding as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    buf =
        if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlOutputBufferPtr
        } else { (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    htmlNodeDumpOutput(buf, doc, cur, encoding);
    let ref mut fresh9 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh9 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseCharRef(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:htmlParseCharRef\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = htmlParseCharRef(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseChunk(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut chunk: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut terminate: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Os#ii:htmlParseChunk\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut chunk as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int,
                        &mut terminate as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = htmlParseChunk(ctxt, chunk, size, terminate);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_PUSH_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_PUSH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseDoc(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"zz:htmlParseDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar,
                        &mut encoding as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlParseDoc(cur, encoding);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseDocument(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:htmlParseDocument\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = htmlParseDocument(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseElement(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:htmlParseElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    htmlParseElement(ctxt);
    let ref mut fresh10 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh10 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseFile(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"zz:htmlParseFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlParseFile(filename, encoding);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlReadDoc(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzzi:htmlReadDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlReadDoc(cur, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlReadFd(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut fd: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"izzi:htmlReadFd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut fd as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlReadFd(fd, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlReadFile(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzi:htmlReadFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlReadFile(filename, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlReadMemory(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"s#izzi:htmlReadMemory\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = htmlReadMemory(buffer, size, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlSaveFile(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"zO:htmlSaveFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = htmlSaveFile(filename, cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlSaveFileEnc(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"zOz:htmlSaveFileEnc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut encoding as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = htmlSaveFileEnc(filename, cur, encoding);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlSaveFileFormat(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut format: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zOzi:htmlSaveFileFormat\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut format as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = htmlSaveFileFormat(filename, cur, encoding, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlSetMetaEncoding(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:htmlSetMetaEncoding\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut encoding as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as htmlDocPtr;
    c_retval = htmlSetMetaEncoding(doc, encoding);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_namePop(mut self_0: *mut PyObject,
                                        mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:namePop\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = namePop(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_namePush(mut self_0: *mut PyObject,
                                         mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:namePush\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = namePush(ctxt, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_nodePop(mut self_0: *mut PyObject,
                                        mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:nodePop\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = nodePop(ctxt);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_nodePush(mut self_0: *mut PyObject,
                                         mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut value: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_value: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:nodePush\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_value as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    value =
        if pyobj_value == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_value as *mut PyxmlNode_Object)).obj };
    c_retval = nodePush(ctxt, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_valuePop(mut self_0: *mut PyObject,
                                         mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:valuePop\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = valuePop(ctxt);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogAdd(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut type_0: *mut xmlChar = 0 as *mut xmlChar;
    let mut orig: *mut xmlChar = 0 as *mut xmlChar;
    let mut replace: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozzz:xmlACatalogAdd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject,
                        &mut type_0 as *mut *mut xmlChar,
                        &mut orig as *mut *mut xmlChar,
                        &mut replace as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    c_retval = xmlACatalogAdd(catal, type_0, orig, replace);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogDump(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlACatalogDump\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject,
                        &mut pyobj_out as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    out =
        if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_out).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_out).ob_type, &mut PyFile_Type)
                          != 0 {
            PyFile_AsFile(pyobj_out)
        } else { stdout };
    xmlACatalogDump(catal, out);
    let ref mut fresh11 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh11 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_CATALOG_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogRemove(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlACatalogRemove\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    c_retval = xmlACatalogRemove(catal, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogResolve(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlACatalogResolve\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject,
                        &mut pubID as *mut *mut xmlChar,
                        &mut sysID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    c_retval = xmlACatalogResolve(catal, pubID, sysID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogResolvePublic(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlACatalogResolvePublic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject,
                        &mut pubID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    c_retval = xmlACatalogResolvePublic(catal, pubID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogResolveSystem(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlACatalogResolveSystem\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject,
                        &mut sysID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    c_retval = xmlACatalogResolveSystem(catal, sysID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogResolveURI(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlACatalogResolveURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject,
                        &mut URI as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    c_retval = xmlACatalogResolveURI(catal, URI);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddChild(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlAddChild\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_parent as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    parent =
        if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_parent as *mut PyxmlNode_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlAddChild(parent, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddChildList(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlAddChildList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_parent as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    parent =
        if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_parent as *mut PyxmlNode_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlAddChildList(parent, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddDocEntity(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut type_0: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozizzz:xmlAddDocEntity\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut type_0 as *mut std::os::raw::c_int,
                        &mut ExternalID as *mut *mut xmlChar,
                        &mut SystemID as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval =
        xmlAddDocEntity(doc, name, type_0, ExternalID, SystemID, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddDtdEntity(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut type_0: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozizzz:xmlAddDtdEntity\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut type_0 as *mut std::os::raw::c_int,
                        &mut ExternalID as *mut *mut xmlChar,
                        &mut SystemID as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval =
        xmlAddDtdEntity(doc, name, type_0, ExternalID, SystemID, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddEncodingAlias(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut name: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut alias: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"zz:xmlAddEncodingAlias\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut name as *mut *mut std::os::raw::c_char,
                        &mut alias as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlAddEncodingAlias(name, alias);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddNextSibling(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlAddNextSibling\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlAddNextSibling(cur, elem);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddPrevSibling(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlAddPrevSibling\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlAddPrevSibling(cur, elem);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddSibling(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlAddSibling\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlAddSibling(cur, elem);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlBoolToText(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut boolval: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlBoolToText\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut boolval as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlBoolToText(boolval);
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlBuildQName(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ncname: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut memory: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzzi:xmlBuildQName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut ncname as *mut *mut xmlChar,
                        &mut prefix as *mut *mut xmlChar,
                        &mut memory as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlBuildQName(ncname, prefix, memory, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlBuildRelativeURI(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut base: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlBuildRelativeURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URI as *mut *mut xmlChar,
                        &mut base as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlBuildRelativeURI(URI, base);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlBuildURI(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut base: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlBuildURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URI as *mut *mut xmlChar,
                        &mut base as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlBuildURI(URI, base);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlByteConsumed(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_long = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlByteConsumed\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlByteConsumed(ctxt);
    py_retval = libxml_longWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCanonicPath(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut path: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCanonicPath\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut path as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCanonicPath(path);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogAdd(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut type_0: *mut xmlChar = 0 as *mut xmlChar;
    let mut orig: *mut xmlChar = 0 as *mut xmlChar;
    let mut replace: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zzz:xmlCatalogAdd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut type_0 as *mut *mut xmlChar,
                        &mut orig as *mut *mut xmlChar,
                        &mut replace as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCatalogAdd(type_0, orig, replace);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogCleanup(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    xmlCatalogCleanup();
    let ref mut fresh12 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh12 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogConvert(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    c_retval = xmlCatalogConvert();
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogDump(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlCatalogDump\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_out as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    out =
        if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_out).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_out).ob_type, &mut PyFile_Type)
                          != 0 {
            PyFile_AsFile(pyobj_out)
        } else { stdout };
    xmlCatalogDump(out);
    let ref mut fresh13 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh13 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_CATALOG_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogGetPublic(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCatalogGetPublic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pubID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCatalogGetPublic(pubID);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogGetSystem(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCatalogGetSystem\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut sysID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCatalogGetSystem(sysID);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogIsEmpty(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlCatalogIsEmpty\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    c_retval = xmlCatalogIsEmpty(catal);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogRemove(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCatalogRemove\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCatalogRemove(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogResolve(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlCatalogResolve\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pubID as *mut *mut xmlChar,
                        &mut sysID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCatalogResolve(pubID, sysID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogResolvePublic(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCatalogResolvePublic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pubID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCatalogResolvePublic(pubID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogResolveSystem(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCatalogResolveSystem\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut sysID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCatalogResolveSystem(sysID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogResolveURI(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCatalogResolveURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URI as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCatalogResolveURI(URI);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogSetDebug(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut level: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlCatalogSetDebug\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut level as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCatalogSetDebug(level);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCharStrdup(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlCharStrdup\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCharStrdup(cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCharStrndup(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlCharStrndup\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut std::os::raw::c_char,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCharStrndup(cur, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCheckFilename(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut path: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlCheckFilename\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut path as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCheckFilename(path);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCheckLanguageID(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut lang: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCheckLanguageID\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut lang as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCheckLanguageID(lang);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCheckUTF8(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut utf: *mut std::os::raw::c_uchar = 0 as *mut std::os::raw::c_uchar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCheckUTF8\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut utf as *mut *mut std::os::raw::c_uchar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCheckUTF8(utf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCheckVersion(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut version: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlCheckVersion\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut version as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    xmlCheckVersion(version);
    let ref mut fresh14 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh14 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupCharEncodingHandlers(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    xmlCleanupCharEncodingHandlers();
    let ref mut fresh15 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh15 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupEncodingAliases(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    xmlCleanupEncodingAliases();
    let ref mut fresh16 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh16 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupGlobals(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    xmlCleanupGlobals();
    let ref mut fresh17 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh17 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupInputCallbacks(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    xmlCleanupInputCallbacks();
    let ref mut fresh18 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh18 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupOutputCallbacks(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    xmlCleanupOutputCallbacks();
    let ref mut fresh19 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh19 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupPredefinedEntities(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    xmlCleanupPredefinedEntities();
    let ref mut fresh20 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh20 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlClearParserCtxt(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlClearParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlClearParserCtxt(ctxt);
    let ref mut fresh21 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh21 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlConvertSGMLCatalog(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlConvertSGMLCatalog\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    c_retval = xmlConvertSGMLCatalog(catal);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyChar(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    let mut out: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"izi:xmlCopyChar\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut len as *mut std::os::raw::c_int,
                        &mut out as *mut *mut xmlChar,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCopyChar(len, out, val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyCharMultiByte(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut out: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlCopyCharMultiByte\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut out as *mut *mut xmlChar,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCopyCharMultiByte(out, val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyDoc(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut recursive: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlCopyDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut recursive as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlCopyDoc(doc, recursive);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyDtd(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlCopyDtd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_dtd as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    dtd =
        if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_dtd as *mut PyxmlNode_Object)).obj } as xmlDtdPtr;
    c_retval = xmlCopyDtd(dtd);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyError(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut from: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_from: *mut PyObject = 0 as *mut PyObject;
    let mut to: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_to: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlCopyError\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_from as *mut *mut PyObject,
                        &mut pyobj_to as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    from =
        if pyobj_from == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlErrorPtr
        } else { (*(pyobj_from as *mut PyError_Object)).obj };
    to =
        if pyobj_to == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlErrorPtr
        } else { (*(pyobj_to as *mut PyError_Object)).obj };
    c_retval = xmlCopyError(from, to);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyNamespace(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlCopyNamespace\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlCopyNamespace(cur);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyNamespaceList(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlCopyNamespaceList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlCopyNamespaceList(cur);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyNode(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut extended: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlCopyNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut extended as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlCopyNode(node, extended);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyNodeList(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlCopyNodeList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlCopyNodeList(node);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyProp(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut target: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_target: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlCopyProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_target as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    target =
        if pyobj_target == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_target as *mut PyxmlNode_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    c_retval = xmlCopyProp(target, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyPropList(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut target: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_target: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlCopyPropList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_target as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    target =
        if pyobj_target == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_target as *mut PyxmlNode_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    c_retval = xmlCopyPropList(target, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateDocParserCtxt(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlCreateDocParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCreateDocParserCtxt(cur);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateEntityParserCtxt(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut URL: *mut xmlChar = 0 as *mut xmlChar;
    let mut ID: *mut xmlChar = 0 as *mut xmlChar;
    let mut base: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zzz:xmlCreateEntityParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URL as *mut *mut xmlChar,
                        &mut ID as *mut *mut xmlChar,
                        &mut base as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCreateEntityParserCtxt(URL, ID, base);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateFileParserCtxt(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlCreateFileParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCreateFileParserCtxt(filename);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateIntSubset(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozzz:xmlCreateIntSubset\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut ExternalID as *mut *mut xmlChar,
                        &mut SystemID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlCreateIntSubset(doc, name, ExternalID, SystemID);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateMemoryParserCtxt(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"s#i:xmlCreateMemoryParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCreateMemoryParserCtxt(buffer, size);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateURI(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlURIPtr = 0 as *mut xmlURI;
    c_retval = xmlCreateURI();
    py_retval = libxml_xmlURIPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateURLParserCtxt(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlCreateURLParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlCreateURLParserCtxt(filename, options);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReadDoc(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozzzi:xmlCtxtReadDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut cur as *mut *mut xmlChar,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReadFd(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut fd: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oizzi:xmlCtxtReadFd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut fd as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlCtxtReadFd(ctxt, fd, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReadFile(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozzi:xmlCtxtReadFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlCtxtReadFile(ctxt, filename, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReadMemory(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Os#izzi:xmlCtxtReadMemory\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReset(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlCtxtReset\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlCtxtReset(ctxt);
    let ref mut fresh22 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh22 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtResetPush(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut chunk: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Os#izz:xmlCtxtResetPush\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut chunk as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlCtxtResetPush(ctxt, chunk, size, filename, encoding);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtUseOptions(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlCtxtUseOptions\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlCtxtUseOptions(ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugCheckDocument(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlDebugCheckDocument\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlDebugCheckDocument(output, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpAttr(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
    let mut depth: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlDebugDumpAttr\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_attr as *mut *mut PyObject,
                        &mut depth as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    attr =
        if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_attr as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    xmlDebugDumpAttr(output, attr, depth);
    let ref mut fresh23 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh23 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpAttrList(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
    let mut depth: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlDebugDumpAttrList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_attr as *mut *mut PyObject,
                        &mut depth as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    attr =
        if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_attr as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    xmlDebugDumpAttrList(output, attr, depth);
    let ref mut fresh24 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh24 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpDTD(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlDebugDumpDTD\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_dtd as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    dtd =
        if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_dtd as *mut PyxmlNode_Object)).obj } as xmlDtdPtr;
    xmlDebugDumpDTD(output, dtd);
    let ref mut fresh25 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh25 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpDocument(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlDebugDumpDocument\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    xmlDebugDumpDocument(output, doc);
    let ref mut fresh26 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh26 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpDocumentHead(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlDebugDumpDocumentHead\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    xmlDebugDumpDocumentHead(output, doc);
    let ref mut fresh27 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh27 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpEntities(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlDebugDumpEntities\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    xmlDebugDumpEntities(output, doc);
    let ref mut fresh28 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh28 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpNode(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut depth: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlDebugDumpNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut depth as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    xmlDebugDumpNode(output, node, depth);
    let ref mut fresh29 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh29 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpNodeList(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut depth: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlDebugDumpNodeList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut depth as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    xmlDebugDumpNodeList(output, node, depth);
    let ref mut fresh30 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh30 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpOneNode(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut depth: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlDebugDumpOneNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut depth as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    xmlDebugDumpOneNode(output, node, depth);
    let ref mut fresh31 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh31 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpString(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlDebugDumpString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut str as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    xmlDebugDumpString(output, str);
    let ref mut fresh32 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh32 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDecodeEntities(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut len: std::os::raw::c_int = 0;
    let mut what: std::os::raw::c_int = 0;
    let mut end: xmlChar = 0;
    let mut end2: xmlChar = 0;
    let mut end3: xmlChar = 0;
    if PyArg_ParseTuple(args,
                        b"Oiiccc:xmlDecodeEntities\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut len as *mut std::os::raw::c_int,
                        &mut what as *mut std::os::raw::c_int,
                        &mut end as *mut xmlChar, &mut end2 as *mut xmlChar,
                        &mut end3 as *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlDecodeEntities(ctxt, len, what, end, end2, end3);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDefaultSAXHandlerInit(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    xmlDefaultSAXHandlerInit();
    let ref mut fresh33 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh33 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDelEncodingAlias(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut alias: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlDelEncodingAlias\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut alias as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlDelEncodingAlias(alias);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDictCleanup(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    xmlDictCleanup();
    let ref mut fresh34 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh34 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocCopyNode(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut extended: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlDocCopyNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut extended as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlDocCopyNode(node, doc, extended);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocCopyNodeList(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlDocCopyNodeList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlDocCopyNodeList(doc, node);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocDump(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut pyobj_f: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlDocDump\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_f as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    f =
        if pyobj_f == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_f).ob_type == &mut PyFile_Type as *mut PyTypeObject
                      ||
                      PyType_IsSubtype((*pyobj_f).ob_type, &mut PyFile_Type)
                          != 0 {
            PyFile_AsFile(pyobj_f)
        } else { stdout };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlDocDump(f, cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocFormatDump(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut pyobj_f: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut format: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlDocFormatDump\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_f as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut format as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    f =
        if pyobj_f == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_f).ob_type == &mut PyFile_Type as *mut PyTypeObject
                      ||
                      PyType_IsSubtype((*pyobj_f).ob_type, &mut PyFile_Type)
                          != 0 {
            PyFile_AsFile(pyobj_f)
        } else { stdout };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlDocFormatDump(f, cur, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocGetRootElement(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlDocGetRootElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    c_retval = xmlDocGetRootElement(doc);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocSetRootElement(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut root: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_root: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlDocSetRootElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_root as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    root =
        if pyobj_root == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_root as *mut PyxmlNode_Object)).obj };
    c_retval = xmlDocSetRootElement(doc, root);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlElemDump(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut pyobj_f: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlElemDump\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_f as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    f =
        if pyobj_f == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_f).ob_type == &mut PyFile_Type as *mut PyTypeObject
                      ||
                      PyType_IsSubtype((*pyobj_f).ob_type, &mut PyFile_Type)
                          != 0 {
            PyFile_AsFile(pyobj_f)
        } else { stdout };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlElemDump(f, doc, cur);
    let ref mut fresh35 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh35 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlEncodeEntities(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut input: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlEncodeEntities\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut input as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlEncodeEntities(doc, input);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlEncodeEntitiesReentrant(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut input: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlEncodeEntitiesReentrant\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut input as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlEncodeEntitiesReentrant(doc, input);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlEncodeSpecialChars(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut input: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlEncodeSpecialChars\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut input as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    c_retval = xmlEncodeSpecialChars(doc, input);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetCode(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlErrorGetCode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_Error as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    Error =
        if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlErrorPtr
        } else { (*(pyobj_Error as *mut PyError_Object)).obj };
    c_retval = (*Error).code;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetDomain(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlErrorGetDomain\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_Error as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    Error =
        if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlErrorPtr
        } else { (*(pyobj_Error as *mut PyError_Object)).obj };
    c_retval = (*Error).domain;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetFile(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlErrorGetFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_Error as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    Error =
        if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlErrorPtr
        } else { (*(pyobj_Error as *mut PyError_Object)).obj };
    c_retval = (*Error).file;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetLevel(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlErrorGetLevel\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_Error as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    Error =
        if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlErrorPtr
        } else { (*(pyobj_Error as *mut PyError_Object)).obj };
    c_retval = (*Error).level as std::os::raw::c_int;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetLine(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlErrorGetLine\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_Error as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    Error =
        if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlErrorPtr
        } else { (*(pyobj_Error as *mut PyError_Object)).obj };
    c_retval = (*Error).line;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetMessage(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlErrorGetMessage\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_Error as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    Error =
        if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlErrorPtr
        } else { (*(pyobj_Error as *mut PyError_Object)).obj };
    c_retval = (*Error).message;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFileMatch(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlFileMatch\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlFileMatch(filename);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFirstElementChild(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFirstElementChild\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_parent as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    parent =
        if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_parent as *mut PyxmlNode_Object)).obj };
    c_retval = xmlFirstElementChild(parent);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeCatalog(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeCatalog\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_catal as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    catal =
        if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlCatalogPtr
        } else { (*(pyobj_catal as *mut Pycatalog_Object)).obj };
    xmlFreeCatalog(catal);
    let ref mut fresh36 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh36 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeDoc(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    xmlFreeDoc(cur);
    let ref mut fresh37 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh37 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeDtd(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeDtd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDtdPtr;
    xmlFreeDtd(cur);
    let ref mut fresh38 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh38 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeNode(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlFreeNode(cur);
    let ref mut fresh39 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh39 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeNodeList(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeNodeList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlFreeNodeList(cur);
    let ref mut fresh40 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh40 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeNs(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeNs\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    xmlFreeNs(cur);
    let ref mut fresh41 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh41 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeNsList(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeNsList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    xmlFreeNsList(cur);
    let ref mut fresh42 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh42 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeParserInputBuffer(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeParserInputBuffer\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_in as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    in_0 =
        if pyobj_in == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserInputBufferPtr
        } else { (*(pyobj_in as *mut PyinputBuffer_Object)).obj };
    xmlFreeParserInputBuffer(in_0);
    let ref mut fresh43 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh43 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeProp(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    xmlFreeProp(cur);
    let ref mut fresh44 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh44 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreePropList(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreePropList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    xmlFreePropList(cur);
    let ref mut fresh45 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh45 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeURI(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_uri: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlFreeURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_uri as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    uri =
        if pyobj_uri == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_uri as *mut PyURI_Object)).obj };
    xmlFreeURI(uri);
    let ref mut fresh46 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh46 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetCompressMode(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    c_retval = xmlGetCompressMode();
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDocCompressMode(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlGetDocCompressMode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    c_retval = xmlGetDocCompressMode(doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDocEntity(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlGetDocEntity\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    c_retval = xmlGetDocEntity(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdAttrDesc(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttributePtr = 0 as *mut xmlAttribute;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    let mut elem: *mut xmlChar = 0 as *mut xmlChar;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlGetDtdAttrDesc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_dtd as *mut *mut PyObject,
                        &mut elem as *mut *mut xmlChar,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    dtd =
        if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_dtd as *mut PyxmlNode_Object)).obj } as xmlDtdPtr;
    c_retval = xmlGetDtdAttrDesc(dtd, elem, name);
    py_retval = libxml_xmlAttributePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdElementDesc(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlElementPtr = 0 as *mut xmlElement;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlGetDtdElementDesc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_dtd as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    dtd =
        if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_dtd as *mut PyxmlNode_Object)).obj } as xmlDtdPtr;
    c_retval = xmlGetDtdElementDesc(dtd, name);
    py_retval = libxml_xmlElementPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdEntity(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlGetDtdEntity\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlGetDtdEntity(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdQAttrDesc(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttributePtr = 0 as *mut xmlAttribute;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    let mut elem: *mut xmlChar = 0 as *mut xmlChar;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozzz:xmlGetDtdQAttrDesc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_dtd as *mut *mut PyObject,
                        &mut elem as *mut *mut xmlChar,
                        &mut name as *mut *mut xmlChar,
                        &mut prefix as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    dtd =
        if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_dtd as *mut PyxmlNode_Object)).obj } as xmlDtdPtr;
    c_retval = xmlGetDtdQAttrDesc(dtd, elem, name, prefix);
    py_retval = libxml_xmlAttributePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdQElementDesc(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlElementPtr = 0 as *mut xmlElement;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlGetDtdQElementDesc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_dtd as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut prefix as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    dtd =
        if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_dtd as *mut PyxmlNode_Object)).obj } as xmlDtdPtr;
    c_retval = xmlGetDtdQElementDesc(dtd, name, prefix);
    py_retval = libxml_xmlElementPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetEncodingAlias(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut alias: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlGetEncodingAlias\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut alias as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlGetEncodingAlias(alias);
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetID(mut self_0: *mut PyObject,
                                         mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut ID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlGetID\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut ID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlGetID(doc, ID);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetIntSubset(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlGetIntSubset\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    c_retval = xmlGetIntSubset(doc);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetLastChild(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlGetLastChild\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_parent as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    parent =
        if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_parent as *mut PyxmlNode_Object)).obj };
    c_retval = xmlGetLastChild(parent);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetLastError(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlErrorPtr = 0 as *mut xmlError;
    c_retval = xmlGetLastError();
    py_retval = libxml_xmlErrorPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetLineNo(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_long = 0;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlGetLineNo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlGetLineNo(node);
    py_retval = libxml_longWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetNoNsProp(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlGetNoNsProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlGetNoNsProp(node, name);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetNodePath(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlGetNodePath\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlGetNodePath(node);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetNsProp(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut nameSpace: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlGetNsProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut nameSpace as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlGetNsProp(node, name, nameSpace);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetParameterEntity(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlGetParameterEntity\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlGetParameterEntity(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetPredefinedEntity(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlGetPredefinedEntity\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlGetPredefinedEntity(name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetProp(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlGetProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlGetProp(node, name);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlHandleEntity(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut entity: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut pyobj_entity: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlHandleEntity\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_entity as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    entity =
        if pyobj_entity == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_entity as *mut PyxmlNode_Object)).obj } as
            xmlEntityPtr;
    xmlHandleEntity(ctxt, entity);
    let ref mut fresh47 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh47 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlHasNsProp(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut nameSpace: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlHasNsProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut nameSpace as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlHasNsProp(node, name, nameSpace);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlHasProp(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlHasProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlHasProp(node, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIOFTPMatch(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlIOFTPMatch\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIOFTPMatch(filename);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_FTP_ENABLED) */
/* defined(LIBXML_FTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIOHTTPMatch(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlIOHTTPMatch\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIOHTTPMatch(filename);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_HTTP_ENABLED) */
/* defined(LIBXML_HTTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitCharEncodingHandlers(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    xmlInitCharEncodingHandlers();
    let ref mut fresh48 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh48 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitGlobals(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    xmlInitGlobals();
    let ref mut fresh49 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh49 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitParser(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    xmlInitParser();
    let ref mut fresh50 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh50 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitParserCtxt(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlInitParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlInitParserCtxt(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitializeCatalog(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    xmlInitializeCatalog();
    let ref mut fresh51 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh51 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitializeDict(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    c_retval = xmlInitializeDict();
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitializePredefinedEntities(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    xmlInitializePredefinedEntities();
    let ref mut fresh52 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh52 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsBaseChar(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlIsBaseChar\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut ch as *mut std::os::raw::c_uint) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsBaseChar(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsBlank(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlIsBlank\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut ch as *mut std::os::raw::c_uint) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsBlank(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsBlankNode(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlIsBlankNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlIsBlankNode(node);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsChar(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlIsChar\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut ch as *mut std::os::raw::c_uint) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsChar(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsCombining(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlIsCombining\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut ch as *mut std::os::raw::c_uint) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsCombining(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsDigit(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlIsDigit\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut ch as *mut std::os::raw::c_uint) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsDigit(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsExtender(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlIsExtender\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut ch as *mut std::os::raw::c_uint) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsExtender(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsID(mut self_0: *mut PyObject,
                                        mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlIsID\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject,
                        &mut pyobj_attr as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    attr =
        if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_attr as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    c_retval = xmlIsID(doc, elem, attr);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsIdeographic(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlIsIdeographic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut ch as *mut std::os::raw::c_uint) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsIdeographic(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsLetter(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut c: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlIsLetter\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut c as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsLetter(c);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsMixedElement(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlIsMixedElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlIsMixedElement(doc, name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsPubidChar(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ch: std::os::raw::c_uint = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlIsPubidChar\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut ch as *mut std::os::raw::c_uint) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsPubidChar(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsRef(mut self_0: *mut PyObject,
                                         mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlIsRef\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject,
                        &mut pyobj_attr as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    attr =
        if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_attr as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    c_retval = xmlIsRef(doc, elem, attr);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsXHTML(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut systemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut publicID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlIsXHTML\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut systemID as *mut *mut xmlChar,
                        &mut publicID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlIsXHTML(systemID, publicID);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlKeepBlanksDefault(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlKeepBlanksDefault\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlKeepBlanksDefault(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLastElementChild(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlLastElementChild\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_parent as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    parent =
        if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_parent as *mut PyxmlNode_Object)).obj };
    c_retval = xmlLastElementChild(parent);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLineNumbersDefault(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlLineNumbersDefault\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlLineNumbersDefault(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLoadACatalog(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlLoadACatalog\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlLoadACatalog(filename);
    py_retval = libxml_xmlCatalogPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLoadCatalog(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlLoadCatalog\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlLoadCatalog(filename);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLoadCatalogs(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut pathss: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlLoadCatalogs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pathss as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    xmlLoadCatalogs(pathss);
    let ref mut fresh53 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh53 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLoadSGMLSuperCatalog(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlLoadSGMLSuperCatalog\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlLoadSGMLSuperCatalog(filename);
    py_retval = libxml_xmlCatalogPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLsCountNode(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlLsCountNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlLsCountNode(node);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_DEBUG_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLsOneNode(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlLsOneNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    xmlLsOneNode(output, node);
    let ref mut fresh54 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh54 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNamespaceParseNCName(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlNamespaceParseNCName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlNamespaceParseNCName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNamespaceParseNSDef(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlNamespaceParseNSDef\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlNamespaceParseNSDef(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoFTPCleanup(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    xmlNanoFTPCleanup();
    let ref mut fresh55 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh55 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_FTP_ENABLED) */
/* defined(LIBXML_FTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoFTPInit(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    xmlNanoFTPInit();
    let ref mut fresh56 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh56 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_FTP_ENABLED) */
/* defined(LIBXML_FTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoFTPProxy(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut host: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut port: std::os::raw::c_int = 0;
    let mut user: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut passwd: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut type_0: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zizzi:xmlNanoFTPProxy\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut host as *mut *mut std::os::raw::c_char,
                        &mut port as *mut std::os::raw::c_int,
                        &mut user as *mut *mut std::os::raw::c_char,
                        &mut passwd as *mut *mut std::os::raw::c_char,
                        &mut type_0 as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    xmlNanoFTPProxy(host, port, user, passwd, type_0);
    let ref mut fresh57 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh57 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_FTP_ENABLED) */
/* defined(LIBXML_FTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoFTPScanProxy(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlNanoFTPScanProxy\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URL as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    xmlNanoFTPScanProxy(URL);
    let ref mut fresh58 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh58 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_FTP_ENABLED) */
/* defined(LIBXML_FTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoHTTPCleanup(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    xmlNanoHTTPCleanup();
    let ref mut fresh59 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh59 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTTP_ENABLED) */
/* defined(LIBXML_HTTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoHTTPInit(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    xmlNanoHTTPInit();
    let ref mut fresh60 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh60 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTTP_ENABLED) */
/* defined(LIBXML_HTTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoHTTPScanProxy(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlNanoHTTPScanProxy\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URL as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    xmlNanoHTTPScanProxy(URL);
    let ref mut fresh61 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh61 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_HTTP_ENABLED) */
/* defined(LIBXML_HTTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewCDataBlock(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozi:xmlNewCDataBlock\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewCDataBlock(doc, content, len);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewCatalog(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut sgml: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlNewCatalog\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut sgml as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlNewCatalog(sgml);
    py_retval = libxml_xmlCatalogPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewCharRef(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNewCharRef\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewCharRef(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewChild(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOzz:xmlNewChild\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_parent as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    parent =
        if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_parent as *mut PyxmlNode_Object)).obj };
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlNewChild(parent, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewComment(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlNewComment\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlNewComment(content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDoc(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut version: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlNewDoc\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut version as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlNewDoc(version);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocComment(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNewDocComment\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewDocComment(doc, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocFragment(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlNewDocFragment\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewDocFragment(doc);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocNode(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOzz:xmlNewDocNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlNewDocNode(doc, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocNodeEatName(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOzz:xmlNewDocNodeEatName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlNewDocNodeEatName(doc, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocPI(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlNewDocPI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewDocPI(doc, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocProp(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlNewDocProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewDocProp(doc, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocRawNode(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOzz:xmlNewDocRawNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlNewDocRawNode(doc, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocText(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNewDocText\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    c_retval = xmlNewDocText(doc, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocTextLen(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozi:xmlNewDocTextLen\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewDocTextLen(doc, content, len);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDtd(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozzz:xmlNewDtd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut ExternalID as *mut *mut xmlChar,
                        &mut SystemID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewDtd(doc, name, ExternalID, SystemID);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewEntity(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut type_0: std::os::raw::c_int = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozizzz:xmlNewEntity\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut type_0 as *mut std::os::raw::c_int,
                        &mut ExternalID as *mut *mut xmlChar,
                        &mut SystemID as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewEntity(doc, name, type_0, ExternalID, SystemID, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewGlobalNs(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut href: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlNewGlobalNs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut href as *mut *mut xmlChar,
                        &mut prefix as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlNewGlobalNs(doc, href, prefix);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewNodeEatName(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNewNodeEatName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlNewNodeEatName(ns, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewNs(mut self_0: *mut PyObject,
                                         mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut href: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlNewNs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut href as *mut *mut xmlChar,
                        &mut prefix as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNewNs(node, href, prefix);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewNsProp(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOzz:xmlNewNsProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlNewNsProp(node, ns, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewNsPropEatName(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOzz:xmlNewNsPropEatName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlNewNsPropEatName(node, ns, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewPI(mut self_0: *mut PyObject,
                                         mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlNewPI\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut name as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlNewPI(name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewParserCtxt(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    c_retval = xmlNewParserCtxt();
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewProp(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlNewProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNewProp(node, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewReference(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNewReference\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    c_retval = xmlNewReference(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewText(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlNewText\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlNewText(content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewTextChild(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOzz:xmlNewTextChild\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_parent as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    parent =
        if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_parent as *mut PyxmlNode_Object)).obj };
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlNewTextChild(parent, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewTextLen(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlNewTextLen\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut content as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlNewTextLen(content, len);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewTextReader(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_input: *mut PyObject = 0 as *mut PyObject;
    let mut URI: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNewTextReader\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_input as *mut *mut PyObject,
                        &mut URI as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    input =
        if pyobj_input == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserInputBufferPtr
        } else { (*(pyobj_input as *mut PyinputBuffer_Object)).obj };
    c_retval = xmlNewTextReader(input, URI);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewTextReaderFilename(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut URI: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlNewTextReaderFilename\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URI as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlNewTextReaderFilename(URI);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewValidCtxt(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    c_retval = xmlNewValidCtxt();
    py_retval = libxml_xmlValidCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNextChar(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlNextChar\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlNextChar(ctxt);
    let ref mut fresh62 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh62 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNextElementSibling(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlNextElementSibling\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNextElementSibling(node);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeAddContent(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNodeAddContent\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlNodeAddContent(cur, content);
    let ref mut fresh63 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh63 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeAddContentLen(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozi:xmlNodeAddContentLen\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlNodeAddContentLen(cur, content, len);
    let ref mut fresh64 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh64 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeDumpOutput(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut level: std::os::raw::c_int = 0;
    let mut format: std::os::raw::c_int = 0;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"OOOiiz:xmlNodeDumpOutput\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_buf as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut level as *mut std::os::raw::c_int,
                        &mut format as *mut std::os::raw::c_int,
                        &mut encoding as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    buf =
        if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlOutputBufferPtr
        } else { (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlNodeDumpOutput(buf, doc, cur, level, format, encoding);
    let ref mut fresh65 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh65 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeGetBase(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlNodeGetBase\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNodeGetBase(doc, cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeGetContent(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlNodeGetContent\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNodeGetContent(cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeGetLang(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlNodeGetLang\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNodeGetLang(cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeGetSpacePreserve(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlNodeGetSpacePreserve\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNodeGetSpacePreserve(cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeIsText(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlNodeIsText\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNodeIsText(node);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeListGetRawString(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut list: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_list: *mut PyObject = 0 as *mut PyObject;
    let mut inLine: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlNodeListGetRawString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_list as *mut *mut PyObject,
                        &mut inLine as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    list =
        if pyobj_list == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_list as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNodeListGetRawString(doc, list, inLine);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeListGetString(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut list: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_list: *mut PyObject = 0 as *mut PyObject;
    let mut inLine: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlNodeListGetString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_list as *mut *mut PyObject,
                        &mut inLine as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    list =
        if pyobj_list == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_list as *mut PyxmlNode_Object)).obj };
    c_retval = xmlNodeListGetString(doc, list, inLine);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetBase(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut uri: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNodeSetBase\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut uri as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlNodeSetBase(cur, uri);
    let ref mut fresh66 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh66 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetContent(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNodeSetContent\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlNodeSetContent(cur, content);
    let ref mut fresh67 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh67 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetContentLen(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozi:xmlNodeSetContentLen\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlNodeSetContentLen(cur, content, len);
    let ref mut fresh68 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh68 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetLang(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut lang: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNodeSetLang\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut lang as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlNodeSetLang(cur, lang);
    let ref mut fresh69 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh69 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetName(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlNodeSetName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlNodeSetName(cur, name);
    let ref mut fresh70 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh70 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetSpacePreserve(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlNodeSetSpacePreserve\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlNodeSetSpacePreserve(cur, val);
    let ref mut fresh71 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh71 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNormalizeURIPath(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut path: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlNormalizeURIPath\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut path as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlNormalizeURIPath(path);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNormalizeWindowsPath(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut path: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlNormalizeWindowsPath\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut path as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlNormalizeWindowsPath(path);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlOutputBufferGetContent(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlOutputBufferGetContent\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_out as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    out =
        if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlOutputBufferPtr
        } else { (*(pyobj_out as *mut PyoutputBuffer_Object)).obj };
    c_retval = xmlOutputBufferGetContent(out);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlOutputBufferWrite(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    let mut len: std::os::raw::c_int = 0;
    let mut buf: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oiz:xmlOutputBufferWrite\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_out as *mut *mut PyObject,
                        &mut len as *mut std::os::raw::c_int,
                        &mut buf as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    out =
        if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlOutputBufferPtr
        } else { (*(pyobj_out as *mut PyoutputBuffer_Object)).obj };
    c_retval = xmlOutputBufferWrite(out, len, buf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlOutputBufferWriteString(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlOutputBufferWriteString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_out as *mut *mut PyObject,
                        &mut str as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    out =
        if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlOutputBufferPtr
        } else { (*(pyobj_out as *mut PyoutputBuffer_Object)).obj };
    c_retval = xmlOutputBufferWriteString(out, str);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseAttValue(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseAttValue\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseAttValue(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseAttributeListDecl(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseAttributeListDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseAttributeListDecl(ctxt);
    let ref mut fresh72 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh72 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseCDSect(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseCDSect\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseCDSect(ctxt);
    let ref mut fresh73 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh73 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseCatalogFile(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlParseCatalogFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlParseCatalogFile(filename);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_CATALOG_ENABLED) */
/* defined(LIBXML_CATALOG_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseCharData(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cdata: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlParseCharData\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut cdata as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseCharData(ctxt, cdata);
    let ref mut fresh74 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh74 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseCharRef(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseCharRef\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseCharRef(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseChunk(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut chunk: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut terminate: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Os#ii:xmlParseChunk\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut chunk as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int,
                        &mut terminate as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseChunk(ctxt, chunk, size, terminate);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_PUSH_ENABLED) */
/* defined(LIBXML_PUSH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseComment(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseComment\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseComment(ctxt);
    let ref mut fresh75 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh75 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseContent(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseContent\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseContent(ctxt);
    let ref mut fresh76 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh76 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseDTD(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlParseDTD\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut ExternalID as *mut *mut xmlChar,
                        &mut SystemID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlParseDTD(ExternalID, SystemID);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseDoc(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlParseDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlParseDoc(cur);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseDocTypeDecl(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseDocTypeDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseDocTypeDecl(ctxt);
    let ref mut fresh77 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh77 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseDocument(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseDocument\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseDocument(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseElement(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseElement(ctxt);
    let ref mut fresh78 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh78 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseElementDecl(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseElementDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseElementDecl(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEncName(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseEncName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseEncName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEncodingDecl(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseEncodingDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseEncodingDecl(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEndTag(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseEndTag\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseEndTag(ctxt);
    let ref mut fresh79 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh79 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEntity(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlParseEntity\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlParseEntity(filename);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEntityDecl(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseEntityDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseEntityDecl(ctxt);
    let ref mut fresh80 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh80 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEntityRef(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseEntityRef\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseEntityRef(ctxt);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseExtParsedEnt(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseExtParsedEnt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseExtParsedEnt(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseExternalSubset(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlParseExternalSubset\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut ExternalID as *mut *mut xmlChar,
                        &mut SystemID as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseExternalSubset(ctxt, ExternalID, SystemID);
    let ref mut fresh81 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh81 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseFile(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlParseFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlParseFile(filename);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseMarkupDecl(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseMarkupDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseMarkupDecl(ctxt);
    let ref mut fresh82 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh82 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseMemory(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"s#i:xmlParseMemory\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlParseMemory(buffer, size);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseMisc(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseMisc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseMisc(ctxt);
    let ref mut fresh83 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh83 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseName(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseName(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseNamespace(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseNamespace\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseNamespace(ctxt);
    let ref mut fresh84 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh84 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseNmtoken(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseNmtoken\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseNmtoken(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseNotationDecl(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseNotationDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseNotationDecl(ctxt);
    let ref mut fresh85 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh85 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParsePEReference(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParsePEReference\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParsePEReference(ctxt);
    let ref mut fresh86 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh86 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParsePI(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParsePI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParsePI(ctxt);
    let ref mut fresh87 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh87 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParsePITarget(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParsePITarget\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParsePITarget(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParsePubidLiteral(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParsePubidLiteral\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParsePubidLiteral(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseQuotedString(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseQuotedString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseQuotedString(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseReference(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseReference\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseReference(ctxt);
    let ref mut fresh88 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh88 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseSDDecl(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseSDDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseSDDecl(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseStartTag(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseStartTag\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseStartTag(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseSystemLiteral(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseSystemLiteral\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseSystemLiteral(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseTextDecl(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseTextDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseTextDecl(ctxt);
    let ref mut fresh89 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh89 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseURI(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlURIPtr = 0 as *mut xmlURI;
    let mut str: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlParseURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlParseURI(str);
    py_retval = libxml_xmlURIPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseURIRaw(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlURIPtr = 0 as *mut xmlURI;
    let mut str: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut raw: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlParseURIRaw\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut std::os::raw::c_char,
                        &mut raw as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlParseURIRaw(str, raw);
    py_retval = libxml_xmlURIPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseURIReference(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_uri: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlParseURIReference\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_uri as *mut *mut PyObject,
                        &mut str as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    uri =
        if pyobj_uri == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_uri as *mut PyURI_Object)).obj };
    c_retval = xmlParseURIReference(uri, str);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseVersionInfo(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseVersionInfo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseVersionInfo(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseVersionNum(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseVersionNum\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlParseVersionNum(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseXMLDecl(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParseXMLDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParseXMLDecl(ctxt);
    let ref mut fresh90 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh90 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserGetDirectory(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlParserGetDirectory\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlParserGetDirectory(filename);
    py_retval = libxml_charPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserGetDoc(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParserGetDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = (*ctxt).myDoc;
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserGetIsValid(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParserGetIsValid\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = (*ctxt).valid;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserGetWellFormed(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParserGetWellFormed\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = (*ctxt).wellFormed;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserHandlePEReference(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParserHandlePEReference\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParserHandlePEReference(ctxt);
    let ref mut fresh91 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh91 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserHandleReference(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlParserHandleReference\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlParserHandleReference(ctxt);
    let ref mut fresh92 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh92 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserInputBufferGrow(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: *mut PyObject = 0 as *mut PyObject;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlParserInputBufferGrow\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_in as *mut *mut PyObject,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    in_0 =
        if pyobj_in == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserInputBufferPtr
        } else { (*(pyobj_in as *mut PyinputBuffer_Object)).obj };
    c_retval = xmlParserInputBufferGrow(in_0, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserInputBufferPush(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: *mut PyObject = 0 as *mut PyObject;
    let mut len: std::os::raw::c_int = 0;
    let mut buf: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oiz:xmlParserInputBufferPush\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_in as *mut *mut PyObject,
                        &mut len as *mut std::os::raw::c_int,
                        &mut buf as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    in_0 =
        if pyobj_in == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserInputBufferPtr
        } else { (*(pyobj_in as *mut PyinputBuffer_Object)).obj };
    c_retval = xmlParserInputBufferPush(in_0, len, buf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserInputBufferRead(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: *mut PyObject = 0 as *mut PyObject;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlParserInputBufferRead\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_in as *mut *mut PyObject,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    in_0 =
        if pyobj_in == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserInputBufferPtr
        } else { (*(pyobj_in as *mut PyinputBuffer_Object)).obj };
    c_retval = xmlParserInputBufferRead(in_0, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetLineNumbers(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut linenumbers: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlParserSetLineNumbers\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut linenumbers as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    (*ctxt).linenumbers = linenumbers;
    let ref mut fresh93 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh93 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetLoadSubset(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut loadsubset: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlParserSetLoadSubset\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut loadsubset as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    (*ctxt).loadsubset = loadsubset;
    let ref mut fresh94 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh94 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetPedantic(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut pedantic: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlParserSetPedantic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pedantic as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    (*ctxt).pedantic = pedantic;
    let ref mut fresh95 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh95 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetReplaceEntities(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut replaceEntities: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlParserSetReplaceEntities\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut replaceEntities as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    (*ctxt).replaceEntities = replaceEntities;
    let ref mut fresh96 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh96 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetValidate(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut validate: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlParserSetValidate\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut validate as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    (*ctxt).validate = validate;
    let ref mut fresh97 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh97 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPathToURI(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut path: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlPathToURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut path as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlPathToURI(path);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPedanticParserDefault(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlPedanticParserDefault\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlPedanticParserDefault(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPopInput(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlChar = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlPopInput\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlPopInput(ctxt);
    py_retval = libxml_intWrap(c_retval as std::os::raw::c_int);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPreviousElementSibling(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlPreviousElementSibling\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlPreviousElementSibling(node);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPrintURI(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut stream: *mut FILE = 0 as *mut FILE;
    let mut pyobj_stream: *mut PyObject = 0 as *mut PyObject;
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_uri: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlPrintURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_stream as *mut *mut PyObject,
                        &mut pyobj_uri as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    stream =
        if pyobj_stream == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_stream).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_stream).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_stream)
        } else { stdout };
    uri =
        if pyobj_uri == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_uri as *mut PyURI_Object)).obj };
    xmlPrintURI(stream, uri);
    let ref mut fresh98 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh98 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReadDoc(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzzi:xmlReadDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlReadDoc(cur, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReadFd(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut fd: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"izzi:xmlReadFd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut fd as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlReadFd(fd, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReadFile(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzi:xmlReadFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlReadFile(filename, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReadMemory(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"s#izzi:xmlReadMemory\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlReadMemory(buffer, size, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderForDoc(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzzi:xmlReaderForDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlReaderForDoc(cur, URL, encoding, options);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderForFd(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut fd: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"izzi:xmlReaderForFd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut fd as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlReaderForFd(fd, URL, encoding, options);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderForFile(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzi:xmlReaderForFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlReaderForFile(filename, encoding, options);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderForMemory(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut size: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zizzi:xmlReaderForMemory\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut size as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlReaderForMemory(buffer, size, URL, encoding, options);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewDoc(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozzzi:xmlReaderNewDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut cur as *mut *mut xmlChar,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlReaderNewDoc(reader, cur, URL, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewFd(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut fd: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oizzi:xmlReaderNewFd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut fd as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlReaderNewFd(reader, fd, URL, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewFile(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozzi:xmlReaderNewFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlReaderNewFile(reader, filename, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewMemory(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut size: std::os::raw::c_int = 0;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozizzi:xmlReaderNewMemory\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut size as *mut std::os::raw::c_int,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval =
        xmlReaderNewMemory(reader, buffer, size, URL, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewWalker(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlReaderNewWalker\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlReaderNewWalker(reader, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderWalker(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlReaderWalker\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlReaderWalker(doc);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReconciliateNs(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_tree: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlReconciliateNs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_tree as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    tree =
        if pyobj_tree == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_tree as *mut PyxmlNode_Object)).obj };
    c_retval = xmlReconciliateNs(doc, tree);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRecoverDoc(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlRecoverDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlRecoverDoc(cur);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRecoverFile(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlRecoverFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlRecoverFile(filename);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRecoverMemory(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut py_buffsize0: std::os::raw::c_int = 0;
    let mut size: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"s#i:xmlRecoverMemory\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut py_buffsize0 as *mut std::os::raw::c_int,
                        &mut size as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlRecoverMemory(buffer, size);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegFreeRegexp(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut regexp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut pyobj_regexp: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlRegFreeRegexp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_regexp as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    regexp =
        if pyobj_regexp == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRegexpPtr
        } else { (*(pyobj_regexp as *mut PyxmlReg_Object)).obj };
    xmlRegFreeRegexp(regexp);
    let ref mut fresh99 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh99 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_REGEXP_ENABLED) */
/* defined(LIBXML_REGEXP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegexpCompile(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut regexp: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlRegexpCompile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut regexp as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlRegexpCompile(regexp);
    py_retval = libxml_xmlRegexpPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_REGEXP_ENABLED) */
/* defined(LIBXML_REGEXP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegexpExec(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut comp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut pyobj_comp: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlRegexpExec\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_comp as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    comp =
        if pyobj_comp == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRegexpPtr
        } else { (*(pyobj_comp as *mut PyxmlReg_Object)).obj };
    c_retval = xmlRegexpExec(comp, content);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_REGEXP_ENABLED) */
/* defined(LIBXML_REGEXP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegexpIsDeterminist(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut comp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut pyobj_comp: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlRegexpIsDeterminist\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_comp as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    comp =
        if pyobj_comp == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRegexpPtr
        } else { (*(pyobj_comp as *mut PyxmlReg_Object)).obj };
    c_retval = xmlRegexpIsDeterminist(comp);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_REGEXP_ENABLED) */
/* defined(LIBXML_REGEXP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegexpPrint(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut regexp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut pyobj_regexp: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlRegexpPrint\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_regexp as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    regexp =
        if pyobj_regexp == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRegexpPtr
        } else { (*(pyobj_regexp as *mut PyxmlReg_Object)).obj };
    xmlRegexpPrint(output, regexp);
    let ref mut fresh100 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh100 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_REGEXP_ENABLED) */
/* defined(LIBXML_REGEXP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegisterDefaultInputCallbacks(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    xmlRegisterDefaultInputCallbacks();
    let ref mut fresh101 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh101 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegisterDefaultOutputCallbacks(mut self_0:
                                                                      *mut PyObject,
                                                                  mut args:
                                                                      *mut PyObject)
 -> *mut PyObject {
    xmlRegisterDefaultOutputCallbacks();
    let ref mut fresh102 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh102 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegisterHTTPPostCallbacks(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    xmlRegisterHTTPPostCallbacks();
    let ref mut fresh103 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh103 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_OUTPUT_ENABLED) && defined(LIBXML_HTTP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGCleanupTypes(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    xmlRelaxNGCleanupTypes();
    let ref mut fresh104 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh104 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGDump(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlRelaxNGDump\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_schema as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    schema =
        if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGPtr
        } else { (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj };
    xmlRelaxNGDump(output, schema);
    let ref mut fresh105 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh105 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGDumpTree(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlRelaxNGDumpTree\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_schema as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    schema =
        if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGPtr
        } else { (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj };
    xmlRelaxNGDumpTree(output, schema);
    let ref mut fresh106 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh106 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGFree(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlRelaxNGFree\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_schema as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    schema =
        if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGPtr
        } else { (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj };
    xmlRelaxNGFree(schema);
    let ref mut fresh107 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh107 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGFreeParserCtxt(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlRelaxNGFreeParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyrelaxNgParserCtxt_Object)).obj };
    xmlRelaxNGFreeParserCtxt(ctxt);
    let ref mut fresh108 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh108 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGInitTypes(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    c_retval = xmlRelaxNGInitTypes();
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGNewDocParserCtxt(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGParserCtxtPtr =
        0 as *mut xmlRelaxNGParserCtxt;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlRelaxNGNewDocParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlRelaxNGNewDocParserCtxt(doc);
    py_retval = libxml_xmlRelaxNGParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGNewMemParserCtxt(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGParserCtxtPtr =
        0 as *mut xmlRelaxNGParserCtxt;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut size: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlRelaxNGNewMemParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut size as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlRelaxNGNewMemParserCtxt(buffer, size);
    py_retval = libxml_xmlRelaxNGParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGNewParserCtxt(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGParserCtxtPtr =
        0 as *mut xmlRelaxNGParserCtxt;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlRelaxNGNewParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URL as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlRelaxNGNewParserCtxt(URL);
    py_retval = libxml_xmlRelaxNGParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGNewValidCtxt(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlRelaxNGNewValidCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_schema as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    schema =
        if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGPtr
        } else { (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj };
    c_retval = xmlRelaxNGNewValidCtxt(schema);
    py_retval = libxml_xmlRelaxNGValidCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGParse(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut ctxt: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlRelaxNGParse\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyrelaxNgParserCtxt_Object)).obj };
    c_retval = xmlRelaxNGParse(ctxt);
    py_retval = libxml_xmlRelaxNGPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidateDoc(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlRelaxNGValidateDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlRelaxNGValidateDoc(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidateFullElement(mut self_0:
                                                                  *mut PyObject,
                                                              mut args:
                                                                  *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlRelaxNGValidateFullElement\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlRelaxNGValidateFullElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidatePopElement(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlRelaxNGValidatePopElement\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlRelaxNGValidatePopElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidatePushCData(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut data: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozi:xmlRelaxNGValidatePushCData\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut data as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj };
    c_retval = xmlRelaxNGValidatePushCData(ctxt, data, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidatePushElement(mut self_0:
                                                                  *mut PyObject,
                                                              mut args:
                                                                  *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlRelaxNGValidatePushElement\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlRelaxNGValidatePushElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxParserSetFlag(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut flags: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlRelaxParserSetFlag\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut flags as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyrelaxNgParserCtxt_Object)).obj };
    c_retval = xmlRelaxParserSetFlag(ctxt, flags);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRemoveID(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlRemoveID\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_attr as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    attr =
        if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_attr as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    c_retval = xmlRemoveID(doc, attr);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRemoveProp(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlRemoveProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    c_retval = xmlRemoveProp(cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRemoveRef(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlRemoveRef\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_attr as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    attr =
        if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_attr as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    c_retval = xmlRemoveRef(doc, attr);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReplaceNode(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut old: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_old: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlReplaceNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_old as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    old =
        if pyobj_old == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_old as *mut PyxmlNode_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlReplaceNode(old, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlResetError(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut err: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_err: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlResetError\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_err as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    err =
        if pyobj_err == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlErrorPtr
        } else { (*(pyobj_err as *mut PyError_Object)).obj };
    xmlResetError(err);
    let ref mut fresh109 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh109 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlResetLastError(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    xmlResetLastError();
    let ref mut fresh110 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh110 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSAXDefaultVersion(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut version: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlSAXDefaultVersion\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut version as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlSAXDefaultVersion(version);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveFile(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"zO:xmlSaveFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlSaveFile(filename, cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveFileEnc(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"zOz:xmlSaveFileEnc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut encoding as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlSaveFileEnc(filename, cur, encoding);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveFormatFile(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut format: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zOi:xmlSaveFormatFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut format as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlSaveFormatFile(filename, cur, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveFormatFileEnc(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut format: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zOzi:xmlSaveFormatFileEnc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut format as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlSaveFormatFileEnc(filename, cur, encoding, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveUri(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_uri: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSaveUri\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_uri as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    uri =
        if pyobj_uri == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_uri as *mut PyURI_Object)).obj };
    c_retval = xmlSaveUri(uri);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlScanName(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlScanName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlScanName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaCleanupTypes(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    xmlSchemaCleanupTypes();
    let ref mut fresh111 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh111 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaCollapseString(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlSchemaCollapseString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlSchemaCollapseString(value);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaDump(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlSchemaDump\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_output as *mut *mut PyObject,
                        &mut pyobj_schema as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    output =
        if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut FILE
        } else if (*pyobj_output).ob_type ==
                      &mut PyFile_Type as *mut PyTypeObject ||
                      PyType_IsSubtype((*pyobj_output).ob_type,
                                       &mut PyFile_Type) != 0 {
            PyFile_AsFile(pyobj_output)
        } else { stdout };
    schema =
        if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaPtr
        } else { (*(pyobj_schema as *mut PySchema_Object)).obj };
    xmlSchemaDump(output, schema);
    let ref mut fresh112 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh112 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaFree(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSchemaFree\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_schema as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    schema =
        if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaPtr
        } else { (*(pyobj_schema as *mut PySchema_Object)).obj };
    xmlSchemaFree(schema);
    let ref mut fresh113 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh113 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaFreeParserCtxt(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSchemaFreeParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaParserCtxt_Object)).obj };
    xmlSchemaFreeParserCtxt(ctxt);
    let ref mut fresh114 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh114 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaInitTypes(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    xmlSchemaInitTypes();
    let ref mut fresh115 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh115 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaIsValid(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSchemaIsValid\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj };
    c_retval = xmlSchemaIsValid(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaNewDocParserCtxt(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSchemaNewDocParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlSchemaNewDocParserCtxt(doc);
    py_retval = libxml_xmlSchemaParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaNewMemParserCtxt(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut buffer: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut size: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlSchemaNewMemParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut buffer as *mut *mut std::os::raw::c_char,
                        &mut size as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlSchemaNewMemParserCtxt(buffer, size);
    py_retval = libxml_xmlSchemaParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaNewParserCtxt(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlSchemaNewParserCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut URL as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlSchemaNewParserCtxt(URL);
    py_retval = libxml_xmlSchemaParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaNewValidCtxt(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSchemaNewValidCtxt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_schema as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    schema =
        if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaPtr
        } else { (*(pyobj_schema as *mut PySchema_Object)).obj };
    c_retval = xmlSchemaNewValidCtxt(schema);
    py_retval = libxml_xmlSchemaValidCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaParse(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut ctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSchemaParse\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaParserCtxt_Object)).obj };
    c_retval = xmlSchemaParse(ctxt);
    py_retval = libxml_xmlSchemaPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaSetValidOptions(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlSchemaSetValidOptions\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj };
    c_retval = xmlSchemaSetValidOptions(ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidCtxtGetOptions(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSchemaValidCtxtGetOptions\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj };
    c_retval = xmlSchemaValidCtxtGetOptions(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidCtxtGetParserCtxt(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSchemaValidCtxtGetParserCtxt\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj };
    c_retval = xmlSchemaValidCtxtGetParserCtxt(ctxt);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidateDoc(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlSchemaValidateDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlSchemaValidateDoc(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidateFile(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozi:xmlSchemaValidateFile\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut filename as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj };
    c_retval = xmlSchemaValidateFile(ctxt, filename, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidateOneElement(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlSchemaValidateOneElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj };
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlSchemaValidateOneElement(ctxt, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidateSetFilename(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut vctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_vctxt: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlSchemaValidateSetFilename\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_vctxt as *mut *mut PyObject,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    vctxt =
        if pyobj_vctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaValidCtxtPtr
        } else { (*(pyobj_vctxt as *mut PySchemaValidCtxt_Object)).obj };
    xmlSchemaValidateSetFilename(vctxt, filename);
    let ref mut fresh116 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh116 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaWhiteSpaceReplace(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlSchemaWhiteSpaceReplace\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlSchemaWhiteSpaceReplace(value);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSearchNs(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut nameSpace: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOz:xmlSearchNs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut nameSpace as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlSearchNs(doc, node, nameSpace);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSearchNsByHref(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut href: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOz:xmlSearchNsByHref\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut href as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlSearchNsByHref(doc, node, href);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetCompressMode(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut mode: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlSetCompressMode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut mode as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    xmlSetCompressMode(mode);
    let ref mut fresh117 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh117 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetDocCompressMode(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut mode: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlSetDocCompressMode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut mode as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    xmlSetDocCompressMode(doc, mode);
    let ref mut fresh118 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh118 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetListDoc(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut list: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_list: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlSetListDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_list as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    list =
        if pyobj_list == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_list as *mut PyxmlNode_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    xmlSetListDoc(list, doc);
    let ref mut fresh119 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh119 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetNs(mut self_0: *mut PyObject,
                                         mut args: *mut PyObject)
 -> *mut PyObject {
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlSetNs\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    xmlSetNs(node, ns);
    let ref mut fresh120 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh120 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetNsProp(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOzz:xmlSetNsProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlSetNsProp(node, ns, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetProp(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlSetProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlSetProp(node, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetTreeDoc(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_tree: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlSetTreeDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_tree as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    tree =
        if pyobj_tree == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_tree as *mut PyxmlNode_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    xmlSetTreeDoc(tree, doc);
    let ref mut fresh121 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh121 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetupParserForBuffer(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut buffer: *mut xmlChar = 0 as *mut xmlChar;
    let mut filename: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlSetupParserForBuffer\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut buffer as *mut *mut xmlChar,
                        &mut filename as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlSetupParserForBuffer(ctxt, buffer, filename);
    let ref mut fresh122 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh122 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_SAX1_ENABLED) */
/* defined(LIBXML_SAX1_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlShellPrintNode(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlShellPrintNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    xmlShellPrintNode(node);
    let ref mut fresh123 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh123 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_OUTPUT_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlShellPrintXPathError(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut errorType: std::os::raw::c_int = 0;
    let mut arg: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"iz:xmlShellPrintXPathError\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut errorType as *mut std::os::raw::c_int,
                        &mut arg as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    xmlShellPrintXPathError(errorType, arg);
    let ref mut fresh124 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh124 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSkipBlankChars(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlSkipBlankChars\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlSkipBlankChars(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStopParser(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlStopParser\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    xmlStopParser(ctxt);
    let ref mut fresh125 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh125 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrEqual(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlStrEqual\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str1 as *mut *mut xmlChar,
                        &mut str2 as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrEqual(str1, str2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrQEqual(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut pref: *mut xmlChar = 0 as *mut xmlChar;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zzz:xmlStrQEqual\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pref as *mut *mut xmlChar,
                        &mut name as *mut *mut xmlChar,
                        &mut str as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrQEqual(pref, name, str);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrcasecmp(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlStrcasecmp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str1 as *mut *mut xmlChar,
                        &mut str2 as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrcasecmp(str1, str2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrcasestr(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlStrcasestr\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar,
                        &mut val as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrcasestr(str, val);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrcat(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut add: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlStrcat\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar,
                        &mut add as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrcat(cur, add);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrchr(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: xmlChar = 0;
    if PyArg_ParseTuple(args,
                        b"zc:xmlStrchr\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar,
                        &mut val as *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrchr(str, val);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrcmp(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlStrcmp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str1 as *mut *mut xmlChar,
                        &mut str2 as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrcmp(str1, str2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrdup(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlStrdup\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrdup(cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStringDecodeEntities(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut what: std::os::raw::c_int = 0;
    let mut end: xmlChar = 0;
    let mut end2: xmlChar = 0;
    let mut end3: xmlChar = 0;
    if PyArg_ParseTuple(args,
                        b"Oziccc:xmlStringDecodeEntities\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut str as *mut *mut xmlChar,
                        &mut what as *mut std::os::raw::c_int,
                        &mut end as *mut xmlChar, &mut end2 as *mut xmlChar,
                        &mut end3 as *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval = xmlStringDecodeEntities(ctxt, str, what, end, end2, end3);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStringGetNodeList(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlStringGetNodeList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    c_retval = xmlStringGetNodeList(doc, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStringLenDecodeEntities(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    let mut what: std::os::raw::c_int = 0;
    let mut end: xmlChar = 0;
    let mut end2: xmlChar = 0;
    let mut end3: xmlChar = 0;
    if PyArg_ParseTuple(args,
                        b"Oziiccc:xmlStringLenDecodeEntities\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut str as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int,
                        &mut what as *mut std::os::raw::c_int,
                        &mut end as *mut xmlChar, &mut end2 as *mut xmlChar,
                        &mut end3 as *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj };
    c_retval =
        xmlStringLenDecodeEntities(ctxt, str, len, what, end, end2, end3);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStringLenGetNodeList(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozi:xmlStringLenGetNodeList\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut value as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as *mut xmlDoc;
    c_retval = xmlStringLenGetNodeList(doc, value, len);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrlen(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlStrlen\x00" as *const u8 as *const std::os::raw::c_char
                            as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrlen(str);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrncasecmp(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzi:xmlStrncasecmp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str1 as *mut *mut xmlChar,
                        &mut str2 as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrncasecmp(str1, str2, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrncat(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut add: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzi:xmlStrncat\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar,
                        &mut add as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrncat(cur, add, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrncatNew(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzi:xmlStrncatNew\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str1 as *mut *mut xmlChar,
                        &mut str2 as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrncatNew(str1, str2, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrncmp(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zzi:xmlStrncmp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str1 as *mut *mut xmlChar,
                        &mut str2 as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrncmp(str1, str2, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrndup(mut self_0: *mut PyObject,
                                           mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlStrndup\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut cur as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrndup(cur, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrstr(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlStrstr\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar,
                        &mut val as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrstr(str, val);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrsub(mut self_0: *mut PyObject,
                                          mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut start: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zii:xmlStrsub\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar,
                        &mut start as *mut std::os::raw::c_int,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlStrsub(str, start, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSubstituteEntitiesDefault(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlSubstituteEntitiesDefault\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlSubstituteEntitiesDefault(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextConcat(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozi:xmlTextConcat\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut content as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlTextConcat(node, content, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextMerge(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut first: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_first: *mut PyObject = 0 as *mut PyObject;
    let mut second: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_second: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlTextMerge\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_first as *mut *mut PyObject,
                        &mut pyobj_second as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    first =
        if pyobj_first == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_first as *mut PyxmlNode_Object)).obj };
    second =
        if pyobj_second == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_second as *mut PyxmlNode_Object)).obj };
    c_retval = xmlTextMerge(first, second);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderAttributeCount(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderAttributeCount\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderAttributeCount(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderByteConsumed(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_long = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderByteConsumed\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderByteConsumed(reader);
    py_retval = libxml_longWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderClose(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderClose\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderClose(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstBaseUri(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderConstBaseUri\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstBaseUri(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstEncoding(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderConstEncoding\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstEncoding(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstLocalName(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderConstLocalName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstLocalName(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstName(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderConstName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstName(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstNamespaceUri(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderConstNamespaceUri\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstNamespaceUri(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstPrefix(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderConstPrefix\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstPrefix(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstString(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlTextReaderConstString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut str as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstString(reader, str);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstValue(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderConstValue\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstValue(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstXmlLang(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderConstXmlLang\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstXmlLang(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstXmlVersion(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderConstXmlVersion\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderConstXmlVersion(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderCurrentDoc(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderCurrentDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderCurrentDoc(reader);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderCurrentNode(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderCurrentNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderCurrentNode(reader);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderDepth(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderDepth\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderDepth(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderExpand(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderExpand\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderExpand(reader);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetAttribute(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlTextReaderGetAttribute\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderGetAttribute(reader, name);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetAttributeNo(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut no: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlTextReaderGetAttributeNo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut no as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderGetAttributeNo(reader, no);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetAttributeNs(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlTextReaderGetAttributeNs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut localName as *mut *mut xmlChar,
                        &mut namespaceURI as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderGetAttributeNs(reader, localName, namespaceURI);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetParserColumnNumber(mut self_0:
                                                                       *mut PyObject,
                                                                   mut args:
                                                                       *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderGetParserColumnNumber\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderGetParserColumnNumber(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetParserLineNumber(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderGetParserLineNumber\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderGetParserLineNumber(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetParserProp(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut prop: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlTextReaderGetParserProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut prop as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderGetParserProp(reader, prop);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetRemainder(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserInputBufferPtr =
        0 as *mut xmlParserInputBuffer;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderGetRemainder\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderGetRemainder(reader);
    py_retval = libxml_xmlParserInputBufferPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderHasAttributes(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderHasAttributes\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderHasAttributes(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderHasValue(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderHasValue\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderHasValue(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderIsDefault(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderIsDefault\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderIsDefault(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderIsEmptyElement(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderIsEmptyElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderIsEmptyElement(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderIsNamespaceDecl(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderIsNamespaceDecl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderIsNamespaceDecl(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderIsValid(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderIsValid\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderIsValid(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderLocatorBaseURI(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut locator: xmlTextReaderLocatorPtr = 0 as *mut std::os::raw::c_void;
    let mut pyobj_locator: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderLocatorBaseURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_locator as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    locator =
        if pyobj_locator == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut std::os::raw::c_void
        } else {
            (*(pyobj_locator as *mut PyxmlTextReaderLocator_Object)).obj
        };
    c_retval = xmlTextReaderLocatorBaseURI(locator);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderLocatorLineNumber(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut locator: xmlTextReaderLocatorPtr = 0 as *mut std::os::raw::c_void;
    let mut pyobj_locator: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderLocatorLineNumber\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_locator as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    locator =
        if pyobj_locator == &mut _Py_NoneStruct as *mut PyObject {
            0 as *mut std::os::raw::c_void
        } else {
            (*(pyobj_locator as *mut PyxmlTextReaderLocator_Object)).obj
        };
    c_retval = xmlTextReaderLocatorLineNumber(locator);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderLookupNamespace(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlTextReaderLookupNamespace\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut prefix as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderLookupNamespace(reader, prefix);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToAttribute(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlTextReaderMoveToAttribute\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderMoveToAttribute(reader, name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToAttributeNo(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut no: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlTextReaderMoveToAttributeNo\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut no as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderMoveToAttributeNo(reader, no);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToAttributeNs(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlTextReaderMoveToAttributeNs\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut localName as *mut *mut xmlChar,
                        &mut namespaceURI as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval =
        xmlTextReaderMoveToAttributeNs(reader, localName, namespaceURI);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToElement(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderMoveToElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderMoveToElement(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToFirstAttribute(mut self_0:
                                                                      *mut PyObject,
                                                                  mut args:
                                                                      *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderMoveToFirstAttribute\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderMoveToFirstAttribute(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToNextAttribute(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderMoveToNextAttribute\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderMoveToNextAttribute(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderNext(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderNext\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderNext(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderNextSibling(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderNextSibling\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderNextSibling(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderNodeType(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderNodeType\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderNodeType(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderNormalization(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderNormalization\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderNormalization(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderPreserve(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderPreserve\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderPreserve(reader);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderQuoteChar(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderQuoteChar\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderQuoteChar(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderRead(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderRead\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderRead(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadAttributeValue(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderReadAttributeValue\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderReadAttributeValue(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadInnerXml(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderReadInnerXml\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderReadInnerXml(reader);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_WRITER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_WRITER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadOuterXml(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderReadOuterXml\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderReadOuterXml(reader);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_WRITER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_WRITER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadState(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderReadState\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderReadState(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadString(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderReadString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderReadString(reader);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderRelaxNGSetSchema(mut self_0:
                                                                  *mut PyObject,
                                                              mut args:
                                                                  *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlTextReaderRelaxNGSetSchema\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut pyobj_schema as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    schema =
        if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGPtr
        } else { (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj };
    c_retval = xmlTextReaderRelaxNGSetSchema(reader, schema);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderRelaxNGValidate(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut rng: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlTextReaderRelaxNGValidate\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut rng as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderRelaxNGValidate(reader, rng);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderRelaxNGValidateCtxt(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlTextReaderRelaxNGValidateCtxt\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlRelaxNGValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj };
    c_retval = xmlTextReaderRelaxNGValidateCtxt(reader, ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSchemaValidate(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut xsd: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlTextReaderSchemaValidate\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut xsd as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderSchemaValidate(reader, xsd);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSchemaValidateCtxt(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOi:xmlTextReaderSchemaValidateCtxt\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj };
    c_retval = xmlTextReaderSchemaValidateCtxt(reader, ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSetParserProp(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut prop: std::os::raw::c_int = 0;
    let mut value: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oii:xmlTextReaderSetParserProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut prop as *mut std::os::raw::c_int,
                        &mut value as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderSetParserProp(reader, prop, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSetSchema(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlTextReaderSetSchema\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut pyobj_schema as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    schema =
        if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlSchemaPtr
        } else { (*(pyobj_schema as *mut PySchema_Object)).obj };
    c_retval = xmlTextReaderSetSchema(reader, schema);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSetup(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_input: *mut PyObject = 0 as *mut PyObject;
    let mut URL: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut encoding: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OOzzi:xmlTextReaderSetup\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject,
                        &mut pyobj_input as *mut *mut PyObject,
                        &mut URL as *mut *mut std::os::raw::c_char,
                        &mut encoding as *mut *mut std::os::raw::c_char,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    input =
        if pyobj_input == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlParserInputBufferPtr
        } else { (*(pyobj_input as *mut PyinputBuffer_Object)).obj };
    c_retval = xmlTextReaderSetup(reader, input, URL, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderStandalone(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlTextReaderStandalone\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_reader as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    reader =
        if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlTextReaderPtr
        } else { (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj };
    c_retval = xmlTextReaderStandalone(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_READER_ENABLED) */
/* defined(LIBXML_READER_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefDefaultBufferSize(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefDefaultBufferSize\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut v as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefDefaultBufferSize(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefDoValidityCheckingDefaultValue(mut self_0:
                                                                            *mut PyObject,
                                                                        mut args:
                                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefDoValidityCheckingDefaultValue\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut v as *mut std::os::raw::c_int) ==
           0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefDoValidityCheckingDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefGetWarningsDefaultValue(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefGetWarningsDefaultValue\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut v as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefGetWarningsDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefIndentTreeOutput(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefIndentTreeOutput\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut v as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefIndentTreeOutput(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefKeepBlanksDefaultValue(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefKeepBlanksDefaultValue\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut v as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefKeepBlanksDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefLineNumbersDefaultValue(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefLineNumbersDefaultValue\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut v as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefLineNumbersDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefLoadExtDtdDefaultValue(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefLoadExtDtdDefaultValue\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut v as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefLoadExtDtdDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefParserDebugEntities(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefParserDebugEntities\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut v as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefParserDebugEntities(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefPedanticParserDefaultValue(mut self_0:
                                                                        *mut PyObject,
                                                                    mut args:
                                                                        *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefPedanticParserDefaultValue\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut v as *mut std::os::raw::c_int) ==
           0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefPedanticParserDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefSaveNoEmptyTags(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefSaveNoEmptyTags\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut v as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefSaveNoEmptyTags(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefSubstituteEntitiesDefaultValue(mut self_0:
                                                                            *mut PyObject,
                                                                        mut args:
                                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut v: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlThrDefSubstituteEntitiesDefaultValue\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut v as *mut std::os::raw::c_int) ==
           0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefSubstituteEntitiesDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefTreeIndentString(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut v: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlThrDefTreeIndentString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut v as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlThrDefTreeIndentString(v);
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsAegeanNumbers(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsAegeanNumbers\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsAegeanNumbers(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsAlphabeticPresentationForms(mut self_0:
                                                                        *mut PyObject,
                                                                    mut args:
                                                                        *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsAlphabeticPresentationForms\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsAlphabeticPresentationForms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArabic(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsArabic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsArabic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArabicPresentationFormsA(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsArabicPresentationFormsA\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsArabicPresentationFormsA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArabicPresentationFormsB(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsArabicPresentationFormsB\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsArabicPresentationFormsB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArmenian(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsArmenian\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsArmenian(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArrows(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsArrows\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsArrows(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBasicLatin(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsBasicLatin\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsBasicLatin(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBengali(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsBengali\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsBengali(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBlock(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut block: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"iz:xmlUCSIsBlock\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int,
                        &mut block as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsBlock(code, block);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBlockElements(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsBlockElements\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsBlockElements(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBopomofo(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsBopomofo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsBopomofo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBopomofoExtended(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsBopomofoExtended\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsBopomofoExtended(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBoxDrawing(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsBoxDrawing\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsBoxDrawing(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBraillePatterns(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsBraillePatterns\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsBraillePatterns(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBuhid(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsBuhid\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsBuhid(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsByzantineMusicalSymbols(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsByzantineMusicalSymbols\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsByzantineMusicalSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKCompatibility(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCJKCompatibility\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCJKCompatibility(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKCompatibilityForms(mut self_0:
                                                                  *mut PyObject,
                                                              mut args:
                                                                  *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCJKCompatibilityForms\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCJKCompatibilityForms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKCompatibilityIdeographs(mut self_0:
                                                                       *mut PyObject,
                                                                   mut args:
                                                                       *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCJKCompatibilityIdeographs\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCJKCompatibilityIdeographs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKCompatibilityIdeographsSupplement(mut self_0:
                                                                                 *mut PyObject,
                                                                             mut args:
                                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCJKCompatibilityIdeographsSupplement\x00"
                            as *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCJKCompatibilityIdeographsSupplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKRadicalsSupplement(mut self_0:
                                                                  *mut PyObject,
                                                              mut args:
                                                                  *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCJKRadicalsSupplement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCJKRadicalsSupplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKSymbolsandPunctuation(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCJKSymbolsandPunctuation\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCJKSymbolsandPunctuation(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKUnifiedIdeographs(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCJKUnifiedIdeographs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCJKUnifiedIdeographs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKUnifiedIdeographsExtensionA(mut self_0:
                                                                           *mut PyObject,
                                                                       mut args:
                                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCJKUnifiedIdeographsExtensionA\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCJKUnifiedIdeographsExtensionA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKUnifiedIdeographsExtensionB(mut self_0:
                                                                           *mut PyObject,
                                                                       mut args:
                                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCJKUnifiedIdeographsExtensionB\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCJKUnifiedIdeographsExtensionB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCat(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    let mut cat: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"iz:xmlUCSIsCat\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int,
                        &mut cat as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCat(code, cat);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatC(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatC\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatC(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatCc(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatCc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatCc(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatCf(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatCf\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatCf(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatCo(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatCo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatCo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatCs(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatCs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatCs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatL(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatL\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatL(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLl(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatLl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatLl(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLm(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatLm\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatLm(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLo(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatLo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatLo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLt(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatLt\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatLt(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLu(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatLu\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatLu(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatM(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatM\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatM(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatMc(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatMc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatMc(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatMe(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatMe\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatMe(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatMn(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatMn\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatMn(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatN(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatN\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatN(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatNd(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatNd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatNd(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatNl(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatNl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatNl(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatNo(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatNo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatNo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatP(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatP\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatP(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPc(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatPc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatPc(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPd(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatPd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatPd(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPe(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatPe\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatPe(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPf(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatPf\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatPf(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPi(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatPi\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatPi(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPo(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatPo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatPo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPs(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatPs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatPs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatS(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatS\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatS(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatSc(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatSc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatSc(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatSk(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatSk\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatSk(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatSm(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatSm\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatSm(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatSo(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatSo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatSo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatZ(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatZ\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatZ(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatZl(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatZl\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatZl(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatZp(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatZp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatZp(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatZs(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCatZs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCatZs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCherokee(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCherokee\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCherokee(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCombiningDiacriticalMarks(mut self_0:
                                                                      *mut PyObject,
                                                                  mut args:
                                                                      *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCombiningDiacriticalMarks\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCombiningDiacriticalMarks(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCombiningDiacriticalMarksforSymbols(mut self_0:
                                                                                *mut PyObject,
                                                                            mut args:
                                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCombiningDiacriticalMarksforSymbols\x00"
                            as *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCombiningDiacriticalMarksforSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCombiningHalfMarks(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCombiningHalfMarks\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCombiningHalfMarks(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCombiningMarksforSymbols(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCombiningMarksforSymbols\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCombiningMarksforSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsControlPictures(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsControlPictures\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsControlPictures(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCurrencySymbols(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCurrencySymbols\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCurrencySymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCypriotSyllabary(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCypriotSyllabary\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCypriotSyllabary(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCyrillic(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCyrillic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCyrillic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCyrillicSupplement(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsCyrillicSupplement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsCyrillicSupplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsDeseret(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsDeseret\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsDeseret(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsDevanagari(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsDevanagari\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsDevanagari(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsDingbats(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsDingbats\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsDingbats(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsEnclosedAlphanumerics(mut self_0:
                                                                  *mut PyObject,
                                                              mut args:
                                                                  *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsEnclosedAlphanumerics\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsEnclosedAlphanumerics(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsEnclosedCJKLettersandMonths(mut self_0:
                                                                        *mut PyObject,
                                                                    mut args:
                                                                        *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsEnclosedCJKLettersandMonths\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsEnclosedCJKLettersandMonths(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsEthiopic(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsEthiopic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsEthiopic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGeneralPunctuation(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsGeneralPunctuation\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsGeneralPunctuation(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGeometricShapes(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsGeometricShapes\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsGeometricShapes(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGeorgian(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsGeorgian\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsGeorgian(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGothic(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsGothic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsGothic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGreek(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsGreek\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsGreek(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGreekExtended(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsGreekExtended\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsGreekExtended(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGreekandCoptic(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsGreekandCoptic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsGreekandCoptic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGujarati(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsGujarati\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsGujarati(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGurmukhi(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsGurmukhi\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsGurmukhi(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHalfwidthandFullwidthForms(mut self_0:
                                                                       *mut PyObject,
                                                                   mut args:
                                                                       *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsHalfwidthandFullwidthForms\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsHalfwidthandFullwidthForms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHangulCompatibilityJamo(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsHangulCompatibilityJamo\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsHangulCompatibilityJamo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHangulJamo(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsHangulJamo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsHangulJamo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHangulSyllables(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsHangulSyllables\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsHangulSyllables(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHanunoo(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsHanunoo\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsHanunoo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHebrew(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsHebrew\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsHebrew(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHighPrivateUseSurrogates(mut self_0:
                                                                     *mut PyObject,
                                                                 mut args:
                                                                     *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsHighPrivateUseSurrogates\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsHighPrivateUseSurrogates(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHighSurrogates(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsHighSurrogates\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsHighSurrogates(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHiragana(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsHiragana\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsHiragana(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsIPAExtensions(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsIPAExtensions\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsIPAExtensions(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsIdeographicDescriptionCharacters(mut self_0:
                                                                             *mut PyObject,
                                                                         mut args:
                                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsIdeographicDescriptionCharacters\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsIdeographicDescriptionCharacters(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKanbun(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsKanbun\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsKanbun(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKangxiRadicals(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsKangxiRadicals\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsKangxiRadicals(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKannada(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsKannada\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsKannada(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKatakana(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsKatakana\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsKatakana(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKatakanaPhoneticExtensions(mut self_0:
                                                                       *mut PyObject,
                                                                   mut args:
                                                                       *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsKatakanaPhoneticExtensions\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsKatakanaPhoneticExtensions(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKhmer(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsKhmer\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsKhmer(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKhmerSymbols(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsKhmerSymbols\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsKhmerSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLao(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLao\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLao(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLatin1Supplement(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLatin1Supplement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLatin1Supplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLatinExtendedA(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLatinExtendedA\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLatinExtendedA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLatinExtendedAdditional(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLatinExtendedAdditional\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLatinExtendedAdditional(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLatinExtendedB(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLatinExtendedB\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLatinExtendedB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLetterlikeSymbols(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLetterlikeSymbols\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLetterlikeSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLimbu(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLimbu\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLimbu(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLinearBIdeograms(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLinearBIdeograms\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLinearBIdeograms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLinearBSyllabary(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLinearBSyllabary\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLinearBSyllabary(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLowSurrogates(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsLowSurrogates\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsLowSurrogates(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMalayalam(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMalayalam\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMalayalam(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMathematicalAlphanumericSymbols(mut self_0:
                                                                            *mut PyObject,
                                                                        mut args:
                                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMathematicalAlphanumericSymbols\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMathematicalAlphanumericSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMathematicalOperators(mut self_0:
                                                                  *mut PyObject,
                                                              mut args:
                                                                  *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMathematicalOperators\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMathematicalOperators(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousMathematicalSymbolsA(mut self_0:
                                                                              *mut PyObject,
                                                                          mut args:
                                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMiscellaneousMathematicalSymbolsA\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMiscellaneousMathematicalSymbolsA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousMathematicalSymbolsB(mut self_0:
                                                                              *mut PyObject,
                                                                          mut args:
                                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMiscellaneousMathematicalSymbolsB\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMiscellaneousMathematicalSymbolsB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousSymbols(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMiscellaneousSymbols\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMiscellaneousSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousSymbolsandArrows(mut self_0:
                                                                          *mut PyObject,
                                                                      mut args:
                                                                          *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMiscellaneousSymbolsandArrows\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMiscellaneousSymbolsandArrows(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousTechnical(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMiscellaneousTechnical\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMiscellaneousTechnical(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMongolian(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMongolian\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMongolian(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMusicalSymbols(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMusicalSymbols\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMusicalSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMyanmar(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsMyanmar\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsMyanmar(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsNumberForms(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsNumberForms\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsNumberForms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOgham(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsOgham\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsOgham(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOldItalic(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsOldItalic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsOldItalic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOpticalCharacterRecognition(mut self_0:
                                                                        *mut PyObject,
                                                                    mut args:
                                                                        *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsOpticalCharacterRecognition\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsOpticalCharacterRecognition(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOriya(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsOriya\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsOriya(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOsmanya(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsOsmanya\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsOsmanya(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsPhoneticExtensions(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsPhoneticExtensions\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsPhoneticExtensions(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsPrivateUse(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsPrivateUse\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsPrivateUse(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsPrivateUseArea(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsPrivateUseArea\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsPrivateUseArea(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsRunic(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsRunic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsRunic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsShavian(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsShavian\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsShavian(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSinhala(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSinhala\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSinhala(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSmallFormVariants(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSmallFormVariants\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSmallFormVariants(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSpacingModifierLetters(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSpacingModifierLetters\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSpacingModifierLetters(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSpecials(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSpecials\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSpecials(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSuperscriptsandSubscripts(mut self_0:
                                                                      *mut PyObject,
                                                                  mut args:
                                                                      *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSuperscriptsandSubscripts\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSuperscriptsandSubscripts(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementalArrowsA(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSupplementalArrowsA\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSupplementalArrowsA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementalArrowsB(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSupplementalArrowsB\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSupplementalArrowsB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementalMathematicalOperators(mut self_0:
                                                                              *mut PyObject,
                                                                          mut args:
                                                                              *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSupplementalMathematicalOperators\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSupplementalMathematicalOperators(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementaryPrivateUseAreaA(mut self_0:
                                                                         *mut PyObject,
                                                                     mut args:
                                                                         *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSupplementaryPrivateUseAreaA\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSupplementaryPrivateUseAreaA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementaryPrivateUseAreaB(mut self_0:
                                                                         *mut PyObject,
                                                                     mut args:
                                                                         *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSupplementaryPrivateUseAreaB\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSupplementaryPrivateUseAreaB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSyriac(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsSyriac\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsSyriac(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTagalog(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsTagalog\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsTagalog(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTagbanwa(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsTagbanwa\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsTagbanwa(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTags(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsTags\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsTags(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTaiLe(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsTaiLe\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsTaiLe(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTaiXuanJingSymbols(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsTaiXuanJingSymbols\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsTaiXuanJingSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTamil(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsTamil\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsTamil(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTelugu(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsTelugu\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsTelugu(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsThaana(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsThaana\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsThaana(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsThai(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsThai\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsThai(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTibetan(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsTibetan\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsTibetan(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsUgaritic(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsUgaritic\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsUgaritic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsUnifiedCanadianAboriginalSyllabics(mut self_0:
                                                                               *mut PyObject,
                                                                           mut args:
                                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsUnifiedCanadianAboriginalSyllabics\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsUnifiedCanadianAboriginalSyllabics(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsVariationSelectors(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsVariationSelectors\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsVariationSelectors(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsVariationSelectorsSupplement(mut self_0:
                                                                         *mut PyObject,
                                                                     mut args:
                                                                         *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsVariationSelectorsSupplement\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char, &mut code as *mut std::os::raw::c_int)
           == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsVariationSelectorsSupplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsYiRadicals(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsYiRadicals\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsYiRadicals(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsYiSyllables(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsYiSyllables\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsYiSyllables(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsYijingHexagramSymbols(mut self_0:
                                                                  *mut PyObject,
                                                              mut args:
                                                                  *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut code: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlUCSIsYijingHexagramSymbols\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut code as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUCSIsYijingHexagramSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_UNICODE_ENABLED) */
/* defined(LIBXML_UNICODE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIEscape(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlURIEscape\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlURIEscape(str);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIEscapeStr(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut list: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlURIEscapeStr\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar,
                        &mut list as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlURIEscapeStr(str, list);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetAuthority(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetAuthority\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).authority;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetFragment(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetFragment\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).fragment;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetOpaque(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetOpaque\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).opaque;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetPath(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetPath\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).path;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetPort(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetPort\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).port;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetQuery(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetQuery\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).query;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetQueryRaw(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetQueryRaw\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).query_raw;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetScheme(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetScheme\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).scheme;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetServer(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetServer\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).server;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetUser(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlURIGetUser\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    c_retval = (*URI).user;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetAuthority(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut authority: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlURISetAuthority\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut authority as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    if !(*URI).authority.is_null() {
        xmlFree.expect("non-null function pointer")((*URI).authority as
                                                        *mut std::os::raw::c_void);
    }
    (*URI).authority =
        xmlStrdup(authority as *const xmlChar) as *mut std::os::raw::c_char;
    let ref mut fresh126 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh126 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetFragment(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut fragment: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlURISetFragment\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut fragment as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    if !(*URI).fragment.is_null() {
        xmlFree.expect("non-null function pointer")((*URI).fragment as
                                                        *mut std::os::raw::c_void);
    }
    (*URI).fragment =
        xmlStrdup(fragment as *const xmlChar) as *mut std::os::raw::c_char;
    let ref mut fresh127 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh127 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetOpaque(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut opaque: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlURISetOpaque\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut opaque as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    if !(*URI).opaque.is_null() {
        xmlFree.expect("non-null function pointer")((*URI).opaque as
                                                        *mut std::os::raw::c_void);
    }
    (*URI).opaque = xmlStrdup(opaque as *const xmlChar) as *mut std::os::raw::c_char;
    let ref mut fresh128 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh128 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetPath(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut path: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlURISetPath\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut path as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    if !(*URI).path.is_null() {
        xmlFree.expect("non-null function pointer")((*URI).path as
                                                        *mut std::os::raw::c_void);
    }
    (*URI).path = xmlStrdup(path as *const xmlChar) as *mut std::os::raw::c_char;
    let ref mut fresh129 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh129 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetPort(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut port: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlURISetPort\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut port as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    (*URI).port = port;
    let ref mut fresh130 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh130 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetQuery(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut query: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlURISetQuery\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut query as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    if !(*URI).query.is_null() {
        xmlFree.expect("non-null function pointer")((*URI).query as
                                                        *mut std::os::raw::c_void);
    }
    (*URI).query = xmlStrdup(query as *const xmlChar) as *mut std::os::raw::c_char;
    let ref mut fresh131 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh131 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetQueryRaw(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut query_raw: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlURISetQueryRaw\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut query_raw as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    if !(*URI).query_raw.is_null() {
        xmlFree.expect("non-null function pointer")((*URI).query_raw as
                                                        *mut std::os::raw::c_void);
    }
    (*URI).query_raw =
        xmlStrdup(query_raw as *const xmlChar) as *mut std::os::raw::c_char;
    let ref mut fresh132 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh132 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetScheme(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut scheme: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlURISetScheme\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut scheme as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    if !(*URI).scheme.is_null() {
        xmlFree.expect("non-null function pointer")((*URI).scheme as
                                                        *mut std::os::raw::c_void);
    }
    (*URI).scheme = xmlStrdup(scheme as *const xmlChar) as *mut std::os::raw::c_char;
    let ref mut fresh133 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh133 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetServer(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut server: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlURISetServer\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut server as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    if !(*URI).server.is_null() {
        xmlFree.expect("non-null function pointer")((*URI).server as
                                                        *mut std::os::raw::c_void);
    }
    (*URI).server = xmlStrdup(server as *const xmlChar) as *mut std::os::raw::c_char;
    let ref mut fresh134 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh134 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetUser(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut user: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlURISetUser\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_URI as *mut *mut PyObject,
                        &mut user as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    URI =
        if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlURIPtr
        } else { (*(pyobj_URI as *mut PyURI_Object)).obj };
    if !(*URI).user.is_null() {
        xmlFree.expect("non-null function pointer")((*URI).user as
                                                        *mut std::os::raw::c_void);
    }
    (*URI).user = xmlStrdup(user as *const xmlChar) as *mut std::os::raw::c_char;
    let ref mut fresh135 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh135 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIUnescapeString(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut str: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut len: std::os::raw::c_int = 0;
    let mut target: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"ziz:xmlURIUnescapeString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut std::os::raw::c_char,
                        &mut len as *mut std::os::raw::c_int,
                        &mut target as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlURIUnescapeString(str, len, target);
    py_retval = libxml_charPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Charcmp(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut utf1: *mut xmlChar = 0 as *mut xmlChar;
    let mut utf2: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlUTF8Charcmp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut utf1 as *mut *mut xmlChar,
                        &mut utf2 as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUTF8Charcmp(utf1, utf2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Size(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlUTF8Size\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut utf as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUTF8Size(utf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strlen(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlUTF8Strlen\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut utf as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUTF8Strlen(utf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strloc(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut utfchar: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"zz:xmlUTF8Strloc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut utf as *mut *mut xmlChar,
                        &mut utfchar as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUTF8Strloc(utf, utfchar);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strndup(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlUTF8Strndup\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut utf as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUTF8Strndup(utf, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strpos(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut pos: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlUTF8Strpos\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut utf as *mut *mut xmlChar,
                        &mut pos as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUTF8Strpos(utf, pos);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strsize(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlUTF8Strsize\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut utf as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUTF8Strsize(utf, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strsub(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut start: std::os::raw::c_int = 0;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zii:xmlUTF8Strsub\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut utf as *mut *mut xmlChar,
                        &mut start as *mut std::os::raw::c_int,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlUTF8Strsub(utf, start, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUnlinkNode(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlUnlinkNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    xmlUnlinkNode(cur);
    let ref mut fresh136 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh136 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUnsetNsProp(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOz:xmlUnsetNsProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlUnsetNsProp(node, ns, name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUnsetProp(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlUnsetProp\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlUnsetProp(node, name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidCtxtNormalizeAttributeValue(mut self_0:
                                                                        *mut PyObject,
                                                                    mut args:
                                                                        *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOOzz:xmlValidCtxtNormalizeAttributeValue\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval =
        xmlValidCtxtNormalizeAttributeValue(ctxt, doc, elem, name, value);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidNormalizeAttributeValue(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOzz:xmlValidNormalizeAttributeValue\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlValidNormalizeAttributeValue(doc, elem, name, value);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateDocument(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlValidateDocument\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlValidateDocument(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateDocumentFinal(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlValidateDocumentFinal\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlValidateDocumentFinal(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateDtd(mut self_0: *mut PyObject,
                                               mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlValidateDtd\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_dtd as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    dtd =
        if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_dtd as *mut PyxmlNode_Object)).obj } as xmlDtdPtr;
    c_retval = xmlValidateDtd(ctxt, doc, dtd);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateDtdFinal(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlValidateDtdFinal\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlValidateDtdFinal(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateElement(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlValidateElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlValidateElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNCName(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut space: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlValidateNCName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar,
                        &mut space as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlValidateNCName(value, space);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNMToken(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut space: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlValidateNMToken\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar,
                        &mut space as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlValidateNMToken(value, space);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateName(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut space: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlValidateName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar,
                        &mut space as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlValidateName(value, space);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNameValue(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlValidateNameValue\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlValidateNameValue(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNamesValue(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlValidateNamesValue\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlValidateNamesValue(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNmtokenValue(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlValidateNmtokenValue\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlValidateNmtokenValue(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNmtokensValue(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlValidateNmtokensValue\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlValidateNmtokensValue(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNotationUse(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut notationName: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOz:xmlValidateNotationUse\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut notationName as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlValidateNotationUse(ctxt, doc, notationName);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateOneAttribute(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOOOz:xmlValidateOneAttribute\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject,
                        &mut pyobj_attr as *mut *mut PyObject,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    attr =
        if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_attr as *mut PyxmlNode_Object)).obj } as xmlAttrPtr;
    c_retval = xmlValidateOneAttribute(ctxt, doc, elem, attr, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateOneElement(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlValidateOneElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlValidateOneElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateOneNamespace(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOOzOz:xmlValidateOneNamespace\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject,
                        &mut prefix as *mut *mut xmlChar,
                        &mut pyobj_ns as *mut *mut PyObject,
                        &mut value as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    c_retval = xmlValidateOneNamespace(ctxt, doc, elem, prefix, ns, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidatePopElement(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut qname: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOOz:xmlValidatePopElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject,
                        &mut qname as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlValidatePopElement(ctxt, doc, elem, qname);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidatePushCData(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut data: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozi:xmlValidatePushCData\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut data as *mut *mut xmlChar,
                        &mut len as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    c_retval = xmlValidatePushCData(ctxt, data, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidatePushElement(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut qname: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"OOOz:xmlValidatePushElement\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_elem as *mut *mut PyObject,
                        &mut qname as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    elem =
        if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_elem as *mut PyxmlNode_Object)).obj };
    c_retval = xmlValidatePushElement(ctxt, doc, elem, qname);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateQName(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut space: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"zi:xmlValidateQName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut value as *mut *mut xmlChar,
                        &mut space as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlValidateQName(value, space);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateRoot(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlValidateRoot\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlValidCtxtPtr
        } else { (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlValidateRoot(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_VALID_ENABLED) */
/* defined(LIBXML_VALID_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXIncludeProcess(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXIncludeProcess\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlXIncludeProcess(doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XINCLUDE_ENABLED) */
/* defined(LIBXML_XINCLUDE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXIncludeProcessFlags(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut flags: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXIncludeProcessFlags\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut flags as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlXIncludeProcessFlags(doc, flags);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XINCLUDE_ENABLED) */
/* defined(LIBXML_XINCLUDE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXIncludeProcessTree(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_tree: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXIncludeProcessTree\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_tree as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    tree =
        if pyobj_tree == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_tree as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXIncludeProcessTree(tree);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XINCLUDE_ENABLED) */
/* defined(LIBXML_XINCLUDE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXIncludeProcessTreeFlags(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_tree: *mut PyObject = 0 as *mut PyObject;
    let mut flags: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXIncludeProcessTreeFlags\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_tree as *mut *mut PyObject,
                        &mut flags as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    tree =
        if pyobj_tree == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_tree as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXIncludeProcessTreeFlags(tree, flags);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XINCLUDE_ENABLED) */
/* defined(LIBXML_XINCLUDE_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathAddValues(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathAddValues\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathAddValues(ctxt);
    let ref mut fresh137 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh137 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathBooleanFunction(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathBooleanFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathBooleanFunction(ctxt, nargs);
    let ref mut fresh138 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh138 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastBooleanToNumber(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_double = 0.;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlXPathCastBooleanToNumber\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathCastBooleanToNumber(val);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastBooleanToString(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlXPathCastBooleanToString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathCastBooleanToString(val);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastNodeToNumber(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_double = 0.;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathCastNodeToNumber\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathCastNodeToNumber(node);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastNodeToString(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathCastNodeToString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathCastNodeToString(node);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastNumberToBoolean(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_double = 0.;
    if PyArg_ParseTuple(args,
                        b"d:xmlXPathCastNumberToBoolean\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_double) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathCastNumberToBoolean(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastNumberToString(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: std::os::raw::c_double = 0.;
    if PyArg_ParseTuple(args,
                        b"d:xmlXPathCastNumberToString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_double) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathCastNumberToString(val);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastStringToBoolean(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlXPathCastStringToBoolean\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathCastStringToBoolean(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastStringToNumber(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_double = 0.;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlXPathCastStringToNumber\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathCastStringToNumber(val);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCeilingFunction(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathCeilingFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathCeilingFunction(ctxt, nargs);
    let ref mut fresh139 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh139 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCmpNodes(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut node1: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node1: *mut PyObject = 0 as *mut PyObject;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node2: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathCmpNodes\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node1 as *mut *mut PyObject,
                        &mut pyobj_node2 as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node1 =
        if pyobj_node1 == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node1 as *mut PyxmlNode_Object)).obj };
    node2 =
        if pyobj_node2 == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node2 as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathCmpNodes(node1, node2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCompareValues(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut inf: std::os::raw::c_int = 0;
    let mut strict: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oii:xmlXPathCompareValues\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut inf as *mut std::os::raw::c_int,
                        &mut strict as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = xmlXPathCompareValues(ctxt, inf, strict);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathConcatFunction(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathConcatFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathConcatFunction(ctxt, nargs);
    let ref mut fresh140 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh140 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathContainsFunction(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathContainsFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathContainsFunction(ctxt, nargs);
    let ref mut fresh141 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh141 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathContextSetCache(mut self_0:
                                                            *mut PyObject,
                                                        mut args:
                                                            *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut active: std::os::raw::c_int = 0;
    let mut value: std::os::raw::c_int = 0;
    let mut options: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oiii:xmlXPathContextSetCache\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut active as *mut std::os::raw::c_int,
                        &mut value as *mut std::os::raw::c_int,
                        &mut options as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPathContextSetCache(ctxt, active, value, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCountFunction(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathCountFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathCountFunction(ctxt, nargs);
    let ref mut fresh142 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh142 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathDivValues(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathDivValues\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathDivValues(ctxt);
    let ref mut fresh143 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh143 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathEqualValues(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathEqualValues\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = xmlXPathEqualValues(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathErr(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut error: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathErr\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut error as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathErr(ctxt, error);
    let ref mut fresh144 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh144 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathEval(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctx: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctx: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"zO:xmlXPathEval\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar,
                        &mut pyobj_ctx as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctx =
        if pyobj_ctx == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctx as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPathEval(str, ctx);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathEvalExpr(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathEvalExpr\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathEvalExpr(ctxt);
    let ref mut fresh145 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh145 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathEvalExpression(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"zO:xmlXPathEvalExpression\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPathEvalExpression(str, ctxt);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathFalseFunction(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathFalseFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathFalseFunction(ctxt, nargs);
    let ref mut fresh146 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh146 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathFloorFunction(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathFloorFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathFloorFunction(ctxt, nargs);
    let ref mut fresh147 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh147 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathFreeContext(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathFreeContext\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    xmlXPathFreeContext(ctxt);
    let ref mut fresh148 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh148 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathFreeParserContext(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathFreeParserContext\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathFreeParserContext(ctxt);
    let ref mut fresh149 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh149 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetContextDoc(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathGetContextDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = (*ctxt).doc;
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetContextNode(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathGetContextNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = (*ctxt).node;
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetContextPosition(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathGetContextPosition\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = (*ctxt).proximityPosition;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetContextSize(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathGetContextSize\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = (*ctxt).contextSize;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetFunction(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathGetFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = (*ctxt).function;
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetFunctionURI(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathGetFunctionURI\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = (*ctxt).functionURI;
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathIdFunction(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathIdFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathIdFunction(ctxt, nargs);
    let ref mut fresh150 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh150 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathInit(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    xmlXPathInit();
    let ref mut fresh151 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh151 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathIsInf(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_double = 0.;
    if PyArg_ParseTuple(args,
                        b"d:xmlXPathIsInf\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_double) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathIsInf(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathIsNaN(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut val: std::os::raw::c_double = 0.;
    if PyArg_ParseTuple(args,
                        b"d:xmlXPathIsNaN\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_double) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathIsNaN(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathIsNodeType(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlXPathIsNodeType\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathIsNodeType(name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathLangFunction(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathLangFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathLangFunction(ctxt, nargs);
    let ref mut fresh152 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh152 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathLastFunction(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathLastFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathLastFunction(ctxt, nargs);
    let ref mut fresh153 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh153 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathLocalNameFunction(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathLocalNameFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathLocalNameFunction(ctxt, nargs);
    let ref mut fresh154 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh154 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathModValues(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathModValues\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathModValues(ctxt);
    let ref mut fresh155 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh155 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathMultValues(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathMultValues\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathMultValues(ctxt);
    let ref mut fresh156 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh156 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNamespaceURIFunction(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathNamespaceURIFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathNamespaceURIFunction(ctxt, nargs);
    let ref mut fresh157 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh157 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewBoolean(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"i:xmlXPathNewBoolean\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathNewBoolean(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewCString(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    if PyArg_ParseTuple(args,
                        b"z:xmlXPathNewCString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut *mut std::os::raw::c_char) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathNewCString(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewContext(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathNewContext\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlXPathNewContext(doc);
    py_retval = libxml_xmlXPathContextPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewFloat(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: std::os::raw::c_double = 0.;
    if PyArg_ParseTuple(args,
                        b"d:xmlXPathNewFloat\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut std::os::raw::c_double) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathNewFloat(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewNodeSet(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_val: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathNewNodeSet\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_val as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    val =
        if pyobj_val == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_val as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNewNodeSet(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewParserContext(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathParserContextPtr =
        0 as *mut xmlXPathParserContext;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"zO:xmlXPathNewParserContext\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPathNewParserContext(str, ctxt);
    py_retval = libxml_xmlXPathParserContextPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewString(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlXPathNewString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut val as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathNewString(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewValueTree(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_val: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathNewValueTree\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_val as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    val =
        if pyobj_val == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_val as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNewValueTree(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextAncestor(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextAncestor\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextAncestor(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextAncestorOrSelf(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextAncestorOrSelf\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextAncestorOrSelf(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextAttribute(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextAttribute\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextAttribute(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextChild(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextChild\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextChild(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextDescendant(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextDescendant\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextDescendant(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextDescendantOrSelf(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextDescendantOrSelf\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextDescendantOrSelf(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextFollowing(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextFollowing\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextFollowing(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextFollowingSibling(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextFollowingSibling\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextFollowingSibling(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextNamespace(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextNamespace\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextNamespace(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextParent(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextParent\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextParent(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextPreceding(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextPreceding\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextPreceding(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextPrecedingSibling(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextPrecedingSibling\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextPrecedingSibling(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextSelf(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathNextSelf\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_cur as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    cur =
        if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_cur as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPathNextSelf(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNodeEval(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctx: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctx: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OzO:xmlXPathNodeEval\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_node as *mut *mut PyObject,
                        &mut str as *mut *mut xmlChar,
                        &mut pyobj_ctx as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    ctx =
        if pyobj_ctx == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctx as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPathNodeEval(node, str, ctx);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNodeSetFreeNs(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathNodeSetFreeNs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ns as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ns =
        if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_ns as *mut PyxmlNode_Object)).obj } as xmlNsPtr;
    xmlXPathNodeSetFreeNs(ns);
    let ref mut fresh158 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh158 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNormalizeFunction(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathNormalizeFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathNormalizeFunction(ctxt, nargs);
    let ref mut fresh159 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh159 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNotEqualValues(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathNotEqualValues\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = xmlXPathNotEqualValues(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNotFunction(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathNotFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathNotFunction(ctxt, nargs);
    let ref mut fresh160 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh160 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNsLookup(mut self_0: *mut PyObject,
                                                 mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlXPathNsLookup\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut prefix as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPathNsLookup(ctxt, prefix);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNumberFunction(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathNumberFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathNumberFunction(ctxt, nargs);
    let ref mut fresh161 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh161 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathOrderDocElems(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_long = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathOrderDocElems\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    c_retval = xmlXPathOrderDocElems(doc);
    py_retval = libxml_longWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathParseNCName(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathParseNCName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = xmlXPathParseNCName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathParseName(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathParseName\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = xmlXPathParseName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathParserGetContext(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathParserGetContext\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = (*ctxt).context;
    py_retval = libxml_xmlXPathContextPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathPopBoolean(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathPopBoolean\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = xmlXPathPopBoolean(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathPopNumber(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_double = 0.;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathPopNumber\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = xmlXPathPopNumber(ctxt);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathPopString(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathPopString\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    c_retval = xmlXPathPopString(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathPositionFunction(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathPositionFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathPositionFunction(ctxt, nargs);
    let ref mut fresh162 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh162 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisterAllFunctions(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathRegisterAllFunctions\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    xmlXPathRegisterAllFunctions(ctxt);
    let ref mut fresh163 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh163 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisterNs(mut self_0: *mut PyObject,
                                                   mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_int = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut ns_uri: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlXPathRegisterNs\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut prefix as *mut *mut xmlChar,
                        &mut ns_uri as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPathRegisterNs(ctxt, prefix, ns_uri);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisteredFuncsCleanup(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathRegisteredFuncsCleanup\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    xmlXPathRegisteredFuncsCleanup(ctxt);
    let ref mut fresh164 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh164 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisteredNsCleanup(mut self_0:
                                                                *mut PyObject,
                                                            mut args:
                                                                *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathRegisteredNsCleanup\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    xmlXPathRegisteredNsCleanup(ctxt);
    let ref mut fresh165 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh165 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisteredVariablesCleanup(mut self_0:
                                                                       *mut PyObject,
                                                                   mut args:
                                                                       *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathRegisteredVariablesCleanup\x00" as
                            *const u8 as *const std::os::raw::c_char as
                            *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    xmlXPathRegisteredVariablesCleanup(ctxt);
    let ref mut fresh166 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh166 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRoot(mut self_0: *mut PyObject,
                                             mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathRoot\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathRoot(ctxt);
    let ref mut fresh167 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh167 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRoundFunction(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathRoundFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathRoundFunction(ctxt, nargs);
    let ref mut fresh168 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh168 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSetContextDoc(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathSetContextDoc\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_doc as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    (*ctxt).doc = doc;
    let ref mut fresh169 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh169 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSetContextNode(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPathSetContextNode\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut pyobj_node as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    node =
        if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_node as *mut PyxmlNode_Object)).obj };
    (*ctxt).node = node;
    let ref mut fresh170 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh170 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathStartsWithFunction(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathStartsWithFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathStartsWithFunction(ctxt, nargs);
    let ref mut fresh171 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh171 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathStringEvalNumber(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: std::os::raw::c_double = 0.;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"z:xmlXPathStringEvalNumber\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    c_retval = xmlXPathStringEvalNumber(str);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathStringFunction(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathStringFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathStringFunction(ctxt, nargs);
    let ref mut fresh172 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh172 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathStringLengthFunction(mut self_0:
                                                                 *mut PyObject,
                                                             mut args:
                                                                 *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathStringLengthFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathStringLengthFunction(ctxt, nargs);
    let ref mut fresh173 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh173 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSubValues(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathSubValues\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathSubValues(ctxt);
    let ref mut fresh174 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh174 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSubstringAfterFunction(mut self_0:
                                                                   *mut PyObject,
                                                               mut args:
                                                                   *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathSubstringAfterFunction\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathSubstringAfterFunction(ctxt, nargs);
    let ref mut fresh175 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh175 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSubstringBeforeFunction(mut self_0:
                                                                    *mut PyObject,
                                                                mut args:
                                                                    *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathSubstringBeforeFunction\x00" as *const u8
                            as *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathSubstringBeforeFunction(ctxt, nargs);
    let ref mut fresh176 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh176 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSubstringFunction(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathSubstringFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathSubstringFunction(ctxt, nargs);
    let ref mut fresh177 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh177 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSumFunction(mut self_0: *mut PyObject,
                                                    mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathSumFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathSumFunction(ctxt, nargs);
    let ref mut fresh178 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh178 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathTranslateFunction(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathTranslateFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathTranslateFunction(ctxt, nargs);
    let ref mut fresh179 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh179 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathTrueFunction(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPathTrueFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathTrueFunction(ctxt, nargs);
    let ref mut fresh180 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh180 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathValueFlipSign(mut self_0:
                                                          *mut PyObject,
                                                      mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPathValueFlipSign\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPathValueFlipSign(ctxt);
    let ref mut fresh181 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh181 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathVariableLookup(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Oz:xmlXPathVariableLookup\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPathVariableLookup(ctxt, name);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathVariableLookupNS(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut ns_uri: *mut xmlChar = 0 as *mut xmlChar;
    if PyArg_ParseTuple(args,
                        b"Ozz:xmlXPathVariableLookupNS\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut name as *mut *mut xmlChar,
                        &mut ns_uri as *mut *mut xmlChar) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPathVariableLookupNS(ctxt, name, ns_uri);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPatherror(mut self_0: *mut PyObject,
                                              mut args: *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut file: *mut std::os::raw::c_char = 0 as *mut std::os::raw::c_char;
    let mut line: std::os::raw::c_int = 0;
    let mut no: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Ozii:xmlXPatherror\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut file as *mut *mut std::os::raw::c_char,
                        &mut line as *mut std::os::raw::c_int,
                        &mut no as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPatherror(ctxt, file, line, no);
    let ref mut fresh182 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh182 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPATH_ENABLED) */
/* defined(LIBXML_XPATH_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrEval(mut self_0: *mut PyObject,
                                            mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctx: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctx: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"zO:xmlXPtrEval\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut str as *mut *mut xmlChar,
                        &mut pyobj_ctx as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctx =
        if pyobj_ctx == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathContextPtr
        } else { (*(pyobj_ctx as *mut PyxmlXPathContext_Object)).obj };
    c_retval = xmlXPtrEval(str, ctx);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPTR_ENABLED) */
/* defined(LIBXML_XPTR_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrEvalRangePredicate(mut self_0:
                                                              *mut PyObject,
                                                          mut args:
                                                              *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPtrEvalRangePredicate\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPtrEvalRangePredicate(ctxt);
    let ref mut fresh183 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh183 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPTR_ENABLED) */
/* defined(LIBXML_XPTR_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrNewCollapsedRange(mut self_0:
                                                             *mut PyObject,
                                                         mut args:
                                                             *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_start: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"O:xmlXPtrNewCollapsedRange\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_start as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    start =
        if pyobj_start == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_start as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPtrNewCollapsedRange(start);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPTR_ENABLED) */
/* defined(LIBXML_XPTR_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrNewContext(mut self_0: *mut PyObject,
                                                  mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut here: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_here: *mut PyObject = 0 as *mut PyObject;
    let mut origin: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_origin: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OOO:xmlXPtrNewContext\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_doc as *mut *mut PyObject,
                        &mut pyobj_here as *mut *mut PyObject,
                        &mut pyobj_origin as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    doc =
        if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_doc as *mut PyxmlNode_Object)).obj } as xmlDocPtr;
    here =
        if pyobj_here == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_here as *mut PyxmlNode_Object)).obj };
    origin =
        if pyobj_origin == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_origin as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPtrNewContext(doc, here, origin);
    py_retval = libxml_xmlXPathContextPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPTR_ENABLED) */
/* defined(LIBXML_XPTR_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrNewLocationSetNodes(mut self_0:
                                                               *mut PyObject,
                                                           mut args:
                                                               *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_start: *mut PyObject = 0 as *mut PyObject;
    let mut end: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_end: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPtrNewLocationSetNodes\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_start as *mut *mut PyObject,
                        &mut pyobj_end as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    start =
        if pyobj_start == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_start as *mut PyxmlNode_Object)).obj };
    end =
        if pyobj_end == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_end as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPtrNewLocationSetNodes(start, end);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPTR_ENABLED) */
/* defined(LIBXML_XPTR_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrNewRange(mut self_0: *mut PyObject,
                                                mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_start: *mut PyObject = 0 as *mut PyObject;
    let mut startindex: std::os::raw::c_int = 0;
    let mut end: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_end: *mut PyObject = 0 as *mut PyObject;
    let mut endindex: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"OiOi:xmlXPtrNewRange\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_start as *mut *mut PyObject,
                        &mut startindex as *mut std::os::raw::c_int,
                        &mut pyobj_end as *mut *mut PyObject,
                        &mut endindex as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    start =
        if pyobj_start == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_start as *mut PyxmlNode_Object)).obj };
    end =
        if pyobj_end == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_end as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPtrNewRange(start, startindex, end, endindex);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPTR_ENABLED) */
/* defined(LIBXML_XPTR_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrNewRangeNodes(mut self_0:
                                                         *mut PyObject,
                                                     mut args: *mut PyObject)
 -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut start: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_start: *mut PyObject = 0 as *mut PyObject;
    let mut end: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_end: *mut PyObject = 0 as *mut PyObject;
    if PyArg_ParseTuple(args,
                        b"OO:xmlXPtrNewRangeNodes\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_start as *mut *mut PyObject,
                        &mut pyobj_end as *mut *mut PyObject) == 0 {
        return 0 as *mut PyObject
    }
    start =
        if pyobj_start == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_start as *mut PyxmlNode_Object)).obj };
    end =
        if pyobj_end == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlNodePtr
        } else { (*(pyobj_end as *mut PyxmlNode_Object)).obj };
    c_retval = xmlXPtrNewRangeNodes(start, end);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
/* defined(LIBXML_XPTR_ENABLED) */
/* defined(LIBXML_XPTR_ENABLED) */
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrRangeToFunction(mut self_0:
                                                           *mut PyObject,
                                                       mut args:
                                                           *mut PyObject)
 -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut nargs: std::os::raw::c_int = 0;
    if PyArg_ParseTuple(args,
                        b"Oi:xmlXPtrRangeToFunction\x00" as *const u8 as
                            *const std::os::raw::c_char as *mut std::os::raw::c_char,
                        &mut pyobj_ctxt as *mut *mut PyObject,
                        &mut nargs as *mut std::os::raw::c_int) == 0 {
        return 0 as *mut PyObject
    }
    ctxt =
        if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
            0 as xmlXPathParserContextPtr
        } else { (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj };
    xmlXPtrRangeToFunction(ctxt, nargs);
    let ref mut fresh184 =
        (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
    *fresh184 += 1;
    return &mut _Py_NoneStruct;
}
/* defined(LIBXML_XPTR_ENABLED) */
