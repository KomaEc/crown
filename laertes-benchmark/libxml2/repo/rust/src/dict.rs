
extern "C" {
    pub type _xmlRMutex;
    #[no_mangle]
    fn xmlStrQEqual(pref: *const xmlChar, name: *const xmlChar,
                    str: *const xmlChar) -> std::os::raw::c_int;
    #[no_mangle]
    fn rand_r(__seed: *mut std::os::raw::c_uint) -> std::os::raw::c_int;
    #[no_mangle]
    fn memcpy(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_void, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn memset(_: *mut std::os::raw::c_void, _: std::os::raw::c_int, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn memcmp(_: *const std::os::raw::c_void, _: *const std::os::raw::c_void,
              _: std::os::raw::c_ulong) -> std::os::raw::c_int;
    #[no_mangle]
    fn strlen(_: *const std::os::raw::c_char) -> std::os::raw::c_ulong;
    /*
 * Summary: interface for all global variables of the library
 * Description: all the global variables and thread handling for
 *              those variables is handled by this module.
 *
 * The bottom of this file is automatically generated by build_glob.py
 * based on the description file global.data
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
 */
    /* *
 * xmlParserInputBufferCreateFilenameFunc:
 * @URI: the URI to read from
 * @enc: the requested source encoding
 *
 * Signature for the function doing the lookup for a suitable input method
 * corresponding to an URI.
 *
 * Returns the new xmlParserInputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /* *
 * xmlOutputBufferCreateFilenameFunc:
 * @URI: the URI to write to
 * @enc: the requested target encoding
 *
 * Signature for the function doing the lookup for a suitable output method
 * corresponding to an URI.
 *
 * Returns the new xmlOutputBufferPtr in case of success or NULL if no
 *         method was found.
 */
    /*
 * Externally global symbols which need to be protected for backwards
 * compatibility support.
 */
    /* *
 * xmlRegisterNodeFunc:
 * @node: the current node
 *
 * Signature for the registration callback of a created node
 */
    /* *
 * xmlDeregisterNodeFunc:
 * @node: the current node
 *
 * Signature for the deregistration callback of a discarded node
 */
    /* * DOC_DISABLE */
/*
 * In general the memory allocation entry points are not kept
 * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED
 *    - xmlMalloc
 *    - xmlMallocAtomic
 *    - xmlRealloc
 *    - xmlMemStrdup
 *    - xmlFree
 */
    /* !LIBXML_THREAD_ALLOC_ENABLED */
    #[no_mangle]
    static mut xmlFree: xmlFreeFunc;
    #[no_mangle]
    static mut xmlMalloc: xmlMallocFunc;
    #[no_mangle]
    fn xmlFreeRMutex(tok: xmlRMutexPtr);
    #[no_mangle]
    fn xmlNewRMutex() -> xmlRMutexPtr;
    #[no_mangle]
    fn xmlRMutexLock(tok: xmlRMutexPtr);
    #[no_mangle]
    fn xmlRMutexUnlock(tok: xmlRMutexPtr);
}
pub type xmlChar = std::os::raw::c_uchar;
pub type size_t = std::os::raw::c_ulong;
pub type __uint32_t = std::os::raw::c_uint;
/* *
 * Summary: interfaces for thread handling
 * Description: set of generic threading related routines
 *              should work with pthreads, Windows native or TLS threads
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * xmlMutex are a simple mutual exception locks.
 */
/*
 * xmlRMutex are reentrant mutual exception locks.
 */
pub type xmlRMutexPtr = *mut xmlRMutex;
pub type xmlRMutex = _xmlRMutex;
pub type uint32_t = __uint32_t;
/*
 * The entire dictionary
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDict {
    pub ref_counter: std::os::raw::c_int,
    pub dict: *mut _xmlDictEntry,
    pub size: size_t,
    pub nbElems: std::os::raw::c_uint,
    pub strings: xmlDictStringsPtr,
    pub subdict: *mut _xmlDict,
    pub seed: std::os::raw::c_int,
    pub limit: size_t,
}
pub type xmlDictStringsPtr = *mut xmlDictStrings;
pub type xmlDictStrings = _xmlDictStrings;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDictStrings {
    pub next: xmlDictStringsPtr,
    pub free: *mut xmlChar,
    pub end: *mut xmlChar,
    pub size: size_t,
    pub nbStrings: size_t,
    pub array: [xmlChar; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDictEntry {
    pub next: *mut _xmlDictEntry,
    pub name: *const xmlChar,
    pub len: std::os::raw::c_uint,
    pub valid: std::os::raw::c_int,
    pub okey: std::os::raw::c_ulong,
}
/*
 * Summary: string dictionary
 * Description: dictionary of reusable strings, just used to avoid allocation
 *         and freeing operations.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/*
 * The dictionary.
 */
pub type xmlDictPtr = *mut xmlDict;
pub type xmlDict = _xmlDict;
/*
 * Summary: interface for the memory allocator
 * Description: provides interfaces for the memory allocator,
 *              including debugging capabilities.
 *
 * Copy: See Copyright for the status of this software.
 *
 * Author: Daniel Veillard
 */
/* *
 * DEBUG_MEMORY:
 *
 * DEBUG_MEMORY replaces the allocator with a collect and debug
 * shell to the libc allocator.
 * DEBUG_MEMORY should only be activated when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/* #define DEBUG_MEMORY_FREED */
/* #define DEBUG_MEMORY_LOCATION */
/* *
 * DEBUG_MEMORY_LOCATION:
 *
 * DEBUG_MEMORY_LOCATION should be activated only when debugging
 * libxml i.e. if libxml has been configured with --with-debug-mem too.
 */
/*
 * The XML memory wrapper support 4 basic overloadable functions.
 */
/* *
 * xmlFreeFunc:
 * @mem: an already allocated block of memory
 *
 * Signature for a free() implementation.
 */
pub type xmlFreeFunc
    =
    Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void) -> ()>;
/* !WITH_BIG_KEY */
/* WITH_BIG_KEY */
/*
 * An entry in the dictionary
 */
pub type xmlDictEntry = _xmlDictEntry;
/* *
 * xmlMallocFunc:
 * @size:  the size requested in bytes
 *
 * Signature for a malloc() implementation.
 *
 * Returns a pointer to the newly allocated block or NULL in case of error.
 */
pub type xmlMallocFunc
    =
    Option<unsafe extern "C" fn(_: size_t) -> *mut std::os::raw::c_void>;
pub type xmlDictEntryPtr = *mut xmlDictEntry;
/*
 * A mutex for modifying the reference counter for shared
 * dictionaries.
 */
static mut xmlDictMutex: xmlRMutexPtr = 0 as *const xmlRMutex as xmlRMutexPtr;
/*
 * Whether the dictionary mutex was initialized.
 */
static mut xmlDictInitialized: std::os::raw::c_int = 0 as std::os::raw::c_int;
/*
 * Internal data for random function, protected by xmlDictMutex
 */
static mut rand_seed: std::os::raw::c_uint = 0 as std::os::raw::c_int as std::os::raw::c_uint;
/* *
 * xmlInitializeDict:
 *
 * Do the dictionary mutex initialization.
 * this function is deprecated
 *
 * Returns 0 if initialization was already done, and 1 if that
 * call led to the initialization
 */
#[no_mangle]
pub unsafe extern "C" fn xmlInitializeDict() -> std::os::raw::c_int {
    return 0 as std::os::raw::c_int;
}
/* *
 * __xmlInitializeDict:
 *
 * This function is not public
 * Do the dictionary mutex initialization.
 * this function is not thread safe, initialization should
 * normally be done once at setup when called from xmlOnceInit()
 * we may also land in this code if thread support is not compiled in
 *
 * Returns 0 if initialization was already done, and 1 if that
 * call led to the initialization
 */
#[no_mangle]
pub unsafe extern "C" fn __xmlInitializeDict() -> std::os::raw::c_int {
    if xmlDictInitialized != 0 {
        return 1 as std::os::raw::c_int
    } //XCHECKS time(NULL);
    xmlDictMutex = xmlNewRMutex();
    if xmlDictMutex.is_null() { return 0 as std::os::raw::c_int }
    xmlRMutexLock(xmlDictMutex);
    rand_seed = 0x12345678 as std::os::raw::c_int as std::os::raw::c_uint;
    rand_r(&mut rand_seed);
    xmlDictInitialized = 1 as std::os::raw::c_int;
    xmlRMutexUnlock(xmlDictMutex);
    return 1 as std::os::raw::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn __xmlRandom() -> std::os::raw::c_int {
    let mut ret: std::os::raw::c_int = 0;
    if xmlDictInitialized == 0 as std::os::raw::c_int { __xmlInitializeDict(); }
    xmlRMutexLock(xmlDictMutex);
    ret = rand_r(&mut rand_seed);
    xmlRMutexUnlock(xmlDictMutex);
    return ret;
}
/*
 * Cleanup function
 */
/* *
 * xmlDictCleanup:
 *
 * Free the dictionary mutex. Do not call unless sure the library
 * is not in use anymore !
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictCleanup() {
    if xmlDictInitialized == 0 { return }
    xmlFreeRMutex(xmlDictMutex);
    xmlDictInitialized = 0 as std::os::raw::c_int;
}
/*
 * xmlDictAddString:
 * @dict: the dictionary
 * @name: the name of the userdata
 * @len: the length of the name
 *
 * Add the string to the array[s]
 *
 * Returns the pointer of the local string, or NULL in case of error.
 */
unsafe extern "C" fn xmlDictAddString(mut dict: xmlDictPtr,
                                      mut name: *const xmlChar,
                                      mut namelen: std::os::raw::c_uint)
 -> *const xmlChar {
    let mut current_block: u64; /* + sizeof(_xmlDictStrings) == 1024 */
    let mut pool: xmlDictStringsPtr = 0 as *mut xmlDictStrings;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    let mut size: size_t = 0 as std::os::raw::c_int as size_t;
    let mut limit: size_t = 0 as std::os::raw::c_int as size_t;
    pool = (*dict).strings;
    loop  {
        if pool.is_null() { current_block = 13183875560443969876; break ; }
        if (*pool).end.offset_from((*pool).free) as std::os::raw::c_long as
               size_t > namelen as std::os::raw::c_ulong {
            current_block = 11752822500114441713;
            break ;
        }
        if (*pool).size > size { size = (*pool).size }
        limit =
            (limit as std::os::raw::c_ulong).wrapping_add((*pool).size) as size_t as
                size_t;
        pool = (*pool).next
    }
    match current_block {
        13183875560443969876 => {
            /*
     * Not found, need to allocate
     */
            if pool.is_null() {
                if (*dict).limit > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                       limit > (*dict).limit {
                    return 0 as *const xmlChar
                } /* exponential growth */
                if size == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                    size = 1000 as std::os::raw::c_int as size_t
                } else {
                    size =
                        (size as
                             std::os::raw::c_ulong).wrapping_mul(4 as std::os::raw::c_int as
                                                             std::os::raw::c_ulong) as
                            size_t as size_t
                } /* just in case ! */
                if size <
                       (4 as std::os::raw::c_int as
                            std::os::raw::c_uint).wrapping_mul(namelen) as
                           std::os::raw::c_ulong {
                    size =
                        (4 as std::os::raw::c_int as
                             std::os::raw::c_uint).wrapping_mul(namelen) as size_t
                }
                pool =
                    xmlMalloc.expect("non-null function pointer")((::std::mem::size_of::<xmlDictStrings>()
                                                                       as
                                                                       std::os::raw::c_ulong).wrapping_add(size))
                        as xmlDictStringsPtr;
                if pool.is_null() { return 0 as *const xmlChar }
                (*pool).size = size;
                (*pool).nbStrings = 0 as std::os::raw::c_int as size_t;
                (*pool).free =
                    &mut *(*pool).array.as_mut_ptr().offset(0 as std::os::raw::c_int
                                                                as isize) as
                        *mut xmlChar;
                (*pool).end =
                    &mut *(*pool).array.as_mut_ptr().offset(size as isize) as
                        *mut xmlChar;
                (*pool).next = (*dict).strings;
                (*dict).strings = pool
            }
        }
        _ => { }
    }
    ret = (*pool).free;
    memcpy((*pool).free as *mut std::os::raw::c_void, name as *const std::os::raw::c_void,
           namelen as std::os::raw::c_ulong);
    (*pool).free = (*pool).free.offset(namelen as isize);
    let fresh0 = (*pool).free;
    (*pool).free = (*pool).free.offset(1);
    *fresh0 = 0 as std::os::raw::c_int as xmlChar;
    (*pool).nbStrings = (*pool).nbStrings.wrapping_add(1);
    return ret;
}
/*
 * xmlDictAddQString:
 * @dict: the dictionary
 * @prefix: the prefix of the userdata
 * @plen: the prefix length
 * @name: the name of the userdata
 * @len: the length of the name
 *
 * Add the QName to the array[s]
 *
 * Returns the pointer of the local string, or NULL in case of error.
 */
unsafe extern "C" fn xmlDictAddQString(mut dict: xmlDictPtr,
                                       mut prefix: *const xmlChar,
                                       mut plen: std::os::raw::c_uint,
                                       mut name: *const xmlChar,
                                       mut namelen: std::os::raw::c_uint)
 -> *const xmlChar {
    let mut current_block: u64; /* + sizeof(_xmlDictStrings) == 1024 */
    let mut pool: xmlDictStringsPtr = 0 as *mut xmlDictStrings;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    let mut size: size_t = 0 as std::os::raw::c_int as size_t;
    let mut limit: size_t = 0 as std::os::raw::c_int as size_t;
    if prefix.is_null() { return xmlDictAddString(dict, name, namelen) }
    pool = (*dict).strings;
    loop  {
        if pool.is_null() { current_block = 13536709405535804910; break ; }
        if (*pool).end.offset_from((*pool).free) as std::os::raw::c_long as
               size_t >
               namelen.wrapping_add(plen).wrapping_add(1 as std::os::raw::c_int as
                                                           std::os::raw::c_uint) as
                   std::os::raw::c_ulong {
            current_block = 2153641082331438319;
            break ;
        }
        if (*pool).size > size { size = (*pool).size }
        limit =
            (limit as std::os::raw::c_ulong).wrapping_add((*pool).size) as size_t as
                size_t;
        pool = (*pool).next
    }
    match current_block {
        13536709405535804910 => {
            /*
     * Not found, need to allocate
     */
            if pool.is_null() {
                if (*dict).limit > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
                       limit > (*dict).limit {
                    return 0 as *const xmlChar
                } /* exponential growth */
                if size == 0 as std::os::raw::c_int as std::os::raw::c_ulong {
                    size = 1000 as std::os::raw::c_int as size_t
                } else {
                    size =
                        (size as
                             std::os::raw::c_ulong).wrapping_mul(4 as std::os::raw::c_int as
                                                             std::os::raw::c_ulong) as
                            size_t as size_t
                } /* just in case ! */
                if size <
                       (4 as std::os::raw::c_int as
                            std::os::raw::c_uint).wrapping_mul(namelen.wrapping_add(plen).wrapping_add(1
                                                                                                   as
                                                                                                   std::os::raw::c_int
                                                                                                   as
                                                                                                   std::os::raw::c_uint))
                           as std::os::raw::c_ulong {
                    size =
                        (4 as std::os::raw::c_int as
                             std::os::raw::c_uint).wrapping_mul(namelen.wrapping_add(plen).wrapping_add(1
                                                                                                    as
                                                                                                    std::os::raw::c_int
                                                                                                    as
                                                                                                    std::os::raw::c_uint))
                            as size_t
                }
                pool =
                    xmlMalloc.expect("non-null function pointer")((::std::mem::size_of::<xmlDictStrings>()
                                                                       as
                                                                       std::os::raw::c_ulong).wrapping_add(size))
                        as xmlDictStringsPtr;
                if pool.is_null() { return 0 as *const xmlChar }
                (*pool).size = size;
                (*pool).nbStrings = 0 as std::os::raw::c_int as size_t;
                (*pool).free =
                    &mut *(*pool).array.as_mut_ptr().offset(0 as std::os::raw::c_int
                                                                as isize) as
                        *mut xmlChar;
                (*pool).end =
                    &mut *(*pool).array.as_mut_ptr().offset(size as isize) as
                        *mut xmlChar;
                (*pool).next = (*dict).strings;
                (*dict).strings = pool
            }
        }
        _ => { }
    }
    ret = (*pool).free;
    memcpy((*pool).free as *mut std::os::raw::c_void, prefix as *const std::os::raw::c_void,
           plen as std::os::raw::c_ulong);
    (*pool).free = (*pool).free.offset(plen as isize);
    let fresh1 = (*pool).free;
    (*pool).free = (*pool).free.offset(1);
    *fresh1 = ':' as i32 as xmlChar;
    memcpy((*pool).free as *mut std::os::raw::c_void, name as *const std::os::raw::c_void,
           namelen as std::os::raw::c_ulong);
    (*pool).free = (*pool).free.offset(namelen as isize);
    let fresh2 = (*pool).free;
    (*pool).free = (*pool).free.offset(1);
    *fresh2 = 0 as std::os::raw::c_int as xmlChar;
    (*pool).nbStrings = (*pool).nbStrings.wrapping_add(1);
    return ret;
}
/*
 * xmlDictComputeBigKey:
 *
 * Calculate a hash key using a good hash function that works well for
 * larger hash table sizes.
 *
 * Hash function by "One-at-a-Time Hash" see
 * http://burtleburtle.net/bob/hash/doobs.html
 */
unsafe extern "C" fn xmlDictComputeBigKey(mut data: *const xmlChar,
                                          mut namelen: std::os::raw::c_int,
                                          mut seed: std::os::raw::c_int) -> uint32_t {
    let mut hash: uint32_t = 0;
    let mut i: std::os::raw::c_int = 0;
    if namelen <= 0 as std::os::raw::c_int || data.is_null() {
        return 0 as std::os::raw::c_int as uint32_t
    }
    hash = seed as uint32_t;
    i = 0 as std::os::raw::c_int;
    while i < namelen {
        hash =
            (hash as
                 std::os::raw::c_uint).wrapping_add(*data.offset(i as isize) as
                                                std::os::raw::c_uint) as uint32_t as
                uint32_t;
        hash =
            (hash as std::os::raw::c_uint).wrapping_add(hash << 10 as std::os::raw::c_int) as
                uint32_t as uint32_t;
        hash ^= hash >> 6 as std::os::raw::c_int;
        i += 1
    }
    hash =
        (hash as std::os::raw::c_uint).wrapping_add(hash << 3 as std::os::raw::c_int) as
            uint32_t as uint32_t;
    hash ^= hash >> 11 as std::os::raw::c_int;
    hash =
        (hash as std::os::raw::c_uint).wrapping_add(hash << 15 as std::os::raw::c_int) as
            uint32_t as uint32_t;
    return hash;
}
/*
 * xmlDictComputeBigQKey:
 *
 * Calculate a hash key for two strings using a good hash function
 * that works well for larger hash table sizes.
 *
 * Hash function by "One-at-a-Time Hash" see
 * http://burtleburtle.net/bob/hash/doobs.html
 *
 * Neither of the two strings must be NULL.
 */
unsafe extern "C" fn xmlDictComputeBigQKey(mut prefix: *const xmlChar,
                                           mut plen: std::os::raw::c_int,
                                           mut name: *const xmlChar,
                                           mut len: std::os::raw::c_int,
                                           mut seed: std::os::raw::c_int)
 -> std::os::raw::c_ulong {
    let mut hash: uint32_t = 0;
    let mut i: std::os::raw::c_int = 0;
    hash = seed as uint32_t;
    i = 0 as std::os::raw::c_int;
    while i < plen {
        hash =
            (hash as
                 std::os::raw::c_uint).wrapping_add(*prefix.offset(i as isize) as
                                                std::os::raw::c_uint) as uint32_t as
                uint32_t;
        hash =
            (hash as std::os::raw::c_uint).wrapping_add(hash << 10 as std::os::raw::c_int) as
                uint32_t as uint32_t;
        hash ^= hash >> 6 as std::os::raw::c_int;
        i += 1
    }
    hash =
        (hash as std::os::raw::c_uint).wrapping_add(':' as i32 as std::os::raw::c_uint) as
            uint32_t as uint32_t;
    hash =
        (hash as std::os::raw::c_uint).wrapping_add(hash << 10 as std::os::raw::c_int) as
            uint32_t as uint32_t;
    hash ^= hash >> 6 as std::os::raw::c_int;
    i = 0 as std::os::raw::c_int;
    while i < len {
        hash =
            (hash as
                 std::os::raw::c_uint).wrapping_add(*name.offset(i as isize) as
                                                std::os::raw::c_uint) as uint32_t as
                uint32_t;
        hash =
            (hash as std::os::raw::c_uint).wrapping_add(hash << 10 as std::os::raw::c_int) as
                uint32_t as uint32_t;
        hash ^= hash >> 6 as std::os::raw::c_int;
        i += 1
    }
    hash =
        (hash as std::os::raw::c_uint).wrapping_add(hash << 3 as std::os::raw::c_int) as
            uint32_t as uint32_t;
    hash ^= hash >> 11 as std::os::raw::c_int;
    hash =
        (hash as std::os::raw::c_uint).wrapping_add(hash << 15 as std::os::raw::c_int) as
            uint32_t as uint32_t;
    return hash as std::os::raw::c_ulong;
}
/* WITH_BIG_KEY */
/*
 * xmlDictComputeFastKey:
 *
 * Calculate a hash key using a fast hash function that works well
 * for low hash table fill.
 */
unsafe extern "C" fn xmlDictComputeFastKey(mut name: *const xmlChar,
                                           mut namelen: std::os::raw::c_int,
                                           mut seed: std::os::raw::c_int)
 -> std::os::raw::c_ulong {
    let mut value: std::os::raw::c_ulong = seed as std::os::raw::c_ulong;
    if name.is_null() { return 0 as std::os::raw::c_int as std::os::raw::c_ulong }
    value = *name as std::os::raw::c_ulong;
    value <<= 5 as std::os::raw::c_int;
    if namelen > 10 as std::os::raw::c_int {
        value =
            value.wrapping_add(*name.offset((namelen - 1 as std::os::raw::c_int) as
                                                isize) as std::os::raw::c_ulong);
        namelen = 10 as std::os::raw::c_int
    }
    let mut current_block_16: u64;
    match namelen {
        10 => {
            value =
                value.wrapping_add(*name.offset(9 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_16 = 17718222357026483669;
        }
        9 => { current_block_16 = 17718222357026483669; }
        8 => { current_block_16 = 5446140710247747918; }
        7 => { current_block_16 = 15705034766489281697; }
        6 => { current_block_16 = 3614378943419643381; }
        5 => { current_block_16 = 11929302008659577344; }
        4 => { current_block_16 = 2236501546269585055; }
        3 => { current_block_16 = 2773542487217368272; }
        2 => { current_block_16 = 18177119835917145477; }
        _ => { current_block_16 = 2838571290723028321; }
    }
    match current_block_16 {
        17718222357026483669 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(8 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_16 = 5446140710247747918;
        }
        _ => { }
    }
    match current_block_16 {
        5446140710247747918 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(7 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_16 = 15705034766489281697;
        }
        _ => { }
    }
    match current_block_16 {
        15705034766489281697 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(6 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_16 = 3614378943419643381;
        }
        _ => { }
    }
    match current_block_16 {
        3614378943419643381 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(5 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_16 = 11929302008659577344;
        }
        _ => { }
    }
    match current_block_16 {
        11929302008659577344 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(4 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_16 = 2236501546269585055;
        }
        _ => { }
    }
    match current_block_16 {
        2236501546269585055 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(3 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_16 = 2773542487217368272;
        }
        _ => { }
    }
    match current_block_16 {
        2773542487217368272 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(2 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_16 = 18177119835917145477;
        }
        _ => { }
    }
    match current_block_16 {
        18177119835917145477 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(1 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong)
        }
        _ => { }
    }
    return value;
}
/*
 * xmlDictComputeFastQKey:
 *
 * Calculate a hash key for two strings using a fast hash function
 * that works well for low hash table fill.
 *
 * Neither of the two strings must be NULL.
 */
unsafe extern "C" fn xmlDictComputeFastQKey(mut prefix: *const xmlChar,
                                            mut plen: std::os::raw::c_int,
                                            mut name: *const xmlChar,
                                            mut len: std::os::raw::c_int,
                                            mut seed: std::os::raw::c_int)
 -> std::os::raw::c_ulong {
    let mut value: std::os::raw::c_ulong = seed as std::os::raw::c_ulong;
    if plen == 0 as std::os::raw::c_int {
        value =
            value.wrapping_add((30 as std::os::raw::c_int as
                                    std::os::raw::c_ulong).wrapping_mul(':' as i32 as
                                                                    std::os::raw::c_ulong))
    } else {
        value =
            value.wrapping_add((30 as std::os::raw::c_int * *prefix as std::os::raw::c_int) as
                                   std::os::raw::c_ulong)
    }
    if len > 10 as std::os::raw::c_int {
        let mut offset: std::os::raw::c_int =
            len - (plen + 1 as std::os::raw::c_int + 1 as std::os::raw::c_int);
        if offset < 0 as std::os::raw::c_int {
            offset = len - (10 as std::os::raw::c_int + 1 as std::os::raw::c_int)
        }
        value =
            value.wrapping_add(*name.offset(offset as isize) as
                                   std::os::raw::c_ulong);
        len = 10 as std::os::raw::c_int;
        if plen > 10 as std::os::raw::c_int { plen = 10 as std::os::raw::c_int }
    }
    let mut current_block_20: u64;
    match plen {
        10 => {
            value =
                value.wrapping_add(*prefix.offset(9 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong);
            current_block_20 = 7999367711246341256;
        }
        9 => { current_block_20 = 7999367711246341256; }
        8 => { current_block_20 = 15904339535608418407; }
        7 => { current_block_20 = 731579331427512053; }
        6 => { current_block_20 = 10905486111603547446; }
        5 => { current_block_20 = 11615379356856243366; }
        4 => { current_block_20 = 3390465415055570287; }
        3 => { current_block_20 = 11860058822417311190; }
        2 => { current_block_20 = 4985680540995348867; }
        1 => { current_block_20 = 16945896738682150754; }
        _ => { current_block_20 = 17478428563724192186; }
    }
    match current_block_20 {
        7999367711246341256 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*prefix.offset(8 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong);
            current_block_20 = 15904339535608418407;
        }
        _ => { }
    }
    match current_block_20 {
        15904339535608418407 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*prefix.offset(7 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong);
            current_block_20 = 731579331427512053;
        }
        _ => { }
    }
    match current_block_20 {
        731579331427512053 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*prefix.offset(6 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong);
            current_block_20 = 10905486111603547446;
        }
        _ => { }
    }
    match current_block_20 {
        10905486111603547446 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*prefix.offset(5 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong);
            current_block_20 = 11615379356856243366;
        }
        _ => { }
    }
    match current_block_20 {
        11615379356856243366 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*prefix.offset(4 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong);
            current_block_20 = 3390465415055570287;
        }
        _ => { }
    }
    match current_block_20 {
        3390465415055570287 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*prefix.offset(3 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong);
            current_block_20 = 11860058822417311190;
        }
        _ => { }
    }
    match current_block_20 {
        11860058822417311190 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*prefix.offset(2 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong);
            current_block_20 = 4985680540995348867;
        }
        _ => { }
    }
    match current_block_20 {
        4985680540995348867 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*prefix.offset(1 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong);
            current_block_20 = 16945896738682150754;
        }
        _ => { }
    }
    match current_block_20 {
        16945896738682150754 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*prefix.offset(0 as std::os::raw::c_int as isize)
                                       as std::os::raw::c_ulong)
        }
        _ => { }
    }
    len -= plen;
    if len > 0 as std::os::raw::c_int {
        value = value.wrapping_add(':' as i32 as std::os::raw::c_ulong);
        len -= 1
    }
    let mut current_block_36: u64;
    match len {
        10 => {
            value =
                value.wrapping_add(*name.offset(9 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_36 = 12657626924318951104;
        }
        9 => { current_block_36 = 12657626924318951104; }
        8 => { current_block_36 = 16412498240494603743; }
        7 => { current_block_36 = 11087779799150400045; }
        6 => { current_block_36 = 18218679824713771056; }
        5 => { current_block_36 = 6892780862565587004; }
        4 => { current_block_36 = 4290504891046847381; }
        3 => { current_block_36 = 6706297331630608221; }
        2 => { current_block_36 = 7059581692039682446; }
        1 => { current_block_36 = 8521750874268929371; }
        _ => { current_block_36 = 2543120759711851213; }
    }
    match current_block_36 {
        12657626924318951104 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(8 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_36 = 16412498240494603743;
        }
        _ => { }
    }
    match current_block_36 {
        16412498240494603743 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(7 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_36 = 11087779799150400045;
        }
        _ => { }
    }
    match current_block_36 {
        11087779799150400045 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(6 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_36 = 18218679824713771056;
        }
        _ => { }
    }
    match current_block_36 {
        18218679824713771056 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(5 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_36 = 6892780862565587004;
        }
        _ => { }
    }
    match current_block_36 {
        6892780862565587004 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(4 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_36 = 4290504891046847381;
        }
        _ => { }
    }
    match current_block_36 {
        4290504891046847381 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(3 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_36 = 6706297331630608221;
        }
        _ => { }
    }
    match current_block_36 {
        6706297331630608221 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(2 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_36 = 7059581692039682446;
        }
        _ => { }
    }
    match current_block_36 {
        7059581692039682446 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(1 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong);
            current_block_36 = 8521750874268929371;
        }
        _ => { }
    }
    match current_block_36 {
        8521750874268929371 =>
        /* Falls through. */
        {
            value =
                value.wrapping_add(*name.offset(0 as std::os::raw::c_int as isize) as
                                       std::os::raw::c_ulong)
        }
        _ => { }
    }
    return value;
}
/* *
 * xmlDictCreate:
 *
 * Create a new dictionary
 *
 * Returns the newly created dictionary, or NULL if an error occurred.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictCreate() -> xmlDictPtr {
    let mut dict: xmlDictPtr = 0 as *mut xmlDict;
    if xmlDictInitialized == 0 {
        if __xmlInitializeDict() == 0 { return 0 as xmlDictPtr }
    }
    dict =
        xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlDict>()
                                                          as std::os::raw::c_ulong) as
            xmlDictPtr;
    if !dict.is_null() {
        (*dict).ref_counter = 1 as std::os::raw::c_int;
        (*dict).limit = 0 as std::os::raw::c_int as size_t;
        (*dict).size = 128 as std::os::raw::c_int as size_t;
        (*dict).nbElems = 0 as std::os::raw::c_int as std::os::raw::c_uint;
        (*dict).dict =
            xmlMalloc.expect("non-null function pointer")((128 as std::os::raw::c_int
                                                               as
                                                               std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlDictEntry>()
                                                                                               as
                                                                                               std::os::raw::c_ulong))
                as *mut _xmlDictEntry;
        (*dict).strings = 0 as xmlDictStringsPtr;
        (*dict).subdict = 0 as *mut _xmlDict;
        if !(*dict).dict.is_null() {
            memset((*dict).dict as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
                   (128 as std::os::raw::c_int as
                        std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<xmlDictEntry>()
                                                        as std::os::raw::c_ulong));
            (*dict).seed = __xmlRandom();
            return dict
        }
        xmlFree.expect("non-null function pointer")(dict as
                                                        *mut std::os::raw::c_void);
    }
    return 0 as xmlDictPtr;
}
/* *
 * xmlDictCreateSub:
 * @sub: an existing dictionary
 *
 * Create a new dictionary, inheriting strings from the read-only
 * dictionary @sub. On lookup, strings are first searched in the
 * new dictionary, then in @sub, and if not found are created in the
 * new dictionary.
 *
 * Returns the newly created dictionary, or NULL if an error occurred.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictCreateSub(mut sub: xmlDictPtr) -> xmlDictPtr {
    let mut dict: xmlDictPtr = xmlDictCreate();
    if !dict.is_null() && !sub.is_null() {
        (*dict).seed = (*sub).seed;
        (*dict).subdict = sub;
        xmlDictReference((*dict).subdict);
    }
    return dict;
}
/* *
 * xmlDictReference:
 * @dict: the dictionary
 *
 * Increment the reference counter of a dictionary
 *
 * Returns 0 in case of success and -1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictReference(mut dict: xmlDictPtr)
 -> std::os::raw::c_int {
    if xmlDictInitialized == 0 {
        if __xmlInitializeDict() == 0 { return -(1 as std::os::raw::c_int) }
    }
    if dict.is_null() { return -(1 as std::os::raw::c_int) }
    xmlRMutexLock(xmlDictMutex);
    (*dict).ref_counter += 1;
    xmlRMutexUnlock(xmlDictMutex);
    return 0 as std::os::raw::c_int;
}
/* *
 * xmlDictGrow:
 * @dict: the dictionary
 * @size: the new size of the dictionary
 *
 * resize the dictionary
 *
 * Returns 0 in case of success, -1 in case of failure
 */
unsafe extern "C" fn xmlDictGrow(mut dict: xmlDictPtr, mut size: size_t)
 -> std::os::raw::c_int {
    let mut key: std::os::raw::c_ulong = 0;
    let mut okey: std::os::raw::c_ulong = 0;
    let mut oldsize: size_t = 0;
    let mut i: size_t = 0;
    let mut iter: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
    let mut next: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
    let mut olddict: *mut _xmlDictEntry = 0 as *mut _xmlDictEntry;
    let mut ret: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut keep_keys: std::os::raw::c_int = 1 as std::os::raw::c_int;
    if dict.is_null() { return -(1 as std::os::raw::c_int) }
    if size < 8 as std::os::raw::c_int as std::os::raw::c_ulong { return -(1 as std::os::raw::c_int) }
    if size > (8 as std::os::raw::c_int * 2048 as std::os::raw::c_int) as std::os::raw::c_ulong {
        return -(1 as std::os::raw::c_int)
    }
    oldsize = (*dict).size;
    olddict = (*dict).dict;
    if olddict.is_null() { return -(1 as std::os::raw::c_int) }
    if oldsize == 128 as std::os::raw::c_int as std::os::raw::c_ulong {
        keep_keys = 0 as std::os::raw::c_int
    }
    (*dict).dict =
        xmlMalloc.expect("non-null function pointer")(size.wrapping_mul(::std::mem::size_of::<xmlDictEntry>()
                                                                            as
                                                                            std::os::raw::c_ulong))
            as *mut _xmlDictEntry;
    if (*dict).dict.is_null() {
        (*dict).dict = olddict;
        return -(1 as std::os::raw::c_int)
    }
    memset((*dict).dict as *mut std::os::raw::c_void, 0 as std::os::raw::c_int,
           size.wrapping_mul(::std::mem::size_of::<xmlDictEntry>() as
                                 std::os::raw::c_ulong));
    (*dict).size = size;
    /*	If the two loops are merged, there would be situations where
	a new entry needs to allocated and data copied into it from
	the main dict. It is nicer to run through the array twice, first
	copying all the elements in the main array (less probability of
	allocate) and then the rest, so we only free in the second loop.
    */
    i = 0 as std::os::raw::c_int as size_t;
    while i < oldsize {
        if !((*olddict.offset(i as isize)).valid == 0 as std::os::raw::c_int) {
            if keep_keys != 0 {
                okey = (*olddict.offset(i as isize)).okey
            } else {
                okey =
                    if (*dict).size == 128 as std::os::raw::c_int as std::os::raw::c_ulong {
                        xmlDictComputeFastKey((*olddict.offset(i as
                                                                   isize)).name,
                                              (*olddict.offset(i as
                                                                   isize)).len
                                                  as std::os::raw::c_int,
                                              (*dict).seed)
                    } else {
                        xmlDictComputeBigKey((*olddict.offset(i as
                                                                  isize)).name,
                                             (*olddict.offset(i as isize)).len
                                                 as std::os::raw::c_int, (*dict).seed)
                            as std::os::raw::c_ulong
                    }
            }
            key = okey.wrapping_rem((*dict).size);
            if (*(*dict).dict.offset(key as isize)).valid == 0 as std::os::raw::c_int
               {
                memcpy(&mut *(*dict).dict.offset(key as isize) as
                           *mut _xmlDictEntry as *mut std::os::raw::c_void,
                       &mut *olddict.offset(i as isize) as *mut _xmlDictEntry
                           as *const std::os::raw::c_void,
                       ::std::mem::size_of::<xmlDictEntry>() as
                           std::os::raw::c_ulong);
                let ref mut fresh3 =
                    (*(*dict).dict.offset(key as isize)).next;
                *fresh3 = 0 as *mut _xmlDictEntry;
                (*(*dict).dict.offset(key as isize)).okey = okey
            } else {
                let mut entry: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
                entry =
                    xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlDictEntry>()
                                                                      as
                                                                      std::os::raw::c_ulong)
                        as xmlDictEntryPtr;
                if !entry.is_null() {
                    (*entry).name = (*olddict.offset(i as isize)).name;
                    (*entry).len = (*olddict.offset(i as isize)).len;
                    (*entry).okey = okey;
                    (*entry).next = (*(*dict).dict.offset(key as isize)).next;
                    (*entry).valid = 1 as std::os::raw::c_int;
                    let ref mut fresh4 =
                        (*(*dict).dict.offset(key as isize)).next;
                    *fresh4 = entry
                } else {
                    /*
		 * we don't have much ways to alert from herei
		 * result is losing an entry and unicity guarantee
		 */
                    ret = -(1 as std::os::raw::c_int)
                }
            }
        }
        i = i.wrapping_add(1)
    }
    i = 0 as std::os::raw::c_int as size_t;
    while i < oldsize {
        iter = (*olddict.offset(i as isize)).next;
        while !iter.is_null() {
            next = (*iter).next;
            /*
	     * put back the entry in the new dict
	     */
            if keep_keys != 0 {
                okey = (*iter).okey
            } else {
                okey =
                    if (*dict).size == 128 as std::os::raw::c_int as std::os::raw::c_ulong {
                        xmlDictComputeFastKey((*iter).name,
                                              (*iter).len as std::os::raw::c_int,
                                              (*dict).seed)
                    } else {
                        xmlDictComputeBigKey((*iter).name,
                                             (*iter).len as std::os::raw::c_int,
                                             (*dict).seed) as std::os::raw::c_ulong
                    }
            }
            key = okey.wrapping_rem((*dict).size);
            if (*(*dict).dict.offset(key as isize)).valid == 0 as std::os::raw::c_int
               {
                memcpy(&mut *(*dict).dict.offset(key as isize) as
                           *mut _xmlDictEntry as *mut std::os::raw::c_void,
                       iter as *const std::os::raw::c_void,
                       ::std::mem::size_of::<xmlDictEntry>() as
                           std::os::raw::c_ulong);
                let ref mut fresh5 =
                    (*(*dict).dict.offset(key as isize)).next;
                *fresh5 = 0 as *mut _xmlDictEntry;
                (*(*dict).dict.offset(key as isize)).valid = 1 as std::os::raw::c_int;
                (*(*dict).dict.offset(key as isize)).okey = okey;
                xmlFree.expect("non-null function pointer")(iter as
                                                                *mut std::os::raw::c_void);
            } else {
                (*iter).next = (*(*dict).dict.offset(key as isize)).next;
                (*iter).okey = okey;
                let ref mut fresh6 =
                    (*(*dict).dict.offset(key as isize)).next;
                *fresh6 = iter
            }
            iter = next
        }
        i = i.wrapping_add(1)
    }
    xmlFree.expect("non-null function pointer")(olddict as *mut std::os::raw::c_void);
    return ret;
}
/* *
 * xmlDictFree:
 * @dict: the dictionary
 *
 * Free the hash @dict and its contents. The userdata is
 * deallocated with @f if provided.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictFree(mut dict: xmlDictPtr) {
    let mut i: size_t = 0;
    let mut iter: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
    let mut next: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
    let mut inside_dict: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut pool: xmlDictStringsPtr = 0 as *mut xmlDictStrings;
    let mut nextp: xmlDictStringsPtr = 0 as *mut xmlDictStrings;
    if dict.is_null() { return }
    if xmlDictInitialized == 0 { if __xmlInitializeDict() == 0 { return } }
    /* decrement the counter, it may be shared by a parser and docs */
    xmlRMutexLock(xmlDictMutex);
    (*dict).ref_counter -= 1;
    if (*dict).ref_counter > 0 as std::os::raw::c_int {
        xmlRMutexUnlock(xmlDictMutex);
        return
    }
    xmlRMutexUnlock(xmlDictMutex);
    if !(*dict).subdict.is_null() { xmlDictFree((*dict).subdict); }
    if !(*dict).dict.is_null() {
        i = 0 as std::os::raw::c_int as size_t;
        while i < (*dict).size &&
                  (*dict).nbElems > 0 as std::os::raw::c_int as std::os::raw::c_uint {
            iter =
                &mut *(*dict).dict.offset(i as isize) as *mut _xmlDictEntry;
            if !((*iter).valid == 0 as std::os::raw::c_int) {
                inside_dict = 1 as std::os::raw::c_int;
                while !iter.is_null() {
                    next = (*iter).next;
                    if inside_dict == 0 {
                        xmlFree.expect("non-null function pointer")(iter as
                                                                        *mut std::os::raw::c_void);
                    }
                    (*dict).nbElems = (*dict).nbElems.wrapping_sub(1);
                    inside_dict = 0 as std::os::raw::c_int;
                    iter = next
                }
            }
            i = i.wrapping_add(1)
        }
        xmlFree.expect("non-null function pointer")((*dict).dict as
                                                        *mut std::os::raw::c_void);
    }
    pool = (*dict).strings;
    while !pool.is_null() {
        nextp = (*pool).next;
        xmlFree.expect("non-null function pointer")(pool as
                                                        *mut std::os::raw::c_void);
        pool = nextp
    }
    xmlFree.expect("non-null function pointer")(dict as *mut std::os::raw::c_void);
}
/* *
 * xmlDictLookup:
 * @dict: the dictionary
 * @name: the name of the userdata
 * @len: the length of the name, if -1 it is recomputed
 *
 * Add the @name to the dictionary @dict if not present.
 *
 * Returns the internal copy of the name or NULL in case of internal error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictLookup(mut dict: xmlDictPtr,
                                       mut name: *const xmlChar,
                                       mut len: std::os::raw::c_int)
 -> *const xmlChar {
    let mut key: std::os::raw::c_ulong = 0;
    let mut okey: std::os::raw::c_ulong = 0;
    let mut nbi: std::os::raw::c_ulong = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    let mut entry: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
    let mut insert: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    let mut l: std::os::raw::c_uint = 0;
    if dict.is_null() || name.is_null() { return 0 as *const xmlChar }
    if len < 0 as std::os::raw::c_int {
        l = strlen(name as *const std::os::raw::c_char) as std::os::raw::c_uint
    } else { l = len as std::os::raw::c_uint }
    if (*dict).limit > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
           l as std::os::raw::c_ulong >= (*dict).limit ||
           l > (2147483647 as std::os::raw::c_int / 2 as std::os::raw::c_int) as std::os::raw::c_uint
       {
        return 0 as *const xmlChar
    }
    /*
     * Check for duplicate and insertion location.
     */
    okey =
        if (*dict).size == 128 as std::os::raw::c_int as std::os::raw::c_ulong {
            xmlDictComputeFastKey(name, l as std::os::raw::c_int, (*dict).seed)
        } else {
            xmlDictComputeBigKey(name, l as std::os::raw::c_int, (*dict).seed) as
                std::os::raw::c_ulong
        };
    key = okey.wrapping_rem((*dict).size);
    if (*(*dict).dict.offset(key as isize)).valid == 0 as std::os::raw::c_int {
        insert = 0 as xmlDictEntryPtr
    } else {
        insert =
            &mut *(*dict).dict.offset(key as isize) as *mut _xmlDictEntry;
        while !(*insert).next.is_null() {
            if (*insert).okey == okey && (*insert).len == l {
                if memcmp((*insert).name as *const std::os::raw::c_void,
                          name as *const std::os::raw::c_void, l as std::os::raw::c_ulong) ==
                       0 {
                    return (*insert).name
                }
            }
            nbi = nbi.wrapping_add(1);
            insert = (*insert).next
        }
        if (*insert).okey == okey && (*insert).len == l {
            if memcmp((*insert).name as *const std::os::raw::c_void,
                      name as *const std::os::raw::c_void, l as std::os::raw::c_ulong) == 0 {
                return (*insert).name
            }
        }
    }
    if !(*dict).subdict.is_null() {
        let mut skey: std::os::raw::c_ulong = 0;
        /* we cannot always reuse the same okey for the subdict */
        if (*dict).size == 128 as std::os::raw::c_int as std::os::raw::c_ulong &&
               (*(*dict).subdict).size != 128 as std::os::raw::c_int as std::os::raw::c_ulong
               ||
               (*dict).size != 128 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   (*(*dict).subdict).size ==
                       128 as std::os::raw::c_int as std::os::raw::c_ulong {
            skey =
                if (*(*dict).subdict).size ==
                       128 as std::os::raw::c_int as std::os::raw::c_ulong {
                    xmlDictComputeFastKey(name, l as std::os::raw::c_int,
                                          (*(*dict).subdict).seed)
                } else {
                    xmlDictComputeBigKey(name, l as std::os::raw::c_int,
                                         (*(*dict).subdict).seed) as
                        std::os::raw::c_ulong
                }
        } else { skey = okey }
        key = skey.wrapping_rem((*(*dict).subdict).size);
        if (*(*(*dict).subdict).dict.offset(key as isize)).valid !=
               0 as std::os::raw::c_int {
            let mut tmp: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
            tmp =
                &mut *(*(*dict).subdict).dict.offset(key as isize) as
                    *mut _xmlDictEntry;
            while !(*tmp).next.is_null() {
                if (*tmp).okey == skey && (*tmp).len == l {
                    if memcmp((*tmp).name as *const std::os::raw::c_void,
                              name as *const std::os::raw::c_void, l as std::os::raw::c_ulong)
                           == 0 {
                        return (*tmp).name
                    }
                }
                nbi = nbi.wrapping_add(1);
                tmp = (*tmp).next
            }
            if (*tmp).okey == skey && (*tmp).len == l {
                if memcmp((*tmp).name as *const std::os::raw::c_void,
                          name as *const std::os::raw::c_void, l as std::os::raw::c_ulong) ==
                       0 {
                    return (*tmp).name
                }
            }
        }
        key = okey.wrapping_rem((*dict).size)
    }
    ret = xmlDictAddString(dict, name, l);
    if ret.is_null() { return 0 as *const xmlChar }
    if insert.is_null() {
        entry = &mut *(*dict).dict.offset(key as isize) as *mut _xmlDictEntry
    } else {
        entry =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlDictEntry>()
                                                              as
                                                              std::os::raw::c_ulong)
                as xmlDictEntryPtr;
        if entry.is_null() { return 0 as *const xmlChar }
    }
    (*entry).name = ret;
    (*entry).len = l;
    (*entry).next = 0 as *mut _xmlDictEntry;
    (*entry).valid = 1 as std::os::raw::c_int;
    (*entry).okey = okey;
    if !insert.is_null() { (*insert).next = entry }
    (*dict).nbElems = (*dict).nbElems.wrapping_add(1);
    if nbi > 3 as std::os::raw::c_int as std::os::raw::c_ulong &&
           (*dict).size <=
               (8 as std::os::raw::c_int * 2048 as std::os::raw::c_int / 2 as std::os::raw::c_int /
                    3 as std::os::raw::c_int) as std::os::raw::c_ulong {
        if xmlDictGrow(dict,
                       ((3 as std::os::raw::c_int * 2 as std::os::raw::c_int) as
                            std::os::raw::c_ulong).wrapping_mul((*dict).size)) !=
               0 as std::os::raw::c_int {
            return 0 as *const xmlChar
        }
    }
    /* Note that entry may have been freed at this point by xmlDictGrow */
    return ret;
}
/* *
 * xmlDictExists:
 * @dict: the dictionary
 * @name: the name of the userdata
 * @len: the length of the name, if -1 it is recomputed
 *
 * Check if the @name exists in the dictionary @dict.
 *
 * Returns the internal copy of the name or NULL if not found.
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictExists(mut dict: xmlDictPtr,
                                       mut name: *const xmlChar,
                                       mut len: std::os::raw::c_int)
 -> *const xmlChar {
    let mut key: std::os::raw::c_ulong = 0;
    let mut okey: std::os::raw::c_ulong = 0;
    let mut nbi: std::os::raw::c_ulong = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    let mut insert: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
    let mut l: std::os::raw::c_uint = 0;
    if dict.is_null() || name.is_null() { return 0 as *const xmlChar }
    if len < 0 as std::os::raw::c_int {
        l = strlen(name as *const std::os::raw::c_char) as std::os::raw::c_uint
    } else { l = len as std::os::raw::c_uint }
    if (*dict).limit > 0 as std::os::raw::c_int as std::os::raw::c_ulong &&
           l as std::os::raw::c_ulong >= (*dict).limit ||
           l > (2147483647 as std::os::raw::c_int / 2 as std::os::raw::c_int) as std::os::raw::c_uint
       {
        return 0 as *const xmlChar
    }
    /*
     * Check for duplicate and insertion location.
     */
    okey =
        if (*dict).size == 128 as std::os::raw::c_int as std::os::raw::c_ulong {
            xmlDictComputeFastKey(name, l as std::os::raw::c_int, (*dict).seed)
        } else {
            xmlDictComputeBigKey(name, l as std::os::raw::c_int, (*dict).seed) as
                std::os::raw::c_ulong
        };
    key = okey.wrapping_rem((*dict).size);
    if (*(*dict).dict.offset(key as isize)).valid == 0 as std::os::raw::c_int {
        insert = 0 as xmlDictEntryPtr
    } else {
        insert =
            &mut *(*dict).dict.offset(key as isize) as *mut _xmlDictEntry;
        while !(*insert).next.is_null() {
            if (*insert).okey == okey && (*insert).len == l {
                if memcmp((*insert).name as *const std::os::raw::c_void,
                          name as *const std::os::raw::c_void, l as std::os::raw::c_ulong) ==
                       0 {
                    return (*insert).name
                }
            }
            nbi = nbi.wrapping_add(1);
            insert = (*insert).next
        }
        if (*insert).okey == okey && (*insert).len == l {
            if memcmp((*insert).name as *const std::os::raw::c_void,
                      name as *const std::os::raw::c_void, l as std::os::raw::c_ulong) == 0 {
                return (*insert).name
            }
        }
    }
    if !(*dict).subdict.is_null() {
        let mut skey: std::os::raw::c_ulong = 0;
        /* we cannot always reuse the same okey for the subdict */
        if (*dict).size == 128 as std::os::raw::c_int as std::os::raw::c_ulong &&
               (*(*dict).subdict).size != 128 as std::os::raw::c_int as std::os::raw::c_ulong
               ||
               (*dict).size != 128 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   (*(*dict).subdict).size ==
                       128 as std::os::raw::c_int as std::os::raw::c_ulong {
            skey =
                if (*(*dict).subdict).size ==
                       128 as std::os::raw::c_int as std::os::raw::c_ulong {
                    xmlDictComputeFastKey(name, l as std::os::raw::c_int,
                                          (*(*dict).subdict).seed)
                } else {
                    xmlDictComputeBigKey(name, l as std::os::raw::c_int,
                                         (*(*dict).subdict).seed) as
                        std::os::raw::c_ulong
                }
        } else { skey = okey }
        key = skey.wrapping_rem((*(*dict).subdict).size);
        if (*(*(*dict).subdict).dict.offset(key as isize)).valid !=
               0 as std::os::raw::c_int {
            let mut tmp: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
            tmp =
                &mut *(*(*dict).subdict).dict.offset(key as isize) as
                    *mut _xmlDictEntry;
            while !(*tmp).next.is_null() {
                if (*tmp).okey == skey && (*tmp).len == l {
                    if memcmp((*tmp).name as *const std::os::raw::c_void,
                              name as *const std::os::raw::c_void, l as std::os::raw::c_ulong)
                           == 0 {
                        return (*tmp).name
                    }
                }
                nbi = nbi.wrapping_add(1);
                tmp = (*tmp).next
            }
            if (*tmp).okey == skey && (*tmp).len == l {
                if memcmp((*tmp).name as *const std::os::raw::c_void,
                          name as *const std::os::raw::c_void, l as std::os::raw::c_ulong) ==
                       0 {
                    return (*tmp).name
                }
            }
        }
    }
    /* not found */
    return 0 as *const xmlChar;
}
/* *
 * xmlDictQLookup:
 * @dict: the dictionary
 * @prefix: the prefix
 * @name: the name
 *
 * Add the QName @prefix:@name to the hash @dict if not present.
 *
 * Returns the internal copy of the QName or NULL in case of internal error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictQLookup(mut dict: xmlDictPtr,
                                        mut prefix: *const xmlChar,
                                        mut name: *const xmlChar)
 -> *const xmlChar {
    let mut okey: std::os::raw::c_ulong = 0;
    let mut key: std::os::raw::c_ulong = 0;
    let mut nbi: std::os::raw::c_ulong = 0 as std::os::raw::c_int as std::os::raw::c_ulong;
    let mut entry: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
    let mut insert: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    let mut len: std::os::raw::c_uint = 0;
    let mut plen: std::os::raw::c_uint = 0;
    let mut l: std::os::raw::c_uint = 0;
    if dict.is_null() || name.is_null() { return 0 as *const xmlChar }
    if prefix.is_null() {
        return xmlDictLookup(dict, name, -(1 as std::os::raw::c_int))
    }
    len = strlen(name as *const std::os::raw::c_char) as std::os::raw::c_uint;
    l = len;
    plen = strlen(prefix as *const std::os::raw::c_char) as std::os::raw::c_uint;
    len =
        len.wrapping_add((1 as std::os::raw::c_int as
                              std::os::raw::c_uint).wrapping_add(plen));
    /*
     * Check for duplicate and insertion location.
     */
    okey =
        if prefix.is_null() {
            if (*dict).size == 128 as std::os::raw::c_int as std::os::raw::c_ulong {
                xmlDictComputeFastKey(name, l as std::os::raw::c_int, (*dict).seed)
            } else {
                xmlDictComputeBigKey(name, l as std::os::raw::c_int, (*dict).seed) as
                    std::os::raw::c_ulong
            }
        } else if (*dict).size == 128 as std::os::raw::c_int as std::os::raw::c_ulong {
            xmlDictComputeFastQKey(prefix, plen as std::os::raw::c_int, name,
                                   l as std::os::raw::c_int, (*dict).seed)
        } else {
            xmlDictComputeBigQKey(prefix, plen as std::os::raw::c_int, name,
                                  l as std::os::raw::c_int, (*dict).seed)
        };
    key = okey.wrapping_rem((*dict).size);
    if (*(*dict).dict.offset(key as isize)).valid == 0 as std::os::raw::c_int {
        insert = 0 as xmlDictEntryPtr
    } else {
        insert =
            &mut *(*dict).dict.offset(key as isize) as *mut _xmlDictEntry;
        while !(*insert).next.is_null() {
            if (*insert).okey == okey && (*insert).len == len &&
                   xmlStrQEqual(prefix, name, (*insert).name) != 0 {
                return (*insert).name
            }
            nbi = nbi.wrapping_add(1);
            insert = (*insert).next
        }
        if (*insert).okey == okey && (*insert).len == len &&
               xmlStrQEqual(prefix, name, (*insert).name) != 0 {
            return (*insert).name
        }
    }
    if !(*dict).subdict.is_null() {
        let mut skey: std::os::raw::c_ulong = 0;
        /* we cannot always reuse the same okey for the subdict */
        if (*dict).size == 128 as std::os::raw::c_int as std::os::raw::c_ulong &&
               (*(*dict).subdict).size != 128 as std::os::raw::c_int as std::os::raw::c_ulong
               ||
               (*dict).size != 128 as std::os::raw::c_int as std::os::raw::c_ulong &&
                   (*(*dict).subdict).size ==
                       128 as std::os::raw::c_int as std::os::raw::c_ulong {
            skey =
                if prefix.is_null() {
                    if (*(*dict).subdict).size ==
                           128 as std::os::raw::c_int as std::os::raw::c_ulong {
                        xmlDictComputeFastKey(name, l as std::os::raw::c_int,
                                              (*(*dict).subdict).seed)
                    } else {
                        xmlDictComputeBigKey(name, l as std::os::raw::c_int,
                                             (*(*dict).subdict).seed) as
                            std::os::raw::c_ulong
                    }
                } else if (*(*dict).subdict).size ==
                              128 as std::os::raw::c_int as std::os::raw::c_ulong {
                    xmlDictComputeFastQKey(prefix, plen as std::os::raw::c_int, name,
                                           l as std::os::raw::c_int,
                                           (*(*dict).subdict).seed)
                } else {
                    xmlDictComputeBigQKey(prefix, plen as std::os::raw::c_int, name,
                                          l as std::os::raw::c_int,
                                          (*(*dict).subdict).seed)
                }
        } else { skey = okey }
        key = skey.wrapping_rem((*(*dict).subdict).size);
        if (*(*(*dict).subdict).dict.offset(key as isize)).valid !=
               0 as std::os::raw::c_int {
            let mut tmp: xmlDictEntryPtr = 0 as *mut xmlDictEntry;
            tmp =
                &mut *(*(*dict).subdict).dict.offset(key as isize) as
                    *mut _xmlDictEntry;
            while !(*tmp).next.is_null() {
                if (*tmp).okey == skey && (*tmp).len == len &&
                       xmlStrQEqual(prefix, name, (*tmp).name) != 0 {
                    return (*tmp).name
                }
                nbi = nbi.wrapping_add(1);
                tmp = (*tmp).next
            }
            if (*tmp).okey == skey && (*tmp).len == len &&
                   xmlStrQEqual(prefix, name, (*tmp).name) != 0 {
                return (*tmp).name
            }
        }
        key = okey.wrapping_rem((*dict).size)
    }
    ret = xmlDictAddQString(dict, prefix, plen, name, l);
    if ret.is_null() { return 0 as *const xmlChar }
    if insert.is_null() {
        entry = &mut *(*dict).dict.offset(key as isize) as *mut _xmlDictEntry
    } else {
        entry =
            xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlDictEntry>()
                                                              as
                                                              std::os::raw::c_ulong)
                as xmlDictEntryPtr;
        if entry.is_null() { return 0 as *const xmlChar }
    }
    (*entry).name = ret;
    (*entry).len = len;
    (*entry).next = 0 as *mut _xmlDictEntry;
    (*entry).valid = 1 as std::os::raw::c_int;
    (*entry).okey = okey;
    if !insert.is_null() { (*insert).next = entry }
    (*dict).nbElems = (*dict).nbElems.wrapping_add(1);
    if nbi > 3 as std::os::raw::c_int as std::os::raw::c_ulong &&
           (*dict).size <=
               (8 as std::os::raw::c_int * 2048 as std::os::raw::c_int / 2 as std::os::raw::c_int /
                    3 as std::os::raw::c_int) as std::os::raw::c_ulong {
        xmlDictGrow(dict,
                    ((3 as std::os::raw::c_int * 2 as std::os::raw::c_int) as
                         std::os::raw::c_ulong).wrapping_mul((*dict).size));
    }
    /* Note that entry may have been freed at this point by xmlDictGrow */
    return ret;
}
/* *
 * xmlDictOwns:
 * @dict: the dictionary
 * @str: the string
 *
 * check if a string is owned by the disctionary
 *
 * Returns 1 if true, 0 if false and -1 in case of error
 * -1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictOwns(mut dict: xmlDictPtr,
                                     mut str: *const xmlChar) -> std::os::raw::c_int {
    let mut pool: xmlDictStringsPtr = 0 as *mut xmlDictStrings;
    if dict.is_null() || str.is_null() { return -(1 as std::os::raw::c_int) }
    pool = (*dict).strings;
    while !pool.is_null() {
        if str >=
               &mut *(*pool).array.as_mut_ptr().offset(0 as std::os::raw::c_int as
                                                           isize) as
                   *mut xmlChar && str <= (*pool).free {
            return 1 as std::os::raw::c_int
        }
        pool = (*pool).next
    }
    if !(*dict).subdict.is_null() { return xmlDictOwns((*dict).subdict, str) }
    return 0 as std::os::raw::c_int;
}
/*
 * Lookup of entry in the dictionary.
 */
/* *
 * xmlDictSize:
 * @dict: the dictionary
 *
 * Query the number of elements installed in the hash @dict.
 *
 * Returns the number of elements in the dictionary or
 * -1 in case of error
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictSize(mut dict: xmlDictPtr) -> std::os::raw::c_int {
    if dict.is_null() { return -(1 as std::os::raw::c_int) }
    if !(*dict).subdict.is_null() {
        return (*dict).nbElems.wrapping_add((*(*dict).subdict).nbElems) as
                   std::os::raw::c_int
    }
    return (*dict).nbElems as std::os::raw::c_int;
}
/* *
 * xmlDictSetLimit:
 * @dict: the dictionary
 * @limit: the limit in bytes
 *
 * Set a size limit for the dictionary
 * Added in 2.9.0
 *
 * Returns the previous limit of the dictionary or 0
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictSetLimit(mut dict: xmlDictPtr,
                                         mut limit: size_t) -> size_t {
    let mut ret: size_t = 0;
    if dict.is_null() { return 0 as std::os::raw::c_int as size_t }
    ret = (*dict).limit;
    (*dict).limit = limit;
    return ret;
}
/*
 * Initializer
 */
/*
 * Constructor and destructor.
 */
/* *
 * xmlDictGetUsage:
 * @dict: the dictionary
 *
 * Get how much memory is used by a dictionary for strings
 * Added in 2.9.0
 *
 * Returns the amount of strings allocated
 */
#[no_mangle]
pub unsafe extern "C" fn xmlDictGetUsage(mut dict: xmlDictPtr) -> size_t {
    let mut pool: xmlDictStringsPtr = 0 as *mut xmlDictStrings;
    let mut limit: size_t = 0 as std::os::raw::c_int as size_t;
    if dict.is_null() { return 0 as std::os::raw::c_int as size_t }
    pool = (*dict).strings;
    while !pool.is_null() {
        limit =
            (limit as std::os::raw::c_ulong).wrapping_add((*pool).size) as size_t as
                size_t;
        pool = (*pool).next
    }
    return limit;
}
/* __INCLUDE_ELFGCCHACK */
