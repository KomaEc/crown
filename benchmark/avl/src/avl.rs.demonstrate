// C program to delete a node from AVL Tree
// An AVL tree node

use std::cmp::{max};
use std::borrow::{Borrow};

pub struct Node {
    pub key: i32,
    pub left: Option<Box<Node>>,
    pub right: Option<Box<Node>>,
    pub height: i32,
}
// A utility function to get height of the tree
pub fn height(mut n: Option<&Node>) -> i32 {
    match n {
        Some(node) => node.height,
        None       => 0,
    }
}

/* Helper function that allocates a new node with the given key and
   NULL left and right pointers. */
pub fn newNode(mut key: i32) -> Box<Node> {
    Box::new(Node {
        key,
        left: None,
        right: None,
        height: 1,
    })
}

pub fn rightRotate_mut(mut y0: Option<&mut Node>) -> Option<&mut Node> {
    let mut y = y0.unwrap();

    // let mut x = y.left.as_mut().map(|mut t| t.as_mut()).unwrap();
    // let mut T2 = x.right.as_mut().map(|mut t| t.as_mut()).unwrap();
    let mut x = y.left.as_mut().unwrap().as_mut();
    let mut T2 = x.right.as_mut().unwrap().as_mut();
    x.right = Some( unsafe { Box::from_raw(y) } );
    y.left = Some( unsafe { Box::from_raw(T2) } );
    (*y).height =
        max(height((*y).left.as_ref().map(|t| t.as_ref())), height((*y).right.as_ref().map(|t| t.as_ref()))) + 1 as i32;
    (*x).height =
        max(height((*x).left.as_ref().map(|t| t.as_ref())), height((*x).right.as_ref().map(|t| t.as_ref()))) + 1 as i32;
    return Some(&mut x);
}

// A utility function to right rotate subtree rooted with y
// See the diagram given above.
pub fn rightRotate(mut y0: Option<Box<Node>>) -> Option<Box<Node>> {
    let mut y = y0.unwrap();

    let mut x: Box<Node> = y.left.unwrap();
    let mut T2: Box<Node> = x.right.unwrap();
    y.left = Some(T2);
    y.height = max(height(y.left.as_ref().map(|t| t.as_ref())), height(y.right.as_ref().map(|t| t.as_ref()))) + 1;
    x.right = Some(y);
    x.height = max(height(x.left.as_ref().map(|t| t.as_ref())), height(x.right.as_ref().map(|t| t.as_ref()))) + 1;
    return Some(x);
    /*
    let mut x: Option<Box<Node>> = y.as_mut().map(|mut node| node.left.take()).flatten();
    // let mut x = y.unwrap().left.unwrap();
    let mut t2: Option<Box<Node>> = x.as_mut().map(|mut node| node.right.take()).flatten();
    // let mut t2 = x.right.unwrap();
    // Perform rotation
    y.as_mut().map(|mut node| node.left = t2);
    {
        let height_l = height(y.as_ref().map(|node| node.left.as_ref()).flatten().map(Borrow::borrow));
        let height_r = height(y.as_ref().map(|node| node.right.as_ref()).flatten().map(Borrow::borrow));
        y.as_mut().map(|mut node| node.height = max(height_l, height_r) + 1);
    }
    x.as_mut().map(|mut node| node.right = y);
    {
        let height_l = height(x.as_ref().map(|node| node.left.as_ref()).flatten().map(Borrow::borrow));
        let height_r = height(x.as_ref().map(|node| node.right.as_ref()).flatten().map(Borrow::borrow));
        x.as_mut().map(|mut node| node.height = max(height_l, height_r) + 1);
    }
    // x.right = y;
    // y.unwrap().left = Some(t2);
    // Update heights
    // y.height = max(y.left.height, y.right.height) + 1
    // x.height = max(x.left.height, y.right.height) + 1
    // Return new root
    return x;
    */
}
// A utility function to left rotate subtree rooted with x
// See the diagram given above.
pub fn leftRotate(mut x: Option<Box<Node>>) -> Option<Box<Node>> {
    let mut y = x.as_mut().map(|mut node| node.right.take()).flatten();
    let mut t2 = y.as_mut().map(|mut node| node.left.take()).flatten();
    // Perform rotation
    x.as_mut().map(|mut node| node.left = t2);
    {
        let height_l = height(x.as_ref().map(|node| node.left.as_ref()).flatten().map(Borrow::borrow));
        let height_r = height(x.as_ref().map(|node| node.right.as_ref()).flatten().map(Borrow::borrow));
        x.as_mut().map(|mut node| node.height = max(height_l, height_r) + 1);
    }
    y.as_mut().map(|mut node| node.left = x);
    {
        let height_l = height(y.as_ref().map(|node| node.left.as_ref()).flatten().map(Borrow::borrow));
        let height_r = height(y.as_ref().map(|node| node.right.as_ref()).flatten().map(Borrow::borrow));
        y.as_mut().map(|mut node| node.height = max(height_l, height_r) + 1);
    }
    // Return new root
    return y;
}
// Get Balance factor of node N
pub fn getBalance(mut n: Option<&Node>) -> i32 {
    match n {
        None => 0,
        Some(node) => height(node.left.as_deref().map(Borrow::borrow)) - height(node.right.as_deref().map(Borrow::borrow)),
    }
}

pub fn insert(mut node: Option<Box<Node>>, mut key: i32)
    -> Option<Box<Node>> {
        /* 1.  Perform the normal BST rotation */
        match node {
            None => Some(newNode(key)),
            Some(mut node) => {
                if key < node.key {
                    node.left = insert(node.left, key);
                } else if key > node.key {
                    node.right = insert(node.right, key);
                } else {
                    return Some(node);
                }
                node.height = 1 + max(height(node.left.as_ref().map(Borrow::borrow)), height(node.right.as_ref().map(Borrow::borrow)));
                let mut balance = getBalance(Some(&node));
                if balance > 1 && key < node.left.as_ref().unwrap().key {
                    return rightRotate(Some(node));
                }
                if balance < -1 && key > node.right.as_ref().unwrap().key {
                    return leftRotate(Some(node));
                }
                if balance > 1 && key > node.left.as_ref().unwrap().key {
                    node.left = leftRotate(node.left);
                    return rightRotate(Some(node));
                }
                if balance < -1 && key < node.right.as_ref().unwrap().key {
                    node.right = rightRotate(node.right);
                    return leftRotate(Some(node));
                }
                Some(node)
            },
        }


    }
/* Given a non-empty binary search tree, return the
   node with minimum key value found in that tree.
   Note that the entire tree does not need to be
   searched. */
pub fn minValueNode(mut node: &Node) -> &Node {
    let mut current = node;
    /* loop down to find the leftmost leaf */
    while let Some(left) = &current.left { current = &**left; }
    return current;
}


pub fn deleteNode(mut root: Option<Box<Node>>, mut key: i32) -> Option<Box<Node>> {
    // STEP 1: PERFORM STANDARD BST DELETE
    if let None = root { return root }
    else if let Some(ref mut r_node) = root {
        if key < r_node.key {
            r_node.left = deleteNode(r_node.left.take(), key);
        } else if key > r_node.key {
            r_node.right = deleteNode(r_node.right.take(), key);
        } else if r_node.left.is_none() || r_node.right.is_none() {
            let mut temp = 
                if r_node.left.is_some() {
                    r_node.left.take()
                } else { r_node.right.take() };
            root = temp;
            // old contents of `root` and `temp` are dropped
        } else {
            let temp = minValueNode(r_node.right.as_deref().map(Borrow::borrow).unwrap());
            let key = temp.key;
            r_node.key = key;
            r_node.right = deleteNode(r_node.right.take(), key);
            // r_node.key = temp.key;
            // r_node.right = deleteNode(r_node.right, temp.key);
        }
    }

    // if let None = root { return root; }
    // else if let Some(mut r_node) = root {
    match root {
        None => { return root; },
        Some(mut r_node) => {
            r_node.height = 1 + max(height(r_node.left.as_deref().map(Borrow::borrow)), height(r_node.right.as_deref().map(Borrow::borrow)));
            let balance = getBalance(Some(&r_node));

            if balance > 1 && getBalance(r_node.left.as_deref().map(Borrow::borrow)) >= 0 {
                return rightRotate(Some(r_node));
            }

            if balance > 1 && getBalance(r_node.left.as_deref().map(Borrow::borrow)) < 0 {
                r_node.left = leftRotate(r_node.left);
                return rightRotate(Some(r_node));
            }

            if balance < -1 && getBalance(r_node.right.as_deref().map(Borrow::borrow)) <= 0 {
                return rightRotate(Some(r_node));
            }

            if balance < -1 && getBalance(r_node.right.as_deref().map(Borrow::borrow)) > 0 {
                r_node.right = rightRotate(r_node.right);
                return leftRotate(Some(r_node));
            }

            return Some(r_node);
        }
    }


}

// A utility function to print preorder traversal of
// the tree.
// The function also prints height of every node
pub fn preOrder(mut root: Option<&Node>) {
    if let Some(root) = root {
        println!("{}", root.key);
        preOrder(root.left.as_ref().map(Borrow::borrow));
        preOrder(root.right.as_ref().map(Borrow::borrow));
    }
}

/*
/* Driver program to test above function*/
#[ownership_constraints()]
unsafe fn main_0() -> i32  {
    let mut root: *mut Node = 0 as *mut Node;
    /* Constructing tree given in the above figure */
    root = insert(root, 9 as i32);
    root = insert(root, 5 as i32);
    root = insert(root, 10 as i32);
    root = insert(root, 0 as i32);
    root = insert(root, 6 as i32);
    root = insert(root, 11 as i32);
    root = insert(root, -(1 as i32));
    root = insert(root, 1 as i32);
    root = insert(root, 2 as i32);
    /* The constructed AVL Tree would be
       9
       /  \
       1    10
       /  \     \
       0    5     11
       /    /  \
       -1   2    6
       */
    printf(b"Preorder traversal of the constructed AVL tree is \n\x00" as
           *const u8 as *const libc::c_char);
    preOrder(root);
    root = deleteNode(root, 10 as i32);
    /* The AVL Tree after deletion of 10
       1
       /  \
       0    9
       /     /  \
       -1    5     11
       /  \
       2    6
       */
    printf(b"\nPreorder traversal after deletion of 10 \n\x00" as *const u8 as
           *const libc::c_char);
    preOrder(root);
    return 0 as i32;
}
#[main]#[ownership_constraints()]
pub fn main() { unsafe { ::std::process::exit(main_0() as i32) } }

*/
