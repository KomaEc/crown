Solving src::rbtree::remove_min with precision 1... ✅
Solving src::rbtree::remove_it with precision 1... ✅
Solving src::rbtree::erase_tree with precision 1... ✅
Solving src::rbtree::create_node with precision 1... ✅
Solving src::rbtree::is_red with precision 1... ✅
Solving src::rbtree::my_compare with precision 1... ✅
Solving src::rbtree::flip_color with precision 1... ✅
Solving src::rbtree::rotate_left with precision 1... ✅
Solving src::rbtree::rotate_right with precision 1... ✅
Solving src::rbtree::insert_this with precision 1... ✅
Solving src::rbtree::insert with precision 1... ✅
Solving src::rbtree::get_key with precision 1... ✅
Solving src::rbtree::min with precision 1... ✅
Solving src::rbtree::balance_me_that with precision 1... ✅
Solving src::rbtree::move_red_to_left with precision 1... ✅
Solving src::rbtree::move_red_to_right with precision 1... ✅
Solving src::rbtree::remove_key with precision 1... ✅
src::rbtree::remove_min: (&move) -> &move
src::rbtree::remove_it: (&move, _) -> &move
src::rbtree::erase_tree: (&move) -> &
src::rbtree::create_node: (_, _) -> &move
src::rbtree::is_red: (&) -> _
src::rbtree::my_compare: (_, _) -> _
src::rbtree::flip_color: (&) -> _
src::rbtree::rotate_left: (&move) -> &move
src::rbtree::rotate_right: (&move) -> &move
src::rbtree::insert_this: (&move, _, _) -> &move
src::rbtree::insert: (_, _) -> _
src::rbtree::get_key: (&, _) -> _
src::rbtree::min: (&) -> &
src::rbtree::balance_me_that: (&move) -> &move
src::rbtree::move_red_to_left: (&move) -> &move
src::rbtree::move_red_to_right: (&move) -> &move
src::rbtree::remove_key: (&move, _) -> &move
Solving src::rbtree::remove_min with precision 2... ✅
Solving src::rbtree::remove_it with precision 2... ❌
Solving src::rbtree::erase_tree with precision 2... ❌
Solving src::rbtree::create_node with precision 2... ✅
Solving src::rbtree::is_red with precision 2... ✅
Solving src::rbtree::my_compare with precision 2... ✅
Solving src::rbtree::flip_color with precision 2... ✅
Solving src::rbtree::rotate_left with precision 2... ✅
Solving src::rbtree::rotate_right with precision 2... ✅
Solving src::rbtree::insert_this with precision 2... ❌
Solving src::rbtree::insert with precision 2... ✅
Solving src::rbtree::get_key with precision 2... ✅
Solving src::rbtree::min with precision 2... ✅
Solving src::rbtree::balance_me_that with precision 2... ❌
Solving src::rbtree::move_red_to_left with precision 2... ❌
Solving src::rbtree::move_red_to_right with precision 2... ✅
Solving src::rbtree::remove_key with precision 2... ✅
src::rbtree::remove_min: (&move &move &) -> & & &
src::rbtree::remove_it: (& & &, _) -> & & &
src::rbtree::erase_tree: (&any &any &any) -> &any &any &any
src::rbtree::create_node: (_, _) -> &move &move &
src::rbtree::is_red: (& & &) -> _
src::rbtree::my_compare: (_, _) -> _
src::rbtree::flip_color: (& & &) -> _
src::rbtree::rotate_left: (& & &) -> & & &
src::rbtree::rotate_right: (& & &) -> & & &
src::rbtree::insert_this: (& &any &any, _, _) -> & & &
src::rbtree::insert: (_, _) -> _
src::rbtree::get_key: (& & &, _) -> _
src::rbtree::min: (& & &) -> & & &
src::rbtree::balance_me_that: (&move & &) -> & & &
src::rbtree::move_red_to_left: (&move &move &) -> &move &move &
src::rbtree::move_red_to_right: (& & &) -> & & &
src::rbtree::remove_key: (& & &, _) -> & & &
Solving src::rbtree::remove_min with precision 3... ✅
Solving src::rbtree::remove_it with precision 2... ❌
Solving src::rbtree::erase_tree with precision 2... ❌
Solving src::rbtree::create_node with precision 3... ✅
Solving src::rbtree::is_red with precision 3... ✅
Solving src::rbtree::my_compare with precision 3... ✅
Solving src::rbtree::flip_color with precision 3... ✅
Solving src::rbtree::rotate_left with precision 3... ✅
Solving src::rbtree::rotate_right with precision 3... ✅
Solving src::rbtree::insert_this with precision 2... ❌
Solving src::rbtree::insert with precision 3... ✅
Solving src::rbtree::get_key with precision 3... ✅
Solving src::rbtree::min with precision 3... ✅
Solving src::rbtree::balance_me_that with precision 2... ❌
Solving src::rbtree::move_red_to_left with precision 2... ❌
Solving src::rbtree::move_red_to_right with precision 3... ✅
Solving src::rbtree::remove_key with precision 3... ✅
src::rbtree::remove_min: (&move &move &move & & & &) -> & & & & & & &
src::rbtree::remove_it: (& & &, _) -> & & &
src::rbtree::erase_tree: (&any &any &any) -> &any &any &any
src::rbtree::create_node: (_, _) -> &move &move &move & & & &
src::rbtree::is_red: (& & & & & & &) -> _
src::rbtree::my_compare: (_, _) -> _
src::rbtree::flip_color: (& & & & & & &) -> _
src::rbtree::rotate_left: (& & & & & & &) -> & & & & & & &
src::rbtree::rotate_right: (& & & & & & &) -> & & & & & & &
src::rbtree::insert_this: (& & &, _, _) -> & & &
src::rbtree::insert: (_, _) -> _
src::rbtree::get_key: (& & & & & & &, _) -> _
src::rbtree::min: (& & & & & & &) -> & & & & & & &
src::rbtree::balance_me_that: (&move & &) -> & & &
src::rbtree::move_red_to_left: (&move &move &) -> &move &move &
src::rbtree::move_red_to_right: (& & & & & & &) -> & & & & & & &
src::rbtree::remove_key: (& & & & & & &, _) -> & & & & & & &
Solving src::rbtree::remove_min with precision 3... ✅
Solving src::rbtree::remove_it with precision 1... ✅
Solving src::rbtree::erase_tree with precision 1... ✅
Solving src::rbtree::create_node with precision 3... ✅
Solving src::rbtree::is_red with precision 3... ✅
Solving src::rbtree::my_compare with precision 3... ✅
Solving src::rbtree::flip_color with precision 3... ✅
Solving src::rbtree::rotate_left with precision 3... ✅
Solving src::rbtree::rotate_right with precision 3... ❌
Solving src::rbtree::insert_this with precision 1... ❌
Solving src::rbtree::insert with precision 3... ✅
Solving src::rbtree::get_key with precision 3... ✅
Solving src::rbtree::min with precision 3... ✅
Solving src::rbtree::balance_me_that with precision 1... ❌
Solving src::rbtree::move_red_to_left with precision 1... ❌
Solving src::rbtree::move_red_to_right with precision 3... ✅
Solving src::rbtree::remove_key with precision 3... ✅
src::rbtree::remove_min: (&move &move &move & & & &) -> & & & & & & &
src::rbtree::remove_it: (&move, _) -> &
src::rbtree::erase_tree: (&move) -> &
src::rbtree::create_node: (_, _) -> &move &move &move & & & &
src::rbtree::is_red: (& & & & & & &) -> _
src::rbtree::my_compare: (_, _) -> _
src::rbtree::flip_color: (& & & & & & &) -> _
src::rbtree::rotate_left: (& & & & & & &) -> & & & & & & &
src::rbtree::rotate_right: (&move &move &move & & & &) -> &move &move &move & & & &
src::rbtree::insert_this: (&, _, _) -> &
src::rbtree::insert: (_, _) -> _
src::rbtree::get_key: (& & & & & & &, _) -> _
src::rbtree::min: (& & & & & & &) -> & & & & & & &
src::rbtree::balance_me_that: (&move) -> &
src::rbtree::move_red_to_left: (&move) -> &move
src::rbtree::move_red_to_right: (&move &move &move & & & &) -> &move &move &move & & & &
src::rbtree::remove_key: (&move &move &move & & & &, _) -> & & & & & & &
Solving src::rbtree::remove_min with precision 3... ✅
Solving src::rbtree::remove_it with precision 1... ✅
Solving src::rbtree::erase_tree with precision 1... ✅
Solving src::rbtree::create_node with precision 3... ✅
Solving src::rbtree::is_red with precision 3... ✅
Solving src::rbtree::my_compare with precision 3... ✅
Solving src::rbtree::flip_color with precision 3... ✅
Solving src::rbtree::rotate_left with precision 3... ✅
Solving src::rbtree::rotate_right with precision 2... ❌
Solving src::rbtree::insert with precision 3... ✅
Solving src::rbtree::get_key with precision 3... ✅
Solving src::rbtree::min with precision 3... ✅
Solving src::rbtree::move_red_to_right with precision 3... ✅
Solving src::rbtree::remove_key with precision 3... ✅
src::rbtree::remove_min: (&move &move &move & & & &) -> & & & & & & &
src::rbtree::remove_it: (&move, _) -> &
src::rbtree::erase_tree: (&move) -> &
src::rbtree::create_node: (_, _) -> &move &move &move & & & &
src::rbtree::is_red: (& & & & & & &) -> _
src::rbtree::my_compare: (_, _) -> _
src::rbtree::flip_color: (& & & & & & &) -> _
src::rbtree::rotate_left: (& & & & & & &) -> & & & & & & &
src::rbtree::rotate_right: (&move &move &) -> &move &move &
src::rbtree::insert_this: (_, _, _) -> _
src::rbtree::insert: (_, _) -> _
src::rbtree::get_key: (& & & & & & &, _) -> _
src::rbtree::min: (& & & & & & &) -> & & & & & & &
src::rbtree::balance_me_that: (_) -> _
src::rbtree::move_red_to_left: (_) -> _
src::rbtree::move_red_to_right: (&move &move &move & & & &) -> &move &move &move & & & &
src::rbtree::remove_key: (&move &move &move & & & &, _) -> & & & & & & &
Solving src::rbtree::remove_min with precision 3... ✅
Solving src::rbtree::remove_it with precision 1... ✅
Solving src::rbtree::erase_tree with precision 1... ✅
Solving src::rbtree::create_node with precision 3... ✅
Solving src::rbtree::is_red with precision 3... ✅
Solving src::rbtree::my_compare with precision 3... ✅
Solving src::rbtree::flip_color with precision 3... ✅
Solving src::rbtree::rotate_left with precision 3... ✅
Solving src::rbtree::rotate_right with precision 1... ✅
Solving src::rbtree::insert with precision 3... ✅
Solving src::rbtree::get_key with precision 3... ✅
Solving src::rbtree::min with precision 3... ✅
Solving src::rbtree::move_red_to_right with precision 3... ✅
Solving src::rbtree::remove_key with precision 3... ✅
src::rbtree::remove_min: (&move &move &move & & & &) -> & & & & & & &
src::rbtree::remove_it: (&move, _) -> &
src::rbtree::erase_tree: (&move) -> &
src::rbtree::create_node: (_, _) -> &move &move &move & & & &
src::rbtree::is_red: (& & & & & & &) -> _
src::rbtree::my_compare: (_, _) -> _
src::rbtree::flip_color: (& & & & & & &) -> _
src::rbtree::rotate_left: (& & & & & & &) -> & & & & & & &
src::rbtree::rotate_right: (&move) -> &move
src::rbtree::insert_this: (_, _, _) -> _
src::rbtree::insert: (_, _) -> _
src::rbtree::get_key: (& & & & & & &, _) -> _
src::rbtree::min: (& & & & & & &) -> & & & & & & &
src::rbtree::balance_me_that: (_) -> _
src::rbtree::move_red_to_left: (_) -> _
src::rbtree::move_red_to_right: (&move &move &move & & & &) -> &move &move &move & & & &
src::rbtree::remove_key: (&move &move &move & & & &, _) -> & & & & & & &
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/rbtree/src/rbtree.rs:78:21: 78:35 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/rbtree/src/rbtree.rs:79:5: 79:25 (#0)
@DefId(0:18 ~ lib[40c5]::src::rbtree::is_red)
bb0:
  _4 = _1
  using: _1@Entry
  _3 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _4) -> bb1
  using: _4@Mir(bb0[0])
bb1:
  _2 = Not(move _3)
  using: _3@Mir(bb0[1])
  switchInt(move _2) -> [0: bb3, otherwise: bb2]
  using: _2@Mir(bb1[0])
bb2:
  _6 = ((*_1).2: u32)
  using: _1@Entry
  _7 = const 1_u32
  using: 
  _5 = Eq(move _6, move _7)
  using: _6@Mir(bb2[0]), _7@Mir(bb2[1])
  _0 = move _5 as i32 (IntToInt)
  using: _5@Mir(bb2[2])
  goto -> bb4
  using: 
bb3:
  _10 = _1
  using: _1@Entry
  _9 = move _10 as usize (PointerExposeAddress)
  using: _10@Mir(bb3[0])
  _8 = Eq(move _9, const 0_usize)
  using: _9@Mir(bb3[1])
  assume(move _8)
  using: _8@Mir(bb3[2])
  _0 = const 0_i32
  using: 
  goto -> bb4
  using: 
bb4:
  return
  using: _0@Phi(bb4)
@DefId(0:19 ~ lib[40c5]::src::rbtree::my_compare)
bb0:
  _4 = _1
  using: _1@Entry
  _5 = _2
  using: _2@Entry
  _3 = Eq(move _4, move _5)
  using: _4@Mir(bb0[0]), _5@Mir(bb0[1])
  switchInt(move _3) -> [0: bb2, otherwise: bb1]
  using: _3@Mir(bb0[2])
bb1:
  _0 = const 0_i32
  using: 
  goto -> bb5
  using: 
bb2:
  _7 = _1
  using: _1@Entry
  _8 = _2
  using: _2@Entry
  _6 = Lt(move _7, move _8)
  using: _7@Mir(bb2[0]), _8@Mir(bb2[1])
  switchInt(move _6) -> [0: bb4, otherwise: bb3]
  using: _6@Mir(bb2[2])
bb3:
  _0 = const -1_i32
  using: 
  goto -> bb5
  using: 
bb4:
  _0 = const 1_i32
  using: 
  goto -> bb5
  using: 
bb5:
  return
  using: _0@Phi(bb5)
@DefId(0:20 ~ lib[40c5]::src::rbtree::flip_color)
bb0:
  _5 = ((*_1).2: u32)
  using: _1@Entry
  _4 = move _5 as u64 (IntToInt)
  using: _5@Mir(bb0[0])
  _3 = Eq(move _4, const 0_u64)
  using: _4@Mir(bb0[1])
  _2 = move _3 as i32 (IntToInt)
  using: _3@Mir(bb0[2])
  ((*_1).2: u32) = move _2 as u32 (IntToInt)
  using: _1@Entry, _2@Mir(bb0[3])
  _14 = deref_copy ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _9 = ((*_14).2: u32)
  using: _14@Mir(bb0[5])
  _8 = move _9 as u64 (IntToInt)
  using: _9@Mir(bb0[6])
  _7 = Eq(move _8, const 0_u64)
  using: _8@Mir(bb0[7])
  _6 = move _7 as i32 (IntToInt)
  using: _7@Mir(bb0[8])
  _15 = deref_copy ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  ((*_15).2: u32) = move _6 as u32 (IntToInt)
  using: _15@Mir(bb0[10]), _6@Mir(bb0[9])
  _16 = deref_copy ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _13 = ((*_16).2: u32)
  using: _16@Mir(bb0[12])
  _12 = move _13 as u64 (IntToInt)
  using: _13@Mir(bb0[13])
  _11 = Eq(move _12, const 0_u64)
  using: _12@Mir(bb0[14])
  _10 = move _11 as i32 (IntToInt)
  using: _11@Mir(bb0[15])
  _17 = deref_copy ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  ((*_17).2: u32) = move _10 as u32 (IntToInt)
  using: _17@Mir(bb0[17]), _10@Mir(bb0[16])
  return
  using: _0@Entry
@DefId(0:21 ~ lib[40c5]::src::rbtree::rotate_left)
bb0:
  _2 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  _4 = _1
  using: _1@Entry
  _3 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _4) -> bb1
  using: _4@Mir(bb0[1])
bb1:
  switchInt(move _3) -> [0: bb3, otherwise: bb2]
  using: _3@Mir(bb0[2])
bb2:
  _7 = _1
  using: _1@Entry
  _6 = move _7 as usize (PointerExposeAddress)
  using: _7@Mir(bb2[0])
  _5 = Eq(move _6, const 0_usize)
  using: _6@Mir(bb2[1])
  assume(move _5)
  using: _5@Mir(bb2[2])
  _0 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  goto -> bb4
  using: 
bb3:
  _8 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _2 = move _8
  using: _8@Mir(bb3[0])
  _9 = ((*_2).3: *mut src::rbtree::s_rbnode)
  using: _2@Mir(bb3[1])
  ((*_1).4: *mut src::rbtree::s_rbnode) = move _9
  using: _1@Entry, _9@Mir(bb3[2])
  _10 = _1
  using: _1@Entry
  ((*_2).3: *mut src::rbtree::s_rbnode) = move _10
  using: _2@Mir(bb3[1]), _10@Mir(bb3[4])
  _11 = ((*_1).2: u32)
  using: _1@Entry
  ((*_2).2: u32) = move _11
  using: _2@Mir(bb3[1]), _11@Mir(bb3[6])
  ((*_1).2: u32) = const _
  using: _1@Entry
  _0 = _2
  using: _2@Mir(bb3[1])
  goto -> bb4
  using: 
bb4:
  return
  using: _0@Phi(bb4)
@DefId(0:22 ~ lib[40c5]::src::rbtree::rotate_right)
bb0:
  _2 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  _4 = _1
  using: _1@Entry
  _3 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _4) -> bb1
  using: _4@Mir(bb0[1])
bb1:
  switchInt(move _3) -> [0: bb3, otherwise: bb2]
  using: _3@Mir(bb0[2])
bb2:
  _7 = _1
  using: _1@Entry
  _6 = move _7 as usize (PointerExposeAddress)
  using: _7@Mir(bb2[0])
  _5 = Eq(move _6, const 0_usize)
  using: _6@Mir(bb2[1])
  assume(move _5)
  using: _5@Mir(bb2[2])
  _0 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  goto -> bb4
  using: 
bb3:
  _8 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _2 = move _8
  using: _8@Mir(bb3[0])
  _9 = ((*_2).4: *mut src::rbtree::s_rbnode)
  using: _2@Mir(bb3[1])
  ((*_1).3: *mut src::rbtree::s_rbnode) = move _9
  using: _1@Entry, _9@Mir(bb3[2])
  _10 = _1
  using: _1@Entry
  ((*_2).4: *mut src::rbtree::s_rbnode) = move _10
  using: _2@Mir(bb3[1]), _10@Mir(bb3[4])
  _11 = ((*_1).2: u32)
  using: _1@Entry
  ((*_2).2: u32) = move _11
  using: _2@Mir(bb3[1]), _11@Mir(bb3[6])
  ((*_1).2: u32) = const _
  using: _1@Entry
  _0 = _2
  using: _2@Mir(bb3[1])
  goto -> bb4
  using: 
bb4:
  return
  using: _0@Phi(bb4)
@DefId(0:23 ~ lib[40c5]::src::rbtree::create_node)
bb0:
  _3 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  _6 = std::mem::size_of::<src::rbtree::s_rbnode>() -> bb1
  using: 
bb1:
  _5 = move _6 as u64 (IntToInt)
  using: _6@Mir(bb0[1])
  _4 = src::rbtree::malloc(move _5) -> bb2
  using: _5@Mir(bb1[0])
bb2:
  _3 = move _4 as *mut src::rbtree::s_rbnode (PtrToPtr)
  using: _4@Mir(bb1[1])
  _8 = _3
  using: _3@Mir(bb2[0])
  _7 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _8) -> bb3
  using: _8@Mir(bb2[1])
bb3:
  switchInt(move _7) -> [0: bb5, otherwise: bb4]
  using: _7@Mir(bb2[2])
bb4:
  _11 = _3
  using: _3@Mir(bb2[0])
  _10 = move _11 as usize (PointerExposeAddress)
  using: _11@Mir(bb4[0])
  _9 = Eq(move _10, const 0_usize)
  using: _10@Mir(bb4[1])
  assume(move _9)
  using: _9@Mir(bb4[2])
  _0 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  goto -> bb6
  using: 
bb5:
  _12 = _1
  using: _1@Entry
  ((*_3).0: u32) = move _12
  using: _3@Mir(bb2[0]), _12@Mir(bb5[0])
  _13 = _2
  using: _2@Entry
  ((*_3).1: u32) = move _13
  using: _3@Mir(bb2[0]), _13@Mir(bb5[2])
  ((*_3).2: u32) = const _
  using: _3@Mir(bb2[0])
  ((*_3).3: *mut src::rbtree::s_rbnode) = const 0_usize as *mut src::rbtree::s_rbnode (PointerFromExposedAddress)
  using: _3@Mir(bb2[0])
  ((*_3).4: *mut src::rbtree::s_rbnode) = const 0_usize as *mut src::rbtree::s_rbnode (PointerFromExposedAddress)
  using: _3@Mir(bb2[0])
  _0 = _3
  using: _3@Mir(bb2[0])
  goto -> bb6
  using: 
bb6:
  return
  using: _0@Phi(bb6)
rewrite call std::mem::size_of @ workspace/rbtree/src/rbtree.rs:85:18: 85:51 (#0) by default
@DefId(0:24 ~ lib[40c5]::src::rbtree::insert_this)
bb0:
  _4 = const 0_i32
  using: 
  _6 = _1
  using: _1@Entry
  _5 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _6) -> bb1
  using: _6@Mir(bb0[1])
bb1:
  switchInt(move _5) -> [0: bb3, otherwise: bb2]
  using: _5@Mir(bb0[2])
bb2:
  _9 = _1
  using: _1@Entry
  _8 = move _9 as usize (PointerExposeAddress)
  using: _9@Mir(bb2[0])
  _7 = Eq(move _8, const 0_usize)
  using: _8@Mir(bb2[1])
  assume(move _7)
  using: _7@Mir(bb2[2])
  _10 = _2
  using: _2@Entry
  _11 = _3
  using: _3@Entry
  _0 = src::rbtree::create_node(move _10, move _11) -> bb35
  using: _10@Mir(bb2[4]), _11@Mir(bb2[5])
bb3:
  _13 = _2
  using: _2@Entry
  _14 = ((*_1).0: u32)
  using: _1@Entry
  _12 = src::rbtree::my_compare(move _13, move _14) -> bb4
  using: _13@Mir(bb3[0]), _14@Mir(bb3[1])
bb4:
  _4 = move _12
  using: _12@Mir(bb3[2])
  _16 = _4
  using: _4@Mir(bb4[0])
  _17 = const 0_i32
  using: 
  _15 = Eq(move _16, move _17)
  using: _16@Mir(bb4[1]), _17@Mir(bb4[2])
  switchInt(move _15) -> [0: bb6, otherwise: bb5]
  using: _15@Mir(bb4[3])
bb5:
  _18 = _3
  using: _3@Entry
  ((*_1).1: u32) = move _18
  using: _1@Entry, _18@Mir(bb5[0])
  goto -> bb11
  using: 
bb6:
  _20 = _4
  using: _4@Mir(bb4[0])
  _21 = const 0_i32
  using: 
  _19 = Lt(move _20, move _21)
  using: _20@Mir(bb6[0]), _21@Mir(bb6[1])
  switchInt(move _19) -> [0: bb9, otherwise: bb7]
  using: _19@Mir(bb6[2])
bb7:
  _23 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _24 = _2
  using: _2@Entry
  _25 = _3
  using: _3@Entry
  _22 = src::rbtree::insert_this(move _23, move _24, move _25) -> bb8
  using: _23@Mir(bb7[0]), _24@Mir(bb7[1]), _25@Mir(bb7[2])
bb8:
  ((*_1).3: *mut src::rbtree::s_rbnode) = move _22
  using: _1@Entry, _22@Mir(bb7[3])
  goto -> bb11
  using: 
bb9:
  _27 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _28 = _2
  using: _2@Entry
  _29 = _3
  using: _3@Entry
  _26 = src::rbtree::insert_this(move _27, move _28, move _29) -> bb10
  using: _27@Mir(bb9[0]), _28@Mir(bb9[1]), _29@Mir(bb9[2])
bb10:
  ((*_1).4: *mut src::rbtree::s_rbnode) = move _26
  using: _1@Entry, _26@Mir(bb9[3])
  goto -> bb11
  using: 
bb11:
  _32 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb11)
  _31 = src::rbtree::is_red(move _32) -> bb15
  using: _32@Mir(bb11[0])
bb12:
  _30 = const false
  using: 
  goto -> bb14
  using: 
bb13:
  _35 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb11)
  _34 = src::rbtree::is_red(move _35) -> bb16
  using: _35@Mir(bb13[0])
bb14:
  switchInt(move _30) -> [0: bb19, otherwise: bb17]
  using: _30@Phi(bb14)
bb15:
  switchInt(move _31) -> [0: bb12, otherwise: bb13]
  using: _31@Mir(bb11[1])
bb16:
  _33 = Eq(move _34, const 0_i32)
  using: _34@Mir(bb13[1])
  _30 = move _33
  using: _33@Mir(bb16[0])
  goto -> bb14
  using: 
bb17:
  _37 = _1
  using: _1@Phi(bb14)
  _36 = src::rbtree::rotate_left(move _37) -> bb18
  using: _37@Mir(bb17[0])
bb18:
  _1 = move _36
  using: _36@Mir(bb17[1])
  goto -> bb19
  using: 
bb19:
  _40 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb19)
  _39 = src::rbtree::is_red(move _40) -> bb23
  using: _40@Mir(bb19[0])
bb20:
  _38 = const false
  using: 
  goto -> bb22
  using: 
bb21:
  _54 = deref_copy ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb19)
  _43 = ((*_54).3: *mut src::rbtree::s_rbnode)
  using: _54@Mir(bb21[0])
  _42 = src::rbtree::is_red(move _43) -> bb24
  using: _43@Mir(bb21[1])
bb22:
  switchInt(move _38) -> [0: bb27, otherwise: bb25]
  using: _38@Phi(bb22)
bb23:
  switchInt(move _39) -> [0: bb20, otherwise: bb21]
  using: _39@Mir(bb19[1])
bb24:
  _41 = Ne(move _42, const 0_i32)
  using: _42@Mir(bb21[2])
  _38 = move _41
  using: _41@Mir(bb24[0])
  goto -> bb22
  using: 
bb25:
  _45 = _1
  using: _1@Phi(bb22)
  _44 = src::rbtree::rotate_right(move _45) -> bb26
  using: _45@Mir(bb25[0])
bb26:
  _1 = move _44
  using: _44@Mir(bb25[1])
  goto -> bb27
  using: 
bb27:
  _48 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb27)
  _47 = src::rbtree::is_red(move _48) -> bb31
  using: _48@Mir(bb27[0])
bb28:
  _46 = const false
  using: 
  goto -> bb30
  using: 
bb29:
  _51 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb27)
  _50 = src::rbtree::is_red(move _51) -> bb32
  using: _51@Mir(bb29[0])
bb30:
  switchInt(move _46) -> [0: bb34, otherwise: bb33]
  using: _46@Phi(bb30)
bb31:
  switchInt(move _47) -> [0: bb28, otherwise: bb29]
  using: _47@Mir(bb27[1])
bb32:
  _49 = Ne(move _50, const 0_i32)
  using: _50@Mir(bb29[1])
  _46 = move _49
  using: _49@Mir(bb32[0])
  goto -> bb30
  using: 
bb33:
  _53 = _1
  using: _1@Phi(bb30)
  _52 = src::rbtree::flip_color(move _53) -> bb34
  using: _53@Mir(bb33[0])
bb34:
  _0 = _1
  using: _1@Phi(bb34)
  goto -> bb35
  using: 
bb35:
  return
  using: _0@Phi(bb35)
@DefId(0:25 ~ lib[40c5]::src::rbtree::insert)
bb0:
  _5 = const {alloc16: *mut *mut src::rbtree::s_rbnode}
  using: 
  _4 = (*_5)
  using: _5@Mir(bb0[0])
  _6 = _1
  using: _1@Entry
  _7 = _2
  using: _2@Entry
  _3 = src::rbtree::insert_this(move _4, move _6, move _7) -> bb1
  using: _4@Mir(bb0[1]), _6@Mir(bb0[2]), _7@Mir(bb0[3])
bb1:
  _8 = const {alloc16: *mut *mut src::rbtree::s_rbnode}
  using: 
  (*_8) = move _3
  using: _8@Mir(bb1[0]), _3@Mir(bb0[4])
  _12 = const {alloc16: *mut *mut src::rbtree::s_rbnode}
  using: 
  _11 = (*_12)
  using: _12@Mir(bb1[2])
  _10 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _11) -> bb2
  using: _11@Mir(bb1[3])
bb2:
  _9 = Not(move _10)
  using: _10@Mir(bb1[4])
  switchInt(move _9) -> [0: bb4, otherwise: bb3]
  using: _9@Mir(bb2[0])
bb3:
  _13 = const {alloc16: *mut *mut src::rbtree::s_rbnode}
  using: 
  _18 = deref_copy (*_13)
  using: _13@Mir(bb3[0])
  ((*_18).2: u32) = const _
  using: _18@Mir(bb3[1])
  goto -> bb5
  using: 
bb4:
  _17 = const {alloc16: *mut *mut src::rbtree::s_rbnode}
  using: 
  _16 = (*_17)
  using: _17@Mir(bb4[0])
  _15 = move _16 as usize (PointerExposeAddress)
  using: _16@Mir(bb4[1])
  _14 = Eq(move _15, const 0_usize)
  using: _15@Mir(bb4[2])
  assume(move _14)
  using: _14@Mir(bb4[3])
  goto -> bb5
  using: 
bb5:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m rewrite immediate value, could be static, func call return
@DefId(0:26 ~ lib[40c5]::src::rbtree::get_key)
bb0:
  _3 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _6 = _1
  using: _1@Phi(bb1)
  _5 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _6) -> bb2
  using: _6@Mir(bb1[0])
bb2:
  _4 = Not(move _5)
  using: _5@Mir(bb1[1])
  switchInt(move _4) -> [0: bb10, otherwise: bb3]
  using: _4@Mir(bb2[0])
bb3:
  _8 = _2
  using: _2@Phi(bb1)
  _9 = ((*_1).0: u32)
  using: _1@Phi(bb1)
  _7 = src::rbtree::my_compare(move _8, move _9) -> bb4
  using: _8@Mir(bb3[0]), _9@Mir(bb3[1])
bb4:
  _3 = move _7
  using: _7@Mir(bb3[2])
  _10 = _3
  using: _3@Mir(bb4[0])
  switchInt(move _10) -> [0: bb5, otherwise: bb6]
  using: _10@Mir(bb4[1])
bb5:
  _0 = ((*_1).1: u32)
  using: _1@Phi(bb1)
  goto -> bb11
  using: 
bb6:
  _13 = _3
  using: _3@Mir(bb4[0])
  _14 = const 0_i32
  using: 
  _12 = Lt(move _13, move _14)
  using: _13@Mir(bb6[0]), _14@Mir(bb6[1])
  switchInt(move _12) -> [0: bb8, otherwise: bb7]
  using: _12@Mir(bb6[2])
bb7:
  _11 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb1)
  goto -> bb9
  using: 
bb8:
  _11 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb1)
  goto -> bb9
  using: 
bb9:
  _1 = move _11
  using: _11@Phi(bb9)
  goto -> bb1
  using: 
bb10:
  _17 = _1
  using: _1@Phi(bb9)
  _16 = move _17 as usize (PointerExposeAddress)
  using: _17@Mir(bb10[0])
  _15 = Eq(move _16, const 0_usize)
  using: _16@Mir(bb10[1])
  assume(move _15)
  using: _15@Mir(bb10[2])
  _0 = const 0_u32
  using: 
  goto -> bb11
  using: 
bb11:
  return
  using: _0@Phi(bb11)
@DefId(0:27 ~ lib[40c5]::src::rbtree::min)
bb0:
  _3 = _1
  using: _1@Entry
  _2 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _3) -> bb1
  using: _3@Mir(bb0[0])
bb1:
  switchInt(move _2) -> [0: bb3, otherwise: bb2]
  using: _2@Mir(bb0[1])
bb2:
  _6 = _1
  using: _1@Entry
  _5 = move _6 as usize (PointerExposeAddress)
  using: _6@Mir(bb2[0])
  _4 = Eq(move _5, const 0_usize)
  using: _5@Mir(bb2[1])
  assume(move _4)
  using: _4@Mir(bb2[2])
  _0 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  goto -> bb7
  using: 
bb3:
  _9 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb3)
  _8 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _9) -> bb4
  using: _9@Mir(bb3[0])
bb4:
  _7 = Not(move _8)
  using: _8@Mir(bb3[1])
  switchInt(move _7) -> [0: bb6, otherwise: bb5]
  using: _7@Mir(bb4[0])
bb5:
  _10 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb3)
  _1 = move _10
  using: _10@Mir(bb5[0])
  goto -> bb3
  using: 
bb6:
  _13 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb3)
  _12 = move _13 as usize (PointerExposeAddress)
  using: _13@Mir(bb6[0])
  _11 = Eq(move _12, const 0_usize)
  using: _12@Mir(bb6[1])
  assume(move _11)
  using: _11@Mir(bb6[2])
  _0 = _1
  using: _1@Phi(bb3)
  goto -> bb7
  using: 
bb7:
  return
  using: _0@Phi(bb7)
@DefId(0:28 ~ lib[40c5]::src::rbtree::balance_me_that)
bb0:
  _3 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _2 = src::rbtree::is_red(move _3) -> bb1
  using: _3@Mir(bb0[0])
bb1:
  switchInt(move _2) -> [0: bb4, otherwise: bb2]
  using: _2@Mir(bb0[1])
bb2:
  _5 = _1
  using: _1@Entry
  _4 = src::rbtree::rotate_left(move _5) -> bb3
  using: _5@Mir(bb2[0])
bb3:
  _1 = move _4
  using: _4@Mir(bb2[1])
  goto -> bb4
  using: 
bb4:
  _8 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb4)
  _7 = src::rbtree::is_red(move _8) -> bb8
  using: _8@Mir(bb4[0])
bb5:
  _6 = const false
  using: 
  goto -> bb7
  using: 
bb6:
  _22 = deref_copy ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb4)
  _11 = ((*_22).3: *mut src::rbtree::s_rbnode)
  using: _22@Mir(bb6[0])
  _10 = src::rbtree::is_red(move _11) -> bb9
  using: _11@Mir(bb6[1])
bb7:
  switchInt(move _6) -> [0: bb12, otherwise: bb10]
  using: _6@Phi(bb7)
bb8:
  switchInt(move _7) -> [0: bb5, otherwise: bb6]
  using: _7@Mir(bb4[1])
bb9:
  _9 = Ne(move _10, const 0_i32)
  using: _10@Mir(bb6[2])
  _6 = move _9
  using: _9@Mir(bb9[0])
  goto -> bb7
  using: 
bb10:
  _13 = _1
  using: _1@Phi(bb7)
  _12 = src::rbtree::rotate_right(move _13) -> bb11
  using: _13@Mir(bb10[0])
bb11:
  _1 = move _12
  using: _12@Mir(bb10[1])
  goto -> bb12
  using: 
bb12:
  _16 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb12)
  _15 = src::rbtree::is_red(move _16) -> bb16
  using: _16@Mir(bb12[0])
bb13:
  _14 = const false
  using: 
  goto -> bb15
  using: 
bb14:
  _19 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb12)
  _18 = src::rbtree::is_red(move _19) -> bb17
  using: _19@Mir(bb14[0])
bb15:
  switchInt(move _14) -> [0: bb19, otherwise: bb18]
  using: _14@Phi(bb15)
bb16:
  switchInt(move _15) -> [0: bb13, otherwise: bb14]
  using: _15@Mir(bb12[1])
bb17:
  _17 = Ne(move _18, const 0_i32)
  using: _18@Mir(bb14[1])
  _14 = move _17
  using: _17@Mir(bb17[0])
  goto -> bb15
  using: 
bb18:
  _21 = _1
  using: _1@Phi(bb15)
  _20 = src::rbtree::flip_color(move _21) -> bb19
  using: _21@Mir(bb18[0])
bb19:
  _0 = _1
  using: _1@Phi(bb19)
  return
  using: _0@Mir(bb19[0])
@DefId(0:29 ~ lib[40c5]::src::rbtree::move_red_to_left)
bb0:
  _3 = _1
  using: _1@Entry
  _2 = src::rbtree::flip_color(move _3) -> bb1
  using: _3@Mir(bb0[0])
bb1:
  _8 = _1
  using: _1@Entry
  _7 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _8) -> bb8
  using: _8@Mir(bb1[0])
bb2:
  _4 = const false
  using: 
  goto -> bb4
  using: 
bb3:
  _21 = deref_copy ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb7)
  _14 = ((*_21).3: *mut src::rbtree::s_rbnode)
  using: _21@Mir(bb3[0])
  _13 = src::rbtree::is_red(move _14) -> bb10
  using: _14@Mir(bb3[1])
bb4:
  switchInt(move _4) -> [0: bb14, otherwise: bb11]
  using: _4@Phi(bb4)
bb5:
  _5 = const false
  using: 
  goto -> bb7
  using: 
bb6:
  _11 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _10 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _11) -> bb9
  using: _11@Mir(bb6[0])
bb7:
  switchInt(move _5) -> [0: bb2, otherwise: bb3]
  using: _5@Phi(bb7)
bb8:
  _6 = Not(move _7)
  using: _7@Mir(bb1[1])
  switchInt(move _6) -> [0: bb5, otherwise: bb6]
  using: _6@Mir(bb8[0])
bb9:
  _9 = Not(move _10)
  using: _10@Mir(bb6[1])
  _5 = move _9
  using: _9@Mir(bb9[0])
  goto -> bb7
  using: 
bb10:
  _12 = Ne(move _13, const 0_i32)
  using: _13@Mir(bb3[2])
  _4 = move _12
  using: _12@Mir(bb10[0])
  goto -> bb4
  using: 
bb11:
  _16 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb4)
  _15 = src::rbtree::rotate_right(move _16) -> bb12
  using: _16@Mir(bb11[0])
bb12:
  ((*_1).4: *mut src::rbtree::s_rbnode) = move _15
  using: _1@Phi(bb4), _15@Mir(bb11[1])
  _18 = _1
  using: _1@Phi(bb4)
  _17 = src::rbtree::rotate_left(move _18) -> bb13
  using: _18@Mir(bb12[1])
bb13:
  _1 = move _17
  using: _17@Mir(bb12[2])
  _20 = _1
  using: _1@Mir(bb13[0])
  _19 = src::rbtree::flip_color(move _20) -> bb14
  using: _20@Mir(bb13[1])
bb14:
  _0 = _1
  using: _1@Phi(bb14)
  return
  using: _0@Mir(bb14[0])
@DefId(0:30 ~ lib[40c5]::src::rbtree::move_red_to_right)
bb0:
  _3 = _1
  using: _1@Entry
  _2 = src::rbtree::flip_color(move _3) -> bb1
  using: _3@Mir(bb0[0])
bb1:
  _8 = _1
  using: _1@Entry
  _7 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _8) -> bb8
  using: _8@Mir(bb1[0])
bb2:
  _4 = const false
  using: 
  goto -> bb4
  using: 
bb3:
  _19 = deref_copy ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb7)
  _14 = ((*_19).3: *mut src::rbtree::s_rbnode)
  using: _19@Mir(bb3[0])
  _13 = src::rbtree::is_red(move _14) -> bb10
  using: _14@Mir(bb3[1])
bb4:
  switchInt(move _4) -> [0: bb13, otherwise: bb11]
  using: _4@Phi(bb4)
bb5:
  _5 = const false
  using: 
  goto -> bb7
  using: 
bb6:
  _11 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _10 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _11) -> bb9
  using: _11@Mir(bb6[0])
bb7:
  switchInt(move _5) -> [0: bb2, otherwise: bb3]
  using: _5@Phi(bb7)
bb8:
  _6 = Not(move _7)
  using: _7@Mir(bb1[1])
  switchInt(move _6) -> [0: bb5, otherwise: bb6]
  using: _6@Mir(bb8[0])
bb9:
  _9 = Not(move _10)
  using: _10@Mir(bb6[1])
  _5 = move _9
  using: _9@Mir(bb9[0])
  goto -> bb7
  using: 
bb10:
  _12 = Ne(move _13, const 0_i32)
  using: _13@Mir(bb3[2])
  _4 = move _12
  using: _12@Mir(bb10[0])
  goto -> bb4
  using: 
bb11:
  _16 = _1
  using: _1@Phi(bb4)
  _15 = src::rbtree::rotate_right(move _16) -> bb12
  using: _16@Mir(bb11[0])
bb12:
  _1 = move _15
  using: _15@Mir(bb11[1])
  _18 = _1
  using: _1@Mir(bb12[0])
  _17 = src::rbtree::flip_color(move _18) -> bb13
  using: _18@Mir(bb12[1])
bb13:
  _0 = _1
  using: _1@Phi(bb13)
  return
  using: _0@Mir(bb13[0])
@DefId(0:31 ~ lib[40c5]::src::rbtree::remove_min)
bb0:
  _3 = _1
  using: _1@Entry
  _2 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _3) -> bb1
  using: _3@Mir(bb0[0])
bb1:
  switchInt(move _2) -> [0: bb3, otherwise: bb2]
  using: _2@Mir(bb0[1])
bb2:
  _6 = _1
  using: _1@Entry
  _5 = move _6 as usize (PointerExposeAddress)
  using: _6@Mir(bb2[0])
  _4 = Eq(move _5, const 0_usize)
  using: _5@Mir(bb2[1])
  assume(move _4)
  using: _4@Mir(bb2[2])
  _0 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  goto -> bb17
  using: 
bb3:
  _8 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _7 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _8) -> bb4
  using: _8@Mir(bb3[0])
bb4:
  switchInt(move _7) -> [0: bb7, otherwise: bb5]
  using: _7@Mir(bb3[1])
bb5:
  _11 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _10 = move _11 as usize (PointerExposeAddress)
  using: _11@Mir(bb5[0])
  _9 = Eq(move _10, const 0_usize)
  using: _10@Mir(bb5[1])
  assume(move _9)
  using: _9@Mir(bb5[2])
  _14 = _1
  using: _1@Entry
  _13 = move _14 as *mut libc::c_void (PtrToPtr)
  using: _14@Mir(bb5[4])
  _12 = src::rbtree::free(move _13) -> bb6
  using: _13@Mir(bb5[5])
bb6:
  _0 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  goto -> bb17
  using: 
bb7:
  _17 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _16 = src::rbtree::is_red(move _17) -> bb11
  using: _17@Mir(bb7[0])
bb8:
  _15 = const false
  using: 
  goto -> bb10
  using: 
bb9:
  _26 = deref_copy ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _20 = ((*_26).3: *mut src::rbtree::s_rbnode)
  using: _26@Mir(bb9[0])
  _19 = src::rbtree::is_red(move _20) -> bb12
  using: _20@Mir(bb9[1])
bb10:
  switchInt(move _15) -> [0: bb15, otherwise: bb13]
  using: _15@Phi(bb10)
bb11:
  switchInt(move _16) -> [0: bb9, otherwise: bb8]
  using: _16@Mir(bb7[1])
bb12:
  _18 = Eq(move _19, const 0_i32)
  using: _19@Mir(bb9[2])
  _15 = move _18
  using: _18@Mir(bb12[0])
  goto -> bb10
  using: 
bb13:
  _22 = _1
  using: _1@Phi(bb10)
  _21 = src::rbtree::move_red_to_left(move _22) -> bb14
  using: _22@Mir(bb13[0])
bb14:
  _1 = move _21
  using: _21@Mir(bb13[1])
  goto -> bb15
  using: 
bb15:
  _24 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb15)
  _23 = src::rbtree::remove_min(move _24) -> bb16
  using: _24@Mir(bb15[0])
bb16:
  ((*_1).3: *mut src::rbtree::s_rbnode) = move _23
  using: _1@Phi(bb15), _23@Mir(bb15[1])
  _25 = _1
  using: _1@Phi(bb15)
  _0 = src::rbtree::balance_me_that(move _25) -> bb17
  using: _25@Mir(bb16[1])
bb17:
  return
  using: _0@Phi(bb17)
@DefId(0:32 ~ lib[40c5]::src::rbtree::remove_it)
bb0:
  _3 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  _5 = _1
  using: _1@Entry
  _4 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _5) -> bb1
  using: _5@Mir(bb0[1])
bb1:
  switchInt(move _4) -> [0: bb3, otherwise: bb2]
  using: _4@Mir(bb0[2])
bb2:
  _8 = _1
  using: _1@Entry
  _7 = move _8 as usize (PointerExposeAddress)
  using: _8@Mir(bb2[0])
  _6 = Eq(move _7, const 0_usize)
  using: _7@Mir(bb2[1])
  assume(move _6)
  using: _6@Mir(bb2[2])
  _0 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  goto -> bb49
  using: 
bb3:
  _11 = _2
  using: _2@Entry
  _12 = ((*_1).0: u32)
  using: _1@Entry
  _10 = src::rbtree::my_compare(move _11, move _12) -> bb4
  using: _11@Mir(bb3[0]), _12@Mir(bb3[1])
bb4:
  _13 = const -1_i32
  using: 
  _9 = Eq(move _10, move _13)
  using: _10@Mir(bb3[2]), _13@Mir(bb4[0])
  switchInt(move _9) -> [0: bb18, otherwise: bb5]
  using: _9@Mir(bb4[1])
bb5:
  _16 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _15 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _16) -> bb6
  using: _16@Mir(bb5[0])
bb6:
  _14 = Not(move _15)
  using: _15@Mir(bb5[1])
  switchInt(move _14) -> [0: bb17, otherwise: bb7]
  using: _14@Mir(bb6[0])
bb7:
  _19 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _18 = src::rbtree::is_red(move _19) -> bb11
  using: _19@Mir(bb7[0])
bb8:
  _17 = const false
  using: 
  goto -> bb10
  using: 
bb9:
  _71 = deref_copy ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _22 = ((*_71).3: *mut src::rbtree::s_rbnode)
  using: _71@Mir(bb9[0])
  _21 = src::rbtree::is_red(move _22) -> bb12
  using: _22@Mir(bb9[1])
bb10:
  switchInt(move _17) -> [0: bb15, otherwise: bb13]
  using: _17@Phi(bb10)
bb11:
  switchInt(move _18) -> [0: bb9, otherwise: bb8]
  using: _18@Mir(bb7[1])
bb12:
  _20 = Eq(move _21, const 0_i32)
  using: _21@Mir(bb9[2])
  _17 = move _20
  using: _20@Mir(bb12[0])
  goto -> bb10
  using: 
bb13:
  _24 = _1
  using: _1@Phi(bb10)
  _23 = src::rbtree::move_red_to_left(move _24) -> bb14
  using: _24@Mir(bb13[0])
bb14:
  _1 = move _23
  using: _23@Mir(bb13[1])
  goto -> bb15
  using: 
bb15:
  _26 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb15)
  _27 = _2
  using: _2@Entry
  _25 = src::rbtree::remove_key(move _26, move _27) -> bb16
  using: _26@Mir(bb15[0]), _27@Mir(bb15[1])
bb16:
  ((*_1).3: *mut src::rbtree::s_rbnode) = move _25
  using: _1@Phi(bb15), _25@Mir(bb15[2])
  goto -> bb48
  using: 
bb17:
  _30 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb15)
  _29 = move _30 as usize (PointerExposeAddress)
  using: _30@Mir(bb17[0])
  _28 = Eq(move _29, const 0_usize)
  using: _29@Mir(bb17[1])
  assume(move _28)
  using: _28@Mir(bb17[2])
  goto -> bb48
  using: 
bb18:
  _32 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb15)
  _31 = src::rbtree::is_red(move _32) -> bb19
  using: _32@Mir(bb18[0])
bb19:
  switchInt(move _31) -> [0: bb22, otherwise: bb20]
  using: _31@Mir(bb18[1])
bb20:
  _34 = _1
  using: _1@Phi(bb15)
  _33 = src::rbtree::rotate_right(move _34) -> bb21
  using: _34@Mir(bb20[0])
bb21:
  _1 = move _33
  using: _33@Mir(bb20[1])
  goto -> bb22
  using: 
bb22:
  _37 = _2
  using: _2@Entry
  _38 = ((*_1).0: u32)
  using: _1@Phi(bb22)
  _36 = src::rbtree::my_compare(move _37, move _38) -> bb26
  using: _37@Mir(bb22[0]), _38@Mir(bb22[1])
bb23:
  _35 = const false
  using: 
  goto -> bb25
  using: 
bb24:
  _40 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb22)
  _39 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _40) -> bb27
  using: _40@Mir(bb24[0])
bb25:
  switchInt(move _35) -> [0: bb30, otherwise: bb28]
  using: _35@Phi(bb25)
bb26:
  switchInt(move _36) -> [0: bb24, otherwise: bb23]
  using: _36@Mir(bb22[2])
bb27:
  _35 = move _39
  using: _39@Mir(bb24[1])
  goto -> bb25
  using: 
bb28:
  _43 = _1
  using: _1@Phi(bb25)
  _42 = move _43 as *mut libc::c_void (PtrToPtr)
  using: _43@Mir(bb28[0])
  _41 = src::rbtree::free(move _42) -> bb29
  using: _42@Mir(bb28[1])
bb29:
  _0 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  goto -> bb49
  using: 
bb30:
  _46 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb25)
  _45 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _46) -> bb31
  using: _46@Mir(bb30[0])
bb31:
  _44 = Not(move _45)
  using: _45@Mir(bb30[1])
  switchInt(move _44) -> [0: bb47, otherwise: bb32]
  using: _44@Mir(bb31[0])
bb32:
  _49 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb25)
  _48 = src::rbtree::is_red(move _49) -> bb36
  using: _49@Mir(bb32[0])
bb33:
  _47 = const false
  using: 
  goto -> bb35
  using: 
bb34:
  _72 = deref_copy ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb25)
  _52 = ((*_72).3: *mut src::rbtree::s_rbnode)
  using: _72@Mir(bb34[0])
  _51 = src::rbtree::is_red(move _52) -> bb37
  using: _52@Mir(bb34[1])
bb35:
  switchInt(move _47) -> [0: bb40, otherwise: bb38]
  using: _47@Phi(bb35)
bb36:
  switchInt(move _48) -> [0: bb34, otherwise: bb33]
  using: _48@Mir(bb32[1])
bb37:
  _50 = Eq(move _51, const 0_i32)
  using: _51@Mir(bb34[2])
  _47 = move _50
  using: _50@Mir(bb37[0])
  goto -> bb35
  using: 
bb38:
  _54 = _1
  using: _1@Phi(bb35)
  _53 = src::rbtree::move_red_to_right(move _54) -> bb39
  using: _54@Mir(bb38[0])
bb39:
  _1 = move _53
  using: _53@Mir(bb38[1])
  goto -> bb40
  using: 
bb40:
  _56 = _2
  using: _2@Entry
  _57 = ((*_1).0: u32)
  using: _1@Phi(bb40)
  _55 = src::rbtree::my_compare(move _56, move _57) -> bb41
  using: _56@Mir(bb40[0]), _57@Mir(bb40[1])
bb41:
  switchInt(move _55) -> [0: bb42, otherwise: bb45]
  using: _55@Mir(bb40[2])
bb42:
  _59 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb40)
  _58 = src::rbtree::min(move _59) -> bb43
  using: _59@Mir(bb42[0])
bb43:
  _3 = move _58
  using: _58@Mir(bb42[1])
  _60 = ((*_3).0: u32)
  using: _3@Mir(bb43[0])
  ((*_1).0: u32) = move _60
  using: _1@Phi(bb40), _60@Mir(bb43[1])
  _61 = ((*_3).1: u32)
  using: _3@Mir(bb43[0])
  ((*_1).1: u32) = move _61
  using: _1@Phi(bb40), _61@Mir(bb43[3])
  _63 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb40)
  _62 = src::rbtree::remove_min(move _63) -> bb44
  using: _63@Mir(bb43[5])
bb44:
  ((*_1).4: *mut src::rbtree::s_rbnode) = move _62
  using: _1@Phi(bb40), _62@Mir(bb43[6])
  goto -> bb48
  using: 
bb45:
  _65 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb40)
  _66 = _2
  using: _2@Entry
  _64 = src::rbtree::remove_key(move _65, move _66) -> bb46
  using: _65@Mir(bb45[0]), _66@Mir(bb45[1])
bb46:
  ((*_1).4: *mut src::rbtree::s_rbnode) = move _64
  using: _1@Phi(bb40), _64@Mir(bb45[2])
  goto -> bb48
  using: 
bb47:
  _69 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb40)
  _68 = move _69 as usize (PointerExposeAddress)
  using: _69@Mir(bb47[0])
  _67 = Eq(move _68, const 0_usize)
  using: _68@Mir(bb47[1])
  assume(move _67)
  using: _67@Mir(bb47[2])
  goto -> bb48
  using: 
bb48:
  _70 = _1
  using: _1@Phi(bb48)
  _0 = src::rbtree::balance_me_that(move _70) -> bb49
  using: _70@Mir(bb48[0])
bb49:
  return
  using: _0@Phi(bb49)
@DefId(0:33 ~ lib[40c5]::src::rbtree::remove_key)
bb0:
  _4 = _1
  using: _1@Entry
  _5 = _2
  using: _2@Entry
  _3 = src::rbtree::remove_it(move _4, move _5) -> bb1
  using: _4@Mir(bb0[0]), _5@Mir(bb0[1])
bb1:
  _1 = move _3
  using: _3@Mir(bb0[2])
  _8 = _1
  using: _1@Mir(bb1[0])
  _7 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _8) -> bb2
  using: _8@Mir(bb1[1])
bb2:
  _6 = Not(move _7)
  using: _7@Mir(bb1[2])
  switchInt(move _6) -> [0: bb4, otherwise: bb3]
  using: _6@Mir(bb2[0])
bb3:
  ((*_1).2: u32) = const _
  using: _1@Mir(bb1[0])
  goto -> bb5
  using: 
bb4:
  _11 = _1
  using: _1@Mir(bb1[0])
  _10 = move _11 as usize (PointerExposeAddress)
  using: _11@Mir(bb4[0])
  _9 = Eq(move _10, const 0_usize)
  using: _10@Mir(bb4[1])
  assume(move _9)
  using: _9@Mir(bb4[2])
  goto -> bb5
  using: 
bb5:
  _0 = _1
  using: _1@Phi(bb5)
  return
  using: _0@Mir(bb5[0])
@DefId(0:34 ~ lib[40c5]::src::rbtree::erase_tree)
bb0:
  _4 = _1
  using: _1@Entry
  _3 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _4) -> bb1
  using: _4@Mir(bb0[0])
bb1:
  _2 = Not(move _3)
  using: _3@Mir(bb0[1])
  switchInt(move _2) -> [0: bb11, otherwise: bb2]
  using: _2@Mir(bb1[0])
bb2:
  _7 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _6 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _7) -> bb3
  using: _7@Mir(bb2[0])
bb3:
  _5 = Not(move _6)
  using: _6@Mir(bb2[1])
  switchInt(move _5) -> [0: bb5, otherwise: bb4]
  using: _5@Mir(bb3[0])
bb4:
  _9 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _8 = src::rbtree::erase_tree(move _9) -> bb6
  using: _9@Mir(bb4[0])
bb5:
  _12 = ((*_1).3: *mut src::rbtree::s_rbnode)
  using: _1@Entry
  _11 = move _12 as usize (PointerExposeAddress)
  using: _12@Mir(bb5[0])
  _10 = Eq(move _11, const 0_usize)
  using: _11@Mir(bb5[1])
  assume(move _10)
  using: _10@Mir(bb5[2])
  goto -> bb6
  using: 
bb6:
  _15 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb6)
  _14 = std::ptr::mut_ptr::<impl *mut src::rbtree::s_rbnode>::is_null(move _15) -> bb7
  using: _15@Mir(bb6[0])
bb7:
  _13 = Not(move _14)
  using: _14@Mir(bb6[1])
  switchInt(move _13) -> [0: bb9, otherwise: bb8]
  using: _13@Mir(bb7[0])
bb8:
  _17 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb6)
  _16 = src::rbtree::erase_tree(move _17) -> bb10
  using: _17@Mir(bb8[0])
bb9:
  _20 = ((*_1).4: *mut src::rbtree::s_rbnode)
  using: _1@Phi(bb6)
  _19 = move _20 as usize (PointerExposeAddress)
  using: _20@Mir(bb9[0])
  _18 = Eq(move _19, const 0_usize)
  using: _19@Mir(bb9[1])
  assume(move _18)
  using: _18@Mir(bb9[2])
  goto -> bb10
  using: 
bb10:
  ((*_1).3: *mut src::rbtree::s_rbnode) = const 0_usize as *mut src::rbtree::s_rbnode (PointerFromExposedAddress)
  using: _1@Phi(bb10)
  ((*_1).4: *mut src::rbtree::s_rbnode) = const 0_usize as *mut src::rbtree::s_rbnode (PointerFromExposedAddress)
  using: _1@Phi(bb10)
  _23 = _1
  using: _1@Phi(bb10)
  _22 = move _23 as *mut libc::c_void (PtrToPtr)
  using: _23@Mir(bb10[2])
  _21 = src::rbtree::free(move _22) -> bb12
  using: _22@Mir(bb10[3])
bb11:
  _26 = _1
  using: _1@Phi(bb10)
  _25 = move _26 as usize (PointerExposeAddress)
  using: _26@Mir(bb11[0])
  _24 = Eq(move _25, const 0_usize)
  using: _25@Mir(bb11[1])
  assume(move _24)
  using: _24@Mir(bb11[2])
  goto -> bb12
  using: 
bb12:
  _0 = const {0x0 as *mut src::rbtree::s_rbnode}
  using: 
  return
  using: _0@Mir(bb12[0])
use ::libc;
extern "C" {
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
}
pub type rbcolor = libc::c_uint;
pub const RED: rbcolor = 1;
pub const BLACK: rbcolor = 0;
pub type t_rbcolor = rbcolor;
pub type t_key = libc::c_uint;
pub type t_value = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
struct ErasedByRefactorer0;
#[repr(C)]
pub struct s_rbnode {
    pub key: t_key,
    pub value: t_value,
    pub color: t_rbcolor,
    pub left: *mut /* owning */ s_rbnode,
    pub right: *mut s_rbnode,
}
impl Default for s_rbnode {fn default() -> Self {Self {
key: Default::default(),
value: Default::default(),
color: Default::default(),
left: std::ptr::null_mut(),
right: std::ptr::null_mut(),
}}}
impl s_rbnode {pub fn take(&mut self) -> Self {core::mem::take(self)}}

pub type t_rbnode = s_rbnode;
#[no_mangle]
pub static mut root_rbtree: *mut t_rbnode = 0 as *const t_rbnode as *mut t_rbnode;
#[inline]
unsafe extern "C" fn is_red(mut node: *const t_rbnode) -> libc::c_int {
    return if !node.is_null() {
        ((*node).color as libc::c_uint == RED as libc::c_int as libc::c_uint) as libc::c_int
    } else {
        ();
        0 as libc::c_int
    };
}
#[inline]
unsafe extern "C" fn my_compare(mut key1: libc::c_uint, mut key2: libc::c_uint) -> libc::c_int {
    return if key1 == key2 {
        0 as libc::c_int
    } else if key1 < key2 {
        -(1 as libc::c_int)
    } else {
        1 as libc::c_int
    };
}
unsafe extern "C" fn flip_color(mut node: *mut t_rbnode) {
    (*node).color= ((*node).color as u64 == 0) as libc::c_int as t_rbcolor;
    (*(*node).left).color= ((*(*node).left).color as u64 == 0) as libc::c_int as t_rbcolor;
    (*(*node).right).color= ((*(*node).right).color as u64 == 0) as libc::c_int as t_rbcolor;
}
unsafe extern "C" fn rotate_left(mut left: *mut t_rbnode) -> *mut t_rbnode {
    let mut right = 0 as *mut t_rbnode;
    if left.is_null() {
        ();
        return 0 as *mut t_rbnode;
    }
    right= (*left).right;
    // let ref mut fresh0 = (*left).right;
    // *fresh0 = (*right).left;
    (*left).right= (*right).left;
    // let ref mut fresh1 = (*right).left;
    // *fresh1 = left;
    (*right).left= left;
    (*right).color= (*left).color;
    (*left).color= RED;
    return right;
}
unsafe extern "C" fn rotate_right(mut right: Option<Box<t_rbnode>>) -> Option<Box<t_rbnode>> {
    let mut left = None;
    if right.as_deref().is_none() {
        ();
        return None;
    }
    left= Some(Box::from_raw((*right.as_deref_mut().unwrap()).left));
    // let ref mut fresh2 = (*right).left;
    // *fresh2 = (*left).right;
    (*right.as_deref_mut().unwrap()).left= (*left.as_deref().unwrap()).right;
    // let ref mut fresh3 = (*left).right;
    // *fresh3 = right;
    (*left.as_deref_mut().unwrap()).right= core::mem::transmute::<_, *mut crate::src::rbtree::s_rbnode>(right.as_deref_mut());
    (*left.as_deref_mut().unwrap()).color= (*right.as_deref().unwrap()).color;
    (*right.as_deref_mut().unwrap()).color= RED;
    return left;
}
#[no_mangle]
pub unsafe extern "C" fn create_node(mut key: t_key, mut value: t_value) -> Option<Box<t_rbnode>> {
    let mut new = None;
    new= Some(Box::new(<crate::src::rbtree::s_rbnode as Default>::default()));
    if new.as_deref().is_none() {
        ();
        return None;
    }
    (*new.as_deref_mut().unwrap()).key= key;
    (*new.as_deref_mut().unwrap()).value= value;
    (*new.as_deref_mut().unwrap()).color= RED;
    // let ref mut fresh4 = (*new).left;
    // *fresh4 = 0 as *mut t_rbnode;
    (*new.as_deref_mut().unwrap()).left= 0 as *mut t_rbnode;
    // let ref mut fresh5 = (*new).right;
    // *fresh5 = 0 as *mut t_rbnode;
    (*new.as_deref_mut().unwrap()).right= 0 as *mut t_rbnode;
    return new;
}
unsafe extern "C" fn insert_this(
    mut node: *mut t_rbnode,
    mut key: t_key,
    mut value: t_value,
) -> *mut t_rbnode {
    let mut res: libc::c_int = 0;
    if node.is_null() {
        ();
        return create_node(key, value);
    }
    res= my_compare(key, (*node).key);
    if res == 0 as libc::c_int {
        (*node).value= value;
    } else if res < 0 as libc::c_int {
        // let ref mut fresh6 = (*node).left;
        // *fresh6 = insert_this((*node).left, key, value);
        (*node).left= insert_this((*node).left, key, value);
    } else {
        // let ref mut fresh7 = (*node).right;
        // *fresh7 = insert_this((*node).right, key, value);
        (*node).right= insert_this((*node).right, key, value);
    }
    if is_red((*node).right) != 0 && is_red((*node).left as *const crate::src::rbtree::s_rbnode) == 0 {
        node= rotate_left(node);
    }
    if is_red((*node).left as *const crate::src::rbtree::s_rbnode) != 0 && is_red((*(*node).left).left as *const crate::src::rbtree::s_rbnode) != 0 {
        node= rotate_right(Some(Box::from_raw(node)));
    }
    if is_red((*node).left as *const crate::src::rbtree::s_rbnode) != 0 && is_red((*node).right) != 0 {
        flip_color(node);
    }
    return node;
}
#[no_mangle]
pub unsafe extern "C" fn insert(mut key: t_key, mut value: t_value) {
    root_rbtree = insert_this(root_rbtree, key, value);
    if !root_rbtree.is_null() {
        (*root_rbtree).color = BLACK;
    } else {
        ();
    }
}
#[no_mangle]
pub unsafe extern "C" fn get_key(mut node: *const t_rbnode, mut key: t_key) -> t_value {
    let mut cmp: libc::c_int = 0;
    while !node.is_null() {
        cmp= my_compare(key, (*node).key);
        if cmp == 0 {
            return (*node).value;
        }
        node= if cmp < 0 as libc::c_int {
            (*node).left as *const crate::src::rbtree::s_rbnode
        } else {
            (*node).right
        };
    }
    ();
    return 0 as libc::c_int as t_value;
}
unsafe extern "C" fn min(mut node: *const t_rbnode) -> *const t_rbnode {
    if node.is_null() {
        ();
        return 0 as *mut t_rbnode;
    }
    while !(*node).left.is_null() {
        node= (*node).left as *const crate::src::rbtree::s_rbnode;
    }
    ();
    return node;
}
#[inline]
unsafe extern "C" fn balance_me_that(mut node: *mut t_rbnode) -> *mut t_rbnode {
    if is_red((*node).right) != 0 {
        node= rotate_left(node);
    }
    if is_red((*node).left as *const crate::src::rbtree::s_rbnode) != 0 && is_red((*(*node).left).left as *const crate::src::rbtree::s_rbnode) != 0 {
        node= rotate_right(Some(Box::from_raw(node)));
    }
    if is_red((*node).left as *const crate::src::rbtree::s_rbnode) != 0 && is_red((*node).right) != 0 {
        flip_color(node);
    }
    return node;
}
unsafe extern "C" fn move_red_to_left(mut node: *mut t_rbnode) -> *mut t_rbnode {
    flip_color(node);
    if !node.is_null() && !(*node).right.is_null() && is_red((*(*node).right).left as *const crate::src::rbtree::s_rbnode) != 0 {
        // let ref mut fresh8 = (*node).right;
        // *fresh8 = rotate_right((*node).right);
        (*node).right= rotate_right(Some(Box::from_raw((*node).right)));
        node= rotate_left(node);
        flip_color(node);
    }
    return node;
}
unsafe extern "C" fn move_red_to_right(mut node: Option<Box<t_rbnode>>) -> Option<Box<t_rbnode>> {
    flip_color(core::mem::transmute::<_, *mut crate::src::rbtree::s_rbnode>(node.as_deref_mut()));
    if !node.as_deref().is_none() && !(*node.as_deref().unwrap()).left.is_null() && is_red((*(*node.as_deref().unwrap()).left).left as *const crate::src::rbtree::s_rbnode) != 0 {
        node= rotate_right(node);
        flip_color(core::mem::transmute::<_, *mut crate::src::rbtree::s_rbnode>(node.as_deref_mut()));
    }
    return node;
}
unsafe extern "C" fn remove_min(mut node: Option<Box<t_rbnode>>) -> *mut t_rbnode {
    if node.as_deref().is_none() {
        ();
        return 0 as *mut t_rbnode;
    }
    if (*node.as_deref().unwrap()).left.is_null() {
        ();
        // std::intrinsics::assume((*node).right as usize == 0);
        ();
        return 0 as *mut t_rbnode;
    }
    if is_red((*node.as_deref().unwrap()).left as *const crate::src::rbtree::s_rbnode) == 0 && is_red((*(*node.as_deref().unwrap()).left).left as *const crate::src::rbtree::s_rbnode) == 0 {
        node= move_red_to_left(core::mem::transmute::<_, *mut crate::src::rbtree::s_rbnode>(node.as_deref_mut()));
    }
    // let ref mut fresh9 = (*node).left;
    // *fresh9 = remove_min((*node).left);
    (*node.as_deref_mut().unwrap()).left= remove_min(Some(Box::from_raw((*node.as_deref_mut().unwrap()).left)));
    return balance_me_that(core::mem::transmute::<_, *mut crate::src::rbtree::s_rbnode>(node.as_deref_mut()));
}
unsafe extern "C" fn remove_it(mut node: Option<Box<t_rbnode>>, mut key: t_key) -> *mut t_rbnode {
    let mut tmp = 0 as *mut t_rbnode;
    if node.as_deref().is_none() {
        ();
        return 0 as *mut t_rbnode;
    }
    if my_compare(key, (*node.as_deref().unwrap()).key) == -(1 as libc::c_int) {
        if !(*node.as_deref().unwrap()).left.is_null() {
            if is_red((*node.as_deref().unwrap()).left as *const crate::src::rbtree::s_rbnode) == 0 && is_red((*(*node.as_deref().unwrap()).left).left as *const crate::src::rbtree::s_rbnode) == 0 {
                node= move_red_to_left(core::mem::transmute::<_, *mut crate::src::rbtree::s_rbnode>(node.as_deref_mut()));
            }
            // let ref mut fresh10 = (*node).left;
            // *fresh10 = remove_key((*node).left, key);
            (*node.as_deref_mut().unwrap()).left= remove_key((*node.as_deref().unwrap()).left, key);
        } else {
            ();
        }
    } else {
        if is_red((*node.as_deref().unwrap()).left as *const crate::src::rbtree::s_rbnode) != 0 {
            node= rotate_right(node);
        }
        if my_compare(key, (*node.as_deref().unwrap()).key) == 0 && (*node.as_deref().unwrap()).right.is_null() {
            // std::intrinsics::assume((*node).left as usize == 0);
            // std::intrinsics::assume((*node).right as usize == 0);
            ();
            return 0 as *mut t_rbnode;
        }
        if !(*node.as_deref().unwrap()).right.is_null() {
            if is_red((*node.as_deref().unwrap()).right) == 0 && is_red((*(*node.as_deref().unwrap()).right).left as *const crate::src::rbtree::s_rbnode) == 0 {
                node= move_red_to_right(node);
            }
            if my_compare(key, (*node.as_deref().unwrap()).key) == 0 {
                tmp= min((*node.as_deref().unwrap()).right);
                (*node.as_deref_mut().unwrap()).key= (*tmp).key;
                (*node.as_deref_mut().unwrap()).value= (*tmp).value;
                // let ref mut fresh11 = (*node).right;
                // *fresh11 = remove_min((*node).right);
                (*node.as_deref_mut().unwrap()).right= remove_min(Some(Box::from_raw((*node.as_deref().unwrap()).right)));
            } else {
                // let ref mut fresh12 = (*node).right;
                // *fresh12 = remove_key((*node).right, key);
                (*node.as_deref_mut().unwrap()).right= remove_key((*node.as_deref().unwrap()).right, key);
            }
        } else {
            ();
        }
    }
    return balance_me_that(core::mem::transmute::<_, *mut crate::src::rbtree::s_rbnode>(node.as_deref_mut()));
}
#[no_mangle]
pub unsafe extern "C" fn remove_key(mut node: *mut t_rbnode, mut key: t_key) -> *mut t_rbnode {
    node= remove_it(Some(Box::from_raw(node)), key);
    if !node.is_null() {
        (*node).color= BLACK;
    } else {
        ();
    }
    return node;
}
#[no_mangle]
pub unsafe extern "C" fn erase_tree(mut node: Option<Box<t_rbnode>>) -> *const t_rbnode {
    if !node.as_deref().is_none() {
        if !(*node.as_deref().unwrap()).left.is_null() {
            erase_tree(Some(Box::from_raw((*node.as_deref_mut().unwrap()).left)));
        } else {
            ();
        }
        if !(*node.as_deref().unwrap()).right.is_null() {
            erase_tree(Some(Box::from_raw((*node.as_deref().unwrap()).right)));
        } else {
            ();
        }
        // let ref mut fresh13 = (*node).left;
        // *fresh13 = 0 as *mut t_rbnode;
        (*node.as_deref_mut().unwrap()).left= 0 as *mut t_rbnode;
        // let ref mut fresh14 = (*node).right;
        // *fresh14 = 0 as *mut t_rbnode;
        (*node.as_deref_mut().unwrap()).right= 0 as *mut t_rbnode;
        ();
    } else {
        ();
    }
    return 0 as *mut t_rbnode;
}
