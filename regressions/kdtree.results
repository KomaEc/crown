Solving src::kdtree::hyperrect_create with precision 1... ✅
Solving src::kdtree::hyperrect_free with precision 1... ✅
Solving src::kdtree::clear_rec with precision 1... ✅
Solving src::kdtree::insert_rec with precision 1... ✅
Solving src::kdtree::kd_insertf with precision 1... ❌
Solving src::kdtree::kd_nearestf with precision 1... ❌
Solving src::kdtree::kd_nearest_rangef with precision 1... ❌
Solving src::kdtree::kd_nearest with precision 1... ✅
Solving src::kdtree::kd_nearest_range with precision 1... ✅
Solving src::kdtree::kd_free with precision 1... ✅
Solving src::kdtree::kd_res_free with precision 1... ✅
Solving src::kdtree::kd_create with precision 1... ✅
Solving src::kdtree::alloc_resnode with precision 1... ✅
Solving src::kdtree::kd_clear with precision 1... ✅
Solving src::kdtree::kd_data_destructor with precision 1... ✅
Solving src::kdtree::kd_insert with precision 1... ✅
Solving src::kdtree::kd_insert3 with precision 1... ✅
Solving src::kdtree::kd_insert3f with precision 1... ✅
Solving src::kdtree::find_nearest with precision 1... ✅
Solving src::kdtree::kd_nearest_i with precision 1... ✅
Solving src::kdtree::kd_nearest3 with precision 1... ✅
Solving src::kdtree::kd_nearest3f with precision 1... ✅
Solving src::kdtree::kd_nearest_range3 with precision 1... ✅
Solving src::kdtree::kd_nearest_range3f with precision 1... ✅
Solving src::kdtree::kd_res_size with precision 1... ✅
Solving src::kdtree::kd_res_rewind with precision 1... ✅
Solving src::kdtree::kd_res_end with precision 1... ✅
Solving src::kdtree::kd_res_next with precision 1... ✅
Solving src::kdtree::kd_res_item with precision 1... ✅
Solving src::kdtree::kd_res_itemf with precision 1... ✅
Solving src::kdtree::kd_res_item3 with precision 1... ✅
Solving src::kdtree::kd_res_item3f with precision 1... ✅
Solving src::kdtree::kd_res_item_data with precision 1... ✅
Solving src::kdtree::hyperrect_duplicate with precision 1... ✅
Solving src::kdtree::hyperrect_extend with precision 1... ✅
Solving src::kdtree::hyperrect_dist_sq with precision 1... ✅
Solving src::kdtree::free_resnode with precision 1... ✅
Solving src::kdtree::rlist_insert with precision 1... ✅
Solving src::kdtree::clear_results with precision 1... ✅
src::kdtree::hyperrect_create: (_, &, &) -> &move
src::kdtree::hyperrect_free: (&move) -> _
src::kdtree::clear_rec: (&move, _) -> _
src::kdtree::insert_rec: (&, &, &, _, _) -> _
src::kdtree::kd_insertf: (&any, &any, &any) -> _
src::kdtree::kd_nearestf: (&any, &any) -> &any
src::kdtree::kd_nearest_rangef: (&any, &any, _) -> &any
src::kdtree::kd_nearest: (&, &) -> &move
src::kdtree::kd_nearest_range: (&, &, _) -> &move
src::kdtree::kd_free: (&move) -> _
src::kdtree::kd_res_free: (&move) -> _
src::kdtree::kd_create: (_) -> &move
src::kdtree::alloc_resnode: () -> &move
src::kdtree::kd_clear: (&uniq  ↓ &uniq ) -> _
src::kdtree::kd_data_destructor: (&uniq  ↓ &uniq , _) -> _
src::kdtree::kd_insert: (&, &, &) -> _
src::kdtree::kd_insert3: (&, _, _, _, &) -> _
src::kdtree::kd_insert3f: (&, _, _, _, &) -> _
src::kdtree::find_nearest: (&, &, _, &uniq  ↓ &uniq , _, _) -> _
src::kdtree::kd_nearest_i: (&, &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &) -> _
src::kdtree::kd_nearest3: (&, _, _, _) -> &move
src::kdtree::kd_nearest3f: (&, _, _, _) -> &move
src::kdtree::kd_nearest_range3: (&, _, _, _, _) -> &move
src::kdtree::kd_nearest_range3f: (&, _, _, _, _) -> &move
src::kdtree::kd_res_size: (&) -> _
src::kdtree::kd_res_rewind: (&uniq  ↓ &uniq ) -> _
src::kdtree::kd_res_end: (&) -> _
src::kdtree::kd_res_next: (&uniq  ↓ &uniq ) -> _
src::kdtree::kd_res_item: (&, &) -> &
src::kdtree::kd_res_itemf: (&, &) -> &
src::kdtree::kd_res_item3: (&, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item3f: (&, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item_data: (&) -> &
src::kdtree::hyperrect_duplicate: (&) -> &move
src::kdtree::hyperrect_extend: (&uniq  ↓ &uniq , &) -> _
src::kdtree::hyperrect_dist_sq: (&, &) -> _
src::kdtree::free_resnode: (&) -> _
src::kdtree::rlist_insert: (&, &, _) -> _
src::kdtree::clear_results: (&uniq  ↓ &uniq ) -> _
Solving src::kdtree::hyperrect_create with precision 2... ✅
Solving src::kdtree::hyperrect_free with precision 2... ✅
Solving src::kdtree::clear_rec with precision 2... ✅
Solving src::kdtree::insert_rec with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for src::kdtree::insert_rec!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for src::kdtree::insert_rec!
❌
Solving src::kdtree::kd_insertf with precision 2... ❌
Solving src::kdtree::kd_nearestf with precision 2... ❌
Solving src::kdtree::kd_nearest_rangef with precision 2... ❌
Solving src::kdtree::kd_nearest with precision 2... ✅
Solving src::kdtree::kd_nearest_range with precision 2... ✅
Solving src::kdtree::kd_free with precision 2... ✅
Solving src::kdtree::kd_res_free with precision 2... ✅
Solving src::kdtree::kd_create with precision 2... ✅
Solving src::kdtree::alloc_resnode with precision 2... ❌
Solving src::kdtree::kd_clear with precision 2... ✅
Solving src::kdtree::kd_data_destructor with precision 2... ✅
Solving src::kdtree::kd_insert with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for src::kdtree::insert_rec!
❌
Solving src::kdtree::kd_insert3 with precision 2... ✅
Solving src::kdtree::kd_insert3f with precision 2... ✅
Solving src::kdtree::find_nearest with precision 2... ✅
Solving src::kdtree::kd_nearest_i with precision 2... ✅
Solving src::kdtree::kd_nearest3 with precision 2... ✅
Solving src::kdtree::kd_nearest3f with precision 2... ✅
Solving src::kdtree::kd_nearest_range3 with precision 2... ✅
Solving src::kdtree::kd_nearest_range3f with precision 2... ✅
Solving src::kdtree::kd_res_size with precision 2... ✅
Solving src::kdtree::kd_res_rewind with precision 2... ✅
Solving src::kdtree::kd_res_end with precision 2... ✅
Solving src::kdtree::kd_res_next with precision 2... ✅
Solving src::kdtree::kd_res_item with precision 2... ✅
Solving src::kdtree::kd_res_itemf with precision 2... ✅
Solving src::kdtree::kd_res_item3 with precision 2... ✅
Solving src::kdtree::kd_res_item3f with precision 2... ✅
Solving src::kdtree::kd_res_item_data with precision 2... ✅
Solving src::kdtree::hyperrect_duplicate with precision 2... ✅
Solving src::kdtree::hyperrect_extend with precision 2... ✅
Solving src::kdtree::hyperrect_dist_sq with precision 2... ✅
Solving src::kdtree::free_resnode with precision 2... ✅
Solving src::kdtree::rlist_insert with precision 2... ❌
Solving src::kdtree::clear_results with precision 2... ❌
src::kdtree::hyperrect_create: (_, &, &) -> &move &move &move
src::kdtree::hyperrect_free: (&move &move &move) -> _
src::kdtree::clear_rec: (&move &move & &move &move, _) -> _
src::kdtree::insert_rec: (&any &any, &any, &any, _, _) -> _
src::kdtree::kd_insertf: (&any &any &any, &any, &any) -> _
src::kdtree::kd_nearestf: (&any &any &any, &any) -> &any &any &any &any
src::kdtree::kd_nearest_rangef: (&any &any &any, &any, _) -> &any &any &any &any
src::kdtree::kd_nearest: (& & &, &) -> &move & &move &
src::kdtree::kd_nearest_range: (& & &, &, _) -> &move & &move &
src::kdtree::kd_free: (&move &move &move) -> _
src::kdtree::kd_res_free: (&move & &move &) -> _
src::kdtree::kd_create: (_) -> &move &move &move
src::kdtree::alloc_resnode: () -> &move & &
src::kdtree::kd_clear: (&uniq &move &move ↓ &uniq & &) -> _
src::kdtree::kd_data_destructor: (&uniq & & ↓ &uniq & &, _) -> _
src::kdtree::kd_insert: (& & &, &, &) -> _
src::kdtree::kd_insert3: (& & &, _, _, _, &) -> _
src::kdtree::kd_insert3f: (& & &, _, _, _, &) -> _
src::kdtree::find_nearest: (& & & & &, &, _, &uniq & & ↓ &uniq & &, _, _) -> _
src::kdtree::kd_nearest_i: (& & & & &, &, &uniq & ↓ &uniq &, &uniq  ↓ &uniq , & & &) -> _
src::kdtree::kd_nearest3: (& & &, _, _, _) -> &move & &move &
src::kdtree::kd_nearest3f: (& & &, _, _, _) -> &move & &move &
src::kdtree::kd_nearest_range3: (& & &, _, _, _, _) -> &move & &move &
src::kdtree::kd_nearest_range3f: (& & &, _, _, _, _) -> &move & &move &
src::kdtree::kd_res_size: (& & & &) -> _
src::kdtree::kd_res_rewind: (&uniq & &move & ↓ &uniq & &move &) -> _
src::kdtree::kd_res_end: (& & & &) -> _
src::kdtree::kd_res_next: (&uniq & & & ↓ &uniq & & &) -> _
src::kdtree::kd_res_item: (& & & &, &) -> &
src::kdtree::kd_res_itemf: (& & & &, &) -> &
src::kdtree::kd_res_item3: (& & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item3f: (& & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item_data: (& & & &) -> &
src::kdtree::hyperrect_duplicate: (& & &) -> &move &move &move
src::kdtree::hyperrect_extend: (&uniq & & ↓ &uniq & &, &) -> _
src::kdtree::hyperrect_dist_sq: (& & &, &) -> _
src::kdtree::free_resnode: (& & &) -> _
src::kdtree::rlist_insert: (& & &, & & & & &, _) -> _
src::kdtree::clear_results: (&uniq & &move & ↓ &uniq & & &) -> _
Solving src::kdtree::hyperrect_create with precision 3... ✅
Solving src::kdtree::hyperrect_free with precision 3... ✅
Solving src::kdtree::clear_rec with precision 3... ✅
Solving src::kdtree::insert_rec with precision 3... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for src::kdtree::insert_rec!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for src::kdtree::insert_rec!
❌
Solving src::kdtree::kd_insertf with precision 2... ❌
Solving src::kdtree::kd_nearestf with precision 2... ❌
Solving src::kdtree::kd_nearest_rangef with precision 2... ❌
Solving src::kdtree::kd_nearest with precision 3... ✅
Solving src::kdtree::kd_nearest_range with precision 3... ✅
Solving src::kdtree::kd_free with precision 3... ✅
Solving src::kdtree::kd_res_free with precision 3... ✅
Solving src::kdtree::kd_create with precision 3... ✅
Solving src::kdtree::alloc_resnode with precision 3... ❌
Solving src::kdtree::kd_clear with precision 3... ✅
Solving src::kdtree::kd_data_destructor with precision 3... ✅
Solving src::kdtree::kd_insert with precision 3... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for src::kdtree::insert_rec!
❌
Solving src::kdtree::kd_insert3 with precision 3... ✅
Solving src::kdtree::kd_insert3f with precision 3... ✅
Solving src::kdtree::find_nearest with precision 3... ✅
Solving src::kdtree::kd_nearest_i with precision 3... ✅
Solving src::kdtree::kd_nearest3 with precision 3... ✅
Solving src::kdtree::kd_nearest3f with precision 3... ✅
Solving src::kdtree::kd_nearest_range3 with precision 3... ✅
Solving src::kdtree::kd_nearest_range3f with precision 3... ✅
Solving src::kdtree::kd_res_size with precision 3... ✅
Solving src::kdtree::kd_res_rewind with precision 3... ✅
Solving src::kdtree::kd_res_end with precision 3... ✅
Solving src::kdtree::kd_res_next with precision 3... ✅
Solving src::kdtree::kd_res_item with precision 3... ✅
Solving src::kdtree::kd_res_itemf with precision 3... ✅
Solving src::kdtree::kd_res_item3 with precision 3... ✅
Solving src::kdtree::kd_res_item3f with precision 3... ✅
Solving src::kdtree::kd_res_item_data with precision 3... ✅
Solving src::kdtree::hyperrect_duplicate with precision 3... ✅
Solving src::kdtree::hyperrect_extend with precision 3... ✅
Solving src::kdtree::hyperrect_dist_sq with precision 3... ✅
Solving src::kdtree::free_resnode with precision 3... ✅
Solving src::kdtree::rlist_insert with precision 3... ❌
Solving src::kdtree::clear_results with precision 3... ❌
src::kdtree::hyperrect_create: (_, &, &) -> &move &move &move
src::kdtree::hyperrect_free: (&move &move &move) -> _
src::kdtree::clear_rec: (&move &move & &move &move & &move &move &move &move & &move &move, _) -> _
src::kdtree::insert_rec: (&any &any &any &any &any &any, &any, &any, _, _) -> _
src::kdtree::kd_insertf: (&any &any &any, &any, &any) -> _
src::kdtree::kd_nearestf: (&any &any &any, &any) -> &any &any &any &any
src::kdtree::kd_nearest_rangef: (&any &any &any, &any, _) -> &any &any &any &any
src::kdtree::kd_nearest: (& & & & & & & & &, &) -> &move & & & &move & & & & &
src::kdtree::kd_nearest_range: (& & & & & & & & &, &, _) -> &move & & & &move & & & & &
src::kdtree::kd_free: (&move &move &move & &move &move &move &move &move) -> _
src::kdtree::kd_res_free: (&move & & & &move & & & & &) -> _
src::kdtree::kd_create: (_) -> &move &move &move & &move &move &move &move &move
src::kdtree::alloc_resnode: () -> &move & & & & & & & &
src::kdtree::kd_clear: (&uniq &move &move & &move &move &move &move &move ↓ &uniq & & & & & & & &) -> _
src::kdtree::kd_data_destructor: (&uniq & & & & & & & & ↓ &uniq & & & & & & & &, _) -> _
src::kdtree::kd_insert: (& & & & & & & & &, &, &) -> _
src::kdtree::kd_insert3: (& & & & & & & & &, _, _, _, &) -> _
src::kdtree::kd_insert3f: (& & & & & & & & &, _, _, _, &) -> _
src::kdtree::find_nearest: (& & & & & & & & & & & & &, &, _, &uniq & & & & & & & & ↓ &uniq & & & & & & & &, _, _) -> _
src::kdtree::kd_nearest_i: (& & & & & & & & & & & & &, &, &uniq & & & & & ↓ &uniq & & & & &, &uniq  ↓ &uniq , & & &) -> _
src::kdtree::kd_nearest3: (& & & & & & & & &, _, _, _) -> &move & & & &move & & & & &
src::kdtree::kd_nearest3f: (& & & & & & & & &, _, _, _) -> &move & & & &move & & & & &
src::kdtree::kd_nearest_range3: (& & & & & & & & &, _, _, _, _) -> &move & & & &move & & & & &
src::kdtree::kd_nearest_range3f: (& & & & & & & & &, _, _, _, _) -> &move & & & &move & & & & &
src::kdtree::kd_res_size: (& & & & & & & & & &) -> _
src::kdtree::kd_res_rewind: (&uniq & & & &move & & & & & ↓ &uniq & & & &move & & & & &) -> _
src::kdtree::kd_res_end: (& & & & & & & & & &) -> _
src::kdtree::kd_res_next: (&uniq & & & & & & & & & ↓ &uniq & & & & & & & & &) -> _
src::kdtree::kd_res_item: (& & & & & & & & & &, &) -> &
src::kdtree::kd_res_itemf: (& & & & & & & & & &, &) -> &
src::kdtree::kd_res_item3: (& & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item3f: (& & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item_data: (& & & & & & & & & &) -> &
src::kdtree::hyperrect_duplicate: (& & &) -> &move &move &move
src::kdtree::hyperrect_extend: (&uniq & & ↓ &uniq & &, &) -> _
src::kdtree::hyperrect_dist_sq: (& & &, &) -> _
src::kdtree::free_resnode: (& & & & & & & & &) -> _
src::kdtree::rlist_insert: (& & & & & & & & &, & & & & & & & & & & & & &, _) -> _
src::kdtree::clear_results: (&uniq & & & &move & & & & & ↓ &uniq & & & & & & & & &) -> _
Solving src::kdtree::hyperrect_create with precision 4... ✅
Solving src::kdtree::hyperrect_free with precision 4... ✅
Solving src::kdtree::clear_rec with precision 4... ✅
Solving src::kdtree::insert_rec with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for src::kdtree::insert_rec!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for src::kdtree::insert_rec!
❌
Solving src::kdtree::kd_insertf with precision 1... ❌
Solving src::kdtree::kd_nearestf with precision 1... ❌
Solving src::kdtree::kd_nearest_rangef with precision 1... ❌
Solving src::kdtree::kd_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_range with precision 4... ✅
Solving src::kdtree::kd_free with precision 4... ✅
Solving src::kdtree::kd_res_free with precision 4... ✅
Solving src::kdtree::kd_create with precision 4... ✅
Solving src::kdtree::alloc_resnode with precision 2... ❌
Solving src::kdtree::kd_clear with precision 4... ✅
Solving src::kdtree::kd_data_destructor with precision 4... ✅
Solving src::kdtree::kd_insert with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for src::kdtree::insert_rec!
❌
Solving src::kdtree::kd_insert3 with precision 4... ✅
Solving src::kdtree::kd_insert3f with precision 4... ✅
Solving src::kdtree::find_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_i with precision 4... ✅
Solving src::kdtree::kd_nearest3 with precision 4... ✅
Solving src::kdtree::kd_nearest3f with precision 4... ✅
Solving src::kdtree::kd_nearest_range3 with precision 4... ✅
Solving src::kdtree::kd_nearest_range3f with precision 4... ✅
Solving src::kdtree::kd_res_size with precision 4... ✅
Solving src::kdtree::kd_res_rewind with precision 4... ✅
Solving src::kdtree::kd_res_end with precision 4... ✅
Solving src::kdtree::kd_res_next with precision 4... ✅
Solving src::kdtree::kd_res_item with precision 4... ✅
Solving src::kdtree::kd_res_itemf with precision 4... ✅
Solving src::kdtree::kd_res_item3 with precision 4... ✅
Solving src::kdtree::kd_res_item3f with precision 4... ✅
Solving src::kdtree::kd_res_item_data with precision 4... ✅
Solving src::kdtree::hyperrect_duplicate with precision 4... ✅
Solving src::kdtree::hyperrect_extend with precision 4... ✅
Solving src::kdtree::hyperrect_dist_sq with precision 4... ✅
Solving src::kdtree::free_resnode with precision 4... ✅
Solving src::kdtree::rlist_insert with precision 2... ❌
Solving src::kdtree::clear_results with precision 2... ❌
src::kdtree::hyperrect_create: (_, &, &) -> &move &move &move
src::kdtree::hyperrect_free: (&move &move &move) -> _
src::kdtree::clear_rec: (&move &move & &move &move & &move &move & &move &move &move &move & &move &move &move &move & &move &move & &move &move &move &move & &move &move, _) -> _
src::kdtree::insert_rec: (&any &any, &any, &any, _, _) -> _
src::kdtree::kd_insertf: (&any, &any, &any) -> _
src::kdtree::kd_nearestf: (&any, &any) -> &any
src::kdtree::kd_nearest_rangef: (&any, &any, _) -> &any
src::kdtree::kd_nearest: (& & & & & & & & & & & & & & & & &, &) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range: (& & & & & & & & & & & & & & & & &, &, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_free: (&move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move) -> _
src::kdtree::kd_res_free: (&move & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_create: (_) -> &move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move
src::kdtree::alloc_resnode: () -> &move & &
src::kdtree::kd_clear: (&uniq &move &move & &move &move & &move &move &move &move & &move &move &move &move &move ↓ &uniq & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_data_destructor: (&uniq & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & &, _) -> _
src::kdtree::kd_insert: (& & &, &, &) -> _
src::kdtree::kd_insert3: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::kd_insert3f: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::find_nearest: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, _, &uniq & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & &, _, _) -> _
src::kdtree::kd_nearest_i: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, &uniq & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & &, &uniq  ↓ &uniq , & & &) -> _
src::kdtree::kd_nearest3: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest3f: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3f: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_res_size: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_rewind: (&uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_end: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_next: (&uniq & & & & & & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_item: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_itemf: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_item3: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item3f: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item_data: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> &
src::kdtree::hyperrect_duplicate: (& & &) -> &move &move &move
src::kdtree::hyperrect_extend: (&uniq & & ↓ &uniq & &, &) -> _
src::kdtree::hyperrect_dist_sq: (& & &, &) -> _
src::kdtree::free_resnode: (& & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::rlist_insert: (& & &, & & & & &, _) -> _
src::kdtree::clear_results: (&uniq & &move & ↓ &uniq & & &) -> _
Solving src::kdtree::hyperrect_create with precision 4... ✅
Solving src::kdtree::hyperrect_free with precision 4... ✅
Solving src::kdtree::clear_rec with precision 4... ✅
Solving src::kdtree::insert_rec with precision 1... ✅
Solving src::kdtree::kd_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_range with precision 4... ✅
Solving src::kdtree::kd_free with precision 4... ✅
Solving src::kdtree::kd_res_free with precision 4... ✅
Solving src::kdtree::kd_create with precision 4... ✅
Solving src::kdtree::alloc_resnode with precision 1... ✅
Solving src::kdtree::kd_clear with precision 4... ✅
Solving src::kdtree::kd_data_destructor with precision 4... ✅
Solving src::kdtree::kd_insert with precision 1... ✅
Solving src::kdtree::kd_insert3 with precision 4... ✅
Solving src::kdtree::kd_insert3f with precision 4... ✅
Solving src::kdtree::find_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_i with precision 4... ✅
Solving src::kdtree::kd_nearest3 with precision 4... ✅
Solving src::kdtree::kd_nearest3f with precision 4... ✅
Solving src::kdtree::kd_nearest_range3 with precision 4... ✅
Solving src::kdtree::kd_nearest_range3f with precision 4... ✅
Solving src::kdtree::kd_res_size with precision 4... ✅
Solving src::kdtree::kd_res_rewind with precision 4... ✅
Solving src::kdtree::kd_res_end with precision 4... ✅
Solving src::kdtree::kd_res_next with precision 4... ✅
Solving src::kdtree::kd_res_item with precision 4... ✅
Solving src::kdtree::kd_res_itemf with precision 4... ✅
Solving src::kdtree::kd_res_item3 with precision 4... ✅
Solving src::kdtree::kd_res_item3f with precision 4... ✅
Solving src::kdtree::kd_res_item_data with precision 4... ✅
Solving src::kdtree::hyperrect_duplicate with precision 4... ✅
Solving src::kdtree::hyperrect_extend with precision 4... ✅
Solving src::kdtree::hyperrect_dist_sq with precision 4... ✅
Solving src::kdtree::free_resnode with precision 4... ✅
Solving src::kdtree::rlist_insert with precision 1... ✅
Solving src::kdtree::clear_results with precision 1... ✅
src::kdtree::hyperrect_create: (_, &, &) -> &move &move &move
src::kdtree::hyperrect_free: (&move &move &move) -> _
src::kdtree::clear_rec: (&move &move & &move &move & &move &move & &move &move &move &move & &move &move &move &move & &move &move & &move &move &move &move & &move &move, _) -> _
src::kdtree::insert_rec: (&, &, &, _, _) -> _
src::kdtree::kd_insertf: (_, _, _) -> _
src::kdtree::kd_nearestf: (_, _) -> _
src::kdtree::kd_nearest_rangef: (_, _, _) -> _
src::kdtree::kd_nearest: (& & & & & & & & & & & & & & & & &, &) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range: (& & & & & & & & & & & & & & & & &, &, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_free: (&move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move) -> _
src::kdtree::kd_res_free: (&move & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_create: (_) -> &move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move
src::kdtree::alloc_resnode: () -> &move
src::kdtree::kd_clear: (&uniq &move &move & &move &move & &move &move &move &move & &move &move &move &move &move ↓ &uniq & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_data_destructor: (&uniq & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & &, _) -> _
src::kdtree::kd_insert: (&, &, &) -> _
src::kdtree::kd_insert3: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::kd_insert3f: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::find_nearest: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, _, &uniq & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & &, _, _) -> _
src::kdtree::kd_nearest_i: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, &uniq & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & &, &uniq  ↓ &uniq , & & &) -> _
src::kdtree::kd_nearest3: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest3f: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3f: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_res_size: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_rewind: (&uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_end: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_next: (&uniq & & & & & & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_item: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_itemf: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_item3: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item3f: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item_data: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> &
src::kdtree::hyperrect_duplicate: (& & &) -> &move &move &move
src::kdtree::hyperrect_extend: (&uniq & & ↓ &uniq & &, &) -> _
src::kdtree::hyperrect_dist_sq: (& & &, &) -> _
src::kdtree::free_resnode: (& & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::rlist_insert: (&, &, _) -> _
src::kdtree::clear_results: (&uniq  ↓ &uniq ) -> _
Solving src::kdtree::hyperrect_create with precision 4... ✅
Solving src::kdtree::hyperrect_free with precision 4... ✅
Solving src::kdtree::clear_rec with precision 4... ✅
Solving src::kdtree::insert_rec with precision 1... ✅
Solving src::kdtree::kd_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_range with precision 4... ✅
Solving src::kdtree::kd_free with precision 4... ✅
Solving src::kdtree::kd_res_free with precision 4... ✅
Solving src::kdtree::kd_create with precision 4... ✅
Solving src::kdtree::alloc_resnode with precision 1... ✅
Solving src::kdtree::kd_clear with precision 4... ✅
Solving src::kdtree::kd_data_destructor with precision 4... ✅
Solving src::kdtree::kd_insert with precision 1... ✅
Solving src::kdtree::kd_insert3 with precision 4... ✅
Solving src::kdtree::kd_insert3f with precision 4... ✅
Solving src::kdtree::find_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_i with precision 4... ✅
Solving src::kdtree::kd_nearest3 with precision 4... ✅
Solving src::kdtree::kd_nearest3f with precision 4... ✅
Solving src::kdtree::kd_nearest_range3 with precision 4... ✅
Solving src::kdtree::kd_nearest_range3f with precision 4... ✅
Solving src::kdtree::kd_res_size with precision 4... ✅
Solving src::kdtree::kd_res_rewind with precision 4... ✅
Solving src::kdtree::kd_res_end with precision 4... ✅
Solving src::kdtree::kd_res_next with precision 4... ✅
Solving src::kdtree::kd_res_item with precision 4... ✅
Solving src::kdtree::kd_res_itemf with precision 4... ✅
Solving src::kdtree::kd_res_item3 with precision 4... ✅
Solving src::kdtree::kd_res_item3f with precision 4... ✅
Solving src::kdtree::kd_res_item_data with precision 4... ✅
Solving src::kdtree::hyperrect_duplicate with precision 4... ✅
Solving src::kdtree::hyperrect_extend with precision 4... ✅
Solving src::kdtree::hyperrect_dist_sq with precision 4... ✅
Solving src::kdtree::free_resnode with precision 4... ✅
Solving src::kdtree::rlist_insert with precision 1... ✅
Solving src::kdtree::clear_results with precision 1... ✅
src::kdtree::hyperrect_create: (_, &, &) -> &move &move &move
src::kdtree::hyperrect_free: (&move &move &move) -> _
src::kdtree::clear_rec: (&move &move & &move &move & &move &move & &move &move &move &move & &move &move &move &move & &move &move & &move &move &move &move & &move &move, _) -> _
src::kdtree::insert_rec: (&, &, &, _, _) -> _
src::kdtree::kd_insertf: (_, _, _) -> _
src::kdtree::kd_nearestf: (_, _) -> _
src::kdtree::kd_nearest_rangef: (_, _, _) -> _
src::kdtree::kd_nearest: (& & & & & & & & & & & & & & & & &, &) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range: (& & & & & & & & & & & & & & & & &, &, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_free: (&move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move) -> _
src::kdtree::kd_res_free: (&move & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_create: (_) -> &move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move
src::kdtree::alloc_resnode: () -> &move
src::kdtree::kd_clear: (&uniq &move &move & &move &move & &move &move &move &move & &move &move &move &move &move ↓ &uniq & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_data_destructor: (&uniq & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & &, _) -> _
src::kdtree::kd_insert: (&, &, &) -> _
src::kdtree::kd_insert3: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::kd_insert3f: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::find_nearest: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, _, &uniq & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & &, _, _) -> _
src::kdtree::kd_nearest_i: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, &uniq & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & &, &uniq  ↓ &uniq , & & &) -> _
src::kdtree::kd_nearest3: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest3f: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3f: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_res_size: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_rewind: (&uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_end: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_next: (&uniq & & & & & & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_item: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_itemf: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_item3: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item3f: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item_data: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> &
src::kdtree::hyperrect_duplicate: (& & &) -> &move &move &move
src::kdtree::hyperrect_extend: (&uniq & & ↓ &uniq & &, &) -> _
src::kdtree::hyperrect_dist_sq: (& & &, &) -> _
src::kdtree::free_resnode: (& & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::rlist_insert: (&, &, _) -> _
src::kdtree::clear_results: (&uniq  ↓ &uniq ) -> _
Solving src::kdtree::hyperrect_create with precision 4... ✅
Solving src::kdtree::hyperrect_free with precision 4... ✅
Solving src::kdtree::clear_rec with precision 4... ✅
Solving src::kdtree::insert_rec with precision 1... ✅
Solving src::kdtree::kd_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_range with precision 4... ✅
Solving src::kdtree::kd_free with precision 4... ✅
Solving src::kdtree::kd_res_free with precision 4... ✅
Solving src::kdtree::kd_create with precision 4... ✅
Solving src::kdtree::alloc_resnode with precision 1... ✅
Solving src::kdtree::kd_clear with precision 4... ✅
Solving src::kdtree::kd_data_destructor with precision 4... ✅
Solving src::kdtree::kd_insert with precision 1... ✅
Solving src::kdtree::kd_insert3 with precision 4... ✅
Solving src::kdtree::kd_insert3f with precision 4... ✅
Solving src::kdtree::find_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_i with precision 4... ✅
Solving src::kdtree::kd_nearest3 with precision 4... ✅
Solving src::kdtree::kd_nearest3f with precision 4... ✅
Solving src::kdtree::kd_nearest_range3 with precision 4... ✅
Solving src::kdtree::kd_nearest_range3f with precision 4... ✅
Solving src::kdtree::kd_res_size with precision 4... ✅
Solving src::kdtree::kd_res_rewind with precision 4... ✅
Solving src::kdtree::kd_res_end with precision 4... ✅
Solving src::kdtree::kd_res_next with precision 4... ✅
Solving src::kdtree::kd_res_item with precision 4... ✅
Solving src::kdtree::kd_res_itemf with precision 4... ✅
Solving src::kdtree::kd_res_item3 with precision 4... ✅
Solving src::kdtree::kd_res_item3f with precision 4... ✅
Solving src::kdtree::kd_res_item_data with precision 4... ✅
Solving src::kdtree::hyperrect_duplicate with precision 4... ✅
Solving src::kdtree::hyperrect_extend with precision 4... ✅
Solving src::kdtree::hyperrect_dist_sq with precision 4... ✅
Solving src::kdtree::free_resnode with precision 4... ✅
Solving src::kdtree::rlist_insert with precision 1... ✅
Solving src::kdtree::clear_results with precision 1... ✅
src::kdtree::hyperrect_create: (_, &, &) -> &move &move &move
src::kdtree::hyperrect_free: (&move &move &move) -> _
src::kdtree::clear_rec: (&move &move & &move &move & &move &move & &move &move &move &move & &move &move &move &move & &move &move & &move &move &move &move & &move &move, _) -> _
src::kdtree::insert_rec: (&, &, &, _, _) -> _
src::kdtree::kd_insertf: (_, _, _) -> _
src::kdtree::kd_nearestf: (_, _) -> _
src::kdtree::kd_nearest_rangef: (_, _, _) -> _
src::kdtree::kd_nearest: (& & & & & & & & & & & & & & & & &, &) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range: (& & & & & & & & & & & & & & & & &, &, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_free: (&move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move) -> _
src::kdtree::kd_res_free: (&move & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_create: (_) -> &move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move
src::kdtree::alloc_resnode: () -> &move
src::kdtree::kd_clear: (&uniq &move &move & &move &move & &move &move &move &move & &move &move &move &move &move ↓ &uniq & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_data_destructor: (&uniq & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & &, _) -> _
src::kdtree::kd_insert: (&, &, &) -> _
src::kdtree::kd_insert3: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::kd_insert3f: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::find_nearest: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, _, &uniq & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & &, _, _) -> _
src::kdtree::kd_nearest_i: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, &uniq & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & &, &uniq  ↓ &uniq , & & &) -> _
src::kdtree::kd_nearest3: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest3f: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3f: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_res_size: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_rewind: (&uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_end: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_next: (&uniq & & & & & & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_item: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_itemf: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_item3: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item3f: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item_data: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> &
src::kdtree::hyperrect_duplicate: (& & &) -> &move &move &move
src::kdtree::hyperrect_extend: (&uniq & & ↓ &uniq & &, &) -> _
src::kdtree::hyperrect_dist_sq: (& & &, &) -> _
src::kdtree::free_resnode: (& & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::rlist_insert: (&, &, _) -> _
src::kdtree::clear_results: (&uniq  ↓ &uniq ) -> _
Solving src::kdtree::hyperrect_create with precision 4... ✅
Solving src::kdtree::hyperrect_free with precision 4... ✅
Solving src::kdtree::clear_rec with precision 4... ✅
Solving src::kdtree::insert_rec with precision 1... ✅
Solving src::kdtree::kd_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_range with precision 4... ✅
Solving src::kdtree::kd_free with precision 4... ✅
Solving src::kdtree::kd_res_free with precision 4... ✅
Solving src::kdtree::kd_create with precision 4... ✅
Solving src::kdtree::alloc_resnode with precision 1... ✅
Solving src::kdtree::kd_clear with precision 4... ✅
Solving src::kdtree::kd_data_destructor with precision 4... ✅
Solving src::kdtree::kd_insert with precision 1... ✅
Solving src::kdtree::kd_insert3 with precision 4... ✅
Solving src::kdtree::kd_insert3f with precision 4... ✅
Solving src::kdtree::find_nearest with precision 4... ✅
Solving src::kdtree::kd_nearest_i with precision 4... ✅
Solving src::kdtree::kd_nearest3 with precision 4... ✅
Solving src::kdtree::kd_nearest3f with precision 4... ✅
Solving src::kdtree::kd_nearest_range3 with precision 4... ✅
Solving src::kdtree::kd_nearest_range3f with precision 4... ✅
Solving src::kdtree::kd_res_size with precision 4... ✅
Solving src::kdtree::kd_res_rewind with precision 4... ✅
Solving src::kdtree::kd_res_end with precision 4... ✅
Solving src::kdtree::kd_res_next with precision 4... ✅
Solving src::kdtree::kd_res_item with precision 4... ✅
Solving src::kdtree::kd_res_itemf with precision 4... ✅
Solving src::kdtree::kd_res_item3 with precision 4... ✅
Solving src::kdtree::kd_res_item3f with precision 4... ✅
Solving src::kdtree::kd_res_item_data with precision 4... ✅
Solving src::kdtree::hyperrect_duplicate with precision 4... ✅
Solving src::kdtree::hyperrect_extend with precision 4... ✅
Solving src::kdtree::hyperrect_dist_sq with precision 4... ✅
Solving src::kdtree::free_resnode with precision 4... ✅
Solving src::kdtree::rlist_insert with precision 1... ✅
Solving src::kdtree::clear_results with precision 1... ✅
src::kdtree::hyperrect_create: (_, &, &) -> &move &move &move
src::kdtree::hyperrect_free: (&move &move &move) -> _
src::kdtree::clear_rec: (&move &move & &move &move & &move &move & &move &move &move &move & &move &move &move &move & &move &move & &move &move &move &move & &move &move, _) -> _
src::kdtree::insert_rec: (&, &, &, _, _) -> _
src::kdtree::kd_insertf: (_, _, _) -> _
src::kdtree::kd_nearestf: (_, _) -> _
src::kdtree::kd_nearest_rangef: (_, _, _) -> _
src::kdtree::kd_nearest: (& & & & & & & & & & & & & & & & &, &) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range: (& & & & & & & & & & & & & & & & &, &, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_free: (&move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move) -> _
src::kdtree::kd_res_free: (&move & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_create: (_) -> &move &move &move & &move &move & &move &move &move &move & &move &move &move &move &move
src::kdtree::alloc_resnode: () -> &move
src::kdtree::kd_clear: (&uniq &move &move & &move &move & &move &move &move &move & &move &move &move &move &move ↓ &uniq & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_data_destructor: (&uniq & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & &, _) -> _
src::kdtree::kd_insert: (&, &, &) -> _
src::kdtree::kd_insert3: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::kd_insert3f: (& & & & & & & & & & & & & & & & &, _, _, _, &) -> _
src::kdtree::find_nearest: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, _, &uniq & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & &, _, _) -> _
src::kdtree::kd_nearest_i: (& & & & & & & & & & & & & & & & & & & & & & & & & & & & &, &, &uniq & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & &, &uniq  ↓ &uniq , & & &) -> _
src::kdtree::kd_nearest3: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest3f: (& & & & & & & & & & & & & & & & &, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_nearest_range3f: (& & & & & & & & & & & & & & & & &, _, _, _, _) -> &move & & & & & & & & & &move & & & & & & & & & & & & & & & & &
src::kdtree::kd_res_size: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_rewind: (&uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & &move & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_end: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_next: (&uniq & & & & & & & & & & & & & & & & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::kd_res_item: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_itemf: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &) -> &
src::kdtree::kd_res_item3: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item3f: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> &
src::kdtree::kd_res_item_data: (& & & & & & & & & & & & & & & & & & & & & & & & & & & &) -> &
src::kdtree::hyperrect_duplicate: (& & &) -> &move &move &move
src::kdtree::hyperrect_extend: (&uniq & & ↓ &uniq & &, &) -> _
src::kdtree::hyperrect_dist_sq: (& & &, &) -> _
src::kdtree::free_resnode: (& & & & & & & & & & & & & & & & & & & & & & &) -> _
src::kdtree::rlist_insert: (&, &, _) -> _
src::kdtree::clear_results: (&uniq  ↓ &uniq ) -> _
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/kdtree/src/kdtree.rs:166:16: 166:27 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/kdtree/src/kdtree.rs:167:20: 167:31 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/kdtree/src/kdtree.rs:167:45: 167:58 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/kdtree/src/kdtree.rs:167:66: 167:77 (#0)
@DefId(0:16 ~ lib[40c5]::src::kdtree::kd_create)
bb0:
  _2 = const {0x0 as *mut src::kdtree::kdtree}
  using: 
  _5 = std::mem::size_of::<src::kdtree::kdtree>() -> bb1
  using: 
bb1:
  _4 = move _5 as u64 (IntToInt)
  using: _5@Mir(bb0[1])
  _3 = src::kdtree::malloc(move _4) -> bb2
  using: _4@Mir(bb1[0])
bb2:
  _2 = move _3 as *mut src::kdtree::kdtree (PtrToPtr)
  using: _3@Mir(bb1[1])
  _7 = _2
  using: _2@Mir(bb2[0])
  _6 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdtree>::is_null(move _7) -> bb3
  using: _7@Mir(bb2[1])
bb3:
  switchInt(move _6) -> [0: bb5, otherwise: bb4]
  using: _6@Mir(bb2[2])
bb4:
  _10 = _2
  using: _2@Mir(bb2[0])
  _9 = move _10 as usize (PointerExposeAddress)
  using: _10@Mir(bb4[0])
  _8 = Eq(move _9, const 0_usize)
  using: _9@Mir(bb4[1])
  assume(move _8)
  using: _8@Mir(bb4[2])
  _0 = const {0x0 as *mut src::kdtree::kdtree}
  using: 
  goto -> bb6
  using: 
bb5:
  _11 = _1
  using: _1@Entry
  ((*_2).0: i32) = move _11
  using: _2@Mir(bb2[0]), _11@Mir(bb5[0])
  ((*_2).1: *mut src::kdtree::kdnode) = const 0_usize as *mut src::kdtree::kdnode (PointerFromExposedAddress)
  using: _2@Mir(bb2[0])
  Deinit(_12)
  using: 
  discriminant(_12) = 0
  using: 
  ((*_2).3: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>) = move _12
  using: _2@Mir(bb2[0]), _12@Mir(bb5[3])
  ((*_2).2: *mut src::kdtree::kdhyperrect) = const 0_usize as *mut src::kdtree::kdhyperrect (PointerFromExposedAddress)
  using: _2@Mir(bb2[0])
  _0 = _2
  using: _2@Mir(bb2[0])
  goto -> bb6
  using: 
bb6:
  return
  using: _0@Phi(bb6)
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:83:19: 83:50 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_12) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_12) = 0 is ignored
@DefId(0:17 ~ lib[40c5]::src::kdtree::kd_free)
bb0:
  _4 = _1
  using: _1@Entry
  _3 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdtree>::is_null(move _4) -> bb1
  using: _4@Mir(bb0[0])
bb1:
  _2 = Not(move _3)
  using: _3@Mir(bb0[1])
  switchInt(move _2) -> [0: bb4, otherwise: bb2]
  using: _2@Mir(bb1[0])
bb2:
  _6 = _1
  using: _1@Entry
  _5 = src::kdtree::kd_clear(move _6) -> bb3
  using: _6@Mir(bb2[0])
bb3:
  _9 = _1
  using: _1@Entry
  _8 = move _9 as *mut libc::c_void (PtrToPtr)
  using: _9@Mir(bb3[0])
  _7 = src::kdtree::free(move _8) -> bb5
  using: _8@Mir(bb3[1])
bb4:
  _12 = _1
  using: _1@Entry
  _11 = move _12 as usize (PointerExposeAddress)
  using: _12@Mir(bb4[0])
  _10 = Eq(move _11, const 0_usize)
  using: _11@Mir(bb4[1])
  assume(move _10)
  using: _10@Mir(bb4[2])
  goto -> bb5
  using: 
bb5:
  return
  using: _0@Entry
@DefId(0:18 ~ lib[40c5]::src::kdtree::clear_rec)
bb0:
  _4 = _1
  using: _1@Entry
  _3 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdnode>::is_null(move _4) -> bb1
  using: _4@Mir(bb0[0])
bb1:
  switchInt(move _3) -> [0: bb3, otherwise: bb2]
  using: _3@Mir(bb0[1])
bb2:
  _7 = _1
  using: _1@Entry
  _6 = move _7 as usize (PointerExposeAddress)
  using: _7@Mir(bb2[0])
  _5 = Eq(move _6, const 0_usize)
  using: _6@Mir(bb2[1])
  assume(move _5)
  using: _5@Mir(bb2[2])
  goto -> bb11
  using: 
bb3:
  _9 = ((*_1).3: *mut src::kdtree::kdnode)
  using: _1@Entry
  _10 = _2
  using: _2@Entry
  _8 = src::kdtree::clear_rec(move _9, move _10) -> bb4
  using: _9@Mir(bb3[0]), _10@Mir(bb3[1])
bb4:
  _12 = ((*_1).4: *mut src::kdtree::kdnode)
  using: _1@Entry
  _13 = _2
  using: _2@Entry
  _11 = src::kdtree::clear_rec(move _12, move _13) -> bb5
  using: _12@Mir(bb4[0]), _13@Mir(bb4[1])
bb5:
  _15 = &_2
  using: _2@Entry
  _14 = std::option::Option::<unsafe extern "C" fn(*mut libc::c_void)>::is_some(move _15) -> bb6
  using: _15@Mir(bb5[0])
bb6:
  switchInt(move _14) -> [0: bb9, otherwise: bb7]
  using: _14@Mir(bb5[1])
bb7:
  _18 = _2
  using: _2@Entry
  _20 = const "non-null function pointer"
  using: 
  _19 = _20
  using: _20@Mir(bb7[1])
  _17 = std::option::Option::<unsafe extern "C" fn(*mut libc::c_void)>::expect(move _18, move _19) -> bb8
  using: _18@Mir(bb7[0]), _19@Mir(bb7[2])
bb8:
  _21 = ((*_1).2: *mut libc::c_void)
  using: _1@Entry
  _16 = move _17(move _21) -> bb9
  using: _17@Entry, _21@Mir(bb8[0])
bb9:
  _24 = ((*_1).0: *mut f64)
  using: _1@Phi(bb9)
  _23 = move _24 as *mut libc::c_void (PtrToPtr)
  using: _24@Mir(bb9[0])
  _22 = src::kdtree::free(move _23) -> bb10
  using: _23@Mir(bb9[1])
bb10:
  _27 = _1
  using: _1@Phi(bb9)
  _26 = move _27 as *mut libc::c_void (PtrToPtr)
  using: _27@Mir(bb10[0])
  _25 = src::kdtree::free(move _26) -> bb11
  using: _26@Mir(bb10[1])
bb11:
  return
  using: _0@Entry
rewrite call std::option::Option::<T>::is_some @ workspace/kdtree/src/kdtree.rs:109:14: 109:23 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call std::option::Option::<T>::expect @ workspace/kdtree/src/kdtree.rs:110:15: 110:50 (#0) by default
@DefId(0:19 ~ lib[40c5]::src::kdtree::kd_clear)
bb0:
  _3 = ((*_1).1: *mut src::kdtree::kdnode)
  using: _1@Entry
  _4 = ((*_1).3: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>)
  using: _1@Entry
  _2 = src::kdtree::clear_rec(move _3, move _4) -> bb1
  using: _3@Mir(bb0[0]), _4@Mir(bb0[1])
bb1:
  ((*_1).1: *mut src::kdtree::kdnode) = const 0_usize as *mut src::kdtree::kdnode (PointerFromExposedAddress)
  using: _1@Entry
  _7 = ((*_1).2: *mut src::kdtree::kdhyperrect)
  using: _1@Entry
  _6 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdhyperrect>::is_null(move _7) -> bb2
  using: _7@Mir(bb1[1])
bb2:
  _5 = Not(move _6)
  using: _6@Mir(bb1[2])
  switchInt(move _5) -> [0: bb5, otherwise: bb3]
  using: _5@Mir(bb2[0])
bb3:
  _9 = ((*_1).2: *mut src::kdtree::kdhyperrect)
  using: _1@Entry
  _8 = src::kdtree::hyperrect_free(move _9) -> bb4
  using: _9@Mir(bb3[0])
bb4:
  ((*_1).2: *mut src::kdtree::kdhyperrect) = const 0_usize as *mut src::kdtree::kdhyperrect (PointerFromExposedAddress)
  using: _1@Entry
  goto -> bb6
  using: 
bb5:
  _12 = ((*_1).2: *mut src::kdtree::kdhyperrect)
  using: _1@Entry
  _11 = move _12 as usize (PointerExposeAddress)
  using: _12@Mir(bb5[0])
  _10 = Eq(move _11, const 0_usize)
  using: _11@Mir(bb5[1])
  assume(move _10)
  using: _10@Mir(bb5[2])
  goto -> bb6
  using: 
bb6:
  return
  using: _0@Entry
@DefId(0:20 ~ lib[40c5]::src::kdtree::kd_data_destructor)
bb0:
  _3 = _2
  using: _2@Entry
  ((*_1).3: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>) = move _3
  using: _1@Entry, _3@Mir(bb0[0])
  return
  using: _0@Entry
@DefId(0:21 ~ lib[40c5]::src::kdtree::insert_rec)
bb0:
  _6 = const 0_i32
  using: 
  _7 = const {0x0 as *mut src::kdtree::kdnode}
  using: 
  _9 = (*_1)
  using: _1@Entry
  _8 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdnode>::is_null(move _9) -> bb1
  using: _9@Mir(bb0[2])
bb1:
  switchInt(move _8) -> [0: bb18, otherwise: bb2]
  using: _8@Mir(bb0[3])
bb2:
  _12 = (*_1)
  using: _1@Entry
  _11 = move _12 as usize (PointerExposeAddress)
  using: _12@Mir(bb2[0])
  _10 = Eq(move _11, const 0_usize)
  using: _11@Mir(bb2[1])
  assume(move _10)
  using: _10@Mir(bb2[2])
  _15 = std::mem::size_of::<src::kdtree::kdnode>() -> bb3
  using: 
bb3:
  _14 = move _15 as u64 (IntToInt)
  using: _15@Mir(bb2[4])
  _13 = src::kdtree::malloc(move _14) -> bb4
  using: _14@Mir(bb3[0])
bb4:
  _7 = move _13 as *mut src::kdtree::kdnode (PtrToPtr)
  using: _13@Mir(bb3[1])
  _17 = _7
  using: _7@Mir(bb4[0])
  _16 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdnode>::is_null(move _17) -> bb5
  using: _17@Mir(bb4[1])
bb5:
  switchInt(move _16) -> [0: bb7, otherwise: bb6]
  using: _16@Mir(bb4[2])
bb6:
  _20 = _7
  using: _7@Mir(bb4[0])
  _19 = move _20 as usize (PointerExposeAddress)
  using: _20@Mir(bb6[0])
  _18 = Eq(move _19, const 0_usize)
  using: _19@Mir(bb6[1])
  assume(move _18)
  using: _18@Mir(bb6[2])
  _0 = const -1_i32
  using: 
  goto -> bb26
  using: 
bb7:
  _24 = _5
  using: _5@Entry
  _23 = move _24 as u64 (IntToInt)
  using: _24@Mir(bb7[0])
  _26 = std::mem::size_of::<f64>() -> bb8
  using: 
bb8:
  _25 = move _26 as u64 (IntToInt)
  using: _26@Mir(bb7[2])
  _22 = core::num::<impl u64>::wrapping_mul(move _23, move _25) -> bb9
  using: _23@Mir(bb7[1]), _25@Mir(bb8[0])
bb9:
  _21 = src::kdtree::malloc(move _22) -> bb10
  using: _22@Mir(bb8[1])
bb10:
  ((*_7).0: *mut f64) = move _21 as *mut f64 (PtrToPtr)
  using: _7@Mir(bb4[0]), _21@Mir(bb9[0])
  _28 = ((*_7).0: *mut f64)
  using: _7@Mir(bb4[0])
  _27 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _28) -> bb11
  using: _28@Mir(bb10[1])
bb11:
  switchInt(move _27) -> [0: bb14, otherwise: bb12]
  using: _27@Mir(bb10[2])
bb12:
  _31 = ((*_7).0: *mut f64)
  using: _7@Mir(bb4[0])
  _30 = move _31 as usize (PointerExposeAddress)
  using: _31@Mir(bb12[0])
  _29 = Eq(move _30, const 0_usize)
  using: _30@Mir(bb12[1])
  assume(move _29)
  using: _29@Mir(bb12[2])
  _34 = _7
  using: _7@Mir(bb4[0])
  _33 = move _34 as *mut libc::c_void (PtrToPtr)
  using: _34@Mir(bb12[4])
  _32 = src::kdtree::free(move _33) -> bb13
  using: _33@Mir(bb12[5])
bb13:
  _0 = const -1_i32
  using: 
  goto -> bb26
  using: 
bb14:
  _37 = ((*_7).0: *mut f64)
  using: _7@Mir(bb4[0])
  _36 = move _37 as *mut libc::c_void (PtrToPtr)
  using: _37@Mir(bb14[0])
  _39 = _2
  using: _2@Entry
  _38 = move _39 as *const libc::c_void (PtrToPtr)
  using: _39@Mir(bb14[2])
  _42 = _5
  using: _5@Entry
  _41 = move _42 as u64 (IntToInt)
  using: _42@Mir(bb14[4])
  _44 = std::mem::size_of::<f64>() -> bb15
  using: 
bb15:
  _43 = move _44 as u64 (IntToInt)
  using: _44@Mir(bb14[6])
  _40 = core::num::<impl u64>::wrapping_mul(move _41, move _43) -> bb16
  using: _41@Mir(bb14[5]), _43@Mir(bb15[0])
bb16:
  _35 = src::kdtree::memcpy(move _36, move _38, move _40) -> bb17
  using: _36@Mir(bb14[1]), _38@Mir(bb14[3]), _40@Mir(bb15[1])
bb17:
  _45 = _3
  using: _3@Entry
  ((*_7).2: *mut libc::c_void) = move _45
  using: _7@Mir(bb4[0]), _45@Mir(bb17[0])
  _46 = _4
  using: _4@Entry
  ((*_7).1: i32) = move _46
  using: _7@Mir(bb4[0]), _46@Mir(bb17[2])
  ((*_7).4: *mut src::kdtree::kdnode) = const 0_usize as *mut src::kdtree::kdnode (PointerFromExposedAddress)
  using: _7@Mir(bb4[0])
  _47 = ((*_7).4: *mut src::kdtree::kdnode)
  using: _7@Mir(bb4[0])
  ((*_7).3: *mut src::kdtree::kdnode) = move _47
  using: _7@Mir(bb4[0]), _47@Mir(bb17[5])
  _48 = _7
  using: _7@Mir(bb4[0])
  (*_1) = move _48
  using: _1@Entry, _48@Mir(bb17[7])
  _0 = const 0_i32
  using: 
  goto -> bb26
  using: 
bb18:
  _49 = (*_1)
  using: _1@Entry
  _7 = move _49
  using: _49@Mir(bb18[0])
  _51 = ((*_7).1: i32)
  using: _7@Mir(bb18[1])
  _52 = const 1_i32
  using: 
  _53 = CheckedAdd(_51, _52)
  using: _51@Mir(bb18[2]), _52@Mir(bb18[3])
  assert(!move (_53.1: bool), "attempt to compute `{} + {}`, which would overflow", move _51, move _52) -> bb19
  using: _53@Entry, _51@Entry, _52@Entry
bb19:
  _50 = move (_53.0: i32)
  using: _53@Mir(bb18[4])
  _54 = _5
  using: _5@Entry
  _55 = Eq(_54, const 0_i32)
  using: _54@Mir(bb19[1])
  assert(!move _55, "attempt to calculate the remainder of `{}` with a divisor of zero", _50) -> bb20
  using: _55@Entry, _50@Entry
bb20:
  _56 = Eq(_54, const -1_i32)
  using: _54@Mir(bb19[1])
  _57 = Eq(_50, const i32::MIN)
  using: _50@Mir(bb19[0])
  _58 = BitAnd(move _56, move _57)
  using: _56@Mir(bb20[0]), _57@Mir(bb20[1])
  assert(!move _58, "attempt to compute the remainder of `{} % {}`, which would overflow", _50, _54) -> bb21
  using: _58@Entry, _50@Entry, _54@Entry
bb21:
  _6 = Rem(move _50, move _54)
  using: _50@Mir(bb19[0]), _54@Mir(bb19[1])
  _62 = _2
  using: _2@Entry
  _64 = ((*_7).1: i32)
  using: _7@Mir(bb18[1])
  _63 = move _64 as isize (IntToInt)
  using: _64@Mir(bb21[2])
  _61 = std::ptr::const_ptr::<impl *const f64>::offset(move _62, move _63) -> bb22
  using: _62@Mir(bb21[1]), _63@Mir(bb21[3])
bb22:
  _60 = (*_61)
  using: _61@Mir(bb21[4])
  _67 = ((*_7).0: *mut f64)
  using: _7@Mir(bb18[1])
  _69 = ((*_7).1: i32)
  using: _7@Mir(bb18[1])
  _68 = move _69 as isize (IntToInt)
  using: _69@Mir(bb22[2])
  _66 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _67, move _68) -> bb23
  using: _67@Mir(bb22[1]), _68@Mir(bb22[3])
bb23:
  _65 = (*_66)
  using: _66@Mir(bb22[4])
  _59 = Lt(move _60, move _65)
  using: _60@Mir(bb22[0]), _65@Mir(bb23[0])
  switchInt(move _59) -> [0: bb25, otherwise: bb24]
  using: _59@Mir(bb23[1])
bb24:
  _82 = deref_copy (*_1)
  using: _1@Entry
  _71 = &mut ((*_82).3: *mut src::kdtree::kdnode)
  using: _82@Mir(bb24[0])
  _70 = &raw mut (*_71)
  using: _71@Mir(bb24[1])
  _72 = _2
  using: _2@Entry
  _73 = _3
  using: _3@Entry
  _74 = _6
  using: _6@Mir(bb21[0])
  _75 = _5
  using: _5@Entry
  _0 = src::kdtree::insert_rec(move _70, move _72, move _73, move _74, move _75) -> bb26
  using: _70@Mir(bb24[2]), _72@Mir(bb24[3]), _73@Mir(bb24[4]), _74@Mir(bb24[5]), _75@Mir(bb24[6])
bb25:
  _83 = deref_copy (*_1)
  using: _1@Entry
  _77 = &mut ((*_83).4: *mut src::kdtree::kdnode)
  using: _83@Mir(bb25[0])
  _76 = &raw mut (*_77)
  using: _77@Mir(bb25[1])
  _78 = _2
  using: _2@Entry
  _79 = _3
  using: _3@Entry
  _80 = _6
  using: _6@Mir(bb21[0])
  _81 = _5
  using: _5@Entry
  _0 = src::kdtree::insert_rec(move _76, move _78, move _79, move _80, move _81) -> bb26
  using: _76@Mir(bb25[2]), _78@Mir(bb25[3]), _79@Mir(bb25[4]), _80@Mir(bb25[5]), _81@Mir(bb25[6])
bb26:
  return
  using: _0@Phi(bb26)
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:141:23: 141:54 (#0) by default
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:147:31: 147:70 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:147:18: 147:88 (#0) by default
rewrite call src::kdtree::malloc @ workspace/kdtree/src/kdtree.rs:145:23: 148:10 (#0) by default
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:157:31: 157:70 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:157:18: 157:88 (#0) by default
rewrite call src::kdtree::memcpy @ workspace/kdtree/src/kdtree.rs:153:9: 158:10 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:167:13: 167:41 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:167:59: 167:87 (#0) by default
@DefId(0:22 ~ lib[40c5]::src::kdtree::kd_insert)
bb0:
  _6 = &mut ((*_1).1: *mut src::kdtree::kdnode)
  using: _1@Entry
  _5 = &raw mut (*_6)
  using: _6@Mir(bb0[0])
  _7 = _2
  using: _2@Entry
  _8 = _3
  using: _3@Entry
  _9 = const 0_i32
  using: 
  _10 = ((*_1).0: i32)
  using: _1@Entry
  _4 = src::kdtree::insert_rec(move _5, move _7, move _8, move _9, move _10) -> bb1
  using: _5@Mir(bb0[1]), _7@Mir(bb0[2]), _8@Mir(bb0[3]), _9@Mir(bb0[4]), _10@Mir(bb0[5])
bb1:
  switchInt(move _4) -> [0: bb3, otherwise: bb2]
  using: _4@Mir(bb0[6])
bb2:
  _0 = const -1_i32
  using: 
  goto -> bb9
  using: 
bb3:
  _12 = ((*_1).2: *mut src::kdtree::kdhyperrect)
  using: _1@Entry
  _11 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdhyperrect>::is_null(move _12) -> bb4
  using: _12@Mir(bb3[0])
bb4:
  switchInt(move _11) -> [0: bb7, otherwise: bb5]
  using: _11@Mir(bb3[1])
bb5:
  _15 = ((*_1).2: *mut src::kdtree::kdhyperrect)
  using: _1@Entry
  _14 = move _15 as usize (PointerExposeAddress)
  using: _15@Mir(bb5[0])
  _13 = Eq(move _14, const 0_usize)
  using: _14@Mir(bb5[1])
  assume(move _13)
  using: _13@Mir(bb5[2])
  _17 = ((*_1).0: i32)
  using: _1@Entry
  _18 = _2
  using: _2@Entry
  _19 = _2
  using: _2@Entry
  _16 = src::kdtree::hyperrect_create(move _17, move _18, move _19) -> bb6
  using: _17@Mir(bb5[4]), _18@Mir(bb5[5]), _19@Mir(bb5[6])
bb6:
  ((*_1).2: *mut src::kdtree::kdhyperrect) = move _16
  using: _1@Entry, _16@Mir(bb5[7])
  goto -> bb8
  using: 
bb7:
  _21 = ((*_1).2: *mut src::kdtree::kdhyperrect)
  using: _1@Entry
  _22 = _2
  using: _2@Entry
  _20 = src::kdtree::hyperrect_extend(move _21, move _22) -> bb8
  using: _21@Mir(bb7[0]), _22@Mir(bb7[1])
bb8:
  _0 = const 0_i32
  using: 
  goto -> bb9
  using: 
bb9:
  return
  using: _0@Phi(bb9)
@DefId(0:23 ~ lib[40c5]::src::kdtree::kd_insertf)
bb0:
  _4 = const {0x0 as *mut f64}
  using: 
  _5 = const {0x0 as *mut f64}
  using: 
  _6 = const 0_i32
  using: 
  _7 = ((*_1).0: i32)
  using: _1@Entry
  _9 = _7
  using: _7@Mir(bb0[3])
  _10 = const 16_i32
  using: 
  _8 = Gt(move _9, move _10)
  using: _9@Mir(bb0[4]), _10@Mir(bb0[5])
  switchInt(move _8) -> [0: bb14, otherwise: bb1]
  using: _8@Mir(bb0[6])
bb1:
  _12 = _7
  using: _7@Mir(bb0[3])
  _13 = const 256_i32
  using: 
  _11 = Le(move _12, move _13)
  using: _12@Mir(bb1[0]), _13@Mir(bb1[1])
  switchInt(move _11) -> [0: bb8, otherwise: bb2]
  using: _11@Mir(bb1[2])
bb2:
  _17 = _7
  using: _7@Mir(bb0[3])
  _16 = move _17 as u64 (IntToInt)
  using: _17@Mir(bb2[0])
  _19 = std::mem::size_of::<f64>() -> bb3
  using: 
bb3:
  _18 = move _19 as u64 (IntToInt)
  using: _19@Mir(bb2[2])
  _15 = core::num::<impl u64>::wrapping_mul(move _16, move _18) -> bb4
  using: _16@Mir(bb2[1]), _18@Mir(bb3[0])
bb4:
  _14 = src::kdtree::malloc(move _15) -> bb5
  using: _15@Mir(bb3[1])
bb5:
  _5 = move _14 as *mut f64 (PtrToPtr)
  using: _14@Mir(bb4[0])
  _20 = _5
  using: _5@Mir(bb5[0])
  _4 = move _20
  using: _20@Mir(bb5[1])
  _22 = _4
  using: _4@Mir(bb5[2])
  _21 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _22) -> bb6
  using: _22@Mir(bb5[3])
bb6:
  switchInt(move _21) -> [0: bb16, otherwise: bb7]
  using: _21@Mir(bb5[4])
bb7:
  _25 = _4
  using: _4@Mir(bb5[2])
  _24 = move _25 as usize (PointerExposeAddress)
  using: _25@Mir(bb7[0])
  _23 = Eq(move _24, const 0_usize)
  using: _24@Mir(bb7[1])
  assume(move _23)
  using: _23@Mir(bb7[2])
  _0 = const -1_i32
  using: 
  goto -> bb25
  using: 
bb8:
  _29 = _7
  using: _7@Mir(bb0[3])
  _28 = move _29 as u64 (IntToInt)
  using: _29@Mir(bb8[0])
  _31 = std::mem::size_of::<f64>() -> bb9
  using: 
bb9:
  _30 = move _31 as u64 (IntToInt)
  using: _31@Mir(bb8[2])
  _27 = core::num::<impl u64>::wrapping_mul(move _28, move _30) -> bb10
  using: _28@Mir(bb8[1]), _30@Mir(bb9[0])
bb10:
  _26 = src::kdtree::malloc(move _27) -> bb11
  using: _27@Mir(bb9[1])
bb11:
  _5 = move _26 as *mut f64 (PtrToPtr)
  using: _26@Mir(bb10[0])
  _32 = _5
  using: _5@Mir(bb11[0])
  _4 = move _32
  using: _32@Mir(bb11[1])
  _34 = _4
  using: _4@Mir(bb11[2])
  _33 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _34) -> bb12
  using: _34@Mir(bb11[3])
bb12:
  switchInt(move _33) -> [0: bb16, otherwise: bb13]
  using: _33@Mir(bb11[4])
bb13:
  _37 = _4
  using: _4@Mir(bb11[2])
  _36 = move _37 as usize (PointerExposeAddress)
  using: _37@Mir(bb13[0])
  _35 = Eq(move _36, const 0_usize)
  using: _36@Mir(bb13[1])
  assume(move _35)
  using: _35@Mir(bb13[2])
  _0 = const -1_i32
  using: 
  goto -> bb25
  using: 
bb14:
  _41 = const {alloc21: *mut [f64; 16]}
  using: 
  _40 = &mut (*_41)
  using: _41@Mir(bb14[0])
  _39 = move _40 as &mut [f64] (Pointer(Unsize))
  using: _40@Mir(bb14[1])
  _38 = core::slice::<impl [f64]>::as_mut_ptr(move _39) -> bb15
  using: _39@Mir(bb14[2])
bb15:
  _5 = move _38
  using: _38@Mir(bb14[3])
  _42 = _5
  using: _5@Mir(bb15[0])
  _4 = move _42
  using: _42@Mir(bb15[1])
  goto -> bb16
  using: 
bb16:
  _43 = _7
  using: _7@Phi(bb16)
  _44 = _7
  using: _7@Phi(bb16)
  _45 = CheckedSub(_44, const 1_i32)
  using: _44@Mir(bb16[1])
  assert(!move (_45.1: bool), "attempt to compute `{} - {}`, which would overflow", move _44, const 1_i32) -> bb17
  using: _45@Entry, _44@Entry
bb17:
  _7 = move (_45.0: i32)
  using: _45@Mir(bb16[2])
  _48 = _43
  using: _43@Mir(bb16[0])
  _49 = const 0_i32
  using: 
  _47 = Gt(move _48, move _49)
  using: _48@Mir(bb17[1]), _49@Mir(bb17[2])
  _46 = Not(move _47)
  using: _47@Mir(bb17[3])
  switchInt(move _46) -> [0: bb19, otherwise: bb18]
  using: _46@Mir(bb17[4])
bb18:
  _58 = _1
  using: _1@Entry
  _60 = _5
  using: _5@Phi(bb16)
  _59 = move _60 as *const f64 (Pointer(MutToConstPointer))
  using: _60@Mir(bb18[1])
  _61 = _3
  using: _3@Entry
  _57 = src::kdtree::kd_insert(move _58, move _59, move _61) -> bb22
  using: _58@Mir(bb18[0]), _59@Mir(bb18[2]), _61@Mir(bb18[3])
bb19:
  _50 = _2
  using: _2@Phi(bb16)
  _52 = _2
  using: _2@Phi(bb16)
  _51 = std::ptr::const_ptr::<impl *const f32>::offset(move _52, const 1_isize) -> bb20
  using: _52@Mir(bb19[1])
bb20:
  _2 = move _51
  using: _51@Mir(bb19[2])
  _53 = _4
  using: _4@Phi(bb16)
  _55 = _4
  using: _4@Phi(bb16)
  _54 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _55, const 1_isize) -> bb21
  using: _55@Mir(bb20[2])
bb21:
  _4 = move _54
  using: _54@Mir(bb20[3])
  _56 = (*_50)
  using: _50@Mir(bb19[0])
  (*_53) = move _56 as f64 (FloatToFloat)
  using: _53@Mir(bb20[1]), _56@Mir(bb21[1])
  goto -> bb16
  using: 
bb22:
  _6 = move _57
  using: _57@Mir(bb18[4])
  _63 = ((*_1).0: i32)
  using: _1@Entry
  _64 = const 256_i32
  using: 
  _62 = Gt(move _63, move _64)
  using: _63@Mir(bb22[1]), _64@Mir(bb22[2])
  switchInt(move _62) -> [0: bb24, otherwise: bb23]
  using: _62@Mir(bb22[3])
bb23:
  _67 = _5
  using: _5@Phi(bb16)
  _66 = move _67 as *mut libc::c_void (PtrToPtr)
  using: _67@Mir(bb23[0])
  _65 = src::kdtree::free(move _66) -> bb24
  using: _66@Mir(bb23[1])
bb24:
  _0 = _6
  using: _6@Mir(bb22[0])
  goto -> bb25
  using: 
bb25:
  return
  using: _0@Phi(bb25)
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:213:25: 213:64 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:212:22: 214:22 (#0) by default
rewrite call src::kdtree::malloc @ workspace/kdtree/src/kdtree.rs:210:19: 215:14 (#0) by default
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:224:25: 224:64 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:223:22: 225:22 (#0) by default
rewrite call src::kdtree::malloc @ workspace/kdtree/src/kdtree.rs:221:19: 226:14 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:243:19: 243:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:245:21: 245:30 (#0) by default
@DefId(0:27 ~ lib[40c5]::src::kdtree::kd_insert3)
bb0:
  _6 = [const 0f64; 3]
  using: 
  _7 = _2
  using: _2@Entry
  _8 = const 0_usize
  using: 
  _6[_8] = move _7
  using: _8@Mir(bb0[2]), _7@Mir(bb0[1])
  _9 = _3
  using: _3@Entry
  _10 = const 1_usize
  using: 
  _6[_10] = move _9
  using: _10@Mir(bb0[5]), _9@Mir(bb0[4])
  _11 = _4
  using: _4@Entry
  _12 = const 2_usize
  using: 
  _6[_12] = move _11
  using: _12@Mir(bb0[8]), _11@Mir(bb0[7])
  _13 = _1
  using: _1@Entry
  _17 = &mut _6
  using: _6@Mir(bb0[0])
  _16 = move _17 as &mut [f64] (Pointer(Unsize))
  using: _17@Mir(bb0[11])
  _15 = core::slice::<impl [f64]>::as_mut_ptr(move _16) -> bb1
  using: _16@Mir(bb0[12])
bb1:
  _14 = move _15 as *const f64 (Pointer(MutToConstPointer))
  using: _15@Mir(bb0[13])
  _18 = _5
  using: _5@Entry
  _0 = src::kdtree::kd_insert(move _13, move _14, move _18) -> bb2
  using: _13@Mir(bb0[10]), _14@Mir(bb1[0]), _18@Mir(bb1[1])
bb2:
  return
  using: _0@Mir(bb1[2])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0f64; 3] is not supported
@DefId(0:30 ~ lib[40c5]::src::kdtree::kd_insert3f)
bb0:
  _6 = [const 0f64; 3]
  using: 
  _7 = _2
  using: _2@Entry
  _8 = const 0_usize
  using: 
  _6[_8] = move _7 as f64 (FloatToFloat)
  using: _8@Mir(bb0[2]), _7@Mir(bb0[1])
  _9 = _3
  using: _3@Entry
  _10 = const 1_usize
  using: 
  _6[_10] = move _9 as f64 (FloatToFloat)
  using: _10@Mir(bb0[5]), _9@Mir(bb0[4])
  _11 = _4
  using: _4@Entry
  _12 = const 2_usize
  using: 
  _6[_12] = move _11 as f64 (FloatToFloat)
  using: _12@Mir(bb0[8]), _11@Mir(bb0[7])
  _13 = _1
  using: _1@Entry
  _17 = &mut _6
  using: _6@Mir(bb0[0])
  _16 = move _17 as &mut [f64] (Pointer(Unsize))
  using: _17@Mir(bb0[11])
  _15 = core::slice::<impl [f64]>::as_mut_ptr(move _16) -> bb1
  using: _16@Mir(bb0[12])
bb1:
  _14 = move _15 as *const f64 (Pointer(MutToConstPointer))
  using: _15@Mir(bb0[13])
  _18 = _5
  using: _5@Entry
  _0 = src::kdtree::kd_insert(move _13, move _14, move _18) -> bb2
  using: _13@Mir(bb0[10]), _14@Mir(bb1[0]), _18@Mir(bb1[1])
bb2:
  return
  using: _0@Mir(bb1[2])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0f64; 3] is not supported
@DefId(0:33 ~ lib[40c5]::src::kdtree::find_nearest)
bb0:
  _7 = const 0f64
  using: 
  _8 = const 0f64
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _13 = _1
  using: _1@Entry
  _12 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdnode>::is_null(move _13) -> bb1
  using: _13@Mir(bb0[5])
bb1:
  switchInt(move _12) -> [0: bb3, otherwise: bb2]
  using: _12@Mir(bb0[6])
bb2:
  _16 = _1
  using: _1@Entry
  _15 = move _16 as usize (PointerExposeAddress)
  using: _16@Mir(bb2[0])
  _14 = Eq(move _15, const 0_usize)
  using: _15@Mir(bb2[1])
  assume(move _14)
  using: _14@Mir(bb2[2])
  _0 = const 0_i32
  using: 
  goto -> bb40
  using: 
bb3:
  _7 = const 0f64
  using: 
  _9 = const 0_i32
  using: 
  goto -> bb4
  using: 
bb4:
  _18 = _9
  using: _9@Phi(bb4)
  _19 = _6
  using: _6@Entry
  _17 = Lt(move _18, move _19)
  using: _18@Mir(bb4[0]), _19@Mir(bb4[1])
  switchInt(move _17) -> [0: bb11, otherwise: bb5]
  using: _17@Mir(bb4[2])
bb5:
  _24 = ((*_1).0: *mut f64)
  using: _1@Phi(bb4)
  _26 = _9
  using: _9@Phi(bb4)
  _25 = move _26 as isize (IntToInt)
  using: _26@Mir(bb5[1])
  _23 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _24, move _25) -> bb6
  using: _24@Mir(bb5[0]), _25@Mir(bb5[2])
bb6:
  _22 = (*_23)
  using: _23@Mir(bb5[3])
  _29 = _2
  using: _2@Phi(bb4)
  _31 = _9
  using: _9@Phi(bb4)
  _30 = move _31 as isize (IntToInt)
  using: _31@Mir(bb6[2])
  _28 = std::ptr::const_ptr::<impl *const f64>::offset(move _29, move _30) -> bb7
  using: _29@Mir(bb6[1]), _30@Mir(bb6[3])
bb7:
  _27 = (*_28)
  using: _28@Mir(bb6[4])
  _21 = Sub(move _22, move _27)
  using: _22@Mir(bb6[0]), _27@Mir(bb7[0])
  _35 = ((*_1).0: *mut f64)
  using: _1@Phi(bb4)
  _37 = _9
  using: _9@Phi(bb4)
  _36 = move _37 as isize (IntToInt)
  using: _37@Mir(bb7[3])
  _34 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _35, move _36) -> bb8
  using: _35@Mir(bb7[2]), _36@Mir(bb7[4])
bb8:
  _33 = (*_34)
  using: _34@Mir(bb7[5])
  _40 = _2
  using: _2@Phi(bb4)
  _42 = _9
  using: _9@Phi(bb4)
  _41 = move _42 as isize (IntToInt)
  using: _42@Mir(bb8[2])
  _39 = std::ptr::const_ptr::<impl *const f64>::offset(move _40, move _41) -> bb9
  using: _40@Mir(bb8[1]), _41@Mir(bb8[3])
bb9:
  _38 = (*_39)
  using: _39@Mir(bb8[4])
  _32 = Sub(move _33, move _38)
  using: _33@Mir(bb8[0]), _38@Mir(bb9[0])
  _20 = Mul(move _21, move _32)
  using: _21@Mir(bb7[1]), _32@Mir(bb9[1])
  _7 = Add(_7, move _20)
  using: _20@Mir(bb9[2])
  _43 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb4)
  assert(!move (_43.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb10
  using: _43@Entry, _9@Entry
bb10:
  _9 = move (_43.0: i32)
  using: _43@Mir(bb9[4])
  goto -> bb4
  using: 
bb11:
  _45 = _7
  using: _7@Mir(bb9[3])
  _47 = _3
  using: _3@Entry
  _48 = _3
  using: _3@Entry
  _46 = Mul(move _47, move _48)
  using: _47@Mir(bb11[1]), _48@Mir(bb11[2])
  _44 = Le(move _45, move _46)
  using: _45@Mir(bb11[0]), _46@Mir(bb11[3])
  switchInt(move _44) -> [0: bb19, otherwise: bb12]
  using: _44@Mir(bb11[4])
bb12:
  _51 = _4
  using: _4@Entry
  _52 = _1
  using: _1@Phi(bb4)
  _54 = _5
  using: _5@Entry
  switchInt(move _54) -> [0: bb14, otherwise: bb13]
  using: _54@Mir(bb12[2])
bb13:
  _53 = _7
  using: _7@Mir(bb9[3])
  goto -> bb15
  using: 
bb14:
  _53 = const -1f64
  using: 
  goto -> bb15
  using: 
bb15:
  _50 = src::kdtree::rlist_insert(move _51, move _52, move _53) -> bb16
  using: _51@Mir(bb12[0]), _52@Mir(bb12[1]), _53@Phi(bb15)
bb16:
  _55 = const -1_i32
  using: 
  _49 = Eq(move _50, move _55)
  using: _50@Mir(bb15[0]), _55@Mir(bb16[0])
  switchInt(move _49) -> [0: bb18, otherwise: bb17]
  using: _49@Mir(bb16[1])
bb17:
  _0 = const -1_i32
  using: 
  goto -> bb40
  using: 
bb18:
  _11 = const 1_i32
  using: 
  goto -> bb19
  using: 
bb19:
  _58 = _2
  using: _2@Phi(bb4)
  _60 = ((*_1).1: i32)
  using: _1@Phi(bb19)
  _59 = move _60 as isize (IntToInt)
  using: _60@Mir(bb19[1])
  _57 = std::ptr::const_ptr::<impl *const f64>::offset(move _58, move _59) -> bb20
  using: _58@Mir(bb19[0]), _59@Mir(bb19[2])
bb20:
  _56 = (*_57)
  using: _57@Mir(bb19[3])
  _63 = ((*_1).0: *mut f64)
  using: _1@Phi(bb19)
  _65 = ((*_1).1: i32)
  using: _1@Phi(bb19)
  _64 = move _65 as isize (IntToInt)
  using: _65@Mir(bb20[2])
  _62 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _63, move _64) -> bb21
  using: _63@Mir(bb20[1]), _64@Mir(bb20[3])
bb21:
  _61 = (*_62)
  using: _62@Mir(bb20[4])
  _8 = Sub(move _56, move _61)
  using: _56@Mir(bb20[0]), _61@Mir(bb21[0])
  _69 = _8
  using: _8@Mir(bb21[1])
  _68 = Le(move _69, const 0f64)
  using: _69@Mir(bb21[2])
  switchInt(move _68) -> [0: bb23, otherwise: bb22]
  using: _68@Mir(bb21[3])
bb22:
  _67 = ((*_1).3: *mut src::kdtree::kdnode)
  using: _1@Phi(bb19)
  goto -> bb24
  using: 
bb23:
  _67 = ((*_1).4: *mut src::kdtree::kdnode)
  using: _1@Phi(bb19)
  goto -> bb24
  using: 
bb24:
  _70 = _2
  using: _2@Phi(bb4)
  _71 = _3
  using: _3@Entry
  _72 = _4
  using: _4@Phi(bb19)
  _73 = _5
  using: _5@Phi(bb19)
  _74 = _6
  using: _6@Entry
  _66 = src::kdtree::find_nearest(move _67, move _70, move _71, move _72, move _73, move _74) -> bb25
  using: _67@Phi(bb24), _70@Mir(bb24[0]), _71@Mir(bb24[1]), _72@Mir(bb24[2]), _73@Mir(bb24[3]), _74@Mir(bb24[4])
bb25:
  _10 = move _66
  using: _66@Mir(bb24[5])
  _77 = _10
  using: _10@Mir(bb25[0])
  _78 = const 0_i32
  using: 
  _76 = Ge(move _77, move _78)
  using: _77@Mir(bb25[1]), _78@Mir(bb25[2])
  switchInt(move _76) -> [0: bb26, otherwise: bb27]
  using: _76@Mir(bb25[3])
bb26:
  _75 = const false
  using: 
  goto -> bb28
  using: 
bb27:
  _81 = _8
  using: _8@Mir(bb21[1])
  _80 = src::kdtree::fabs(move _81) -> bb29
  using: _81@Mir(bb27[0])
bb28:
  switchInt(move _75) -> [0: bb36, otherwise: bb30]
  using: _75@Phi(bb28)
bb29:
  _82 = _3
  using: _3@Entry
  _79 = Lt(move _80, move _82)
  using: _80@Mir(bb27[1]), _82@Mir(bb29[0])
  _75 = move _79
  using: _79@Mir(bb29[1])
  goto -> bb28
  using: 
bb30:
  _83 = _10
  using: _10@Mir(bb25[0])
  _84 = CheckedAdd(_11, _83)
  using: _11@Phi(bb19), _83@Mir(bb30[0])
  assert(!move (_84.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, move _83) -> bb31
  using: _84@Entry, _11@Entry, _83@Entry
bb31:
  _11 = move (_84.0: i32)
  using: _84@Mir(bb30[1])
  _88 = _8
  using: _8@Phi(bb28)
  _87 = Le(move _88, const 0f64)
  using: _88@Mir(bb31[1])
  switchInt(move _87) -> [0: bb33, otherwise: bb32]
  using: _87@Mir(bb31[2])
bb32:
  _86 = ((*_1).4: *mut src::kdtree::kdnode)
  using: _1@Phi(bb24)
  goto -> bb34
  using: 
bb33:
  _86 = ((*_1).3: *mut src::kdtree::kdnode)
  using: _1@Phi(bb24)
  goto -> bb34
  using: 
bb34:
  _89 = _2
  using: _2@Phi(bb4)
  _90 = _3
  using: _3@Phi(bb28)
  _91 = _4
  using: _4@Phi(bb19)
  _92 = _5
  using: _5@Phi(bb19)
  _93 = _6
  using: _6@Entry
  _85 = src::kdtree::find_nearest(move _86, move _89, move _90, move _91, move _92, move _93) -> bb35
  using: _86@Phi(bb34), _89@Mir(bb34[0]), _90@Mir(bb34[1]), _91@Mir(bb34[2]), _92@Mir(bb34[3]), _93@Mir(bb34[4])
bb35:
  _10 = move _85
  using: _85@Mir(bb34[5])
  goto -> bb36
  using: 
bb36:
  _95 = _10
  using: _10@Phi(bb36)
  _96 = const -1_i32
  using: 
  _94 = Eq(move _95, move _96)
  using: _95@Mir(bb36[0]), _96@Mir(bb36[1])
  switchInt(move _94) -> [0: bb38, otherwise: bb37]
  using: _94@Mir(bb36[2])
bb37:
  _0 = const -1_i32
  using: 
  goto -> bb40
  using: 
bb38:
  _97 = _10
  using: _10@Phi(bb36)
  _98 = CheckedAdd(_11, _97)
  using: _11@Phi(bb36), _97@Mir(bb38[0])
  assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, move _97) -> bb39
  using: _98@Entry, _11@Entry, _97@Entry
bb39:
  _11 = move (_98.0: i32)
  using: _98@Mir(bb38[1])
  _0 = _11
  using: _11@Mir(bb39[0])
  goto -> bb40
  using: 
bb40:
  return
  using: _0@Phi(bb40)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:302:32: 302:50 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:302:58: 302:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:303:35: 303:53 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:303:61: 303:79 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:314:15: 314:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:314:61: 314:89 (#0) by default
rewrite call src::kdtree::fabs @ workspace/kdtree/src/kdtree.rs:323:35: 323:43 (#0) by default
@DefId(0:34 ~ lib[40c5]::src::kdtree::kd_nearest_i)
bb0:
  _6 = ((*_1).1: i32)
  using: _1@Entry
  _7 = const 0_i32
  using: 
  _8 = const 0f64
  using: 
  _9 = const 0f64
  using: 
  _10 = const {0x0 as *mut src::kdtree::kdnode}
  using: 
  _11 = const {0x0 as *mut src::kdtree::kdnode}
  using: 
  _12 = const {0x0 as *mut f64}
  using: 
  _13 = const {0x0 as *mut f64}
  using: 
  _16 = _2
  using: _2@Entry
  _18 = _6
  using: _6@Mir(bb0[0])
  _17 = move _18 as isize (IntToInt)
  using: _18@Mir(bb0[9])
  _15 = std::ptr::const_ptr::<impl *const f64>::offset(move _16, move _17) -> bb1
  using: _16@Mir(bb0[8]), _17@Mir(bb0[10])
bb1:
  _14 = (*_15)
  using: _15@Mir(bb0[11])
  _21 = ((*_1).0: *mut f64)
  using: _1@Entry
  _23 = _6
  using: _6@Mir(bb0[0])
  _22 = move _23 as isize (IntToInt)
  using: _23@Mir(bb1[2])
  _20 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _21, move _22) -> bb2
  using: _21@Mir(bb1[1]), _22@Mir(bb1[3])
bb2:
  _19 = (*_20)
  using: _20@Mir(bb1[4])
  _8 = Sub(move _14, move _19)
  using: _14@Mir(bb1[0]), _19@Mir(bb2[0])
  _25 = _8
  using: _8@Mir(bb2[1])
  _26 = const 0f64
  using: 
  _24 = Le(move _25, move _26)
  using: _25@Mir(bb2[2]), _26@Mir(bb2[3])
  switchInt(move _24) -> [0: bb6, otherwise: bb3]
  using: _24@Mir(bb2[4])
bb3:
  _27 = ((*_1).3: *mut src::kdtree::kdnode)
  using: _1@Entry
  _10 = move _27
  using: _27@Mir(bb3[0])
  _28 = ((*_1).4: *mut src::kdtree::kdnode)
  using: _1@Entry
  _11 = move _28
  using: _28@Mir(bb3[2])
  _30 = ((*_5).2: *mut f64)
  using: _5@Entry
  _32 = _6
  using: _6@Mir(bb0[0])
  _31 = move _32 as isize (IntToInt)
  using: _32@Mir(bb3[5])
  _29 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _30, move _31) -> bb4
  using: _30@Mir(bb3[4]), _31@Mir(bb3[6])
bb4:
  _12 = move _29
  using: _29@Mir(bb3[7])
  _34 = ((*_5).1: *mut f64)
  using: _5@Entry
  _36 = _6
  using: _6@Mir(bb0[0])
  _35 = move _36 as isize (IntToInt)
  using: _36@Mir(bb4[2])
  _33 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _34, move _35) -> bb5
  using: _34@Mir(bb4[1]), _35@Mir(bb4[3])
bb5:
  _13 = move _33
  using: _33@Mir(bb4[4])
  goto -> bb9
  using: 
bb6:
  _37 = ((*_1).4: *mut src::kdtree::kdnode)
  using: _1@Entry
  _10 = move _37
  using: _37@Mir(bb6[0])
  _38 = ((*_1).3: *mut src::kdtree::kdnode)
  using: _1@Entry
  _11 = move _38
  using: _38@Mir(bb6[2])
  _40 = ((*_5).1: *mut f64)
  using: _5@Entry
  _42 = _6
  using: _6@Mir(bb0[0])
  _41 = move _42 as isize (IntToInt)
  using: _42@Mir(bb6[5])
  _39 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _40, move _41) -> bb7
  using: _40@Mir(bb6[4]), _41@Mir(bb6[6])
bb7:
  _12 = move _39
  using: _39@Mir(bb6[7])
  _44 = ((*_5).2: *mut f64)
  using: _5@Entry
  _46 = _6
  using: _6@Mir(bb0[0])
  _45 = move _46 as isize (IntToInt)
  using: _46@Mir(bb7[2])
  _43 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _44, move _45) -> bb8
  using: _44@Mir(bb7[1]), _45@Mir(bb7[3])
bb8:
  _13 = move _43
  using: _43@Mir(bb7[4])
  goto -> bb9
  using: 
bb9:
  _49 = _10
  using: _10@Phi(bb9)
  _48 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdnode>::is_null(move _49) -> bb10
  using: _49@Mir(bb9[0])
bb10:
  _47 = Not(move _48)
  using: _48@Mir(bb9[1])
  switchInt(move _47) -> [0: bb14, otherwise: bb11]
  using: _47@Mir(bb10[0])
bb11:
  _50 = (*_12)
  using: _12@Phi(bb9)
  _8 = move _50
  using: _50@Mir(bb11[0])
  _53 = ((*_1).0: *mut f64)
  using: _1@Phi(bb9)
  _55 = _6
  using: _6@Phi(bb9)
  _54 = move _55 as isize (IntToInt)
  using: _55@Mir(bb11[3])
  _52 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _53, move _54) -> bb12
  using: _53@Mir(bb11[2]), _54@Mir(bb11[4])
bb12:
  _51 = (*_52)
  using: _52@Mir(bb11[5])
  (*_12) = move _51
  using: _12@Phi(bb9), _51@Mir(bb12[0])
  _57 = _10
  using: _10@Phi(bb9)
  _58 = _2
  using: _2@Entry
  _59 = _3
  using: _3@Entry
  _60 = _4
  using: _4@Entry
  _61 = _5
  using: _5@Phi(bb9)
  _56 = src::kdtree::kd_nearest_i(move _57, move _58, move _59, move _60, move _61) -> bb13
  using: _57@Mir(bb12[2]), _58@Mir(bb12[3]), _59@Mir(bb12[4]), _60@Mir(bb12[5]), _61@Mir(bb12[6])
bb13:
  _62 = _8
  using: _8@Mir(bb11[1])
  (*_12) = move _62
  using: _12@Phi(bb9), _62@Mir(bb13[0])
  goto -> bb15
  using: 
bb14:
  _65 = _10
  using: _10@Phi(bb9)
  _64 = move _65 as usize (PointerExposeAddress)
  using: _65@Mir(bb14[0])
  _63 = Eq(move _64, const 0_usize)
  using: _64@Mir(bb14[1])
  assume(move _63)
  using: _63@Mir(bb14[2])
  goto -> bb15
  using: 
bb15:
  _9 = const 0f64
  using: 
  _7 = const 0_i32
  using: 
  goto -> bb16
  using: 
bb16:
  _67 = _7
  using: _7@Phi(bb16)
  _68 = ((*_5).0: i32)
  using: _5@Phi(bb15)
  _66 = Lt(move _67, move _68)
  using: _67@Mir(bb16[0]), _68@Mir(bb16[1])
  switchInt(move _66) -> [0: bb23, otherwise: bb17]
  using: _66@Mir(bb16[2])
bb17:
  _73 = ((*_1).0: *mut f64)
  using: _1@Phi(bb16)
  _75 = _7
  using: _7@Phi(bb16)
  _74 = move _75 as isize (IntToInt)
  using: _75@Mir(bb17[1])
  _72 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _73, move _74) -> bb18
  using: _73@Mir(bb17[0]), _74@Mir(bb17[2])
bb18:
  _71 = (*_72)
  using: _72@Mir(bb17[3])
  _78 = _2
  using: _2@Phi(bb16)
  _80 = _7
  using: _7@Phi(bb16)
  _79 = move _80 as isize (IntToInt)
  using: _80@Mir(bb18[2])
  _77 = std::ptr::const_ptr::<impl *const f64>::offset(move _78, move _79) -> bb19
  using: _78@Mir(bb18[1]), _79@Mir(bb18[3])
bb19:
  _76 = (*_77)
  using: _77@Mir(bb18[4])
  _70 = Sub(move _71, move _76)
  using: _71@Mir(bb18[0]), _76@Mir(bb19[0])
  _84 = ((*_1).0: *mut f64)
  using: _1@Phi(bb16)
  _86 = _7
  using: _7@Phi(bb16)
  _85 = move _86 as isize (IntToInt)
  using: _86@Mir(bb19[3])
  _83 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _84, move _85) -> bb20
  using: _84@Mir(bb19[2]), _85@Mir(bb19[4])
bb20:
  _82 = (*_83)
  using: _83@Mir(bb19[5])
  _89 = _2
  using: _2@Phi(bb16)
  _91 = _7
  using: _7@Phi(bb16)
  _90 = move _91 as isize (IntToInt)
  using: _91@Mir(bb20[2])
  _88 = std::ptr::const_ptr::<impl *const f64>::offset(move _89, move _90) -> bb21
  using: _89@Mir(bb20[1]), _90@Mir(bb20[3])
bb21:
  _87 = (*_88)
  using: _88@Mir(bb20[4])
  _81 = Sub(move _82, move _87)
  using: _82@Mir(bb20[0]), _87@Mir(bb21[0])
  _69 = Mul(move _70, move _81)
  using: _70@Mir(bb19[1]), _81@Mir(bb21[1])
  _9 = Add(_9, move _69)
  using: _69@Mir(bb21[2])
  _92 = CheckedAdd(_7, const 1_i32)
  using: _7@Phi(bb16)
  assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, const 1_i32) -> bb22
  using: _92@Entry, _7@Entry
bb22:
  _7 = move (_92.0: i32)
  using: _92@Mir(bb21[4])
  goto -> bb16
  using: 
bb23:
  _94 = _9
  using: _9@Mir(bb21[3])
  _95 = (*_4)
  using: _4@Phi(bb15)
  _93 = Lt(move _94, move _95)
  using: _94@Mir(bb23[0]), _95@Mir(bb23[1])
  switchInt(move _93) -> [0: bb25, otherwise: bb24]
  using: _93@Mir(bb23[2])
bb24:
  _96 = _1
  using: _1@Phi(bb16)
  (*_3) = move _96
  using: _3@Phi(bb15), _96@Mir(bb24[0])
  _97 = _9
  using: _9@Mir(bb21[3])
  (*_4) = move _97
  using: _4@Phi(bb15), _97@Mir(bb24[2])
  goto -> bb25
  using: 
bb25:
  _100 = _11
  using: _11@Phi(bb9)
  _99 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdnode>::is_null(move _100) -> bb26
  using: _100@Mir(bb25[0])
bb26:
  _98 = Not(move _99)
  using: _99@Mir(bb25[1])
  switchInt(move _98) -> [0: bb32, otherwise: bb27]
  using: _98@Mir(bb26[0])
bb27:
  _101 = (*_13)
  using: _13@Phi(bb9)
  _8 = move _101
  using: _101@Mir(bb27[0])
  _104 = ((*_1).0: *mut f64)
  using: _1@Phi(bb25)
  _106 = _6
  using: _6@Phi(bb15)
  _105 = move _106 as isize (IntToInt)
  using: _106@Mir(bb27[3])
  _103 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _104, move _105) -> bb28
  using: _104@Mir(bb27[2]), _105@Mir(bb27[4])
bb28:
  _102 = (*_103)
  using: _103@Mir(bb27[5])
  (*_13) = move _102
  using: _13@Phi(bb9), _102@Mir(bb28[0])
  _109 = _5
  using: _5@Phi(bb15)
  _110 = _2
  using: _2@Phi(bb16)
  _108 = src::kdtree::hyperrect_dist_sq(move _109, move _110) -> bb29
  using: _109@Mir(bb28[2]), _110@Mir(bb28[3])
bb29:
  _111 = (*_4)
  using: _4@Phi(bb25)
  _107 = Lt(move _108, move _111)
  using: _108@Mir(bb28[4]), _111@Mir(bb29[0])
  switchInt(move _107) -> [0: bb31, otherwise: bb30]
  using: _107@Mir(bb29[1])
bb30:
  _113 = _11
  using: _11@Phi(bb9)
  _114 = _2
  using: _2@Phi(bb16)
  _115 = _3
  using: _3@Phi(bb25)
  _116 = _4
  using: _4@Phi(bb25)
  _117 = _5
  using: _5@Phi(bb15)
  _112 = src::kdtree::kd_nearest_i(move _113, move _114, move _115, move _116, move _117) -> bb31
  using: _113@Mir(bb30[0]), _114@Mir(bb30[1]), _115@Mir(bb30[2]), _116@Mir(bb30[3]), _117@Mir(bb30[4])
bb31:
  _118 = _8
  using: _8@Mir(bb27[1])
  (*_13) = move _118
  using: _13@Phi(bb9), _118@Mir(bb31[0])
  goto -> bb33
  using: 
bb32:
  _121 = _11
  using: _11@Phi(bb31)
  _120 = move _121 as usize (PointerExposeAddress)
  using: _121@Mir(bb32[0])
  _119 = Eq(move _120, const 0_usize)
  using: _120@Mir(bb32[1])
  assume(move _119)
  using: _119@Mir(bb32[2])
  goto -> bb33
  using: 
bb33:
  return
  using: _0@Entry
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:355:18: 355:38 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:355:56: 355:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:359:48: 359:68 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:360:49: 360:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:364:48: 364:68 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:365:49: 365:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:369:50: 369:70 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:377:32: 377:50 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:377:58: 377:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:378:35: 378:53 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:378:61: 378:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:387:51: 387:71 (#0) by default
@DefId(0:35 ~ lib[40c5]::src::kdtree::kd_nearest)
bb0:
  _3 = const {0x0 as *mut src::kdtree::kdhyperrect}
  using: 
  _4 = const 0_usize as *mut src::kdtree::kdnode (PointerFromExposedAddress)
  using: 
  _5 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  _6 = const 0f64
  using: 
  _7 = const 0_i32
  using: 
  _9 = _1
  using: _1@Entry
  _8 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdtree>::is_null(move _9) -> bb1
  using: _9@Mir(bb0[5])
bb1:
  switchInt(move _8) -> [0: bb3, otherwise: bb2]
  using: _8@Mir(bb0[6])
bb2:
  _12 = _1
  using: _1@Entry
  _11 = move _12 as usize (PointerExposeAddress)
  using: _12@Mir(bb2[0])
  _10 = Eq(move _11, const 0_usize)
  using: _11@Mir(bb2[1])
  assume(move _10)
  using: _10@Mir(bb2[2])
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb41
  using: 
bb3:
  _14 = ((*_1).2: *mut src::kdtree::kdhyperrect)
  using: _1@Entry
  _13 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdhyperrect>::is_null(move _14) -> bb4
  using: _14@Mir(bb3[0])
bb4:
  switchInt(move _13) -> [0: bb6, otherwise: bb5]
  using: _13@Mir(bb3[1])
bb5:
  _17 = ((*_1).2: *mut src::kdtree::kdhyperrect)
  using: _1@Entry
  _16 = move _17 as usize (PointerExposeAddress)
  using: _17@Mir(bb5[0])
  _15 = Eq(move _16, const 0_usize)
  using: _16@Mir(bb5[1])
  assume(move _15)
  using: _15@Mir(bb5[2])
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb41
  using: 
bb6:
  _20 = std::mem::size_of::<src::kdtree::kdres>() -> bb7
  using: 
bb7:
  _19 = move _20 as u64 (IntToInt)
  using: _20@Mir(bb6[0])
  _18 = src::kdtree::malloc(move _19) -> bb8
  using: _19@Mir(bb7[0])
bb8:
  _5 = move _18 as *mut src::kdtree::kdres (PtrToPtr)
  using: _18@Mir(bb7[1])
  _22 = _5
  using: _5@Mir(bb8[0])
  _21 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdres>::is_null(move _22) -> bb9
  using: _22@Mir(bb8[1])
bb9:
  switchInt(move _21) -> [0: bb11, otherwise: bb10]
  using: _21@Mir(bb8[2])
bb10:
  _25 = _5
  using: _5@Mir(bb8[0])
  _24 = move _25 as usize (PointerExposeAddress)
  using: _25@Mir(bb10[0])
  _23 = Eq(move _24, const 0_usize)
  using: _24@Mir(bb10[1])
  assume(move _23)
  using: _23@Mir(bb10[2])
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb41
  using: 
bb11:
  _26 = src::kdtree::alloc_resnode() -> bb12
  using: 
bb12:
  ((*_5).1: *mut src::kdtree::res_node) = move _26
  using: _5@Mir(bb8[0]), _26@Mir(bb11[0])
  _28 = ((*_5).1: *mut src::kdtree::res_node)
  using: _5@Mir(bb8[0])
  _27 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _28) -> bb13
  using: _28@Mir(bb12[1])
bb13:
  switchInt(move _27) -> [0: bb16, otherwise: bb14]
  using: _27@Mir(bb12[2])
bb14:
  _31 = ((*_5).1: *mut src::kdtree::res_node)
  using: _5@Mir(bb8[0])
  _30 = move _31 as usize (PointerExposeAddress)
  using: _31@Mir(bb14[0])
  _29 = Eq(move _30, const 0_usize)
  using: _30@Mir(bb14[1])
  assume(move _29)
  using: _29@Mir(bb14[2])
  _34 = _5
  using: _5@Mir(bb8[0])
  _33 = move _34 as *mut libc::c_void (PtrToPtr)
  using: _34@Mir(bb14[4])
  _32 = src::kdtree::free(move _33) -> bb15
  using: _33@Mir(bb14[5])
bb15:
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb41
  using: 
bb16:
  _103 = deref_copy ((*_5).1: *mut src::kdtree::res_node)
  using: _5@Mir(bb8[0])
  ((*_103).2: *mut src::kdtree::res_node) = const 0_usize as *mut src::kdtree::res_node (PointerFromExposedAddress)
  using: _103@Mir(bb16[0])
  _35 = _1
  using: _1@Entry
  ((*_5).0: *mut src::kdtree::kdtree) = move _35
  using: _5@Mir(bb8[0]), _35@Mir(bb16[2])
  _38 = ((*_1).2: *mut src::kdtree::kdhyperrect)
  using: _1@Entry
  _37 = move _38 as *const src::kdtree::kdhyperrect (Pointer(MutToConstPointer))
  using: _38@Mir(bb16[4])
  _36 = src::kdtree::hyperrect_duplicate(move _37) -> bb17
  using: _37@Mir(bb16[5])
bb17:
  _3 = move _36
  using: _36@Mir(bb16[6])
  _40 = _3
  using: _3@Mir(bb17[0])
  _39 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdhyperrect>::is_null(move _40) -> bb18
  using: _40@Mir(bb17[1])
bb18:
  switchInt(move _39) -> [0: bb21, otherwise: bb19]
  using: _39@Mir(bb17[2])
bb19:
  _43 = _3
  using: _3@Mir(bb17[0])
  _42 = move _43 as usize (PointerExposeAddress)
  using: _43@Mir(bb19[0])
  _41 = Eq(move _42, const 0_usize)
  using: _42@Mir(bb19[1])
  assume(move _41)
  using: _41@Mir(bb19[2])
  _45 = _5
  using: _5@Mir(bb8[0])
  _44 = src::kdtree::kd_res_free(move _45) -> bb20
  using: _45@Mir(bb19[4])
bb20:
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb41
  using: 
bb21:
  _46 = ((*_1).1: *mut src::kdtree::kdnode)
  using: _1@Entry
  _4 = move _46
  using: _46@Mir(bb21[0])
  _47 = const 0_i32
  using: 
  _6 = move _47 as f64 (IntToFloat)
  using: _47@Mir(bb21[2])
  _7 = const 0_i32
  using: 
  goto -> bb22
  using: 
bb22:
  _49 = _7
  using: _7@Phi(bb22)
  _50 = ((*_1).0: i32)
  using: _1@Entry
  _48 = Lt(move _49, move _50)
  using: _49@Mir(bb22[0]), _50@Mir(bb22[1])
  switchInt(move _48) -> [0: bb29, otherwise: bb23]
  using: _48@Mir(bb22[2])
bb23:
  _55 = ((*_4).0: *mut f64)
  using: _4@Phi(bb22)
  _57 = _7
  using: _7@Phi(bb22)
  _56 = move _57 as isize (IntToInt)
  using: _57@Mir(bb23[1])
  _54 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _55, move _56) -> bb24
  using: _55@Mir(bb23[0]), _56@Mir(bb23[2])
bb24:
  _53 = (*_54)
  using: _54@Mir(bb23[3])
  _60 = _2
  using: _2@Phi(bb22)
  _62 = _7
  using: _7@Phi(bb22)
  _61 = move _62 as isize (IntToInt)
  using: _62@Mir(bb24[2])
  _59 = std::ptr::const_ptr::<impl *const f64>::offset(move _60, move _61) -> bb25
  using: _60@Mir(bb24[1]), _61@Mir(bb24[3])
bb25:
  _58 = (*_59)
  using: _59@Mir(bb24[4])
  _52 = Sub(move _53, move _58)
  using: _53@Mir(bb24[0]), _58@Mir(bb25[0])
  _66 = ((*_4).0: *mut f64)
  using: _4@Phi(bb22)
  _68 = _7
  using: _7@Phi(bb22)
  _67 = move _68 as isize (IntToInt)
  using: _68@Mir(bb25[3])
  _65 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _66, move _67) -> bb26
  using: _66@Mir(bb25[2]), _67@Mir(bb25[4])
bb26:
  _64 = (*_65)
  using: _65@Mir(bb25[5])
  _71 = _2
  using: _2@Phi(bb22)
  _73 = _7
  using: _7@Phi(bb22)
  _72 = move _73 as isize (IntToInt)
  using: _73@Mir(bb26[2])
  _70 = std::ptr::const_ptr::<impl *const f64>::offset(move _71, move _72) -> bb27
  using: _71@Mir(bb26[1]), _72@Mir(bb26[3])
bb27:
  _69 = (*_70)
  using: _70@Mir(bb26[4])
  _63 = Sub(move _64, move _69)
  using: _64@Mir(bb26[0]), _69@Mir(bb27[0])
  _51 = Mul(move _52, move _63)
  using: _52@Mir(bb25[1]), _63@Mir(bb27[1])
  _6 = Add(_6, move _51)
  using: _51@Mir(bb27[2])
  _74 = CheckedAdd(_7, const 1_i32)
  using: _7@Phi(bb22)
  assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, const 1_i32) -> bb28
  using: _74@Entry, _7@Entry
bb28:
  _7 = move (_74.0: i32)
  using: _74@Mir(bb27[4])
  goto -> bb22
  using: 
bb29:
  _76 = ((*_1).1: *mut src::kdtree::kdnode)
  using: _1@Entry
  _77 = _2
  using: _2@Phi(bb22)
  _79 = &mut _4
  using: _4@Phi(bb22)
  _78 = &raw mut (*_79)
  using: _79@Mir(bb29[2])
  _81 = &mut _6
  using: _6@Mir(bb27[3])
  _80 = &raw mut (*_81)
  using: _81@Mir(bb29[4])
  _82 = _3
  using: _3@Mir(bb17[0])
  _75 = src::kdtree::kd_nearest_i(move _76, move _77, move _78, move _80, move _82) -> bb30
  using: _76@Mir(bb29[0]), _77@Mir(bb29[1]), _78@Mir(bb29[3]), _80@Mir(bb29[5]), _82@Mir(bb29[6])
bb30:
  _84 = _3
  using: _3@Mir(bb17[0])
  _83 = src::kdtree::hyperrect_free(move _84) -> bb31
  using: _84@Mir(bb30[0])
bb31:
  _87 = _4
  using: _4@Phi(bb22)
  _86 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdnode>::is_null(move _87) -> bb32
  using: _87@Mir(bb31[0])
bb32:
  _85 = Not(move _86)
  using: _86@Mir(bb31[1])
  switchInt(move _85) -> [0: bb39, otherwise: bb33]
  using: _85@Mir(bb32[0])
bb33:
  _90 = ((*_5).1: *mut src::kdtree::res_node)
  using: _5@Mir(bb8[0])
  _91 = _4
  using: _4@Phi(bb22)
  _89 = src::kdtree::rlist_insert(move _90, move _91, const -1f64) -> bb34
  using: _90@Mir(bb33[0]), _91@Mir(bb33[1])
bb34:
  _92 = const -1_i32
  using: 
  _88 = Eq(move _89, move _92)
  using: _89@Mir(bb33[2]), _92@Mir(bb34[0])
  switchInt(move _88) -> [0: bb37, otherwise: bb35]
  using: _88@Mir(bb34[1])
bb35:
  _94 = _5
  using: _5@Mir(bb8[0])
  _93 = src::kdtree::kd_res_free(move _94) -> bb36
  using: _94@Mir(bb35[0])
bb36:
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb41
  using: 
bb37:
  _95 = const 1_i32
  using: 
  ((*_5).3: i32) = move _95
  using: _5@Mir(bb8[0]), _95@Mir(bb37[0])
  _97 = _5
  using: _5@Mir(bb8[0])
  _96 = src::kdtree::kd_res_rewind(move _97) -> bb38
  using: _97@Mir(bb37[2])
bb38:
  _0 = _5
  using: _5@Mir(bb8[0])
  goto -> bb41
  using: 
bb39:
  _100 = _4
  using: _4@Phi(bb22)
  _99 = move _100 as usize (PointerExposeAddress)
  using: _100@Mir(bb39[0])
  _98 = Eq(move _99, const 0_usize)
  using: _99@Mir(bb39[1])
  assume(move _98)
  using: _98@Mir(bb39[2])
  _102 = _5
  using: _5@Mir(bb8[0])
  _101 = src::kdtree::kd_res_free(move _102) -> bb40
  using: _102@Mir(bb39[4])
bb40:
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb41
  using: 
bb41:
  return
  using: _0@Phi(bb41)
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:410:19: 410:49 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:431:34: 431:52 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:431:60: 431:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:432:37: 432:55 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:432:63: 432:81 (#0) by default
@DefId(0:36 ~ lib[40c5]::src::kdtree::kd_nearestf)
bb0:
  _3 = const {0x0 as *mut f64}
  using: 
  _4 = const {0x0 as *mut f64}
  using: 
  _5 = ((*_1).0: i32)
  using: _1@Entry
  _6 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  _8 = _5
  using: _5@Mir(bb0[2])
  _9 = const 16_i32
  using: 
  _7 = Gt(move _8, move _9)
  using: _8@Mir(bb0[4]), _9@Mir(bb0[5])
  switchInt(move _7) -> [0: bb14, otherwise: bb1]
  using: _7@Mir(bb0[6])
bb1:
  _11 = _5
  using: _5@Mir(bb0[2])
  _12 = const 256_i32
  using: 
  _10 = Le(move _11, move _12)
  using: _11@Mir(bb1[0]), _12@Mir(bb1[1])
  switchInt(move _10) -> [0: bb8, otherwise: bb2]
  using: _10@Mir(bb1[2])
bb2:
  _16 = _5
  using: _5@Mir(bb0[2])
  _15 = move _16 as u64 (IntToInt)
  using: _16@Mir(bb2[0])
  _18 = std::mem::size_of::<f64>() -> bb3
  using: 
bb3:
  _17 = move _18 as u64 (IntToInt)
  using: _18@Mir(bb2[2])
  _14 = core::num::<impl u64>::wrapping_mul(move _15, move _17) -> bb4
  using: _15@Mir(bb2[1]), _17@Mir(bb3[0])
bb4:
  _13 = src::kdtree::malloc(move _14) -> bb5
  using: _14@Mir(bb3[1])
bb5:
  _4 = move _13 as *mut f64 (PtrToPtr)
  using: _13@Mir(bb4[0])
  _19 = _4
  using: _4@Mir(bb5[0])
  _3 = move _19
  using: _19@Mir(bb5[1])
  _21 = _3
  using: _3@Mir(bb5[2])
  _20 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _21) -> bb6
  using: _21@Mir(bb5[3])
bb6:
  switchInt(move _20) -> [0: bb16, otherwise: bb7]
  using: _20@Mir(bb5[4])
bb7:
  _24 = _3
  using: _3@Mir(bb5[2])
  _23 = move _24 as usize (PointerExposeAddress)
  using: _24@Mir(bb7[0])
  _22 = Eq(move _23, const 0_usize)
  using: _23@Mir(bb7[1])
  assume(move _22)
  using: _22@Mir(bb7[2])
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb25
  using: 
bb8:
  _28 = _5
  using: _5@Mir(bb0[2])
  _27 = move _28 as u64 (IntToInt)
  using: _28@Mir(bb8[0])
  _30 = std::mem::size_of::<f64>() -> bb9
  using: 
bb9:
  _29 = move _30 as u64 (IntToInt)
  using: _30@Mir(bb8[2])
  _26 = core::num::<impl u64>::wrapping_mul(move _27, move _29) -> bb10
  using: _27@Mir(bb8[1]), _29@Mir(bb9[0])
bb10:
  _25 = src::kdtree::malloc(move _26) -> bb11
  using: _26@Mir(bb9[1])
bb11:
  _4 = move _25 as *mut f64 (PtrToPtr)
  using: _25@Mir(bb10[0])
  _31 = _4
  using: _4@Mir(bb11[0])
  _3 = move _31
  using: _31@Mir(bb11[1])
  _33 = _3
  using: _3@Mir(bb11[2])
  _32 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _33) -> bb12
  using: _33@Mir(bb11[3])
bb12:
  switchInt(move _32) -> [0: bb16, otherwise: bb13]
  using: _32@Mir(bb11[4])
bb13:
  _36 = _3
  using: _3@Mir(bb11[2])
  _35 = move _36 as usize (PointerExposeAddress)
  using: _36@Mir(bb13[0])
  _34 = Eq(move _35, const 0_usize)
  using: _35@Mir(bb13[1])
  assume(move _34)
  using: _34@Mir(bb13[2])
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb25
  using: 
bb14:
  _40 = const {alloc34: *mut [f64; 16]}
  using: 
  _39 = &mut (*_40)
  using: _40@Mir(bb14[0])
  _38 = move _39 as &mut [f64] (Pointer(Unsize))
  using: _39@Mir(bb14[1])
  _37 = core::slice::<impl [f64]>::as_mut_ptr(move _38) -> bb15
  using: _38@Mir(bb14[2])
bb15:
  _4 = move _37
  using: _37@Mir(bb14[3])
  _41 = _4
  using: _4@Mir(bb15[0])
  _3 = move _41
  using: _41@Mir(bb15[1])
  goto -> bb16
  using: 
bb16:
  _42 = _5
  using: _5@Phi(bb16)
  _43 = _5
  using: _5@Phi(bb16)
  _44 = CheckedSub(_43, const 1_i32)
  using: _43@Mir(bb16[1])
  assert(!move (_44.1: bool), "attempt to compute `{} - {}`, which would overflow", move _43, const 1_i32) -> bb17
  using: _44@Entry, _43@Entry
bb17:
  _5 = move (_44.0: i32)
  using: _44@Mir(bb16[2])
  _47 = _42
  using: _42@Mir(bb16[0])
  _48 = const 0_i32
  using: 
  _46 = Gt(move _47, move _48)
  using: _47@Mir(bb17[1]), _48@Mir(bb17[2])
  _45 = Not(move _46)
  using: _46@Mir(bb17[3])
  switchInt(move _45) -> [0: bb19, otherwise: bb18]
  using: _45@Mir(bb17[4])
bb18:
  _57 = _1
  using: _1@Entry
  _59 = _4
  using: _4@Phi(bb16)
  _58 = move _59 as *const f64 (Pointer(MutToConstPointer))
  using: _59@Mir(bb18[1])
  _56 = src::kdtree::kd_nearest(move _57, move _58) -> bb22
  using: _57@Mir(bb18[0]), _58@Mir(bb18[2])
bb19:
  _49 = _2
  using: _2@Phi(bb16)
  _51 = _2
  using: _2@Phi(bb16)
  _50 = std::ptr::const_ptr::<impl *const f32>::offset(move _51, const 1_isize) -> bb20
  using: _51@Mir(bb19[1])
bb20:
  _2 = move _50
  using: _50@Mir(bb19[2])
  _52 = _3
  using: _3@Phi(bb16)
  _54 = _3
  using: _3@Phi(bb16)
  _53 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _54, const 1_isize) -> bb21
  using: _54@Mir(bb20[2])
bb21:
  _3 = move _53
  using: _53@Mir(bb20[3])
  _55 = (*_49)
  using: _49@Mir(bb19[0])
  (*_52) = move _55 as f64 (FloatToFloat)
  using: _52@Mir(bb20[1]), _55@Mir(bb21[1])
  goto -> bb16
  using: 
bb22:
  _6 = move _56
  using: _56@Mir(bb18[3])
  _61 = ((*_1).0: i32)
  using: _1@Entry
  _62 = const 256_i32
  using: 
  _60 = Gt(move _61, move _62)
  using: _61@Mir(bb22[1]), _62@Mir(bb22[2])
  switchInt(move _60) -> [0: bb24, otherwise: bb23]
  using: _60@Mir(bb22[3])
bb23:
  _65 = _4
  using: _4@Phi(bb16)
  _64 = move _65 as *mut libc::c_void (PtrToPtr)
  using: _65@Mir(bb23[0])
  _63 = src::kdtree::free(move _64) -> bb24
  using: _64@Mir(bb23[1])
bb24:
  _0 = _6
  using: _6@Mir(bb22[0])
  goto -> bb25
  using: 
bb25:
  return
  using: _0@Phi(bb25)
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:474:25: 474:64 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:473:22: 475:22 (#0) by default
rewrite call src::kdtree::malloc @ workspace/kdtree/src/kdtree.rs:471:19: 476:14 (#0) by default
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:485:25: 485:64 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:484:22: 486:22 (#0) by default
rewrite call src::kdtree::malloc @ workspace/kdtree/src/kdtree.rs:482:19: 487:14 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:504:19: 504:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:506:21: 506:30 (#0) by default
@DefId(0:40 ~ lib[40c5]::src::kdtree::kd_nearest3)
bb0:
  _5 = [const 0f64; 3]
  using: 
  _6 = _2
  using: _2@Entry
  _7 = const 0_usize
  using: 
  _5[_7] = move _6
  using: _7@Mir(bb0[2]), _6@Mir(bb0[1])
  _8 = _3
  using: _3@Entry
  _9 = const 1_usize
  using: 
  _5[_9] = move _8
  using: _9@Mir(bb0[5]), _8@Mir(bb0[4])
  _10 = _4
  using: _4@Entry
  _11 = const 2_usize
  using: 
  _5[_11] = move _10
  using: _11@Mir(bb0[8]), _10@Mir(bb0[7])
  _12 = _1
  using: _1@Entry
  _16 = &mut _5
  using: _5@Mir(bb0[0])
  _15 = move _16 as &mut [f64] (Pointer(Unsize))
  using: _16@Mir(bb0[11])
  _14 = core::slice::<impl [f64]>::as_mut_ptr(move _15) -> bb1
  using: _15@Mir(bb0[12])
bb1:
  _13 = move _14 as *const f64 (Pointer(MutToConstPointer))
  using: _14@Mir(bb0[13])
  _0 = src::kdtree::kd_nearest(move _12, move _13) -> bb2
  using: _12@Mir(bb0[10]), _13@Mir(bb1[0])
bb2:
  return
  using: _0@Mir(bb1[1])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0f64; 3] is not supported
@DefId(0:43 ~ lib[40c5]::src::kdtree::kd_nearest3f)
bb0:
  _5 = [const 0f64; 3]
  using: 
  _6 = _2
  using: _2@Entry
  _7 = const 0_usize
  using: 
  _5[_7] = move _6 as f64 (FloatToFloat)
  using: _7@Mir(bb0[2]), _6@Mir(bb0[1])
  _8 = _3
  using: _3@Entry
  _9 = const 1_usize
  using: 
  _5[_9] = move _8 as f64 (FloatToFloat)
  using: _9@Mir(bb0[5]), _8@Mir(bb0[4])
  _10 = _4
  using: _4@Entry
  _11 = const 2_usize
  using: 
  _5[_11] = move _10 as f64 (FloatToFloat)
  using: _11@Mir(bb0[8]), _10@Mir(bb0[7])
  _12 = _1
  using: _1@Entry
  _16 = &mut _5
  using: _5@Mir(bb0[0])
  _15 = move _16 as &mut [f64] (Pointer(Unsize))
  using: _16@Mir(bb0[11])
  _14 = core::slice::<impl [f64]>::as_mut_ptr(move _15) -> bb1
  using: _15@Mir(bb0[12])
bb1:
  _13 = move _14 as *const f64 (Pointer(MutToConstPointer))
  using: _14@Mir(bb0[13])
  _0 = src::kdtree::kd_nearest(move _12, move _13) -> bb2
  using: _12@Mir(bb0[10]), _13@Mir(bb1[0])
bb2:
  return
  using: _0@Mir(bb1[1])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0f64; 3] is not supported
@DefId(0:46 ~ lib[40c5]::src::kdtree::kd_nearest_range)
bb0:
  _4 = const 0_i32
  using: 
  _5 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  _8 = std::mem::size_of::<src::kdtree::kdres>() -> bb1
  using: 
bb1:
  _7 = move _8 as u64 (IntToInt)
  using: _8@Mir(bb0[2])
  _6 = src::kdtree::malloc(move _7) -> bb2
  using: _7@Mir(bb1[0])
bb2:
  _5 = move _6 as *mut src::kdtree::kdres (PtrToPtr)
  using: _6@Mir(bb1[1])
  _10 = _5
  using: _5@Mir(bb2[0])
  _9 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdres>::is_null(move _10) -> bb3
  using: _10@Mir(bb2[1])
bb3:
  switchInt(move _9) -> [0: bb5, otherwise: bb4]
  using: _9@Mir(bb2[2])
bb4:
  _13 = _5
  using: _5@Mir(bb2[0])
  _12 = move _13 as usize (PointerExposeAddress)
  using: _13@Mir(bb4[0])
  _11 = Eq(move _12, const 0_usize)
  using: _12@Mir(bb4[1])
  assume(move _11)
  using: _11@Mir(bb4[2])
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb16
  using: 
bb5:
  _14 = src::kdtree::alloc_resnode() -> bb6
  using: 
bb6:
  ((*_5).1: *mut src::kdtree::res_node) = move _14
  using: _5@Mir(bb2[0]), _14@Mir(bb5[0])
  _16 = ((*_5).1: *mut src::kdtree::res_node)
  using: _5@Mir(bb2[0])
  _15 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _16) -> bb7
  using: _16@Mir(bb6[1])
bb7:
  switchInt(move _15) -> [0: bb10, otherwise: bb8]
  using: _15@Mir(bb6[2])
bb8:
  _19 = ((*_5).1: *mut src::kdtree::res_node)
  using: _5@Mir(bb2[0])
  _18 = move _19 as usize (PointerExposeAddress)
  using: _19@Mir(bb8[0])
  _17 = Eq(move _18, const 0_usize)
  using: _18@Mir(bb8[1])
  assume(move _17)
  using: _17@Mir(bb8[2])
  _22 = _5
  using: _5@Mir(bb2[0])
  _21 = move _22 as *mut libc::c_void (PtrToPtr)
  using: _22@Mir(bb8[4])
  _20 = src::kdtree::free(move _21) -> bb9
  using: _21@Mir(bb8[5])
bb9:
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb16
  using: 
bb10:
  _39 = deref_copy ((*_5).1: *mut src::kdtree::res_node)
  using: _5@Mir(bb2[0])
  ((*_39).2: *mut src::kdtree::res_node) = const 0_usize as *mut src::kdtree::res_node (PointerFromExposedAddress)
  using: _39@Mir(bb10[0])
  _23 = _1
  using: _1@Entry
  ((*_5).0: *mut src::kdtree::kdtree) = move _23
  using: _5@Mir(bb2[0]), _23@Mir(bb10[2])
  _25 = ((*_1).1: *mut src::kdtree::kdnode)
  using: _1@Entry
  _26 = _2
  using: _2@Entry
  _27 = _3
  using: _3@Entry
  _28 = ((*_5).1: *mut src::kdtree::res_node)
  using: _5@Mir(bb2[0])
  _29 = const 0_i32
  using: 
  _30 = ((*_1).0: i32)
  using: _1@Entry
  _24 = src::kdtree::find_nearest(move _25, move _26, move _27, move _28, move _29, move _30) -> bb11
  using: _25@Mir(bb10[4]), _26@Mir(bb10[5]), _27@Mir(bb10[6]), _28@Mir(bb10[7]), _29@Mir(bb10[8]), _30@Mir(bb10[9])
bb11:
  _4 = move _24
  using: _24@Mir(bb10[10])
  _32 = _4
  using: _4@Mir(bb11[0])
  _33 = const -1_i32
  using: 
  _31 = Eq(move _32, move _33)
  using: _32@Mir(bb11[1]), _33@Mir(bb11[2])
  switchInt(move _31) -> [0: bb14, otherwise: bb12]
  using: _31@Mir(bb11[3])
bb12:
  _35 = _5
  using: _5@Mir(bb2[0])
  _34 = src::kdtree::kd_res_free(move _35) -> bb13
  using: _35@Mir(bb12[0])
bb13:
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb16
  using: 
bb14:
  _36 = _4
  using: _4@Mir(bb11[0])
  ((*_5).3: i32) = move _36
  using: _5@Mir(bb2[0]), _36@Mir(bb14[0])
  _38 = _5
  using: _5@Mir(bb2[0])
  _37 = src::kdtree::kd_res_rewind(move _38) -> bb15
  using: _38@Mir(bb14[2])
bb15:
  _0 = _5
  using: _5@Mir(bb2[0])
  goto -> bb16
  using: 
bb16:
  return
  using: _0@Phi(bb16)
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:549:19: 549:49 (#0) by default
@DefId(0:47 ~ lib[40c5]::src::kdtree::kd_nearest_rangef)
bb0:
  _4 = const {0x0 as *mut f64}
  using: 
  _5 = const {0x0 as *mut f64}
  using: 
  _6 = ((*_1).0: i32)
  using: _1@Entry
  _7 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  _9 = _6
  using: _6@Mir(bb0[2])
  _10 = const 16_i32
  using: 
  _8 = Gt(move _9, move _10)
  using: _9@Mir(bb0[4]), _10@Mir(bb0[5])
  switchInt(move _8) -> [0: bb14, otherwise: bb1]
  using: _8@Mir(bb0[6])
bb1:
  _12 = _6
  using: _6@Mir(bb0[2])
  _13 = const 256_i32
  using: 
  _11 = Le(move _12, move _13)
  using: _12@Mir(bb1[0]), _13@Mir(bb1[1])
  switchInt(move _11) -> [0: bb8, otherwise: bb2]
  using: _11@Mir(bb1[2])
bb2:
  _17 = _6
  using: _6@Mir(bb0[2])
  _16 = move _17 as u64 (IntToInt)
  using: _17@Mir(bb2[0])
  _19 = std::mem::size_of::<f64>() -> bb3
  using: 
bb3:
  _18 = move _19 as u64 (IntToInt)
  using: _19@Mir(bb2[2])
  _15 = core::num::<impl u64>::wrapping_mul(move _16, move _18) -> bb4
  using: _16@Mir(bb2[1]), _18@Mir(bb3[0])
bb4:
  _14 = src::kdtree::malloc(move _15) -> bb5
  using: _15@Mir(bb3[1])
bb5:
  _5 = move _14 as *mut f64 (PtrToPtr)
  using: _14@Mir(bb4[0])
  _20 = _5
  using: _5@Mir(bb5[0])
  _4 = move _20
  using: _20@Mir(bb5[1])
  _22 = _4
  using: _4@Mir(bb5[2])
  _21 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _22) -> bb6
  using: _22@Mir(bb5[3])
bb6:
  switchInt(move _21) -> [0: bb16, otherwise: bb7]
  using: _21@Mir(bb5[4])
bb7:
  _25 = _4
  using: _4@Mir(bb5[2])
  _24 = move _25 as usize (PointerExposeAddress)
  using: _25@Mir(bb7[0])
  _23 = Eq(move _24, const 0_usize)
  using: _24@Mir(bb7[1])
  assume(move _23)
  using: _23@Mir(bb7[2])
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb25
  using: 
bb8:
  _29 = _6
  using: _6@Mir(bb0[2])
  _28 = move _29 as u64 (IntToInt)
  using: _29@Mir(bb8[0])
  _31 = std::mem::size_of::<f64>() -> bb9
  using: 
bb9:
  _30 = move _31 as u64 (IntToInt)
  using: _31@Mir(bb8[2])
  _27 = core::num::<impl u64>::wrapping_mul(move _28, move _30) -> bb10
  using: _28@Mir(bb8[1]), _30@Mir(bb9[0])
bb10:
  _26 = src::kdtree::malloc(move _27) -> bb11
  using: _27@Mir(bb9[1])
bb11:
  _5 = move _26 as *mut f64 (PtrToPtr)
  using: _26@Mir(bb10[0])
  _32 = _5
  using: _5@Mir(bb11[0])
  _4 = move _32
  using: _32@Mir(bb11[1])
  _34 = _4
  using: _4@Mir(bb11[2])
  _33 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _34) -> bb12
  using: _34@Mir(bb11[3])
bb12:
  switchInt(move _33) -> [0: bb16, otherwise: bb13]
  using: _33@Mir(bb11[4])
bb13:
  _37 = _4
  using: _4@Mir(bb11[2])
  _36 = move _37 as usize (PointerExposeAddress)
  using: _37@Mir(bb13[0])
  _35 = Eq(move _36, const 0_usize)
  using: _36@Mir(bb13[1])
  assume(move _35)
  using: _35@Mir(bb13[2])
  _0 = const {0x0 as *mut src::kdtree::kdres}
  using: 
  goto -> bb25
  using: 
bb14:
  _41 = const {alloc43: *mut [f64; 16]}
  using: 
  _40 = &mut (*_41)
  using: _41@Mir(bb14[0])
  _39 = move _40 as &mut [f64] (Pointer(Unsize))
  using: _40@Mir(bb14[1])
  _38 = core::slice::<impl [f64]>::as_mut_ptr(move _39) -> bb15
  using: _39@Mir(bb14[2])
bb15:
  _5 = move _38
  using: _38@Mir(bb14[3])
  _42 = _5
  using: _5@Mir(bb15[0])
  _4 = move _42
  using: _42@Mir(bb15[1])
  goto -> bb16
  using: 
bb16:
  _43 = _6
  using: _6@Phi(bb16)
  _44 = _6
  using: _6@Phi(bb16)
  _45 = CheckedSub(_44, const 1_i32)
  using: _44@Mir(bb16[1])
  assert(!move (_45.1: bool), "attempt to compute `{} - {}`, which would overflow", move _44, const 1_i32) -> bb17
  using: _45@Entry, _44@Entry
bb17:
  _6 = move (_45.0: i32)
  using: _45@Mir(bb16[2])
  _48 = _43
  using: _43@Mir(bb16[0])
  _49 = const 0_i32
  using: 
  _47 = Gt(move _48, move _49)
  using: _48@Mir(bb17[1]), _49@Mir(bb17[2])
  _46 = Not(move _47)
  using: _47@Mir(bb17[3])
  switchInt(move _46) -> [0: bb19, otherwise: bb18]
  using: _46@Mir(bb17[4])
bb18:
  _58 = _1
  using: _1@Entry
  _60 = _5
  using: _5@Phi(bb16)
  _59 = move _60 as *const f64 (Pointer(MutToConstPointer))
  using: _60@Mir(bb18[1])
  _62 = _3
  using: _3@Entry
  _61 = move _62 as f64 (FloatToFloat)
  using: _62@Mir(bb18[3])
  _57 = src::kdtree::kd_nearest_range(move _58, move _59, move _61) -> bb22
  using: _58@Mir(bb18[0]), _59@Mir(bb18[2]), _61@Mir(bb18[4])
bb19:
  _50 = _2
  using: _2@Phi(bb16)
  _52 = _2
  using: _2@Phi(bb16)
  _51 = std::ptr::const_ptr::<impl *const f32>::offset(move _52, const 1_isize) -> bb20
  using: _52@Mir(bb19[1])
bb20:
  _2 = move _51
  using: _51@Mir(bb19[2])
  _53 = _4
  using: _4@Phi(bb16)
  _55 = _4
  using: _4@Phi(bb16)
  _54 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _55, const 1_isize) -> bb21
  using: _55@Mir(bb20[2])
bb21:
  _4 = move _54
  using: _54@Mir(bb20[3])
  _56 = (*_50)
  using: _50@Mir(bb19[0])
  (*_53) = move _56 as f64 (FloatToFloat)
  using: _53@Mir(bb20[1]), _56@Mir(bb21[1])
  goto -> bb16
  using: 
bb22:
  _7 = move _57
  using: _57@Mir(bb18[5])
  _64 = ((*_1).0: i32)
  using: _1@Entry
  _65 = const 256_i32
  using: 
  _63 = Gt(move _64, move _65)
  using: _64@Mir(bb22[1]), _65@Mir(bb22[2])
  switchInt(move _63) -> [0: bb24, otherwise: bb23]
  using: _63@Mir(bb22[3])
bb23:
  _68 = _5
  using: _5@Phi(bb16)
  _67 = move _68 as *mut libc::c_void (PtrToPtr)
  using: _68@Mir(bb23[0])
  _66 = src::kdtree::free(move _67) -> bb24
  using: _67@Mir(bb23[1])
bb24:
  _0 = _7
  using: _7@Mir(bb22[0])
  goto -> bb25
  using: 
bb25:
  return
  using: _0@Phi(bb25)
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:601:25: 601:64 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:600:22: 602:22 (#0) by default
rewrite call src::kdtree::malloc @ workspace/kdtree/src/kdtree.rs:598:19: 603:14 (#0) by default
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:612:25: 612:64 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:611:22: 613:22 (#0) by default
rewrite call src::kdtree::malloc @ workspace/kdtree/src/kdtree.rs:609:19: 614:14 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:631:19: 631:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:633:21: 633:30 (#0) by default
@DefId(0:51 ~ lib[40c5]::src::kdtree::kd_nearest_range3)
bb0:
  _6 = [const 0f64; 3]
  using: 
  _7 = _2
  using: _2@Entry
  _8 = const 0_usize
  using: 
  _6[_8] = move _7
  using: _8@Mir(bb0[2]), _7@Mir(bb0[1])
  _9 = _3
  using: _3@Entry
  _10 = const 1_usize
  using: 
  _6[_10] = move _9
  using: _10@Mir(bb0[5]), _9@Mir(bb0[4])
  _11 = _4
  using: _4@Entry
  _12 = const 2_usize
  using: 
  _6[_12] = move _11
  using: _12@Mir(bb0[8]), _11@Mir(bb0[7])
  _13 = _1
  using: _1@Entry
  _17 = &mut _6
  using: _6@Mir(bb0[0])
  _16 = move _17 as &mut [f64] (Pointer(Unsize))
  using: _17@Mir(bb0[11])
  _15 = core::slice::<impl [f64]>::as_mut_ptr(move _16) -> bb1
  using: _16@Mir(bb0[12])
bb1:
  _14 = move _15 as *const f64 (Pointer(MutToConstPointer))
  using: _15@Mir(bb0[13])
  _18 = _5
  using: _5@Entry
  _0 = src::kdtree::kd_nearest_range(move _13, move _14, move _18) -> bb2
  using: _13@Mir(bb0[10]), _14@Mir(bb1[0]), _18@Mir(bb1[1])
bb2:
  return
  using: _0@Mir(bb1[2])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0f64; 3] is not supported
@DefId(0:54 ~ lib[40c5]::src::kdtree::kd_nearest_range3f)
bb0:
  _6 = [const 0f64; 3]
  using: 
  _7 = _2
  using: _2@Entry
  _8 = const 0_usize
  using: 
  _6[_8] = move _7 as f64 (FloatToFloat)
  using: _8@Mir(bb0[2]), _7@Mir(bb0[1])
  _9 = _3
  using: _3@Entry
  _10 = const 1_usize
  using: 
  _6[_10] = move _9 as f64 (FloatToFloat)
  using: _10@Mir(bb0[5]), _9@Mir(bb0[4])
  _11 = _4
  using: _4@Entry
  _12 = const 2_usize
  using: 
  _6[_12] = move _11 as f64 (FloatToFloat)
  using: _12@Mir(bb0[8]), _11@Mir(bb0[7])
  _13 = _1
  using: _1@Entry
  _17 = &mut _6
  using: _6@Mir(bb0[0])
  _16 = move _17 as &mut [f64] (Pointer(Unsize))
  using: _17@Mir(bb0[11])
  _15 = core::slice::<impl [f64]>::as_mut_ptr(move _16) -> bb1
  using: _16@Mir(bb0[12])
bb1:
  _14 = move _15 as *const f64 (Pointer(MutToConstPointer))
  using: _15@Mir(bb0[13])
  _19 = _5
  using: _5@Entry
  _18 = move _19 as f64 (FloatToFloat)
  using: _19@Mir(bb1[1])
  _0 = src::kdtree::kd_nearest_range(move _13, move _14, move _18) -> bb2
  using: _13@Mir(bb0[10]), _14@Mir(bb1[0]), _18@Mir(bb1[2])
bb2:
  return
  using: _0@Mir(bb1[3])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0f64; 3] is not supported
@DefId(0:57 ~ lib[40c5]::src::kdtree::kd_res_free)
bb0:
  _3 = _1
  using: _1@Entry
  _2 = src::kdtree::clear_results(move _3) -> bb1
  using: _3@Mir(bb0[0])
bb1:
  _5 = ((*_1).1: *mut src::kdtree::res_node)
  using: _1@Entry
  _4 = src::kdtree::free_resnode(move _5) -> bb2
  using: _5@Mir(bb1[0])
bb2:
  _8 = _1
  using: _1@Entry
  _7 = move _8 as *mut libc::c_void (PtrToPtr)
  using: _8@Mir(bb2[0])
  _6 = src::kdtree::free(move _7) -> bb3
  using: _7@Mir(bb2[1])
bb3:
  return
  using: _0@Entry
@DefId(0:58 ~ lib[40c5]::src::kdtree::kd_res_size)
bb0:
  _0 = ((*_1).3: i32)
  using: _1@Entry
  return
  using: _0@Mir(bb0[0])
@DefId(0:59 ~ lib[40c5]::src::kdtree::kd_res_rewind)
bb0:
  _3 = deref_copy ((*_1).1: *mut src::kdtree::res_node)
  using: _1@Entry
  _2 = ((*_3).2: *mut src::kdtree::res_node)
  using: _3@Mir(bb0[0])
  ((*_1).2: *mut src::kdtree::res_node) = move _2
  using: _1@Entry, _2@Mir(bb0[1])
  return
  using: _0@Entry
@DefId(0:60 ~ lib[40c5]::src::kdtree::kd_res_end)
bb0:
  _3 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _4 = const {0x0 as *mut src::kdtree::res_node}
  using: 
  _2 = Eq(move _3, move _4)
  using: _3@Mir(bb0[0]), _4@Mir(bb0[1])
  _0 = move _2 as i32 (IntToInt)
  using: _2@Mir(bb0[2])
  return
  using: _0@Mir(bb0[3])
@DefId(0:61 ~ lib[40c5]::src::kdtree::kd_res_next)
bb0:
  _6 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _2 = ((*_6).2: *mut src::kdtree::res_node)
  using: _6@Mir(bb0[0])
  ((*_1).2: *mut src::kdtree::res_node) = move _2
  using: _1@Entry, _2@Mir(bb0[1])
  _4 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _5 = const {0x0 as *mut src::kdtree::res_node}
  using: 
  _3 = Ne(move _4, move _5)
  using: _4@Mir(bb0[3]), _5@Mir(bb0[4])
  _0 = move _3 as i32 (IntToInt)
  using: _3@Mir(bb0[5])
  return
  using: _0@Mir(bb0[6])
@DefId(0:62 ~ lib[40c5]::src::kdtree::kd_res_item)
bb0:
  _5 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _4 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _5) -> bb1
  using: _5@Mir(bb0[0])
bb1:
  _3 = Not(move _4)
  using: _4@Mir(bb0[1])
  switchInt(move _3) -> [0: bb9, otherwise: bb2]
  using: _3@Mir(bb1[0])
bb2:
  _8 = _2
  using: _2@Entry
  _7 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _8) -> bb3
  using: _8@Mir(bb2[0])
bb3:
  _6 = Not(move _7)
  using: _7@Mir(bb2[1])
  switchInt(move _6) -> [0: bb7, otherwise: bb4]
  using: _6@Mir(bb3[0])
bb4:
  _11 = _2
  using: _2@Entry
  _10 = move _11 as *mut libc::c_void (PtrToPtr)
  using: _11@Mir(bb4[0])
  _25 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _26 = deref_copy ((*_25).0: *mut src::kdtree::kdnode)
  using: _25@Mir(bb4[2])
  _13 = ((*_26).0: *mut f64)
  using: _26@Mir(bb4[3])
  _12 = move _13 as *const libc::c_void (PtrToPtr)
  using: _13@Mir(bb4[4])
  _27 = deref_copy ((*_1).0: *mut src::kdtree::kdtree)
  using: _1@Entry
  _16 = ((*_27).0: i32)
  using: _27@Mir(bb4[6])
  _15 = move _16 as u64 (IntToInt)
  using: _16@Mir(bb4[7])
  _18 = std::mem::size_of::<f64>() -> bb5
  using: 
bb5:
  _17 = move _18 as u64 (IntToInt)
  using: _18@Mir(bb4[9])
  _14 = core::num::<impl u64>::wrapping_mul(move _15, move _17) -> bb6
  using: _15@Mir(bb4[8]), _17@Mir(bb5[0])
bb6:
  _9 = src::kdtree::memcpy(move _10, move _12, move _14) -> bb8
  using: _10@Mir(bb4[1]), _12@Mir(bb4[5]), _14@Mir(bb5[1])
bb7:
  _21 = _2
  using: _2@Entry
  _20 = move _21 as usize (PointerExposeAddress)
  using: _21@Mir(bb7[0])
  _19 = Eq(move _20, const 0_usize)
  using: _20@Mir(bb7[1])
  assume(move _19)
  using: _19@Mir(bb7[2])
  goto -> bb8
  using: 
bb8:
  _28 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb8)
  _29 = deref_copy ((*_28).0: *mut src::kdtree::kdnode)
  using: _28@Mir(bb8[0])
  _0 = ((*_29).2: *mut libc::c_void)
  using: _29@Mir(bb8[1])
  goto -> bb10
  using: 
bb9:
  _24 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb8)
  _23 = move _24 as usize (PointerExposeAddress)
  using: _24@Mir(bb9[0])
  _22 = Eq(move _23, const 0_usize)
  using: _23@Mir(bb9[1])
  assume(move _22)
  using: _22@Mir(bb9[2])
  _0 = const {0x0 as *mut libc::c_void}
  using: 
  goto -> bb10
  using: 
bb10:
  return
  using: _0@Phi(bb10)
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:705:25: 705:64 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:704:22: 706:22 (#0) by default
rewrite call src::kdtree::memcpy @ workspace/kdtree/src/kdtree.rs:700:13: 707:14 (#0) by default
@DefId(0:63 ~ lib[40c5]::src::kdtree::kd_res_itemf)
bb0:
  _5 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _4 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _5) -> bb1
  using: _5@Mir(bb0[0])
bb1:
  _3 = Not(move _4)
  using: _4@Mir(bb0[1])
  switchInt(move _3) -> [0: bb12, otherwise: bb2]
  using: _3@Mir(bb1[0])
bb2:
  _8 = _2
  using: _2@Entry
  _7 = std::ptr::mut_ptr::<impl *mut f32>::is_null(move _8) -> bb3
  using: _8@Mir(bb2[0])
bb3:
  _6 = Not(move _7)
  using: _7@Mir(bb2[1])
  switchInt(move _6) -> [0: bb10, otherwise: bb4]
  using: _6@Mir(bb3[0])
bb4:
  _9 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  goto -> bb5
  using: 
bb5:
  _11 = _9
  using: _9@Phi(bb5)
  _29 = deref_copy ((*_1).0: *mut src::kdtree::kdtree)
  using: _1@Phi(bb5)
  _12 = ((*_29).0: i32)
  using: _29@Mir(bb5[1])
  _10 = Lt(move _11, move _12)
  using: _11@Mir(bb5[0]), _12@Mir(bb5[2])
  switchInt(move _10) -> [0: bb11, otherwise: bb6]
  using: _10@Mir(bb5[3])
bb6:
  _30 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb5)
  _31 = deref_copy ((*_30).0: *mut src::kdtree::kdnode)
  using: _30@Mir(bb6[0])
  _15 = ((*_31).0: *mut f64)
  using: _31@Mir(bb6[1])
  _17 = _9
  using: _9@Phi(bb5)
  _16 = move _17 as isize (IntToInt)
  using: _17@Mir(bb6[3])
  _14 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _15, move _16) -> bb7
  using: _15@Mir(bb6[2]), _16@Mir(bb6[4])
bb7:
  _13 = (*_14)
  using: _14@Mir(bb6[5])
  _19 = _2
  using: _2@Phi(bb5)
  _21 = _9
  using: _9@Phi(bb5)
  _20 = move _21 as isize (IntToInt)
  using: _21@Mir(bb7[2])
  _18 = std::ptr::mut_ptr::<impl *mut f32>::offset(move _19, move _20) -> bb8
  using: _19@Mir(bb7[1]), _20@Mir(bb7[3])
bb8:
  (*_18) = move _13 as f32 (FloatToFloat)
  using: _18@Mir(bb7[4]), _13@Mir(bb7[0])
  _22 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb5)
  assert(!move (_22.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb9
  using: _22@Entry, _9@Entry
bb9:
  _9 = move (_22.0: i32)
  using: _22@Mir(bb8[1])
  goto -> bb5
  using: 
bb10:
  _25 = _2
  using: _2@Phi(bb5)
  _24 = move _25 as usize (PointerExposeAddress)
  using: _25@Mir(bb10[0])
  _23 = Eq(move _24, const 0_usize)
  using: _24@Mir(bb10[1])
  assume(move _23)
  using: _23@Mir(bb10[2])
  goto -> bb11
  using: 
bb11:
  _32 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb11)
  _33 = deref_copy ((*_32).0: *mut src::kdtree::kdnode)
  using: _32@Mir(bb11[0])
  _0 = ((*_33).2: *mut libc::c_void)
  using: _33@Mir(bb11[1])
  goto -> bb13
  using: 
bb12:
  _28 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb11)
  _27 = move _28 as usize (PointerExposeAddress)
  using: _28@Mir(bb12[0])
  _26 = Eq(move _27, const 0_usize)
  using: _27@Mir(bb12[1])
  assume(move _26)
  using: _26@Mir(bb12[2])
  _0 = const {0x0 as *mut libc::c_void}
  using: 
  goto -> bb13
  using: 
bb13:
  return
  using: _0@Phi(bb13)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:726:57: 726:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:724:22: 726:22 (#0) by default
@DefId(0:64 ~ lib[40c5]::src::kdtree::kd_res_item3)
bb0:
  _7 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _6 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _7) -> bb1
  using: _7@Mir(bb0[0])
bb1:
  _5 = Not(move _6)
  using: _6@Mir(bb0[1])
  switchInt(move _5) -> [0: bb18, otherwise: bb2]
  using: _5@Mir(bb1[0])
bb2:
  _10 = _2
  using: _2@Entry
  _9 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _10) -> bb3
  using: _10@Mir(bb2[0])
bb3:
  _8 = Not(move _9)
  using: _9@Mir(bb2[1])
  switchInt(move _8) -> [0: bb6, otherwise: bb4]
  using: _8@Mir(bb3[0])
bb4:
  _41 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _42 = deref_copy ((*_41).0: *mut src::kdtree::kdnode)
  using: _41@Mir(bb4[0])
  _13 = ((*_42).0: *mut f64)
  using: _42@Mir(bb4[1])
  _14 = const 0_isize
  using: 
  _12 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _13, move _14) -> bb5
  using: _13@Mir(bb4[2]), _14@Mir(bb4[3])
bb5:
  _11 = (*_12)
  using: _12@Mir(bb4[4])
  (*_2) = move _11
  using: _2@Entry, _11@Mir(bb5[0])
  goto -> bb7
  using: 
bb6:
  _17 = _2
  using: _2@Entry
  _16 = move _17 as usize (PointerExposeAddress)
  using: _17@Mir(bb6[0])
  _15 = Eq(move _16, const 0_usize)
  using: _16@Mir(bb6[1])
  assume(move _15)
  using: _15@Mir(bb6[2])
  goto -> bb7
  using: 
bb7:
  _20 = _3
  using: _3@Entry
  _19 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _20) -> bb8
  using: _20@Mir(bb7[0])
bb8:
  _18 = Not(move _19)
  using: _19@Mir(bb7[1])
  switchInt(move _18) -> [0: bb11, otherwise: bb9]
  using: _18@Mir(bb8[0])
bb9:
  _43 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb7)
  _44 = deref_copy ((*_43).0: *mut src::kdtree::kdnode)
  using: _43@Mir(bb9[0])
  _23 = ((*_44).0: *mut f64)
  using: _44@Mir(bb9[1])
  _24 = const 1_isize
  using: 
  _22 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _23, move _24) -> bb10
  using: _23@Mir(bb9[2]), _24@Mir(bb9[3])
bb10:
  _21 = (*_22)
  using: _22@Mir(bb9[4])
  (*_3) = move _21
  using: _3@Entry, _21@Mir(bb10[0])
  goto -> bb12
  using: 
bb11:
  _27 = _3
  using: _3@Entry
  _26 = move _27 as usize (PointerExposeAddress)
  using: _27@Mir(bb11[0])
  _25 = Eq(move _26, const 0_usize)
  using: _26@Mir(bb11[1])
  assume(move _25)
  using: _25@Mir(bb11[2])
  goto -> bb12
  using: 
bb12:
  _30 = _4
  using: _4@Entry
  _29 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _30) -> bb13
  using: _30@Mir(bb12[0])
bb13:
  _28 = Not(move _29)
  using: _29@Mir(bb12[1])
  switchInt(move _28) -> [0: bb16, otherwise: bb14]
  using: _28@Mir(bb13[0])
bb14:
  _45 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb12)
  _46 = deref_copy ((*_45).0: *mut src::kdtree::kdnode)
  using: _45@Mir(bb14[0])
  _33 = ((*_46).0: *mut f64)
  using: _46@Mir(bb14[1])
  _34 = const 2_isize
  using: 
  _32 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _33, move _34) -> bb15
  using: _33@Mir(bb14[2]), _34@Mir(bb14[3])
bb15:
  _31 = (*_32)
  using: _32@Mir(bb14[4])
  (*_4) = move _31
  using: _4@Entry, _31@Mir(bb15[0])
  goto -> bb17
  using: 
bb16:
  _37 = _4
  using: _4@Entry
  _36 = move _37 as usize (PointerExposeAddress)
  using: _37@Mir(bb16[0])
  _35 = Eq(move _36, const 0_usize)
  using: _36@Mir(bb16[1])
  assume(move _35)
  using: _35@Mir(bb16[2])
  goto -> bb17
  using: 
bb17:
  _47 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb17)
  _48 = deref_copy ((*_47).0: *mut src::kdtree::kdnode)
  using: _47@Mir(bb17[0])
  _0 = ((*_48).2: *mut libc::c_void)
  using: _48@Mir(bb17[1])
  goto -> bb19
  using: 
bb18:
  _40 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb17)
  _39 = move _40 as usize (PointerExposeAddress)
  using: _40@Mir(bb18[0])
  _38 = Eq(move _39, const 0_usize)
  using: _39@Mir(bb18[1])
  assume(move _38)
  using: _38@Mir(bb18[2])
  _0 = const {0x0 as *mut libc::c_void}
  using: 
  goto -> bb19
  using: 
bb19:
  return
  using: _0@Phi(bb19)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:744:50: 744:83 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:747:50: 747:83 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:750:50: 750:83 (#0) by default
@DefId(0:65 ~ lib[40c5]::src::kdtree::kd_res_item3f)
bb0:
  _7 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _6 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _7) -> bb1
  using: _7@Mir(bb0[0])
bb1:
  _5 = Not(move _6)
  using: _6@Mir(bb0[1])
  switchInt(move _5) -> [0: bb18, otherwise: bb2]
  using: _5@Mir(bb1[0])
bb2:
  _10 = _2
  using: _2@Entry
  _9 = std::ptr::mut_ptr::<impl *mut f32>::is_null(move _10) -> bb3
  using: _10@Mir(bb2[0])
bb3:
  _8 = Not(move _9)
  using: _9@Mir(bb2[1])
  switchInt(move _8) -> [0: bb6, otherwise: bb4]
  using: _8@Mir(bb3[0])
bb4:
  _41 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Entry
  _42 = deref_copy ((*_41).0: *mut src::kdtree::kdnode)
  using: _41@Mir(bb4[0])
  _13 = ((*_42).0: *mut f64)
  using: _42@Mir(bb4[1])
  _14 = const 0_isize
  using: 
  _12 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _13, move _14) -> bb5
  using: _13@Mir(bb4[2]), _14@Mir(bb4[3])
bb5:
  _11 = (*_12)
  using: _12@Mir(bb4[4])
  (*_2) = move _11 as f32 (FloatToFloat)
  using: _2@Entry, _11@Mir(bb5[0])
  goto -> bb7
  using: 
bb6:
  _17 = _2
  using: _2@Entry
  _16 = move _17 as usize (PointerExposeAddress)
  using: _17@Mir(bb6[0])
  _15 = Eq(move _16, const 0_usize)
  using: _16@Mir(bb6[1])
  assume(move _15)
  using: _15@Mir(bb6[2])
  goto -> bb7
  using: 
bb7:
  _20 = _3
  using: _3@Entry
  _19 = std::ptr::mut_ptr::<impl *mut f32>::is_null(move _20) -> bb8
  using: _20@Mir(bb7[0])
bb8:
  _18 = Not(move _19)
  using: _19@Mir(bb7[1])
  switchInt(move _18) -> [0: bb11, otherwise: bb9]
  using: _18@Mir(bb8[0])
bb9:
  _43 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb7)
  _44 = deref_copy ((*_43).0: *mut src::kdtree::kdnode)
  using: _43@Mir(bb9[0])
  _23 = ((*_44).0: *mut f64)
  using: _44@Mir(bb9[1])
  _24 = const 1_isize
  using: 
  _22 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _23, move _24) -> bb10
  using: _23@Mir(bb9[2]), _24@Mir(bb9[3])
bb10:
  _21 = (*_22)
  using: _22@Mir(bb9[4])
  (*_3) = move _21 as f32 (FloatToFloat)
  using: _3@Entry, _21@Mir(bb10[0])
  goto -> bb12
  using: 
bb11:
  _27 = _3
  using: _3@Entry
  _26 = move _27 as usize (PointerExposeAddress)
  using: _27@Mir(bb11[0])
  _25 = Eq(move _26, const 0_usize)
  using: _26@Mir(bb11[1])
  assume(move _25)
  using: _25@Mir(bb11[2])
  goto -> bb12
  using: 
bb12:
  _30 = _4
  using: _4@Entry
  _29 = std::ptr::mut_ptr::<impl *mut f32>::is_null(move _30) -> bb13
  using: _30@Mir(bb12[0])
bb13:
  _28 = Not(move _29)
  using: _29@Mir(bb12[1])
  switchInt(move _28) -> [0: bb16, otherwise: bb14]
  using: _28@Mir(bb13[0])
bb14:
  _45 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb12)
  _46 = deref_copy ((*_45).0: *mut src::kdtree::kdnode)
  using: _45@Mir(bb14[0])
  _33 = ((*_46).0: *mut f64)
  using: _46@Mir(bb14[1])
  _34 = const 2_isize
  using: 
  _32 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _33, move _34) -> bb15
  using: _33@Mir(bb14[2]), _34@Mir(bb14[3])
bb15:
  _31 = (*_32)
  using: _32@Mir(bb14[4])
  (*_4) = move _31 as f32 (FloatToFloat)
  using: _4@Entry, _31@Mir(bb15[0])
  goto -> bb17
  using: 
bb16:
  _37 = _4
  using: _4@Entry
  _36 = move _37 as usize (PointerExposeAddress)
  using: _37@Mir(bb16[0])
  _35 = Eq(move _36, const 0_usize)
  using: _36@Mir(bb16[1])
  assume(move _35)
  using: _35@Mir(bb16[2])
  goto -> bb17
  using: 
bb17:
  _47 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb17)
  _48 = deref_copy ((*_47).0: *mut src::kdtree::kdnode)
  using: _47@Mir(bb17[0])
  _0 = ((*_48).2: *mut libc::c_void)
  using: _48@Mir(bb17[1])
  goto -> bb19
  using: 
bb18:
  _40 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb17)
  _39 = move _40 as usize (PointerExposeAddress)
  using: _40@Mir(bb18[0])
  _38 = Eq(move _39, const 0_usize)
  using: _39@Mir(bb18[1])
  assume(move _38)
  using: _38@Mir(bb18[2])
  _0 = const {0x0 as *mut libc::c_void}
  using: 
  goto -> bb19
  using: 
bb19:
  return
  using: _0@Phi(bb19)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:765:50: 765:83 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:769:50: 769:83 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:773:50: 773:83 (#0) by default
@DefId(0:66 ~ lib[40c5]::src::kdtree::kd_res_item_data)
bb0:
  _2 = _1
  using: _1@Entry
  _3 = const {0x0 as *mut f64}
  using: 
  _0 = src::kdtree::kd_res_item(move _2, move _3) -> bb1
  using: _2@Mir(bb0[0]), _3@Mir(bb0[1])
bb1:
  return
  using: _0@Mir(bb0[2])
@DefId(0:67 ~ lib[40c5]::src::kdtree::hyperrect_create)
bb0:
  _6 = _1
  using: _1@Entry
  _5 = move _6 as u64 (IntToInt)
  using: _6@Mir(bb0[0])
  _8 = std::mem::size_of::<f64>() -> bb1
  using: 
bb1:
  _7 = move _8 as u64 (IntToInt)
  using: _8@Mir(bb0[2])
  _4 = core::num::<impl u64>::wrapping_mul(move _5, move _7) -> bb2
  using: _5@Mir(bb0[1]), _7@Mir(bb1[0])
bb2:
  _9 = const {0x0 as *mut src::kdtree::kdhyperrect}
  using: 
  _12 = std::mem::size_of::<src::kdtree::kdhyperrect>() -> bb3
  using: 
bb3:
  _11 = move _12 as u64 (IntToInt)
  using: _12@Mir(bb2[1])
  _10 = src::kdtree::malloc(move _11) -> bb4
  using: _11@Mir(bb3[0])
bb4:
  _9 = move _10 as *mut src::kdtree::kdhyperrect (PtrToPtr)
  using: _10@Mir(bb3[1])
  _14 = _9
  using: _9@Mir(bb4[0])
  _13 = std::ptr::mut_ptr::<impl *mut src::kdtree::kdhyperrect>::is_null(move _14) -> bb5
  using: _14@Mir(bb4[1])
bb5:
  switchInt(move _13) -> [0: bb7, otherwise: bb6]
  using: _13@Mir(bb4[2])
bb6:
  _17 = _9
  using: _9@Mir(bb4[0])
  _16 = move _17 as usize (PointerExposeAddress)
  using: _17@Mir(bb6[0])
  _15 = Eq(move _16, const 0_usize)
  using: _16@Mir(bb6[1])
  assume(move _15)
  using: _15@Mir(bb6[2])
  _0 = const {0x0 as *mut src::kdtree::kdhyperrect}
  using: 
  goto -> bb21
  using: 
bb7:
  _18 = _1
  using: _1@Entry
  ((*_9).0: i32) = move _18
  using: _9@Mir(bb4[0]), _18@Mir(bb7[0])
  _20 = _4
  using: _4@Mir(bb1[1])
  _19 = src::kdtree::malloc(move _20) -> bb8
  using: _20@Mir(bb7[2])
bb8:
  ((*_9).1: *mut f64) = move _19 as *mut f64 (PtrToPtr)
  using: _9@Mir(bb4[0]), _19@Mir(bb7[3])
  _22 = ((*_9).1: *mut f64)
  using: _9@Mir(bb4[0])
  _21 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _22) -> bb9
  using: _22@Mir(bb8[1])
bb9:
  switchInt(move _21) -> [0: bb12, otherwise: bb10]
  using: _21@Mir(bb8[2])
bb10:
  _25 = ((*_9).1: *mut f64)
  using: _9@Mir(bb4[0])
  _24 = move _25 as usize (PointerExposeAddress)
  using: _25@Mir(bb10[0])
  _23 = Eq(move _24, const 0_usize)
  using: _24@Mir(bb10[1])
  assume(move _23)
  using: _23@Mir(bb10[2])
  _28 = _9
  using: _9@Mir(bb4[0])
  _27 = move _28 as *mut libc::c_void (PtrToPtr)
  using: _28@Mir(bb10[4])
  _26 = src::kdtree::free(move _27) -> bb11
  using: _27@Mir(bb10[5])
bb11:
  _0 = const {0x0 as *mut src::kdtree::kdhyperrect}
  using: 
  goto -> bb21
  using: 
bb12:
  _30 = _4
  using: _4@Mir(bb1[1])
  _29 = src::kdtree::malloc(move _30) -> bb13
  using: _30@Mir(bb12[0])
bb13:
  ((*_9).2: *mut f64) = move _29 as *mut f64 (PtrToPtr)
  using: _9@Mir(bb4[0]), _29@Mir(bb12[1])
  _32 = ((*_9).2: *mut f64)
  using: _9@Mir(bb4[0])
  _31 = std::ptr::mut_ptr::<impl *mut f64>::is_null(move _32) -> bb14
  using: _32@Mir(bb13[1])
bb14:
  switchInt(move _31) -> [0: bb18, otherwise: bb15]
  using: _31@Mir(bb13[2])
bb15:
  _35 = ((*_9).2: *mut f64)
  using: _9@Mir(bb4[0])
  _34 = move _35 as usize (PointerExposeAddress)
  using: _35@Mir(bb15[0])
  _33 = Eq(move _34, const 0_usize)
  using: _34@Mir(bb15[1])
  assume(move _33)
  using: _33@Mir(bb15[2])
  _38 = ((*_9).1: *mut f64)
  using: _9@Mir(bb4[0])
  _37 = move _38 as *mut libc::c_void (PtrToPtr)
  using: _38@Mir(bb15[4])
  _36 = src::kdtree::free(move _37) -> bb16
  using: _37@Mir(bb15[5])
bb16:
  _41 = _9
  using: _9@Mir(bb4[0])
  _40 = move _41 as *mut libc::c_void (PtrToPtr)
  using: _41@Mir(bb16[0])
  _39 = src::kdtree::free(move _40) -> bb17
  using: _40@Mir(bb16[1])
bb17:
  _0 = const {0x0 as *mut src::kdtree::kdhyperrect}
  using: 
  goto -> bb21
  using: 
bb18:
  _44 = ((*_9).1: *mut f64)
  using: _9@Mir(bb4[0])
  _43 = move _44 as *mut libc::c_void (PtrToPtr)
  using: _44@Mir(bb18[0])
  _46 = _2
  using: _2@Entry
  _45 = move _46 as *const libc::c_void (PtrToPtr)
  using: _46@Mir(bb18[2])
  _47 = _4
  using: _4@Mir(bb1[1])
  _42 = src::kdtree::memcpy(move _43, move _45, move _47) -> bb19
  using: _43@Mir(bb18[1]), _45@Mir(bb18[3]), _47@Mir(bb18[4])
bb19:
  _50 = ((*_9).2: *mut f64)
  using: _9@Mir(bb4[0])
  _49 = move _50 as *mut libc::c_void (PtrToPtr)
  using: _50@Mir(bb19[0])
  _52 = _3
  using: _3@Entry
  _51 = move _52 as *const libc::c_void (PtrToPtr)
  using: _52@Mir(bb19[2])
  _53 = _4
  using: _4@Mir(bb1[1])
  _48 = src::kdtree::memcpy(move _49, move _51, move _53) -> bb20
  using: _49@Mir(bb19[1]), _51@Mir(bb19[3]), _53@Mir(bb19[4])
bb20:
  _0 = _9
  using: _9@Mir(bb4[0])
  goto -> bb21
  using: 
bb21:
  return
  using: _0@Phi(bb21)
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:790:23: 790:62 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/kdtree/src/kdtree.rs:790:10: 790:80 (#0) by default
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:792:19: 792:55 (#0) by default
rewrite call src::kdtree::malloc @ workspace/kdtree/src/kdtree.rs:798:19: 798:31 (#0) by default
rewrite call src::kdtree::malloc @ workspace/kdtree/src/kdtree.rs:803:19: 803:31 (#0) by default
rewrite call src::kdtree::memcpy @ workspace/kdtree/src/kdtree.rs:809:5: 809:79 (#0) by default
rewrite call src::kdtree::memcpy @ workspace/kdtree/src/kdtree.rs:810:5: 810:79 (#0) by default
@DefId(0:68 ~ lib[40c5]::src::kdtree::hyperrect_free)
bb0:
  _4 = ((*_1).1: *mut f64)
  using: _1@Entry
  _3 = move _4 as *mut libc::c_void (PtrToPtr)
  using: _4@Mir(bb0[0])
  _2 = src::kdtree::free(move _3) -> bb1
  using: _3@Mir(bb0[1])
bb1:
  _7 = ((*_1).2: *mut f64)
  using: _1@Entry
  _6 = move _7 as *mut libc::c_void (PtrToPtr)
  using: _7@Mir(bb1[0])
  _5 = src::kdtree::free(move _6) -> bb2
  using: _6@Mir(bb1[1])
bb2:
  _10 = _1
  using: _1@Entry
  _9 = move _10 as *mut libc::c_void (PtrToPtr)
  using: _10@Mir(bb2[0])
  _8 = src::kdtree::free(move _9) -> bb3
  using: _9@Mir(bb2[1])
bb3:
  return
  using: _0@Entry
@DefId(0:69 ~ lib[40c5]::src::kdtree::hyperrect_duplicate)
bb0:
  _2 = ((*_1).0: i32)
  using: _1@Entry
  _4 = ((*_1).1: *mut f64)
  using: _1@Entry
  _3 = move _4 as *const f64 (Pointer(MutToConstPointer))
  using: _4@Mir(bb0[1])
  _6 = ((*_1).2: *mut f64)
  using: _1@Entry
  _5 = move _6 as *const f64 (Pointer(MutToConstPointer))
  using: _6@Mir(bb0[3])
  _0 = src::kdtree::hyperrect_create(move _2, move _3, move _5) -> bb1
  using: _2@Mir(bb0[0]), _3@Mir(bb0[2]), _5@Mir(bb0[4])
bb1:
  return
  using: _0@Mir(bb0[5])
@DefId(0:70 ~ lib[40c5]::src::kdtree::hyperrect_extend)
bb0:
  _3 = const 0_i32
  using: 
  _3 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _5 = _3
  using: _3@Phi(bb1)
  _6 = ((*_1).0: i32)
  using: _1@Phi(bb1)
  _4 = Lt(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb16, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _10 = _2
  using: _2@Phi(bb1)
  _12 = _3
  using: _3@Phi(bb1)
  _11 = move _12 as isize (IntToInt)
  using: _12@Mir(bb2[1])
  _9 = std::ptr::const_ptr::<impl *const f64>::offset(move _10, move _11) -> bb3
  using: _10@Mir(bb2[0]), _11@Mir(bb2[2])
bb3:
  _8 = (*_9)
  using: _9@Mir(bb2[3])
  _15 = ((*_1).1: *mut f64)
  using: _1@Phi(bb1)
  _17 = _3
  using: _3@Phi(bb1)
  _16 = move _17 as isize (IntToInt)
  using: _17@Mir(bb3[2])
  _14 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _15, move _16) -> bb4
  using: _15@Mir(bb3[1]), _16@Mir(bb3[3])
bb4:
  _13 = (*_14)
  using: _14@Mir(bb3[4])
  _7 = Lt(move _8, move _13)
  using: _8@Mir(bb3[0]), _13@Mir(bb4[0])
  switchInt(move _7) -> [0: bb8, otherwise: bb5]
  using: _7@Mir(bb4[1])
bb5:
  _20 = _2
  using: _2@Phi(bb1)
  _22 = _3
  using: _3@Phi(bb1)
  _21 = move _22 as isize (IntToInt)
  using: _22@Mir(bb5[1])
  _19 = std::ptr::const_ptr::<impl *const f64>::offset(move _20, move _21) -> bb6
  using: _20@Mir(bb5[0]), _21@Mir(bb5[2])
bb6:
  _18 = (*_19)
  using: _19@Mir(bb5[3])
  _24 = ((*_1).1: *mut f64)
  using: _1@Phi(bb1)
  _26 = _3
  using: _3@Phi(bb1)
  _25 = move _26 as isize (IntToInt)
  using: _26@Mir(bb6[2])
  _23 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _24, move _25) -> bb7
  using: _24@Mir(bb6[1]), _25@Mir(bb6[3])
bb7:
  (*_23) = move _18
  using: _23@Mir(bb6[4]), _18@Mir(bb6[0])
  goto -> bb8
  using: 
bb8:
  _30 = _2
  using: _2@Phi(bb8)
  _32 = _3
  using: _3@Phi(bb8)
  _31 = move _32 as isize (IntToInt)
  using: _32@Mir(bb8[1])
  _29 = std::ptr::const_ptr::<impl *const f64>::offset(move _30, move _31) -> bb9
  using: _30@Mir(bb8[0]), _31@Mir(bb8[2])
bb9:
  _28 = (*_29)
  using: _29@Mir(bb8[3])
  _35 = ((*_1).2: *mut f64)
  using: _1@Phi(bb8)
  _37 = _3
  using: _3@Phi(bb8)
  _36 = move _37 as isize (IntToInt)
  using: _37@Mir(bb9[2])
  _34 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _35, move _36) -> bb10
  using: _35@Mir(bb9[1]), _36@Mir(bb9[3])
bb10:
  _33 = (*_34)
  using: _34@Mir(bb9[4])
  _27 = Gt(move _28, move _33)
  using: _28@Mir(bb9[0]), _33@Mir(bb10[0])
  switchInt(move _27) -> [0: bb14, otherwise: bb11]
  using: _27@Mir(bb10[1])
bb11:
  _40 = _2
  using: _2@Phi(bb8)
  _42 = _3
  using: _3@Phi(bb8)
  _41 = move _42 as isize (IntToInt)
  using: _42@Mir(bb11[1])
  _39 = std::ptr::const_ptr::<impl *const f64>::offset(move _40, move _41) -> bb12
  using: _40@Mir(bb11[0]), _41@Mir(bb11[2])
bb12:
  _38 = (*_39)
  using: _39@Mir(bb11[3])
  _44 = ((*_1).2: *mut f64)
  using: _1@Phi(bb8)
  _46 = _3
  using: _3@Phi(bb8)
  _45 = move _46 as isize (IntToInt)
  using: _46@Mir(bb12[2])
  _43 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _44, move _45) -> bb13
  using: _44@Mir(bb12[1]), _45@Mir(bb12[3])
bb13:
  (*_43) = move _38
  using: _43@Mir(bb12[4]), _38@Mir(bb12[0])
  goto -> bb14
  using: 
bb14:
  _47 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb14)
  assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb15
  using: _47@Entry, _3@Entry
bb15:
  _3 = move (_47.0: i32)
  using: _47@Mir(bb14[0])
  goto -> bb1
  using: 
bb16:
  return
  using: _0@Entry
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:830:17: 830:35 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:830:53: 830:71 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:831:54: 831:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:831:28: 831:46 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:833:17: 833:35 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:833:53: 833:71 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:834:54: 834:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:834:28: 834:46 (#0) by default
@DefId(0:71 ~ lib[40c5]::src::kdtree::hyperrect_dist_sq)
bb0:
  _3 = const 0_i32
  using: 
  _0 = const 0f64
  using: 
  _3 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _5 = _3
  using: _3@Phi(bb1)
  _6 = ((*_1).0: i32)
  using: _1@Phi(bb1)
  _4 = Lt(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb20, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _10 = _2
  using: _2@Phi(bb1)
  _12 = _3
  using: _3@Phi(bb1)
  _11 = move _12 as isize (IntToInt)
  using: _12@Mir(bb2[1])
  _9 = std::ptr::const_ptr::<impl *const f64>::offset(move _10, move _11) -> bb3
  using: _10@Mir(bb2[0]), _11@Mir(bb2[2])
bb3:
  _8 = (*_9)
  using: _9@Mir(bb2[3])
  _15 = ((*_1).1: *mut f64)
  using: _1@Phi(bb1)
  _17 = _3
  using: _3@Phi(bb1)
  _16 = move _17 as isize (IntToInt)
  using: _17@Mir(bb3[2])
  _14 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _15, move _16) -> bb4
  using: _15@Mir(bb3[1]), _16@Mir(bb3[3])
bb4:
  _13 = (*_14)
  using: _14@Mir(bb3[4])
  _7 = Lt(move _8, move _13)
  using: _8@Mir(bb3[0]), _13@Mir(bb4[0])
  switchInt(move _7) -> [0: bb10, otherwise: bb5]
  using: _7@Mir(bb4[1])
bb5:
  _22 = ((*_1).1: *mut f64)
  using: _1@Phi(bb1)
  _24 = _3
  using: _3@Phi(bb1)
  _23 = move _24 as isize (IntToInt)
  using: _24@Mir(bb5[1])
  _21 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _22, move _23) -> bb6
  using: _22@Mir(bb5[0]), _23@Mir(bb5[2])
bb6:
  _20 = (*_21)
  using: _21@Mir(bb5[3])
  _27 = _2
  using: _2@Phi(bb1)
  _29 = _3
  using: _3@Phi(bb1)
  _28 = move _29 as isize (IntToInt)
  using: _29@Mir(bb6[2])
  _26 = std::ptr::const_ptr::<impl *const f64>::offset(move _27, move _28) -> bb7
  using: _27@Mir(bb6[1]), _28@Mir(bb6[3])
bb7:
  _25 = (*_26)
  using: _26@Mir(bb6[4])
  _19 = Sub(move _20, move _25)
  using: _20@Mir(bb6[0]), _25@Mir(bb7[0])
  _33 = ((*_1).1: *mut f64)
  using: _1@Phi(bb1)
  _35 = _3
  using: _3@Phi(bb1)
  _34 = move _35 as isize (IntToInt)
  using: _35@Mir(bb7[3])
  _32 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _33, move _34) -> bb8
  using: _33@Mir(bb7[2]), _34@Mir(bb7[4])
bb8:
  _31 = (*_32)
  using: _32@Mir(bb7[5])
  _38 = _2
  using: _2@Phi(bb1)
  _40 = _3
  using: _3@Phi(bb1)
  _39 = move _40 as isize (IntToInt)
  using: _40@Mir(bb8[2])
  _37 = std::ptr::const_ptr::<impl *const f64>::offset(move _38, move _39) -> bb9
  using: _38@Mir(bb8[1]), _39@Mir(bb8[3])
bb9:
  _36 = (*_37)
  using: _37@Mir(bb8[4])
  _30 = Sub(move _31, move _36)
  using: _31@Mir(bb8[0]), _36@Mir(bb9[0])
  _18 = Mul(move _19, move _30)
  using: _19@Mir(bb7[1]), _30@Mir(bb9[1])
  _0 = Add(_0, move _18)
  using: _18@Mir(bb9[2])
  goto -> bb18
  using: 
bb10:
  _44 = _2
  using: _2@Phi(bb1)
  _46 = _3
  using: _3@Phi(bb1)
  _45 = move _46 as isize (IntToInt)
  using: _46@Mir(bb10[1])
  _43 = std::ptr::const_ptr::<impl *const f64>::offset(move _44, move _45) -> bb11
  using: _44@Mir(bb10[0]), _45@Mir(bb10[2])
bb11:
  _42 = (*_43)
  using: _43@Mir(bb10[3])
  _49 = ((*_1).2: *mut f64)
  using: _1@Phi(bb1)
  _51 = _3
  using: _3@Phi(bb1)
  _50 = move _51 as isize (IntToInt)
  using: _51@Mir(bb11[2])
  _48 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _49, move _50) -> bb12
  using: _49@Mir(bb11[1]), _50@Mir(bb11[3])
bb12:
  _47 = (*_48)
  using: _48@Mir(bb11[4])
  _41 = Gt(move _42, move _47)
  using: _42@Mir(bb11[0]), _47@Mir(bb12[0])
  switchInt(move _41) -> [0: bb18, otherwise: bb13]
  using: _41@Mir(bb12[1])
bb13:
  _56 = ((*_1).2: *mut f64)
  using: _1@Phi(bb1)
  _58 = _3
  using: _3@Phi(bb1)
  _57 = move _58 as isize (IntToInt)
  using: _58@Mir(bb13[1])
  _55 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _56, move _57) -> bb14
  using: _56@Mir(bb13[0]), _57@Mir(bb13[2])
bb14:
  _54 = (*_55)
  using: _55@Mir(bb13[3])
  _61 = _2
  using: _2@Phi(bb1)
  _63 = _3
  using: _3@Phi(bb1)
  _62 = move _63 as isize (IntToInt)
  using: _63@Mir(bb14[2])
  _60 = std::ptr::const_ptr::<impl *const f64>::offset(move _61, move _62) -> bb15
  using: _61@Mir(bb14[1]), _62@Mir(bb14[3])
bb15:
  _59 = (*_60)
  using: _60@Mir(bb14[4])
  _53 = Sub(move _54, move _59)
  using: _54@Mir(bb14[0]), _59@Mir(bb15[0])
  _67 = ((*_1).2: *mut f64)
  using: _1@Phi(bb1)
  _69 = _3
  using: _3@Phi(bb1)
  _68 = move _69 as isize (IntToInt)
  using: _69@Mir(bb15[3])
  _66 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _67, move _68) -> bb16
  using: _67@Mir(bb15[2]), _68@Mir(bb15[4])
bb16:
  _65 = (*_66)
  using: _66@Mir(bb15[5])
  _72 = _2
  using: _2@Phi(bb1)
  _74 = _3
  using: _3@Phi(bb1)
  _73 = move _74 as isize (IntToInt)
  using: _74@Mir(bb16[2])
  _71 = std::ptr::const_ptr::<impl *const f64>::offset(move _72, move _73) -> bb17
  using: _72@Mir(bb16[1]), _73@Mir(bb16[3])
bb17:
  _70 = (*_71)
  using: _71@Mir(bb16[4])
  _64 = Sub(move _65, move _70)
  using: _65@Mir(bb16[0]), _70@Mir(bb17[0])
  _52 = Mul(move _53, move _64)
  using: _53@Mir(bb15[1]), _64@Mir(bb17[1])
  _0 = Add(_0, move _52)
  using: _52@Mir(bb17[2])
  goto -> bb18
  using: 
bb18:
  _75 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb18)
  assert(!move (_75.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb19
  using: _75@Entry, _3@Entry
bb19:
  _3 = move (_75.0: i32)
  using: _75@Mir(bb18[0])
  goto -> bb1
  using: 
bb20:
  return
  using: _0@Phi(bb18)
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:847:17: 847:35 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:847:53: 847:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:849:36: 849:54 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:849:62: 849:80 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:850:39: 850:57 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:850:65: 850:83 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:851:24: 851:42 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:851:60: 851:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:853:36: 853:54 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:853:62: 853:80 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/kdtree/src/kdtree.rs:854:39: 854:57 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/kdtree/src/kdtree.rs:854:65: 854:83 (#0) by default
@DefId(0:74 ~ lib[40c5]::src::kdtree::alloc_resnode)
bb0:
  _0 = const {0x0 as *mut src::kdtree::res_node}
  using: 
  _4 = const {alloc80: *mut src::kdtree::pthread_mutex_t}
  using: 
  _3 = &mut (*_4)
  using: _4@Mir(bb0[1])
  _2 = &raw mut (*_3)
  using: _3@Mir(bb0[2])
  _1 = src::kdtree::pthread_mutex_lock(move _2) -> bb1
  using: _2@Mir(bb0[3])
bb1:
  _7 = const {alloc81: *mut *mut src::kdtree::res_node}
  using: 
  _6 = (*_7)
  using: _7@Mir(bb1[0])
  _5 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _6) -> bb2
  using: _6@Mir(bb1[1])
bb2:
  switchInt(move _5) -> [0: bb6, otherwise: bb3]
  using: _5@Mir(bb1[2])
bb3:
  _11 = const {alloc81: *mut *mut src::kdtree::res_node}
  using: 
  _10 = (*_11)
  using: _11@Mir(bb3[0])
  _9 = move _10 as usize (PointerExposeAddress)
  using: _10@Mir(bb3[1])
  _8 = Eq(move _9, const 0_usize)
  using: _9@Mir(bb3[2])
  assume(move _8)
  using: _8@Mir(bb3[3])
  _14 = std::mem::size_of::<src::kdtree::res_node>() -> bb4
  using: 
bb4:
  _13 = move _14 as u64 (IntToInt)
  using: _14@Mir(bb3[5])
  _12 = src::kdtree::malloc(move _13) -> bb5
  using: _13@Mir(bb4[0])
bb5:
  _0 = move _12 as *mut src::kdtree::res_node (PtrToPtr)
  using: _12@Mir(bb4[1])
  goto -> bb7
  using: 
bb6:
  _16 = const {alloc81: *mut *mut src::kdtree::res_node}
  using: 
  _15 = (*_16)
  using: _16@Mir(bb6[0])
  _0 = move _15
  using: _15@Mir(bb6[1])
  _18 = const {alloc81: *mut *mut src::kdtree::res_node}
  using: 
  _24 = deref_copy (*_18)
  using: _18@Mir(bb6[3])
  _17 = ((*_24).2: *mut src::kdtree::res_node)
  using: _24@Mir(bb6[4])
  _19 = const {alloc81: *mut *mut src::kdtree::res_node}
  using: 
  (*_19) = move _17
  using: _19@Mir(bb6[6]), _17@Mir(bb6[5])
  ((*_0).2: *mut src::kdtree::res_node) = const 0_usize as *mut src::kdtree::res_node (PointerFromExposedAddress)
  using: _0@Mir(bb6[2])
  goto -> bb7
  using: 
bb7:
  _23 = const {alloc80: *mut src::kdtree::pthread_mutex_t}
  using: 
  _22 = &mut (*_23)
  using: _23@Mir(bb7[0])
  _21 = &raw mut (*_22)
  using: _22@Mir(bb7[1])
  _20 = src::kdtree::pthread_mutex_unlock(move _21) -> bb8
  using: _21@Mir(bb7[2])
bb8:
  return
  using: _0@Phi(bb7)
rewrite call src::kdtree::pthread_mutex_lock @ workspace/kdtree/src/kdtree.rs:886:5: 886:41 (#0) by default
rewrite call std::mem::size_of @ workspace/kdtree/src/kdtree.rs:888:23: 888:56 (#0) by default
rewrite call src::kdtree::pthread_mutex_unlock @ workspace/kdtree/src/kdtree.rs:895:5: 895:43 (#0) by default
@DefId(0:75 ~ lib[40c5]::src::kdtree::free_resnode)
bb0:
  _5 = const {alloc80: *mut src::kdtree::pthread_mutex_t}
  using: 
  _4 = &mut (*_5)
  using: _5@Mir(bb0[0])
  _3 = &raw mut (*_4)
  using: _4@Mir(bb0[1])
  _2 = src::kdtree::pthread_mutex_lock(move _3) -> bb1
  using: _3@Mir(bb0[2])
bb1:
  _7 = const {alloc81: *mut *mut src::kdtree::res_node}
  using: 
  _6 = (*_7)
  using: _7@Mir(bb1[0])
  ((*_1).2: *mut src::kdtree::res_node) = move _6
  using: _1@Entry, _6@Mir(bb1[1])
  _8 = _1
  using: _1@Entry
  _9 = const {alloc81: *mut *mut src::kdtree::res_node}
  using: 
  (*_9) = move _8
  using: _9@Mir(bb1[4]), _8@Mir(bb1[3])
  _13 = const {alloc80: *mut src::kdtree::pthread_mutex_t}
  using: 
  _12 = &mut (*_13)
  using: _13@Mir(bb1[6])
  _11 = &raw mut (*_12)
  using: _12@Mir(bb1[7])
  _10 = src::kdtree::pthread_mutex_unlock(move _11) -> bb2
  using: _11@Mir(bb1[8])
bb2:
  return
  using: _0@Entry
rewrite call src::kdtree::pthread_mutex_lock @ workspace/kdtree/src/kdtree.rs:899:5: 899:41 (#0) by default
rewrite call src::kdtree::pthread_mutex_unlock @ workspace/kdtree/src/kdtree.rs:902:5: 902:43 (#0) by default
@DefId(0:76 ~ lib[40c5]::src::kdtree::rlist_insert)
bb0:
  _4 = const {0x0 as *mut src::kdtree::res_node}
  using: 
  _5 = src::kdtree::alloc_resnode() -> bb1
  using: 
bb1:
  _4 = move _5
  using: _5@Mir(bb0[1])
  _7 = _4
  using: _4@Mir(bb1[0])
  _6 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _7) -> bb2
  using: _7@Mir(bb1[1])
bb2:
  switchInt(move _6) -> [0: bb4, otherwise: bb3]
  using: _6@Mir(bb1[2])
bb3:
  _10 = _4
  using: _4@Mir(bb1[0])
  _9 = move _10 as usize (PointerExposeAddress)
  using: _10@Mir(bb3[0])
  _8 = Eq(move _9, const 0_usize)
  using: _9@Mir(bb3[1])
  assume(move _8)
  using: _8@Mir(bb3[2])
  _0 = const -1_i32
  using: 
  goto -> bb12
  using: 
bb4:
  _11 = _2
  using: _2@Entry
  ((*_4).0: *mut src::kdtree::kdnode) = move _11
  using: _4@Mir(bb1[0]), _11@Mir(bb4[0])
  _12 = _3
  using: _3@Entry
  ((*_4).1: f64) = move _12
  using: _4@Mir(bb1[0]), _12@Mir(bb4[2])
  _14 = _3
  using: _3@Entry
  _13 = Ge(move _14, const 0f64)
  using: _14@Mir(bb4[4])
  switchInt(move _13) -> [0: bb11, otherwise: bb5]
  using: _13@Mir(bb4[5])
bb5:
  _18 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb5)
  _17 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _18) -> bb9
  using: _18@Mir(bb5[0])
bb6:
  _15 = const false
  using: 
  goto -> bb8
  using: 
bb7:
  _25 = deref_copy ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb5)
  _20 = ((*_25).1: f64)
  using: _25@Mir(bb7[0])
  _21 = _3
  using: _3@Phi(bb5)
  _19 = Lt(move _20, move _21)
  using: _20@Mir(bb7[1]), _21@Mir(bb7[2])
  _15 = move _19
  using: _19@Mir(bb7[3])
  goto -> bb8
  using: 
bb8:
  switchInt(move _15) -> [0: bb11, otherwise: bb10]
  using: _15@Phi(bb8)
bb9:
  _16 = Not(move _17)
  using: _17@Mir(bb5[1])
  switchInt(move _16) -> [0: bb6, otherwise: bb7]
  using: _16@Mir(bb9[0])
bb10:
  _22 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb8)
  _1 = move _22
  using: _22@Mir(bb10[0])
  goto -> bb5
  using: 
bb11:
  _23 = ((*_1).2: *mut src::kdtree::res_node)
  using: _1@Phi(bb11)
  ((*_4).2: *mut src::kdtree::res_node) = move _23
  using: _4@Mir(bb1[0]), _23@Mir(bb11[0])
  _24 = _4
  using: _4@Mir(bb1[0])
  ((*_1).2: *mut src::kdtree::res_node) = move _24
  using: _1@Phi(bb11), _24@Mir(bb11[2])
  _0 = const 0_i32
  using: 
  goto -> bb12
  using: 
bb12:
  return
  using: _0@Phi(bb12)
@DefId(0:77 ~ lib[40c5]::src::kdtree::clear_results)
bb0:
  _2 = const {0x0 as *mut src::kdtree::res_node}
  using: 
  _14 = deref_copy ((*_1).1: *mut src::kdtree::res_node)
  using: _1@Entry
  _3 = ((*_14).2: *mut src::kdtree::res_node)
  using: _14@Mir(bb0[1])
  goto -> bb1
  using: 
bb1:
  _6 = _3
  using: _3@Phi(bb1)
  _5 = std::ptr::mut_ptr::<impl *mut src::kdtree::res_node>::is_null(move _6) -> bb2
  using: _6@Mir(bb1[0])
bb2:
  _4 = Not(move _5)
  using: _5@Mir(bb1[1])
  switchInt(move _4) -> [0: bb4, otherwise: bb3]
  using: _4@Mir(bb2[0])
bb3:
  _7 = _3
  using: _3@Phi(bb1)
  _2 = move _7
  using: _7@Mir(bb3[0])
  _8 = ((*_3).2: *mut src::kdtree::res_node)
  using: _3@Phi(bb1)
  _3 = move _8
  using: _8@Mir(bb3[2])
  _10 = _2
  using: _2@Mir(bb3[1])
  _9 = src::kdtree::free_resnode(move _10) -> bb1
  using: _10@Mir(bb3[4])
bb4:
  _13 = _3
  using: _3@Phi(bb1)
  _12 = move _13 as usize (PointerExposeAddress)
  using: _13@Mir(bb4[0])
  _11 = Eq(move _12, const 0_usize)
  using: _12@Mir(bb4[1])
  assume(move _11)
  using: _11@Mir(bb4[2])
  _15 = deref_copy ((*_1).1: *mut src::kdtree::res_node)
  using: _1@Entry
  ((*_15).2: *mut src::kdtree::res_node) = const 0_usize as *mut src::kdtree::res_node (PointerFromExposedAddress)
  using: _15@Mir(bb4[4])
  return
  using: _0@Entry
use ::libc;
extern "C" {
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn fabs(_: libc::c_double) -> libc::c_double;
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
pub type size_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *const __pthread_internal_list,
    pub __next: *const __pthread_internal_list,
}
impl Default for __pthread_internal_list {fn default() -> Self {Self {
__prev: std::ptr::null_mut(),
__next: std::ptr::null_mut(),
}}}

pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
impl Default for __pthread_mutex_s {fn default() -> Self {Self {
__lock: Default::default(),
__count: Default::default(),
__owner: Default::default(),
__nusers: Default::default(),
__kind: Default::default(),
__spins: Default::default(),
__elision: Default::default(),
__list: Default::default(),
}}}

#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
struct ErasedByRefactorer0;
#[repr(C)]
pub struct kdtree {
    pub dim: libc::c_int,
    pub root: Option<Box<kdnode>>,
    pub rect: Option<Box<kdhyperrect>>,
    pub destr: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
}
impl Default for kdtree {fn default() -> Self {Self {
dim: Default::default(),
root: None,
rect: None,
destr: Default::default(),
}}}
impl kdtree {pub fn take(&mut self) -> Self {core::mem::take(self)}}

#[derive(Copy, Clone)]
#[repr(C)]
struct ErasedByRefactorer1;
#[repr(C)]
pub struct kdhyperrect {
    pub dim: libc::c_int,
    pub min: *mut /* owning */ libc::c_double,
    pub max: *mut /* owning */ libc::c_double,
}
impl Default for kdhyperrect {fn default() -> Self {Self {
dim: Default::default(),
min: std::ptr::null_mut(),
max: std::ptr::null_mut(),
}}}
impl kdhyperrect {pub fn take(&mut self) -> Self {core::mem::take(self)}}

#[derive(Copy, Clone)]
#[repr(C)]
struct ErasedByRefactorer2;
#[repr(C)]
pub struct kdnode {
    pub pos: *mut /* owning */ libc::c_double,
    pub dir: libc::c_int,
    pub data: *mut libc::c_void,
    pub left: Option<Box<kdnode>>,
    pub right: Option<Box<kdnode>>,
}
impl Default for kdnode {fn default() -> Self {Self {
pos: std::ptr::null_mut(),
dir: Default::default(),
data: std::ptr::null_mut(),
left: None,
right: None,
}}}
impl kdnode {pub fn take(&mut self) -> Self {core::mem::take(self)}}

#[derive(Copy, Clone)]
#[repr(C)]
struct ErasedByRefactorer3;
#[repr(C)]
pub struct kdres {
    pub tree: *const kdtree,
    pub rlist: *mut /* owning */ res_node,
    pub riter: *const res_node,
    pub size: libc::c_int,
}
impl Default for kdres {fn default() -> Self {Self {
tree: std::ptr::null_mut(),
rlist: std::ptr::null_mut(),
riter: std::ptr::null_mut(),
size: Default::default(),
}}}
impl kdres {pub fn take(&mut self) -> Self {core::mem::take(self)}}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct res_node {
    pub item: *const kdnode,
    pub dist_sq: libc::c_double,
    pub next: *mut res_node,
}
impl Default for res_node {fn default() -> Self {Self {
item: std::ptr::null_mut(),
dist_sq: Default::default(),
next: std::ptr::null_mut(),
}}}

#[no_mangle]
pub unsafe extern "C" fn kd_create(mut k: libc::c_int) -> Option<Box<kdtree>> {
    let mut tree = None;
    tree= Some(Box::new(<crate::src::kdtree::kdtree as Default>::default()));
    if tree.as_deref().is_none() {();
        return None;
    }
    (*tree.as_deref_mut().unwrap()).dim= k;
    (*tree.as_deref_mut().unwrap()).root= None;
    (*tree.as_deref_mut().unwrap()).destr= None;
    (*tree.as_deref_mut().unwrap()).rect= None;
    return tree;
}
#[no_mangle]
pub unsafe extern "C" fn kd_free(mut tree: Option<Box<kdtree>>) {
    if !tree.as_deref().is_none() {
        kd_clear(tree.as_deref_mut());
        ();
    }else { (); }
}
unsafe extern "C" fn clear_rec(
    mut node: Option<Box<kdnode>>,
    mut destr: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    if node.as_deref().is_none() {();
        return;
    }
    clear_rec((*node.as_deref_mut().unwrap()).left.take(), destr);
    clear_rec((*node.as_deref_mut().unwrap()).right.take(), destr);
    if destr.is_some() {
        destr.expect("non-null function pointer")((*node).data);
    }
    free((*node.as_deref().unwrap()).pos as *mut libc::c_void);
    ();
}
#[no_mangle]
pub unsafe extern "C" fn kd_clear(mut tree: Option<&mut kdtree>) {
    clear_rec((*tree.as_deref_mut().unwrap()).root.take(), (*tree.as_deref().unwrap()).destr);
    (*tree.as_deref_mut().unwrap()).root= None;
    if !(*tree.as_deref().unwrap()).rect.as_deref().is_none() {
        hyperrect_free((*tree.as_deref_mut().unwrap()).rect.take());
        (*tree.as_deref_mut().unwrap()).rect= None;
    }else { (); }
}
#[no_mangle]
pub unsafe extern "C" fn kd_data_destructor(
    mut tree: Option<&mut kdtree>,
    mut destr: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    (*tree.as_deref_mut().unwrap()).destr= destr;
}
unsafe extern "C" fn insert_rec(
    mut nptr: *mut *mut kdnode,
    mut pos: *const libc::c_double,
    mut data: *mut libc::c_void,
    mut dir: libc::c_int,
    mut dim: libc::c_int,
) -> libc::c_int {
    let mut new_dir: libc::c_int = 0;
    let mut node = None;
    if (*nptr).is_null() {();
        node= Some(Box::new(<crate::src::kdtree::kdnode as Default>::default()));
        if node.as_deref().is_none() {();
            return -(1 as libc::c_int);
        }
        (*node.as_deref_mut().unwrap()).pos= malloc(
            (dim as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_double>() as libc::c_ulong),
        ) as *mut libc::c_double;
        if (*node.as_deref().unwrap()).pos.is_null() {();
            ();
            return -(1 as libc::c_int);
        }
        memcpy(
            (*node.as_deref().unwrap()).pos as *mut libc::c_void,
            pos as *const libc::c_void,
            (dim as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_double>() as libc::c_ulong),
        );
        (*node.as_deref_mut().unwrap()).data= data;
        (*node.as_deref_mut().unwrap()).dir= dir;
        (*node.as_deref_mut().unwrap()).right= None; (*node.as_deref_mut().unwrap()).left= (*node.as_deref_mut().unwrap()).right.take();
        *nptr= core::mem::transmute::<_, *mut crate::src::kdtree::kdnode>(node.as_deref_mut());
        return 0 as libc::c_int;
    }
    node= Some(Box::from_raw((*nptr)));
    new_dir= ((*node).dir + 1 as libc::c_int) % dim;
    if *pos.offset((*node.as_deref().unwrap()).dir as isize) < *(*node.as_deref().unwrap()).pos.offset((*node.as_deref().unwrap()).dir as isize) {
        return insert_rec(&mut (**nptr).left, pos, data, new_dir, dim);
    }
    return insert_rec(&mut (**nptr).right, pos, data, new_dir, dim);
}
#[no_mangle]
pub unsafe extern "C" fn kd_insert(
    mut tree: *mut kdtree,
    mut pos: *const libc::c_double,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    if insert_rec(&mut (*tree).root, pos, data, 0 as libc::c_int, (*tree).dim) != 0 {
        return -(1 as libc::c_int);
    }
    if (*tree).rect.as_deref().is_none() {();
        (*tree).rect= hyperrect_create((*tree).dim, pos, pos);
    } else {
        hyperrect_extend((*tree).rect.as_deref_mut(), pos);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn kd_insertf(
    mut tree: *mut kdtree,
    mut pos: *const libc::c_float,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    static mut sbuf: [libc::c_double; 16] = [0.; 16];
    let mut bptr = 0 as *mut libc::c_double;
    let mut buf = 0 as *mut libc::c_double;
    let mut res: libc::c_int = 0;
    let mut dim = (*tree).dim;
    if dim > 16 as libc::c_int {
        if dim <= 256 as libc::c_int {
            // let mut fresh11 = ::std::vec::from_elem(
            //     0,
            //     (dim as libc::c_ulong)
            //         .wrapping_mul(
            //             ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
            //         ) as usize,
            // );
            // buf = fresh11.as_mut_ptr() as *mut libc::c_double;
            // bptr = buf;
            buf= malloc(
                (dim as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    ),
            ) as *mut libc::c_double;
            bptr= buf;
            if bptr.is_null() {();
                return -(1 as libc::c_int);
            }
        } else {
            buf= malloc(
                (dim as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    ),
            ) as *mut libc::c_double;
            bptr= buf;
            if bptr.is_null() {();
                return -(1 as libc::c_int);
            }
        }
    } else {
        buf= sbuf.as_mut_ptr();
        bptr= buf;
    }
    loop {
        let fresh12 = dim;
        dim= dim - 1;
        if !(fresh12 > 0 as libc::c_int) {
            break;
        }
        let fresh13 = pos;
        pos= pos.offset(1);
        let fresh14 = bptr;
        bptr= bptr.offset(1);
        *fresh14= (*fresh13) as libc::c_double;
    }
    res= kd_insert(tree, buf, data);
    if (*tree).dim > 256 as libc::c_int {
        free(buf as *mut libc::c_void);
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn kd_insert3(
    mut tree: *mut kdtree,
    mut x: libc::c_double,
    mut y: libc::c_double,
    mut z: libc::c_double,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    let mut buf: [libc::c_double; 3] = [0.; 3];
    buf[0 as libc::c_int as usize] = x;
    buf[1 as libc::c_int as usize] = y;
    buf[2 as libc::c_int as usize] = z;
    return kd_insert(tree, buf.as_mut_ptr(), data);
}
#[no_mangle]
pub unsafe extern "C" fn kd_insert3f(
    mut tree: *mut kdtree,
    mut x: libc::c_float,
    mut y: libc::c_float,
    mut z: libc::c_float,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    let mut buf: [libc::c_double; 3] = [0.; 3];
    buf[0 as libc::c_int as usize] = x as libc::c_double;
    buf[1 as libc::c_int as usize] = y as libc::c_double;
    buf[2 as libc::c_int as usize] = z as libc::c_double;
    return kd_insert(tree, buf.as_mut_ptr(), data);
}
unsafe extern "C" fn find_nearest(
    mut node: *const kdnode,
    mut pos: *const libc::c_double,
    mut range: libc::c_double,
    mut list: Option<&mut res_node>,
    mut ordered: libc::c_int,
    mut dim: libc::c_int,
) -> libc::c_int {
    let mut dist_sq: libc::c_double = 0.;
    let mut dx: libc::c_double = 0.;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut added_res = 0 as libc::c_int;
    if node.is_null() {();
        return 0 as libc::c_int;
    }
    dist_sq= 0 as libc::c_int as libc::c_double;
    i= 0 as libc::c_int;
    while i < dim {
        dist_sq+= (*(*node).pos.offset(i as isize) - *pos.offset(i as isize))
                * (*(*node).pos.offset(i as isize) - *pos.offset(i as isize));
        i+= 1;
    }
    if dist_sq <= range * range {
        if rlist_insert(core::mem::transmute::<_, *mut crate::src::kdtree::res_node>(list.as_deref_mut()), node, (if ordered != 0 { dist_sq } else { -1.0f64 }))
            == -(1 as libc::c_int)
        {
            return -(1 as libc::c_int);
        }
        added_res= 1 as libc::c_int;
    }
    dx= *pos.offset((*node).dir as isize) - *(*node).pos.offset((*node).dir as isize);
    ret= find_nearest(
        if dx <= 0.0f64 { core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*node).left.as_deref()) } else { core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*node).right.as_deref()) },
        pos,
        range,
        list.as_deref_mut(),
        ordered,
        dim,
    );
    if ret >= 0 as libc::c_int && fabs(dx) < range {
        added_res+= ret;
        ret= find_nearest(
            if dx <= 0.0f64 { core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*node).right.as_deref()) } else { core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*node).left.as_deref()) },
            pos,
            range,
            list.as_deref_mut(),
            ordered,
            dim,
        );
    }
    if ret == -(1 as libc::c_int) {
        return -(1 as libc::c_int);
    }
    added_res+= ret;
    return added_res;
}
unsafe extern "C" fn kd_nearest_i(
    mut node: *const kdnode,
    mut pos: *const libc::c_double,
    mut result: Option<&mut *const kdnode>,
    mut result_dist_sq: Option<&mut libc::c_double>,
    mut rect: *mut kdhyperrect,
) {
    let mut dir = (*node).dir;
    let mut i: libc::c_int = 0;
    let mut dummy: libc::c_double = 0.;
    let mut dist_sq: libc::c_double = 0.;
    let mut nearer_subtree = 0 as *mut kdnode;
    let mut farther_subtree = 0 as *mut kdnode;
    let mut nearer_hyperrect_coord = 0 as *mut libc::c_double;
    let mut farther_hyperrect_coord = 0 as *mut libc::c_double;
    dummy= *pos.offset(dir as isize) - *(*node).pos.offset(dir as isize);
    if dummy <= 0 as libc::c_int as libc::c_double {
        nearer_subtree= core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*node).left.as_deref());
        farther_subtree= core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*node).right.as_deref());
        nearer_hyperrect_coord= (*rect).max.offset(dir as isize);
        farther_hyperrect_coord= (*rect).min.offset(dir as isize);
    } else {
        nearer_subtree= core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*node).right.as_deref());
        farther_subtree= core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*node).left.as_deref());
        nearer_hyperrect_coord= (*rect).min.offset(dir as isize);
        farther_hyperrect_coord= (*rect).max.offset(dir as isize);
    }
    if !nearer_subtree.is_null() {
        dummy= (*nearer_hyperrect_coord);
        *nearer_hyperrect_coord= *(*node).pos.offset(dir as isize);
        kd_nearest_i(nearer_subtree, pos, result.as_deref_mut(), result_dist_sq.as_deref_mut(), rect);
        *nearer_hyperrect_coord= dummy;
    }else { (); }
    dist_sq= 0 as libc::c_int as libc::c_double;
    i= 0 as libc::c_int;
    while i < (*rect).dim {
        dist_sq+= (*(*node).pos.offset(i as isize) - *pos.offset(i as isize))
                * (*(*node).pos.offset(i as isize) - *pos.offset(i as isize));
        i+= 1;
    }
    if dist_sq < (*result_dist_sq.as_deref().unwrap()) {
        *result.as_deref_mut().unwrap()= node;
        *result_dist_sq.as_deref_mut().unwrap()= dist_sq;
    }
    if !farther_subtree.is_null() {
        dummy= (*farther_hyperrect_coord);
        *farther_hyperrect_coord= *(*node).pos.offset(dir as isize);
        if hyperrect_dist_sq(rect, pos) < (*result_dist_sq.as_deref().unwrap()) {
            kd_nearest_i(farther_subtree, pos, result.as_deref_mut(), result_dist_sq.as_deref_mut(), rect);
        }
        *farther_hyperrect_coord= dummy;
    }else { (); }
}
#[no_mangle]
pub unsafe extern "C" fn kd_nearest(
    mut kd: *const kdtree,
    mut pos: *const libc::c_double,
) -> Option<Box<kdres>> {
    let mut rect = None;
    let mut result = 0 as *mut kdnode;
    let mut rset = None;
    let mut dist_sq: libc::c_double = 0.;
    let mut i: libc::c_int = 0;
    if kd.is_null() {();
        return None;
    }
    if (*kd).rect.as_deref().is_none() {();
        return None;
    }
    rset= Some(Box::new(<crate::src::kdtree::kdres as Default>::default()));
    if rset.as_deref().is_none() {();
        return None;
    }
    (*rset.as_deref_mut().unwrap()).rlist= alloc_resnode();
    if (*rset.as_deref().unwrap()).rlist.is_null() {();
        ();
        return None;
    }
    (*(*rset.as_deref_mut().unwrap()).rlist).next= 0 as *mut res_node;
    (*rset.as_deref_mut().unwrap()).tree= kd;
    rect= hyperrect_duplicate(core::mem::transmute::<_, *const crate::src::kdtree::kdhyperrect>((*kd).rect.as_deref()));
    if rect.as_deref().is_none() {();
        kd_res_free(rset);
        return None;
    }
    result= core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*kd).root.as_deref());
    dist_sq= 0 as libc::c_int as libc::c_double;
    i= 0 as libc::c_int;
    while i < (*kd).dim {
        dist_sq+= (*(*result).pos.offset(i as isize) - *pos.offset(i as isize))
                * (*(*result).pos.offset(i as isize) - *pos.offset(i as isize));
        i+= 1;
    }
    kd_nearest_i(core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*kd).root.as_deref()), pos, &mut result, &mut dist_sq, core::mem::transmute::<_, *mut crate::src::kdtree::kdhyperrect>(rect.as_deref_mut()));
    hyperrect_free(rect);
    if !result.is_null() {
        if rlist_insert((*rset.as_deref().unwrap()).rlist, result, -1.0f64) == -(1 as libc::c_int) {
            kd_res_free(rset);
            return None;
        }
        (*rset.as_deref_mut().unwrap()).size= 1 as libc::c_int;
        kd_res_rewind(rset.as_deref_mut());
        return rset;
    } else {();
        kd_res_free(rset);
        return None;
    };
}
#[no_mangle]
pub unsafe extern "C" fn kd_nearestf(
    mut tree: *const kdtree,
    mut pos: *const libc::c_float,
) -> *const kdres {
    static mut sbuf: [libc::c_double; 16] = [0.; 16];
    let mut bptr = 0 as *mut libc::c_double;
    let mut buf = 0 as *mut libc::c_double;
    let mut dim = (*tree).dim;
    let mut res = 0 as *mut kdres;
    if dim > 16 as libc::c_int {
        if dim <= 256 as libc::c_int {
            // let mut fresh18 = ::std::vec::from_elem(
            //     0,
            //     (dim as libc::c_ulong)
            //         .wrapping_mul(
            //             ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
            //         ) as usize,
            // );
            // buf = fresh18.as_mut_ptr() as *mut libc::c_double;
            // bptr = buf;
            buf= malloc(
                (dim as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    ),
            ) as *mut libc::c_double;
            bptr= buf;
            if bptr.is_null() {();
                return 0 as *mut kdres;
            }
        } else {
            buf= malloc(
                (dim as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    ),
            ) as *mut libc::c_double;
            bptr= buf;
            if bptr.is_null() {();
                return 0 as *mut kdres;
            }
        }
    } else {
        buf= sbuf.as_mut_ptr();
        bptr= buf;
    }
    loop {
        let fresh19 = dim;
        dim= dim - 1;
        if !(fresh19 > 0 as libc::c_int) {
            break;
        }
        let fresh20 = pos;
        pos= pos.offset(1);
        let fresh21 = bptr;
        bptr= bptr.offset(1);
        *fresh21= (*fresh20) as libc::c_double;
    }
    res= kd_nearest(tree, buf);
    if (*tree).dim > 256 as libc::c_int {
        free(buf as *mut libc::c_void);
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn kd_nearest3(
    mut tree: *const kdtree,
    mut x: libc::c_double,
    mut y: libc::c_double,
    mut z: libc::c_double,
) -> Option<Box<kdres>> {
    let mut pos: [libc::c_double; 3] = [0.; 3];
    pos[0 as libc::c_int as usize] = x;
    pos[1 as libc::c_int as usize] = y;
    pos[2 as libc::c_int as usize] = z;
    return kd_nearest(tree, pos.as_mut_ptr());
}
#[no_mangle]
pub unsafe extern "C" fn kd_nearest3f(
    mut tree: *const kdtree,
    mut x: libc::c_float,
    mut y: libc::c_float,
    mut z: libc::c_float,
) -> Option<Box<kdres>> {
    let mut pos: [libc::c_double; 3] = [0.; 3];
    pos[0 as libc::c_int as usize] = x as libc::c_double;
    pos[1 as libc::c_int as usize] = y as libc::c_double;
    pos[2 as libc::c_int as usize] = z as libc::c_double;
    return kd_nearest(tree, pos.as_mut_ptr());
}
#[no_mangle]
pub unsafe extern "C" fn kd_nearest_range(
    mut kd: *const kdtree,
    mut pos: *const libc::c_double,
    mut range: libc::c_double,
) -> Option<Box<kdres>> {
    let mut ret: libc::c_int = 0;
    let mut rset = None;
    rset= Some(Box::new(<crate::src::kdtree::kdres as Default>::default()));
    if rset.as_deref().is_none() {();
        return None;
    }
    (*rset.as_deref_mut().unwrap()).rlist= alloc_resnode();
    if (*rset.as_deref().unwrap()).rlist.is_null() {();
        ();
        return None;
    }
    (*(*rset.as_deref_mut().unwrap()).rlist).next= 0 as *mut res_node;
    (*rset.as_deref_mut().unwrap()).tree= kd;
    ret= find_nearest(
        core::mem::transmute::<_, *const crate::src::kdtree::kdnode>((*kd).root.as_deref()),
        pos,
        range,
        (*rset.as_deref_mut().unwrap()).rlist.as_mut(),
        0 as libc::c_int,
        (*kd).dim,
    );
    if ret == -(1 as libc::c_int) {
        kd_res_free(rset);
        return None;
    }
    (*rset.as_deref_mut().unwrap()).size= ret;
    kd_res_rewind(rset.as_deref_mut());
    return rset;
}
#[no_mangle]
pub unsafe extern "C" fn kd_nearest_rangef(
    mut kd: *const kdtree,
    mut pos: *const libc::c_float,
    mut range: libc::c_float,
) -> *const kdres {
    static mut sbuf: [libc::c_double; 16] = [0.; 16];
    let mut bptr = 0 as *mut libc::c_double;
    let mut buf = 0 as *mut libc::c_double;
    let mut dim = (*kd).dim;
    let mut res = 0 as *mut kdres;
    if dim > 16 as libc::c_int {
        if dim <= 256 as libc::c_int {
            // let mut fresh25 = ::std::vec::from_elem(
            //     0,
            //     (dim as libc::c_ulong)
            //         .wrapping_mul(
            //             ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
            //         ) as usize,
            // );
            // buf = fresh25.as_mut_ptr() as *mut libc::c_double;
            // bptr = buf;
            buf= malloc(
                (dim as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    ),
            ) as *mut libc::c_double;
            bptr= buf;
            if bptr.is_null() {();
                return 0 as *mut kdres;
            }
        } else {
            buf= malloc(
                (dim as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    ),
            ) as *mut libc::c_double;
            bptr= buf;
            if bptr.is_null() {();
                return 0 as *mut kdres;
            }
        }
    } else {
        buf= sbuf.as_mut_ptr();
        bptr= buf;
    }
    loop {
        let fresh26 = dim;
        dim= dim - 1;
        if !(fresh26 > 0 as libc::c_int) {
            break;
        }
        let fresh27 = pos;
        pos= pos.offset(1);
        let fresh28 = bptr;
        bptr= bptr.offset(1);
        *fresh28= (*fresh27) as libc::c_double;
    }
    res= kd_nearest_range(kd, buf, range as libc::c_double);
    if (*kd).dim > 256 as libc::c_int {
        free(buf as *mut libc::c_void);
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn kd_nearest_range3(
    mut tree: *const kdtree,
    mut x: libc::c_double,
    mut y: libc::c_double,
    mut z: libc::c_double,
    mut range: libc::c_double,
) -> Option<Box<kdres>> {
    let mut buf: [libc::c_double; 3] = [0.; 3];
    buf[0 as libc::c_int as usize] = x;
    buf[1 as libc::c_int as usize] = y;
    buf[2 as libc::c_int as usize] = z;
    return kd_nearest_range(tree, buf.as_mut_ptr(), range);
}
#[no_mangle]
pub unsafe extern "C" fn kd_nearest_range3f(
    mut tree: *const kdtree,
    mut x: libc::c_float,
    mut y: libc::c_float,
    mut z: libc::c_float,
    mut range: libc::c_float,
) -> Option<Box<kdres>> {
    let mut buf: [libc::c_double; 3] = [0.; 3];
    buf[0 as libc::c_int as usize] = x as libc::c_double;
    buf[1 as libc::c_int as usize] = y as libc::c_double;
    buf[2 as libc::c_int as usize] = z as libc::c_double;
    return kd_nearest_range(tree, buf.as_mut_ptr(), range as libc::c_double);
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_free(mut rset: Option<Box<kdres>>) {
    clear_results(rset.as_deref_mut());
    free_resnode((*rset.as_deref().unwrap()).rlist);
    ();
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_size(mut set: *const kdres) -> libc::c_int {
    return (*set).size;
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_rewind(mut rset: Option<&mut kdres>) {
    (*rset.as_deref_mut().unwrap()).riter= (*(*rset.as_deref().unwrap()).rlist).next;
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_end(mut rset: *const kdres) -> libc::c_int {
    return ((*rset).riter == 0 as *mut res_node) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_next(mut rset: Option<&mut kdres>) -> libc::c_int {
    (*rset.as_deref_mut().unwrap()).riter= (*(*rset.as_deref().unwrap()).riter).next;
    return ((*rset.as_deref().unwrap()).riter != 0 as *mut res_node) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_item(
    mut rset: *const kdres,
    mut pos: *mut libc::c_double,
) -> *const libc::c_void {
    if !(*rset).riter.is_null() {
        if !pos.is_null() {
            memcpy(
                pos as *mut libc::c_void,
                (*(*(*rset).riter).item).pos as *const f64 as *const libc::c_void,
                ((*(*rset).tree).dim as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    ),
            );
        }else { (); }
        return (*(*(*rset).riter).item).data;
    }else { (); }
    return 0 as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_itemf(
    mut rset: *const kdres,
    mut pos: *mut libc::c_float,
) -> *const libc::c_void {
    if !(*rset).riter.is_null() {
        if !pos.is_null() {
            let mut i: libc::c_int = 0;
            i= 0 as libc::c_int;
            while i < (*(*rset).tree).dim {
                *pos
                    .offset(
                        i as isize,
                    ) = *(*(*(*rset).riter).item).pos.offset(i as isize)
                    as libc::c_float;
                i+= 1;
            }
        }else { (); }
        return (*(*(*rset).riter).item).data;
    }else { (); }
    return 0 as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_item3(
    mut rset: *const kdres,
    mut x: Option<&mut libc::c_double>,
    mut y: Option<&mut libc::c_double>,
    mut z: Option<&mut libc::c_double>,
) -> *const libc::c_void {
    if !(*rset).riter.is_null() {
        if !x.as_deref().is_none() {
            *x.as_deref_mut().unwrap()= *(*(*(*rset).riter).item).pos.offset(0 as libc::c_int as isize);
        }else { (); }
        if !y.as_deref().is_none() {
            *y.as_deref_mut().unwrap()= *(*(*(*rset).riter).item).pos.offset(1 as libc::c_int as isize);
        }else { (); }
        if !z.as_deref().is_none() {
            *z.as_deref_mut().unwrap()= *(*(*(*rset).riter).item).pos.offset(2 as libc::c_int as isize);
        }else { (); }
        return (*(*(*rset).riter).item).data;
    }else { (); }
    return 0 as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_item3f(
    mut rset: *const kdres,
    mut x: Option<&mut libc::c_float>,
    mut y: Option<&mut libc::c_float>,
    mut z: Option<&mut libc::c_float>,
) -> *const libc::c_void {
    if !(*rset).riter.is_null() {
        if !x.as_deref().is_none() {
            *x.as_deref_mut().unwrap()= *(*(*(*rset).riter).item).pos.offset(0 as libc::c_int as isize)
                as libc::c_float;
        }else { (); }
        if !y.as_deref().is_none() {
            *y.as_deref_mut().unwrap()= *(*(*(*rset).riter).item).pos.offset(1 as libc::c_int as isize)
                as libc::c_float;
        }else { (); }
        if !z.as_deref().is_none() {
            *z.as_deref_mut().unwrap()= *(*(*(*rset).riter).item).pos.offset(2 as libc::c_int as isize)
                as libc::c_float;
        }else { (); }
        return (*(*(*rset).riter).item).data;
    }else { (); }
    return 0 as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn kd_res_item_data(mut set: *const kdres) -> *const libc::c_void {
    return kd_res_item(set, 0 as *mut libc::c_double);
}
unsafe extern "C" fn hyperrect_create(
    mut dim: libc::c_int,
    mut min: *const libc::c_double,
    mut max: *const libc::c_double,
) -> Option<Box<kdhyperrect>> {
    let mut size = (dim as libc::c_ulong)
        .wrapping_mul(::std::mem::size_of::<libc::c_double>() as libc::c_ulong);
    let mut rect = None;
    rect= Some(Box::new(<crate::src::kdtree::kdhyperrect as Default>::default()));
    if rect.as_deref().is_none() {();
        return None;
    }
    (*rect.as_deref_mut().unwrap()).dim= dim;
    (*rect.as_deref_mut().unwrap()).min= malloc(size) as *mut libc::c_double;
    if (*rect.as_deref().unwrap()).min.is_null() {();
        ();
        return None;
    }
    (*rect.as_deref_mut().unwrap()).max= malloc(size) as *mut libc::c_double;
    if (*rect.as_deref().unwrap()).max.is_null() {();
        free((*rect.as_deref().unwrap()).min as *mut libc::c_void);
        ();
        return None;
    }
    memcpy((*rect.as_deref().unwrap()).min as *mut libc::c_void, min as *const libc::c_void, size);
    memcpy((*rect.as_deref().unwrap()).max as *mut libc::c_void, max as *const libc::c_void, size);
    return rect;
}
unsafe extern "C" fn hyperrect_free(mut rect: Option<Box<kdhyperrect>>) {
    free((*rect.as_deref().unwrap()).min as *mut libc::c_void);
    free((*rect.as_deref().unwrap()).max as *mut libc::c_void);
    ();
}
unsafe extern "C" fn hyperrect_duplicate(
    mut rect: *const kdhyperrect,
) -> Option<Box<kdhyperrect>> {
    return hyperrect_create((*rect).dim, (*rect).min as *const f64, (*rect).max as *const f64);
}
unsafe extern "C" fn hyperrect_extend(
    mut rect: Option<&mut kdhyperrect>,
    mut pos: *const libc::c_double,
) {
    let mut i: libc::c_int = 0;
    i= 0 as libc::c_int;
    while i < (*rect.as_deref().unwrap()).dim {
        if *pos.offset(i as isize) < *(*rect.as_deref().unwrap()).min.offset(i as isize) {
            *(*rect.as_deref().unwrap()).min.offset(i as isize) = *pos.offset(i as isize);
        }
        if *pos.offset(i as isize) > *(*rect.as_deref().unwrap()).max.offset(i as isize) {
            *(*rect.as_deref().unwrap()).max.offset(i as isize) = *pos.offset(i as isize);
        }
        i+= 1;
    }
}
unsafe extern "C" fn hyperrect_dist_sq(
    mut rect: *const kdhyperrect,
    mut pos: *const libc::c_double,
) -> libc::c_double {
    let mut i: libc::c_int = 0;
    let mut result = 0 as libc::c_int as libc::c_double;
    i= 0 as libc::c_int;
    while i < (*rect).dim {
        if *pos.offset(i as isize) < *(*rect).min.offset(i as isize) {
            result+= (*(*rect).min.offset(i as isize) - *pos.offset(i as isize))
                    * (*(*rect).min.offset(i as isize) - *pos.offset(i as isize));
        } else if *pos.offset(i as isize) > *(*rect).max.offset(i as isize) {
            result+= (*(*rect).max.offset(i as isize) - *pos.offset(i as isize))
                    * (*(*rect).max.offset(i as isize) - *pos.offset(i as isize));
        }
        i+= 1;
    }
    return result;
}
static mut free_nodes: *mut res_node = 0 as *const res_node as *mut res_node;
static mut alloc_mutex: pthread_mutex_t = pthread_mutex_t {
    __data: {
        let mut init = __pthread_mutex_s {
            __lock: 0 as libc::c_int,
            __count: 0 as libc::c_int as libc::c_uint,
            __owner: 0 as libc::c_int,
            __nusers: 0 as libc::c_int as libc::c_uint,
            __kind: 0 as libc::c_int,
            __spins: 0 as libc::c_int as libc::c_short,
            __elision: 0 as libc::c_int as libc::c_short,
            __list: {
                let mut init = __pthread_internal_list {
                    __prev: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                };
                init
            },
        };
        init
    },
};
unsafe extern "C" fn alloc_resnode() -> Option<Box<res_node>> {
    let mut node = None;
    pthread_mutex_lock(&mut alloc_mutex);
    if free_nodes.is_null() {();
        node= Some(Box::new(<crate::src::kdtree::res_node as Default>::default()));
    } else {
        node= free_nodes;
        free_nodes = (*free_nodes).next;
        (*node.as_deref_mut().unwrap()).next= 0 as *mut res_node;
    }
    pthread_mutex_unlock(&mut alloc_mutex);
    return node;
}
unsafe extern "C" fn free_resnode(mut node: *mut res_node) {
    pthread_mutex_lock(&mut alloc_mutex);
    (*node).next= free_nodes;
    free_nodes = node;
    pthread_mutex_unlock(&mut alloc_mutex);
}
unsafe extern "C" fn rlist_insert(
    mut list: *mut res_node,
    mut item: *const kdnode,
    mut dist_sq: libc::c_double,
) -> libc::c_int {
    let mut rnode = None;
    rnode= alloc_resnode();
    if rnode.as_deref().is_none() {();
        return -(1 as libc::c_int);
    }
    (*rnode.as_deref_mut().unwrap()).item= item;
    (*rnode.as_deref_mut().unwrap()).dist_sq= dist_sq;
    if dist_sq >= 0.0f64 {
        while !(*list).next.is_null() && (*(*list).next).dist_sq < dist_sq {
            list= (*list).next;
        }
    }
    (*rnode.as_deref_mut().unwrap()).next= (*list).next;
    (*list).next= core::mem::transmute::<_, *mut crate::src::kdtree::res_node>(rnode.as_deref_mut());
    return 0 as libc::c_int;
}
unsafe extern "C" fn clear_results(mut rset: Option<&mut kdres>) {
    let mut tmp = 0 as *mut res_node;
    let mut node = (*(*rset.as_deref().unwrap()).rlist).next;
    while !node.is_null() {
        tmp= node;
        node= (*node).next;
        free_resnode(tmp);
    }();
    (*(*rset.as_deref_mut().unwrap()).rlist).next= 0 as *mut res_node;
}
